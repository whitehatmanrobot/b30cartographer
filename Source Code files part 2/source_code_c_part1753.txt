            <bndtrn.h>
#include                <bndrel.h>
#include                <newexe.h>
#if EXE386
#include                <exe386.h>
#endif
#if SETVBUF
#include                <lnkio.h>
#endif
#if OXOUT OR OIAPX286
#include                <xenfmt.h>
#endif
#include                <extern.h>

/* Variables shared regardless of executable format */

char FAR                *lpszLink;
char FAR                *lpszPath;
char FAR                *lpszTMP;
char FAR                *lpszLIB;
char FAR                *lpszQH;
char FAR                *lpszHELPFILES;
char FAR                *lpszCmdLine;
#if OSEGEXE
RBTYPE                  procOrder;
#endif
int                     vmfd;
BSTYPE                  bsErr /* DLH stderr isn't constant with CRT DLL */ /* = stderr */;
BSTYPE                  bsInput;
BSTYPE                  bsLst;
BSTYPE                  bsRunfile;
WORD                    cbBakpat;
WORD                    cbRec;
WORD                    cErrors;
int                     (cdecl *cmpf)(const RBTYPE *sb1, const RBTYPE *sb2);
#if OMF386
FTYPE                   f386;
#endif
#if (OSEGEXE AND defined(LEGO)) OR EXE386
FTYPE                   fKeepFixups;
#endif
#if EXE386
GRTYPE                  ggrFlat;
FTYPE                   fFullMap;
FTYPE                   fKeepVSize;
#endif
WORD                    extMac;
WORD                    extMax;
int                     ExitCode=0;
FTYPE                   fFullMap;
FTYPE                   fCommon;
#if C8_IDE
FTYPE                   fC8IDE = FALSE;
#endif
FTYPE                   fDelexe = (FTYPE) FALSE;
FTYPE                   fDrivePass;
FTYPE                   fFarCallTrans;
FTYPE                   fIgnoreCase = (FTYPE) IGNORECASE;
FTYPE                   fInOverlay;
FTYPE                   fLibPass;
FTYPE                   fLibraryFile;
FTYPE                   fListAddrOnly;
FTYPE                   fLstFileOpen;
FTYPE                   fScrClosed = (FTYPE) TRUE;
FTYPE                   fUndefinedExterns;
FTYPE                   fExeStrSeen = FALSE;
FTYPE                   fPackFunctions = (FTYPE) TRUE;
#if TCE
FTYPE                   fTCE = FALSE;
#endif
FTYPE                   fTextMoved = (FTYPE) FALSE;
int                     NullDelta = 16;
#if O68K
FTYPE                   f68k = (FTYPE) FALSE;
FTYPE                   fTBigEndian = (FTYPE) FALSE;
BYTE                    iMacType = MAC_NONE;
#endif /* O68K */
GRTYPE                  ggrDGroup;
GRTYPE                  ggrMac =        1;
GRTYPE                  grMac;
SNTYPE                  gsnMac =        1;
SNTYPE                  gsnMax =        DFGSNMAX;
SNTYPE                  gsnStack;
WORD                    ifhLibCur;
WORD                    ifhLibMac;
long                    lfaLast;
WORD                    lnameMac;
WORD                    lnameMax = 256;
WORD                    modkey;
SNTYPE                  *mpextgsn;
RATYPE                  *mpextra;
RBTYPE FAR              *mpextprop;
SNTYPE                  mpggrgsn[GGRMAX];
GRTYPE                  *mpgrggr;
#if FAR_SEG_TABLES
RATYPE  FAR             *mpgsndra;
FTYPE   FAR             *mpgsnfCod;
RBTYPE  FAR             *mpgsnrprop;
SEGTYPE FAR             *mpgsnseg;
RATYPE  FAR             *mpsegraFirst;
SATYPE  FAR             *mpsegsa;
BYTE FAR * FAR          *mpsegMem;
BYTE FAR * FAR          *mpsaMem;
#else
RATYPE                  *mpgsndra;
FTYPE                   *mpgsnfCod;
RBTYPE                  *mpgsnrprop;
SEGTYPE                 *mpgsnseg;
RATYPE                  *mpsegraFirst;
SATYPE                  *mpsegsa;
#endif
SNTYPE                  *mpsngsn;
RBTYPE                  mpifhrhte[IFHLIBMAX];
long                    *mpitypelen;
WORD                    *mpityptyp;
RBTYPE FAR              *mplnamerhte;
BYTE                    *psbRun;
WORD                    pubMac;
#if TCE
APROPCOMDAT             *pActiveComdat;
#endif
int                     QCExtDefDelta = 0;
int                     QCLinNumDelta = 0;
WORD                    symMac;         /* Number of symbols defined */
long                    raStart;
#if NOT NEWSYM OR AUTOVM
#if AUTOVM
WORD                    rbMacSyms;
#else
RBTYPE                  rbMacSyms;
#endif
#endif
RECTTYPE                rect;
#if RGMI_IN_PLACE
BYTE                    bufg[DATAMAX + 4];
BYTE                    *rgmi;
#else
BYTE                    rgmi[DATAMAX + 4];
#endif
RBTYPE                  rhteBegdata;
RBTYPE                  rhteBss;
RBTYPE                  rhteFirstObject;
RBTYPE                  rhteRunfile;
RBTYPE                  rhteStack;
RBTYPE                  rprop1stFile;
RBTYPE                  rprop1stOpenFile;
RBTYPE                  r1stFile;
SBTYPE                  sbModule;
SEGTYPE                 segCodeLast;
SEGTYPE                 segDataLast;
SEGTYPE                 segLast;
SEGTYPE                 segStart;
WORD                    snkey;
SNTYPE                  snMac;
WORD                    typMac;
WORD                    vcbData;
WORD                    vcln;
FTYPE                   vfCreated;
FTYPE                   vfLineNos;
FTYPE                   vfMap;
FTYPE                   vfNewOMF;
FTYPE                   vfNoDefaultLibrarySearch;
FTYPE                   vfPass1;        /* Pass 1 flag */
SNTYPE                  vgsnCur;
#if EXE386
DWORD                   vpageCur;               /* Current object page number */
#endif
RATYPE                  vraCur;
SNTYPE                  vgsnLineNosPrev;
RECTTYPE                vrectData;
RBTYPE                  vrhte;
RBTYPE                  vrhteCODEClass;
RBTYPE                  vrhteFile;
RBTYPE                  vrprop;
RBTYPE                  vrpropFile;
RBTYPE                  vrpropTailFile;
SEGTYPE                 vsegCur;
WORD                    ExeStrLen = 0;
WORD                    ExeStrMax = 0;
char FAR                *ExeStrBuf = 0;
#if LOCALSYMS
FTYPE                   fLocals;
WORD                    locMac;
#endif
#if FDEBUG
FTYPE                   fDebug;
#endif
#if CMDXENIX
WORD                    symlen;
#endif
#if OSMSDOS
char                    bigbuf[LBUFSIZ];
FTYPE                   fPauseRun;
BYTE                    chRunFile;
BYTE                    chListFile;
RBTYPE                  rhteLstfile;
BYTE                    DskCur;
#endif
#if LIBMSDOS
FTYPE                   fNoExtDic;
long                    libHTAddr;
#endif
#if FIXEDSTACK
int                     _stack =                STKSIZ;
#endif
#if ECS
FTYPE                   fLeadByte[0x80]; /* f(n) true iff n+0x80 is lead byte */
#endif
#if CRLF
char                    _eol[] =                "\r\n";
#endif
#if SYMDEB
FTYPE                   fSymdeb;
FTYPE                   fCVpack = (FTYPE) TRUE;
FTYPE                   fDebSeg;
FTYPE                   fSkipPublics;
WORD                    cSegCode;
WORD                    ObjDebTotal;
SEGTYPE                 segDebFirst;
SEGTYPE                 segDebLast;
//DWORD                 vaCVMac = (DWORD) AREACV;
//DWORD                 vaCVBase;
#if OSEGEXE
WORD                    cbImpSeg;
SNTYPE                  gsnImports;
#endif
#endif

#if NOT M_WORDSWAP OR M_BYTESWAP
char                    _cbexehdr[] = "wssssssssssssss2sssssls7sl";
char                    _cbnewexe[] = "wsccsslssssllsssssssslss12c";
char                    _cbnewrlc[] = "wccs2cs";
char                    _cbnewseg[] = "wssss";
char                    _cblong[] = "wl";
char                    _cbword[] = "ws";
#endif
#if C8_IDE
char                    msgBuf[_MAX_PATH];
#endif
#if OUT_EXP
char                    bufExportsFileName[_MAX_PATH] = {'\0'};
#endif
/*  Variables for segmented-executable format */
#if OSEGEXE
SNTYPE                  gsnAppLoader;
RBTYPE                  vpropAppLoader;
#if EXE386
DWORD                   hdrSize  = 0x10000L;
DWORD                   virtBase = 0x10000L;
DWORD                   cbEntTab;
DWORD                   cbNamePtr;
DWORD                   cbOrdinal;
DWORD                   cbExpName;
DWORD                   cbImports;
DWORD                   cbImportsMod;
DWORD                   *mpsaVMArea;
DWORD                   *mpsaBase;
DWORD                   cbStack;
DWORD                   cbStackCommit;
DWORD                   cbHeap;
DWORD                   cbHeapCommit;
#else
WORD                    cbHeap;
WORD                    cbStack;
#endif
WORD                    cFixupBuckets;
#if EXE386
WORD                    cChainBuckets = BKTMAX;
#endif
long                    chksum32;
WORD                    cMovableEntries;
#if EXE386
BYTE                    TargetOs;
BYTE                    TargetSubsys = E32_SSWINCHAR;
DWORD                   dfCode = OBJ_CODE | OBJ_READ | OBJ_EXEC;
DWORD                   dfData = OBJ_INITDATA | OBJ_READ | OBJ_WRITE;
BYTE                    ExeMajorVer = 0;
BYTE                    ExeMinorVer = 0;
BYTE                    UserMajorVer = 0;
BYTE                    UserMinorVer = 0;
#else

#if DOSEXTENDER OR DOSX32 OR WIN_NT
BYTE                    TargetOs = NE_WINDOWS; // For DOS the default is Windows
#else
BYTE                    TargetOs = NE_OS2;
#endif
WORD                    dfCode = NSCODE | (3<<SHIFTDPL);
WORD                    dfData = NSDATA | (3<<SHIFTDPL);
BYTE                    ExeMajorVer = DEF_EXETYPE_WINDOWS_MAJOR;
BYTE                    ExeMinorVer = DEF_EXETYPE_WINDOWS_MINOR;
#endif
WORD                    expMac;
FTYPE                   fHeapMax;
FTYPE                   fRealMode;
FTYPE                   fStub = (FTYPE) TRUE;
FTYPE                   fWarnFixup;
EPTYPE FAR * FAR        *htsaraep;
DWORD FAR               *mpsacb;
#if O68K
DWORD                   *mpsadraDP;
#endif
DWORD FAR               *mpsacbinit;
#if EXE386
DWORD                   *mpsacrlc;
DWORD                   *mpsaflags;
WORD                    *mpextflags;
#else
RLCHASH FAR * FAR       *mpsaRlc;
BYTE FAR                *mpextflags;
WORD FAR                *mpsaflags;
#endif
RLCPTR                  rlcCurLidata;
RLCPTR                  rlcLidata;
WORD                    raChksum;
RBTYPE                  rhteDeffile;
RBTYPE                  rhteModule;
RBTYPE                  rhteStub;
WORD                    fileAlign =             DFSAALIGN;
#if EXE386
WORD                    pageAlign =             DFPGALIGN;
WORD                    objAlign  =             DFOBJALIGN;
#endif
SATYPE                  saMac;
WORD                    vepMac =                1;
#if EXE386
WORD                    vFlags =                0;
WORD                    dllFlags =              0;
#else
WORD                    vFlags =                NEINST;
BYTE                    vFlagsOthers;
#endif
#endif /* OSEGEXE */

FTYPE                   fExePack;
#if PCODE
FTYPE                   fMPC;
FTYPE                   fIgnoreMpcRun = FALSE;
#endif

/* Variables for DOS3 format executables */
#if ODOS3EXE
FTYPE                   fBinary = FALSE;
WORD                    cparMaxAlloc = 0xFFFF;
WORD                    csegsAbs;
WORD                    dosExtMode;
FTYPE                   fNoGrpAssoc;
SEGTYPE                 segResLast;
WORD                    vchksum;
WORD                    vdoslev;
FTYPE                   vfDSAlloc;
#if FEXEPACK
FRAMERLC FAR            mpframeRlc[16];
#endif
#if OVERLAYS
FTYPE                   fOverlays;
FTYPE                   fOldOverlay = (FTYPE) FALSE;
FTYPE                   fDynamic;
SNTYPE                  gsnOvlData;
SNTYPE                  gsnOverlay;
WORD                    iovMac = 1;
WORD                    ovlThunkMax = 256;
WORD                    ovlThunkMac = 1;
SNTYPE FAR              *mposngsn;
SNTYPE FAR              *htgsnosn;
IOVTYPE FAR             *mpsegiov;
RUNRLC FAR              *mpiovRlc;
ALIGNTYPE FAR           *mpsegalign;
SNTYPE                  osnMac = 1;
BYTE                    vintno = DFINTNO;
#endif /* OVERLAYS */
#endif /* ODOS3EXE */
/* Variables for segmented-x.out format */
#if OIAPX286
long                    absAddr = -1L;
FTYPE                   fPack = TRUE;
SATYPE                  *mpstsa;
SATYPE                  stBias = DFSTBIAS;
SATYPE                  stDataBias;
SATYPE                  stLast;
WORD                    stMac;
#if EXE386
WORD                    xevmod;
RATYPE                  rbaseText;
RATYPE                  rbaseData = 0x1880000L;
WORD                    xevmod;
FTYPE                   fPageswitch;
BYTE                    cblkPage = 1024 >> 9;
#endif
#endif
/* Variables shared by segmented x.out and DOS3 exes */
#if OIAPX286 OR ODOS3EXE
GRTYPE                  *mpextggr;
long FAR                *mpsegcb;
FTYPE FAR               *mpsegFlags;
char                    *ompimisegDstIdata;
#endif
/* Variables for x.out format */
#if OXOUT OR OIAPX286
FTYPE                   fIandD;
FTYPE                   fLarge;
FTYPE                   fLocals;
FTYPE                   fMedium;
FTYPE                   fMixed;
FTYPE                   fSymbol = TRUE;
WORD                    xever = DFXEVER;
#endif

#ifdef QCLINK
#if NOT WIN_3
FTYPE                   fZ1 = FALSE;
#endif
FTYPE                   fZ2 = FALSE;
#endif

/* Variables for ILINK support */
#if ILINK
FTYPE                   fZincr = FALSE;
FTYPE                   fQCIncremental = FALSE;
FTYPE                   fIncremental = FALSE;
WORD                    imodFile;
WORD                    imodCur = 0;    /* one-based module number */
#endif
WORD                    cbPadCode;      /* code padding size */
WORD                    cbPadData = 16; /* data padding size */

/* Variables shared by segmented-exe and DOS3 executables */
#if OEXE
FTYPE                   fDOSExtended;
FTYPE                   fNoNulls;
FTYPE                   fPackData = FALSE;
FTYPE                   fPackSet;
FTYPE                   fSegOrder;
DWORD                   packLim;
DWORD                   DataPackLim;
#endif
/* Variables for dual-exe format capability */
#if OSEGEXE AND ODOS3EXE
FTYPE                   fNewExe;
FTYPE                   fOptimizeFixups;
void                    (NEAR *pfProcFixup)(FIXINFO *pfi);
#endif
/* Variables shared by segmented-exe and segmented-x.out */
#if OSEGEXE OR OIAPX286
RBTYPE                  mpggrrhte[GRMAX];
#if FAR_SEG_TABLES
SNTYPE FAR              *mpseggsn;
#else
SNTYPE                  *mpseggsn;
#endif
#endif

FTYPE                   fNoEchoLrf;
FTYPE                   fNoBanner;
FTYPE                   BannerOnScreen;

/* Variables for MS-DOS style command interface */
#if CMDMSDOS
BYTE                    bSep = ',';     /* Separator character */
BYTE                    chMaskSpace = ' ';
FTYPE                   fEsc;
#if WIN_3
FTYPE                   fNoprompt = TRUE;
#else
FTYPE                   fNoprompt;
#endif
#if USE_REAL
FTYPE                   fUseReal = FALSE;
FTYPE                   fSwNoUseReal = FALSE;
#endif

RBTYPE                  rgLibPath[IFHLIBMAX];
WORD                    cLibPaths;
# if OSXENIX
char                    CHSWITCH = '-'; /* Switch character */
# else
char                    CHSWITCH = '/'; /* Switch character */
# endif
#if OSMSDOS AND NOT WIN_3
int                     (cdecl *pfPrompt)() = PromptStd;
#endif
#if WIN_3
int                     (cdecl *pfPrompt)() = NULL;
#endif

#endif /* CMDMSDOS */
/* Miscellaneous combinations */
#if QBLIB
FTYPE                   fQlib;
#endif
#if OSEGEXE OR QCLINK
typedef void (FAR * FARFPTYPE)();       /* FAR function pointer type */
FARFPTYPE FAR           *pfQTab;
#endif
char                    *lnknam = "LINK";
#if NEWSYM
long                    cbSymtab;
void    (*pfEnSyms)(void (*pproc)(APROPNAMEPTR papropName,
                                  RBTYPE       rhte,
                                  RBTYPE       rprop,
                                  WORD         fNewHte),
                    ATTRTYPE attr) = BigEnSyms;
#endif /* NEWSYM */
#if NEWLIST
RBTYPE                  rbLstUndef = RHTENIL;
#endif

#if WIN_3
void                    (*pfCputc)(int ch) = CputcWin;
void                    (*pfCputs)(char *str) = CputsWin;
#else
void                    (*pfCputc)(int ch) = CputcStd;
void                    (*pfCputs)(char *str) = CputsStd;
#endif
#if NEWIO
RBTYPE                  rbFilePrev;
char                    mpifhfh[IFHLIBMAX];
#endif
#if ILINK OR SYMDEB
long                    lfaBase;
#endif

#if ALIGN_REC
BYTE                    *pbRec;         // data for current record
char                    recbuf[8192];   // record buffer...
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newtp2.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWTP2.C                            *
    *                                                               *
    *  This module contains functions to process object modules on  *
    *  pass 2.                                                      *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants, macros */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE structure definitions */
#if EXE386
#include                <exe386.h>      /* 386 .EXE structure definitions */
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OXOUT OR OIAPX286
#include                <xenfmt.h>      /* Xenix format definitions */
#endif
#include                <extern.h>      /* External declarations */


#if OSEGEXE
extern RLCPTR           rlcLidata;      /* Pointer to LIDATA fixup array */
extern RLCPTR           rlcCurLidata;   /* Pointer to current LIDATA fixup */
#endif



/*
 *  LOCAL FUNCTION PROTOTYPES
 */


LOCAL void  NEAR DataRec(void);
BYTE * ObExpandIteratedData(unsigned char *pb,
  unsigned short cBlocks, WORD *pSize);
LOCAL void  NEAR DataBlockToVM(void);
LOCAL void  NEAR SegRec2(void);
LOCAL void  NEAR GrpRec2(void);
LOCAL void  NEAR ExtRec2(void);
LOCAL void  NEAR ComDef2(void);


#if ALIGN_REC
#else
/*
 *  GetBytesNoLim : just like GetBytes but no fixed limit
 */

void NEAR               GetBytesNoLim(pb,n)
BYTE                    *pb;            /* Pointer to buffer */
WORD                    n;              /* Number of bytes to read in */
{
    FILE *f = bsInput;

    if (n <= f->_cnt)
        {
        memcpy(pb,f->_ptr, n);
        f->_cnt -= n;
        f->_ptr += n;
        }
    else
        fread(pb,1,n,bsInput);          /* Ask for n bytes */

//  ChkInput();
    cbRec -= n;                         /* Update byte count */
}
#endif

    /****************************************************************
    *                                                               *
    *  DataRec:                                                     *
    *                                                               *
    *  This  function  takes  no arguments.  It processes a LEDATA  *
    *  record  or  an  LIDATA  record.    It  does  not  return  a  *
    *  meaningful value.  See "8086 Object Formats EPS."            *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         DataRec(void)   /* Process a data record */
{
    SNTYPE              sn;             /* SEGDEF number */
    RATYPE              ra;             /* Segment offset */
    SNTYPE              gsn;            /* Global SEGDEF number */


    fSkipFixups = FALSE;                // Make sure that we don't skip fixups
    sn = GetIndex((WORD)1,(WORD)(snMac - 1));   /* Get segment number */
#if OMF386
    if(rect & 1) ra = LGets();
    else
#endif
    ra = WGets();                       /* Get relative address */
    vcbData = cbRec - 1;                /* Get no. of data bytes in rec */
    if(vcbData > DATAMAX) Fatal(ER_datarec);
                                        /* Check if record too large */
#if NOT RGMI_IN_PLACE
    GetBytesNoLim(rgmi,vcbData);        /* Fill the buffer */
#endif
    gsn = mpsngsn[sn];                  /* Map SEGDEF no. to global SEGDEF */
    vgsnCur = gsn;                      /* Set global */

    fDebSeg = (fSymdeb) ? (FTYPE) ((0x8000 & gsn) != 0) : fSymdeb;
                                        /* If debug option on check for debug segs*/
    if (fDebSeg)
    {                                   /* If debug segment */
      vraCur = ra;                      /* Set current relative address */
      vsegCur = vgsnCur = 0x7fff & gsn; /* Set current segment */
    }
    else
    {
        /* If not a valid segment, don't process datarec */
#if SYMDEB
        if(gsn == 0xffff || !gsn || mpgsnseg[gsn] > segLast)
#else
        if(!gsn || mpgsnseg[gsn] > segLast)
#endif
        {
            vsegCur = SEGNIL;
            vrectData = RECTNIL;
#if RGMI_IN_PLACE
            SkipBytes(vcbData);         /* must skip bytes for this record...*/
#endif
            fSkipFixups = TRUE;         /* plus skip any associated fixups */
            return;                     /* Good-bye! */
        }
        vraCur = ra + mpgsndra[gsn];    /* Set current relative address */
        vsegCur = mpgsnseg[gsn];        /* Set current segment */
    }
    vrectData = rect;                   /* Set the record type */

#if RGMI_IN_PLACE
    if(TYPEOF(rect) == LIDATA)          /* If LIDATA record */
    {
        rgmi = bufg;                    /* use general purpose buffer for read*/
    }
    else
    {
        rgmi = PchSegAddress(vcbData,vsegCur,vraCur);
                                        /* read data in place... */
    }
    GetBytesNoLim(rgmi,vcbData);        /* Fill the buffer */
#endif


    if(TYPEOF(vrectData) == LIDATA)     /* If LIDATA record */
    {
#if OSEGEXE
        if(fNewExe)
        {
            if (vcbData >= DATAMAX)
                Fatal(ER_lidata);
            rlcLidata = (RLCPTR ) &rgmi[(vcbData + 1) & ~1];
                                        /* Set base of fixup array */
            rlcCurLidata = rlcLidata;   /* Initialize pointer */
            return;
        }
#endif
#if ODOS3EXE OR OIAPX286
        if(vcbData > (DATAMAX / 2))
        {
            OutError(ER_lidata);
            memset(&rgmi[vcbData],0,DATAMAX - vcbData);
        }
        else
            memset(&rgmi[vcbData],0,vcbData);
        ompimisegDstIdata = (char *) rgmi + vcbData;
#endif
    }
}

    /****************************************************************
    *                                                               *
    *  SegRec2:                                                     *
    *                                                               *
    *  This function processes SEGDEF records on pass 2.            *
    *  See pp. 32-35 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SegRec2(void)
{
    WORD                tysn;           /* ACBP field */
    WORD                align;          /* Alignment subfield of ACBP */
    SATYPE              saAbs;          /* Frame number of absolute LSEG */
    LNAMETYPE           lname;          /* Segment name index */
    WORD                comb;           /* Segment combining information */
    APROPSNPTR          apropSn;        /* Pointer to segment hash tab entry */
    SNTYPE              gsn;            /* Global SEGDEF no. */
    RATYPE              dra;
    RBTYPE              rhteClass;      /* Segment class name rhte */
    WORD                DebKind;        /* Debug seg kind; 1-$$TYPES; 2-$$SYMBOLS */
    DWORD               gsnLen;         /* Segment length */
#if ILINK
    WORD                cbPad;          /* size of padding used */
#endif

    ASSERT(snMac < SNMAX);              /* No overflow on Pass 2 */
    tysn = Gets();                      /* Read in ACBP byte */
    align = (tysn >> 5) & 7;            /* Get alignment subfield */
    ASSERT(align != 5);                 /* Unnamed absolute not supported */
    ASSERT(align != 6);                 /* LTL LSEG not supported */
    if(align == ALGNABS)                /* If absolute LSEG */
    {
        saAbs = WGets();                /* Read in frame number */
        Gets();                         /* Skip frame offset */
    }
#if OMF386
    if(rect & 1)
        gsnLen = LGets();
    else
#endif
        gsnLen = (long) WGets();        /* Read in segment length */
    /* Don't need to check for 386 record, done in pass 1: */
    if(tysn & BIGBIT) gsnLen = LXIVK;   /* Length 64K if big bit set */
    lname = GetIndex((WORD)1,(WORD)(lnameMac - 1));     /* Get segment name index */
    rhteClass = mplnamerhte[GetIndex((WORD)1,(WORD)(lnameMac - 1))];
                                        /* Get segment class name rhte */
#if SYMDEB
    if (DebKind = IsDebSeg(rhteClass, mplnamerhte[lname]))
    {                                   /* If MS debug segment then mark it */
        if (!fSymdeb)
          mpsngsn[snMac++] = 0xffff;
        else
          mpsngsn[snMac++] = ((DebKind == 1) ?
                               segDebFirst + segDebLast :
                               segDebFirst + segDebLast + ObjDebTotal
                             ) | 0x8000;  /* Set debug global number */
        SkipBytes((WORD)(cbRec - 1));
        return;
    }
#endif
    GetIndex((WORD)0,(WORD)(lnameMac - 1));             /* Skip overlay name index */
    switch(align)                       /* Switch on alignment type */
    {
        case ALGNABS:                   /* Absolute LSEG */
        case ALGNWRD:                   /* Word-aligned LSEG */
        case ALGNBYT:                   /* Byte-aligned LSEG */
        case ALGNPAR:                   /* Paragraph-aligned LSEG */
        case ALGNPAG:                   /* Page-aligned LSEG */
#if OMF386
        case ALGNDBL:                   /* Double-aligned LSEG */
#endif
            break;

        default:                        /* Unsupported or illegal types */
            mpsngsn[snMac++] = 0;       /* Map to nothing */
            return;                     /* And return */
    }
    ++snkey;                            /* Increment segment i.d. key */
    if(comb = (tysn >> 2) & 7)          /* If not a private segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname],ATTRPSN,FALSE);
                                        /* Look up property cell */
        ASSERT(apropSn != PROPNIL);     /* Should always be true */
        while(apropSn->as_attr != ATTRNIL)
        {                               /* Look for matching class */
            if(apropSn->as_attr == ATTRPSN &&
              apropSn->as_rCla == rhteClass) break;
                                        /* Break if a match is found */
            apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
                                        /* Try next link in list */
        }
        ASSERT(apropSn->as_attr == ATTRPSN);
    }
    else                                /* Else if private segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname],ATTRLSN,FALSE);
                                        /* Look up property cell */
        ASSERT(apropSn != PROPNIL);     /* Should always be true */
        while(apropSn->as_attr != ATTRNIL)
        {                               /* Search for match */
            if(apropSn->as_attr == ATTRLSN && apropSn->as_key == snkey) break;
                                        /* Break when match found */
            apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
                                        /* Try next link in list */
        }
        ASSERT(apropSn->as_attr == ATTRLSN);
    }
    gsn = apropSn->as_gsn;              /* Get global SEGDEF no. */
#if ILINK
    if (fIncremental && !fLibraryFile && !(apropSn->as_fExtra & NOPAD) &&
        gsnLen && gsnLen != LXIVK)
        /* Add code/data padding to non-library segments if it doesn't
         * overflow.
         */
        gsnLen += (cbPad = ((apropSn->as_flags & NSTYPE) == NSCODE) ?
              cbPadCode : cbPadData);
    else
        cbPad = 0;  /* no padding please */
#endif
    if(comb == COMBSTK) mpgsndra[gsn] =
      mpsegraFirst[mpgsnseg[gsn]] + apropSn->as_cbMx - gsnLen;
    else
    {
        /* If combine-type public, start at end of combined segment. */
        if(comb != COMBCOM)
            dra = mpgsndra[gsn] + apropSn->as_cbPv;
        /*
         * Else if common, start at beginning of segment.  Save current
         * combined size, except this portion, in as_cbPv.  If this
         * portion is bigger as_cbPv is reset below.
         */
        else
        {
            dra = mpsegraFirst[mpgsnseg[gsn]];
            apropSn->as_cbPv += mpgsndra[gsn] - dra;
        }
        switch(align)                       /* Switch on alignment type */
        {
            case ALGNWRD:       /* Word-aligned LSEG */
              mpgsndra[gsn] = (~0L<<1) & (dra + (1<<1) - 1);
                        /* Round to next word offset */
              break;
#if OMF386
            case ALGNDBL:       /* Double-aligned LSEG */
              mpgsndra[gsn] = (~0L<<2) & (dra + (1<<2) - 1);
                        /* Round to next double offset */
              break;
#endif
            case ALGNPAR:       /* Paragraph-aligned LSEG */
              mpgsndra[gsn] = (~0L<<4) & (dra + (1<<4) - 1);
                        /* Round to next paragraph offset */
              break;

            case ALGNPAG:       /* Page-aligned LSEG */
              mpgsndra[gsn] = (~0L<<8) & (dra + (1<<8) - 1);
                        /* Round to next page offset */
              break;

            default:            /* All others */
              mpgsndra[gsn] = dra;  /* Use byte offset */
              break;
        }
    }
    /*
     * If public, as_cbPv is size of this public portion; if common,
     * as_cbPv is the larger of total combined publics and this
     * common portion. Skip empty SEGDEFs.
     */
    if (/*gsnLen != 0L && */(comb != COMBCOM || gsnLen > apropSn->as_cbPv))
        apropSn->as_cbPv = gsnLen;
    mpsngsn[snMac++] = gsn;             /* Map SEGDEF no. to gsn */
    if(align == ALGNABS) mpsegsa[mpgsnseg[gsn]] = saAbs;
                                        /* Map seg base to frame number */
    MARKVP();                           /* Mark page as changed */
#if ILINK
    if (fIncremental)
    {
        AddContribution(gsn,
                        (WORD) (mpgsndra[gsn] - mpsegraFirst[mpgsnseg[gsn]]),
                        (WORD) (mpgsndra[gsn] - mpsegraFirst[mpgsnseg[gsn]] + gsnLen),
                        cbPad);
        gsnLen -= cbPad;                /* Don't include padding for CV */
    }
#endif
#if SYMDEB
    if(fSymdeb && gsnLen && IsCodeFlg(apropSn->as_flags))
        SaveCode(gsn, gsnLen, (DWORD) -1L);
#endif
}

    /****************************************************************
    *                                                               *
    *  GrpRec2:                                                     *
    *                                                               *
    *  This function processes GRPDEF records on pass 2.            *
    *  See pp. 36-39 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         GrpRec2(void)
{
    LNAMETYPE           lnameGroup;     /* Group name index */
    APROPGROUPPTR       apropGroup;     /* Pointer to property cell */

    lnameGroup = GetIndex((WORD)1,(WORD)(lnameMac - 1));
                                        /* Read in group name index */
    apropGroup = (APROPGROUPPTR )
      PropRhteLookup(mplnamerhte[lnameGroup],ATTRGRP,FALSE);
                                        /* Look up entry in hash table */
    ASSERT(grMac < GRMAX);              /* Should have been caught on pass 1 */
    mpgrggr[grMac++] = apropGroup->ag_ggr;
                                        /* Map GRPDEF to global GRPDEF */
    SkipBytes((WORD)(cbRec - 1));               /* Skip to checksum byte */
}

/*
 *  AddVmProp :  Add a symbol-table property address to a list
 *
 *      Returns:  pointer to the new list element; the pointer is
 *              a word offset from the start of the list area in VM
 */

PLTYPE FAR *  NEAR      AddVmProp (PLTYPE FAR *list, RBTYPE rprop)
{
    PLTYPE FAR          *new;

    new = (PLTYPE FAR *) GetMem(sizeof(PLTYPE));

    // Add unresolved external at the list head

    new->pl_next = list;
    new->pl_rprop = rprop;

    return(new);
}

    /****************************************************************
    *                                                               *
    *  ExtRec2:                                                     *
    *                                                               *
    *  This  function  processes EXTDEF  records  on pass 2.  Note  *
    *  that in pass 2, any undefined externals are errors.          *
    *  See pp. 47-48 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         ExtRec2(void)
{
    SBTYPE              sb;             /* External symbol name */
    APROPNAMEPTR        apropName;      /* Property cell pointer */
    APROPUNDEFPTR       apropUndef;     /* Property cell pointer */
    APROPALIASPTR       apropAlias;     /* Property cell pointer */
    RBTYPE              rhte;           /* Virt. addr. of hash table entry */
#if OSEGEXE
    APROPEXPPTR         apropExp;       /* Export cell pointer */
#endif

    while (cbRec > 1)                   /* While not at end of record */
    {
        ASSERT(extMac < EXTMAX);        /* Should be checked on Pass 1 */

        if (TYPEOF(rect) == CEXTDEF)
        {
            /* Look for symbol among PUBDEFs */

            rhte = mplnamerhte[GetIndex(1, (WORD)(lnameMac - 1))];
            apropName = (APROPNAMEPTR) PropRhteLookup(rhte, ATTRPNM, FALSE);
        }
        else
        {
            sb[0] = (BYTE) Gets();      /* Read in symbol length */
            if(TYPEOF(rect) == EXTDEF)
                GetBytes(&sb[1], B2W(sb[0]));
                                        /* Read in the text of the symbol */
            else
                GetLocName(sb);         /* Transform local name */
#if CMDXENIX
            if (symlen && B2W(sb[0]) > symlen)
                sb[0] = symlen;         /* Truncate if necessary */
#endif
            /* Look for symbol among PUBDEFs */

            apropName = (APROPNAMEPTR) PropSymLookup(sb, ATTRPNM, FALSE);
            rhte = vrhte;
        }

        GetIndex(0, 0x7FFF);            /* Skip the type index */

        apropUndef = PROPNIL;

        if (apropName == PROPNIL)
        {
            /* Look for symbol among ALIASES */

            apropAlias = (APROPALIASPTR) PropRhteLookup(rhte, ATTRALIAS, FALSE);

            if (apropAlias != PROPNIL)
            {
                // Every call to PropRhteLookup as a side effect sets
                // the global variable 'vrprop' pointing to the
                // just retrieved proprety cell from symbol table.
                // Because for substitute symbols we don't call
                // PropRhteLookup instead we use direct pointer from
                // alias property cell, then we have to reset the
                // 'vrprop' here.

                vrprop = apropAlias->al_sym;
                apropName = (APROPNAMEPTR) FetchSym(apropAlias->al_sym, FALSE);
                if (apropName->an_attr == ATTRUND)
                {
                    apropUndef = (APROPUNDEFPTR) apropName;
                    apropName = PROPNIL;
                }
            }

#if OSEGEXE
            /* If public definition not found and this is segmented DLL,
             * handle the possibility that this is a self-imported alias.
             */
            if (apropName == PROPNIL && fNewExe && (vFlags & NENOTP))
            {
                /* Look up exported name. */

                apropExp = (APROPEXPPTR) PropRhteLookup(rhte, ATTREXP, FALSE);

                /* If found, get the symbol definition which might be different
                 * from the export name (i.e. an alias).  If not marked public,
                 * assume not found.
                 */

                if (apropExp != PROPNIL && apropExp->ax_symdef != RHTENIL)
                    apropName = (APROPNAMEPTR) FetchSym(apropExp->ax_symdef, FALSE);
            }
#endif

            if (apropName == PROPNIL)
            {
                /* If not among PUBDEFs, ALIASes, or EXPORTs */

                /* Look among undefs */

                if (apropUndef == PROPNIL)
                    apropUndef = (APROPUNDEFPTR) PropRhteLookup(rhte, ATTRUND, FALSE);

                if (apropUndef != PROPNIL)   /* Should always exist */
                {
                    if ((apropUndef->au_flags & STRONGEXT) ||
                        (apropUndef->au_flags & UNDECIDED) )
                    {
                        /* "Strong" extern */

                        apropUndef->au_flags &= ~(WEAKEXT | UNDECIDED);
                        apropUndef->au_flags |= STRONGEXT;
                        fUndefinedExterns = (FTYPE) TRUE;
                                            /* There are undefined externals */
                        apropUndef->u.au_rFil =
                            AddVmProp(apropUndef->u.au_rFil,vrpropFile);
                    }
                    else
                    {
                        /* "Weak" extern - find default resolution */

                        apropName = (APROPNAMEPTR) FetchSym(apropUndef->au_Default, FALSE);
                    }
                }
            }
        }

        if (apropName != PROPNIL)       /* If among PUBDEFs or EXPDEF's or "weak" extern or ALIASes */
        {
            mpextprop[extMac] = vrprop; /* Save the property addr */
#if OSEGEXE
            if(fNewExe)
                mpextflags[extMac] = apropName->an_flags;
                                        /* Save the flags */
#if ODOS3EXE
            else
#endif
#endif
#if ODOS3EXE OR OIAPX286
                mpextggr[extMac] = apropName->an_ggr;
                                        /* Save the global GRPDEF number */
#endif
#if OSEGEXE
            if(apropName->an_flags & FIMPORT)
            {                           /* If we have a dynamic link */
#if EXE386
                mpextgsn[extMac] = gsnImport;
                                        /* Save the thunk segment no. */
                mpextra[extMac] = apropName->an_thunk;
                                        /* Save the offset in thunk segment */
#else
                mpextgsn[extMac] = apropName->an_module;
                                        /* Save the module specification */
                mpextra[extMac] = apropName->an_entry;
                                        /* Save the entry specification */
#endif
            }
            else                        /* Else if internal reference */
#endif
            {
                mpextra[extMac] = apropName->an_ra;
                                        /* Save the offset */
                mpextgsn[extMac] = apropName->an_gsn;
                                        /* Save the global SEGDEF number */
            }
        }

        else
        {
            /* External is undefined */

            mpextra[extMac] = 0;
            mpextgsn[extMac] = SNNIL;
            mpextprop[extMac] = PROPNIL;
#if OSEGEXE
            if (fNewExe)
                mpextflags[extMac] = 0;
#if ODOS3EXE
            else
#endif
#endif
#if ODOS3EXE OR OIAPX286
                mpextggr[extMac] = GRNIL;
#endif
        }

        ++extMac;                       /* Increment public symbol counter */
    }
}

LOCAL void NEAR         ComDef2(void)
{
        int                     tmp;    /* workaround a cl bug */
    SBTYPE              sb;             /* External symbol name */
    APROPNAMEPTR        apropName;      /* Property cell pointer */

    while(cbRec > 1)                    /* While not at end of record */
    {
        sb[0] = (BYTE) Gets();          /* Read in symbol length */
        if(rect == COMDEF)
            GetBytes(&sb[1],B2W(sb[0]));/* Read in the text of the symbol */
        else
            GetLocName(sb);             /* Transform local name */
#if CMDXENIX
        if(symlen && B2W(sb[0]) > symlen) sb[0] = symlen;
                                        /* Truncate if necessary */
#endif
        GetIndex(0,0x7FFF);             /* Skip the type index */
        tmp =  Gets();
        switch(tmp)
        {
            case TYPEFAR:
                TypLen();               /* Skip num. elems. field */
                                        /* Fall through ... */
            case TYPENEAR:
                TypLen();               /* Skip length field */
        }
        apropName = (APROPNAMEPTR ) PropSymLookup(sb,ATTRPNM,FALSE);
                                        /* Look for symbol among PUBDEFs */
        if (apropName == PROPNIL)
        {
            ExitCode = 4;
            Fatal(ER_unrcom);           /* Internal error */
        }
#if OSEGEXE
        if(fNewExe)
            mpextflags[extMac] = apropName->an_flags;
                                        /* Save the flags */
#if ODOS3EXE
        else
#endif
#endif
#if ODOS3EXE OR OIAPX286
            mpextggr[extMac] = apropName->an_ggr;
                                        /* Save the global GRPDEF number */
#endif
#if OSEGEXE
        if(fNewExe && (apropName->an_flags & FIMPORT))
            DupErr(sb);                 /* Communal vars can't resolve to dynamic links */
#endif
        mpextra[extMac] = apropName->an_ra;
                                        /* Save the offset */
        mpextgsn[extMac] = apropName->an_gsn;
                                        /* Save the global SEGDEF number */
        mpextprop[extMac] = vrprop;     /* Save the property address */
        ++extMac;                       /* Increment public symbol counter */
    }
}

    /****************************************************************
    *                                                               *
    *  ObExpandIteratedData:                                        *
    *                                                               *
    *  This  function  expands  a  LIDATA  record  and moves it to  *
    *  virtual memory.  The  function  returns  a  pointer to  the  *
    *  start of the next iterated  data block (if any).  This is a  *
    *  recursive function.                                          *
    *  See pp. 68-69,63 in "8086 Object Module Formats EPS."        *
    *                                                               *
    ****************************************************************/

BYTE *  ObExpandIteratedData(pb,cBlocks, pSize)
BYTE                    *pb;            /* Pointer into LIDATA buffer */
WORD                    cBlocks;        /* Current block count subfield */
WORD                    *pSize;         /* != NULL if all the caller wants
                                            is the size of expanded block */
{
    WORD                cNextLevelBlocks;
                                        /* Block count for next level */
    RATYPE              cRepeat;        /* Repeat count */
    WORD                cbContent;      /* Size of content subfield in bytes */
    BYTE                *pbRet;         /* Recursion return value */

    DEBUGVALUE(pb);                     /* Debug info */
    DEBUGVALUE(cBlocks);                /* Debug info */
    DEBUGVALUE(vraCur);                 /* Debug info */
    if(!cBlocks)                        /* If block count subfield is zero */
    {
        cbContent = B2W(*pb++);         /* Get size of content subfield */
        if (pSize!=NULL)
            *pSize += cbContent;

#if OIAPX286
        if(pSize==NULL)
           MoveToVm(cbContent,pb,vsegCur,vraCur - mpsegraFirst[vsegCur]);
                                        /* Move data to virtual memory */
#endif
#if NOT OIAPX286
#if OSEGEXE
        if (fNewExe && (pSize==NULL))
            DoIteratedFixups(cbContent,pb);/* Do any iterated fixups */
#endif
        if(pSize==NULL)
            MoveToVm(cbContent,pb,vsegCur,vraCur);
                                        /* Move data to virtual memory */
#if ODOS3EXE
        if(!fNewExe)
        {
            while(cbContent--)
            {
                if(pb[vcbData] && (pSize==NULL))
                  RecordSegmentReference(vsegCur,(long)vraCur,B2W(pb[vcbData]));
                ++vraCur;               /* Increment current offset */
                ++pb;                   /* Increment buffer pointer */
            }
            cbContent++;
        }
#endif
#endif /* NOT OIAPX286 */

        vraCur += cbContent;            /* Adjust current offset */
        pb += cbContent;                /* Move ahead in buffer */
    }
    else                                /* Else if non-zero block count */
    {
        while(cBlocks--)                /* While there are blocks to do */
        {
#if OMF386
            if(vrectData & 1)
            {
                cRepeat = getword(pb) + ((long)(getword(&pb[2])) << 16);
                cNextLevelBlocks = getword(&pb[4]);
                pb += 6;
            }
            else
#endif
            {
                cRepeat = getword(pb);  /* Get repeat count */
                cNextLevelBlocks = getword(&pb[2]);
                                        /* Get block count */
                pb += 4;                /* Skip over fields */
            }
            ASSERT(cRepeat != 0);       /* One hopes it won't happen */
            if(!cRepeat) InvalidObject();
                                        /* Must have non-zero repeat count */
            while(cRepeat--) pbRet = ObExpandIteratedData(pb,cNextLevelBlocks, pSize);
                                        /* Recurse to expand record */
            pb = pbRet;                 /* Skip over expanded block */
        }
    }
    DEBUGVALUE(pb);                     /* Debug info */
    DEBUGVALUE(rgmi + vcbData + 1);     /* Debug info */
    ASSERT(pb <= rgmi + vcbData + 1);   /* Should be true always */
    if(pb > rgmi + vcbData + 1) InvalidObject();
                                        /* Length must agree with format */
    return(pb);                         /* Ret ptr to next iterated data blk */
}

    /****************************************************************
    *                                                               *
    *  DataBlockToVm:                                               *
    *                                                               *
    *  This function moves data  from a LEDATA record  or a LIDATA  *
    *  record into virtual memory.                                  *
    *  See pp. 66-69 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         DataBlockToVM(void)
{
    REGISTER BYTE       *pb;            /* Pointer to data buffer */
    REGISTER RECTTYPE   rect;           /* Record type */

    DEBUGVALUE(vcbData);                /* Debug info */
    /*
     * In new-format exes, disallow initialization of the stack segment
     * if it is in DGROUP.
     */
    if(fNewExe && vgsnCur == gsnStack && ggrDGroup != GRNIL &&
      mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]] == mpsegsa[mpgsnseg[gsnStack]])
      return;
    rect = vrectData;                   /* Get record type */
    /*
     * Mask off all but the low bit of vrectData here, since ObExp.
     * will call RecordSegmentReference for runtime relocations which
     * were postponed until the LIDATA record was expanded.
     * RecordSegmentReference will think it's at the earlier phase if
     * vrectData is LIDATA, and the reloc won't get generated.
     * Leave low bit of vrectData so ObExp. can tell if OMF 386.
     */
#if OMF386
    vrectData &= 1;
#else
    vrectData = RECTNIL;
#endif
    if(TYPEOF(rect) == LEDATA)          /* If enumerated data record */
    {
        DEBUGVALUE(vraCur);             /* Debug info */
#if RGMI_IN_PLACE
        if (!fDebSeg && fNewExe) 
        {
            // If data is going up to or past current end of initialized data,
            // omit any trailing null bytes and reset mpsacbinit.  Mpsacbinit
            // will usually go up but may go down if a common segment over-
            // writes previous end data with nulls.

            SATYPE  sa = mpsegsa[vsegCur];
            WORD    cb = vcbData;
            long cbtot = (long)cb + vraCur;

            if ((DWORD) cbtot >= mpsacbinit[sa])
            {
                if ((DWORD) vraCur < mpsacbinit[sa] ||
                    (cb = zcheck(rgmi, cb)) != 0)
                    mpsacbinit[sa] = (long)vraCur + cb;
            }
        }
#else
#if OIAPX286
        if (fDebSeg)
          MoveToVm(vcbData,rgmi,vsegCur,vraCur);
        else
          MoveToVm(vcbData,rgmi,vsegCur,vraCur - mpsegraFirst[vsegCur]);
#else
        MoveToVm(vcbData,rgmi,vsegCur,vraCur);
#endif
#endif
                                        /* Move data to virtual memory */
        vraCur += vcbData;              /* Update current offset */
    }
    else                                /* Else if iterated data record */
    {
        pb = rgmi;                      /* Get address of buffer */
        while((pb = ObExpandIteratedData(pb,1, NULL)) < rgmi + vcbData);
                                        /* Expand and move to VM */
    }
    DEBUGVALUE(vsegCur);                /* Debug info */
#if ODOS3EXE OR OIAPX286
    if (!fNewExe && !fDebSeg) mpsegFlags[vsegCur] |= FNOTEMPTY;
#endif
#if OMF386
    vrectData = RECTNIL;
#endif
}

    /****************************************************************
    *                                                               *
    *  LinRec2:                                                     *
    *                                                               *
    *  This function processes LINNUM records on pass 2.            *
    *  See pp. 51-52 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

void NEAR               LinRec2(void)
{
    SNTYPE              sn;             /* SEGDEF index value */
    SNTYPE              gsn;            /* Global SEGDEF no. */
    SEGTYPE             seg;
    WORD                ln;             /* Line number */
    RATYPE              ra;             /* Offset */
    APROPPTR            aprop;
    AHTEPTR             ahte;           // Pointer to hash table entry
    WORD                attr;           // COMDAT flags
    WORD                comdatIdx;      // COMDAT index
    APROPCOMDATPTR      comdat;         // Pointer to symbol table entry
    DWORD               comdatRa;       // Offset of the COMDAT symbol

    /*
     * Get the group index and ignore it, so the linker can work with
     * other compilers.
     */

    if ((rect & ~1) == LINNUM)
    {
        // Read regular LINNUM record

        GetIndex((WORD)0,(WORD)(grMac - 1));
        sn = GetIndex(1, (WORD)(snMac - 1));
        gsn = mpsngsn[sn];              /* Get global SEGDEF number */
        comdatRa = 0L;
    }
    else
    {
        // Read LINSYM record - line numbers for COMDAT

        attr = (WORD) Gets();
        comdatIdx = GetIndex(1, (WORD)(lnameMac - 1));
        comdat = (APROPCOMDATPTR ) PropRhteLookup(mplnamerhte[comdatIdx], ATTRCOMDAT, FALSE);
        if (comdat != NULL)
        {
            gsn = comdat->ac_gsn;
            comdatRa = comdat->ac_ra;
        }
        else
            InvalidObject();            /* Invalid module */
    }

    /* If LINNUM record is empty, don't do anything.  */

    if(cbRec == 1)
        return;

    seg = mpgsnseg[gsn];
    if(gsn != vgsnLineNosPrev)          /* If we weren't doing line numbers */
    {                                   /* for this segment last time */
        if(vcln) NEWLINE(bsLst);        /* Newline */
        fputs("\r\nLine numbers for ",bsLst);
                                        /* Message */
        OutFileCur(bsLst);              /* File name */
        fputs(" segment ",bsLst);       /* Message */
        aprop = (APROPPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        /* Fetch from virtual memory */
        ASSERT(aprop != PROPNIL);       /* Should never happen! */
        ahte = GetHte(aprop->a_next);   /* Get hash table entry */
        OutSb(bsLst,GetFarSb(ahte->cch));       /* Segment name */
        fputs("\r\n\r\n",bsLst);                /* End line, skip a line */
        vgsnLineNosPrev = gsn;          /* Save global SEGDEF number */
        vcln = 0;                       /* No entries on line yet */
    }
    while(cbRec > 1)                    /* While not at checksum */
    {
        if(vcln >= 4)                   /* If four entries on this line */
        {
            vcln = 0;                   /* Reset counter */
            NEWLINE(bsLst);             /* Newline */
        }
        ln = WGets() + QCLinNumDelta;   /* Read in line number */
#if OMF386
        if (rect & 1)
            ra = LGets();
        else
#endif
            ra = (RATYPE) WGets();
        ra += mpgsndra[gsn] + comdatRa; /* Get fixed segment offset */
        if(gsn == gsnText && comdatRa && fTextMoved)
                ra -=  NullDelta;
        fprintf(bsLst,"  %4d %04x:",ln,mpsegsa[seg]);
#if EXE386
        if (f386)
            fprintf(bsLst,"%08lx",(long) ra);
        else
#endif
            fprintf(bsLst,"%04x",(WORD) ra);
        ++vcln;                         /* Increment counter */
    }
}

    /****************************************************************
    *                                                               *
    *  ProcP2:                                                      *
    *                                                               *
    *  This  function  controls the processing of  object  modules  *
    *  during pass 2.                                               *
    *                                                               *
    ****************************************************************/

#pragma check_stack(on)

void NEAR               ProcP2(void)
{
#if EXE386
    WORD                extflags[EXTMAX];
#else
    BYTE                extflags[EXTMAX];
#endif
    SNTYPE              extgsn[EXTMAX];
    RATYPE              extra[EXTMAX];
    FTYPE               fFirstMod;
    FTYPE               fModEnd;
#if SYMDEB
    WORD                bTmp=TRUE;
#endif
#if OXOUT OR OIAPX286
    LFATYPE             lfa;            /* Seek value */
#endif

    /* Group associations for EXTDEFs are only used for old exes and
     * EXTDEF flags are only used for new exes, so they can share the
     * same space. */
#if OSEGEXE
    if(fNewExe)
        mpextflags = extflags;          /* Initialize pointer */
#if ODOS3EXE
    else
#endif
#endif
#if ODOS3EXE OR OIAPX286
        mpextggr = extflags;
#endif
    mpextgsn = extgsn;                  /* Initialize pointer */
    mpextra = extra;                    /* Initialize pointer */
    vgsnLineNosPrev = SNNIL;            /* No line numbers from this module */
    fFirstMod = (FTYPE) TRUE;                   /* First module */
    for(;;)                             /* Loop to process modules */
    {
        snMac = 1;                      /* Initialize counter */
        grMac = 1;                      /* Initialize counter */
        extMac = 1;                     /* Initialize counter */
        lnameMac = 1;                   /* Initialize counter */
        QCExtDefDelta = 0;              /* Initialize QC deltas */
        QCLinNumDelta = 0;
        vrectData = RECTNIL;            /* Initialize record type variable */
        cbBakpat = 0;                   /* Initialize */
#if OXOUT OR OIAPX286
        lfa = ftell(bsInput);           /* Save initial file position */

        cbRec = WSGets();               /* Read record length */

        if(cbRec == X_MAGIC) fseek(bsInput,(long) CBRUN - sizeof(WORD),1);
                                        /* Skip x.out header if any */
        else fseek(bsInput,lfa,0);      /* Else return to start */
#endif
#if RGMI_IN_PLACE
        rgmi = NULL;                    /* There is no data available */
        vcbData = 0;                    /* There is really no data, honest */
#endif
        fModEnd = FALSE;                /* Not end of module */
        while(!fModEnd)                 /* Loop to process object module */
        {
            rect = getc(bsInput);       /* Read record type */
            if (IsBadRec(rect))
            {
                if(fFirstMod) break;    /* Break if 1st module invalid */
                return;                 /* Else return */
            }
            cbRec = getc(bsInput) | (getc(bsInput) << 8);
                                        /* Read record length */
#if ALIGN_REC
            if (bsInput->_cnt >= cbRec)
            {
                pbRec = bsInput->_ptr;
                bsInput->_ptr += cbRec;
                bsInput->_cnt -= cbRec;
            }
            else
            {
                if (cbRec >= sizeof(recbuf))
                {
                    // error -- record too large [rm]
                    InvalidObject();
                }

                // read record into contiguous buffer
                fread(recbuf,1,cbRec,bsInput);
                pbRec = recbuf;
            }
#endif
            lfaLast += cbRec + 3;       /* Update current file position */
            DEBUGVALUE(rect);           /* Debug info */
            DEBUGVALUE(cbRec);          /* Debug info */
                                        /* If FIXUPP, perform relocation */
            if (TYPEOF(rect) == FIXUPP) FixRc2();
            else                        /* Else if not fixup record */
            {
                if (vrectData != RECTNIL)
                {
                    DataBlockToVM();    /* Move data to virtual memory */
                    fFarCallTrans = fFarCallTransSave;
                                        /* Restore the /FARCALL state */
                }
                fDebSeg = FALSE;
                switch(TYPEOF(rect))    /* Switch on record type */
                {
                    case SEGDEF:
                      SegRec2();
                      break;

                    case THEADR:
                    case LHEADR:
                      fSkipFixups = FALSE;
                      ModRc1();
                      break;

                    case GRPDEF:
                      GrpRec2();
                      break;

                    case EXTDEF:
                    case LEXTDEF:
                    case CEXTDEF:
                      ExtRec2();
                      break;

                    case COMDEF:
                    case LCOMDEF:
                      ComDef2();
                      break;

                    case LNAMES:
                    case LLNAMES:
                      LNmRc1((WORD)(TYPEOF(rect) == LLNAMES));
                      break;

                    case LINNUM:
                    case LINSYM:

#if SYMDEB
                      if (fSymdeb)
                        bTmp=DoDebSrc();
#endif
                      if (fLstFileOpen && vfLineNos
#if SYMDEB
                          && bTmp
#endif
                                       )
                        LinRec2();
                      else
                        SkipBytes((WORD)(cbRec - 1));
                      break;

                    case LEDATA:
                    case LIDATA:
                      DataRec();
                      break;

                    case MODEND:
#if OVERLAYS
                      if (!fOverlays) EndRec();
                      else SkipBytes((WORD)(cbRec - 1));
#else
                      EndRec();
#endif
                      fModEnd = (FTYPE) TRUE;
                      break;

                    case BAKPAT:
                    case NBAKPAT:
                      BakPat();
                      break;

                    case COMENT:        /* COMENT records are processed in   */
                                        /* pass 2 for support of INCDEF for QC */
                      Gets();           /* Skip byte 1 of comment type field */
                      if (Gets() == 0xA0)
                      {                 /* if Microsoft OMF extension */
                          if (Gets() == 0x03)
                          {             /* QC 2.0 - INCremental DEFinition */
                              QCExtDefDelta += WGets();
                              QCLinNumDelta += WGets();
                          }
                      }
                      SkipBytes((WORD)(cbRec - 1));
                      break;

                    case COMDAT:
                      ComDatRc2();
                      break;

                    default:
                      if (rect == EOF)
                          InvalidObject();
                      SkipBytes((WORD)(cbRec - 1));
                                        /* Skip to checksum byte */
                      break;
                }
            }
            DEBUGVALUE(cbRec);          /* Debug info */
            if(cbRec != 1) break;       /* If record length bad */
            Gets();                     /* Eat the checksum byte */
        }
        if(!fModEnd)
        {
            ChkInput();                 /* First check for I/O problems */
            InvalidObject();            /* Invalid module */
        }
        ++modkey;                       /* For local symbols */
#if SYMDEB
        if (fSymdeb) DebMd2();          /* Module post-processing for ISLAND */
#endif
        if(cbBakpat)                    /* Fix up backpatches if any */
            FixBakpat();
        if(fLibraryFile) return;        /* One at a time from libraries */
        fFirstMod = FALSE;              /* No longer first module */
    }
}

#pragma check_stack(off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newtp1.c ===
/*
*      Copyright Microsoft Corporation, 1983-1989
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWTP1.C                            *
    *                                                               *
    *  Pass 1 object module processing routines.                    *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Basic types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* Relocation record definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OXOUT OR OIAPX286
#include                <xenfmt.h>      /* Xenix format definitions */
#endif
#include                <extern.h>      /* External declarations */
#include                <undname.h>
#if OVERLAYS
      WORD              iovFile;        /* Overlay number of input file */
#endif
LOCAL FTYPE             fP2Start;       /* Start of Pass 2 records */
LOCAL FTYPE             fModEnd;        /* MODEND seen */
LOCAL WORD              cSegCode;       /* Number of code seg's in module */

#if O68K
#define F68KCODE(ch)    ((ch) >= 'A' && (ch) <= 'E')
#endif /* O68K */
/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR TypErr(MSGTYPE msg,unsigned char *sb);
LOCAL void NEAR DoCommon(APROPUNDEFPTR apropUndef,
                          long length,
                          unsigned short cbEl,
                          unsigned char *sb);
LOCAL void NEAR SegUnreliable(APROPSNPTR apropSn);
LOCAL void NEAR redefinition(WORD iextWeak, WORD iextDefRes, RBTYPE oldDefRes);
LOCAL void NEAR SegRc1(void);
LOCAL void NEAR TypRc1(void);
LOCAL void NEAR ComDf1(void);
LOCAL void NEAR GrpRc1(void);
LOCAL void NEAR PubRc1(void);
LOCAL void NEAR ExtRc1(void);
LOCAL void NEAR imprc1(void);
LOCAL void NEAR exprc1(void);
LOCAL void NEAR ComRc1(void);
LOCAL void NEAR EndRc1(void);

extern  void NEAR FixRc1(void);

LOCAL void NEAR     redefinition(WORD iextWeak, WORD iextDefRes, RBTYPE oldDefRes)
{
    // Redefinition of default resolution.
    // Warn the user.

    SBTYPE          oldDefault;
    SBTYPE          newDefault;
    APROPUNDEFPTR   undef;
    AHTEPTR         rhte;

    undef = (APROPUNDEFPTR ) FetchSym(oldDefRes, FALSE);
    while (undef->au_attr != ATTRNIL)
    {
        rhte = (AHTEPTR) undef->au_next;
                /* Try next entry in list */
        undef = (APROPUNDEFPTR ) FetchSym((RBTYPE)rhte,FALSE);
                /* Fetch it from VM */
    }
    strcpy(oldDefault, GetFarSb(rhte->cch));
    undef = (APROPUNDEFPTR ) FetchSym(mpextprop[iextDefRes], FALSE);
    while (undef->au_attr != ATTRNIL)
    {
        rhte = (AHTEPTR) undef->au_next;
                /* Try next entry in list */
        undef = (APROPUNDEFPTR ) FetchSym((RBTYPE)rhte,FALSE);
                /* Fetch it from VM */
    }
    strcpy(newDefault, GetFarSb(rhte->cch));
    undef = (APROPUNDEFPTR ) FetchSym(mpextprop[iextWeak], FALSE);
    while (undef->au_attr != ATTRNIL)
    {
        rhte = (AHTEPTR) undef->au_next;
                        /* Try next entry in list */
        undef = (APROPUNDEFPTR ) FetchSym((RBTYPE)rhte,FALSE);
                        /* Fetch it from VM */
    }
    OutWarn(ER_weakredef, 1 + GetFarSb(rhte->cch), &oldDefault[1], &newDefault[1]);
}

/*** IsDebSeg - check is segment is one of the special debug segments
*
* Purpose:
*   Check if segment name and class name match reserved debugger
*   segment names.
*
* Input:
*   - rhteClass - pointer to class name
*   - rhteSeg   - pointer to segment name
*
* Output:
*   If this is a debug segment function returns 1 for $$TYPES, and 2
*   for $$SYMBOLS.  For non-debug segments it returns FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

WORD NEAR               IsDebSeg(RBTYPE rhteClass, RBTYPE rhteSeg)
{
    if (rhteClass == rhteDebTyp)
        return ((rhteSeg == rhteTypes || rhteSeg == rhte0Types) ? 1 : FALSE);
    else if (rhteClass == rhteDebSym)
        return ((rhteSeg == rhteSymbols || rhteSeg == rhte0Symbols) ? 2 : FALSE);
    else
        return(FALSE);
}


    /****************************************************************
    *                                                               *
    *  ModRc1:                                                      *
    *                                                               *
    *  This function reads the name from a THEADR record and makes  *
    *  an entry containing the name in the hash table.              *
    *  See p. 26 in "8086 Object Module Formats EPS."               *
    *                                                               *
    ****************************************************************/

void NEAR               ModRc1(void)
{
    APROPFILEPTR        apropFile;

    sbModule[0] = (BYTE) Gets();        /* Read in the length byte */
    GetBytes(&sbModule[1],B2W(sbModule[0]));
                                        /* Read in the name */
    PropSymLookup(sbModule, ATTRNIL, TRUE);
                                        /* Make entry in hash table */
    apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,TRUE);
                                        /* Allocate space in virt mem */


    // The name of a module is given by the very first THEADR record

    if(apropFile->af_rMod == 0)
            apropFile->af_rMod = vrhte;         /* Load pointer into hash table */
#if FDEBUG
    if(fDebug)                          /* If runtime debugging on */
    {
        OutFileCur(stderr);             /* Write current file and module */
        NEWLINE(stderr);
    }
#endif
}

long NEAR               TypLen()        /* Get type length */
{
    WORD                b;              /* Byte value */
    long                l;              /* Size */

    if(cbRec < 2) InvalidObject();      /* Make sure record long enough */
    b = Gets();                         /* Get length byte */
    if(b < 128) return(B2L(b));         /* One byte length field */
    if(b == 129)                        /* If two byte length */
    {
        if(cbRec < 3) InvalidObject();  /* Make sure record long enough */
        return((long) WGets());         /* Return the length */
    }
    if(b == 132)                        /* If three byte length */
    {
        if(cbRec < 4) InvalidObject();  /* Make sure record long enough */
        l = (long) WGets();             /* Get the low word */
        return(l + ((long) Gets() << WORDLN));
                                        /* Return the length */
    }
    if(b == 136)                        /* If four byte length */
    {
        if(cbRec < 5) InvalidObject();  /* Make sure record long enough */
        l = (long) WGets();             /* Get the low word */
        return(l + ((long) WGets() << WORDLN));
                                        /* Return the length */
    }
    InvalidObject();                    /* Bad length specification */
}

    /****************************************************************
    *                                                               *
    *  TypRc1:                                                      *
    *                                                               *
    *  This function processes  TYPDEF records.  These records are  *
    *  difficult  to  understand.  They are (poorly) described  on  *
    *  pp. 40-43 of "8086  Object  Module  Formats EPS," with some  *
    *  additional  information on pp. 89-90.                        *
    *  Microsoft used to used them for communal variables but they  *
    *  have been superseded by COMDEF records.                      *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         TypRc1(void)
{
    long                l;
    WORD                b;
    WORD                typ;            /* Near or FAR */
    WORD                ityp;           /* Type index */

    if(typMac >= TYPMAX)
        Fatal(ER_typdef);
    SkipBytes(Gets());                  /* Skip the name field */
    Gets();                             /* Skip the EN byte */
    l = -1L;                            /* Initialize */
    mpityptyp[typMac] = 0;              /* Assume no element type */
    if(cbRec > 3)                       /* If at least four bytes left */
    {
        typ = Gets();                   /* Get type leaf */
        b = Gets();                     /* Get next leaf */
        if(typ == TYPENEAR)             /* If near variable */
        {
            if(b != 0x7B && b != 0x79 && b != 0x77) InvalidObject();
                                        /* Scalar, structure, or array */
            fCommon = (FTYPE) TRUE;     /* We have communal variables */
            l = (TypLen() + 7) >> 3;    /* Round length to nearest byte */
        }
        else if(typ == TYPEFAR)         /* Else if FAR variable */
        {
            if(b != 0x77) InvalidObject();
                                        /* Must have an array */
            fCommon = (FTYPE) TRUE;     /* We have communal variables */
            l = TypLen();               /* Get number of elements */
            ityp = GetIndex(1, (WORD) (typMac - 1));
                                        /* Get type index */
            if(mpityptyp[ityp] || mpitypelen[ityp] == -1L) InvalidObject();
                                        /* Must index valid TYPDEF */
            mpityptyp[typMac] = ityp;   /* Save type index */
            /* If element length too big, treat as TYPENEAR */
            if(mpitypelen[ityp] > CBELMAX)
            {
                l *= mpitypelen[ityp];
                mpitypelen[ityp] = 0;
            }
        }
    }
    mpitypelen[typMac++] = l;           /* Store length */
    SkipBytes((WORD) (cbRec - 1));      /* Skip all but the checksum */
}

LOCAL void NEAR         TypErr(msg,sb)  /* Type error message routine */
MSGTYPE                 msg;            /* Message */
BYTE                    *sb;            /* Symbol to which error refers */
{
    sb[B2W(sb[0]) + 1] = '\0';          /* Null-terminate */
    OutError(msg,1 + sb);
}

/*
 *  DoCommon
 *
 *  Resolves old and new communal definitions of the same symbol.
 *  Does work for both ComDf1() and ExtRc1().
 */

LOCAL void NEAR         DoCommon (apropUndef, length, cbEl, sb)
APROPUNDEFPTR           apropUndef;     /* Ptr to property cell */
long                    length;         /* Length or number of elements */
WORD                    cbEl;           /* # bytes per array element */
BYTE                    *sb;            /* Name of symbol */
{
    if(apropUndef->au_len == -1L)       /* If not previously a communal */
    {
        apropUndef->au_cbEl = cbEl;     /* Set the element size */
        MARKVP();                       /* Page has changed */
    }
    else if (cbEl == 0 && apropUndef->au_cbEl != 0)
    {                                   /* Else if near reference to FAR */
        apropUndef->au_len *= apropUndef->au_cbEl;
                                        /* Calculate FAR variable length */
        apropUndef->au_cbEl = 0;        /* Force DS-type to near */
        MARKVP();                       /* Page has changed */
        if (apropUndef->au_len > LXIVK) /* If huge variable */
        {
            TypErr(ER_nearhuge,sb);     /* Issue error message */
            return;                     /* Skip this symbol */
        }
    }
    else if (cbEl != 0 && apropUndef->au_cbEl == 0)
    {                                   /* Else if FAR reference to near */
        length *= cbEl;                 /* Calculate FAR variable length */
        cbEl = 0;                       /* Force DS-type to near */
        if (length > LXIVK)             /* If huge variable */
        {
            TypErr(ER_nearhuge,sb);     /* Issue error message */
            return;                     /* Skip this symbol */
        }
    }
    else if (cbEl != apropUndef->au_cbEl)
    {                                   /* If array element sizes don't match */
        TypErr(ER_arrmis,sb);
        return;                         /* Skip this symbol */
    }
    if (apropUndef->au_len < length)
    {                                   /* If new length is larger */
        apropUndef->au_len = length;    /* Save it */
        MARKVP();
    }
}

/*
 *  ComDf1
 *
 *  This function processes COMDEF records on pass 1.
 */
LOCAL void NEAR         ComDf1 (void)
{
        int tmp;                        /* workaround a cl bug */
    SBTYPE              sb;             /* COMDEF symbol */
    REGISTER APROPUNDEFPTR
                        apropUndef;     /* Pointer to symbol entry */
    long                length;         /* Communal variable length */
    long                cbEl;           /* Size of array element */
    WORD                itype;          /* Type index */

    while(cbRec > 1)                    /* While there are symbols left */
    {
        if(extMac >= EXTMAX - 1)        /* Check for table overflow */
            Fatal(ER_extdef);
        sb[0] = (BYTE) Gets();          /* Get symbol length */
        if(rect == COMDEF)
            GetBytes(&sb[1],B2W(sb[0]));/* Read in text of symbol */
        else
            GetLocName(sb);             /* Transform local name */
#if CMDXENIX
        if(symlen && B2W(sb[0]) > symlen) sb[0] = symlen;
                                        /* Truncate if necessary */
#endif
        itype = GetIndex(0,0x7FFF);     /* Get type index */
        tmp =  Gets();
        switch(tmp)                     /* Get data seg type */
        {
            case TYPENEAR:
                length = TypLen();      /* Get length */
                cbEl = 0;
                break;
            case TYPEFAR:
                length = TypLen();      /* Get number of elements */
                /* Get element length.  If too big, treat as near.  Cmerge
                 * will never generate cbEl > 64K so this is not a problem.
                 */
                if((cbEl = TypLen()) > CBELMAX)
                {
                    length *= cbEl;
                    cbEl = 0;
                }
                break;
            default:
                InvalidObject();        /* Unrecognized DS type */
        }
#if FALSE
if(fDebug)
{
sb[sb[0]+1] = '\0';
fprintf(stdout, "%s has index = %u\r\n", sb+1, extMac);
}
#endif
        apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRPNM, FALSE);
                                        /* Look for a matching PUBDEF */
        if(apropUndef == PROPNIL)       /* If there isn't one */
        {
            /* Insert as undefined symbol */

            if (vrhte == RHTENIL)
               apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRUND, TRUE);
            else
               apropUndef = (APROPUNDEFPTR) PropRhteLookup(vrhte, ATTRUND, TRUE);

            mpextprop[extMac++] = vrprop;
            fCommon = (FTYPE) TRUE;     /* There are communals */
            if (vfCreated)
                apropUndef->au_flags |= UNDECIDED;
            else if (apropUndef->au_flags & UNDECIDED)
            {
                apropUndef->au_flags &= ~(UNDECIDED | WEAKEXT | SUBSTITUTE);
                apropUndef->au_flags |= STRONGEXT;
            }
            else if (apropUndef->au_flags & WEAKEXT)
                apropUndef->au_flags |= UNDECIDED;

            if (vfCreated || !(apropUndef->au_flags & COMMUNAL))
            {                           /* If not previously defined */
                apropUndef->au_flags |= COMMUNAL;
                                        /* Mark as communal */
                apropUndef->au_len = -1L;
#if ILINK
                apropUndef->u.au_module = imodFile;
                                        /* Save module index.  */
#endif
                DoCommon(apropUndef, length, (WORD) cbEl, sb);
#if SYMDEB
                if (fSymdeb && (sb[0] != '\0' && sb[1] > ' ' && sb[1] <= '~'))
                {
#if O68K
                    /* REVIEW: This should not be under the O68K flag. */
                    apropUndef->au_CVtype = itype;
#endif /* O68K */
                    DebPublic(mpextprop[extMac-1], rect);
                }
#endif
            }
            else
                DoCommon(apropUndef, length, (WORD) cbEl, sb);
        }
        else
        {
            mpextprop[extMac++] = vrprop;
            if (mpgsnfCod[((APROPNAMEPTR )apropUndef)->an_gsn])
                                        /* Communal matches code PUBDEF */
                DupErr(sb);             /* Duplicate definition */
        }
    }
}


    /****************************************************************
    *                                                               *
    *  LNmRc1:                                                      *
    *                                                               *
    *  This function  reads LNAME records and  stores the names in  *
    *  the  hash table.  The function does not return a meaningful  *
    *  value.                                                       *
    *  See p. 31 in "8086 Object Module Formats EPS."               *
    *                                                               *
    ****************************************************************/

void NEAR               LNmRc1(WORD fLocal)
{
    SBTYPE              lname;          /* Buffer for lnames */
    RBTYPE FAR          *lnameTab;
#if NOT ALIGN_REC
    FILE *f;
#endif
    WORD cb;


    while(cbRec > 1)                    /* While not at end of record */
    {
        if (lnameMac >= lnameMax)
        {
            if (lnameMax >= (LXIVK >> 2))
                Fatal(ER_nammax);
            lnameTab = (RBTYPE FAR *) FREALLOC(mplnamerhte, 2*lnameMax*sizeof(RBTYPE));
            if (lnameTab == NULL)
                Fatal(ER_nammax);
            mplnamerhte = lnameTab;
            lnameMax <<= 1;
        }

#if ALIGN_REC
        if (!fLocal)
        {
            cb = 1 + *pbRec;
            PropSymLookup(pbRec, ATTRNIL, TRUE);
            cbRec   -= cb;
            pbRec   += cb;
        }
        else
        {
            lname[0] = (BYTE)Gets();    /* Get name length */
            GetLocName(lname);  /* Read in text of name */
            PropSymLookup(lname, ATTRNIL, TRUE);
        }
#else
        f = bsInput;

        if (!fLocal && f->_cnt && (WORD)f->_cnt > (cb = 1 + *(BYTE *)f->_ptr))
        {
            PropSymLookup((BYTE *)f->_ptr, ATTRNIL, TRUE);
            f->_cnt -= cb;
            f->_ptr += cb;
            cbRec   -= cb;
        }
        else
        {
            lname[0] = (BYTE) Gets();   /* Get name length */
            DEBUGVALUE(B2W(lname[0]));  /* Length of name */
            if (lname[0] > SBLEN - 1)
                Fatal(ER_badobj);
            if (fLocal)
                GetLocName(lname);
            else
                GetBytes(&lname[1],B2W(lname[0]));
                                        /* Read in text of name */
            DEBUGSB(lname);             /* The name itself */
            PropSymLookup(lname, ATTRNIL, TRUE);
        }
#endif
                                        /* Insert symbol in hash table */
        mplnamerhte[lnameMac++] = vrhte;/* Save address of hash table entry */
    }
}

/*
 *  GetPropName - get the name of a property cell.
 *
 *  Return pointer to the result, stored in a static buffer.
 *  Alternate between two buffers so we can be used in multi-part
 *  messages.
 *  Terminate result with null byte.
 */

typedef BYTE            SBTYPE1[SBLEN+1];/* 1 extra for null byte */

BYTE * NEAR             GetPropName(ahte)
AHTEPTR                 ahte;
{
    static SBTYPE1      msgbuf[2];
    static int          toggle = 0;
    char                *p;

    while(ahte->attr != ATTRNIL)
        ahte = (AHTEPTR ) FetchSym(ahte->rhteNext,FALSE);
    p = msgbuf[toggle ^= 1];

    /* Copy string to buffer */

    FMEMCPY((char FAR *) p, ahte->cch, B2W(ahte->cch[0]) + 1);
    p[1 + B2W(p[0])] = '\0';            /* Null-terminate */
    return(p);
}

/*
 * SegUnreliable - warning message for 286 bug
 */

LOCAL void NEAR         SegUnreliable (apropSn)
APROPSNPTR              apropSn;
{
    static FTYPE        fReported = FALSE;


    MARKVP();                           /* Take care of current vp */
    if (!fReported)
    {
        OutWarn(ER_segunsf,1 + GetPropName(apropSn));
        fReported = (FTYPE) TRUE;
    }
}


/*** CheckClass - check segment's class name
*
* Purpose:
*   Check if we have the segment with the same name but with different
*   class name.
*
* Input:
*   apropSn      - real pointer to segment symbol table descriptor
*   rhteClass    - hash vector entry for class name
*
* Output:
*   Returns real pointer to segment symbol table descriptor.
*
* Exceptions:
*   Found same segment with different class name - display error.
*
* Notes:
*   None.
*
*************************************************************************/

APROPSNPTR              CheckClass(APROPSNPTR apropSn, RBTYPE rhteClass)
{
#if ILINK
    FTYPE fDifClass = FALSE;
#endif


    while(apropSn->as_attr != ATTRNIL)
    {                                   /* Look for class match or list end */
        if(apropSn->as_attr == ATTRPSN &&
          apropSn->as_rCla == rhteClass) break;
                                        /* Break if pub. with matching class */
        apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
                                        /* Advance down the list */
#if ILINK
        fDifClass = (FTYPE) TRUE;       /* Same seg exists with dif. class */
#endif
    }
#if ILINK
    if(fIncremental && fDifClass)
        OutError(ER_difcls, 1 + GetPropName(apropSn));
#endif
    if(apropSn->as_attr == ATTRNIL)
    {                                   /* If attribute not public */
        vfCreated = (FTYPE) TRUE;       /* New cell */
        apropSn = (APROPSNPTR ) PropAdd(vrhte, ATTRPSN);
                                        /* Segment is public */
    }
    return(apropSn);
}

#if OVERLAYS
void                    CheckOvl(APROPSNPTR apropSn, WORD iovFile)
{
    SNTYPE              gsn;
    WORD                fCanOverlayData;
    WORD                fOverlaySegment;


    if (fOverlays)
    {

        // First check if mapping tables are allocated.
        //
        //      SNTYPE  mposngsn[OSNMAX];
        //      SNTYPE  htgsnosn[OSNMAX];

        if (mposngsn == NULL && htgsnosn == NULL)
        {
            mposngsn = (SNTYPE FAR *) GetMem(2*OSNMAX*sizeof(SNTYPE));
            htgsnosn = (SNTYPE FAR *) &mposngsn[OSNMAX];
        }

        fCanOverlayData = IsDataFlg(apropSn->as_flags) &&
                          apropSn->as_ggr != ggrDGroup &&
                          apropSn->as_fExtra & FROM_DEF_FILE &&
                          apropSn->as_iov != (IOVTYPE) NOTIOVL;
        fOverlaySegment = IsCodeFlg(apropSn->as_flags) || fCanOverlayData;
        if (fOverlaySegment)
        {
            // We allow DATA segment overlaying ONLY if they ar NOT a members
            // of DGROUP and HAVE preassigned overlay number form .DEF file.
            // If segment is to be overlaid - check overlay number assigments

            if ((apropSn->as_iov != (IOVTYPE) NOTIOVL) && (iovFile != apropSn->as_iov))
            {
                if (apropSn->as_fExtra & FROM_DEF_FILE)
                {
                    // Use .DEF file overlay assigment

                    iovFile = apropSn->as_iov;
                }
                else
                {
                    // Use current .OBJ file overlay assigment

                    OutWarn(ER_badsegovl, 1 + GetPropName(apropSn), apropSn->as_iov, iovFile);
                }
            }
        }

        if (iovFile != IOVROOT && fOverlaySegment)
        {
            if (osnMac < OSNMAX)
            {
                gsn = (SNTYPE)(apropSn->as_gsn & ((LG2OSN << 1) - 1));
                                            // Get initial hash index
                while (htgsnosn[gsn] != SNNIL)
                {                           // While buckets are full
                        if ((gsn += HTDELTA) >= OSNMAX)
                        gsn -= OSNMAX;      // Calculate next hash index
                }
                htgsnosn[gsn] = osnMac;     // Save overlay segment number
                mposngsn[osnMac++] = apropSn->as_gsn;
                                            // Map osn to gsn
                apropSn->as_iov = iovFile;  // Save overlay number
            }
            else
            {
                if (osnMac++ == OSNMAX)
                    OutWarn(ER_osnmax, OSNMAX);
                apropSn->as_iov = IOVROOT;
            }
        }
        else
            apropSn->as_iov = IOVROOT;      // Not an overlay
    }
    else
        apropSn->as_iov = IOVROOT;
}
#endif


    /****************************************************************
    *                                                               *
    *  SegRc1:                                                      *
    *                                                               *
    *  This function processes SEGDEF records.                      *
    *  See pp. 32-35 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SegRc1(void)
{
    WORD                tysn;           /* ACBP byte */
    LNAMETYPE           lname;          /* Index into mplnamerhte */
    APROPSNPTR          apropSn;        /* Pointer to seg. record */
    SNTYPE              gsn;            /* Global SEGDEF number */
    WORD                align;          /* This contributuion alignment */
    WORD                prevAlign;      /* Logical segment aligment so FAR */
    WORD                comb;           /* Segment combine-type */
    DWORD               seglen;         /* Segment length */
    DWORD               contriblen;     /* Contribution length */
    DWORD               cbMaxPrev;      /* Segment length previously */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    SATYPE              saAbs;          /* Address for absolute seg */
    BYTE                flags;          /* Segment attribute flags */
    RBTYPE              rhteClass;      /* Class hash table address */
#if SYMDEB
    APROPFILEPTR        apropFile;
    CVINFO FAR          *pCvInfo;       // Pointer to CodeView information
#endif

    if(snMac >= SNMAX)
        Fatal(ER_segdef);
    tysn = Gets();                      /* Read in the ACBP byte */
    align = (WORD) ((tysn >> 5) & 7);   /* Get the alignment field */
    ASSERT(align != 6);                 /* Not supported by this linker */
    if(align == ALGNABS)                /* If absolute LSEG */
    {
        saAbs = (SATYPE) WGets();       /* Get the frame number */
        Gets();                         /* Punt the frame offset */
    }
#if OMF386
    if(rect & 1)                        /* If 386 extension */
        seglen = LGets();
    else
#endif
        seglen = (DWORD) WGets();       /* Get segment length */
    if(tysn & BIGBIT)
    {
#if OMF386
        if(rect & 1)
            seglen = CBMAXSEG32 + 1;    /* Force fatal error below */
        else
#endif
        seglen = LXIVK;                 /* Sixty-four K */
    }
    contriblen = seglen;
    lname = (LNAMETYPE) GetIndex(1, (WORD) (lnameMac - 1));
                                        /* Get segment name index */
    ahte = (AHTEPTR ) FetchSym(mplnamerhte[lname],FALSE);
    rhteClass = mplnamerhte[(LNAMETYPE) GetIndex(1, (WORD) (lnameMac - 1))];
                                        /* Get class name rhte */
#if SYMDEB
    if (IsDebSeg(rhteClass, mplnamerhte[lname]))
    {                                   /* If MS debug segment */
        mpsngsn[snMac++] = 0;
        if (fSymdeb)                    /* If debugger support on */
        {
            apropFile = (APROPFILEPTR) FetchSym(vrpropFile, TRUE);
            if (apropFile->af_cvInfo == NULL)
                apropFile->af_cvInfo = (CVINFO FAR *) GetMem(sizeof(CVINFO));
            pCvInfo = apropFile->af_cvInfo;
            if (rhteClass == rhteDebTyp)
            {
                // "DEBTYP"

                pCvInfo->cv_cbTyp = (DWORD) seglen;
#ifdef RGMI_IN_PLACE
                pCvInfo->cv_typ = NULL; // defer allocation until pass 2 (!)
#else
                pCvInfo->cv_typ = GetMem(seglen);
#endif
            }
            else if (rhteClass == rhteDebSym)
            {
                // "DEBSYM"

                pCvInfo->cv_cbSym = (DWORD) seglen;
#ifdef RGMI_IN_PLACE
                pCvInfo->cv_sym = NULL; // defer allocation until pass 2 (!)
#else
                pCvInfo->cv_sym = GetMem(seglen);
#endif
            }
        }
        SkipBytes((WORD) (cbRec - 1));
        return;
    }
#endif
    GetIndex(0, (WORD) (lnameMac - 1)); /* Eat overlay name index */
    DEBUGVALUE(seglen);                 /* Debug info */
    DEBUGVALUE(lname);                  /* Debug info */
    ahte = (AHTEPTR ) FetchSym(rhteClass,FALSE);
                                        /* Fetch hash table entry from VM */
    if(SbSuffix(GetFarSb(ahte->cch),"\004CODE",TRUE))
        flags = FCODE;
    else
        flags = 0;
#if OMF386
    /* Remember if 32-bit segment */
    if(tysn & CODE386BIT)
    {
        flags |= FCODE386;
#if EXE386
        /* Must set f386 here because newdeb needs to know in pass 1 */
        f386 = (FTYPE) TRUE;
#endif
    }
#endif
#if ILINK
    else
    if (fIncremental && !fLibraryFile && seglen && seglen != LXIVK)
    {
        /* Add padding to non-zero-length, non-library, non-64K segment
         * contributions.  (64K from huge model)
         * UNDONE:  More general overflow check, accounting for previous
         * UNDONE:  contributions.
         */
        seglen += (flags & FCODE) ? cbPadCode : cbPadData;
    }
#endif
    switch(align)                       /* Switch on alignment type */
    {
        case ALGNABS:                   /* Absolute LSEG */
        case ALGNBYT:                   /* Relocatable byte-aligned LSEG */
        case ALGNWRD:                   /* Relocatable word-aligned LSEG */
        case ALGNPAR:                   /* Relocatable para-aligned LSEG */
        case ALGNPAG:                   /* Relocatable page-aligned LSEG */
#if OMF386
        case ALGNDBL:                   /* double-word-aligned */
#endif
            break;

    default:                            /* ABSMAS, LTL LSEG, or error */
        mpsngsn[snMac++] = 0;
        return;
    }
    ++snkey;                            /* Increment segment i.d. key */
    if(comb = (WORD) ((tysn >> 2) & 7)) /* If "public" segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname], ATTRPSN, (FTYPE) TRUE);
                                        /* Look up symbol table entry */
        if(!vfCreated)                  /* If it was already there */
        {
            apropSn = CheckClass(apropSn, rhteClass);
#if OSEGEXE
            if (apropSn->as_fExtra & FROM_DEF_FILE)
            {                           /* Override .DEF file segment attributes */
                mpgsnfCod[apropSn->as_gsn] = (FTYPE) (flags & FCODE);
                apropSn->as_tysn = (TYSNTYPE) tysn;
                                        /* Save ACBP field */
#if NOT EXE386
                if (flags & FCODE386 || seglen > LXIVK)
                    apropSn->as_flags |= NS32BIT;
                                        /* Set Big/Default bit */
#endif
                apropSn->as_key = snkey;/* Save the key value */
            }
#endif
        }
    }
    else                                /* Else if private segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname], ATTRPSN, (FTYPE) FALSE);
        /* Check if defined in .def file - caviar:4767             */
        if(apropSn && apropSn->as_fExtra & FROM_DEF_FILE)
        {
            OutWarn(ER_farovl, GetPropName(apropSn)+1, "root");
        }

        vfCreated = (FTYPE) TRUE;       /* This is a new segment */
        apropSn = (APROPSNPTR ) PropAdd(mplnamerhte[lname],ATTRLSN);
    }
    if(vfCreated)                       /* If a new cell was created */
    {
        if(gsnMac >= gsnMax)
                Fatal(ER_segmax);
                                        /* Check for table overflow */
        apropSn->as_gsn = gsnMac;       /* Assign new global SEGDEF number */
        mpgsnrprop[gsnMac++] = vrprop;  /* Save address of property list */
        apropSn->as_rCla = rhteClass;   /* Save ptr to class hash tab ent */
                                        /* Superclass hash table entry */
        DEBUGVALUE(apropSn);            /* Debug info */
        DEBUGVALUE(apropSn->as_rCla);   /* Debug info */
        apropSn->as_tysn = (TYSNTYPE) tysn;
                                        /* Save ACBP field */
        mpgsnfCod[apropSn->as_gsn] = (FTYPE) (flags & FCODE);
#if OSEGEXE
#if EXE386
        apropSn->as_flags = flags & FCODE ? dfCode : dfData;
                                        /* Assume default flags */
#else
        apropSn->as_flags = (WORD) (flags & FCODE ? dfCode : dfData);
                                        /* Assume default flags */
        if (flags & FCODE386 || seglen > LXIVK)
            apropSn->as_flags |= NS32BIT;
                                        /* Set Big/Default bit */
#endif
#else
        apropSn->as_flags = flags;
#endif
        apropSn->as_key = snkey;        /* Save the key value */
        apropSn->as_ComDat = NULL;      /* No COMDATs yet */
#if OVERLAYS
        apropSn->as_iov = (IOVTYPE) NOTIOVL;
                                        // No overlay assigment yet
#endif
    }
#if OMF386 AND NOT EXE386
    else
    {
        /* If segment defined as both 16- and 32-bit, fatal error */

        WORD    fNew, fOld;

        fNew = (WORD) ((flags & FCODE386) ? 1 : 0);
        fOld = (WORD) (
#if OSEGEXE
               (apropSn->as_flags & NS32BIT) ?
#else
               (apropSn->as_flags & FCODE386) ?
#endif
                                                1 : 0);
            if (fNew != fOld)
                Fatal(ER_16seg32,1 + GetPropName(apropSn));
    }
#endif
#if OVERLAYS
    CheckOvl(apropSn, iovFile);
#endif
#if SYMDEB
    if (seglen && (flags & FCODE))
        cSegCode++;                     /* Count code seg's, so CV gets proper */
                                        /* number of sstModule subsections */
#endif
    gsn = apropSn->as_gsn;              /* Save global SEGDEF no. */
    if(comb == COMBSTK)                 /* If segment combines like stack */
    {
        gsnStack = gsn;                 /* Set stack global SEGDEF number */
        align = ALGNBYT;                /* Force to byte alignment */
        if (cbStack)
            seglen = 0L;                /* Ignore stack segment size if /STACK given */
    }
    else if(comb == COMBCOM)            /* If segment combines like common */
    {
        cbMaxPrev = apropSn->as_cbMx;   /* Get previous segment size */
        apropSn->as_cbMx = 0L;          /* Set size to zero */
        if(seglen < cbMaxPrev) seglen = cbMaxPrev;
                                        /* Take the larger of the two sizes */
    }
    cbMaxPrev = apropSn->as_cbMx;       /* Get previous size */
    if(align == ALGNWRD) cbMaxPrev = (~0L<<1) & (cbMaxPrev + (1<<1) - 1);
                                        /* Round size up to word boundary */
#if OMF386
    else if(align == ALGNDBL) cbMaxPrev = (~0L<<2) & (cbMaxPrev + (1<<2) - 1);
#endif                                  /* Round size up to double boundary */
    else if(align == ALGNPAR) cbMaxPrev = (~0L<<4) & (cbMaxPrev + (1<<4) - 1);
                                        /* Round size up to para. boundary */
    else if(align == ALGNPAG) cbMaxPrev = (~0L<<8) & (cbMaxPrev + (1<<8) - 1);
                                        /* Round size up to word boundary */

    prevAlign = (WORD) ((apropSn->as_tysn >> 5) & 7);

    // In Assign Addresses pass the aligment of the whole logical
    // segment has to be equal to the biggest aligment of all
    // contributions for given logical segment. Here we are checking
    // if current contribution has bigger aligment then the
    // contributions seen so FAR. The bigger aligment criteria is a
    // bit tricky - the aligment constants are defined as follows:
    //
    //      1 - byte aligment
    //      2 - word aligment
    //      3 - paragraph aligment
    //      4 - page aligment
    //      5 - double word aligment
    //
    // The aligment ordering is as follows:
    //
    //      byte < word < dword < para < page
    //        1     2       5       3      4
    //

    // If align greater than prev. val.

    if (prevAlign == ALGNDBL || align == ALGNDBL)
    {
        if (prevAlign == ALGNDBL && align >= ALGNPAR)
            apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 31) | (align << 5));
                                        /* Use new value */
        else if (align == ALGNDBL && prevAlign <= ALGNWRD)
            apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 31) | (align << 5));
                                        /* Use new value */
    }
    else if (align > prevAlign)
        apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 31) | (align << 5));
                                        /* Use new value */

    if (align != ALGNABS)               /* If not an absolute LSEG */
    {
        seglen += cbMaxPrev;
#if EXE386 OR OMF386
        if ((flags & FCODE386) != 0
#if O68K
            && iMacType == MAC_NONE
#endif
        )
        {
#if EXE386
            if (seglen < cbMaxPrev)     /* errmsg takes # megabytes */
                Fatal(ER_seg386, 1 + GetPropName(apropSn), 1 << (LG2SEG32 - 20));
#else
            if (seglen > CBMAXSEG32)    /* errmsg takes # megabytes */
                Fatal(ER_seg386,1 + GetPropName(apropSn),1 << (LG2SEG32 - 20));
#endif
        }
        else
#endif
             if (seglen > LXIVK)
             {
                if (comb != COMBSTK)
                    OutError(ER_segsize,1 + GetPropName(apropSn));
                                        /* Check for segment overflow */
                else
                {
                    if (!cbStack)
                        OutWarn(ER_stack64);
                    cbStack = LXIVK - 2;/* Assume 64k stack segment */
                }
             }
        apropSn->as_cbMx = seglen;      /* Save new segment size */
        /*
         * If this is a 16-bit code segment, check for unreliable
         * lengths due to the 286 bug.  For DOS exes, assume worst
         * case, i.e. real mode limit.
         */
        if((flags & FCODE) && !(EXE386 && (flags & FCODE386)))
#if OIAPX286
            if(seglen == LXIVK)
#else
            if(seglen > LXIVK - 36)
#endif
                SegUnreliable(apropSn);
    }
    else apropSn->as_cbMx = (long) saAbs;
                                        /* "Hack to save origin of abs seg" */
    mpgsndra[gsn] = cbMaxPrev;          /* Save previous size */
    mpsngsn[snMac++] = gsn;             /* Map SEGDEF no to global SEGDEF no */
    MARKVP();                           /* Virtual page has changed */
    if (fFullMap && contriblen)
        AddContributor(gsn, (unsigned long) -1L, contriblen);
}

    /****************************************************************
    *                                                               *
    *  GrpRc1:                                                      *
    *                                                               *
    *  This function processes GRPDEF records on pass 1.            *
    *  See pp. 36-39 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         GrpRc1(void)
{
    LNAMETYPE           lnameGroup;     /* Group LNAME number */
    SNTYPE              sn;             /* Group (local) segment number */
    APROPSNPTR          apropSn;
    APROPGROUPPTR       apropGroup;
    GRTYPE              ggr;            /* Global GRPDEF number */
    WORD                gcdesc;         /* GRPDEF component descriptor */
#if EXE386
    BYTE                *pGrName;       /* Group name */
#endif


    if(grMac >= GRMAX) Fatal(ER_grpdef);
    lnameGroup = GetIndex(1, (WORD) (lnameMac - 1));
                                        /* Read in group name index */
    apropGroup = (APROPGROUPPTR )
      PropRhteLookup(mplnamerhte[lnameGroup], ATTRGRP, (FTYPE) TRUE);
                                        /* Look up cell in hash table */
    if(vfCreated)                       /* If entry did not exist before */
    {
        if(ggrMac >= GGRMAX) Fatal(ER_grpmax);
        apropGroup->ag_ggr = ggrMac++;  /* Save global GRPDEF no. */
    }
    ggr = apropGroup->ag_ggr;           /* Get global GRPDEF no. */
    mpggrrhte[ggr] = mplnamerhte[lnameGroup];
                                        /* Save pointer to name */
    mpgrggr[grMac++] = ggr;             /* Map local to global */
#if EXE386
    /* Check for pseudo-group FLAT here */
    pGrName = GetFarSb(((AHTEPTR)(FetchSym(mpggrrhte[ggr], FALSE)))->cch);
    if (SbCompare(pGrName, sbFlat, TRUE))
        ggrFlat = ggr;
#endif
    while(cbRec > 1)                    /* While not at end of record */
    {
        gcdesc = Gets();                /* Read in the descriptor */
        ASSERT(gcdesc == 0xFF);         /* Linker doesn't handle others */
        sn = GetIndex(1,snMac);         /* Get local SEGDEF index */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[mpsngsn[sn]],TRUE);
                                        /* Fetch from virt mem */
        if(apropSn->as_ggr == GRNIL)
        {                               /* Store global GRPDEF no. if none */
            apropSn->as_ggr = ggr;
#if OSEGEXE
            /*
             * Check if a segment which is part of DGROUP was defined
             * as class "CODE", also if it was given a sharing attribute
             * that conflicts with the autodata type.
             * Could only happen if seg defined in a def-file.  Must be
             * done here because only now do we know that it's in DGROUP.
             */
            if(ggr == ggrDGroup && (apropSn->as_fExtra & FROM_DEF_FILE))
            {

#if EXE386
                if (IsEXECUTABLE(apropSn->as_flags))
                {
                    SetREADABLE(apropSn->as_flags);
                    SetWRITABLE(apropSn->as_flags);
                    apropSn->as_rCla = rhteBegdata;
                    mpgsnfCod[apropSn->as_gsn] = FALSE;
                    OutWarn(ER_cod2dat,1 + GetPropName(apropSn));
                    apropSn = (APROPSNPTR )
                        FetchSym(mpgsnrprop[mpsngsn[sn]],TRUE);
                }
                if (((vFlags & NESOLO) && !IsSHARED(apropSn->as_flags)) ||
                    ((vFlags & NEINST) && IsSHARED(apropSn->as_flags)))
                {
                    if (vFlags & NESOLO)
                        SetSHARED(apropSn->as_flags);
                    else
                        apropSn->as_flags &= ~OBJ_SHARED;
                    OutWarn(ER_adcvt,1 + GetPropName(apropSn));
                }

#else
                if((apropSn->as_flags & NSTYPE) != NSDATA)
                {
                    apropSn->as_flags &= ~NSTYPE;
                    apropSn->as_flags |= NSDATA;
                    apropSn->as_rCla = rhteBegdata;
                    mpgsnfCod[apropSn->as_gsn] = FALSE;
                    OutWarn(ER_cod2dat,1 + GetPropName(apropSn));
                    apropSn = (APROPSNPTR )
                        FetchSym(mpgsnrprop[mpsngsn[sn]],TRUE);
                }
                if(((vFlags & NESOLO) && !(apropSn->as_flags & NSSHARED)) ||
                    ((vFlags & NEINST) && (apropSn->as_flags & NSSHARED)))
                {
                    if(vFlags & NESOLO) apropSn->as_flags |= NSSHARED;
                    else apropSn->as_flags &= ~NSSHARED;
                    OutWarn(ER_adcvt,1 + GetPropName(apropSn));
                }
#endif /* EXE386 */
            }
#endif /* OSEGEXE */
        }
        else if (apropSn->as_ggr != ggr)/* If segment belongs to other group */
        {
            if(fLstFileOpen) fflush(bsLst);
                                        /* Flush list file, if any */
            OutWarn(ER_grpmul,1 + GetPropName(apropSn));
        }
    }
}

void NEAR               DupErr(BYTE *sb)/* Duplicate definition error */
                                        /* Symbol to which error refers */
{
    BSTYPE              bsTmp;          /* Temporary file pointer */
    MSGTYPE             msg;            /* Message to use */
#if OSMSDOS
    extern char         *pExtDic;       /* Pointer to extended dictionary */
#endif
    SBTYPE              sbUndecor;      /* a buffer for undecorated name */

    /* If this module is in an extended dictionary, suggest /NOEXT in error
     * message.
     */
    msg = (MSGTYPE) (
#if OSMSDOS
          pExtDic ? ER_symdup1 :
#endif
                    ER_symdup);

    UndecorateSb((char FAR*) sb, (char FAR*) sbUndecor, sizeof(sbUndecor) );

    OutError(msg,1 + sbUndecor);
    if(fLstFileOpen && bsErr != bsLst)
    {
        bsTmp = bsErr;
        bsErr = bsLst;
        OutError(msg,1 + sbUndecor);
        bsErr = bsTmp;
    }
}






    /****************************************************************
    *                                                               *
    *  PubRc1:                                                      *
    *                                                               *
    *  This function processes PUBDEF records on pass 1.            *
    *  See pp. 44-46 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         PubRc1(void)
{
    GRTYPE              ggr;            /* Group definition number */
    SNTYPE              sn;             /* Local SEGDEF no. */
    SNTYPE              gsn;            /* Global SEGDEF no. */
    RATYPE              dra;
    SBTYPE              sb;             /* Public symbol */
    RATYPE              ra;             /* Public symbol offset */
    APROPNAMEPTR        apropName;      /* Table entry for symbol name */
    WORD                type;           /* Local type no. */
    int                 fSkipCv = FALSE;/* Don't register DATA PUBDEF if a COMDEF
                                           for that symbol has already been seen */


    DEBUGVALUE(grMac - 1);              /* Debug info */
    ggr = (GRTYPE) GetIndex(0, (WORD) (grMac - 1));/* Get group index */
    DEBUGVALUE(ggr);                    /* Debug info */
    if (!(sn = GetIndex(0, (WORD) (snMac - 1))))/* If frame number present */
    {
        gsn = 0;                        /* No global SEGDEF no. */
        dra = 0;
        SkipBytes(2);                   /* Skip the frame number */
    }
    else                                /* Else if local SEGDEF no. given */
    {
        if (ggr != GRNIL)
            ggr = mpgrggr[ggr];         /* If group specified, get global no */
        gsn = mpsngsn[sn];              /* Get global SEGDEF no. */
        dra = mpgsndra[gsn];
    }
    DEBUGVALUE(cbRec);                  /* Debug info */
    while (cbRec > 1)                   /* While there are symbols left */
    {
        sb[0] = (BYTE) Gets();          /* Get symbol length */
        if (TYPEOF(rect) == PUBDEF)
            GetBytes(&sb[1],B2W(sb[0]));/* Read in symbol text */
        else
            GetLocName(sb);             /* Transform local name */
#if CMDXENIX
        if(symlen && B2W(sb[0]) > symlen) sb[0] = symlen;
                                        /* Truncate if necessary */
#endif
#if OMF386
        if (rect & 1)
            ra = LGets();
        else
#endif
            ra = WGets();               /* Get symbol segment offset */
        type = GetIndex(0,0x7FFF);      /* Get type index */
        if (!vfNewOMF)
            type = 0;

        /* Look for symbol among undefined */

        apropName = (APROPNAMEPTR) PropSymLookup(sb, ATTRUND, FALSE);

        if (apropName != PROPNIL)       /* Symbol known to be undefined */
        {
            if (((APROPUNDEFPTR )apropName)->au_flags & COMMUNAL)
            {
                if (mpgsnfCod[gsn])
                    DupErr(sb);         /* Communal matches code PUBDEF */
                fSkipCv = TRUE;
            }
            vfCreated = (FTYPE) TRUE;
        }
        else
        {
            /* Look for symbol among ALIASes */

            if (vrhte == RHTENIL)
                apropName = PROPNIL;
            else
                apropName = (APROPNAMEPTR) PropRhteLookup(vrhte, ATTRALIAS, FALSE);

            if (apropName != PROPNIL)
            {
#if FDEBUG
                if (fDebug)
                {
                    sb[sb[0] + 1] = '\0';
                    OutWarn(ER_ignoalias, &sb[1]);
                }
#endif
                continue;
            }

            else if (vrhte == RHTENIL)
            {
               apropName = (APROPNAMEPTR) PropSymLookup(sb, ATTRPNM, TRUE);
            }

            else
            {
                apropName = (APROPNAMEPTR) PropRhteLookup(vrhte, ATTRPNM, TRUE);
            }
        }

        if (vfCreated)                  /* If new PUBNAM entry created or */
        {                               /* old UNDEF entry to modify */

            // If printable symbol, increment counter and set flags

            if (sb[0] != '\0' && sb[1] > ' ' && sb[1] <= '~')
            {
                ++pubMac;
                apropName->an_flags = FPRINT;
            }
            else
            {
#if ILINK
                ++locMac;               /* Included in .SYM file */
#endif
            }

            apropName->an_attr = ATTRPNM;
                                        /* Symbol is a public name */
            apropName->an_ra = ra + dra;/* Give symbol its adjusted offset */
            apropName->an_gsn = gsn;    /* Save its global SEGDEF no. */
            apropName->an_ggr = ggr;    /* Save its global SEGDEF no. */
#if OVERLAYS
            apropName->an_thunk = THUNKNIL;
#endif
#if ILINK
            apropName->an_module = imodFile;
#endif
            MARKVP();                   /* Mark virtual page as changed */
#if SYMDEB
            if (fSymdeb && (apropName->an_flags & FPRINT) && !fSkipPublics && !fSkipCv)
            {
                // Remember CV type index

                apropName->an_CVtype = type;
                DebPublic(vrprop, rect);
            }
#endif
        }
        else if(apropName->an_gsn != gsn || apropName->an_ra != ra + dra)
        {
            DupErr(sb);                 /* Definitions do not match */
        }
    }
}

    /****************************************************************
    *                                                               *
    *  ExtRc1:                                                      *
    *                                                               *
    *  This function processes EXTDEF records on pass 1.            *
    *  See pp. 47-48 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         ExtRc1(void)
{
    SBTYPE              sb;             /* EXTDEF symbol */
    APROPUNDEFPTR       apropUndef;     /* Pointer to symbol entry */
    APROPALIASPTR       apropAlias;     /* Pointer to symbol entry */
    APROPNAMEPTR        apropName;      /* Pointer to symbol entry */
    APROPCOMDATPTR      apropComdat;    /* pointer to symbol entry */
    WORD                itype;          /* Type index */
    RBTYPE              rhte;           /* Virt. addr. of hash table entry */
    AHTEPTR             ahte;           // Symbol table hash entry

    while (cbRec > 1)                   /* While there are symbols left */
    {
        if (extMac >= EXTMAX - 1)       /* Check for table overflow */
            Fatal(ER_extdef);

        if (TYPEOF(rect) == CEXTDEF)
        {
            itype = GetIndex(0, (WORD) (lnameMac - 1));
            rhte = mplnamerhte[itype];
            ahte = (AHTEPTR) FetchSym(rhte, FALSE);
            FMEMCPY((char FAR *) sb, ahte->cch, ahte->cch[0] + 1);

            /* Look for a matching PUBDEF */

            apropUndef = (APROPUNDEFPTR) PropRhteLookup(rhte, ATTRPNM, FALSE);
        }
        else
        {
            rhte = RHTENIL;

            sb[0] = (BYTE) Gets();      /* Get symbol length */
            if (TYPEOF(rect) == EXTDEF)
                GetBytes(&sb[1], B2W(sb[0]));
                                        /* Read in text of symbol */
            else
                GetLocName(sb);         /* Get local name */
#if CMDXENIX
            if (symlen && B2W(sb[0]) > symlen)
                sb[0] = symlen;         /* Truncate if necessary */
#endif
            /* Look for a matching PUBDEF */

            apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRPNM, FALSE);
        }

        DEBUGSB(sb);                    /* Print symbol */

        if (!vfNewOMF)                  /* If old-style OMF */
            itype = GetIndex(0, (WORD) (typMac - 1));/* Get type index */
        else
            itype = GetIndex(0, 0x7FFF); /* Get type index (any value OK) */

#if FALSE
        if (fDebug)
        {
            sb[sb[0]+1] = '\0';
            fprintf(stdout, "\r\n%s has index = %u", sb+1, extMac);
        }
#endif

        apropName  = PROPNIL;

        if (apropUndef == PROPNIL)      /* If there isn't one */
        {
            /* Look for a matching ALIAS */

            if (vrhte == RHTENIL)
                apropAlias = PROPNIL;
            else
                apropAlias = (APROPALIASPTR) PropRhteLookup(vrhte, ATTRALIAS, FALSE);

            if (apropAlias != PROPNIL)
            {
                /* ALIAS matches this EXTDEF */

                mpextprop[extMac++] = apropAlias->al_sym;
                apropName = (APROPNAMEPTR) FetchSym(apropAlias->al_sym, TRUE);
                if (apropName->an_attr == ATTRPNM)
                {
                    // If substitute name is a PUBDEF then use it

                    if (!vfNewOMF && itype && (mpitypelen[itype] > 0L) &&
                        mpgsnfCod[apropName->an_gsn])
                                         /* Communal matches code PUBDEF */
                        DupErr(sb);      /* Duplicate definition */
                }
                else
                {
                    // The substitute name is an EXTDEF
                    // Mark substitute name so it causes the library search, because
                    // we don't know neither the alias nor the substitute

                    apropUndef = (APROPUNDEFPTR) apropName;
                    apropUndef->au_flags |= SEARCH_LIB;
                    apropName = PROPNIL;
#if NEW_LIB_SEARCH
                    if (fStoreUndefsInLookaside)
                        StoreUndef((APROPNAMEPTR)apropUndef, RhteFromProp((APROPPTR)apropUndef),0,0);
#endif

#ifdef DEBUG_SHOWALIAS
                    sb[sb[0]+1] = '\0';
                    fprintf(stderr, "extdef alias: %s\r\n", sb+1);
                    fflush(stderr);
#endif
                }
            }
            else
            {
                /* Insert as undefined symbol */

                if (vrhte == RHTENIL)
                    apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRUND, TRUE);
                else
                    apropUndef = (APROPUNDEFPTR) PropRhteLookup(vrhte, ATTRUND, TRUE);

                mpextprop[extMac++] = vrprop;
                if(vfCreated)
                {
                    apropUndef->au_flags |= UNDECIDED;
                    apropUndef->au_len = -1L;
#if NEWLIST
                    apropUndef->u.au_rbNxt = rbLstUndef;
                    rbLstUndef = vrprop;
#endif
                }
                else if (apropUndef->au_flags & UNDECIDED)
                {
                    apropUndef->au_flags &= ~(UNDECIDED | WEAKEXT | SUBSTITUTE);
                    apropUndef->au_flags |= STRONGEXT;

#if NEW_LIB_SEARCH
                    if (fStoreUndefsInLookaside)
                        StoreUndef((APROPNAMEPTR)apropUndef, RhteFromProp((APROPPTR)apropUndef),0,0);
#endif
                }
                else if (apropUndef->au_flags & WEAKEXT)
                    apropUndef->au_flags |= UNDECIDED;

                if (vfNewOMF) continue; /* Skip if module uses COMDEFs */
                if(itype)               /* If there is reference to TYPDEF */
                    DoCommon(apropUndef, mpitypelen[itype],
                        (WORD) (mpityptyp[itype] ? mpitypelen[mpityptyp[itype]] : 0),
                        sb);

                if (apropUndef->au_len > 0L)
                    apropUndef->au_flags |= COMMUNAL;
                                        /* Mark as true communal or not */
                MARKVP();               /* Mark virt page as changed */
            }
        }
        else
        {
            apropName = (APROPNAMEPTR ) apropUndef;
            mpextprop[extMac++] = vrprop;
            if (!vfNewOMF && itype && (mpitypelen[itype] > 0L) &&
                mpgsnfCod[((APROPNAMEPTR )apropUndef)->an_gsn])
                                        /* Communal matches code PUBDEF */
                DupErr(sb);             /* Duplicate definition */
        }

        // If we are processing CEXTDEF/EXTDEF and there is public symbol
        // matching the CEXTDEF/EXTDEF symbol, then mark COMDAT descriptor
        // as referenced

        if (apropName != PROPNIL)
        {
            apropComdat = (APROPCOMDATPTR) PropRhteLookup(vrhte, ATTRCOMDAT,
#if TCE
             FALSE
#else
             TRUE
#endif
             );

            if (apropComdat != PROPNIL)
            {
                apropComdat->ac_flags |= REFERENCED_BIT;
#if TCE_DEBUG
                fprintf(stdout, "\r\nEXTDEF1 referencing '%s' ", 1+GetPropName(apropComdat));
#endif
            }
        }
    }
}

#if OSEGEXE AND NOT QCLINK
    /****************************************************************
    *                                                               *
    *  imprc1:                                                      *
    *                                                               *
    *  This function processes  Microsoft OMF extension records of  *
    *  type IMPDEF (i.e. IMPort DEFinition records).                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         imprc1(void)
{
    SBTYPE              sbInt;          /* Internal name */
    SBTYPE              sbMod;          /* Module name */
    SBTYPE              sbImp;          /* Imported name */
    FTYPE               fOrd;           /* Import-by-ordinal flag */

#if ODOS3EXE
    fNewExe = (FTYPE) TRUE;             /* Import forces new-format exe */
#endif
    fOrd = (FTYPE) Gets();              /* Get ordinal flag */
    sbInt[0] = (BYTE) Gets();           /* Get length of internal name */
    GetBytes(&sbInt[1],B2W(sbInt[0]));  /* Get the internal name */
    sbMod[0] = (BYTE) Gets();           /* Get length of module name */
    GetBytes(&sbMod[1],B2W(sbMod[0]));  /* Get the module name */
    if(!(fOrd & 0x1))                   /* If import by name */
    {
        sbImp[0] = (BYTE) Gets();       /* Get length of imported name */
        if(sbImp[0] != '\0')            /* If names differ */
        {
            GetBytes(&sbImp[1],B2W(sbImp[0]));
                                        /* Get the imported name */
#if EXE386
            NewImport(sbImp,0,sbMod,sbInt, (fOrd & 0x2));
#else
            NewImport(sbImp,0,sbMod,sbInt);
#endif
                                        /* Enter new import */
        }
        else
#if EXE386
            NewImport(sbInt,0,sbMod,sbInt, (fOrd & 0x2));
#else
            NewImport(sbInt,0,sbMod,sbInt);
#endif
                                        /* Enter new import */
    }
    else
#if EXE386
        NewImport(NULL,WGets(),sbMod,sbInt, (fOrd & 0x2));
#else
        NewImport(NULL,WGets(),sbMod,sbInt);
#endif
                                        /* Else import by ordinal */
}


    /****************************************************************
    *                                                               *
    *  exprc1:                                                      *
    *                                                               *
    *  This function processes  Microsoft OMF extension records of  *
    *  type EXPDEF (i.e. EXPort DEFinition records).                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         exprc1(void)
{
    SBTYPE              sbInt;          /* Internal name */
    SBTYPE              sbExp;          /* Exported name */
    WORD                OrdNum;         /* Ordinal number */
    WORD                fRec;           /* Record flags */


#if ODOS3EXE
    fNewExe = (FTYPE) TRUE;             /* Export forces new-format exe */
#endif
    fRec = (BYTE) Gets();               /* Get record flags */
    sbExp[0] = (BYTE) Gets();           /* Get length of exported name */
    GetBytes(&sbExp[1],B2W(sbExp[0]));  /* Get the exported name */
    sbInt[0] = (BYTE) Gets();           /* Get length of internal name */
    if (sbInt[0])
        GetBytes(&sbInt[1],B2W(sbInt[0]));
                                        /* Get the internal name */
    if (fRec & 0x80)
    {                                   /* If ordinal number specified */
        OrdNum = WGets();               /* Read it and set highest bit */
        OrdNum |= ((fRec & 0x40) << 1); /* if resident name */
    }
    else
        OrdNum = 0;                     /* No ordinal number specified */

    // Convert flags:
    // OMF flags:
    //        80h = set if ordinal number specified
    //        40h = set if RESIDENTNAME
    //        20h = set if NODATA
    //        1Fh = # of parameter words
    // EXE flags:
    //        01h = set if entry is exported
    //        02h = set if entry uses global (shared) data segment (!NODATA)
    //        F8h = # of parameter words
    //
    // Since the logic is reversed for the NODATA flag, we toggle bit 0x20
    // in the OMF flags via the expression ((fRec & 0x20) ^ 0x20).

    fRec = (BYTE) (((fRec & 0x1f) << 3) | (((fRec & 0x20) ^ 0x20) >> 4) | 1);

    // Mark fRec, so NewExport doesn't try to free name buffers

    fRec |= 0x8000;

    if (sbInt[0])
        NewExport(sbExp, sbInt, OrdNum, fRec);
    else
        NewExport(sbExp, NULL, OrdNum, fRec);
}
#endif /* OSEGEXE */



    /****************************************************************
    *                                                               *
    *  ComRc1:                                                      *
    *                                                               *
    *  This function processes COMENT records on pass 1.            *
    *  See pp. 86-87 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

#pragma check_stack(on)

LOCAL void NEAR         ComRc1(void)
{
#if OXOUT OR OIAPX286
    WORD                mismatch;       /* Model mismatch flag */
#endif
#if FALSE
    static BYTE         modtype = 0;    /* Initial model type */
    BYTE                curmodtype;     /* Current model type */
#endif
    SBTYPE              text;           /* Comment text */
    SBTYPE              LibName;
    APROPFILEPTR        aprop;
    WORD                iextWeak;
    WORD                iextDefRes;
    APROPUNDEFPTR       undefName;
    FTYPE               fIgnoreCaseSave;
    BYTE                flags;
    void FAR            *pTmp;
#if ILINK
    SNTYPE              noPadSn;
    APROPSNPTR          apropSn;        /* Pointer to seg. record */
#endif
#if O68K
    BYTE                chModel;
#endif /* O68K */


    Gets();                             /* Skip byte 1 of comment type field */
    switch(Gets())                      /* Switch on comment class */
    {
#if OEXE
        case 0:                         /* Translator record */
            if(fNewExe)
                break;
#if ODOS3EXE
            text[0] = (BYTE) (cbRec - 1);/* Get length of comment */
            GetBytes(&text[1],(WORD)(cbRec - 1));/* Read in text of comment */
            /*
             * If translator is pre-3.30 MS/IBM PASCAL or FORTRAN,
             * force on /DS and /NOG.
             */
            if(SbCompare(text,"\011MS PASCAL", TRUE) ||
                        SbCompare(text,"\012FORTRAN 77", TRUE))
                vfDSAlloc = fNoGrpAssoc = (FTYPE) TRUE;
#endif
            break;
#endif
        case 0x81:                      /* Library specifier */
#if OSMSDOS OR OSPCDOS
        case 0x9F:                      /* Library specifier (alt.) */
#endif
            text[0] = (BYTE) (cbRec - 1);/* Get length of comment */
            if (text[0] == 0)
                break;                  /* Skip empty spec */
            GetBytes(&text[1], (WORD) (cbRec - 1));/* Read in text of comment */
                                        /* Add name to search list */
#if CMDMSDOS
            strcpy(LibName, sbDotLib);
            UpdateFileParts(LibName, text);
#endif
#if CMDXENIX
            memcpy(LibName, text, B2W(text[0]) + 1);
                                        /* Leave name unchanged */
#endif
            if(!vfNoDefaultLibrarySearch)
            {
#if OSMSDOS
                fIgnoreCaseSave = fIgnoreCase;
                fIgnoreCase = (FTYPE) TRUE;

                /* If the name begins with a drive letter, skip it.  This
                 * is to allow compatibility with old compilers which
                 * generated comments of the form "A:FOO.LIB".
                 */
                if(LibName[2] == ':' && B2W(LibName[0]) > 1)
                {
                    LibName[2] = (BYTE) (LibName[0] - 2);
                    if (PropSymLookup(LibName+2,ATTRSKIPLIB,FALSE) == PROPNIL)
                      AddLibrary(LibName+2);
                }
                else
#endif
                    if (PropSymLookup(LibName,ATTRSKIPLIB,FALSE) == PROPNIL)
                      AddLibrary(LibName);
                fIgnoreCase = fIgnoreCaseSave;
            }
            break;
#if OEXE
        case 0x9E:                      /* Force segment order directive */
            SetDosseg();                /* Set switch */
            break;
#endif /* OEXE */

        case 0x9D:                      /* Model specifier */
#if FALSE
            /* Removed */
            mismatch = 0;               /* Assume all is well */
            while(cbRec > 1)            /* While bytes remain */
            {
                curmodtype = Gets();    /* Get byte value */
                switch(curmodtype)
                {
                    case 'c':           /* Compact model */
                    case 's':           /* Small model */
                    case 'm':           /* Medium model */
                    case 'l':           /* Large model */
                    case 'h':           /* Huge model */
                        if (modtype)
                            mismatch = curmodtype != modtype;
                        else
                            modtype = curmodtype;
                        break;
                }
            }
            if(mismatch) OutWarn(ER_memmodel);
                                        /* Warn if mismatch found */
#endif
#if OXOUT OR OIAPX286
            mismatch = 0;               /* Assume all is well */
            while(cbRec > 1)            /* While bytes remain */
            {
                modtype = Gets();       /* Get byte value */
                if (fMixed) continue;   /* Mixed model means we don't care */
                switch(modtype)
                {
                    case 'c':           /* Compact model */
                        if(!fLarge || fMedium) mismatch = 1;
                        break;          /* Warn if near data or FAR code */

                    case 's':           /* Small model */
                        if(fLarge || fMedium) mismatch = 1;
                                        /* Warn if FAR data or FAR code */
                        break;

                    case 'm':           /* Medium model */
                        if(fLarge || !fMedium) mismatch = 1;
                                        /* Warn if FAR data or near code */
                        break;

                    case 'l':           /* Large model */
                    case 'h':           /* Huge model */
                        if(!fLarge || !fMedium) mismatch = 1;
                                        /* Warn if near data or near code */
                        break;
                }
            }
            if(mismatch) OutError(ER_modelmis);
                                        /* Warn if mismatch found */
#endif /* OXOUT OR OIAPX286 */
#if O68K
            while (!f68k && cbRec > 1)  /* While bytes remain */
            {
                chModel = (BYTE) Gets();/* Get byte value */
                f68k = (FTYPE) F68KCODE(chModel);
            }
#endif /* O68K */
            break;

#if OSEGEXE AND NOT QCLINK
        case 0xA0:                      /* Microsoft OMF extension */
            switch(Gets())              /* Switch on extension record type */
            {
                case 0x01:              /* IMPort DEFinition */
                    imprc1();           /* Call the processing routine */
                    break;
                case 0x02:              /* EXPort DEFinition */
                    exprc1();           /* Call the processing routine */
                    break;
                case 0x03:
                    break;              /* In pass-1 skip INCDEF's for QC */
#if EXE386
                case 0x04:              // OMF extension - link386
//                  if (IsDLL(vFlags))
//                      vFlags |= E32PROTDLL;
                                        // Protected memory library module
                    break;
#endif
                case 0x05:              // C++ directives
                    flags = (BYTE) Gets();// Get flags field
#if NOT EXE386
                    if (flags & 0x01)
                        fNewExe = (FTYPE) TRUE; // PCODE forces segmented exe format
#endif
#if SYMDEB
                    if (flags & 0x02)
                        fSkipPublics = (FTYPE) TRUE;
                                        // In C++ they don't want PUBLIC subsection in CV info
#endif
                    if ((flags & 0x04) && !fIgnoreMpcRun) // ignore if /PCODE:NOMPC
                        fMPC = (FTYPE) TRUE;  // PCODE app - spawn MPC

                    break;
                case 0x06:              // target is a big-endian machine
#if O68K
                    fTBigEndian = (FTYPE) TRUE;
#endif /* O68K */
                    break;
                case 0x07:              // Use SSTPRETYPES instead of SSTTYPES4 in OutSSt
                    aprop = (APROPFILEPTR ) FetchSym(vrpropFile, TRUE);
                    aprop->af_flags |= FPRETYPES;
                    break;


                default:                /* Unknown */
                    InvalidObject();    /* Invalid object module */
            }
            break;
#endif

        case 0xA1:                      /* 1st OMF extension:  COMDEFs */
            vfNewOMF = (FTYPE) TRUE;
            aprop = (APROPFILEPTR ) FetchSym(vrpropFile, TRUE);
            aprop->af_flags |= FNEWOMF;
            break;

        case 0xA2:                      /* 2nd OMF extension */
            switch(Gets())
            {
                case 0x01:              /* Start linkpass2 records */
                /*
                 * WARNING:  It is assumed this comment will NOT be in a
                 * module whose MODEND record contains a program starting
                 * address.  If there are overlays, we need to see the
                 * starting address on pass 1 to define the symbol $$MAIN.
                 */
                    fP2Start = fModEnd = (FTYPE) TRUE;
                    break;
                default:
                    break;
            }
            break;

#if FALSE
        case 0xA3:                      // DON'T use - already used by LIB
             break;
#endif

        case 0xA4:                      /* OMF extension - EXESTR */
            fExeStrSeen = (FTYPE) TRUE;
                // WARNING: The code in this loop assumes:
                //
                //              ExeStrLen, cBrec and ExeStrMax are 16-bit unsigned WORDS
                //              An int is 32-bits
                //              All arithmetic and comparisons are 32-bit
                //
            while (cbRec > 1)
            {
                // Limit total EXESTR to 64K - 2 bytes.  We lose 1 because 0 means 0,
                // and we lose another because the buffer extension loop tops out at
                // 0xFFFE bytes.
                if (ExeStrLen + cbRec - 1 > 0xFFFEu)
                {
                        SkipBytes ( (WORD) (cbRec - 1) );
                }
                else
                if (ExeStrLen + cbRec - 1 > ExeStrMax)
                {
                    if (ExeStrBuf == NULL)
                    {
                        ExeStrBuf = GetMem(cbRec - 1);
                        ExeStrMax = cbRec - 1;
                    }
                    else
                    {
                        // This loop doubles the buffer size until it overflows 16 bits.  After this,
                        // it adds one half of the difference between the current value and 0xFFFF
                        //
                        while (ExeStrMax < ExeStrLen + cbRec - 1) {
                                ASSERT (ExeStrMax != 0);
                                if ((ExeStrMax << 1) >= 0x10000)
                                        ExeStrMax += (~ExeStrMax & 0xFFFF) >> 1;
                                else
                                ExeStrMax <<= 1;
                                }
                        pTmp = GetMem(ExeStrMax);
                        FMEMCPY(pTmp, ExeStrBuf, ExeStrLen);
                        FFREE(ExeStrBuf);
                        ExeStrBuf = pTmp;
                    }
                }
                // This must be done first because GetBytes() decrements
                // cbRec as a side effect.
        ExeStrLen += cbRec - 1;
                GetBytes(&ExeStrBuf[ExeStrLen-cbRec+1], (WORD) (cbRec - 1));

            }
            break;




        case 0xA6:                      /* OMF extension - INCERR */
            Fatal(ER_incerr);           /* Invalid object due to aborted incremental compile */
            break;
#if ILINK
        case 0xA7:                      /* OMF extension - NOPAD */
            if (fIncremental && !fLibraryFile)
            {
                /* Remove padding from non-zero-length, non-library,
                 * non-64K segment contributions.  (64K from huge model)
                 */
                while (cbRec > 1)
                {
                    noPadSn = GetIndex(1, snMac - 1);
                    apropSn = (APROPSNPTR) FetchSym(mpgsnrprop[mpsngsn[noPadSn]], TRUE);
                    if (apropSn->as_cbMx > 0L && apropSn->as_cbMx != LXIVK)
                    {
                        apropSn->as_cbMx -= mpgsnfCod[mpsngsn[noPadSn]] ? cbPadCode : cbPadData;
                        apropSn->as_fExtra |= NOPAD;
                    }
                }
            }
            break;
#endif

        case 0xA8:                      /* OMF extension - WeaK EXTern */
            while (cbRec > 1)
            {
                iextWeak = GetIndex(1, (WORD) (extMac - 1));
                                        /* Get weak extern index */
                iextDefRes = GetIndex(1, (WORD) (extMac - 1));
                                        /* Get default extern index */
#if FALSE
                DumpWeakExtern(mpextprop, iextWeak, iextDefRes);
#endif
                if (mpextprop[iextWeak] != PROPNIL && iextWeak < extMac)
                {
                    undefName = (APROPUNDEFPTR ) FetchSym(mpextprop[iextWeak], TRUE);
                    if (undefName->au_attr == ATTRUND)
                    {
                        // If this is EXTDEF

                        if (undefName->au_flags & UNDECIDED)
                        {
                            // This can be one of the following:
                            //  - weakness specified for the first time
                            //    if WEAKEXT is not set
                            //  - redefinition of weakness if the WEAKEXT
                            //    is set.
                            // In case of weakness redefinition check if
                            // it specified the same default resolution as
                            // the first one. Issue warning if different
                            // default resolutions and override old one
                            // with new. In both cases reset UNDECIDED bit.


                            undefName->au_flags &= ~UNDECIDED;
                            if (undefName->au_flags & WEAKEXT)
                            {
                                if (undefName->au_Default != mpextprop[iextDefRes])
                                    redefinition(iextWeak, iextDefRes, undefName->au_Default);
                                undefName->au_Default = mpextprop[iextDefRes];
                            }
                            else
                            {
                                undefName->au_Default = mpextprop[iextDefRes];
                                undefName->au_flags |= WEAKEXT;
                            }
                        }
                        // Ignore weakness - must be strong extern form
                        // some other .OBJ
                    }
                }
                else
                    InvalidObject();
            }
            break;
        default:                        /* Unrecognized */
            break;
    }
    if (cbRec > 1)
        SkipBytes((WORD) (cbRec - 1)); /* Punt rest of text */
}



/*** AliasRc1 - pass 1 ALIAS record processing
*
* Purpose:
*   Read and decode ALIAS OMF record (Microsoft OMF extension).
*   ALIAS record introduces pair of names - alias name and substitute
*   name. Enter both names into linker symbol table.
*
* Input:
*   No explicit value is passed. When this function is called the record
*   type and lenght are already read, so we can start reading name pairs.
*
* Output:
*   No explicit value is returned. Names are entered into symbol table.
*
* Exceptions:
*   Warning - redefinition of ALIAS <name>; substitute name changed
*   from <name1> to <name2>.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AliasRc1(void)
{
    SBTYPE              alias;
    SBTYPE              substitute;
    APROPALIASPTR       aliasDsc;
    RBTYPE              vAliasDsc;
    APROPNAMEPTR        pubName;
    APROPUNDEFPTR       undefName;
    RBTYPE              vPtr;
    WORD                fReferenced;


    while (cbRec > 1)                   /* While there are symbols left */
    {
        /* Read alias and its substitute */

        alias[0] = (BYTE) Gets();
        GetBytes(&alias[1], B2W(alias[0]));
        substitute[0] = (BYTE) Gets();
        GetBytes(&substitute[1], B2W(substitute[0]));
        aliasDsc = (APROPALIASPTR) PropSymLookup(alias, ATTRALIAS, FALSE);
        vAliasDsc = vrprop;
        if (aliasDsc == PROPNIL)
        {
            /* New ALIAS - check if we have PUBDEF for the alias name */

            pubName = (APROPNAMEPTR ) PropSymLookup(alias, ATTRPNM, FALSE);
            if (pubName == PROPNIL)
            {
                /* Enter ALIAS name in to symbol table */

                aliasDsc = (APROPALIASPTR) PropSymLookup(alias, ATTRALIAS, TRUE);
                vAliasDsc = vrprop;
#if SYMDEB
                if (fSymdeb)
                    DebPublic(vrprop, ALIAS);
#endif
                // Check if we have an EXTDEF for alias name. If we have
                // this means, that substitute name has to be used in
                // the library search.

                undefName = (APROPUNDEFPTR ) PropSymLookup(alias, ATTRUND, FALSE);
                fReferenced = (WORD) (undefName != PROPNIL);

                // Check if we know the substitute name as PUBDEF or EXTDEF

                pubName = (APROPNAMEPTR ) PropSymLookup(substitute, ATTRPNM, FALSE);
                if (pubName != PROPNIL)
                    vPtr = vrprop;
                else
                {
                    undefName = (APROPUNDEFPTR ) PropSymLookup(substitute, ATTRUND, FALSE);
                    if (undefName != NULL)
                    {
                        vPtr = vrprop;
                        undefName->au_flags |= (SUBSTITUTE | SEARCH_LIB);
                        undefName->au_Default = vAliasDsc;
#if NEW_LIB_SEARCH
                    if (fStoreUndefsInLookaside)
                        StoreUndef((APROPNAMEPTR)undefName, RhteFromProp((APROPPTR)undefName),0,0);
#endif
                    }
                    else
                    {
                        /* Enter substitute name into symbol table */
                        /* as undefined symbol                     */

                        if (extMac >= EXTMAX - 1)
                            Fatal(ER_extdef);

                        undefName = (APROPUNDEFPTR ) PropSymLookup(substitute, ATTRUND, TRUE);
                        vPtr = vrprop;
                        mpextprop[extMac++] = vrprop;
                        if (fReferenced)
                            undefName->au_flags |= (STRONGEXT | SUBSTITUTE | SEARCH_LIB);
                        else
                            undefName->au_flags |= (UNDECIDED | SUBSTITUTE);
                        undefName->au_len = -1L;
                        undefName->au_Default = vAliasDsc;
#if NEWLIST
                        undefName->u.au_rbNxt = rbLstUndef;
                        rbLstUndef = vrprop;
#endif

                    }
                }

                /* Attach substitute symbol to the ALIAS */

                aliasDsc = (APROPALIASPTR) FetchSym(vAliasDsc, TRUE);
                aliasDsc->al_sym = vPtr;

            }
            else
            {
#if FDEBUG
                if (fDebug)
                {
                    alias[alias[0] + 1] = '\0';
                    OutWarn(ER_ignoalias, &alias[1]);
                }
#endif
            }
        }
        else
        {
            /* Check if we have redefinition */

            vPtr = aliasDsc->al_sym;
            pubName = (APROPNAMEPTR ) PropSymLookup(substitute, ATTRPNM, FALSE);
            if (pubName != PROPNIL)
            {
                if (vPtr != vrprop)
                {
                    aliasDsc = (APROPALIASPTR) FetchSym(vAliasDsc, TRUE);
                    aliasDsc->al_sym = vrprop;
                    OutWarn(ER_aliasredef, &alias[1], 1 + GetPropName(pubName), &substitute[1]);
                }
            }
            else
            {
                undefName = (APROPUNDEFPTR ) PropSymLookup(substitute, ATTRUND, FALSE);
                if (undefName != PROPNIL)
                {
                    if (vPtr != vrprop)
                    {
                        aliasDsc = (APROPALIASPTR) FetchSym(vAliasDsc, TRUE);
                        aliasDsc->al_sym = vrprop;
                        OutWarn(ER_aliasredef, &alias[1], 1 + GetPropName(undefName), &substitute[1]);
                    }
                }
            }
        }
    }
}

#pragma check_stack(off)


#if OVERLAYS
    /****************************************************************
    *                                                               *
    *  EndRc1:                                                      *
    *                                                               *
    *  This   function  is  called  to   process  the  information  *
    *  contained  in  a  MODEND  (type 8AH) record  concerning the  *
    *  program  starting address.  The function  does not return a  *
    *  meaningful value.                                            *
    *  See pp. 80-81 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         EndRc1(void)
{
    WORD                modtyp;         /* MODEND record modtyp byte */
    WORD                fixdat;         /* Fixdat byte */
    SNTYPE              gsn;            /* Global SEGDEF number */
    RATYPE              ra;             /* Symbol offset */
    APROPSNPTR          apropSn;        /* Pointer to segment info */
    WORD                frameMethod;


    if ((modtyp = Gets()) & FSTARTADDRESS)
    {                                   /* If execution start address given */
        ASSERT(modtyp & 1);             /* Must be logical start address */
        fixdat = Gets();                /* Get fixdat byte */
        ASSERT(!(fixdat & 0x8F));       /* Frame, target must be explicit,
                                         *  target must be given by seg index
                                         */
        frameMethod = (fixdat & 0x70) >> 4;
        if (frameMethod != F4 && frameMethod != F5)
            GetIndex(0,IMAX - 1);       /* Punt frame index */
        gsn = mpsngsn[GetIndex((WORD)1,(WORD)(snMac - 1))];
                                        /* Get gsn from target segment index */
#if OMF386
        if(rect & 1) ra = LGets() + mpgsndra[gsn];
        else
#endif
        ra = WGets() + mpgsndra[gsn];   /* Get offset */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        /* Get segment information */
        MkPubSym("\006$$MAIN",apropSn->as_ggr,gsn,ra);
                                        /* Make public symbol */
    }
}
#endif /* OVERLAYS */


    /****************************************************************
    *                                                               *
    *  ProcP1:                                                      *
    *                                                               *
    *  This function  controls the processing of an  object module  *
    *  on pass 1.                                                   *
    *                                                               *
    ****************************************************************/

#pragma check_stack(on)

void NEAR               ProcP1(void)
{
    long                typlen[TYPMAX];
    WORD                typtyp[TYPMAX];
    RBTYPE              extprop[EXTMAX];
    FTYPE               fFirstRec;      /* First record flag */
    FTYPE               fFirstMod;      /* First module flag */
    APROPFILEPTR        apropFile;      /* File name entry */

#if OXOUT OR OIAPX286
    RUNTYPE             xhdr;
    LFATYPE             lfa;
#endif

    mpitypelen = typlen;                /* Initialize pointer */
    mpityptyp = typtyp;                 /* Initialize pointer */
    mpextprop = (RBTYPE FAR *) extprop; /* Initialize pointer */
    FMEMSET(mpextprop, 0, sizeof(extprop));
    fFirstMod = (FTYPE) TRUE;           /* First module */
    for(;;)                             /* Loop to process file */
    {
        snMac = 1;                      /* Initialize counter */
        grMac = 1;                      /* Initialize */
        extMac = 1;                     /* Initialize counter */
        lnameMac = 1;                   /* Initialize counter */
        typMac = 1;                     /* Initialize counter */
        vfNewOMF = FALSE;               /* Assume old OMF */
        DEBUGVALUE(gsnMac);             /* Debug info */
        DEBUGVALUE(ggrMac);             /* Debug info */
#if OXOUT OR OIAPX286
        lfa = ftell(bsInput);           /* Save initial file position */
        fread(&xhdr,1,CBRUN,bsInput);   /* Read x.out header */
        if(xhdr.x_magic == X_MAGIC)     /* If magic number found */
        {
#if OXOUT
            if((xhdr.x_cpu & XC_CPU) != XC_8086) InvalidObject();
                                        /* Bad if not 8086 */
#else
            xhdr.x_cpu &= XC_CPU;       /* Get CPU specification */
            if(xhdr.x_cpu != XC_286 && xhdr.x_cpu != XC_8086) InvalidObject();
                                        /* Bad if not 286 or 8086 */
#endif
            if(xhdr.x_relsym != (XR_R86REL | XR_S86REL)) InvalidObject();
                                        /* Check symbol table type */
            if((xhdr.x_renv & XE_VERS) != xever) InvalidObject();
                                        /* Check Xenix version */
        }
        else
            fseek(bsInput,lfa,0);       /* Else return to start */
#endif /* OXOUT OR OIAPX286 */
#if OVERLAYS
        if(fOverlays)                   /* If there are overlays */
            iovFile = ((APROPFILEPTR) vrpropFile)->af_iov;
                                        /* Save overlay number for file */
        else
            iovFile = 0;                /* File contains part of root */
#endif
        fFirstRec = (FTYPE) TRUE;       /* Looking at first record */
        fModEnd = FALSE;                /* Not at module's end */
        fP2Start = FALSE;               /* No p2start record yet */
#if SYMDEB
        cSegCode = 0;                   /* No code segments yet */
#endif
        while(!fModEnd)                 /* Loop to process object module */
        {
            rect = (WORD) getc(bsInput);/* Read record type */
            if(fFirstRec)               /* If first record */
            {
                if(rect != THEADR && rect != LHEADR)
                {                       /* If not header */
                    if(fFirstMod) break;/* Error if first module */
                    return;             /* Else return */
                }
                fFirstRec = FALSE;      /* Not first record any more */
            }
            else if (IsBadRec(rect)) break;
                                        /* Break if invalid object */

            cbRec = WSGets();           /* Read record length */
            lfaLast += cbRec + 3;       /* Update current file pos. */

#if ALIGN_REC
            if (bsInput->_cnt >= cbRec)
            {
                pbRec = bsInput->_ptr;
                bsInput->_ptr += cbRec;
                bsInput->_cnt -= cbRec;
            }
            else
            {
                if (cbRec > sizeof(recbuf))
                {
                    // error -- record too large [rm]
                    InvalidObject();
                }

                // read record into contiguous buffer
                fread(recbuf,1,cbRec,bsInput);
                pbRec = recbuf;
            }
#endif

            DEBUGVALUE(rect);           /* Debug info */
            DEBUGVALUE(cbRec);          /* Debug info */
            switch(TYPEOF(rect))        /* Switch on record type */
            {
#if TCE
                case  FIXUPP:
                    if(fTCE)
                        FixRc1();
                    else
                        SkipBytes((WORD) (cbRec - 1));   /* Skip to checksum byte */
                    break;
#endif

                case TYPDEF:
                    TypRc1();
                    break;

                case COMDEF:
                case LCOMDEF:
                    ComDf1();
                    break;

                case SEGDEF:
                    SegRc1();
                    break;

                case THEADR:
                    ModRc1();
                    break;

                case COMENT:
                    ComRc1();
                    break;

                case LHEADR:
                    ModRc1();
                    break;

                case GRPDEF:
                    GrpRc1();
                    break;

                case EXTDEF:
                case LEXTDEF:
                case CEXTDEF:
                    ExtRc1();
                    break;

                case LNAMES:
                case LLNAMES:
                    LNmRc1((WORD) (TYPEOF(rect) == LLNAMES));
                    break;

                case PUBDEF:
                case LPUBDEF:
                    PubRc1();
                    break;

                case MODEND:
#if OVERLAYS
                    if(fOverlays) EndRc1();
                    else
#endif
                    SkipBytes((WORD) (cbRec - 1));   /* Skip to checksum byte */
                    fModEnd = (FTYPE) TRUE; /* Stop processing module */
                    break;

                case COMDAT:
                    ComDatRc1();
                    break;

                case ALIAS:
                    AliasRc1();
                    break;

                default:
                    if (rect == EOF)
                        InvalidObject();
                    SkipBytes((WORD) (cbRec - 1));   /* Skip to checksum byte */
                    break;
            }
            if(cbRec != 1) break;       /* If record length bad */
            Gets();                     /* Eat the checksum byte */
        }
        if(!fModEnd)
        {
            ChkInput();                 /* First check for I/O problems */
            InvalidObject();            /* Invalid module */
        }
        ++modkey;                       /* For local symbols */
#if SYMDEB
        if (fSymdeb)
        {
            apropFile = (APROPFILEPTR) FetchSym(vrpropFile, TRUE);
            if (apropFile->af_cvInfo || apropFile->af_Src)
                ++ObjDebTotal;          /* Count the .OBJ with CV info */
        }
#endif
        if(extMac > extMax)             /* Possibly set new extMax */
            extMax = extMac;
        if(fLibraryFile || fP2Start) return;
        fFirstMod = FALSE;              /* Not first module */
    }
}

#pragma check_stack(off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newsym.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
/*
 *  NEWSYM.C -- Symbol table routine.
 *
 *  Modifications:
 *
 *      05-Jan-1989 RB  Delete MaskSymbols hack.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

#if NEWSYM
#if OSXENIX
#define _osmode         1               /* Xenix is always protect mode */
#endif
#endif /* NEWSYM */
#ifndef IRHTEMAX
#ifdef DOSX32
#define IRHTEMAX        16384
#else
#define IRHTEMAX        256
#endif
#endif

LOCAL WORD              IHashKey(BYTE *psb);
LOCAL PROPTYPE          CreateNewSym(WORD irhte, BYTE *psym, ATTRTYPE attr);

#if AUTOVM
LOCAL RBTYPE            AllocVirtMem(WORD cb);
LOCAL FTYPE             fVirtualAllocation = FALSE;
#endif

#define _32k    0x8000

typedef struct _SymTabBlock
{
    struct _SymTabBlock FAR *next;
    WORD                size;
    WORD                used;
    BYTE FAR            *mem;
}
                        SYMTABBLOCK;

SYMTABBLOCK             *pSymTab;
SYMTABBLOCK FAR         *pCurBlock;

#if NOT NEWSYM
BYTE                    symtab[CBMAXSYMSRES];
                                        /* Resident portion of symbol table */
#endif
LOCAL BYTE              mpattrcb[] =    /* Attribute size have to be <= 255 */
                                        /* Map attribute to struct size */
    {
        3,
        CBPROPSN,                       /* Size of APROPSNTYPE */
        CBPROPSN,                       /* Size of APROPSNTYPE */
        (CBPROPNAME>CBPROPUNDEF)? CBPROPNAME: CBPROPUNDEF,
                                        /* Max(CBPROPNAME,CBPROPUNDEF) */
        (CBPROPNAME>CBPROPUNDEF)? CBPROPNAME: CBPROPUNDEF,
                                        /* Max(CBPROPNAME,CBPROPUNDEF) */
        CBPROPFILE,                     /* Size of APROPFILETYPE */
        CBPROPGROUP,                    /* Size of APROPGROUPTYPE */
        (CBPROPNAME>CBPROPUNDEF)? CBPROPNAME: CBPROPUNDEF,
                                        /* Max(CBPROPNAME,CBPROPUNDEF) */
        CBHTE,                          /* Size of AHTETYPE     */
        CBPROPCOMDAT,                   /* Size of APROPCOMDAT */
        CBPROPALIAS,                    /* Size of APROPALIAS  */
#if OSEGEXE
                                        /* These two are always at the end */
                                        /* Adding something make sure that */
                                        /* this stays that way */
        CBPROPEXP,                      /* Size of APROPEXPTYPE */
        CBPROPIMP,                      /* Size of APROPIMPTYPE */
#endif
        3
    };

#if NEWSYM AND (CPU8086 OR CPU286 OR DOSEXTENDER)
LOCAL WORD              cbMaxBlk;       /* # bytes available in block */
LOCAL WORD              cbMacBlk;       /* # bytes allocated in block */
LOCAL WORD              saBlk;          /* Address of current block */
#endif

/*
 * INTERFACE TO ASSEMBLY LANGUAGE FUNCTIONS
 */

#if NEWSYM AND (CPU8086 OR CPU286 OR DOSEXTENDER)
WORD                    saFirst;        /* Address of 1st block */
#endif
RBTYPE                  rgrhte[IRHTEMAX];
                                        /* Symbol hash table */


    /****************************************************************
    *                                                               *
    *  InitSym:                                                     *
    *                                                               *
    *  This function takes no  arguments and returns no meaningful  *
    *  value.  It initializes the symbol table handler.             *
    *                                                               *
    ****************************************************************/

void                   InitSym(void)    /* Initialize symbol table handler */
{
    // Allocate first symbol table memory block

    pSymTab = (SYMTABBLOCK FAR *) GetMem(sizeof(SYMTABBLOCK));
    pSymTab->mem = (BYTE FAR *) GetMem(_32k);
    pSymTab->size = _32k;
    pSymTab->used = 0;
    pCurBlock = pSymTab;
}

#if AUTOVM
    /****************************************************************
    *                                                               *
    *  FetchSym:                                                    *
    *                                                               *
    *  This function  fetches a symbol from the symbol table given  *
    *  its virtual address.  The symbol  may either be resident or  *
    *  in virtual memory.                                           *
    *                                                               *
    ****************************************************************/

BYTE FAR * NEAR         FetchSym(rb, fDirty)
RBTYPE                  rb;             /* Virtual address */
WORD                    fDirty;         /* Dirty page flag */
{
    union {
            long      vptr;             /* Virtual pointer */
            BYTE FAR  *fptr;            /* FAR pointer     */
            struct  {
                      unsigned short  offset;
                                        /* Offset value    */
                      unsigned short  seg;
                    }                   /* Segmnet value   */
                      ptr;
          }
                        pointer;        /* Different ways to describe pointer */

    pointer.fptr = rb;

    if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
    {
        picur = 0;                      /* Picur not valid */
        return(pointer.fptr);           /* Return pointer */
    }
    pointer.fptr = (BYTE FAR *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),fDirty);
                                        /* Fetch from virtual memory */
    return(pointer.fptr);
}
#endif

    /****************************************************************
    *                                                               *
    *  IHashKey:                                                    *
    *                                                               *
    *  This function hashes a  length-prefixed  string and returns  *
    *  hash value.                                                  *
    *                                                               *
    ****************************************************************/
#if NOASM

#define FOUR_BYTE_HASH

#ifdef FOUR_BYTE_HASH
LOCAL WORD              IHashKey(psb)
BYTE                    *psb;           /* Pointer to length-prefixed string */
{
    unsigned cb = *psb++;
    unsigned hash = cb;

    while (cb >= sizeof(unsigned))
    {
        hash = ((hash >> 28) | (hash << 4)) ^ (*(unsigned UNALIGNED *)psb | 0x20202020);
        cb  -= sizeof(unsigned);
        psb += sizeof(unsigned);
    }

    while (cb)
    {
        hash = ((hash >> 28) | (hash << 4)) ^ (*psb++ | 0x20);
        cb--;
    }

    return ((WORD)hash) ^ (WORD)(hash>>16);
}
#else
LOCAL WORD              IHashKey(psb)
BYTE                    *psb;           /* Pointer to length-prefixed string */
{
#if defined(M_I386)
    _asm
    {
        push    edi                 ; Save edi
        push    esi                 ; Save esi
        mov     ebx, psb            ; ebx = pointer to length prefixed string
        xor     edx, edx
        mov     dl, byte ptr [ebx]  ; edx = string length
        mov     edi, edx            ; edi = hash value
        mov     esi, ebx
        add     esi, edx            ; esi = &psb[psb[0]]
        std                         ; Loop down

HashLoop:
        xor     eax, eax
        lodsb                       ; Get char from DS:ESI into AL
        or      eax, 0x20
        mov     cl, dl
        and     cl, 3
        shl     eax, cl
        add     edi, eax
        dec     edx
        jg      HashLoop            ; Allow for EDX = -1 here so we don't have to special-case null symbol.
        cld
        mov     eax, edi            ; eax = hash value
        pop     esi
        pop     edi
    }
#else
    REGISTER WORD       i;              /* Index */
    REGISTER WORD       hashval;        /* Hash value */

    /* NOTE:  IRHTEMAX MUST BE 256 OR THIS FUNCTION WILL FAIL */
    hashval = B2W(psb[0]);              /* Get length as initial hash value */
#if DEBUG
    fputs("Hashing ",stderr);           /* Message */
    OutSb(stderr,psb);                  /* Symbol */
    fprintf(stderr,"  length %d\r\n",hashval);
                                        /* Length */
#endif
    for(i = hashval; i; --i)            /* Loop through string */
    {
/*
*  Old hash function:
*
*       hashval = rorb(hashval,2) ^ (B2W(psb[i]) | 040);
*/
        hashval += (WORD) ((B2W(psb[i]) | 040) << (i & 3));
                                        /* Hash */
    }
#if DEBUG
    fprintf(stderr,"Hash value: %u\r\n",hashval);
#endif
#if IRHTEMAX == 512
    return((hashval & 0xfeff) | ((psb[0] & 1) << 8));
#else
    return(hashval);                    /* Return value */
#endif
#endif // M_I386
}

#endif /*FOUR_BYTE_HASH*/
#endif /*NOASM*/


#if AUTOVM
    /****************************************************************
    *                                                               *
    *  AllocVirtMem:                                                *
    *                                                               *
    *  This function takes as its input a WORD n, and it allocates  *
    *  n  continguous  bytes  in  the  symbol  area  and returns a  *
    *  virtual pointer  to  the  first  of those bytes.  The bytes  *
    *  are guaranteed to reside on the same  virtual page.          *
    *                                                               *
    ****************************************************************/


LOCAL RBTYPE            AllocVirtMem(cb)
WORD                    cb;
{
    WORD                rbLimVbf;       /* End of current page */
    WORD                rb;             /* Address of allocated bytes */
    WORD                x;


    ASSERT(cb <= PAGLEN);               /* Cannot alloc. more than 512 bytes */
    x = cb;
    cb = (WORD) ((cb + (1 << SYMSCALE) - 1) >> SYMSCALE);
                                        /* Determine number of units wanted */
    if(rbMacSyms > (WORD) (0xFFFF - cb)) Fatal(ER_symovf);
                                        /* Check for symbol table overflow */
    rbLimVbf = (rbMacSyms + (1 << (LG2PAG - SYMSCALE)) - 1) &
      (~0 << (LG2PAG - SYMSCALE));      /* Find limit of current page */
    if((WORD) (rbMacSyms + cb) > rbLimVbf && rbLimVbf) rbMacSyms = rbLimVbf;
                                        /* If alloc. would cross page
                                        *  boundary, start with new page
                                        */
    rb = rbMacSyms;                     /* Get address to return */
    rbMacSyms += cb;                    /* Update pointer to end of area */
#if FALSE
    fprintf(stderr,"Allocated %u bytes at VA %x\r\n",cb << SYMSCALE,rb);
#endif
    return((BYTE FAR *) (long) rb);
                                        /* Return the address */
}
#endif



/*** RbAllocSymNode - symbol table memory allocator
*
* Purpose:
*   This function takes as its input a WORD n, and it allocates
*   n  continguous  bytes  in  the  symbol  area  and returns a
*   pointer  to  the  first  of  those  bytes.  The  bytes  are
*   guaranteed to reside on the same  virtual page (when not in
*   memory).
*
*
* Input:
*   cb          - number of bytes to allocate
*
* Output:
*   Pointer to allocated memory area. Pointer can be real or virtual.
*
* Exceptions:
*   I/O error in temporary file used for VM.
*
* Notes:
*   Uses differnet strategy depending under which operating system
*   memory is allocated.
*
*************************************************************************/


RBTYPE     NEAR         RbAllocSymNode(WORD cb)
{
    SYMTABBLOCK FAR     *pTmp;
    RBTYPE              rb;             /* Address of allocated bytes */

#if defined( _WIN32 )
    // Round up allocation size to keep returned pointers
    // at least DWORD aligned.

    cb = ( cb + sizeof(DWORD) - 1 ) & ~( sizeof(DWORD) - 1 );
#endif // _WIN32

    if ((WORD) (pCurBlock->used + cb) >= pCurBlock->size)
    {
        // Allocate new symbol table memory block

        pTmp = (SYMTABBLOCK FAR *) GetMem(sizeof(SYMTABBLOCK));
        pTmp->mem  = (BYTE FAR *) GetMem(_32k);
        pTmp->size = _32k;
        pTmp->used = 0;
        pCurBlock->next = pTmp;
        pCurBlock = pTmp;
    }

    // Sub-allocated in the current block

    rb = (RBTYPE) &(pCurBlock->mem[pCurBlock->used]);
    pCurBlock->used += cb;
    cbSymtab += cb;
    return(rb);
}

void                    FreeSymTab(void)
{
    SYMTABBLOCK FAR     *pTmp;
    SYMTABBLOCK FAR     *pNext;

    FFREE(mplnamerhte);
    FFREE(mpsegraFirst);
    FFREE(mpgsndra);
    FFREE(mpgsnrprop);
    FFREE(mpsegsa);
    FFREE(mpgsnseg);
    FFREE(mpseggsn);

    for (pTmp = pSymTab; pTmp != NULL;)
    {
        pNext = pTmp->next;
        FFREE(pTmp->mem);
        FFREE(pTmp);
        pTmp = pNext;
    }
}

    /****************************************************************
    *                                                               *
    *  PropAdd:                                                     *
    *                                                               *
    *  This function  adds a property to a  hash table entry node.  *
    *  It returns the  location of  the property.  Inputs  are the  *
    *  virtual  address of the hash table  entry and the attribute  *
    *  (or property) to be added.                                   *
    *                                                               *
    ****************************************************************/


PROPTYPE NEAR           PropAdd(rhte,attr)
RBTYPE                  rhte;           /* Virtual addr of hash tab ent */
ATTRTYPE                attr;           /* Attribute to add to entry */
{
    REGISTER AHTEPTR    hte;            /* Hash table entry pointer */
    REGISTER APROPPTR   aprop;          /* Property list pointer */
    RBTYPE              rprop;          /* Property cell list pointer */

    DEBUGVALUE(rhte);                   /* Debug info */
    DEBUGVALUE(attr);                   /* Debug info */
    hte = (AHTEPTR ) FetchSym(rhte,TRUE);
                                        /* Fetch from VM */
    DEBUGVALUE(hte);                    /* Debug info */
    rprop = hte->rprop;                 /* Save pointer to property list */
    vrprop = RbAllocSymNode(mpattrcb[attr]);
                                        /* Allocate symbol space */
    hte->rprop = vrprop;                /* Complete link */
    aprop = (APROPPTR ) FetchSym(vrprop,TRUE);
                                        /* Fetch the property cell */
    FMEMSET(aprop,'\0',mpattrcb[attr]); /* Zero the space */
    aprop->a_attr = attr;               /* Store the attribute */
    aprop->a_next = rprop;              /* Set link */

#if NEW_LIB_SEARCH
    if (attr == ATTRUND && fStoreUndefsInLookaside)
        StoreUndef((APROPNAMEPTR)aprop, rhte, 0, 0);
#endif

    return((PROPTYPE) aprop);           /* Return pointer */
}

    /****************************************************************
    *                                                               *
    *  PropRhteLookup:                                              *
    *                                                               *
    *  "Look up a property on hash  table entry (possibly creating  *
    *  it) and return pointer to property.                          *
    *                                                               *
    *  Input:   rhte    Virtual address of hash table entry.        *
    *           attr    Property to look up.                        *
    *           fCreate Flag  to  create   property  cell  if  not  *
    *                   present.                                    *
    *  Return:          pointer to property cell."                  *
    *                                                               *
    ****************************************************************/

PROPTYPE NEAR           PropRhteLookup(rhte,attr,fCreate)
RBTYPE                  rhte;           /* Virt. addr. of hash table entry */
ATTRTYPE                attr;           /* Property to look up */
FTYPE                   fCreate;        /* Create property cell flag */
{
    REGISTER APROPPTR   aprop;
    AHTEPTR             ahte;

    DEBUGVALUE(rhte);                   /* Debug info */
    DEBUGVALUE(attr);                   /* Debug info */
    DEBUGVALUE(fCreate);                /* Debug info */
    vrhte = rhte;                       /* Set global */
    ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch symbol */
    vrprop = ahte->rprop;
    vfCreated = FALSE;                  /* Assume no creation takes place */
    for(;;)
    {
        aprop = (APROPPTR ) FetchSym(vrprop,FALSE);
                                        /* Fetch from VM */
        if(aprop->a_attr == attr)       /* If match found */
        {
            DEBUGMSG("Match found");    /* Debug message */
            return((PROPTYPE) aprop);   /* Return address of cell */
        }
        DEBUGMSG("Following link:");    /* Debug message */
        vrprop = aprop->a_next;         /* Try next item in list */
        DEBUGVALUE(vrprop);             /* Debug info */
        if(aprop->a_attr == ATTRNIL)    /* If no entry here */
        {
            DEBUGMSG("Match NOT found");/* Debug message */
            if(!fCreate)                /* If creation inhibited */
            {
                                        /* Debug info */
                return(PROPNIL);        /* Return nil pointer */
            }
            vfCreated = (FTYPE) TRUE;           /* A new creation! */
            DEBUGMSG("Leaving PropRhteLookup with value of PropAdd");
                                        /* Debug message */
            return(PropAdd(vrhte,attr));/* Let someone else do it */
        }
    }
}

    /****************************************************************
    *                                                               *
    *  RhteFromProp:                                                *
    *                                                               *
    *  give back the master rhte for this prop entry                *
    *                                                               *
    *  Input:   aprop   mapped  address of the propery cell         *
    *                                                               *
    *  Return:          Virtual address of hash table entry.        *
    *                                                               *
    ****************************************************************/

RBTYPE NEAR             RhteFromProp(aprop)
APROPPTR                aprop;          /* address of property block */
{
    RBTYPE              vrprop;

    /* if we're already at the head, we have to go all the way around
     * to compute the *virutal* address of the head
     */

    for(;;)
    {
        DEBUGMSG("Following link:");    /* Debug message */
        vrprop = aprop->a_next;         /* Try next item in list */
        DEBUGVALUE(vrprop);             /* Debug info */

        aprop = (APROPPTR) FetchSym(vrprop,FALSE);
                                        /* Fetch from VM */
        if(aprop->a_attr == ATTRNIL)    /* If no entry here */
        {
            return(vrprop);             /* found head -- return it */
        }
    }
}

#if NEWSYM AND NOASM
FTYPE NEAR              SbNewComp(ps1,ps2,fncs)
BYTE                    *ps1;           /* Pointer to symbol */
BYTE FAR                *ps2;           /* Pointer to FAR symbol */
FTYPE                   fncs;           /* True if not case-sensitive */
{
    WORD                length;         /* No. of char.s to compare */

    length = B2W(*ps1);                 /* Get length */
    if (!fncs)                          /* If case-sensitive */
    {                                   /* Simple string comparison */
        while (length && (*++ps1 == *++ps2)) {
            length--;
            }
        return((FTYPE) (length ? FALSE : TRUE));        /* Success iff nothing left */
    }
    while(length--)
    {
#ifdef _MBCS
        ps1++;
        ps2++;
        if (IsLeadByte(*ps1))
            if (*((WORD *)ps1) != *((WORD *)ps2)) {
                return FALSE;
                }
            else {
                ps1++;
                ps2++;
                length--;
                continue;
                }
        else
#else
        if(*++ps1 == *++ps2)
            continue;  /* Bytes match */
        else
#endif
            if((*ps1 & 0137) != (*ps2 & 0137)) {
                return(FALSE);
                }
    }
    return(TRUE);                       /* They match */
}
#endif

    /****************************************************************
    *                                                               *
    *  PropSymLookup:                                               *
    *                                                               *
    *  This  function  looks  up  a  symbol  and its property.  It  *
    *  can create an entry, if necessary.  It returns a pointer to  *
    *  the property cell.  It takes  as its inputs  a pointer to a  *
    *  symbol, the property to look up, and a flag which specifies  *
    *  if a new  property cell is to be  created in the event that  *
    *  one of the given type does not already exist.                *
    *                                                               *
    ****************************************************************/
#if NOASM
PROPTYPE NEAR           PropSymLookup(psym,attr,fCreate)
BYTE                    *psym;          /* Pointer to length-prefixed string */
ATTRTYPE                attr;           /* Attribute to look up */
WORD                    fCreate;        /* Create prop cell if not found */
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    WORD                hashval;        /* Hash value */

#if DEBUG                               /* If debugging on */
    fputs("Looking up ",stderr);        /* Message */
    OutSb(stderr,psym);                 /* Symbol */
    fprintf(stderr,"(%d) with attr %d\r\n",B2W(psym[0]),B2W(attr));
#endif                                  /* End debugging code */
    hashval = IHashKey(psym);           /* Get hash index */
    vrhte = rgrhte[hashval % IRHTEMAX]; /* Get VM address of chain */
    vfCreated = FALSE;                  /* Assume nothing will be created */
    for(;;)
    {
        DEBUGVALUE(vrhte);              /* Debug info */
        if(vrhte == RHTENIL)            /* If nil pointer */
        {
            DEBUGMSG("Empty slot found");
                                        /* Debug message */
            if(!fCreate)                /* If creation inhibited */
            {
                return(PROPNIL);        /* Return nil pointer */
            }
            else
            {
                DEBUGMSG("Leaving PropSymLookup with value of CreateNewSym");
                return CreateNewSym(hashval, psym, attr);
            }
        }
        DEBUGMSG("Collision");          /* Debug message */
        ahte = (AHTEPTR ) FetchSym(vrhte,FALSE);
                                        /* Fetch from VM */
#if DEBUG
        fputs("Comparing \"",stderr);   /* Message */
        OutSb(stderr,psym);             /* Symbol */
        fprintf(stderr,"\"(%d) to \"",B2W(psym[0]));
                                        /* Message */
        OutSb(stderr,GetFarSb(ahte->cch));      /* Symbol */
        fprintf(stderr,"\"(%d) %signoring case\r\n",
          B2W(ahte->cch[0]),fIgnoreCase? "": "NOT ");
                                        /* Message */
#endif
        if(hashval == ahte->hashval && psym[0] == ahte->cch[0]
            && SbNewComp(psym,(BYTE FAR *)ahte->cch,fIgnoreCase))
        {                               /* If a match found */
            DEBUGMSG("Match found");    /* Debug message */
            DEBUGMSG("Leaving PropSymLookup w/ val of PropRhteLookup");
            return(PropRhteLookup(vrhte,attr, (FTYPE) fCreate));
                                        /* Return property cell pointer */
        }
        vrhte = ahte->rhteNext;         /* Move down list */
        DEBUGMSG("Following link:");    /* Debug message */
        DEBUGVALUE(vrhte);              /* Debug info */
    }
}
#endif /*NOASM*/

    /****************************************************************
    *                                                               *
    *  CreateNewSym:                                                *
    *                                                               *
    *  This function adds the given symbol into the hash table at   *
    *  the position indicated by hashval.  If attr is not ATTRNIL   *
    *  then it also creates the specified property type             *
    *                                                               *
    ****************************************************************/

LOCAL PROPTYPE NEAR CreateNewSym(hashval, psym, attr)
WORD                    hashval;        /* the hash value of this symbol */
BYTE                    *psym;          /* Pointer to length-prefixed string */
ATTRTYPE                attr;           /* Attribute to create */
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    WORD                irhte;          /* hash bucket */

    irhte = hashval % IRHTEMAX;

    vfCreated = TRUE;           /* New creation */
    vrhte = RbAllocSymNode((WORD) (CBHTE + B2W(psym[0])));
                                /* Allocate space for symbol entry */
    ahte = (AHTEPTR ) FetchSym(vrhte,TRUE);
                                /* Fetch symbol from virtual memory */
    ahte->rhteNext = rgrhte[irhte];
                                /* Tack on chain */

    DEBUGMSG("Origin of original chain:");
    DEBUGVALUE(rgrhte[irhte]);  /* Debug info */

    ahte->attr = ATTRNIL;       /* Symbol has Nil attribute */
    ahte->rprop = vrhte;        /* Prop list points to self */
    ahte->hashval = hashval;    /* Save hash value */
    memcpy(ahte->cch, psym, psym[0] + 1);
    rgrhte[irhte] = vrhte;      /* Make new symbol first in chain */

    DEBUGMSG("Origin of new chain:");
    DEBUGVALUE(rgrhte[irhte]);  /* Debug info */

    if(attr != ATTRNIL)         /* If property to give symbol */
    {
        DEBUGMSG("Leaving PropSymLookup with the value of PropAdd");
        return(PropAdd(vrhte,attr));
                                /* Add the attribute */
    }
                                /* Debug info */
    return(PROPNIL);            /* Nothing to return */
}

    /****************************************************************
    *                                                               *
    *  The legendary EnSyms:                                        *
    *                                                               *
    *  This  function  applies  a function to  all symbol/property  *
    *  pairs that  have a  particular  property.  It takes  as its  *
    *  inputs  a pointer to a function  to call and a  property to  *
    *  look for.  EnSyms() does not return a meaningful value.      *
    *                                                               *
    ****************************************************************/

void                    BigEnSyms(void (*pproc)(APROPNAMEPTR papropName,
                                                RBTYPE       rhte,
                                                RBTYPE       rprop,
                                                WORD fNewHte), ATTRTYPE attr)
{
    APROPPTR            aprop;          /* Pointer to a property cell */
    AHTEPTR             ahte;           /* Pointer to a hash table entry */
    WORD                irhte;          /* Hash table index */
    RBTYPE              rhte;           /* Hash table entry address */
    ATTRTYPE            attrT;
    FTYPE               fNewHte;
    RBTYPE              rprop;
    RBTYPE              rhteNext;
    RBTYPE              rpropNext;

    DEBUGVALUE(attr);                   /* Debug info */
    for(irhte = 0; irhte < IRHTEMAX; ++irhte)
    {                                   /* Look through hash table */
        rhte = rgrhte[irhte];           /* Get pointer to chain */
        while(rhte != RHTENIL)          /* While not at end of chain */
        {
            DEBUGVALUE(rhte);           /* Debug info */
            ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch entry from VM */
            DEBUGSB(ahte->cch);         /* Debug info */
            fNewHte = (FTYPE) TRUE;     /* First call on this hash tab entry */
            rhteNext = ahte->rhteNext;  /* Get pointer to next in chain */
            rprop = ahte->rprop;        /* Get pointer to property list */
            for(;;)                     /* Loop to search property list */
            {
                aprop = (APROPPTR ) FetchSym(rprop,FALSE);
                                        /* Fetch entry from symbol table */
                rpropNext = aprop->a_next;
                                        /* Get pointer to next in list */
                attrT = aprop->a_attr;  /* Get the attribute */
                DEBUGVALUE(attrT);      /* Debug info */
                if(attr == attrT || attr == ATTRNIL)
                {                       /* If property is acceptable */
                    (*pproc)((APROPNAMEPTR) aprop, rhte, rprop, (WORD) fNewHte);
                                        /* Apply function to node */
                    fNewHte = FALSE;    /* Next call (if any) won't be first */
                }
                if(attrT == ATTRNIL) break;
                                        /* Break if at end of prop list */
                rprop = rpropNext;      /* Move down the list */
            }
            rhte = rhteNext;            /* Move down the chain */
        }
    }
}
#if PROFSYM
/*
 *  ProfSym : Profile the symbol table, displaying results to stdout
 */
void                    ProfSym ()
{
    REGISTER AHTEPTR    ahte;           /* Pointer to a hash table entry */
    WORD                irhte;          /* Hash table index */
    RBTYPE              rhte;           /* Hash table entry address */
    unsigned            cSymbols = 0;   /* # of symtab entries */
    unsigned            cBktlen = 0;    /* Total length of buckets */
    unsigned            bucketlen;      /* Current bucket length */
    unsigned            maxBkt = 0;
    long                sumBktSqr = 0L; /* Sum of bucketlen squared */
    int                 bdist[6];

    bdist[0] = bdist[1] = bdist[2] = bdist[3] = bdist[4] = bdist[5] = 0;


    for(irhte = 0; irhte < IRHTEMAX; ++irhte)
    {                                   /* Look through hash table */
        rhte = rgrhte[irhte];           /* Get pointer to chain */
        bucketlen = 0;
        while(rhte != RHTENIL)          /* While not at end of chain */
        {
            ++cSymbols;
            ++bucketlen;
            ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
            rhte = ahte->rhteNext;      /* Move down the chain */
        }

        if (bucketlen >= 5)
                bdist[5]++;
        else
                bdist[bucketlen]++;

        sumBktSqr += bucketlen * bucketlen;
        cBktlen += bucketlen;
        if(bucketlen > maxBkt) maxBkt = bucketlen;
    }
    fprintf(stdout,"\r\n");
    fprintf(stdout,"Total number of buckets = %6u\r\n",IRHTEMAX);
    fprintf(stdout,"Total number of symbols = %6u\r\n",cSymbols);
    fprintf(stdout,"Sum of bucketlen^2      = %6lu\r\n",sumBktSqr);
    fprintf(stdout,"(cSymbols^2)/#buckets   = %6lu\r\n",
              ((long) cSymbols * cSymbols) / IRHTEMAX);
    fprintf(stdout,"Average bucket length   = %6u\r\n",cBktlen/IRHTEMAX);
    fprintf(stdout,"Maximum bucket length   = %6u\r\n",maxBkt);
    fprintf(stdout,"# of buckets with 0     = %6u\r\n",bdist[0]);
    fprintf(stdout,"# of buckets with 1     = %6u\r\n",bdist[1]);
    fprintf(stdout,"# of buckets with 2     = %6u\r\n",bdist[2]);
    fprintf(stdout,"# of buckets with 3     = %6u\r\n",bdist[3]);
    fprintf(stdout,"# of buckets with 4     = %6u\r\n",bdist[4]);
    fprintf(stdout,"# of buckets with >= 5  = %6u\r\n",bdist[5]);
    fprintf(stdout,"\r\n");
}
#endif /*PROFSYM*/

#if DEBUG AND ( NOT defined( _WIN32 ) )
void DispMem( void)
{
unsigned int mem_para, mem_kb;
unsigned int error_code=0;

_asm{
    mov bx, 0xffff
    mov ax, 0x4800
    int 21h
    jc  Error
    mov bx, 0xffff
    jmp MyEnd
Error:
    mov error_code, ax
MyEnd:
    mov mem_para, bx
    }

mem_kb = mem_para>>6;

if(error_code == 8 || error_code)
   fprintf( stdout, "\r\nAvailable Memory: %u KB, %u paragraphs, error: %d\r\n", mem_kb, mem_para, error_code);
else
   fprintf( stdout, "\r\nMemory Error No %d\r\n", error_code);
fflush(stdout);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newtrn.c ===
/* SCCSID = @(#)newtrn.c    4.10 86/10/08 */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                         NEWTRN.C                              *
    *                                                               *
    *  Main function of the linker.                                 *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants, macros */
#if USE_REAL AND (NOT defined( _WIN32 ))
#define i386
#endif
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <nmsg.h>        /* Near message strings */
#include                <newexe.h>
#include                <sys\types.h>
#if NOT CLIBSTD
#include                <fcntl.h>
#endif
#include                <direct.h>
#if EXE386
#include                <exe386.h>
#endif
#if OSEGEXE AND CPU286
#define INCL_DOSSESMGR
#define INCL_DOSERRORS
#include                <os2.h>
#if defined(M_I86LM)
#undef  NEAR
#define NEAR
#endif
#endif
#include                <process.h>
#include                <malloc.h>
#include                <undname.h>
#if WIN_NT
#include                <except.h>
#endif
#if (WIN_3 OR USE_REAL)
#if defined( _WIN32 )
#undef NEAR
#undef FAR
#undef PASCAL
#endif
#include                <windows.h>
#endif
#define _32k            0x8000


LOCAL FTYPE             RunFileOpen;    /* Executable-file-open flag */
LOCAL int               ifhLast;        /* Last input file */
#if LNKPROF
extern FTYPE            fP1stop;        /* Stop after Pass 1 */
#endif
#if NEWIO
#include                <errno.h>       /* System level error codes */
#endif


 /*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR PrintStats(void);
LOCAL void PrintAnUndef(APROPNAMEPTR prop,
                        RBTYPE rhte,
                        RBTYPE rprop,
                        WORD fNewHte);
LOCAL void NEAR InitFP(void);
LOCAL void NEAR InitFpSym(BYTE *sb, BYTE flags);
LOCAL void NEAR InterPass(void);
LOCAL void NEAR InitAfterCmd(void);
#if EXE386
LOCAL void NEAR ChkSize386(void);
#endif
LOCAL void NEAR CleanUp(void);
LOCAL void NEAR OutRunFile(BYTE *sbRun);
LOCAL void NEAR SpawnOther(BYTE *sbRun, BYTE *szMyself);


#if CVPACK_MONDO
extern int cvpack_main(int, char **);
#endif // CVPACK_MONDO

#ifdef PENTER_PROFILE
void saveEntries();
#endif

#if TIMINGS
#include <sys\types.h>
#include <sys\timeb.h>

struct _timeb time_start;
struct _timeb time_end;
int fShowTiming;
#endif // TIMINGS

#if DEBUG_HEAP_ALLOCS

#define D_SIZE 5        // Number of test bytes on each side of the allocated buffer
#define FILL_CHAR 1     // Character to fill the test areas
#define P_SIZE 5000     // Size of an array of 'malloc'ated pointers
struct Entry {
        BYTE FAR * ptr;
        int size;
        };
struct  Entry Pointers[P_SIZE];
int     indexMac = 0;

// Check a block from the Pointers table

int Ckb ( int index )
{
    BYTE * pBuf;
    int size,i;
    int ret = 1;
    if(index > P_SIZE)
    {
        fprintf(stdout, "INDEX TOO LARGE %d ", index);
        return 0;
    }
    if(!Pointers[index].ptr)  // a freed entry
        return 1;
    pBuf = Pointers[index].ptr-D_SIZE;
    size = Pointers[index].size;
    for( i=0; i<D_SIZE; i++ )
    {
        if(pBuf[i] != FILL_CHAR)
        {
            fprintf(stdout, "\r\nFront block memory error; idx %d at %d, %x != %x ",
                index, i, pBuf[i], FILL_CHAR);
            ret = 0;
        }
    }
    pBuf += D_SIZE + size;
    for( i=0; i<D_SIZE; i++ )
    {
        if(pBuf[i] != FILL_CHAR)
        {
            fprintf(stdout, "\r\nMemory tail error; idx %d at %d, %x != %x",
                index, i, pBuf[i], FILL_CHAR);
            ret = 0;
        }
    }
    fflush(stdout);
    return ret;
}

// Ckeck all the memory blocks allocated so far

int CheckAll(void)
{
    int i;
    for(i=0; i<indexMac; i++)
    {
        if(!Ckb(i))
            return 0;
    }
    return 1;
}
#pragma intrinsic(memset)

BYTE FAR                *GETMEM(unsigned size, BYTE* pFile, int Line)
{
    BYTE FAR            *p;
    BYTE FAR            *pBuf;

    fprintf(stdout,"\r\nGETMEM : size %d bytes, idx %d, file %s, line %d ",
             size, indexMac, pFile, Line);
    if(!CheckAll()) // check all so far allocated blocks first
        exit(2);
    pBuf = (BYTE FAR *) malloc(size + 2*D_SIZE);
    if(pBuf)
    {
        p = pBuf + D_SIZE;
        memset(pBuf, FILL_CHAR, size + 2*D_SIZE);
    }
    else
        Fatal(ER_memovf);
    memset(p, 0, size);
    Pointers[indexMac].ptr = p;
    Pointers[indexMac++].size = size;
    fprintf(stdout, " returns %x ", p);
    fflush(stdout);
    return(p);
}
#pragma function(memset)

void FreeMem( void * p )
{
    int i;
    unsigned size;
    BYTE FAR * pBuf = (BYTE*)p-D_SIZE;
    fprintf(stdout, "\r\nFreeMem : %x ", p);
    for( i=0; i<= indexMac; i++)
    {
        if(Pointers[i].ptr == p)
        {
            size = Pointers[i].size;
            fprintf(stdout, "size %d, idx %d ", size, i);
            break;
        }
    }
    if (i> indexMac)
    {
        fprintf(stdout, "Pointer UNKNOWN ");
        return;
    }
    if (!Ckb(i))
        exit(1);
    fprintf(stdout, " freeing %x ", (BYTE*)p-D_SIZE);
    fflush(stdout);
    free((BYTE*)p-D_SIZE);
    fprintf(stdout, ". ");
    fflush(stdout);
    Pointers[i].ptr = NULL;
}

void *REALLOC_ (void * memblock, size_t nsize, char* pFile, int Line)
{
    int i;
    unsigned size;
    BYTE * ret;
    BYTE FAR * pBuf = (BYTE FAR* )memblock-D_SIZE;
    fprintf(stdout, "\r\nREALLOC %x, new size %d, file %s, line %d ",
       memblock, nsize, pFile, Line);
    if(!CheckAll())
        exit(2);
    if(!memblock)
     exit(2);
    for( i=0; i<= indexMac; i++)
    {
        if(Pointers[i].ptr == memblock)
        {
            size = Pointers[i].size;
            fprintf(stdout, "old size %d, idx %d ", size, i);
            if(Ckb(i))
                fprintf(stdout, " Chk OK ");
            break;
        }
    }
    if (i> indexMac)
    {
        fprintf(stdout, "Pointer UNKNOWN ");
        memblock = realloc( memblock, nsize );
        if (!memblock)
                Fatal(ER_memovf);
        return (void*)memblock;
    }
    else
    {
        fflush(stdout);
        fprintf(stdout, "\r\nreallocing %x ", pBuf);
        fflush(stdout);

        pBuf = malloc(nsize + 2*D_SIZE);
        if (!pBuf)    Fatal(ER_memovf);

        memset(pBuf, FILL_CHAR, nsize+2*D_SIZE);
        memcpy(pBuf+D_SIZE, memblock, size);
        free((BYTE*)memblock-D_SIZE);
        fprintf(stdout, " new addr %x ", pBuf);
        fflush(stdout);
        Pointers[i].size = nsize;
        Pointers[i].ptr = pBuf+D_SIZE;
        if(Ckb(i))
                fprintf(stdout, " Chk2 OK ");
        else
            exit(2);
        return pBuf+D_SIZE;
    }
}
#else   // IF !DEBUG_HEAP_ALLOCS

/*** GetMem - memory allocator
*
* Purpose:
*   Allocate memory block and zero-out it. Report problems.
*
* Input:
*   - size - memory block size in bytes.
*
* Output:
*   If sucessfull function returns pointer to the allocated memory,
*   otherwise function doesnt return.
*
* Exceptions:
*   No more memory - fatal error - abort
*
* Notes:
*   None.
*
*************************************************************************/
#pragma intrinsic(memset)

BYTE FAR                *GetMem(unsigned size)
{
    BYTE FAR            *p;

    p = (BYTE FAR *) FMALLOC(size);
    if (p == NULL)
        Fatal(ER_memovf);
    FMEMSET(p, 0, size);
    return(p);
}
#pragma function(memset)

#endif // !DEBUG_HEAP_ALLOCS

/*** DeclareStdIds - declare standard identifiers
*
* Purpose:
*   Introduce to linker's symbol table standard identifiers
*
* Input:
*   None.
*
* Output:
*   No explicit value is returned. Symbol table is initialized.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


void                    DeclareStdIds(void)
{
    APROPGROUPPTR       papropGroup;

    // Definition of DGROUP

    papropGroup = (APROPGROUPPTR ) PropSymLookup((BYTE *) "\006DGROUP", ATTRGRP, TRUE);
    papropGroup->ag_ggr = ggrMac;

    // In case we won't see a DGROUP definition
    mpggrrhte[ggrMac] = vrhte;

    ggrDGroup = ggrMac++;

    // Definition of class "CODE"

    PropSymLookup((BYTE *) "\004CODE", ATTRNIL, TRUE);
                                        /* Create hash table entry */
    vrhteCODEClass = vrhte;             /* Save virtual hash table address */

    // Definition of special classes

    PropSymLookup((BYTE *) "\007BEGDATA", ATTRNIL, TRUE);
    rhteBegdata = vrhte;
    PropSymLookup((BYTE *) "\003BSS", ATTRNIL, TRUE);
    rhteBss = vrhte;
    PropSymLookup((BYTE *) "\005STACK", ATTRNIL, TRUE);
    rhteStack = vrhte;
}


#if FDEBUG
/*
 *  Print statistics to list file or console.
 */
LOCAL void NEAR         PrintStats()
{
    if (fLstFileOpen)                   /* Send to list file if any */
        bsErr = bsLst;

    // Print statistics

    FmtPrint(GetMsg(STAT_segs), gsnMac - 1);
    FmtPrint(GetMsg(STAT_groups), ggrMac - 1);
    FmtPrint(GetMsg(STAT_bytes),
#if NEWSYM
      (long) cbSymtab);
#else
      (long) rbMacSyms << SYMSCALE);
#endif
#if OVERLAYS
    if (fOverlays)
        FmtPrint(GetMsg(STAT_ovls), iovMac);
#endif
    bsErr = stderr;                     /* Reset */
}
#endif /* FDEBUG */

    /****************************************************************
    *                                                               *
    *  CleanUp:                                                     *
    *                                                               *
    *  This function cleans up after the rest of the linker.        *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR  CleanUp(void)
{
    SBTYPE       buf;

    if (bsRunfile != NULL)       /* If run file open, close it */
        CloseFile (bsRunfile);
    if(vgsnLineNosPrev && fLstFileOpen) NEWLINE(bsLst); /* Write newline */
#if CMDMSDOS AND NOT WIN_3
    if (
#if QCLINK
        !fZ1 &&
#endif
        cErrors)                /* If there were non-fatal errors */
        FmtPrint(strcpy(buf, GetMsg((MSGTYPE)(cErrors > 1 ? P_errors : P_1error))),
            cErrors);
#endif
}

#if NEWIO
/* #pragma loop_opt(on) */
/*
 *  FreeHandle : Free a file handle by closing an open file
 *
 *  In pass 1, close the currently open file.  In pass 2, close
 *  an open library handle.
 *  Mark the appropriate record fields 0 to indicate unopened.
 */
void                    FreeHandle ()
{
    APROPFILEPTR        apropFile;      /* Pointer to file */
    RBTYPE              vindx;          /* Virtual temp. pointer */
    int                 FileHandle;
    int                 CurrentFileHandle;
    FTYPE               fLibFile;
    int                 count;


    CurrentFileHandle = fileno(bsInput);

    /* Loop throught all open files and close one, that is different from */
    /* currently open file                                                */

    vindx = rprop1stOpenFile;
    count = 0;
    do
    {
      apropFile = (APROPFILEPTR) FetchSym(vindx,TRUE);
                                     /* Fetch file property cell from VM */
      fLibFile = (FTYPE) (apropFile->af_ifh != FHNIL);
                                     /* Check if this is library file    */
      if (fLibFile)                  /* Get file handle                  */
        FileHandle = mpifhfh[apropFile->af_ifh];
      else
        FileHandle = apropFile->af_fh;

      if (FileHandle &&
          FileHandle != CurrentFileHandle &&
          FileHandle != vmfd)
      {                              /* File can be closed               */
          _close(FileHandle);
          count++;
          if (fLibFile)              /* Mark data structures             */
            mpifhfh[apropFile->af_ifh] = 0;
          else
            apropFile->af_fh = 0;

          if (count == 2)
          {
            rprop1stOpenFile = (apropFile->af_FNxt == RHTENIL) ?
                                r1stFile : apropFile->af_FNxt;
                                     /* Set new first open file pointer  */
                                     /* If end of file list goto list begin */
                                     /* Becouse of bug in bind API emulation */
                                     /* we have to free to handles at any time */
            break;                   /* Job done                         */
          }
      }

      vindx = (apropFile->af_FNxt == RHTENIL) ? r1stFile : apropFile->af_FNxt;

    } while (vindx != rprop1stOpenFile);


}

/* #pragma loop_opt(off) */

/*
 *  SmartOpen : open a file, closing another file if necessary
 *
 *  Open the given file for binary reading, plus sharing mode
 *  "deny write" if library file.  If no more handles, free a
 *  handle and try again.  Update mpifhfh[].
 *
 *  PARAMETERS:
 *      sbInput         Null-terminated string, name of file
 *      ifh             File index (FHNIL if not a library)
 *
 *  RETURNS
 *      File handle of opened file or -1.
 *
 *  SIDE EFFECTS
 *      Sets mpifhfh[ifh] to file handle if successful.
 */
int NEAR                SmartOpen (char *sbInput, int ifh)
{
    int                 fh;             /* File handle */
    FTYPE               fLib;           /* True if library */
    int                 secondtry = 0;  /* True if on second try */

    // Determine whether library file or not.

    fLib = (FTYPE) (ifh != FHNIL);
    secondtry = 0;

    // Do at most twice

    for(;;)
    {
        if (fLib)
            fh = _sopen(sbInput, O_BINARY|O_RDONLY, SH_DENYWR);
        else
            fh = _open(sbInput, O_BINARY|O_RDONLY);

        // If open succeeds or we've tried twice exit the loop.

        if (fh != -1 || secondtry)
            break;

        // Prepare for second try:  free a file handle

        FreeHandle();
        secondtry = 1;
    }

    // If library file and open succeeded, update mpifhfh[].

    if (fLib && fh != -1)
        mpifhfh[ifh] = (char) fh;
    return(fh);
}
#endif /* NEWIO */


/*** SearchPathLink - self-expalnatory
*
* Purpose:
*   Search given path for given file and open file if found.
*
* Input:
*   lpszPath     - path to search
*   pszFile      - file to search for
*   ifh          - file handle index for libraries
*   fStripPath   - TRUE if original path specification
*                  can be ignored
*
* Output:
*   Returns file handle if file was found.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

#pragma check_stack(on)

int  NEAR               SearchPathLink(char FAR *lpszPath, char *pszFile,
                                   int ifh, WORD fStripPath)
{
    char                oldDrive[_MAX_DRIVE];
    char                oldDir[_MAX_DIR];
    char                oldName[_MAX_FNAME];
    char                oldExt[_MAX_EXT];
    char                newDir[_MAX_DIR];
    char                fullPath[_MAX_PATH];
    int                 fh;
    char FAR            *lpch;
    char                *pch;


    /* Decompose pszFile into four components */

    _splitpath(pszFile, oldDrive, oldDir, oldName, oldExt);

    // Don't search path if the input file has absolute or
    // relative path and you are not allowed to ignore it

    if (!fStripPath && (oldDrive[0] != '\0' || oldDir[0] != '\0'))
        return(-1);

    /* Loop through environment value */

    lpch = lpszPath;
    pch  = newDir;
    do
    {
        if (*lpch == ';' || *lpch == '\0')
        {                                 /* If end of path specification */
            if (pch > newDir)
            {                             /* If specification not empty */
                if (!fPathChr(pch[-1]) && pch[-1] != ':')
                    *pch++ = CHPATH;      /* Add path char if none */
                *pch = '\0';
                _makepath(fullPath, NULL, newDir, oldName, oldExt);

                fh = SmartOpen(fullPath, ifh);
                if (fh > 0)
                    return(fh);           /* File found - return file handle */
                pch = newDir;             /* Reset pointer */
            }
        }
        else
            *pch++ = *lpch;               /* Else copy character to path */
    }
    while(*lpch++ != '\0' && pch < &newDir[_MAX_DIR - 1]);
                                          /* Loop until end of string */
    return(-1);
}

#pragma check_stack(off)


    /****************************************************************
    *                                                               *
    *  DrivePass:                                                   *
    *                                                               *
    *  This  function  applies  either  the  pass 1 or  the pass 2  *
    *  object module  processor  to  all  the objects being linked  *
    *  together.                                                    *
    *                                                               *
    ****************************************************************/

void NEAR               DrivePass(void (NEAR *pProcessPass)(void))
{
    GRTYPE              grggr[GRMAX];   /* f(local grpnum) = global grpnum */
    SNTYPE              sngsn[SNMAX];   /* f(local segnum) = global segnum */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    APROPFILEPTR        apropFile;      /* Pointer to file entry */
    int                 ifh;            /* File handle index */
    RBTYPE              rbFileNext;     /* Ptr to prop list of next file */
    long                lfa;            /* File offset */
    WORD                i;
    BYTE                *psbName;
#if NEWSYM
    BYTE                *sbInput;
#else
    SBTYPE              sbInput;        /* Input file name */
#endif
#if OSMSDOS
    BYTE                b;              /* A byte */
#endif
#if NEWIO
    int                 fh;             /* File handle */
#endif

    fDrivePass = (FTYPE) TRUE;          /* Executing DrivePass */
    mpgrggr = grggr;                    /* Initialize pointer */
    mpsngsn = sngsn;                    /* Initialize pointer */
    rbFileNext = rprop1stFile;          /* Next file to look at is first */
    while(rbFileNext)                   /* Loop to process objects */
    {
        vrpropFile = rbFileNext;        /* Make next file the current file */
        apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,FALSE);
                                        /* Fetch table entry from VM */
#if ILINK
        if (fIncremental)
            imodFile = apropFile->af_imod;
#endif
        rbFileNext = apropFile->af_FNxt;/* Get pointer to next file */
        ifh = apropFile->af_ifh;        /* Get the file handle index */
        fLibraryFile = (FTYPE) (ifh != FHNIL);
                                        /* Set library flag */
#if NEWIO
        if(fLibraryFile)
            fh = mpifhfh[ifh];
        else
            fh = (int) apropFile->af_fh;
#endif
        if(!vfPass1)
            vfNewOMF = (FTYPE) ((apropFile->af_flags & FNEWOMF) != 0);
        lfa = apropFile->af_lfa;        /* Get file offset */
        /* "Get hte (name) of file" */
        while(apropFile->af_attr != ATTRNIL)
        {                               /* While haven't found nil attr */
            vrhteFile = apropFile->af_next;
                                        /* Try next entry in list */
            apropFile = (APROPFILEPTR ) FetchSym(vrhteFile,FALSE);
                                        /* Fetch it from VM */
        }
        DEBUGVALUE(vrhteFile);          /* Debug info */
        ahte = (AHTEPTR ) apropFile;    /* Save pointer to hash tab entry */
#if CMDMSDOS
        /* Library file with offset 0 means process all the modules
         * the library.  This is done on pass 1; in pass 2 they are
         * inserted into the file list.
         */
        if(fLibraryFile && lfa == 0 && vfPass1)
        {
            psbName = GetFarSb(ahte->cch);
#if WIN_3
            StatMsgWin("%s\r\n", psbName+1);
#endif
#if C8_IDE
                if(fC8IDE)
                {
                        sprintf(msgBuf, "@I4%s\r\n", psbName+1);
                        _write(fileno(stderr), msgBuf, strlen(msgBuf));
                }
#endif
            GetLibAll(psbName);
            continue;
        }
#endif
        /* If new object file, or pass2 and new library, there's a
         * new file to open.
         */
        if(!fLibraryFile || (!fLibPass && ifhLast != ifh))
        {
#if NOT NEWIO
            if(!fLibPass && ifhLast != FHNIL) fclose(bsInput);
                                        /* Close previous lib. on pass two */
#endif
            for(;;)                     /* Loop to get input file and */
            {                           /* allow user to change diskette */
#if NEWSYM
                sbInput = GetFarSb(ahte->cch);
#else
                memcpy(sbInput,1 + GetFarSb(ahte->cch),B2W(ahte->cch[0]));
                                        /* Copy name to buffer */
                sbInput[B2W(ahte->cch[0])] = '\0';
                                        /* Null-terminate file name */
#endif

#if WIN_3
                StatMsgWin("%s\r\n", sbInput+1);
#endif
#if C8_IDE
                if(fC8IDE)
                {
                    sprintf(msgBuf, "@I4%s\r\n", sbInput+1);
                    _write(fileno(stderr), msgBuf, strlen(msgBuf));
                }
#endif
#if NEWIO
                if(!fh)
                    fh = SmartOpen(&sbInput[1],ifh);
                if(fh > 0)
                    break;
#if OSMSDOS
                else if (lpszLIB != NULL)
                {                       /* If variable set */
                    fh = SearchPathLink(lpszLIB, &sbInput[1], ifh, FALSE);
                    if(fh > 0)
                        break;          /* File found, breake WHILE loop */
                }
#endif
#else
                if((bsInput = fopen(sbInput,RDBIN)) != NULL)
                                        /* If no error opening input file */
                    break;              /* Exit loop */
#endif /* NEWIO */
#if OSMSDOS
                if (ahte->cch[2] == ':') b = (char) (ahte->cch[1] - 'A');
                                        /* If disk specified, grab it */
                else b = DskCur;        /* Else use current drive */
#endif
                fDrivePass = FALSE;
#if OSMSDOS
                /* "If we are changing the listfile device or
                *  the VM.TMP device or if the device is not
                *  changeable, then exit."
                */
                if((fLstFileOpen && b == chListFile) ||
                  (!fScrClosed && b == DskCur) || !FCHGDSK(b) ||
                    fNoprompt)
#endif
                    Fatal(ER_opnobj,&sbInput[1]);
#if OSMSDOS
                if(!(*pfPrompt)(NULL,ER_fileopn,(int) (INT_PTR)(sbInput+1),P_ChangeDiskette,
                                b + 'A'))
                    Fatal(0);
#endif
#if NEWIO
                fh = 0;
#endif
                fDrivePass = (FTYPE) TRUE;
#if OSXENIX
                break;                  /* Make sure we exit the loop */
#endif
            }

            if(fh > 0)
            {
                fflush(bsInput);
                bsInput->_file = (char) fh;
                bsInput->_flag &= ~_IOEOF;
            }
        }

        /* If previous module was in same library, do relative seek
         * else do absolute seek.
         * Can't do it with Xenix libraries unless __.SYMDEF is loaded
         * in memory.
         */
#if LIBMSDOS
        if(fLibraryFile && ifh == ifhLast)
        {
            if (lfa-lfaLast > 0)
              fseek(bsInput,lfa - lfaLast,1);
            else
              fseek(bsInput,lfa,0);
        }
        else
#endif
        if(fLibraryFile || !vfPass1)
            fseek(bsInput,lfa,0);       /* Seek to desired offset */
        lfaLast = lfa;                  /* Update current file position */
        (*pProcessPass)();              /* Call ProcP1 or ProcP2 */
        ifhLast = ifh;                  /* Save this file handle */
        if(!fLibraryFile)               /* If not a library */
        {
#if NEWIO
            apropFile = (APROPFILEPTR) FetchSym(vrpropFile,TRUE);
            if(vfPass1)
                apropFile->af_fh = fileno(bsInput);
            else
            {
                _close(fileno(bsInput));
                apropFile->af_fh = 0;
            }
#else
            fclose(bsInput);            /* Close input file */
#endif
        }
#if NEWIO
        rbFilePrev = vrpropFile;
#endif
    }
#if NEWIO
    if(!vfPass1)                        /* Free up file stream on pass two */
#else
    if(ifh != FHNIL && !vfPass1)        // Close libraries on pass two
#endif
    {
        for (i = 0; i < ifhLibMac; i++)
        {
            if (mpifhfh[i])
            {
                _close(mpifhfh[i]);
                mpifhfh[i] = 0;
            }
        }
    }
    fDrivePass = FALSE;                 /* No longer executing DrivePass */
}

    /****************************************************************
    *                                                               *
    *  PrintAnUndef:                                                *
    *                                                               *
    *  This  function will print  the name of an  undefined symbol  *
    *  and the name(s) of the module(s) in which it is referenced.  *
    *  This routine is passed as an argument to EnSyms().           *
    *                                                               *
    ****************************************************************/

LOCAL void              PrintAnUndef(prop,rhte,rprop,fNewHte)
APROPNAMEPTR            prop;           /* Pointer to undef prop cell */
RBTYPE                  rprop;          /* Virt addr of prop cell */
RBTYPE                  rhte;           /* Virt addr of hash tab ent */
WORD                    fNewHte;        /* True if name has been written */
{
    APROPUNDEFPTR       propUndef;
    AHTEPTR             hte;            /* Pointer to hash table entry */
    WORD                x;
    MSGTYPE             errKind;
    PLTYPE FAR *        entry;
    char                *puname;
    char                *substitute;
    SBTYPE              testName;
    SBTYPE              undecorUndef;
    SBTYPE              undecorSubst;


    propUndef = (APROPUNDEFPTR) prop;
    if (((propUndef->au_flags & WEAKEXT) && !(propUndef->au_flags & UNDECIDED)) ||
        !propUndef->u.au_rFil)
        return;                         // Don't print "weak" externs or
                                        // undefined exports

    hte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch symbol from hash table */
    puname = GetFarSb(hte->cch);
    substitute = NULL;
    if (propUndef->au_flags & SUBSTITUTE)
    {
        substitute = puname;
        puname = GetPropName(FetchSym(propUndef->au_Default, FALSE));
    }

    ++cErrors;                          /* Increment error count */

    hte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch symbol from hash table */
    errKind = ER_UnresExtern;
#if WIN_3
    fSeverity = SEV_ERROR;
#endif

    // Check here for calling convention mismatch

    if (puname[1] == '@' || puname[1] == '_')
    {
        strcpy(testName, puname);
        if (testName[1] == '@')
            testName[1] = '_';
        else
            testName[1] = '@';

        // Check for fast-call/C-call mismatch

        if (PropSymLookup(testName, ATTRPNM, FALSE) != PROPNIL)
            errKind = ER_callmis;
        else
        {
            // Check for Pascal/fast-call or C-call mismatch

            for (x = 1; x < testName[0]; x++)
                testName[x] = (BYTE) toupper(testName[x + 1]);
            testName[0]--;
            if (PropSymLookup(testName, ATTRPNM, FALSE) != PROPNIL)
                errKind = ER_callmis;
        }
    }

    // Undecorate names if necessary

    if (puname[1] == '?')
    {
        UndecorateSb(puname, undecorUndef, sizeof(undecorUndef));
        puname = undecorUndef;
    }

    if (substitute && substitute[1] == '?')
    {
        UndecorateSb(substitute, undecorSubst, sizeof(undecorSubst));
        substitute = undecorSubst;
    }

    // Walk the list of file references to this symbol

    entry = propUndef->u.au_rFil;
    vrpropFile = 0;
    do
    {
        if (vrpropFile != entry->pl_rprop)
            vrpropFile = entry->pl_rprop;/* Set the file pointer */
        else
        {
            entry = entry->pl_next;         /* Advance the list pointer */
            continue;
        }
        if(fLstFileOpen && bsLst != stdout)
        {                               /* If listing but not to console */
#if QCLINK
            if (fZ1)
            {
                fZ1 = FALSE;            // Restore normal linker print function
                OutFileCur(bsLst);      // Output file name
                fZ1 = (FTYPE) TRUE;     // Restore QC call-back
            }
            else
#endif
            {
                #if WIN_3
                APROPFILEPTR    apropFile;      /* Pointer to file property cell */
                AHTEPTR     ahte;       /* Pointer symbol name */
                SBTYPE      sb;     /* String buffer */
                int         n;      /* String length counter */

                apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,FALSE);
                ahte = GetHte(vrpropFile);
                for(n = B2W(ahte->cch[0]), sb[n+1] = 0; n >= 0; sb[n] = ahte->cch[n], --n);
                fprintf(bsLst, sb+1);
                #else
                OutFileCur(bsLst);    /* Output file name */
                #endif
            }


        }
        OutFileCur(stderr);             /* Output file name */
        if(fLstFileOpen && bsLst != stdout)
        {                               /* If listing but not to console */
#if MSGMOD
            fprintf(bsLst, " : %s %c%04d: ",
                        __NMSG_TEXT(N_error), 'L', ER_UnresExtern);
            fprintf(bsLst, GetMsg(errKind), &puname[1]);
            if (substitute)
                fprintf(bsLst, GetMsg(ER_UnresExtra), &substitute[1]);
#else
            fprintf(bsLst, " : error: ");
            fprintf(bsLst, GetMsg(errKind), &puname[1]);
#endif
        }

#if MSGMOD
        FmtPrint(" : %s %c%04d: ", __NMSG_TEXT(N_error), 'L', errKind);
        FmtPrint(GetMsg(errKind), &puname[1]);
        if (substitute)
            FmtPrint(GetMsg(ER_UnresExtra), &substitute[1]);
#else
        FmtPrint(" : error: ");
        FmtPrint(GetMsg(errKind), &puname[1]);
#endif
        entry = entry->pl_next;         /* Advance the list pointer */
    } while(entry != NULL);
}

#if OSEGEXE AND NOT QCLINK
LOCAL void NEAR         InitFpSym(sb, flags)
BYTE *                  sb;
BYTE                    flags;
{
    APROPNAMEPTR        aprop;

    /* If symbol exists as EXTDEF, convert to PUBDEF */
    aprop = (APROPNAMEPTR ) PropSymLookup(sb,ATTRUND,FALSE);
    if(aprop != PROPNIL)
    {
        aprop->an_attr = ATTRPNM;
        aprop->an_gsn = 0;
        aprop->an_ra = 0;
        aprop->an_ggr = 0;
        aprop->an_flags = 0;
    }
    /* Otherwise, if it exists as a PUBDEF, get it else quit */
    else
    {
        aprop = (APROPNAMEPTR) PropSymLookup(sb,ATTRPNM,FALSE);
        if(aprop == PROPNIL)
            return;
    }
    aprop->an_flags |= flags;
    MARKVP();
}

/*
 *  InitFP
 *
 *  Initialize table for processing floating-point fixups for new-format
 *  executables.
 */

LOCAL void NEAR         InitFP ()
{
        InitFpSym((BYTE *) "\006FIARQQ", 1 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FISRQQ", 2 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FICRQQ", 3 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FIERQQ", 4 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FIDRQQ", 5 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FIWRQQ", 6 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FJARQQ", FFP2ND);
        InitFpSym((BYTE *) "\006FJSRQQ", FFP2ND);
        InitFpSym((BYTE *) "\006FJCRQQ", FFP2ND);
}
#endif /* OSEGEXE  AND NOT QCLINK */

#if (OSEGEXE AND CPU286)

/* until the 16 bit bsedos.h supports these definitions: */

#define FAPPTYP_NOTSPEC         0x0000
#define FAPPTYP_NOTWINDOWCOMPAT 0x0001
#define FAPPTYP_WINDOWCOMPAT    0x0002
#define FAPPTYP_WINDOWAPI       0x0003
#define FAPPTYP_BOUND           0x0008
#define FAPPTYP_DLL             0x0010
#define FAPPTYP_DOS             0x0020
#define FAPPTYP_PHYSDRV         0x0040  /* physical device driver       */
#define FAPPTYP_VIRTDRV         0x0080  /* virtual device driver        */
#define FAPPTYP_PROTDLL         0x0100  /* 'protected memory' dll       */

/* I added these definitions: */

#define _FAPPTYP_32BIT          0x4000
#define _FAPPTYP_EXETYPE        FAPPTYP_WINDOWAPI

/*-----------------------------------------------------------*/
/* from cruiser DCR 1117: */
/*
 *  PM Program                             PM    (0x0)
 *  DOS                                    DOSFS (0x1)
 *  OS/2 or FAPI Window Compatible         OS2W  (0x2)
 *  OS/2 or FAPI Non-Window Compatible     OS2FS (0x3)
 */
#define _AT_PMAPI               0x00            /* Uses PM API */
#define _AT_DOS                 0x01            /* DOS APP */
#define _AT_PMW                 0x02            /* Window compatible */
#define _AT_NOPMW               0x03            /* Not Window compatible */
#define _AT_EXETYPE             0x03            /* EXE type mask */




/*** InitEA - initialize buffer describing extended attribute
*
* Purpose:
*   Initialize EA buffer by coping its name and setting up the FEALIST.
*
* Input:
*   pEABuf       - pointer to EA buffer
*   cbBuf        - size of EA buffer
*   pszEAName    - extended attribute name
*   peaop        - pointer to EA operand
*   cbEAVal      - size of extended attribute value
*   bEAFlags     - extended attribute flags
*
* Output:
*   Pointer to the place where the EA value should be copied into EA buffer
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL BYTE * NEAR       InitEA(BYTE *pEABuf, WORD cbBuf, char *pszEAName,
                               EAOP *peaop, WORD cbEAVal, WORD bEAFlags)
{
    WORD                cbFEAList;
    FEALIST             *pfeaList;
    WORD                cbEAName;
    BYTE                *pszT;


    cbEAName = strlen(pszEAName);
    cbFEAList = sizeof(FEALIST) + 1 + cbEAName + cbEAVal + 2*sizeof(USHORT);
    if (cbFEAList > cbBuf)
        return(NULL);

    pfeaList = (FEALIST *) pEABuf;

    /* First initialize the EAOP structure */

    peaop->fpGEAList = NULL;      /* Not used for sets */
    peaop->fpFEAList = (PFEALIST)pfeaList;

    /* Now initialize the FEAList */

    pfeaList->cbList = cbFEAList;
    pfeaList->list[0].fEA = (BYTE) bEAFlags;
    pfeaList->list[0].cbName = (unsigned char) cbEAName;
    pfeaList->list[0].cbValue = cbEAVal + 2*sizeof(USHORT);
    pszT = (char *) pfeaList + sizeof(FEALIST);
    strcpy(pszT, pszEAName);
    pszT += cbEAName + 1;
    return(pszT);
}


#pragma check_stack(on)

/*** SetFileEABinary - set file extended attribute binary value
*
* Purpose:
*   Set file extended attributes for OS/2 1.2 and higher.
*
* Input:
*   fh           - file handle
*   pszEAName    - extended attribute name
*   EAVal        - extended attribute value
*   bEAFlags     - extended attribute flags
*
* Output:
*   No explicit value is returned. If succesfull file extended attributes
*   are set, otherwise not.
*
* Exceptions:
*   None.
*
* Notes:
*   This function allocates quite a bit on stack, so don't remove
*   stack checking pragma.
*
*************************************************************************/


LOCAL void NEAR         SetFileEABinary(int fh, char *pszEAName,
                                        BYTE *pEAVal, USHORT cbEAVal,
                                        WORD bEAFlags)
{
    BYTE                bEABuf[512];        /* Should be enought for linker purposes */
    EAOP                eaop;
    BYTE                *pszT;
    WORD                retCode;



    if (pszEAName == NULL || cbEAVal > sizeof(bEABuf))
        return;


    pszT = InitEA(bEABuf, sizeof(bEABuf), pszEAName, &eaop, cbEAVal, bEAFlags);
    if (pszT == NULL)
        return;

    *((USHORT *)pszT) = EAT_BINARY;
    pszT += sizeof(USHORT);
    *((USHORT *)pszT) = cbEAVal;
    pszT += sizeof(USHORT);
    memmove(pszT, pEAVal, cbEAVal);

    /* Now call the set file info to set the EA */

    retCode = DosSetFileInfo(fh, 0x2, (void FAR *)&eaop, sizeof(EAOP));
#if FALSE
    switch (retCode)
    {
        case 0:
            fprintf(stdout, "EA -> Binary set - %s; %d bytes\r\n", pszEAName, cbEAVal);
            break;
        case ERROR_BUFFER_OVERFLOW:
            fprintf(stdout, "Buffer overflow\r\n");
            break;
        case ERROR_DIRECT_ACCESS_HANDLE:
            fprintf(stdout, "Direct access handle\r\n");
            break;
        case ERROR_EA_LIST_INCONSISTENT:
            fprintf(stdout, "EA list inconsistent\r\n");
            break;
        case ERROR_INVALID_EA_NAME:
            fprintf(stdout, "Invalid EA name\r\n");
            break;
        case ERROR_INVALID_HANDLE:
            fprintf(stdout, "Invalid handle\r\n");
            break;
        case ERROR_INVALID_LEVEL:
            fprintf(stdout, "Invalid level\r\n");
            break;
        default:
            fprintf(stdout, "Unknow %d\r\n", retCode);
            break;
    }
#endif
    return;
}


/*** SetFileEAString - set file extended attribute string
*
* Purpose:
*   Set file extended attributes for OS/2 1.2 and higher.
*
* Input:
*   fh           - file handle
*   pszEAName    - extended attribute name
*   pszEAVal     - extended attribute string
*   bEAFlags     - extended attribute flags
*
* Output:
*   No explicit value is returned. If succesfull file extended attributes
*   are set, otherwise not.
*
* Exceptions:
*   None.
*
* Notes:
*   This function allocates quite a bit on stack, so don't remove
*   stack checking pragma.
*
*************************************************************************/


LOCAL void NEAR         SetFileEAString(int fh, char *pszEAName,
                                        char *pszEAVal, WORD bEAFlags)
{
    BYTE                bEABuf[512];        /* Should be enought for linker purposes */
    EAOP                eaop;
    WORD                cbEAVal;
    char                *pszT;
    WORD                retCode;



    if (pszEAName == NULL)
        return;

    if (pszEAVal != NULL)
        cbEAVal = strlen(pszEAVal);
    else
        cbEAVal = 0;

    pszT = InitEA(bEABuf, sizeof(bEABuf), pszEAName, &eaop, cbEAVal, bEAFlags);
    if (pszT == NULL)
        return;

    if (pszEAVal != NULL)
    {
        *((USHORT *)pszT) = EAT_ASCII;
        pszT += sizeof(USHORT);
        *((USHORT *)pszT) = cbEAVal;
        pszT += sizeof(USHORT);
        memmove(pszT ,pszEAVal , cbEAVal);
    }

    /* Now call the set path call to set the EA */

    retCode = DosSetFileInfo(fh, 0x2, (void FAR *)&eaop, sizeof(EAOP));
#if FALSE
    switch (retCode)
    {
        case 0:
            fprintf(stdout, "EA -> String set - %s = '%s'\r\n", pszEAName, pszEAVal);
            break;
        case ERROR_BUFFER_OVERFLOW:
            fprintf(stdout, "Buffer overflow\r\n");
            break;
        case ERROR_DIRECT_ACCESS_HANDLE:
            fprintf(stdout, "Direct access handle\r\n");
            break;
        case ERROR_EA_LIST_INCONSISTENT:
            fprintf(stdout, "EA list inconsistent\r\n");
            break;
        case ERROR_INVALID_EA_NAME:
            fprintf(stdout, "Invalid EA name\r\n");
            break;
        case ERROR_INVALID_HANDLE:
            fprintf(stdout, "Invalid handle\r\n");
            break;
        case ERROR_INVALID_LEVEL:
            fprintf(stdout, "Invalid level\r\n");
            break;
        default:
            fprintf(stdout, "Unknow %d\r\n", retCode);
            break;
    }
#endif
    return;
}

#pragma check_stack(off)

#endif

#pragma check_stack(on)

/*
 *  OutRunFile:
 *
 *  Top-level routine to outputting executable file.  Prepares some,
 *  then calls routine to do the work according exe format.
 */

LOCAL void NEAR         OutRunFile(sbRun)
BYTE                    *sbRun;         /* Executable file name */
{
    AHTEPTR             hte;            /* Hash table entry address */
#if (OSEGEXE AND CPU286) OR EXE386
#pragma pack(1)
    struct {
             WORD ibm;                  /* IBM part */
             WORD ms;                   /* Microsoft part */
           }            EAAppType;      /* Happy EA's !?! */
#pragma pack()
#endif
#if defined(M_I386) || defined( _WIN32 )
    BYTE                *pIOBuf;
#endif


    CheckSegmentsMemory();
#if CMDMSDOS
#if ODOS3EXE
    if(fQlib)
        ValidateRunFileName(sbDotQlb, TRUE, TRUE);
                                        /* Force extension to .QLB */
    else if (fBinary)
        ValidateRunFileName(sbDotCom, TRUE, TRUE);
                                        /* Force extension to .COM */
    else
#endif
#if OSMSDOS
    /* If runfile is a dynlink library and no runfile extension
     * has been given, force the extension to ".DLL".  Issue a
     * warning that the name is being changed.
     */
    if ((vFlags & NENOTP) && (TargetOs == NE_OS2))
        ValidateRunFileName(sbDotDll, TRUE, TRUE);
    else
#endif /* OSMSDOS */
        ValidateRunFileName(sbDotExe, TRUE, TRUE);
                                        /* If extension missing add .EXE */
#endif
    hte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
                                        /* Get run file name */
#if OSMSDOS
#if NOT WIN_NT
    if(hte->cch[2] != ':')              /* If no drive spec */
    {
        sbRun[1] = chRunFile;           /* Use saved drive letter */
        sbRun[2] = ':';                 /* Put in colon */
        sbRun[0] = '\002';              /* Set length */
    }
    else
#endif
        sbRun[0] = '\0';                /* Length is zero */
    memcpy(&sbRun[B2W(sbRun[0]) + 1],&GetFarSb(hte->cch)[1],B2W(hte->cch[0]));
                                        /* Get name from hash table */
    sbRun[0] += hte->cch[0];            /* Fix length */
#else
    memcpy(sbRun,GetFarSb(hte->cch),B2W(hte->cch[0]) + 1);
                                        /* Get name from hash table */
#endif
    sbRun[B2W(sbRun[0]) + 1] = '\0';
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf, "@I4%s\r\n", sbRun+1);
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

    if ((bsRunfile = fopen(&sbRun[1],WRBIN)) == NULL)
        Fatal(ER_runopn, &sbRun[1], strerror(errno));
#if CPU286 AND OSMSDOS
    /* Relative seeking to character devices is prohibited in
     * protect mode (and under API emulation).  Since we call fseek
     * later on, if the output file is a character device then just
     * skip the output stage.
     */
    if(isatty(fileno(bsRunfile)))
        return;
#endif
#if OSMSDOS
#if defined(M_I386) || defined( _WIN32 )
    pIOBuf = GetMem(_32k);              // Allocate 32k I/O buffer
    setvbuf(bsRunfile,pIOBuf,_IOFBF,_32k);
#else
    setvbuf(bsRunfile,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
#endif
    psbRun = sbRun;                     /* Set global pointer */
#if OIAPX286
    OutXenExe();
#endif
#if OSEGEXE
#if EXE386
    OutExe386();
#else
    if(fNewExe)
        OutSegExe();
#if ODOS3EXE
    else
#endif
#endif
#endif
#if ODOS3EXE
        OutDos3Exe();
#endif
#if (OSEGEXE AND CPU286)
    if ((_osmode == OS2_MODE && (_osmajor == 1 && _osminor >= 20 || _osmajor >= 2)) ||
        (_osmode == DOS_MODE && _osmajor >= 10))
    {
        /* Set Extended Attributes for .EXE file */

        SetFileEAString(fileno(bsRunfile), ".TYPE", "Executable", 0);
        EAAppType.ibm = 0;
        EAAppType.ms  = FAPPTYP_NOTSPEC;
        if (fNewExe)
        {
#if NOT EXE386
            if (vFlags & NENOTP)
                EAAppType.ms = FAPPTYP_DLL;

            if ((vFlags & NEWINAPI) == NEWINAPI)
            {
                EAAppType.ibm = _AT_PMAPI;
                EAAppType.ms  |= FAPPTYP_WINDOWAPI;
            }
            else if (vFlags & NEWINCOMPAT)
            {
                EAAppType.ibm = _AT_PMW;
                EAAppType.ms  |= FAPPTYP_WINDOWCOMPAT;
            }
            else if (vFlags & NENOTWINCOMPAT)
            {
                EAAppType.ibm = _AT_NOPMW;
                EAAppType.ms  |= FAPPTYP_NOTWINDOWCOMPAT;
            }
#endif
        }
        else
        {
            EAAppType.ibm = _AT_DOS;
            EAAppType.ms  = FAPPTYP_DOS;
        }

        SetFileEABinary(fileno(bsRunfile), ".APPTYPE",
                        (BYTE *) &EAAppType, sizeof(EAAppType), 0);
    }
#endif
    CloseFile(bsRunfile);                /* Close run file */
#if defined(M_I386) || defined( _WIN32 )
    FreeMem(pIOBuf);
#endif
#if OSXENIX
    if(!fUndefinedExterns) chmod(&sbRun[1],0775 & ~umask(077));
                                        /* Set protection executable */
#endif
}

#pragma check_stack(off)

#if NOT WIN_3

/*** SpawnOther - spawn any other processes
*
* Purpose:
*   Spawn the other processes (i.e. cvpack) necessary to complete the
*   construction of the executible.
*
* Input:
*   sbRun        - pointer to the name of the executible
*
* Output:
*   None.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         SpawnOther(sbRun, szMyself)
BYTE                    *sbRun;         /* Executable file name */
BYTE                    *szMyself;      /* A full LINK path */
{
    char FAR            *env[2];        /* Enviroment for MPC */
    SBTYPE              progName;       /* Program to invoke after linker */
    SBTYPE              progOptions;    /* Program options */
    char                path_buffer[_MAX_PATH]; /* Stuff for splitpath() */
    char                drive[_MAX_DRIVE];
    char                dir[_MAX_DIR];
    char                fname[_MAX_FNAME];
    char                ext[_MAX_EXT];
    intptr_t            status;


    if ((
#if PCODE
         fMPC ||
#endif
                 (fSymdeb && fCVpack)
#if O68K
        || iMacType != MAC_NONE
#endif
        ) && !cErrors && !fUndefinedExterns)
    {
#if FAR_SEG_TABLES
        FreeSymTab();
#if NOT WIN_NT AND NOT DOSX32
        _fheapmin();
#endif
#endif

#if NOT WIN_NT
        if(lpszPath != NULL)
        {
            FSTRCPY((char FAR *) bufg, lpszPath - 5);
            env[0] = (char FAR *) bufg;
            env[1] = NULL;
            _putenv((char FAR *) bufg);
        }
#endif
#if O68K
        if (fMPC || (fSymdeb && fCVpack)) {
#endif /* O68K */
            progOptions[0] = '\0';
#if PCODE
            if (fSymdeb && fCVpack && fMPC)
            {
                strcpy(progName, "cvpack");
                strcpy(progOptions, "/pcode");
            }
            else
                strcpy(progName, fMPC ? "mpc" : "cvpack16");
#else
            strcpy(progName, "cvpack");
#endif
#ifndef C8_IDE
            if (fNoBanner)
#endif
                strcat(progOptions, "/nologo");

            // Now determine which instance of child is to be loaded
            // First - check the LINK directory

            _splitpath(szMyself, drive, dir, fname, ext);
            strcpy(fname, progName);
            _makepath(path_buffer, drive, dir, fname, ext);
            if (_access(path_buffer, 0) != 0)    // file not in the LINK dir
            {
               // Second - check the current dir

               drive[0] = '\0';
               _getcwd(dir, _MAX_DIR);
               _makepath(path_buffer, drive, dir, fname, ext);
               if (_access(path_buffer, 0) != 0) // file not in the current dir
               {
                  strcpy(path_buffer, progName);// spawn on the PATH
               }
            }
#if NOT (WIN_NT OR EXE386)

            // If /TINY is active, we are building a .COM file,
            // and the cv info is in a .DBG file

            if (fBinary)
            {
                 _splitpath(sbRun+1, drive, dir, fname, ext);
                 strcpy(ext, ".DBG");
                 _makepath(sbRun+1, drive, dir, fname, ext);
            }
#endif
#if WIN_NT OR DOSX32
            if ((status = _spawnlp(P_WAIT, path_buffer, path_buffer, progOptions, &sbRun[1], NULL)) == -1)
                OutWarn(ER_badspawn, path_buffer, &sbRun[1], strerror(errno));
            else if (status != 0)
                cErrors++;
#else
            if (spawnlpe(
#if DOSEXTENDER
                (!_fDosExt) ?
#else
                (_osmode == DOS_MODE && _osmajor < 10) ?
#endif
                P_OVERLAY : P_WAIT, path_buffer, path_buffer, progOptions, &sbRun[1], NULL, env) == -1)
                OutWarn(ER_badspawn, path_buffer, &sbRun[1], strerror(errno));


#endif
#if O68K
        }
        if (iMacType != MAC_NONE) {
            progOptions[0] = '\0';
            strcpy(progName, "link_68k");

            /*  Now determine which instance of child is to be loaded */
            /*  First - check the LINK directory */

            _splitpath (szMyself, drive, dir, fname, ext);
            strcpy (fname, progName);
            _makepath (path_buffer, drive, dir, fname, ext);
            if (_access (path_buffer, 0) != 0)   // file not in the LINK dir
            {
               // Second - check the current dir
               drive[0] = '\0';
#if (_MSC_VER >= 700)
               _getcwd (0, dir, _MAX_DIR);
#else
               _getcwd (dir, _MAX_DIR);
#endif
               _makepath (path_buffer, drive, dir, fname, ext);
               if (_access (path_buffer, 0) != 0) // file not in the current dir
               {
                  strcpy (path_buffer, progName); // spawn on the PATH
               }
            }

            if (iMacType == MAC_SWAP)
                strcat(progOptions, "/s ");
            if (fSymdeb)
                strcat(progOptions, "/c ");

            if ((status = spawnlp(P_WAIT, path_buffer, path_buffer,
              progOptions, &sbRun[1], NULL)) == -1)
                OutWarn(ER_badspawn, path_buffer, &sbRun[1], strerror(errno));
            else if (status != 0)
                cErrors++;

        }
#endif /* O68K */
    }
}

#endif
    /****************************************************************
    *                                                               *
    *  InterPass:                                                   *
    *                                                               *
    *  Take care of miscellaneous items which must be done between  *
    *  pass 1 and 2.                                                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         InterPass (void)
{

#if OEXE
    if(!fPackSet) packLim = fNewExe ?
#if EXE386
                                    CBMAXSEG32 :
#elif O68K
                                    (iMacType != MAC_NONE ? LXIVK / 2 :
                                    LXIVK - 36) :
#else
                                    LXIVK - 36 :
#endif
                                    0L;
#endif
#if NOT EXE386
    // Set TargetOS - see LINK540 bug #11 for description

    if (fNewExe && TargetOs != NE_OS2)
    {
        // Import/export seen in the OBJ files or .DEF file specified
#if CPU286
        if(rhteDeffile == RHTENIL)  // OS2 host and no .def file - OS2 target
            TargetOs = NE_OS2;
        else
            TargetOs = NE_WINDOWS;
#else
            TargetOs = NE_WINDOWS;
#endif
    }
#endif
#if ODOS3EXE

    // /DOSSEG (from switch or comment rec) forces off /DS, /NOG

    if (fSegOrder)
        vfDSAlloc = fNoGrpAssoc = FALSE;
#endif

#if ILINK
    fQCIncremental = (FTYPE) (!fNewExe && fIncremental);
                         /* QC incremental link */
    if (fQCIncremental)
    {
        TargetOs = 0xff; /* Mark .EXE as not compatibile with OS/2 .EXE */
        fNewExe = (FTYPE) TRUE;  /* Force to build segemented-executable */
    }
#endif

#if ODOS3EXE AND OSEGEXE AND NOT EXE386
    if (fNewExe)
    {
        // Check for invalid options for segmented-executable and ignore them

        if ((vFlags & NENOTP) && cbStack)
        {
            cbStack = 0;          // For DLLs ignore STACKSIZE
            OutWarn(ER_ignostksize);
        }
        if (

#if ILINK
        !fQCIncremental &&
#endif
                           cparMaxAlloc != 0xffff)
        {
            OutWarn(ER_swbadnew, "/HIGH or /CPARMAXALLOC");
            cparMaxAlloc = 0xffff;
        }
        if (vfDSAlloc)
        {
            OutWarn(ER_swbadnew, "/DSALLOCATE");
            vfDSAlloc = FALSE;
        }
        if (fNoGrpAssoc)
        {
            OutWarn(ER_swbadnew, "/NOGROUPASSOCIATION");
            fNoGrpAssoc = FALSE;
        }
        if (fBinary)
        {
            OutWarn(ER_swbadnew, "/TINY");
            fBinary = FALSE;
        }
#if OVERLAYS
        if (fOverlays)
        {
            OutWarn(ER_swbadnew, "Overlays");
            fOverlays = FALSE;
        }
#endif
    }
    else
    {
        if(fileAlign != DFSAALIGN)
            OutWarn(ER_swbadold,"/ALIGNMENT");
#ifdef  LEGO
        if (fKeepFixups)
            OutWarn(ER_swbadold, "/KEEPFIXUPS");
#endif  /* LEGO */
        if(fPackData)
            OutWarn(ER_swbadold,"/PACKDATA");
#if OVERLAYS
        if(fOldOverlay)
            fDynamic= (FTYPE) FALSE;
        else
            fDynamic = fOverlays;
#endif
    }
#if NOT QCLINK
    // Check if fixup optimizations are possible

    fOptimizeFixups = (FTYPE) ((TargetOs == NE_OS2 || TargetOs == NE_WINDOWS)
#if ILINK
         && !fIncremental
#endif
#if O68K
         && iMacType == MAC_NONE
#endif
                         );
#endif
    pfProcFixup = fNewExe ? FixNew : FixOld;
#ifdef  LEGO
    if (fKeepFixups && fNewExe && (vFlags & NEPROT)
#if     ILINK
        && !fIncremental
#endif
#if     O68K
        && (iMacType == MAC_NONE)
#endif
        )
        pfProcFixup = FixNewKeep;
#endif  /* LEGO */
#endif

    /* Since mpsegraFirst was used for something else, clear it.  */

    FMEMSET(mpsegraFirst,0, gsnMax * sizeof(RATYPE));
}

#if EXE386
/*
 *  ChkSize386 : check 386 program size
 *
 *  Made necessary by the way segment mapping is done to VM.  See
 *  msa386().
 */
LOCAL void NEAR         ChkSize386(void)
{
    register long       *p;             /* Pointer to mpsegcb */
    register long       *pEnd;          /* Pointer to end of mpsegcb */
    register unsigned long cb;          /* Byte count */

    /*
     * Check that total size of segments fits within virtual memory
     * area alloted for segments.  Note that we DO NOT CHECK FOR
     * ARITHMETIC OVERFLOW.  To be strictly correct we should but
     * it will be very rare and the error should be evident elsewhere.
     */
    if (fNewExe)
    {
        p    = &mpsacb[1];
        pEnd = &mpsacb[segLast];
    }
#if ODOS3EXE
    else
    {
        p    = &mpsegcb[1];
        pEnd = &mpsegcb[segLast];
    }
#endif
    for(cb = 0; p <= pEnd; ++p)
        cb += (*p + (PAGLEN - 1)) & ~(PAGLEN - 1);
    /* If size exceeds VM limit, quit with a fatal error. */
    if(cb > (((unsigned long)VPLIB1ST<<LG2PAG)-AREAFSG))
        Fatal(ER_pgmtoobig,(((unsigned long)VPLIB1ST<<LG2PAG)-AREAFSG));
}
#endif

LOCAL void NEAR         InitAfterCmd (void)
{
#if ILINK
    if (fIncremental && fBinary)
    {
        fIncremental = FALSE;
        OutWarn(ER_tinyincr);
    }

    if (fIncremental && !fPackSet)
    {
        packLim = 0;
        fPackSet = (FTYPE) TRUE;
    }
#endif
    fFarCallTransSave = fFarCallTrans;
    InitTabs();                         /* Initialize dynamic tables */
#if QBLIB
    if(fQlib) InitQbLib();              /* Initialize QB-Library items */
#endif
#if CMDMSDOS
    LibEnv();                           /* Process LIB= environment variable */
#endif
    if(fLstFileOpen && cbStack)
        fprintf(bsLst,"Stack Allocation = %u bytes\r\n",
            (cbStack + 1) & ~1);        /* Print stack size */
}



    /****************************************************************
    *                                                               *
    *  main:                                                        *
    *                                                               *
    *  The main function.                                           *
    *                                                               *
    ****************************************************************/

#if NOT WIN_3

void __cdecl main         (argc,argv)
int                     argc;           /* Argument count */
char                    **argv;         /* Argument list */

#else

int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )

#endif
{
#if OVERLAYS OR ODOS3EXE
    APROPNAMEPTR        apropName;      /* Public symbol pointer */
#endif
    SBTYPE              sbRun;          /* Executable file name */


#if NOT WIN_3
#if !defined( _WIN32 ) AND ( WIN_NT AND !defined(DOSX32) OR USE_REAL )
    int                 exceptCode;

    _try
    {
#endif

    /* DLH bsErr can't be statically initialized with the CRT in a DLL */
    bsErr = stderr;

#if CVPACK_MONDO
    /* check for special cvpack only invocation */
    if (argc > 1 && strcmp(argv[1], "/CvpackOnly") == 0)
    {
        /* we're not linking at all -- just invoke the built in cvpack */
        argv[1] = "cvpack";
        argv++;
        argc--;
        exit(cvpack_main(argc, argv));
    }
#endif // CVPACK_MONDO

#if TIMINGS
    ftime(&time_start);
#endif // TIMINGS

#if OSEGEXE
    /* HACK ALERT !!! - special check for undocumented /Z1 option */
    if (argc > 1)
    {
        if ((argv[1][0] == CHSWITCH) &&
            ((argv[1][1] == 'Z') || (argv[1][1] == 'z')))
        {
            BYTE    option[30];

            option[0] = (BYTE) strlen(argv[1]);
            strcpy(&option[1], argv[1]);
            PeelFlags(option);          /* Process /Z1 */
        }
    }
#endif
#else  // WIN_3 TRUE
    ProcessWinArgs( lpCmdLine );
#endif // WIN_3

    InitializeWorld();                  /* Initialize the linker */

#if NOT WIN_3
#if CMDMSDOS
    if (argc <= 1 && !fNoBanner)
#endif
        DisplayBanner();                /* Display signon banner */

    ParseCmdLine(argc,argv);            /* Parse the command line */
    InitAfterCmd();                     /* Initialize post-cmd stuff */
#else // WIN_3 is TRUE
    ParseLinkCmdStr();
    InitAfterCmd();                     /* Initialize post-cmd stuff */
#endif // WIN_3
#if USE_REAL
    if(IsDosxnt() && IsWin31() && !fSwNoUseReal)
        fUseReal = (FTYPE)MakeConvMemPageable();
        if(fUseReal)
            _onexit( (_onexit_t) RealMemExit );
#endif

#if OSEGEXE
#if FDEBUG AND NOT QCLINK AND NOT WIN_3
    if(fDebug) FmtPrint(GetMsg(P_parsedeffile));  // **** PARSE DEFINITIONS FILE ****\r\n
#endif
#if WIN_3
    StatHdrWin(GetMsg(P_lwParseDef));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf, "@I0\r\n");
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
        sprintf(msgBuf, "@I1Microsoft (R) Linker Version 5.40\r\n");
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
        sprintf(msgBuf, "@I2Copyright (C) Microsoft Corp 1992\r\n");
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
        sprintf(msgBuf, "@I3%s\r\n", GetMsg(P_lwParseDef));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif
#if NOT QCLINK
#if NOT EXE386
    if (!fBinary)
#endif
        ParseDeffile();                 /* Parse the definitions file */
#endif
#endif
#if ODOS3EXE
    // If overlays have been specified, but switches /OLDOV /DYN were
    // not present on the command line, set /DYN to ON
    // (dynamic overlays are the default)

    if(fOverlays && !fOldOverlay && !fDynamic)
    {
         fDynamic = TRUE;
         fFarCallTrans = (FTYPE) TRUE;
         fPackSet = (FTYPE) TRUE;
         packLim = LXIVK - 36;         /* Default limit is 64K - 36 */
         ovlThunkMax = 256;
    }
#endif
    fFarCallTransSave = fFarCallTrans;
    if(fDynamic && fExePack)
    {
        fExePack = FALSE;
        OutWarn(ER_dynexep);
    }

#if WIN_3
    StatHdrWin(GetMsg(P_lwPassOne));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwPassOne));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif


#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_passone)); // **** PASS ONE ****\r\n
#endif
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
    snkey = 0;                          /* Initialize for pass 1 */
    modkey = 0;                         /* Initialize for pass 1 */
    ObjDebTotal = 1;
    ifhLast = FHNIL;                    /* No files looked at yet */
#if NEWIO
    /* Allocate a file stream for bsInput with a dummy file handle */
    bsInput = fdopen(0,RDBIN);
#endif /*NEWIO*/
#if OSMSDOS
    setvbuf(bsInput,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
    rprop1stOpenFile = rprop1stFile;    /* Remember first open file */
    r1stFile = rprop1stFile;            /* which is also first input file */
    vfPass1 = (FTYPE) TRUE;             /* Now pass 1 */
    DrivePass(ProcP1);                  /* Make pass 1 */
#if OVERLAYS

    // If overlays, make $$OVLINIT or $$MOVEINIT an undefined symbol

    if (fOverlays)
    {
        if (!fOldOverlay)
        {
            if (PropSymLookup("\012$$MOVEINIT",ATTRPNM,FALSE) == PROPNIL)
                PropSymLookup("\012$$MOVEINIT", ATTRUND, TRUE);
        }
        else
        {
            if (PropSymLookup("\011$$OVLINIT",ATTRPNM,FALSE) == PROPNIL)
                PropSymLookup("\011$$OVLINIT", ATTRUND, TRUE);
        }
    }
#endif
#if WIN_3
        StatHdrWin(GetMsg(P_lwLibraryS));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwLibraryS));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_libsearch));
#endif
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
#if OEXE
    if (fSegOrder)
        SetDosseg();
#endif
    LibrarySearch();                    /* Search libraries */
    vfPass1 = FALSE;                    /* No longer pass 1 */
#if LNKPROF
    if(fP1stop) { FlsStdio(); exit(0); }
#endif
    InterPass();                        /* Do various between-pass tasks */
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
#if WIN_3
        StatHdrWin(GetMsg(P_lwAssign));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwAssign));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_assignadd));   /* **** ASSIGN ADDRESSES ****\r\n*/
#endif
    AllocComDat();
    AssignAddresses();                  /* Assign addresses to segments */
#if SYMDEB
    if (fSymdeb)
        DoComdatDebugging();
#endif
    if (fFullMap)
        UpdateComdatContrib(
#if ILINK
                                FALSE,
#endif
                                TRUE);
#if EXE386
    InitVmBase();                       /* Set VM object areas base addresses */
    FillInImportTable();
#endif
    if(fLstFileOpen)                    /* If list file open */
    {
#if WIN_3
    StatHdrWin(GetMsg(P_lwMapfile));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwMapfile));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif


#if FDEBUG
        if(fDebug) FmtPrint(GetMsg(P_printmap));/*  **** PRINT MAP ****\r\n */
#endif
        PrintMap();                     /* Print load map */
#if QBLIB
        if(fQlib) PrintQbStart();
#endif
    }
#if OSEGEXE AND NOT QCLINK
    if (fNewExe
#if NOT EXE386 AND ILINK
                && !fQCIncremental
#endif
       )
        InitEntTab();                   /* Initialize the Entry Table */
#endif
#if EXE386
    if(f386) ChkSize386();              /* Check program size for 386 */
#endif
#if OSEGEXE AND NOT QCLINK
    if (fNewExe
#if NOT EXE386 AND ILINK
                && !fQCIncremental
#endif
       )
        InitFP();                       /* Initialize floating-point items */
#endif
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
    snkey = 0;                          /* Initialize for pass 2 */
    modkey = 0;                         /* Initialize for pass 2 */
    ifhLast = FHNIL;                    /* No files examined on pass 2 yet */

#if WIN_3
    StatHdrWin(GetMsg(P_lwPassTwo));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwPassTwo));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_passtwo)); /* **** PASS TWO ****\r\n*/
#endif
    DrivePass(ProcP2);                  /* Make pass 2 */
#if OSEGEXE
    if (vpropAppLoader != PROPNIL)
    {
        APROPUNDEFPTR   apropUndef;

        apropUndef = (APROPUNDEFPTR) FetchSym(vpropAppLoader, TRUE);
        fUndefinedExterns = fUndefinedExterns || (FTYPE) (apropUndef->au_attr == ATTRUND);
        apropUndef->u.au_rFil = AddVmProp(apropUndef->u.au_rFil, rprop1stFile);
    }
#endif
#if ODOS3EXE
    if (fDOSExtended)
    {
        apropName = (APROPNAMEPTR ) PropSymLookup("\017__DOSEXT16_MODE", ATTRPNM, FALSE);
                                        // Look up public symbol
        if (apropName != PROPNIL)
        {
            if (dosExtMode != 0)
                MoveToVm(sizeof(WORD), (BYTE *) &dosExtMode, mpgsnseg[apropName->an_gsn], apropName->an_ra);
                                        // Store value
        }
    }
#endif
#if OVERLAYS
    if (fOverlays)
    {
        // If there are overlays check if we have an overlay manager

        apropName = (APROPNAMEPTR ) PropSymLookup(fDynamic ? "\012$$MOVEINIT" :
                                                             "\011$$OVLINIT",
                                                             ATTRPNM, FALSE);

        if (apropName != PROPNIL)
        {                               // If starting point defined
            raStart  = apropName->an_ra;// Get offset of entry point
            segStart = mpgsnseg[apropName->an_gsn];
                                        // Get base number of entry point
        }
        else
            OutError(ER_ovlmnger);
    }
#endif
    if(fUndefinedExterns)               /* If we have unresolved references */
    {
        if(fLstFileOpen && bsLst != stdout)
        {                               /* If we have a list file */
            NEWLINE(bsLst);
#if CMDXENIX
            fprintf(bsLst,"%s: ",lnknam);
                                        /* Linker name */
#endif
        }
#if QCLINK
        if (!fZ1)
#endif
            NEWLINE(stderr);
        EnSyms(PrintAnUndef,ATTRUND);   /* Print undefined symbols */
        if(fLstFileOpen && bsLst != stdout)
            NEWLINE(bsLst);
#if QCLINK
        if (!fZ1)
#endif
            NEWLINE(stderr);
    }
#if ILINK
    if (fIncremental)
    {
        OutputIlk();                    /* Output .ilk / .sym files */
    }
#endif /*ILINK*/

#if FDEBUG
    if(fDebug)
    {
      if( !fDelexe || fDelexe && cErrors==0 )
      {
        FmtPrint(GetMsg(P_writing1)); /* **** WRITING  */
        if (fNewExe)
        {
            if (TargetOs == NE_OS2)
                FmtPrint("OS/2");
            else if (TargetOs == NE_WINDOWS)
                FmtPrint("WINDOWS");
        }
        else
        {
            FmtPrint("DOS");
#if OVERLAYS
            if (fOverlays)
                FmtPrint(GetMsg(P_writing2));  /*  - overlaid*/
#endif
        }
        FmtPrint(GetMsg(P_writing3)); /*  EXECUTABLE ****\r\n*/
#if OVERLAYS
        if (fOverlays && fDynamic)
            FmtPrint(GetMsg(P_overlaycalls), ovlThunkMax, ovlThunkMac);/***** NUMBER OF INTEROVERLAY CALLS: requested %d; generated %d ****\r\n*/
#endif
        PrintStats();
#if PROFSYM
        ProfSym();              /* Profile symbol table */
#endif
      }
      else  // some errors occured
      {
        FmtPrint(GetMsg(P_noexe));
      }


    }
#endif /* FDEBUG */


  if( !fDelexe || fDelexe && cErrors==0 )
  {
#if WIN_3
    StatHdrWin(GetMsg(P_lwExecutable));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwExecutable));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if OSMSDOS
    if (chRunFile >= 'a' && chRunFile <= 'z')
        chRunFile += (BYTE) ('A' - 'a');
                                        /* Make drive letter upper case */
    if(fPauseRun && FCHGDSK(chRunFile - 'A'))
    {
        if(fLstFileOpen && chListFile == (BYTE) (chRunFile - 'A'))
        {                               /* If map on EXE drive */
            fclose(bsLst);              /* Close the list file */
            fLstFileOpen = FALSE;       /* Set flag accordingly */
        }
        (*pfPrompt)(NULL,P_genexe,(int) NULL,P_ChangeDiskette,chRunFile);
    }
    else
        fPauseRun = FALSE;
#endif
    if(fLstFileOpen && bsLst != stdout)
    {
        fclose(bsLst);
        fLstFileOpen = FALSE;
    }
    fclose(bsInput);                    /* Close input file */

#if NOT EXE386
    if (fExePack && fNewExe && (TargetOs == NE_WINDOWS))
    {
        OutWarn(ER_exepack);
        fExePack = FALSE;
    }
#endif

    OutRunFile(sbRun);                  /* Output executable file */
    CleanUp();                          /* Mop up after itself */
#ifdef PENTER_PROFILE
        saveEntries();
#endif
#if OWNSTDIO
    FlsStdio();
#endif
#if TIMINGS
    if (fShowTiming)    // check if we started the timer...
    {
        char buf[80];
        int hundr;
        time_t td;

        ftime(&time_end);
        td = time_end.time - time_start.time;
        hundr = (time_end.millitm - time_start.millitm)/10;

        td = td*100 + hundr;
        sprintf(buf, "Linker phase: %d.%02ds\r\n", td/100, td%100);
        _write(fileno(stdout), buf, strlen(buf));
        time_start = time_end;
    }
#endif // TIMINGS
#if NOT WIN_3
#ifndef CVPACK_MONDO
    SpawnOther(sbRun, argv[0]);
#else
    if (fSymdeb && fCVpack && !cErrors && !fUndefinedExterns)
    {
        char drive[_MAX_DRIVE];
        char dir[_MAX_DIR];
        char fname[_MAX_FNAME];

        int argcT = 0;
        char *argvT[5];

        argvT[argcT++] = "cvpack";

        argvT[argcT++] = "/nologo";

        if (fMPC)
            argvT[argcT++] = "/pcode";

        sbRun[sbRun[0]+1] = '\0';       // NUL terminate

        // If /TINY is active, we are building a .COM file,
        // and the cv info is in a .DBG file

        if (fBinary)
        {
            _splitpath(sbRun+1, drive, dir, fname, NULL);
            _makepath(sbRun+1, drive, dir, fname, ".DBG");
        }

        argvT[argcT++] = sbRun+1;
        argvT[argcT] = NULL;

        fflush(stderr);
        fflush(stdout);

        _setmode(1,_O_TEXT);
        _setmode(2,_O_TEXT);
#if FAR_SEG_TABLES
        FreeSymTab();
#if NOT WIN_NT AND NOT DOSX32
        _fheapmin();
#endif
#endif


        cvpack_main(argcT, argvT);
    }
    else if (fMPC)
        SpawnOther(sbRun, argv[0]);     // we'll be running MPC
#endif
#if TIMINGS
    if (fShowTiming)    // check if we started the timer...
    {
        char buf[80];
        int hundr;
        time_t td;

        ftime(&time_end);
        td = time_end.time - time_start.time;
        hundr = (time_end.millitm - time_start.millitm)/10;

        td = td*100 + hundr;
        sprintf(buf, "Cvpack phase: %d.%02ds\r\n", td/100, td%100);
        _write(fileno(stdout), buf, strlen(buf));
        time_start = time_end;
    }
#endif // TIMINGS
#endif
  }
    fflush(stdout);
    fflush(stderr);
#if USE_REAL
    RealMemExit();
#endif
    EXIT((cErrors || fUndefinedExterns)? 2: 0);
#if !defined( _WIN32 ) AND ( WIN_NT AND !defined(DOSX32) OR USE_REAL )
    }

    _except (1)
    {
#if USE_REAL
        RealMemExit();
#endif
        exceptCode = _exception_code();

        if (exceptCode == EXCEPTION_ACCESS_VIOLATION)
        {
            fprintf(stdout, "\r\nLINK : fatal error L5000 : internal failure - access violation ");
            fflush(stdout);
        }
        else if (exceptCode == EXCEPTION_DATATYPE_MISALIGNMENT)
        {
            fprintf(stdout, "\r\nLINK : fatal error L5001 : internal failure - datatype misalignment ");
            fflush(stdout);
        }
        else

            CtrlC();
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newutl.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWUTL.C                            *
    *                                                               *
    *  Linker utilities.                                            *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <newdeb.h>      /* CodeView support */
#include                <extern.h>      /* External declarations */
#include                <nmsg.h>        /* Near message strings */
#include                <string.h>
#include                <stdarg.h>
#if EXE386
#include                <exe386.h>
#endif
#if NEWIO
#include                <errno.h>       /* System error codes */
#endif
#if USE_REAL
#if NOT defined( _WIN32 )
#define i386
#include                <windows.h>
#endif
// The memory sizes are in paragraphs.
#define TOTAL_CONV_MEM   (0xFFFF)
#define CONV_MEM_FOR_TNT (0x800)        // 32K of memory
#define MIN_CONV_MEM (0x1900)   // 100 K of memory

typedef unsigned short selector_t ; //Define type to hold selectors 

static selector_t  convMemSelector  ; // Selector to conv memory.
static short noOfParagraphs      ; // size of the available blocks in paragraphs
static int      realModeMemPageable ; // = FALSE        
#endif

#if WIN_NT OR DOSX32
unsigned char   FCHGDSK(int drive)
{
    return(FALSE);
}
#endif
#define DISPLAY_ON FALSE
#if DISPLAY_ON
extern int TurnDisplayOn;
#endif
APROPCOMDATPTR          comdatPrev=NULL;     /* Pointer to symbol table entry */
int                     fSameComdat=FALSE;   /* Set if LINSYM to the same COMDAT */

/********************************************************************
*                       INPUT ROUTINES                              *
********************************************************************/


/*** GetLineOff - read part of LINNUM record
*
* Purpose:
*   This function reads line/offset pair from LINNUM record. It is here
*   because we want to keep all the I/O functions near and the LINNUM
*   processing is performed in NEWDEB.C which resides in another segment.
*
* Input:
*   - pLine - pointer to line number
*   - pRa   - pointer to offset
*
* Output:
*   Returns line/offset pair from OMF record.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    GetLineOff(WORD *pLine, RATYPE *pRa)
{
    *pLine = WGets() + QCLinNumDelta;   // Get line number

    // Get code segment offset

#if OMF386
    if (rect & 1)
        *pRa = LGets();
    else
#endif
        *pRa = (RATYPE) WGets();
}

/*** GetGsnInfo - read the segment index of the LINNUM
*
* Purpose:
*   This function reads the segemnt index from LINNUM record. It is here
*   because we want to keep all the I/O functions near and the LINNUM
*   processing is performed in NEWDEB.C which resides in another segment.
*
* Input:
*   - pRa  - pointer to offset correction for COMDATs
*
* Output:
*   Returns global segment index and for lines in COMDAT record
*   offset correction.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

WORD                    GetGsnInfo(GSNINFO *pInfo)
{
    WORD                fSuccess;       // TRUE if everything is OK
    WORD                attr;           // COMDAT flags
    WORD                comdatIdx;      // COMDAT symbol index
    APROPCOMDATPTR      comdat;         // Pointer to symbol table entry


    fSuccess = TRUE;
    if (TYPEOF(rect) == LINNUM)
    {
        // Read regular LINNUM record

        GetIndex((WORD)0,(WORD)(grMac - 1));            // Skip group index
        pInfo->gsn = mpsngsn[GetIndex((WORD)1,(WORD)(snMac - 1))];
                                        // Get global SEGDEF number
        pInfo->comdatRa = 0L;
        pInfo->comdatSize = 0L;
        pInfo->fComdat = FALSE;
    }
    else
    {
        // Read LINSYM record - line numbers for COMDAT

        attr = (WORD) Gets();
        comdatIdx = GetIndex(1, (WORD)(lnameMac - 1));
        comdat = (APROPCOMDATPTR ) PropRhteLookup(mplnamerhte[comdatIdx], ATTRCOMDAT, FALSE);
        fSameComdat = FALSE;
        if (comdat != NULL)
        {
            if(comdat == comdatPrev)
                fSameComdat = 1;
            else
                comdatPrev = comdat;

            if ((fPackFunctions && !(comdat->ac_flags & REFERENCED_BIT)) ||
                !(comdat->ac_flags & SELECTED_BIT) ||
                comdat->ac_obj != vrpropFile)
            {
                SkipBytes((WORD)(cbRec - 1));
                fSuccess = FALSE;
            }
            else
            {
                pInfo->gsn        = comdat->ac_gsn;
                pInfo->comdatRa   = comdat->ac_ra;
                pInfo->comdatSize = comdat->ac_size;
                pInfo->comdatAlign= comdat->ac_align;
                pInfo->fComdat    = TRUE;
            }
        }
        else
        {
            SkipBytes((WORD)(cbRec - 1));
            fSuccess = FALSE;
        }
    }
    return(fSuccess);
}

    /****************************************************************
    *                                                               *
    *  Gets:                                                        *
    *                                                               *
    *  Read a byte of input and return it.                          *
    *                                                               *
    ****************************************************************/
#if NOASM
#if !defined( M_I386 ) && !defined( _WIN32 )
WORD NEAR               Gets(void)
{
    REGISTER WORD       b;

    if((b = getc(bsInput)) == EOF) InvalidObject();
    /* After reading the byte, decrement the OMF record counter.  */
    --cbRec;
    return(b);
}
#endif
#endif


#if ALIGN_REC
#else
    /****************************************************************
    *                                                               *
    *  WGetsHard:                                                   *
    *                                                               *
    *  Read a word of input and return it.                          *
    *                                                               *
    ****************************************************************/

WORD NEAR               WGetsHard()
{
    REGISTER WORD       w;

    // handle hard case... easy case already tested in WGets

    w = Gets();                         /* Get low-order byte */
    return(w | (Gets() << BYTELN));     /* Return word */
}

#if OMF386
    /****************************************************************
    *                                                               *
    *  LGets:                                                       *
    *                                                               *
    *  Read a long word of input and return it.                     *
    *                                                               *
    ****************************************************************/

DWORD NEAR              LGets()
{
    DWORD               lw;
    FILE *              f = bsInput;

    // NOTE: this code will only work on a BigEndian machine
    if (f->_cnt >= sizeof(DWORD))
        {
        lw = *(DWORD *)(f->_ptr);
        f->_ptr += sizeof(DWORD);
        f->_cnt -= sizeof(DWORD);
        cbRec   -= sizeof(DWORD);
        return lw;
        }

    lw = WGets();                       /* Get low-order word */
    return(lw | ((DWORD) WGets() << 16));/* Return long word */
}
#endif
#endif

#if 0
    /****************************************************************
    *                                                               *
    *  GetBytes:                                                    *
    *                                                               *
    *  Read n bytes from input.                                     *
    *  If n is greater than SBLEN - 1, issue a fatal error.         *
    *                                                               *
    ****************************************************************/

void NEAR               GetBytes(pb,n)
BYTE                    *pb;            /* Pointer to buffer */
WORD                    n;              /* Number of bytes to read in */
{
    FILE *f = bsInput;

    if(n >= SBLEN)
        InvalidObject();

    if (n <= f->_cnt)
        {
        memcpy(pb,f->_ptr, n);
        f->_cnt -= n;
        f->_ptr += n;
        }
    else
        fread(pb,1,n,f);                /* Ask for n bytes */

    cbRec -= n;                         /* Update byte count */
}
#endif

#if 0
    /****************************************************************
    *                                                               *
    *  SkipBytes:                                                   *
    *                                                               *
    *  Skip n bytes of input.                                       *
    *                                                               *
    ****************************************************************/

void NEAR              SkipBytes(n)
REGISTER WORD          n;               /* Number of bytes to skip */
{
#if WIN_NT
    WORD               cbRead;
    SBTYPE             skipBuf;

    cbRec -= n;                         // Update byte count
    while (n)                           // While there are bytes to skip
    {
        cbRead = n < sizeof(SBTYPE) ? n : sizeof(SBTYPE);
        if (fread(skipBuf, 1, cbRead, bsInput) != cbRead)
            InvalidObject();
        n -= cbRead;
    }
#else
    FILE *f = bsInput;

    if (f->_cnt >= n)
        {
        f->_cnt -= n;
        f->_ptr += n;
        }
    else if(fseek(f,(long) n,1))
        InvalidObject();
    cbRec -= n;                         /* Update byte count */
#endif
}
#endif

    /****************************************************************
    *                                                               *
    *  GetIndexHard:    (GetIndex -- hard case)                     *
    *                                                               *
    *  This function  reads in  a variable-length index field from  *
    *  the input file.  It takes as its  arguments two word values  *
    *  which  represent  the minimum and maximum  allowable values  *
    *  the index.  The function returns the value of the index.     *
    *  See p. 12 in "8086 Object Module Formats EPS."               *
    *                                                               *
    ****************************************************************/

WORD NEAR               GetIndexHard(imin,imax)
WORD                    imin;           /* Minimum permissible value */
WORD                    imax;           /* Maximum permissible value */
{
    REGISTER WORD       index;

    FILE *f = bsInput;

    if (f->_cnt >= sizeof(WORD))
    {
        index = *(BYTE *)(f->_ptr);
        if (index & 0x80)
        {
            index  <<= BYTELN;
            index   |= *(BYTE *)(f->_ptr+1);
            index   &= 0x7fff;
            f->_cnt -= sizeof(WORD);
            f->_ptr += sizeof(WORD);
            cbRec   -= sizeof(WORD);
        }
        else
        {
            f->_cnt--;
            f->_ptr++;
            cbRec--;
        }
    }
    else
    {
        if((index = Gets()) & 0x80)
            index = ((index & 0x7f) << BYTELN) | Gets();
    }

    if(index < imin || index > imax) InvalidObject();
    return(index);                      /* Return a good value */
}

/********************************************************************
*                       STRING ROUTINES                             *
********************************************************************/

#if OSEGEXE
#if NOASM
    /****************************************************************
    *                                                               *
    *  zcheck:                                                      *
    *                                                               *
    *  Determine length of initial nonzero stream in a buffer, and  *
    *  return the length.                                           *
    *                                                               *
    ****************************************************************/

#if defined(M_I386)
#pragma auto_inline(off)
#endif

WORD                zcheck(BYTE *pb, WORD cb)
{
    // Loop down from end until a nonzero byte found.
    // Return length of remainder of buffer.

#if defined(M_I386)

    _asm
    {
        push    edi             ; Save edi
        movzx   ecx, cb         ; Number of bytes to check
        push    ds              ; Copy ds into es
        pop     es
        xor     eax, eax        ; Looking for zeros
        mov     edi, pb         ; Start of buffer
        add     edi, ecx        ; Just past the end of buffer
        dec     edi             ; Last byte in the buffer
        std                     ; Decrement pointer
        repz    scasb           ; Scan until non-zero byte found
        jz      AllZeros        ; Buffer truly empty
        inc     ecx             ; Fix count

AllZeros:
        cld                     ; Clear flag just to be safe
        pop     edi             ; Restore edi
        mov     eax, ecx        ; Return count in eax
    }
#endif

    for(pb = &pb[cb]; cb != 0; --cb)
        if(*--pb != '\0') break;
    return(cb);
}
#endif
#endif /* OSEGEXE */

#if defined(M_I386)
#pragma auto_inline(on)
#endif

/*** CheckSegmentsMemory - check is all segments have allocated memory
*
* Purpose:
*   Check for not initialized segments.  If the segment have a non-zero
*   size but no initialized data, then we have to allocate for it a
*   zero filled memory buffer. Normally 'MoveToVm' allocates memory
*   buffer for segments, but in this case there was no 'moves to VM'.
*
* Input:
*   No explicit value is passed.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    CheckSegmentsMemory(void)
{
    SEGTYPE             seg;
    SATYPE              sa;

    if (fNewExe)
    {
        for (sa = 1; sa < saMac; sa++)
            if (mpsaMem[sa] == NULL && mpsacb[sa] > 0)
                mpsaMem[sa] = (BYTE FAR *) GetMem(mpsacb[sa]);
    }
    else
    {
        for (seg = 1; seg <= segLast; seg++)
            if (mpsegMem[seg] == NULL && mpsegcb[seg] > 0)
                mpsegMem[seg] = (BYTE FAR *) GetMem(mpsegcb[seg] + mpsegraFirst[seg]);
    }
}

/*** WriteExe - write bytes to the executable file
*
* Purpose:
*   Write to the executable file and check for errors.
*
* Input:
*   pb - byte buffer to write
*   cb - buffer size in bytes
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O problems - fatal error and abort
*
* Notes:
*   None.
*
*************************************************************************/

#if !defined( M_I386 ) && !defined( _WIN32 )

#pragma check_stack(on)

void                    WriteExe(void FAR *pb, unsigned cb)
{
    BYTE                localBuf[1024];
    WORD                count;

    while (cb > 0)
    {
        count = (WORD) (cb <= sizeof(localBuf) ? cb : sizeof(localBuf));
        FMEMCPY((BYTE FAR *) localBuf, pb, count);
        if (fwrite((char *) localBuf, sizeof(BYTE), count, bsRunfile) != count)
        {
            ExitCode = 4;
            Fatal(ER_spcrun, strerror(errno));
        }
        cb -= count;
        ((BYTE FAR *) pb) += count;
    }
}

#pragma check_stack(off)

#else

/*** NoRoomForExe - the exe didn't fit
*
* Purpose:
*   emit error message
*   give fatal error and abort
*
* Input:
*   errno must be set
*
* Output:
*   No explicit value is returned.
*
* Notes:
*   None.
*
*************************************************************************/

void                    NoRoomForExe()
{
    ExitCode = 4;
    Fatal(ER_spcrun, strerror(errno));
}

#endif

/*** WriteZeros - write zero bytes to the executable file
*
* Purpose:
*   Pad executable file with zero bytes.
*
* Input:
*   cb - number of bytes to write
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O problems - fatal error and abort
*
* Notes:
*   None.
*
*************************************************************************/

void                    WriteZeros(unsigned cb)
{
    BYTE                buf[512];
    unsigned            count;

    memset(buf, 0, sizeof(buf));
    while (cb > 0)
    {
        count = cb <= sizeof(buf) ? cb : sizeof(buf);
        WriteExe(buf, count);
        cb -= count;
    }
}

    /****************************************************************
    *                                                               *
    *  MoveToVm:                                                    *
    *                                                               *
    *  Move a piece of data into a virtual memory area/va.          *
    *                                                               *
    *  Input:   cb      Count of bytes to be moved.                 *
    *           obData  Address of data to be moved.                *
    *           seg     Logical segment to which data belongs.      *
    *           ra      Offset at which data belongs.               *
    *                                                               *
    ****************************************************************/

#pragma intrinsic(memcpy)

#if EXE386
void                    MoveToVm(WORD cb, BYTE *obData, SEGTYPE seg, RATYPE ra)
#else
void NEAR               MoveToVm(WORD cb, BYTE *obData, SEGTYPE seg, RATYPE ra)
#endif
{
    long                cbtot;          /* Count of bytes total */
    long                cbSeg;          /* Segment size */
    WORD                fError;
    BYTE FAR            *pMemImage;
    CVINFO FAR          *pCVInfo;
    SATYPE              sa;


    cbtot = (long) cb + ra;

    if (fDebSeg)
    {
        pCVInfo = ((APROPFILEPTR ) FetchSym(vrpropFile, FALSE))->af_cvInfo;
        if (pCVInfo)
        {
            if (seg < (SEGTYPE) (segDebFirst + ObjDebTotal))
            {
                cbSeg     = pCVInfo->cv_cbTyp;
                pMemImage = pCVInfo->cv_typ;
            }
            else
            {
                cbSeg     = pCVInfo->cv_cbSym;
                pMemImage = pCVInfo->cv_sym;
            }

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
        else
        {
            OutError(ER_badcvseg);
            return;
        }
    }
    else
    {
        if (fNewExe)
        {
            cbSeg = ((APROPSNPTR) FetchSym(mpgsnrprop[vgsnCur],FALSE))->as_cbMx;
            sa = mpsegsa[seg];
            if (mpsaMem[sa] == NULL)
                mpsaMem[sa] = (BYTE FAR *) GetMem(mpsacb[sa]);
            pMemImage = mpsaMem[sa];

            // Check against segment bounds

            fError = (long) ((ra - mpgsndra[vgsnCur]) + cb) > cbSeg;

            // If data is going up to or past current end of initialized data,
            // omit any trailing null bytes and reset mpsacbinit.  Mpsacbinit
            // will usually go up but may go down if a common segment over-
            // writes previous end data with nulls.

            if ((DWORD) cbtot >= mpsacbinit[sa])
            {
                if ((DWORD) ra < mpsacbinit[sa] ||
                    (cb = zcheck(obData,cb)) != 0)
                    mpsacbinit[sa] = (long) ra + cb;
            }
        }
        else
        {
            cbSeg = mpsegcb[seg] + mpsegraFirst[seg];
            if (mpsegMem[seg] == NULL)
                mpsegMem[seg] = (BYTE FAR *) GetMem(cbSeg);
            pMemImage = mpsegMem[seg];

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
    }

    if (fError)
    {
        if (!fDebSeg)
            OutError(ER_segbnd, 1 + GetFarSb(GetHte(mpgsnrprop[vgsnCur])->cch));
        else
            OutError(ER_badcvseg);
    }
    else
        FMEMCPY(&pMemImage[ra], obData, cb);
}

#pragma function(memcpy)

#if (OSEGEXE AND ODOS3EXE) OR EXE386
/*
 *  Map segment index to memory image address for new-format exes.
 */
BYTE FAR * NEAR     msaNew (SEGTYPE seg)
{
    return(mpsaMem[mpsegsa[seg]]);
}
#endif

#if (OSEGEXE AND ODOS3EXE) OR EXE386
/*
 *  Map segment index to memory image address for DOS3 or 286Xenix exes.
 */
BYTE FAR * NEAR     msaOld (SEGTYPE seg)
{
    return(mpsegMem[seg]);
}
#endif

#if EXE386
/*
 *  Map segment index to VM area address for 386 exes.
 */
long NEAR               msa386 (seg)
SEGTYPE                 seg;
{
    register long       *p;             /* Pointer to mpsegcb */
    register long       *pEnd;          /* Pointer to end of mpsegcb */
    register long       va = AREAFSG;   /* Current VM address */

    /*
     * Segment number-to-VM area mapping is different for 386 segments
     * because their size limit is so big that allocating a fixed amount
     * for each segment is impractical, especially when sdb support is
     * enabled.  So segments are allocated contiguously.  Each segment
     * is padded to a VM page boundary for efficiency.
     *
     * Implementation:  the fastest way would be to allocate a segment
     * based table of virtual addresses, but this would take more code
     * and memory.  Counting segment sizes is slower but this is not
     * time-critical routine, and in most cases there will be very few
     * segments.
     */
    if (fNewExe)
    {
        p    = &mpsacb[1];
        pEnd = &mpsacb[seg];
    }
#if ODOS3EXE
    else
    {
        p    = &mpsegcb[1];
        pEnd = &mpsegcb[seg];
    }
#endif
    for( ; p < pEnd; ++p)
        va += (*p + (PAGLEN - 1)) & ~(PAGLEN - 1);
    return(va);
}
#endif /* EXE386 */



/********************************************************************
*                       (ERROR) MESSAGE ROUTINES                    *
********************************************************************/
#pragma auto_inline(off)
 /*
 *  SysFatal : system-level error
 *
 *  Issue error message and exit with return code 4.
 */
void cdecl               SysFatal (MSGTYPE msg)
{
    ExitCode = 4;
    Fatal(msg);
}



void NEAR                InvalidObject(void)
{
    Fatal((MSGTYPE)(fDrivePass ? ER_badobj: ER_eofobj));
}

#pragma auto_inline(on)
/********************************************************************
*                       MISCELLANEOUS ROUTINES                      *
********************************************************************/

/*
 * Output a word integer.
 */
void                    OutWord(x)
WORD                    x;      /* A word integer */
{
    WriteExe(&x, CBWORD);
}


/*
 *  GetLocName : read in a symbol name for L*DEF
 *
 *      Transform the name by prefixing a space followed by the
 *      module number.  Update the length byte.
 *
 *      Parameters:     pointer to a string buffer, 1st byte already
 *              contains length
 *      Returns:  nothing
 */
void NEAR               GetLocName (psb)
BYTE                    *psb;           /* Name buffer */
{
    WORD                n;
    BYTE                *p;

    p = &psb[1];                        /* Start after length byte */
    *p++ = 0x20;                        /* Prefix begins with space char */
    GetBytes(p,B2W(psb[0]));            /* Read in text of symbol */
    p += B2W(psb[0]);                   /* Go to end of string */
    *p++ = 0x20;
    n = modkey;                         /* Initialize */
    /* Convert the module key to ASCII and store backwards */
    do
    {
        *p++ = (BYTE) ((n % 10) + '0');
        n /= 10;
    } while(n);
    psb[0] = (BYTE) ((p - (psb + 1)));  /* Update length byte */
}



PROPTYPE                EnterName(psym,attr,fCreate)
BYTE                    *psym;          /* Pointer to length-prefixed string */
ATTRTYPE                attr;           /* Attribute to look up */
WORD                    fCreate;        /* Create prop cell if not found */
{
    return(PropSymLookup(psym, attr, fCreate));
                                        /* Hide call to near function */
}

#if CMDMSDOS

#pragma check_stack(on)

/*** ValidateRunFileName - Check if output file has proper extension
*
* Purpose:
*           Check user-specified output file name for valid extension.
*           Issue warning if extension is invalid and create new file
*           name with proper extension.
*
* Input:
*           ValidExtension - pointer to length prefixed ascii string
*                            representing valid exetension for output
*                            file name.
*           ForceExtension - TRUE if output file must have new extension,
*                            otherwise user responce takes precedence.
*           WarnUser       - If TRUE than display L4045 if file name changed.
*
* Output:
*           rhteRunfile    - global virtual pointer to output file
*                            name, changed only if new output name
*                            is created because of invalid original
*                            extension.
*           warning L4045  - if output file name have to be changed.
*
*************************************************************************/


void NEAR               ValidateRunFileName(BYTE *ValidExtension,
                                            WORD ForceExtension,
                                            WORD WarnUser)
{
    SBTYPE              sb;             /* String buffer */
    BYTE                *psbRunfile;    /* Name of runfile */
    char                oldDrive[_MAX_DRIVE];
    char                oldDir[_MAX_DIR];
    char                oldName[_MAX_FNAME];
    char                oldExt[_MAX_EXT];


    /* Get the name of the runfile and check if it has user supplied extension */

    psbRunfile = GetFarSb(((AHTEPTR) FetchSym(rhteRunfile,FALSE))->cch);
    _splitpath(psbRunfile, oldDrive, oldDir, oldName, oldExt);

    /* Force extension only when no user defined extension */

    if (ForceExtension && oldExt[0] == NULL)
    {
        memcpy(sb, ValidExtension, strlen(ValidExtension));
        memcpy(bufg, psbRunfile, 1 + B2W(*psbRunfile));
    }
    else
    {
        memcpy(bufg, ValidExtension, strlen(ValidExtension));
        memcpy(sb, psbRunfile, 1 + B2W(*psbRunfile));
    }
    UpdateFileParts(bufg, sb);

    /* If the name has changed, issue a warning and update rhteRunfile. */

    if (!SbCompare(bufg, psbRunfile, (FTYPE) TRUE))
    {
        if (WarnUser && !SbCompare(ValidExtension, sbDotExe, (FTYPE) TRUE))
            OutWarn(ER_outputname,bufg + 1);
        PropSymLookup(bufg, ATTRNIL, TRUE);
        rhteRunfile = vrhte;
    }
}

#pragma check_stack(off)

#endif



/********************************************************************
*                       PORTABILITY ROUTINES                        *
********************************************************************/

#if M_BYTESWAP
WORD                getword(cp) /* Get a word given a pointer */
REGISTER char       *cp;        /* Pointer */
{
    return(B2W(cp[0]) + (B2W(cp[1]) << BYTELN));
                                /* Return 8086-style word */
}

DWORD               getdword(cp)/* Get a double word given a pointer */
REGISTER char       *cp;        /* Pointer */
{
    return(getword(cp) + (getword(cp+2) << WORDLN));
                                /* Return 8086-style double word */
}
#endif

#if NOT M_WORDSWAP OR M_BYTESWAP
/*
 * Portable structure I/O routines
 */
#define cget(f)     fgetc(f)

static int      bswap;      /* Byte-swapped mode (1 on; 0 off) */
static int      wswap;      /* Word-swapped mode (1 on; 0 off) */

static          cput(c,f)
char            c;
FILE            *f;
{
#if FALSE AND OEXE
    CheckSum(1, &c);
#endif
    fputc(c, f);
}

static          pshort(s,f)
REGISTER short      s;
REGISTER FILE       *f;
{
    cput(s & 0xFF,f);           /* Low byte */
    cput(s >> 8,f);         /* High byte */
}

static unsigned short   gshort(f)
REGISTER FILE       *f;
{
    REGISTER short  s;

    s = cget(f);            /* Get low byte */
    return(s + (cget(f) << 8));     /* Get high byte */
}

static          pbshort(s,f)
REGISTER short      s;
REGISTER FILE       *f;
{
    cput(s >> 8,f);         /* High byte */
    cput(s & 0xFF,f);           /* Low byte */
}

static unsigned short   gbshort(f)
REGISTER FILE       *f;
{
    REGISTER short  s;

    s = cget(f) << 8;           /* Get high byte */
    return(s + cget(f));        /* Get low byte */
}

static int      (*fpstab[2])() =
            {
                pshort,
                pbshort
            };
static unsigned short   (*fgstab[2])() =
            {
                gshort,
                gbshort
            };

static          plong(l,f)
long            l;
REGISTER FILE       *f;
{
    (*fpstab[bswap])((short)(l >> 16),f);
                    /* High word */
    (*fpstab[bswap])((short) l,f);  /* Low word */
}

static long     glong(f)
REGISTER FILE       *f;
{
    long        l;

    l = (long) (*fgstab[bswap])(f) << 16;
                    /* Get high word */
    return(l + (unsigned) (*fgstab[bswap])(f));
                    /* Get low word */
}

static          pwlong(l,f)
long            l;
REGISTER FILE       *f;
{
    (*fpstab[bswap])((short) l,f);  /* Low word */
    (*fpstab[bswap])((short)(l >> 16),f);
                    /* High word */
}

static long     gwlong(f)
REGISTER FILE       *f;
{
    long        l;

    l = (unsigned) (*fgstab[bswap])(f); /* Get low word */
    return(l + ((long) (*fgstab[bswap])(f) << 16));
                    /* Get high word */
}

static int      (*fpltab[2])() =
            {
                plong,
                pwlong
            };
static long     (*fgltab[2])() =
            {
                glong,
                gwlong
            };

/*
 * int          swrite(cp,dopevec,count,file)
 * char         *cp;
 * char         *dopevec;
 * int          count;
 * FILE         *file;
 *
 * Returns number of bytes written.
 *
 * Dopevec is a character string with the
 * following format:
 *
 * "[b][w][p]{[<cnt>]<type>}"
 *
 * where [...] denotes an optional part, {...} denotes a part
 * that may be repeated zero or more times, and <...> denotes
 * a description of a part.
 *
 * b            bytes are "swapped" (not in PDP-11 order)
 * w            words are swapped
 * p            struct is "packed" (no padding for alignment)
 * <cnt>        count of times to repeat following type
 * <type>       one of the following:
 *   c          char
 *   s          short
 *   l          long
 *
 * Example: given the struct
 *
 * struct
 * {
 *   short      x;
 *   short      y;
 *   char       z[16];
 *   long       w;
 * };
 *
 * and assuming it is to be written so as to use VAX byte- and
 * word-ordering, its dope vector would be:
 *
 *  "wss16cl"
 */

int         swrite(cp,dopevec,count,file)
char            *cp;        /* Pointer to struct array */
char            *dopevec;   /* Dope vector for struct */
int         count;      /* Number of structs in array */
FILE            *file;      /* File to write to */
{
    int         pack;       /* Packed flag */
    int         rpt;        /* Repeat count */
    REGISTER int    cc = 0;     /* Count of characters written */
    REGISTER char   *dv;        /* Dope vector less flags */
    short       *sp;        /* Pointer to short */
    long        *lp;        /* Pointer to long */

    bswap = wswap = pack = 0;       /* Initialize flags */
    while(*dopevec != '\0')     /* Loop to set flags */
    {
        if(*dopevec == 'b') bswap = 1;  /* Check for byte-swapped flag */
        else if(*dopevec == 'p') pack = 1;
                        /* Check for packed flag */
        else if(*dopevec == 'w') wswap = 1;
                        /* Check for word-swapped flag */
        else break;
        ++dopevec;
    }
    while(count-- > 0)          /* Main loop */
    {
        dv = dopevec;           /* Initialize */
        for(;;)             /* Loop to write struct */
        {
            if(*dv >= '0' && *dv <= '9')
            {               /* If there is a repeat count */
                rpt = 0;        /* Initialize */
                do          /* Loop to get repeat count */
                {
                    rpt = rpt*10 + *dv++ - '0';
                            /* Take digit */
                }
                while(*dv >= '0' && *dv <= '9');
                            /* Loop until non-digit found */
            }
            else rpt = 1;       /* Else repeat count defaults to one */
            if(*dv == '\0') break;  /* break if end of dope vector */
            switch(*dv++)       /* Switch on type character */
            {
            case 'c':       /* Character */
#if FALSE AND OEXE
              CheckSum(rpt, cp);
#endif
              if(fwrite(cp,sizeof(char),rpt,file) != rpt) return(cc);
                        /* Write the characters */
              cp += rpt;        /* Increment pointer */
              cc += rpt;        /* Increment count of bytes written */
              break;

            case 's':       /* Short */
              if(!pack && (cc & 1)) /* If not packed and misaligned */
                {
                  cput(*cp++,file); /* Write padding byte */
                  ++cc;     /* Increment byte count */
                }
              sp = (short *) cp;    /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to write shorts */
                {
                  (*fpstab[bswap])(*sp++,file);
                        /* Write the short */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(short);
                        /* Increment byte count */
                }
              cp = (char *) sp; /* Update pointer */
              break;

            case 'l':       /* Long */
              if(!pack && (cc & 3)) /* If not packed and misaligned */
                {
                  while(cc & 3) /* While not aligned */
                    {
                      cput(*cp++,file);
                            /* Write padding byte */
                      ++cc;     /* Increment byte count */
                    }
                }
              lp = (long *) cp; /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to write longs */
                {
                  (*fpltab[wswap])(*lp++,file);
                        /* Write the long */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(long);
                        /* Increment byte count */
                }
              cp = (char *) lp; /* Update pointer */
              break;
            }
        }
    }
    return(cc);             /* Return count of bytes written */
}

/*
 * int          sread(cp,dopevec,count,file)
 * char         *cp;
 * char         *dopevec;
 * int          count;
 * FILE         *file;
 *
 * Returns number of bytes read.
 *
 * Dopevec is a character string whose format is described
 * with swrite() above.
 */
int         sread(cp,dopevec,count,file)
char            *cp;        /* Pointer to struct array */
char            *dopevec;   /* Dope vector for struct */
int         count;      /* Number of structs in array */
FILE            *file;      /* File to read from */
{
    int         pack;       /* Packed flag */
    int         rpt;        /* Repeat count */
    REGISTER int    cc = 0;     /* Count of characters written */
    REGISTER char   *dv;        /* Dope vector less flags */
    short       *sp;        /* Pointer to short */
    long        *lp;        /* Pointer to long */

    bswap = wswap = pack = 0;       /* Initialize flags */
    while(*dopevec != '\0')     /* Loop to set flags */
    {
        if(*dopevec == 'b') bswap = 1;  /* Check for byte-swapped flag */
        else if(*dopevec == 'p') pack = 1;
                        /* Check for packed flag */
        else if(*dopevec == 'w') wswap = 1;
                        /* Check for word-swapped flag */
        else break;
        ++dopevec;
    }
    while(count-- > 0)          /* Main loop */
    {
        dv = dopevec;           /* Initialize */
        for(;;)             /* Loop to write struct */
        {
            if(*dv >= '0' && *dv <= '9')
            {               /* If there is a repeat count */
                rpt = 0;        /* Initialize */
                do          /* Loop to get repeat count */
                {
                    rpt = rpt*10 + *dv++ - '0';
                            /* Take digit */
                }
                while(*dv >= '0' && *dv <= '9');
                            /* Loop until non-digit found */
            }
            else rpt = 1;       /* Else repeat count defaults to one */
            if(*dv == '\0') break;  /* break if end of dope vector */
            switch(*dv++)       /* Switch on type character */
            {
            case 'c':       /* Character */
              if(fread(cp,sizeof(char),rpt,file) != rpt) return(cc);
                        /* Read the characters */
              cp += rpt;        /* Increment pointer */
              cc += rpt;        /* Increment count of bytes written */
              break;

            case 's':       /* Short */
              if(!pack && (cc & 1)) /* If not packed and misaligned */
                {
                  *cp ++ = cget(file);
                        /* Read padding byte */
                  ++cc;     /* Increment byte count */
                }
              sp = (short *) cp;    /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to read shorts */
                {
                  *sp++ = (*fgstab[bswap])(file);
                        /* Read the short */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(short);
                        /* Increment byte count */
                }
              cp = (char *) sp; /* Update pointer */
              break;

            case 'l':       /* Long */
              if(!pack && (cc & 3)) /* If not packed and misaligned */
                {
                  while(cc & 3) /* While not aligned */
                    {
                      *cp++ = cget(file);
                            /* Read padding byte */
                      ++cc;     /* Increment byte count */
                    }
                }
              lp = (long *) cp; /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to read longs */
                {
                  *lp++ = (*fgltab[wswap])(file);
                        /* Read the long */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(long);
                        /* Increment byte count */
                }
              cp = (char *) lp; /* Update pointer */
              break;
            }
        }
    }
    return(cc);             /* Return count of bytes written */
}
#endif

#define CB_POOL 4096

typedef struct _POOLBLK
    {
    struct _POOLBLK *   pblkNext;   // next pool in list
    int                 cb;         // number of bytes in this pool (free+alloc)
    char                rgb[1];     // data for this pool (variable sized)
    } POOLBLK;

typedef struct _POOL
    {
    struct _POOLBLK *   pblkHead;   // start of poolblk list
    struct _POOLBLK *   pblkCur;    // current poolblk we are searching
    int                 cb;         // # bytes free in current pool
    char *              pch;        // pointer to free data in current pool
    } POOL;

void *
PInit()
{
    POOL *ppool;

    // create new pool, set size and allocate CB_POOL bytes

    ppool                     = (POOL *)GetMem(sizeof(POOL));
    ppool->pblkHead           = (POOLBLK *)GetMem(sizeof(POOLBLK) + CB_POOL-1);
    ppool->pblkHead->cb       = CB_POOL;
    ppool->pblkHead->pblkNext = NULL;
    ppool->cb                 = CB_POOL;
    ppool->pch                = &ppool->pblkHead->rgb[0];
    ppool->pblkCur            = ppool->pblkHead;

    return (void *)ppool;
}

void *
PAlloc(void *pp, int cb)
{
    POOL *ppool = (POOL *)pp;
    void *pchRet;
    POOLBLK *pblkCur, *pblkNext;

    // if the allocation doesn't fit in the current block

    if (cb > ppool->cb)
    {
        pblkCur  = ppool->pblkCur;
        pblkNext = pblkCur->pblkNext;

        // then check the next block

        if (pblkNext && pblkNext->cb >= cb)
        {
            // set the master info to reflect the next page...

            ppool->pblkCur  = pblkNext;
            ppool->cb       = pblkNext->cb;
            ppool->pch      = &pblkNext->rgb[0];
            memset(ppool->pch, 0, ppool->cb);
        }
        else
        {
            POOLBLK *pblkNew;   // new pool

            // allocate new memory -- at least enough for this allocation
            pblkNew           = (POOLBLK *)GetMem(sizeof(POOLBLK)+cb+CB_POOL-1);
            pblkNew->cb       = CB_POOL + cb;

            // link the current page to the new page

            pblkNew->pblkNext = pblkNext;
            pblkCur->pblkNext = pblkNew;

            // set the master info to reflect the new page...

            ppool->pblkCur    = pblkNew;
            ppool->cb         = CB_POOL + cb;
            ppool->pch        = &pblkNew->rgb[0];
        }

    }

    pchRet      = (void *)ppool->pch;
    ppool->pch += cb;
    ppool->cb  -= cb;
    return pchRet;
}

void
PFree(void *pp)
{
    POOL    *ppool     = (POOL *)pp;
    POOLBLK *pblk      = ppool->pblkHead;
    POOLBLK *pblkNext;

    while (pblk)
    {
        pblkNext = pblk->pblkNext;
        FFREE(pblk);
        pblk = pblkNext;
    }

    FFREE(ppool);
}

void
PReinit(void *pp)
{
    POOL *ppool    = (POOL *)pp;

    ppool->pblkCur = ppool->pblkHead;
    ppool->cb      = ppool->pblkHead->cb;
    ppool->pch     = &ppool->pblkHead->rgb[0];

    memset(ppool->pch, 0, ppool->cb);
}

#if RGMI_IN_PLACE

    /****************************************************************
    *                                                               *
    *  PchSegAddress:                                               *
    *                                                               *
    *  compute the address that will hold this data so we can read  *
    *  it in place... we make sure that we can read in place at     *
    *  and give errors as in MoveToVm if we cannot                  *
    *                                                               *
    *  Input:   cb      Count of bytes to be moved.                 *
    *           seg     Logical segment to which data belongs.      *
    *           ra      Offset at which data belongs.               *
    *                                                               *
    ****************************************************************/

BYTE FAR *              PchSegAddress(WORD cb, SEGTYPE seg, RATYPE ra)
{
    long                cbtot;          /* Count of bytes total */
    long                cbSeg;          /* Segment size */
    WORD                fError;
    BYTE FAR            *pMemImage;
    CVINFO FAR          *pCVInfo;
    SATYPE              sa;

    cbtot = (long) cb + ra;

    if (fDebSeg)
    {
        pCVInfo = ((APROPFILEPTR ) FetchSym(vrpropFile, FALSE))->af_cvInfo;
        if (pCVInfo)
        {
            if (seg < (SEGTYPE) (segDebFirst + ObjDebTotal))
            {
                cbSeg     = pCVInfo->cv_cbTyp;
                pMemImage = pCVInfo->cv_typ;

                if (!pMemImage)
                    pCVInfo->cv_typ = pMemImage = GetMem(cbSeg);
            }
            else
            {
                cbSeg     = pCVInfo->cv_cbSym;
                pMemImage = pCVInfo->cv_sym;

                if (!pMemImage)
                    pCVInfo->cv_sym = pMemImage = GetMem(cbSeg);
            }

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
        else
        {
            OutError(ER_badcvseg);
            return NULL;
        }
    }
    else
    {
        if (fNewExe)
        {
            cbSeg = ((APROPSNPTR) FetchSym(mpgsnrprop[vgsnCur],FALSE))->as_cbMx;
            sa = mpsegsa[seg];
            if (mpsaMem[sa] == NULL)
                mpsaMem[sa] = (BYTE FAR *) GetMem(mpsacb[sa]);
            pMemImage = mpsaMem[sa];

            // Check against segment bounds

            fError = (long) ((ra - mpgsndra[vgsnCur]) + cb) > cbSeg;
        }
        else
        {
            cbSeg = mpsegcb[seg] + mpsegraFirst[seg];
            if (mpsegMem[seg] == NULL)
                mpsegMem[seg] = (BYTE FAR *) GetMem(cbSeg);
            pMemImage = mpsegMem[seg];

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
    }

    if (fError)
    {
        if (!fDebSeg)
            OutError(ER_segbnd, 1 + GetFarSb(GetHte(mpgsnrprop[vgsnCur])->cch));
        else
            OutError(ER_badcvseg);
    }

    return (pMemImage + ra);
}

#endif

#if USE_REAL

// Indicates if you are running under TNT.
// If it returns FALSE today, you are running on NT.

int IsDosxnt ( ) {

#if defined( _WIN32 )
        return FALSE;
#else
        HINSTANCE hLib = GetModuleHandle("kernel32.dll");
        if ( hLib != 0 && (GetProcAddress(hLib, "IsTNT") != 0)) {
                return(TRUE);
                }
        else {
                return(FALSE);
                }
#endif

 }

// Are we running on Win31 or greater.
// Note that we know if we are running under Windows we are running in enhanced mode.

int IsWin31() {
                
#if defined( _WIN32 )
        return FALSE;
#else
        __asm {
                mov ax,1600h            ; Is Win31 or greater running 
                int     2fh                                              
                cmp al,03h              ; Is major version number 3.0   
                jb  NotWin31            ; Major version less than 3.0
                ja  ItIsWin31
                cmp ah,0ah              ; Is minor version atleast .10
                jb  NotWin31            ; Must be Win3.0
                }
ItIsWin31:
        return (TRUE);
NotWin31:
        return (FALSE);
#endif  // NOT _WIN32
        }
                
int MakeConvMemPageable ( )
    {
#if defined( _WIN32 )
        return TRUE;
#else
        if ( realModeMemPageable ) {
                return ( TRUE ); // Somebody already freed the real mode mem.
                }
        __asm {
                mov ax,0100h                    ; function to get DOS memory.
                mov bx,TOTAL_CONV_MEM   ; Ask for 1 M  to get max memory count
                int 31h                         

                jnc errOut                              ; allocated 1 M - something must be wrong.

                cmp ax,08h                              ; Did we fail because of not enough memory
                jne errOut                              ; No we failed because of some other reason.
                cmp bx,MIN_CONV_MEM             ; See if we can allocate atleast the min

                // We could fail for two reasons here .
                // 1) we really didn't have sufficient memory.
                // 2) Some TNT app that spawned us already unlocked this memory. For ex:
                //    cl might have already freed up the memory when it calls link.exe.

                jb      errOut                          ; Too little mem available don't bother.

                sub bx,CONV_MEM_FOR_TNT ; Leave  real mode mem for TNT.
                mov ax,0100h                    ; Try again with new amount of memory
                int 31h                                 ; Ask for the real mode memory from DPMI. 
                jc errOut                               ; didn't succeed again, give up.

                mov convMemSelector,dx  ; Save the value of the selector for allocated block
                mov noOfParagraphs,bx   ; amount of  memory we were able to allocate.

                mov ax,0006h                    ; function to get base addr of a selector
                mov bx,dx                               ; move the selector to bx
                int 31h                                 ; Get Segment Base Address
                jc      errOut                          ; 

                mov bx,cx                               ; mov lin addr from cx:dx to  bx:cx
                mov cx,dx                               ;

                movzx eax,noOfParagraphs
                shl eax,4                               ; Multiply by 16 to get count in bytes.
                
                mov di,ax                               ; transfer size to si:di from eax
                shr eax,16                              ; 
                mov si,ax                               ;
        
                mov ax,602h                             ; Make real mode memory  pageable
                int 31h

                jc errOut                               ; Didn't work.

                mov ax,703h                             ; Indicate data in these pages is discardable.
                int 31h
                // Even if we fail this call, we will still assume we are succesful,
                // because it is just a performance  enhancement
                // Also for correctness we should relock the memory once it is free. 
                        }
        realModeMemPageable = TRUE ;
errOut:
        return(realModeMemPageable);
#endif  // NOT _WIN32
        }

/* Relock the real mode memory now */

int RelockConvMem ( void )  
{
#if defined( _WIN32 )
        return TRUE;
#else
        if ( !realModeMemPageable ) {
                return ( TRUE );  // We were never able to free the mem anyway.
                }
        __asm {
                mov bx, convMemSelector  
                mov ax, 0006h
                int 31h                                 ; Get Segment Base Address. 
                jc  errOut                              ;       

                mov bx,cx                               ; Mov lin addr from cx:dx to bx:cx
                mov cx,dx       

                movzx eax,noOfParagraphs        
                shl eax,4                               ; Mul paragraphs by 16 to get count in bytes.
        
                mov di,ax                               ;Transfer size to si:di from eax.
                shr eax,16                                      
                mov si,ax

                mov ax,603h                             ; Relock real mode region
                int 31h                                 
                jc  errOut

                mov dx,convMemSelector
                mov ax,101h                             ; Free the real mode memory
                int 31h
                jc errOut
                }
                realModeMemPageable = FALSE ;
                return ( TRUE );
errOut:
                return ( FALSE );
#endif  // NOT _WIN32
}

void    RealMemExit(void)
{
    if(fUseReal)
    {
        if(!RelockConvMem())
            OutError(ER_membad);
        fUseReal = FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\nmsg.h ===
#define N_tgtexternal   300
#define N_frmseg        301
#define N_tgtseg        302
#define N_tgtoff        303
#define N_warning       304
#define N_error         305
#define N_fatal         306
#define N_pos   307
#define N_rectyp        308
#define N_infiles       309
#define N_version       310
#define N_allrights     311
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\qbsym.c ===
#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* More of the same */
#include                <bndrel.h>      /* More of the same */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

RBTYPE                  rhteBlank;
RBTYPE                  rhteBc_vars;
RBTYPE                  rhteFarData;
RBTYPE                  rhteFarBss;
SEGTYPE                 segFD1st;
SEGTYPE                 segFDLast;
SEGTYPE                 segFB1st;
SEGTYPE                 segFBLast;
SNTYPE                  gsnComBl;
SEGTYPE                 segQCode;

LOCAL RBTYPE            *psymrb;        /* pointer to table of sym addr's */
LOCAL WORD              symCodeMac;     /* # of code symbols */
LOCAL RATYPE            raNames;        /* offset into $name_list */
LOCAL RATYPE            raQbSym;        /* offset into SYMBOL segment */
LOCAL SEGTYPE           segQbSym;       /* segment number of SYMBOL segment */
LOCAL WORD              symQbMac;       /* count of all symbols */
LOCAL RBTYPE            rbQbstart;      /* Property address of __aulstart */

#define CBQBHDR         sizeof(QBHDRTYPE)
#define CBSYMENTRY      (4*sizeof(WORD))
#define QBTYP_CODE      1               /* code symbol */
#define QBTYP_DATA      2               /* data symbol */
#define QBTYP_SEG       3               /* segment symbol */
#define QBTYP_BCSEG     4               /* class BC_VARS, or name COMMON
                                         *  and class BLANK */
#define QBTYP_ABS       5               /* absolute symbol */
#define QBMAGIC         0x6c75          /* "ul" */
#define JMPFAR          0xea            /* JMP FAR */
#define QB_RACODELST    CBQBHDR
#define QBVER           2

/* QB symbol table header */
typedef struct qbhdr
  {
    BYTE                jmpstart[5];    /* JMP FAR __aulstart */
    BYTE                version;        /* version number */
    WORD                magic;          /* Magic word */
    WORD                raCodeLst;      /* Start of code symbols */
    WORD                raDataLst;      /* Start of data symbols */
    WORD                raSegLst;       /* Start of segment symbols */
    WORD                saCode;         /* Segment addr of seg _CODE */
    WORD                saData;         /* Segment addr of seg DGROUP */
    WORD                saSymbol;       /* Segment addr of seg SYMBOL (us) */
    WORD                cbSymbol;       /* Size of seg SYMBOL */
    WORD                saFarData;      /* Segment addr of 1st 'FAR_DATA' seg */
    long                cbFarData;      /* Total size of 'FAR_DATA' segs */
    WORD                saFarBss;       /* Segment addr of 1st 'FAR_BSS' seg */
    long                cbFarBss;       /* Total size of 'FAR_BSS' segs */
  } QBHDRTYPE;

/* Offsets into qbhdr */
#define QH_SAQBSTART    3               /* Segment part of __aulstart */
#define QH_SACODE       14              /* saCode */
#define QH_SADATA       16              /* saData */
#define QH_SASYMBOL     18              /* saSymbol */
#define QH_SAFARDATA    22              /* saFarData */
#define QH_SAFARBSS     28              /* saFarBss */

typedef struct qbsym
  {
    WORD                flags;          /* symbol type (code, data, segment) */
    WORD                raName;         /* offset into name_list */
    WORD                ra;             /* symbol address offset */
    SATYPE              sa;             /* symbol address segment base */
  } QBSYMTYPE;


/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void      QbSaveSym(APROPNAMEPTR prop,
                          RBTYPE       rhte,
                          RBTYPE       rprop,
                          WORD         fNewHte);
LOCAL void NEAR MoveToQbSym(unsigned short cb,void *pData);
LOCAL void NEAR BldQbHdr(void);
LOCAL void NEAR QbAddName(AHTEPTR ahte);
LOCAL void NEAR BldSegSym(unsigned short gsn);
LOCAL void NEAR BldSym(void FAR *prop);



/*
 *  Initializes items for Quick Basic symbol table.
 */

void NEAR               InitQbLib ()
  {
    SBTYPE              sb;             /* String buffer */
    BYTE                *psbRunfile;    /* Name of runfile */

#if OVERLAYS
    /* If overlays are specified, issue fatal error.  */
    if(fOverlays)
        Fatal(ER_swbadovl, "/QUICKLIB");
#endif
    PropSymLookup("\005BLANK",ATTRNIL,TRUE);
    rhteBlank = vrhte;
    PropSymLookup("\007BC_VARS",ATTRNIL,TRUE);
    rhteBc_vars = vrhte;
    PropSymLookup("\012__aulstart",ATTRUND,TRUE);
    rbQbstart = vrprop;
    PropSymLookup("\010FAR_DATA",ATTRNIL,TRUE);
    rhteFarData = vrhte;
    PropSymLookup("\007FAR_BSS",ATTRNIL,TRUE);
    rhteFarBss = vrhte;

    /* Assign default runfile extension, as appropriate.
     * First, make sb contain .QLB updated with user-supplied
     * name and extension, if any.
     */
    memcpy(sb,sbDotQlb,sizeof(sbDotQlb));
    UpdateFileParts(sb,bufg);

    /* Next, get the name of the runfile and update it with sb.
     */
    psbRunfile = GetFarSb(((AHTEPTR) FetchSym(rhteRunfile,FALSE))->cch);
    memcpy(bufg,psbRunfile,1 + B2W(*psbRunfile));
    UpdateFileParts(bufg,sb);
    /* If the name has changed, issue a warning and update rhteRunfile.
     */
    if(!SbCompare(bufg,psbRunfile,TRUE))
    {
        bufg[1 + B2W(*bufg)] = 0;
        OutWarn(ER_outputname, bufg + 1);
        PropSymLookup(bufg,ATTRNIL,TRUE);
        rhteRunfile = vrhte;
    }
  }

void NEAR               PrintQbStart(void)
{
    fprintf(bsLst,"\r\nProgram entry point at %04x:%04x\r\n",
          mpsegsa[segStart],(WORD)raStart);     /* Print entry point */
}

LOCAL void              QbSaveSym(APROPNAMEPTR prop,
                                  RBTYPE       rhte,
                                  RBTYPE       rprop,
                                  WORD         fNewHte)
  {
    AHTEPTR             hte = (AHTEPTR) rhte;

    /* Omit nonprintable symbols from the symbol table */
    if (!(prop->an_flags & FPRINT)) return;
    /* Omit printable symbols which starts with "B$..." or "b$..." */
    if(hte->cch[2] == '$' && hte->cch[0] >= 2 &&
            (hte->cch[1] == 'b' || hte->cch[1] == 'B'))
        return;

    if (prop->an_gsn != SNNIL && mpsegFlags[mpgsnseg[prop->an_gsn]] & FCODE)
        symCodeMac++;
    psymrb[symQbMac++] = rprop;         /* Save the prop addr */
  }

LOCAL void NEAR         MoveToQbSym (cb, pData)
WORD                    cb;
char                    *pData;
  {
    MoveToVm(cb, pData, segQbSym, raQbSym);
    raQbSym += cb;
  }

LOCAL void NEAR         BldQbHdr ()
  {
    QBHDRTYPE           hdr;            /* QB symbol table headr */
    APROPNAMEPTR        aprop;
    SATYPE              sa;

    memset(&hdr,0,sizeof(hdr));         /* Clear all header fields */
    hdr.jmpstart[0] = JMPFAR;
    aprop = (APROPNAMEPTR ) FetchSym(rbQbstart,FALSE);
    if(aprop == PROPNIL || aprop->an_attr != ATTRPNM)
        OutError(ER_qlib);
    else
    {
        hdr.jmpstart[1] = (BYTE) aprop->an_ra;
        hdr.jmpstart[2] = (BYTE) (aprop->an_ra >> 8);
        sa = mpsegsa[mpgsnseg[aprop->an_gsn]];
        hdr.jmpstart[3] = (BYTE) sa;
        hdr.jmpstart[4] = (BYTE) (sa >> 8);
        RecordSegmentReference(segQbSym,(long)QH_SAQBSTART,1);
    }
    hdr.raCodeLst = QB_RACODELST;       /* $code_list starts at known offset */
    hdr.raDataLst = (symCodeMac * CBSYMENTRY) + hdr.raCodeLst + 2;
    hdr.raSegLst = ((symQbMac - symCodeMac) * CBSYMENTRY) + hdr.raDataLst + 2;
    if(segQCode != SEGNIL)
    {
        hdr.saCode = mpsegsa[segQCode]; /* 1st code segment */
        RecordSegmentReference(segQbSym,(long)QH_SACODE,1);
    }
    if(ggrDGroup != GRNIL)
    {
        hdr.saData = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]];
        RecordSegmentReference(segQbSym,(long)QH_SADATA,1);
    }
    hdr.saSymbol = mpsegsa[segQbSym];   /* segment base of SYMBOL (us) */
    RecordSegmentReference(segQbSym,(long)QH_SASYMBOL,1);
    /* Get starting segment and size of FAR_DATA */
    if(segFD1st != SEGNIL)
    {
        hdr.saFarData = mpsegsa[segFD1st];
        RecordSegmentReference(segQbSym,(long)QH_SAFARDATA,1);
        hdr.cbFarData = mpsegcb[segFDLast] +
          ((long)(mpsegsa[segFDLast] - mpsegsa[segFD1st]) << 4);

    }
    /* Get starting segment and size of FAR_BSS */
    if(segFB1st != SEGNIL)
    {
        hdr.saFarBss = mpsegsa[segFB1st];
        RecordSegmentReference(segQbSym,(long)QH_SAFARBSS,1);
        hdr.cbFarBss = mpsegcb[segFBLast] +
          ((long)(mpsegsa[segFBLast] - mpsegsa[segFB1st]) << 4);

    }
    hdr.version = QBVER;
    hdr.magic = QBMAGIC;
    hdr.cbSymbol = (WORD) raQbSym;
    raQbSym = 0;
    MoveToQbSym(sizeof hdr, &hdr);
  }

int cdecl               QbCompSym (const RBTYPE *prb1, const RBTYPE *prb2)
  {
    APROPNAMEPTR        prop;
    SNTYPE              gsn1, gsn2;
    FTYPE               fCode1, fCode2;
    RBTYPE              rb1, rb2;


    gsn1 = ((APROPNAMEPTR ) FetchSym(*prb1, FALSE))->an_gsn;
    gsn2 = ((APROPNAMEPTR ) FetchSym(*prb2, FALSE))->an_gsn;
    if (gsn1 == gsn2)
    {
        prop = (APROPNAMEPTR ) FetchSym(*prb1,FALSE);
        while(prop->an_attr != ATTRNIL)
            prop = (APROPNAMEPTR ) FetchSym(rb1 = prop->an_next,FALSE);
        prop = (APROPNAMEPTR ) FetchSym(*prb2,FALSE);
        while(prop->an_attr != ATTRNIL)
            prop = (APROPNAMEPTR ) FetchSym(rb2 = prop->an_next,FALSE);
        return(FGtName(&rb1, &rb2));
    }
    /* For sorting, absolute symbols are treated as data */
    /* 1 code, 2 data:  1 < 2 : -1
     * 1 data, 2 code:  1 > 2 :  1
     * same:            1 = 2 :  0
     */
    fCode1 = (FTYPE) (gsn1 != SNNIL && mpsegFlags[mpgsnseg[gsn1]] & FCODE);
    fCode2 = (FTYPE) (gsn2 != SNNIL && mpsegFlags[mpgsnseg[gsn2]] & FCODE);
    if(fCode1 && !fCode2)
        return(-1);
    if(!fCode1 && fCode2)
        return(1);
    return(0);
  }

LOCAL void NEAR         QbAddName (ahte)
AHTEPTR                 ahte;
  {
    SBTYPE              sbName;
    WORD                cbName;
    BYTE                *sb;

    sb = GetPropName(ahte);
    cbName = B2W(sb[0]);
    memcpy(sbName,sb+1,cbName);         /* Copy name sans length byte */
    sbName[cbName] = '\0';              /* Terminate with null */
    MoveToVm((short)(cbName + 1), sbName, segQbSym, raNames);
    raNames += cbName + 1;              /* Update the name_list offset */
  }

LOCAL void NEAR         BldSegSym (gsn)
SNTYPE                  gsn;
  {
    APROPSNPTR          apropSn;
    QBSYMTYPE           entry;

    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], FALSE);
    if(apropSn->as_rCla == rhteBc_vars || gsn == gsnComBl)
        entry.flags = QBTYP_BCSEG;
    else
        entry.flags = QBTYP_SEG;        /* other segment */
    entry.raName = (WORD) raNames;      /* offset to name string */
    entry.ra = (WORD) mpsegraFirst[mpgsnseg[gsn]];
    entry.sa = mpsegsa[mpgsnseg[gsn]];
    RecordSegmentReference(segQbSym, (long) (raQbSym + 6), 1);
    MoveToQbSym(sizeof entry, &entry);  /* Move to symbol segment */
    QbAddName((AHTEPTR) apropSn);               /* Append name to name_list */
  }

/*
 * BldSym : Build a Quick symbol table entry for a given symbol prop addr
 */
LOCAL void NEAR         BldSym (prop)
APROPNAMEPTR            prop;           /* Symbol property cell */
{
    QBSYMTYPE           entry;          /* Quick symbol entry structure */
    SNTYPE              seg;            /* Segment number */
    SATYPE              saGroup;        /* Group base */
    APROPSNPTR          papropSn;       /* Segment property cell */

#if NOT NEWSYM
    prop = (APROPNAMEPTR ) FetchSym((RBTYPE) prop, FALSE);
#endif
    /* Set the symbol type in the flags field */
    if(prop->an_gsn == SNNIL)
        entry.flags = QBTYP_ABS;
    else if (mpsegFlags[mpgsnseg[prop->an_gsn]] & FCODE)
        entry.flags = QBTYP_CODE;
    else
        entry.flags = QBTYP_DATA;
    entry.raName = (WORD) raNames;      /* offset to name string */
    entry.ra = (WORD) prop->an_ra;      /* symbol address offset */
    if(entry.flags == QBTYP_ABS)
        entry.sa = 0;
    else
    {
        entry.sa = mpsegsa[seg = mpgsnseg[prop->an_gsn]];
                                        /* symbol address segment */
        if(seg <= segLast)
        {
            /* If segment is member of a group, adjust symbol offset
             * to be group-relative.
             */
            papropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[prop->an_gsn],
                                                 FALSE);
            if(papropSn->as_ggr != GRNIL)
            {
                saGroup = mpsegsa[mpgsnseg[mpggrgsn[papropSn->as_ggr]]];
                entry.ra = (WORD)((entry.ra + ((entry.sa - saGroup) << 4)) & ~(~0 << WORDLN));
                                        /* Fix offset */
                entry.sa = saGroup;     /* Set base to base of group */
            }
        }
        RecordSegmentReference(segQbSym, (long) (raQbSym + 6), 1);
    }
    MoveToQbSym(sizeof entry, &entry);  /* Move to SYMBOL segment */
    QbAddName((AHTEPTR) prop);          /* Append name to name_list */
}

void NEAR               BldQbSymbols (gsnQbSym)
SNTYPE                  gsnQbSym;
{
    SNTYPE              seg;
    SNTYPE              gsn;
    WORD                zero = 0;
    APROPSNPTR          apropSn;
    WORD                sym;
    extern WORD         pubMac;


    psymrb = (RBTYPE FAR *) GetMem((pubMac+1) * sizeof(RBTYPE));
    segStart = segQbSym = mpgsnseg[gsnQbSym];
    raStart = 0;
    mpsegFlags[segQbSym] |= FNOTEMPTY;  /* Make sure it is output */
    if (mpsegMem[segQbSym])
        FFREE(mpsegMem[segQbSym]);      // Initial allocation was incorrect
    mpsegMem[segQbSym] = GetMem(LXIVK); // Allocate 64k
    mpsegcb[segQbSym] = LXIVK;
    raQbSym = CBQBHDR;                  /* Skip header for now */
    EnSyms(QbSaveSym, ATTRPNM);         /* Save the symbol addr's in symrb */
    qsort(psymrb, symQbMac, sizeof(RBTYPE),
          (int (__cdecl *)(const void *, const void *)) QbCompSym);
                                        /* Sort into code, data, & by name */
    raNames = raQbSym + ((symQbMac + segLast) * CBSYMENTRY) + 6;
    for (sym = 0; sym < symCodeMac; sym++)
        BldSym(psymrb[sym]);
    MoveToQbSym(2, &zero);
    for (; sym < symQbMac; sym++)
        BldSym(psymrb[sym]);
    MoveToQbSym(2, &zero);
    /* Look for segment COMMON class BLANK */
    apropSn = (APROPSNPTR ) PropSymLookup("\006COMMON",ATTRPSN,FALSE);
    if(apropSn != PROPNIL)
    {
        while(apropSn->as_attr != ATTRNIL)
        {
            if(apropSn->as_attr == ATTRPSN && apropSn->as_rCla == rhteBlank)
                break;
            apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
        }
        if(apropSn->as_attr != ATTRNIL)
            gsnComBl = apropSn->as_gsn;
    }
    for (seg = 1; seg <= segLast; seg++)
    {
        for (gsn = 1; gsn <= gsnMac && seg != mpgsnseg[gsn]; gsn++);
        BldSegSym(gsn);
        if(segQCode == SEGNIL && (mpsegFlags[seg] & FCODE))
            segQCode = seg;
    }
    raQbSym = raNames;
    MoveToQbSym(2, &zero);
    mpsegcb[segQbSym] = (long) raQbSym;
    ((APROPSNPTR ) FetchSym(mpgsnrprop[gsnQbSym], TRUE))->as_cbMx = raQbSym;
    BldQbHdr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\pack.c ===
/*static char *SCCSID = "%W% %E%";*/
/*
*       Copyright Microsoft Corporation 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* Exepack */

    /****************************************************************
    *                                                               *
    *                           PACK.C                              *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

#if FEXEPACK AND ODOS3EXE                       /* Whole file is conditional */
typedef struct _RUNTYPE
{
    WORD                wSignature;
    WORD                cbLastp;
    WORD                cpnRes;
    WORD                irleMax;
    WORD                cparDirectory;
    WORD                cparMinAlloc;
    WORD                cparMaxAlloc;
    WORD                saStack;
    WORD                raStackInit;
    WORD                wchksum;
    WORD                raStart;
    WORD                saStart;
    WORD                rbrgrle;
    WORD                iovMax;
    WORD                doslev;
}
                        RUNTYPE;

/* States of automaton */
#define STARTSTATE      0
#define FINDREPEAT      1
#define FINDENDRPT      2
#define EMITRECORD      3

/*
 *  LOCAL FUNCTION PROTOTYPES
 */


LOCAL void           NEAR EmitRecords(void);
LOCAL unsigned char  NEAR GetFromVM(void);
LOCAL unsigned short NEAR ScanWhileSame(void);
LOCAL unsigned short NEAR ScanWhileDifferent(void);
LOCAL WORD           NEAR AfterScanning(unsigned short l);
LOCAL void           NEAR OutEnum(void);
LOCAL void           NEAR OutIter(SATYPE sa, WORD length);


/*
 *                  DATA DEFINED IN UNPACK MODULE: unpack.asm
 */

#if NOT defined( _WIN32 )
extern char * FAR cdecl UnpackModule;   /* Unpacker/Relocator module */
extern char  FAR  cdecl SegStart;       // Start of unpacker
extern WORD  FAR  cdecl cbUnpack;       /* Length of UnpackModule */
extern WORD  FAR  cdecl ipsave;         /* Original IP */
extern WORD  FAR  cdecl cssave;         /* Original CS */
extern WORD  FAR  cdecl spsave;         /* Original SP */
extern WORD  FAR  cdecl sssave;         /* Original SS */
extern WORD  FAR  cdecl cparExp;        /* # para. in expanded image */
extern WORD  FAR  cdecl raStartUnpack;  /* Offset of code start in unpacker */
extern WORD  FAR  cdecl raMoveUnpack;   /* Offset of self-moving in unpacker */
extern WORD  FAR  cdecl raBadStack;     /* Bottom of bad stack range */
extern WORD  FAR  cdecl szBadStack;     /* Bad stack range */
#else // _WIN32

//
// For the portable NTGroup version of this linker, we can't use unpack32.asm
// directly because we need to run on RISC platforms.  But we still need this
// code, which is real-mode x86 code tacked onto the DOS binary which unpacks
// the packed EXE and then calls the real entrypoint.  So it's defined as a
// byte array, and the interesting offsets are hard-coded here.  I came across
// these values and the code debugging link3216.exe built as the languages group
// did.
//

#define SegStart        unpack
#define cbUnpack        (*(WORD *) &unpack[6])
#define ipsave          (*(WORD *) &unpack[0])
#define cssave          (*(WORD *) &unpack[2])
#define spsave          (*(WORD *) &unpack[8])
#define sssave          (*(WORD *) &unpack[0xa])
#define cparExp         (*(WORD *) &unpack[0xc])
#define raStartUnpack   0x10
#define raMoveUnpack    0x33
#define raBadStack      0
#define szBadStack      0x35

unsigned char unpack[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x42,
    0x8b, 0xe8, 0x8c, 0xc0, 0x05, 0x10, 0x00, 0x0e,
    0x1f, 0xa3, 0x04, 0x00, 0x03, 0x06, 0x0c, 0x00,
    0x8e, 0xc0, 0x8b, 0x0e, 0x06, 0x00, 0x8b, 0xf9,
    0x4f, 0x8b, 0xf7, 0xfd, 0xf3, 0xa4, 0x50, 0xb8,
    0x34, 0x00, 0x50, 0xcb, 0x8c, 0xc3, 0x8c, 0xd8,
    0x48, 0x8e, 0xd8, 0x8e, 0xc0, 0xbf, 0x0f, 0x00,
    0xb9, 0x10, 0x00, 0xb0, 0xff, 0xf3, 0xae, 0x47,
    0x8b, 0xf7, 0x8b, 0xc3, 0x48, 0x8e, 0xc0, 0xbf,
    0x0f, 0x00, 0xb1, 0x04, 0x8b, 0xc6, 0xf7, 0xd0,
    0xd3, 0xe8, 0x8c, 0xda, 0x2b, 0xd0, 0x73, 0x04,
    0x8c, 0xd8, 0x2b, 0xd2, 0xd3, 0xe0, 0x03, 0xf0,
    0x8e, 0xda, 0x8b, 0xc7, 0xf7, 0xd0, 0xd3, 0xe8,
    0x8c, 0xc2, 0x2b, 0xd0, 0x73, 0x04, 0x8c, 0xc0,
    0x2b, 0xd2, 0xd3, 0xe0, 0x03, 0xf8, 0x8e, 0xc2,

    0xac, 0x8a, 0xd0, 0x4e, 0xad, 0x8b, 0xc8, 0x46,
    0x8a, 0xc2, 0x24, 0xfe, 0x3c, 0xb0, 0x75, 0x05,
    0xac, 0xf3, 0xaa, 0xeb, 0x06, 0x3c, 0xb2, 0x75,
    0x6d, 0xf3, 0xa4, 0x8a, 0xc2, 0xa8, 0x01, 0x74,
    0xb1, 0xbe, 0x32, 0x01, 0x0e, 0x1f, 0x8b, 0x1e,
    0x04, 0x00, 0xfc, 0x33, 0xd2, 0xad, 0x8b, 0xc8,
    0xe3, 0x13, 0x8b, 0xc2, 0x03, 0xc3, 0x8e, 0xc0,
    0xad, 0x8b, 0xf8, 0x83, 0xff, 0xff, 0x74, 0x11,
    0x26, 0x01, 0x1d, 0xe2, 0xf3, 0x81, 0xfa, 0x00,
    0xf0, 0x74, 0x16, 0x81, 0xc2, 0x00, 0x10, 0xeb,
    0xdc, 0x8c, 0xc0, 0x40, 0x8e, 0xc0, 0x83, 0xef,
    0x10, 0x26, 0x01, 0x1d, 0x48, 0x8e, 0xc0, 0xeb,
    0xe2, 0x8b, 0xc3, 0x8b, 0x3e, 0x08, 0x00, 0x8b,
    0x36, 0x0a, 0x00, 0x03, 0xf0, 0x01, 0x06, 0x02,
    0x00, 0x2d, 0x10, 0x00, 0x8e, 0xd8, 0x8e, 0xc0,
    0xbb, 0x00, 0x00, 0xfa, 0x8e, 0xd6, 0x8b, 0xe7,

    0xfb, 0x8b, 0xc5, 0x2e, 0xff, 0x2f, 0xb4, 0x40,
    0xbb, 0x02, 0x00, 0xb9, 0x16, 0x00, 0x8c, 0xca,
    0x8e, 0xda, 0xba, 0x1c, 0x01, 0xcd, 0x21, 0xb8,
    0xff, 0x4c, 0xcd, 0x21, 0x50, 0x61, 0x63, 0x6b,
    0x65, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20,
    0x69, 0x73, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x75,
    0x70, 0x74
};

#endif // _WIN32

LOCAL WORD              lastc;          /* last character */
LOCAL WORD              c;              /* current or next character */
LOCAL WORD              State = STARTSTATE;
                                        /* current state */
LOCAL FTYPE             fEnumOK;        /* OK to emit enumerated records */
LOCAL WORD              cbRepeat;       /* length of repeated stream */
LOCAL WORD              cbEnum;         /* length of enumerated stream */

#define EHLEN           3               /* 2 for length + 1 for type */
#define MAXRPT          0xfff0          /* Maximum length to compress */
#define MAXENM          (0xfff0-(EHLEN+1))
                                        /* Maximum length of enum. stream */
#define MINEXP          (2*EHLEN+2)     /* Minimum length of repeated stream,
                                         * after the first repeate record */
#define toAdr20(seg, off) (((long)seg << 4) + off)

LOCAL WORD              minRpt = (18 * EHLEN) + 1;
                                        /* Minimum for rpt rec begins larger */

/* Type values for expansion record headers */

#define RPTREC          0xb0            /* Repeat record */
#define ENMREC          0xb2            /* Enumerated record */


/*
 * OutPack - Run a buffer through the compactor.  Return value is
 *      undefined.
 */
void                    OutPack (pb, cb)
REGISTER BYTE           *pb;            /* Pointer to buffer */
unsigned                cb;             /* Number of bytes to compress */
{
    REGISTER BYTE       *endp;          /* Pointer to end of buffer */

    endp = &pb[cb];

    while (pb < endp)
        switch (State)
        {
            case STARTSTATE:
                lastc = *pb++;
                State = FINDREPEAT;
                break;

            case FINDREPEAT:
                if (cbEnum >= MAXENM)
                {
                    EmitRecords();
                    State = FINDREPEAT;
                    break;
                }
                c = *pb++;
                if (c == lastc)
                {
                    cbRepeat = 2;
                    State = FINDENDRPT;
                    break;
                }
                /* At this point c != lastc */
                fputc(lastc, bsRunfile);
                cbEnum++;
                lastc = c;
                break;

            case FINDENDRPT:
                c = *pb++;
                if (c == lastc && cbRepeat < MAXRPT)
                {
                    cbRepeat++;
                    break;
                }
                if (cbRepeat < minRpt)
                {
                    /*
                     * Not long enough.  Enum record swallows
                     * repeated chars.
                     */
                    while (cbEnum <= MAXENM && cbRepeat > 0)
                    {
                        fputc(lastc, bsRunfile);
                        cbEnum++;
                        cbRepeat--;
                    }
                    if (cbRepeat > 0)
                        EmitRecords();
                } else
                    EmitRecords();
                lastc = c;      /* Prepare for next stream */
                State = FINDREPEAT;
        }
}

/*
 * EmitRecords  - Emits 1 or 2 expansion records.  Return value is
 *      undefined.
 */

LOCAL void NEAR         EmitRecords ()
{
    /* We have 1 or 2 records to output */
    if (cbEnum > 0)
    {
#if MDEBUG AND FDEBUG
        if (fDebug) fprintf(stdout, "E%8x\n", cbEnum);
#endif
        if (fEnumOK)
        {
            /* Output an enumerated record header */
            OutWord(cbEnum);
            fputc(ENMREC, bsRunfile);
        }
        cbEnum = 0;
    }
    if (cbRepeat >= minRpt)
    {
#if MDEBUG AND FDEBUG
        if (fDebug) fprintf(stdout, "R%8x\n", cbRepeat);
#endif
        /* Output a repeat record */
        fputc(lastc, bsRunfile);
        OutWord(cbRepeat);
        if (!fEnumOK)
        {
            /* 1st record header generated */
            fputc(RPTREC|1, bsRunfile);
            fEnumOK = 1;
        } else
            fputc(RPTREC, bsRunfile);
        cbRepeat = 0;
        minRpt = MINEXP;                /* 1st is out, so reset minRpt */
    } else if (cbRepeat > 0)
    {
        cbEnum = cbRepeat;
        while (cbRepeat-- > 0)
            fputc(lastc, bsRunfile);
    }
}

/*
 * EndPack      - End the packing procedure:  add the relocator module.
 */
void                    EndPack (prun)
RUNTYPE                 *prun;                  /* Pointer to runfile header */
{
    long                fpos;           /* File position */
    WORD                cparPacked;     /* # paras in packed image */
    WORD                cparUnpack;     /* Size of Unpack module (paras) */
    int                 i;
    int                 crle;           /* Count of relocs for a frame */
    long                cTmp;           /* Temporary count */
    long                us;             /* User's stack in minalloc         */
    long                los;            /* Low end of forbidden stack       */


    fseek(bsRunfile, 0L, 2);            /* Go to end of file */

    cTmp = (((((long)prun->cpnRes-1)<<5) - prun->cparDirectory) << 4) +
            (prun->cbLastp ? prun->cbLastp : 512);
                                        /* Get # bytes in expanded image */
    cbRepeat += (WORD) (0xf & (0x10 - (0xf & cTmp)));
                                        /* Make it look like image ends on
                                         * paragraph boundary */
    if (State == FINDREPEAT)
    {
        fputc(lastc, bsRunfile);        /* Update last enum record */
        cbEnum++;
    }
    minRpt = 1;                         /* Force final repeat rec. out */
    EmitRecords();                      /* Output the final record(s) */

    cparExp = (short) ((cTmp + 0xf) >> 4);/* Save # paras in image */

    /*
     * Append the unpacking module (relocator-expander)
     */
    fpos = ftell(bsRunfile);            /* Save where Unpack begins */

    /* Align Unpack on paragraph boundary */
    while (fpos & 0x0f)
    {
        fpos++;
        fputc(0xff, bsRunfile);
    }

    /* Make sure User stack won't stomp on unpack code                  */

    us  = toAdr20(prun->saStack, prun->raStackInit);
    los = toAdr20((cTmp >> 4), raBadStack);

    while ( us > los && us - los < szBadStack )
    {
        for (i = 0; i < 16; i++)
        {
            us--;
            fpos++;
            fputc(0xff, bsRunfile);
        }
    }

    fflush(bsRunfile);

    cparPacked = (WORD) ((fpos >> 4) - prun->cparDirectory);
    if (cTmp < ((long)cparPacked << 4) + raMoveUnpack)
        Fatal(ER_badpack);

    /* Append relocator module (Unpack).  This code depends
     * closely on the structure of unpack.asm.  */

    /* Get length of relocation area */
    for (crle = 0, i = 0; i < 16; i++)
        crle += (mpframeRlc[i].count + 1) << 1;

    /* Initialize stack of relocator module */
    ipsave = prun->raStart;
    cssave = prun->saStart;
#if defined( _WIN32 )
    if (cbUnpack != sizeof(unpack))
        Fatal(ER_badpack);
#endif
    i = cbUnpack;
    cbUnpack += (WORD)crle;
    spsave = prun->raStackInit;
    sssave = prun->saStack;
#ifdef M_BYTESWAP
    bswap(Unpack, 7);
#endif
#if DOSX32
    WriteExe(&SegStart, i);
#else
    fwrite(UnpackModule, 1, i, bsRunfile);
#endif
    /* Append optimized relocation records */
    for (i = 0; i < 16; i++)
    {
        crle = mpframeRlc[i].count;
        OutWord((WORD) crle);
        WriteExe(mpframeRlc[i].rgRlc, crle * sizeof(WORD));
    }

    /* Correct header values */
    fpos += cbUnpack;
    prun->cbLastp = (WORD) (fpos & 0x1ff);
    prun->cpnRes = (WORD) ((fpos + 511) >> 9);
    prun->irleMax = 0;
    cparUnpack = (cbUnpack + 0xf) >> 4;
    prun->cparMinAlloc = (cparExp + max(prun->cparMinAlloc,(cparUnpack+8)))
             - (cparPacked + cparUnpack);
    if (prun->cparMaxAlloc < prun->cparMinAlloc)
        prun->cparMaxAlloc = prun->cparMinAlloc;
    prun->saStack = cparExp + cparUnpack;
    prun->raStackInit = 128;
    prun->raStart = raStartUnpack;
    prun->saStart = cparPacked;
    fseek(bsRunfile, 0L, 0);
    OutHeader((struct exe_hdr *) prun);
    fseek(bsRunfile, fpos, 0);
}

#ifdef M_BYTESWAP
/*
 * Swap bytes for 1st n words in buffer.
 */
LOCAL bswap (buf, n)
REGISTER char   *buf;
REGISTER int    n;
{
    REGISTER char       swapb;

    for ( ; n-- > 0 ; buf += 2)
    {
        swapb = buf[0];
        buf[0] = buf[1];
        buf[1] = swapb;
    }
}
#endif
#endif /*FEXEPACK AND ODOS3EXE*/

/*
 * The following routines concern packing segmented-executable format
 * files.
 */
#if FALSE
#define MINREPEAT       32              /* Min length of iteration cousing compression */

LOCAL long              vaLast;         /* Virtual address */
LOCAL long              vaStart;        /* Virtual scanning start address */
LOCAL long              BufEnd;         /* Virtual address of buffer end */
#if EXE386
LOCAL long              ra;             /* Offset within packed segment */
#endif
LOCAL BYTE              LastB;
LOCAL BYTE              CurrentB;
LOCAL long              VPageAddress;   /* Virtual address of current page */
LOCAL WORD              VPageOffset;    /* Current position within virtual page */
LOCAL BYTE              *PageBuffer;    /* Virtual page buffer */


LOCAL BYTE NEAR         GetFromVM()
{

    if (VPageOffset == PAGLEN)
      {
        PageBuffer = mapva(VPageAddress, FALSE);
                                        /* Fetch  page */
        VPageAddress += PAGLEN;         /* Update page virtual address */
        VPageOffset = 0;                /* Init page offset */
      }
    return(PageBuffer[VPageOffset++]);
}


LOCAL WORD NEAR         ScanWhileSame()
{
    long                l;

    l = 2L;                            /* We are looking at two bytes in buffer */
    while (CurrentB == LastB)
      {
        if (vaStart + l >= BufEnd)
          return((WORD) l);            /* We bump the buffer end */

        CurrentB = GetFromVM();
        l++;
      }
    return(l == 2L ? 0 : (WORD) (l - 1));
                                       /* We went one byte too far to detect they are different */
}


LOCAL WORD NEAR         ScanWhileDifferent()
{
    long                l;

    l = 2L;                            /* We are looking at two bytes in buffer */
    while (CurrentB != LastB)
      {
        if (vaStart + l >= BufEnd)
          return((WORD) l);            /* We bump the buffer end */

        LastB = CurrentB;
        CurrentB = GetFromVM();
        l++;
      }
    return((WORD) (l - 2));            /* We went two bytes too far to detect they are the same */
}


LOCAL WORD NEAR         AfterScanning(l)
WORD                    l;              /* Length of scanned bytes */
{
    vaStart += l;                       /* Update scan start address */
#if EXE386
    ra += l;                            /* Update offset in segment */
#endif
    if (vaStart + 2 >= BufEnd)
    {                                   /* We need at least to bytes remaining */
      return(FALSE);                    /* Buffer end */
    }
    else
    {
      if (LastB != CurrentB)
      {                                 /* We stop at iterated and enumerated */
        LastB = CurrentB;               /* byte sequence, so we have move     */
        CurrentB = GetFromVM();         /* one byte forward                   */
      }
      return((WORD) TRUE);
    }
}


LOCAL void NEAR         OutEnum(void)
{
#if EXE386
    if (ExeFormat == Exe386)
        OutVm(vaLast, vaStart - vaLast);
    else
    {
#endif
        OutWord(1);
        OutWord((WORD) (vaStart - vaLast));
        OutVm(vaLast, vaStart - vaLast);
#if EXE386
    }
#endif

    PageBuffer = mapva((VPageAddress - PAGLEN), FALSE);
                                        /* Refetch  page */
}


LOCAL void NEAR         OutIter(SATYPE sa, WORD length)
{
#if EXE386
    ITER                idata;          /* Iterated data description for range */


    if (ExeFormat == Exe386)
    {
        idata.iterations = (DWORD) length;
        idata.length = (DWORD) 1;
        idata.data = (DWORD) LastB;
        UpdateRanges(ShortIterData, sa, ra, &idata);
    }
    else
    {
#endif
        OutWord(length);
        OutWord(1);
        OutByte(bsRunfile, LastB);
#if EXE386
    }
#endif
}

/*
 *      Out5Pack - Run a buffer through the compactor.  Return value is
 *      starting position where data was written to output file.
 */


long                    Out5Pack (sa, packed)
SATYPE                  sa;             /* File segment to be packed */
WORD                    *packed;        /* TRUE if iterated records written */
{
    WORD                proceed;        /* True if there are bytes to scan */
    WORD                length;         /* Scanned bytes length */
    long                lfaStart;       /* Starting file address */


    lfaStart = ftell(bsRunfile);        /* Get the starting address */
    VPageAddress = AREASA(sa);
    VPageOffset = PAGLEN;
    *packed = FALSE;
    if (mpsacbinit[sa] > 1L)
      {                                 /* If buffer is big enough */
#if EXE386
        ra = 0L;                        /* Offset within segment */
#endif
        vaStart = VPageAddress;
        vaLast = vaStart;
        BufEnd = vaStart + mpsacbinit[sa];
        LastB = GetFromVM();
        CurrentB = GetFromVM();
        proceed = (WORD) TRUE;          /* Initialize */

        while (proceed)
          {
            length = ScanWhileDifferent();
            if (!(proceed = AfterScanning(length)))
              break;

            if ((length = ScanWhileSame()) > MINREPEAT)
              {                         /* If there are enough same bytes */
                if (vaLast != vaStart)
                    OutEnum();          /* First write out preceeding diff. bytes */

                OutIter(sa, length);    /* Now write out iterated record */
                proceed = AfterScanning(length);
                *packed = (WORD) TRUE;
                vaLast = vaStart;
              }
            else proceed = AfterScanning(length);
                                        /* Otherwise enumerated record swallow this */
          }                             /* small repeated record */
      }
    if (*packed)
      {
        if (vaLast != BufEnd)
        {
            vaStart = BufEnd;
            OutEnum();                   /* Write out any remainig bytes */
        }

        mpsacbinit[sa] = ftell(bsRunfile) - lfaStart;
                                        /* Return number of written bytes */
        return(lfaStart);
      }
    else
      return(OutVm(AREASA(sa),mpsacbinit[sa]));
}
#endif /*FEXEPACK AND OSEGEXE*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\stdio20.h ===
/*** stdio20.h - linker I/O package
*
*       Copyright <C> 1985, Microsoft Corporation
*
* Purpose:
*   This is optimized stdio package for linker. Advantages over standard
*   C run-time stdio are:
*       - smaller size
*       - greater speed
*   This package is not general nature and is tailored to linker
*   requrements.
*
*************************************************************************/



#define NULL                    0
#define EOF                     (-1)
#define _IOREAD                 0x01
#define _IOWRT                  0x02
#define _IOPEN                  0x03
#define _IONBF                  0x04
#define _IOEOF                  0x10
#define _IOERR                  0x20
#define  _IOFBF     0x0
#define CTRL_Z                  0x1a

typedef struct file
  {
    char                *_ptr;
    int                 _cnt;
    char                *_base;
    char                _flag;
    char                _file;
    int                 _bsize;             /* buffer size */
  }
                        FILE;

extern FILE             _iob[];

extern int  cdecl _filbuf(struct file *f);
extern void cdecl _xfilbuf(struct file *f);
extern int  cdecl _flsbuf(unsigned int c,struct file *f);
extern int  cdecl fflush(struct file *f);
extern int  cdecl fclose(struct file *f);
extern long cdecl ftell(struct file *f);
extern int  cdecl fseek(struct file *f,long lfa,int mode);
extern int  cdecl fgetc(struct file *f);
extern int  cdecl fputc(unsigned int c,struct file *f);
extern int  cdecl fputs(char *s,struct file *f);
extern int  cdecl fread(void *pobj,
                        unsigned int cbobj,
                        unsigned int nobj,
                        struct file *f);
extern int  cdecl fwrite(char *pobj,int cbobj,int nobj,struct file *f);
extern int  cdecl ungetc(int c,struct file *f);
extern void cdecl FlsStdio(void);
extern struct file * cdecl fopen(char *name,char *mode);
extern struct file * cdecl fdopen(int fh,char *mode);
extern int  cdecl setvbuf(struct file *fh,char *buf,int type,int size);


#define stdin           (&_iob[0])
#define stdout          (&_iob[1])
#define stderr          (&_iob[2])
#define getc(p)         (--(p)->_cnt>=0? *(p)->_ptr++&0377:_filbuf(p))
#define putc(x,p)       (--(p)->_cnt>=0? ((int)(*(p)->_ptr++=(char)(unsigned)(x))):_flsbuf((unsigned)(x),p))
#define feof(p)         (((p)->_flag&_IOEOF)!=0)
#define ferror(p)       (((p)->_flag&_IOERR)!=0)
#define fileno(p)       ((p)->_file)


// The following functions are comming from standard C run-time library

#if defined( _WIN32 )
#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif
#endif


extern int  cdecl sprintf(char *buf, const char *fmt, ...);
extern int  cdecl vsprintf(char *buf, const char *fmt, va_list pArgs);

//
// DLH Can't use fprintf or vfprintf from MSVCRT.DLL, since the FILE structure
// is too different.  Implemented in stdio20.c instead.
//

extern int  cdecl fprintf(struct file *f, const char *fmt, ...);
extern int  cdecl vfprintf(struct file *f, const char *fmt, va_list pArgs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\stdio20.c ===
/*static char *SCCSID = "%W% %E%";*/
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
/*
 *  STANDARD I/O:
 *
 *  Standard (buffered) I/O package which is smaller and faster
 *  than the MS C runtime stdio.
 */

#include                <fcntl.h>
#include                <minlit.h>
#include                <memory.h>
#include                <io.h>
#include                <string.h>

#if NOT defined( _WIN32 )
#define i386
#endif
#include                <stdarg.h>


#if OWNSTDIO

#define STDSIZ          128                 /* Size for stdin, stdout */
#define BUFSIZ          1024                /* Size for other files */
typedef char            IOEBUF[STDSIZ];     /* For stdin, stdout */
#define _NFILE          10
#define _NSTD           2               /* # automatic stdio buffers */

LOCAL IOEBUF            _buf0;
LOCAL IOEBUF            _buf1;
LOCAL int               cffree = _NFILE - _NSTD;

#if DOSX32              // hack needed untill the libc.lib is fixed
int _cflush;
#endif


/*
 * typedef struct file
 *   {
 *     char             *_ptr;
 *     int              _cnt;
 *     char             *_base;
 *     char             _flag;
 *     char             _file;
 *     int              _bsize;
 *   }
 *                      FILE;
 */
FILE                    _iob[_NFILE] =
{
    { NULL, NULL, _buf0, _IOREAD, 0, STDSIZ },
    { _buf1, STDSIZ, _buf1, _IOWRT, 1, STDSIZ },
};

typedef struct file2
{
    char  _flag2;
    char  _charbuf;
    int   _bufsiz;
    int   __tmpnum;
    char  _padding[2];              /* pad out to size of FILE structure */
}
          FILE2;

FILE2                   _iob2[_NFILE] =
{
    {0x01, '\0', STDSIZ        },
    {0x00, '\0', 0             }
};

#if (_MSC_VER >= 700)

// 23-Jun-1993 HV Kill the near keyword to make the compiler happy
#define near

/* pointer to end of descriptors */
FILE * near       _lastiob = &_iob[ _NFILE -1];
#endif

/*
 *  LOCAL FUNCTION PROTOTYPES
 */



int  cdecl               _filbuf(f)
REGISTER FILE            *f;
{
    if((f->_cnt = _read(f->_file,f->_base,f->_bsize)) <= 0)
    {
        if(!f->_cnt) f->_flag |= _IOEOF;
        else f->_flag |= _IOERR;
        return(EOF);
    }
    f->_ptr = f->_base;
    --f->_cnt;
    return((int) *f->_ptr++ & 0xff);
}

/* Just like _filbuf but don't return 1st char */

void  cdecl              _xfilbuf(f)
REGISTER FILE            *f;
{
    if((f->_cnt = _read(f->_file,f->_base,f->_bsize)) <= 0)
    {
        if(!f->_cnt) f->_flag |= _IOEOF;
        else f->_flag |= _IOERR;
    }
    f->_ptr = f->_base;
}

int  cdecl              _flsbuf(c,f)
unsigned                c;
REGISTER FILE           *f;
{
    unsigned            b;

    if(f->_flag & _IONBF)
    {
        b = c;
        if(_write(f->_file,&b,1) != 1)
        {
            f->_flag |= _IOERR;
            return(EOF);
        }
        f->_cnt = 0;
        return((int) c);
    }
    f->_cnt = f->_bsize - 1;
    if(_write(f->_file,f->_base,f->_bsize) != f->_bsize)
    {
        f->_flag |= _IOERR;
        return(EOF);
    }
    f->_ptr = f->_base;
    *f->_ptr++ = (char) c;
    return((int) c);
}

#if (_MSC_VER >= 700)
int  cdecl               _flush(f)
REGISTER FILE            *f;
{
    return(fflush(f));
}
#endif



int  cdecl               fflush(f)
REGISTER FILE            *f;
{
    REGISTER int        i;

    if(f->_flag & _IONBF) return(0);
    if(f->_flag & _IOWRT)
    {
        i = f->_bsize - f->_cnt;
        f->_cnt = f->_bsize;
        if(i && _write(f->_file,f->_base,i) != i)
        {
            f->_flag |= _IOERR;
            return(EOF);
        }
        f->_ptr = f->_base;
        return(0);
    }
    if(f->_flag & _IOREAD)
    {
        f->_cnt = 0;
        return(0);
    }
    return(EOF);
}

int  cdecl              fclose(f)
REGISTER FILE           *f;
{
    int                 rc;             /* Return code from close() */

    if(!(f->_flag & _IOPEN))
        return(EOF);
    fflush(f);
    if(f->_file > 2)
    {
        rc = _close(f->_file);
        /* Free the file stream pointer regardless of close() return
         * value, since code elsewhere may be intentionally calling
         * fclose() on a file whose handle has already been closed.
         */
        f->_flag = 0;
        ++cffree;
        return(rc);
    }
    return(0);
}

long  cdecl             ftell(f)
REGISTER FILE           *f;
{
    if(f->_flag & _IONBF) return(_lseek(f->_file,0L,1));
    if(f->_flag & _IOREAD) return(_lseek(f->_file,0L,1) - f->_cnt);
    if(f->_flag & _IOWRT) return(_lseek(f->_file,0L,1) + f->_bsize - f->_cnt);
    return(-1L);
}

int  cdecl              fseek(f,lfa,mode)
REGISTER FILE           *f;
long                    lfa;
int                     mode;
{
    REGISTER int        ilfa;

    f->_flag &= ~_IOEOF;
    if(f->_flag & _IONBF)
    {
        if(_lseek(f->_file,lfa,mode) != -1L) return(0);
        f->_flag |= _IOERR;
        return(EOF);
    }
    if(mode == 1)
    {
        if(f->_flag & _IOREAD)
        {
            if(((long) f->_cnt > lfa && lfa >= 0) ||
            (lfa < 0 && (long)(f->_base - f->_ptr) <= lfa))
            {                           /* If we won't go beyond the buffer */
                ilfa = (int) lfa;
                f->_cnt -= ilfa;
                f->_ptr += ilfa;
                return(0);
            }
            lfa -= f->_cnt;
        }
    }
    if(fflush(f)) return(EOF);
    if (mode != 2 && (f->_flag & _IOREAD))
    {
        /*
         * If absolute mode, or relative mode AND forward, seek to the
         * est preceding 512-byte boundary to optimize disk I/O.
         * It could be done for backward relative seeks as well, but we
         * would have to check whether the current file pointer (FP) is
         * on a 512-byte boundary.  If FP were not on a 512-byte boundary,
         * we might attempt to seek before the beginning of the file.
         * (Example:  FP = 0x2445, destination address = 0x0010, lfa = -0x2435,
         * mode = 1.  Rounding of lfa to 512-boundary yields -0x2600
         * which is bogus.)  FP will usually not be on a 512 boundary
         * at the end of file, for example.  Solution is to keep track of
         * current FP.  This is not worth the effort, especially since
         * seeks are rare because of the extended dictionary.
         * Use "lfa >= 0" as test, since if mode is 0 this will always be
         * true, and it also filters out backward relative seeks.
         */
        if(lfa >= 0)
        {
            /*
             * Optimization:  eliminate relative seeks of 0.
             */
            if(mode == 0 || lfa & ~0x1ff)
                if (_lseek(f->_file, lfa & ~0x1ff, mode) == -1L)
                {
                    f->_flag |= _IOERR;
                    return(EOF);
                }
            _xfilbuf(f);
            f->_cnt -= lfa & 0x1ff;     /* adjust _iobuf fields */
            f->_ptr += lfa & 0x1ff;
            return(0);
        }
    }
    if(_lseek(f->_file,lfa,mode) == -1L)
    {
        f->_flag |= _IOERR;
        return(EOF);
    }
    return(0);
}

int  cdecl              fgetc(f)
REGISTER FILE           *f;
{
    return(getc(f));
}

int  cdecl              fputc(c,f)
unsigned                c;
REGISTER FILE           *f;
{
    unsigned            b;

    if(f->_flag & _IONBF)
    {
        b = c;
        if(_write(f->_file,&b,1) == 1) return((int) c);
        f->_flag |= _IOERR;
        return(EOF);
    }
    return(putc(c,f));
}

int  cdecl               fputs(s,f)
REGISTER char            *s;
REGISTER FILE            *f;
{
    int         i;

    if(f->_flag & _IONBF)
    {
        i = strlen(s);
        if(_write(f->_file,s,i) == i) return(0);
        f->_flag |= _IOERR;
        return(EOF);
    }
    for(; *s; ++s)
        if(putc(*s,f) == EOF) return(EOF);
    return(0);
}

int  cdecl              fread(pobj,cbobj,nobj,f)
char                    *pobj;
unsigned                cbobj;
unsigned                nobj;
FILE                    *f;
{
    REGISTER int      i;        /* # bytes left to read */
    REGISTER unsigned j;        /* # bytes to transfer to buffer */

    // special case for one block -- try to avoid all this junk
    if (cbobj == 1 && nobj <= (unsigned)f->_cnt)
    {
        memcpy(pobj, f->_ptr, nobj);
        f->_cnt -= nobj;
        f->_ptr += nobj;
        return nobj;
    }

    i = nobj*cbobj;             /* Initial request ==> bytes */
    do
    {
        j = (i <= f->_cnt)? i: f->_cnt; /* Determine how much we can move */
        memcpy( pobj,f->_ptr,j);          /* Move it */
        f->_cnt -= j;                   /* Update file count */
        f->_ptr += j;                   /* Update file pointer */
        i -= j;                         /* Update request count */
        pobj += j;                      /* Update buffer pointer */
        if (i && !f->_cnt) _xfilbuf(f); /* Fill buffer if necessary */
    } while (i && !(f->_flag & (_IOEOF|_IOERR)));
    return(nobj - i/cbobj);
}

/*
 *  fwrite : standard library routine
 */
int  cdecl              fwrite(pobj,cbobj,nobj,f)

char                    *pobj;          /* Pointer to buffer */
int                     cbobj;          /* # bytes per object */
int                     nobj;           /* # objects */
register FILE           *f;             /* File stream */
{
    register int        cb;             /* # bytes remaining to write */


    /* Check for error initially so we don't trash data unnecessarily.  */
    if(ferror(f))
        return(0);

    /* Initialize count of bytes remaining to write.  */
    cb = nobj * cbobj;

    if (cb > f->_cnt) // doesn't fit -- must flush
        if (fflush(f))
            return 0;

    if (cb > f->_cnt) // bigger than the buffer... don't bother copying
        {
        if (_write(f->_file, pobj, cb) != cb)
            return 0;
        }
    else
        {
        memcpy(f->_ptr, pobj, cb);
        f->_cnt -= cb;
        f->_ptr += cb;
        }

    return nobj;
}


int  cdecl              ungetc(c,f)
int                     c;
FILE                    *f;
{
    if(!(f->_flag & _IONBF) && f->_cnt < f->_bsize && c != EOF)
    {
        ++f->_cnt;
        *--f->_ptr = (char) c;
        return(c);
    }
    return(EOF);
}


void cdecl              flushall ()
{
    FlsStdio();
}


#if (_MSC_VER >= 700)
void cdecl              _flushall ()
{
    FlsStdio();
}
#endif

void  cdecl             FlsStdio()
{
    FILE                *p;

    for(p = _iob; p < &_iob[_NSTD]; p++)
        if(p->_flag & _IOPEN) fclose(p);
}

/*
 *  makestream
 *
 *  Makes a file stream structure for a possibly already-opened file.
 *  Does common work for fopen, fdopen.
 *  If name parameter is NULL, then file has been opened, else use the
 *  name.
 *  RETURNS     pointer to stream or NULL.
 */

LOCAL FILE *  NEAR cdecl makestream(mode,name,fh)
char                     *mode;
char                     *name;
int                      fh;
{
    REGISTER int         i;
    REGISTER FILE        *f;
    int                  openmode;
    int                  iOpenRet;

    if(!cffree--)
    {
        cffree = 0;
        return(NULL);
    }
    for(i = _NSTD; _iob[i]._flag & _IOPEN; ++i);
    f = &_iob[i];
    f->_base = NULL;
    f->_bsize = 0;
    f->_flag = _IONBF;
    if(name == NULL)
        f->_file = (char) fh;
    if(*mode == 'r')
    {
        openmode = O_RDONLY;
        if(mode[1] == 't')
            openmode |= O_TEXT;
        else if(mode[1] == 'b')
            openmode |= O_BINARY;


        if(name != NULL)
        {
            iOpenRet = _open(name,openmode);
            if (iOpenRet == -1)
            {
                ++cffree;
                return(NULL);
            }
            else
            {
                f->_file = (char) iOpenRet;
            }
        }
        f->_cnt = 0;
        f->_flag |= _IOREAD;
        return(f);
    }
    f->_cnt = f->_bsize;
    f->_ptr = f->_base;
    openmode = O_CREAT | O_TRUNC | O_WRONLY;
    if(mode[1] == 't')
        openmode |= O_TEXT;
    else if(mode[1] == 'b')
        openmode |= O_BINARY;


        if(name != NULL)
        {
            iOpenRet = _open(name,openmode, 0600);
            if (iOpenRet == -1)
            {
                ++cffree;
                return(NULL);
            }
            else
            {
                f->_file = (char) iOpenRet;
            }
        }

    f->_flag |= _IOWRT;
    return(f);
}

/*
 *  fopen : (standard library routine)
 *
 *  WARNING:  This is a LIMITED version of fopen().  Only "r" and
 *  "w" modes are supported.
 */

FILE *  cdecl           fopen(name,mode)
char                    *name;
char                    *mode;
{
    return(makestream(mode,name,0));
}

/*
 *  fdopen : (standard library routine)
 *
 *  WARNING:  This is a LIMITED version of fdopen().  Only "r" and
 *  "w" modes are supported.
 */

FILE *  cdecl           fdopen(fh,mode)
int                     fh;
char                    *mode;
{
    return(makestream(mode,NULL,fh));
}

/*
 *  setvbuf : standard library routine
 *
 *  WARNING:  This is a LIMITED version of setvbuf().  Only
 *  type _IOFBF is supported.
 */
int  cdecl              setvbuf (fh, buf, type, size)
FILE                    *fh;
char                    *buf;
int                     type;
int                     size;
{
    if(fflush(fh) || type != _IOFBF)
        return(EOF);
    fh->_base = buf;
    fh->_flag &= ~_IONBF;
    fh->_bsize = size;
    if(fh->_flag & _IOWRT)
    {
        fh->_cnt = size;
        fh->_ptr = buf;
    }
    return(0);
}

#endif

int
__cdecl
printf(char *fmt, ...)
{
    va_list marker;
    int ret;

    va_start(marker, fmt);
    ret = vfprintf(stdout, fmt, marker);
    fflush(stdout);
    va_end(marker);
    return ret;
}

//
// DLH Can't use fprintf or vfprintf from MSVCRT.DLL, since the FILE structure
// is too different.
//

int cdecl fprintf(struct file *f, const char *fmt, ...)
{
    va_list marker;
    int ret;

    va_start(marker, fmt);
    ret = vfprintf(f, fmt, marker);
    fflush(f);
    va_end(marker);
    return ret;
}

int  cdecl vfprintf(struct file *f, const char *fmt, va_list pArgs)
{
    int cb;
    static char szBuf[4096];

    cb = vsprintf(szBuf, fmt, pArgs);

    fwrite(szBuf, 1, cb, f);

    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\undname.h ===
#if     ( defined ( _M_IX86 ) || defined ( M_I386) || defined ( _WIN32) )
        //      The 32-bit compiler

        #define __far
        #define __near
// DLH        #define __cdecl
// DLH        #define __pascal
        #define __export        _export
        #define __loadds
#elif   ( defined ( _MSC_VER ) && ( _MSC_VER < 700 ))
        //      Using C6.00 or earlier ?

        #define __far           _far
        #define __near          _near
        #define __cdecl         _cdecl
        #define __pascal        _pascal
        #define __export        _export
        #define __loadds        _loadds
#endif

#ifndef USE_CRT_HEAP
#define USE_CRT_HEAP    0
#endif
#ifndef NO_OPTIONS
#define NO_OPTIONS              0
#endif


typedef char __far *            pchar_t;
typedef const char __far *      pcchar_t;

#if     ( !USE_CRT_HEAP )
typedef void __far *    ( __far __cdecl * Alloc_t )( size_t );
typedef void                    ( __far __cdecl * Free_t  )( void __far * );
#endif  // !USE_CRT_HEAP


#if     __cplusplus
extern "C"
#endif


pchar_t __far __cdecl __loadds  __unDName (
                                                        pchar_t,                // User supplied buffer (or NULL)
                                                        pcchar_t,               // Input decorated name
                                                        int                             // Maximum length of user buffer

#if     ( !USE_CRT_HEAP )
                                                        ,Alloc_t                // Address of heap allocator
                                                        ,Free_t                 // Address of heap deallocator
#endif  // USE_CRT_HEAP

#if     ( !NO_OPTIONS )
                                                        ,unsigned short // Feature disable flags
#endif  // !NO_OPTIONS
                                                );

/*
 *      The user may provide a buffer into which the undecorated declaration
 *      is to be placed, in which case, the lenght field must be specified.
 *      The lenght is the maximum number of characters (including the terminating
 *      NULL character) which may be written into the user buffer.
 *
 *      If the output buffer is NULL, the lenght field is ignored, and the
 *      undecorator will allocate a buffer exactly large enough to hold the
 *      resulting declaration.  It is the users responsibility to deallocate
 *      this buffer.
 *
 *      The user may also supply the allocator and deallocator functions if
 *      they wish.  If they do, then all heap actions performed by the routine
 *      will use the provide heap functions.
 *
 *      If the allocator address is NULL, then the routine will default to using
 *      the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *      If an error occurs internally, then the routine will return NULL.  If
 *      it was successful, it will return the buffer address provided by the
 *      user, or the address of the buffer allocated on their behalf, if they
 *      specified a NULL buffer address.
 *
 *      If a given name does not have a valid undecoration, the original name
 *      is returned in the output buffer.
 *
 *      Fine selection of a number of undecorator attributes is possible, by
 *      specifying flags (bit-fields) to disable the production of parts of the
 *      complete declaration.  The flags may be OR'ed together to select multiple
 *      disabling of selected fields.  The fields and flags are as follows :-
 */

#if     ( !NO_OPTIONS )
#define UNDNAME_COMPLETE                                (0x0000)        // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)        // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS                  (0x0002)        // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS             (0x0004)        // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL             (0x0008)        // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)        // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE                  (0x0020)        /* NYI */       // Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE                  (0x0040)        /* NYI */       // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE                             (0x0060)        // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)        // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES             (0x0100)        // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE                  (0x0200)        // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL             (0x0400)        // Disable expansion of MS model for UDT returns
#endif  // NO_OPTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\ver3216.c ===
/*
 *  VER3216.C
 *
 *  Version-related information.
 *
 */
#include            <minlit.h>
#include            <bndtrn.h>
#include            <bndrel.h>
#include            <lnkio.h>
#include            <extern.h>
#include            <lnkmsg.h>
#include            "ver3216.h"

unsigned char      LINKVER = rmj;   /* Version number */
unsigned char      LINKREV = rmm;   /* Release number */


void                    DisplayBanner(void)
{
    if (!BannerOnScreen && !fNoBanner)
    {
#if O68K
        FmtPrint("\r\nMicrosoft (R) x86/68k Segmented Executable Linker  "VERSION_STRING );
#else
#if defined( _WIN32 )
        FmtPrint("\r\nMicrosoft (R) Segmented Executable Linker NTGroup "VERSION_STRING );
#else
        FmtPrint("\r\nMicrosoft (R) Segmented Executable Linker  "VERSION_STRING );
#endif
#endif
        FmtPrint("\r\nCopyright (C) Microsoft Corp 1984-1993.  %s.\r\n\r\n",
                    __NMSG_TEXT(N_allrights));
        BannerOnScreen = (FTYPE) TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\ver3216.h ===
/*
 * defines for the version string
 */
#include "version.h"

#if( rmm < 10 )
#define rmmpad "0"
#else
#define rmmpad
#endif

#if( rup < 10 )
#define ruppad "00"
#endif

#if( (rup >= 10) && (rup < 100) )
#define ruppad "0"
#endif

#if( rup >= 100 )
#define ruppad
#endif

#define X(a,b,c) #a "." rmmpad #b "." ruppad #c ""

#define VER_OUTPUT(a,b,c) X(a,b,c)
#if WIN_3 OR O68K
#define VERSION_STRING "Version "VER_OUTPUT(rmj,rmm,rup)
#else
#define VERSION_STRING "Version "VER_OUTPUT(rmj,rmm,rup)" "__DATE__"\0\xE0""01"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\verimp.h ===
/*
 * defines for the version string
 */
#include "version.h"

#undef rmj
#undef rmm

#define rmj 1           /* major version string */
#ifdef _WIN32
#define rmm 50
#else
#ifdef M_I386
#define rmm 50          /* minor version string */
#else
#define rmm 42          /* minor version string */
#endif
#endif

#if( rmm < 10 )
#define rmmpad "0"
#else
#define rmmpad
#endif

#if( rup < 10 )
#define ruppad "00"
#endif

#if( (rup >= 10) && (rup < 100) )
#define ruppad "0"
#endif

#if( rup >= 100 )
#define ruppad
#endif

#define X(a,b,c) #a "." rmmpad #b "." ruppad #c

#define VER_OUTPUT(a,b,c) X(a,b,c)

#define VERSION_STRING "Version "VER_OUTPUT(rmj,rmm,rup)"\0\xE0\xEA""01"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\version.h ===
#define rmj             5
#define rmm             60
#define rup             220
#define szVerName       ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\undname.cxx ===
//      Make sure all dependent defines exist and have a valid value

#ifndef TUNE
#define TUNE                                    0
#endif
#ifndef DEBUG
#define DEBUG                                   0
#endif
#ifndef STANDALONE
#define STANDALONE                              0
#endif
#ifndef SPECIAL
#define SPECIAL                                 0
#endif
#ifndef TARGET_32BIT
#define TARGET_32BIT                    1  // DLH set in makefile originally
#endif
#ifndef USE_CRT_HEAP
#define USE_CRT_HEAP                    0
#endif
#ifndef NO_COMPILER_NAMES
#define NO_COMPILER_NAMES               0
#endif
#ifndef NO_OPTIONS
#define NO_OPTIONS                              0
#endif
#ifndef NO_INLINES
#define NO_INLINES                              0
#endif
#ifndef VERS_P3
#define VERS_P3                                 0
#endif
#ifndef VERS_PWB
#define VERS_PWB                                0
#endif
#ifndef VERS_LNK
#define VERS_LNK                                1  // DLH set in makefile originally
#endif
#ifndef PACK_SIZE
#define PACK_SIZE                               1
#endif
#ifndef inline_p3
#define inline_p3
#endif
#ifndef inline_pwb
#define inline_pwb
#endif
#ifndef inline_lnk
#define inline_lnk
#endif
#ifndef NO_VIRTUAL
#define NO_VIRTUAL                              0
#endif


//      Check for version inconsistancies, ans setup version flags

#if     ( TUNE && STANDALONE )
#error  "TUNE and STANDALONE are incompatible"
#endif  // TUNE && STANDALONE

#if     ( VERS_P3 == 1 )
        #if     ( VERS_PWB == 1 )
        #error  "VERS_P3 and VERS_PWB are incompatible"
        #endif  // VERS_PWB
        #if     ( VERS_LNK == 1 )
        #error  "VERS_P3 and VERS_LNK are incompatible"
        #endif  // VERS_LNK

        #undef  inline_p3
        #define inline_p3       inline

        #undef  USE_CRT_HEAP
        #define USE_CRT_HEAP            1

        #undef  NO_COMPILER_NAMES
        #define NO_COMPILER_NAMES       1

        #undef  NO_OPTIONS
        #define NO_OPTIONS                      1

        #pragma inline_depth ( 3 )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE                       1
#endif

#if     ( VERS_PWB == 1 )
        #if     ( DEBUG == 1 )
        #error  "VERS_PWB and DEBUG are incompatible"
        #endif  // DEBUG
        #if     ( VERS_LNK == 1 )
        #error  "VERS_PWB and VERS_LNK are incompatible"
        #endif  // VERS_LNK

        #undef  inline_pwb
        #define inline_pwb      inline

        #undef  USE_CRT_HEAP
        #define USE_CRT_HEAP            0

        #undef  NO_COMPILER_NAMES
        #define NO_COMPILER_NAMES       1

        #undef  NO_OPTIONS
        #define NO_OPTIONS                      1

        #undef  PACK_SIZE
        #define PACK_SIZE                       2

        #undef  NO_VIRTUAL
        #define NO_VIRTUAL                      1

        #pragma inline_depth ( 5 )
        #pragma pack ( 2 )
#endif  // VERS_PWB

#if     ( VERS_LNK == 1 )
        #if     ( VERS_PWB == 1 )
        #error  "VERS_LNK and VERS_PWB are incompatible"
        #endif  // VERS_PWB

        #undef  inline_lnk
        #define inline_lnk      inline

        #if     ( DEBUG == 1 )
                #if     !STANDALONE
                        #undef  USE_CRT_HEAP
                        #define USE_CRT_HEAP            1
                #endif
        #else   // } else !DEBUG {
                #undef  USE_CRT_HEAP
                #define USE_CRT_HEAP            0
        #endif  // !DEBUG

        #undef  NO_COMPILER_NAMES
        #define NO_COMPILER_NAMES       0

        #undef  NO_OPTIONS
        #define NO_OPTIONS                      0

        #undef  NO_VIRTUAL
        #define NO_VIRTUAL                      1

        #pragma inline_depth ( 3 )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE                       2
#endif  // VERS_LNK


#if     ( TARGET_32BIT )
#define __far           /* no far */
#define __near          /* no near */
#define __pascal        /* no pascal */
#if !defined( _WIN32 )
#define __cdecl         /* no cdecl */
#endif
#define __loadds        /* no loadds */
#endif  // TARGET_32BIT


#if     ( !NO_VIRTUAL )
#define PURE    =0
#else   // } elif NO_VIRTUAL {
#define PURE
#define virtual
#endif

#if     DEBUG && STANDALONE
        #define STDEBUG 1
#endif


#include        "undname.hxx"


static  unsigned int    __near __pascal strlen ( pcchar_t );
static  pchar_t                 __near __pascal strncpy ( pchar_t, pcchar_t, unsigned int );


#if     USE_CRT_HEAP
extern "C"      void __far *    __far __cdecl   malloc ( unsigned int );
extern "C"      void                    __far __cdecl   free   ( void __far * );
#endif  // USE_CRT_HEAP


#if     STDEBUG
        #pragma inline_depth    ( 0 )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE               1


        #include        <stdio.h>


        class   DName;
        class   DNameNode;

        class   CallTrace
        {
        private:
                enum InOut { out = -1, mark = 0, in = 1 };
                pchar_t name;
        static  int             trace;
        static  FILE *  fp;
        static  char    buf[ 512 ];
        static  int             inTrace;
        static  void    indent ( InOut inOut )
                { static depth = 0; for ( int d = depth - (( inOut == out ) ? 1 : 0 ); d; d-- ) fputc ( '.', fp ); switch ( inOut ) { case in: depth++; break; case out: depth--; break; }}

        public:
                CallTrace ( pchar_t p )
                :       name ( p )
                { if(trace&&!inTrace){ indent ( in ); fprintf ( fp, "Entered : '%s'\n", name ); fflush ( fp ); }}

        static  void    On ( pchar_t f )
                { fp = fopen ( f, "wt" ); if(fp) trace = 1; }

                void    Dump ( const DName &, pcchar_t, int );
                void    Dump ( const DNameNode &, pcchar_t, int );
                void    Dump ( unsigned long, pcchar_t, int );
                void    Dump ( void*, pcchar_t, int );
                void    Dump ( pcchar_t, pcchar_t, int );
                void    Message ( pcchar_t, int );
                void    Track ( pcchar_t, int );

                void    LogError ( int );

                ~CallTrace ()
                { if(trace&&!inTrace){ indent ( out ); fprintf ( fp, "Leaving : '%s'\n", name ); fflush ( fp ); }}
        };

        int             CallTrace::trace        = 0;
        int             CallTrace::inTrace      = 0;
        FILE *  CallTrace::fp           = 0;
        char    CallTrace::buf[ 512 ];

        #undef  NO_INLINES
        #define NO_INLINES              1

        #define FTRACE(n)       CallTrace fName(#n)
        #define TRACEON()       do{if((argc>=2)&&(*argv[1]!='?')&&((*argv[1]<'0')||(*argv[1]>'9'))){argv++;argc--;CallTrace::On(*argv);}}while(0)
        #define DUMP(n)         (fName.Dump(n,#n,__LINE__))
        #define TRACK()         (fName.Track(__FILE__,__LINE__))
        #define MESSAGE(m)      (fName.Message(#m,__LINE__))
        #define ERROR           (fName.LogError(__LINE__),DN_error)
#else   // } elif !STDEBUG {
        #pragma check_stack             ( off )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE               1

        #define FTRACE(n)
        #define TRACEON()
        #define DUMP(n)
        #define TRACK()
        #define MESSAGE(m)      (0)
        #define ERROR           DN_error
#endif  // !STDEBUG



#if     ( NO_INLINES )
#undef  inline_p3
#undef  inline_pwb
#undef  inline_lnk

#define inline
#define inline_p3
#define inline_pwb
#define inline_lnk
#endif  // NO_INLINES


#if     STANDALONE
extern "C"      int                             __far __cdecl   printf ( pcchar_t, ... );
extern "C"      int                             __far __cdecl   atoi ( pcchar_t );
extern "C"      void __far *    __far __cdecl   malloc ( unsigned int );
extern "C"      void                    __far __cdecl   free   ( void __far * );

#if     STDEBUG
int     shallowCopies   = 0;
int     deepCopies              = 0;
int     shallowAssigns  = 0;
int     deepAssigns             = 0;
#endif

int actual                      = 0;
int     requested               = 0;
int     clones                  = 0;

int     __cdecl main ( int argc, pchar_t* argv )
{
TRACEON();
FTRACE(main);
        unsigned short  flags   = 0;


        if      (( argc > 2 ) && ( *argv[ 1 ] >= '0' ) && ( *argv[ 1 ] <= '9' ))
                ( flags = atoi ( argv[ 1 ]), argc--, argv++ );

        for     ( int i = 1; i < argc; i++ )
        {
                printf ( "Undecoration of :- \"%s\"\n", argv[ i ]);

                pchar_t uName   = unDName       (       0,
                                                                                argv[ i ],
                                                                                0
#if     ( !USE_CRT_HEAP )
                                                                                ,&malloc
                                                                                ,&free
#endif  // !USE_CRT_HEAP

#if     ( !NO_OPTIONS )
                                                                                ,flags
#endif  // !NO_OPTIONS
                                                                        );

                if      ( uName )
                        printf ( "is :- \"%s\"\n\n", uName );
                else
                        printf ( "Internal Error in Undecorator\n" );
        }

#if     STDEBUG
        printf ( "%d bytes of memory requested, %d bytes allocated\n", requested, actual );
        printf ( "%d shallow copies and %d deep copies\n", shallowCopies, deepCopies );
        printf ( "%d shallow assigns and %d deep assigns\n", shallowAssigns, deepAssigns );
        printf ( "%d clones\n", clones );
#endif

        return  0;

}       // End of PROGRAM
#endif  // STANDALONE


#if     TUNE
void    __cdecl main ()
{       (void)unDName ( 0, 0, 0

        #if     ( !USE_CRT_HEAP )
                                        ,0, 0
        #endif  // !USE_CRT_HEAP
        #if     ( !NO_OPTIONS )
                                        ,0
        #endif  // !NO_OPTIONS
        );      }
#endif  // TUNE


class   DName;
class   DNameNode;
class   Replicator;
class   HeapManager;
class   UnDecorator;


const   unsigned int    memBlockSize    = 508;  // A '512' byte block including the header


class   HeapManager
{
private:

#if     ( !USE_CRT_HEAP )
                Alloc_t                 pOpNew;
                Free_t                  pOpDelete;
#endif  // !USE_CRT_HEAP

                struct  Block
                {
                        Block *         next;
                        char            memBlock[ memBlockSize ];

                                __near  Block ()        {       next    = 0;    }

                };

                Block *                 head;
                Block *                 tail;
                unsigned int    blockLeft;

public:
#if     ( !USE_CRT_HEAP )
                void    __near  Constructor ( Alloc_t pAlloc, Free_t pFree )
                                                {       pOpNew          = pAlloc;
                                                        pOpDelete       = pFree;
#else   // } elif USE_CRT_HEAP {
                void    __near  Constructor ( void )
                                                {
#endif  // USE_CRT_HEAP

                                                        blockLeft       = 0;
                                                        head            = 0;
                                                        tail            = 0;
                                                }

                void __far *    __near  getMemory ( size_t, int );

                void    __near  Destructor ( void )
                                                {       while   ( tail = head )
                                                        {
                                                                head    = tail->next;

#if     ( !USE_CRT_HEAP )
                                                                ( *pOpDelete )( tail );
#else   // } elif USE_CRT_HEAP {
                                                                free ( tail );
#endif  // USE_CRT_HEAP

                                                }       }

                #define gnew    new(heap,0)
                #define rnew    new(heap,1)

};



void   *        __near __pascal operator new ( size_t, HeapManager &, int = 0 );



static  HeapManager     heap;


#if     ( !VERS_PWB )
//      The MS Token table

enum    Tokens
{
        TOK_near,
        TOK_nearSp,
        TOK_nearP,
        TOK_far,
        TOK_farSp,
        TOK_farP,
        TOK_huge,
        TOK_hugeSp,
        TOK_hugeP,
        TOK_basedLp,
        TOK_cdecl,
        TOK_pascal,
        TOK_stdcall,
        TOK_syscall,
        TOK_fastcall,
        TOK_interrupt,
        TOK_saveregs,
        TOK_self,
        TOK_segment,
        TOK_segnameLpQ

};


static  pcchar_t        __near  tokenTable[]    =
{
        "__near",               // TOK_near
        "__near ",              // TOK_nearSp
        "__near*",              // TOK_nearP
        "__far",                // TOK_far
        "__far ",               // TOK_farSp
        "__far*",               // TOK_farP
        "__huge",               // TOK_huge
        "__huge ",              // TOK_hugeSp
        "__huge*",              // TOK_hugeP
        "__based(",             // TOK_basedLp
        "__cdecl",              // TOK_cdecl
        "__pascal",             // TOK_pascal
        "__stdcall",    // TOK_stdcall
        "__syscall",    // TOK_syscall
        "__fastcall",   // TOK_fastcall
        "__interrupt",  // TOK_interrupt
        "__saveregs",   // TOK_saveregs
        "__self",               // TOK_self
        "__segment",    // TOK_segment
        "__segname(\""  // TOK_segnameLpQ

};
#endif  // !VERS_PWB


//      The operator mapping table

static  pcchar_t        __near  nameTable[]     =
{
        " new",
        " delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!=",
        "[]",

#if     VERS_P3
        "<UDC>",
#else   // } !VERS_P3 {
        "operator",
#endif  // VERS_P3

        "->",
        "*",
        "++",
        "--",
        "-",
        "+",
        "&",
        "->*",
        "/",
        "%",
        "<",
        "<=",
        ">",
        ">=",
        ",",
        "()",
        "~",
        "^",
        "|",
        "&&",
        "||",
        "*=",
        "+=",
        "-=",
        "/=",
        "%=",
        ">>=",
        "<<=",
        "&=",
        "|=",
        "^=",

#if     ( !NO_COMPILER_NAMES )
        "`vftable'",
        "`vbtable'",
        "`vcall",
        "`typeof'",
        "`local static guard",
        "`reserved'",
        "`vbase destructor'",
        "`vector deleting destructor'",
        "`default constructor closure'",
        "`scalar deleting destructor'",
        "`vector constructor iterator'",
        "`vector destructor iterator'",
        "`vector vbase constructor iterator'"
#endif  // !NO_COMPILER_NAMES

};



//      The following 'enum' should really be nested inside 'class DName', but to
//      make the code compile better with Glockenspiel, I have extracted it

enum    DNameStatus
{
        DN_valid,
        DN_invalid,
        DN_truncated,
        DN_error
};


class   DName
{
public:
                                        __near  DName ();
                                        __near  DName ( char );

#if     1
                                        __near  DName ( const DName & );                // Shallow copy
#endif

                                        __near  DName ( DNameNode * );
                                        __near  DName ( pcchar_t );
                                        __near  DName ( pcchar_t&, char );
                                        __near  DName ( DNameStatus );

#if     ( !VERS_P3 )
                                        __near  DName ( DName * );
                                        __near  DName ( unsigned long );
#endif  // !VERS_P3

                int                     __near  isValid () const;
                int                     __near  isEmpty () const;
                DNameStatus     __near  status () const;

#if     ( !VERS_P3 )
                DName &         __near  setPtrRef ();
                int                     __near  isPtrRef () const;
                int                     __near  isUDC () const;
                void            __near  setIsUDC ();
#endif  // !VERS_P3

                int                     __near  length () const;
                pchar_t         __near  getString ( pchar_t, int ) const;

                DName           __near  operator + ( pcchar_t ) const;
                DName           __near  operator + ( const DName & ) const;

#if     ( !VERS_P3 )
                DName           __near  operator + ( char ) const;
                DName           __near  operator + ( DName * ) const;
                DName           __near  operator + ( DNameStatus ) const;

                DName &         __near  operator += ( char );
                DName &         __near  operator += ( pcchar_t );
                DName &         __near  operator += ( DName * );
                DName &         __near  operator += ( DNameStatus );

                DName &         __near  operator |= ( const DName & );
#endif  // !VERS_P3

                DName &         __near  operator += ( const DName & );


                DName &         __near  operator = ( pcchar_t );
                DName &         __near  operator = ( const DName & );

#if     ( !VERS_P3 )
                DName &         __near  operator = ( char );
                DName &         __near  operator = ( DName * );
                DName &         __near  operator = ( DNameStatus );
#endif  // !VERS_P3

//      Friends :

friend  DName           __near __pascal operator + ( char, const DName & );
friend  DName           __near __pascal operator + ( pcchar_t, const DName & );

#if     ( !VERS_P3 )
friend  DName           __near __pascal operator + ( DNameStatus, const DName & );
#endif  // !VERS_P3

private:
                DNameNode *             node;

                DNameStatus             stat    : 4;
                unsigned int    isIndir : 1;
                unsigned int    isAUDC  : 1;

                void            __near  doPchar ( pcchar_t, int );

};



class   Replicator
{
private:
                //      Declare, in order to suppress automatic generation
                void                    operator = ( const Replicator& );

                int                             index;
                DName *                 dNameBuffer[ 10 ];
                const DName             ErrorDName;
                const DName             InvalidDName;

public:
                                                __near  Replicator ();

                int                             __near  isFull () const;

                Replicator &    __near  operator += ( const DName & );
                const DName &   __near  operator [] ( int ) const;

};



class   UnDecorator
{
private:
                //      Declare, in order to suppress automatic generation
                void                    operator = ( const UnDecorator& );

#if     ( !VERS_P3 )
                Replicator              ArgList;
static  Replicator *    pArgList;
#endif  // !VERS_P3

                Replicator              ZNameList;
static  Replicator *    pZNameList;

static  pcchar_t                gName;
static  pcchar_t                name;
static  pchar_t                 outputString;
static  int                             maxStringLength;

#if     (!NO_OPTIONS)
static  unsigned short  disableFlags;
#endif  // !NO_OPTIONS

static  DName   __near  getDecoratedName ( void );
static  DName   __near  getSymbolName ( void );
static  DName   __near  getZName ( void );
static  DName   __near  getOperatorName ( void );
static  DName   __near  getScope ( void );

#if     ( !VERS_P3 )
static  DName   __near  getDimension ( void );
static  int             __near  getNumberOfDimensions ( void );
static  DName   __near  getTemplateName ( void );
static  DName   __near  composeDeclaration ( const DName & );
static  int             __near  getTypeEncoding ( void );
static  DName   __near  getBasedType ( void );
static  DName   __near  getECSUName ( void );
static  DName   __near  getEnumName ( void );
static  DName   __near  getCallingConvention ( void );
static  DName   __near  getReturnType ( DName * = 0 );
static  DName   __near  getDataType ( DName * );
static  DName   __near  getPrimaryDataType ( const DName & );
static  DName   __near  getDataIndirectType ( const DName &, char, const DName &, int = FALSE );
static  DName   __near  getDataIndirectType ();
static  DName   __near  getBasicDataType ( const DName & );
static  DName   __near  getECSUDataType ( int = 0 );
static  int             __near  getECSUDataIndirectType ();
static  DName   __near  getPtrRefType ( const DName &, const DName &, int );
static  DName   __near  getPtrRefDataType ( const DName &, int );
static  DName   __near  getArrayType ( DName * );
static  DName   __near  getArgumentTypes ( void );
static  DName   __near  getArgumentList ( void );
static  DName   __near  getThrowTypes ( void );
static  DName   __near  getLexicalFrame ( void );
static  DName   __near  getStorageConvention ( void );
static  DName   __near  getThisType ( void );
static  DName   __near  getPointerType ( const DName &, const DName & );
static  DName   __near  getReferenceType ( const DName &, const DName & );
static  DName   __near  getExternalDataType ( const DName & );

#if     ( !VERS_PWB )
static  DName   __near  getSegmentName ( void );
#endif  // !VERS_PWB

#if     ( !NO_COMPILER_NAMES )
static  DName   __near  getDisplacement ( void );
static  DName   __near  getCallIndex ( void );
static  DName   __near  getGuardNumber ( void );
static  DName   __near  getVfTableType ( const DName & );
static  DName   __near  getVbTableType ( const DName & );
static  DName   __near  getVCallThunkType ( void );
#endif  // !NO_COMPILER_NAMES
#endif  // !VERS_P3

public:

#if     ( !NO_OPTIONS )
                                __near  UnDecorator ( pchar_t, pcchar_t, int, unsigned short );

static  int             __near  doUnderScore ();
static  int             __near  doMSKeywords ();
static  int             __near  doFunctionReturns ();
static  int             __near  doAllocationModel ();
static  int             __near  doAllocationLanguage ();

#if     0
static  int             __near  doMSThisType ();
static  int             __near  doCVThisType ();
#endif

static  int             __near  doThisTypes ();
static  int             __near  doAccessSpecifiers ();
static  int             __near  doThrowTypes ();
static  int             __near  doMemberTypes ();
static  int             __near  doReturnUDTModel ();
#else   // } elif NO_OPTIONS {
                                __near  UnDecorator ( pchar_t, pcchar_t, int );
#endif  // NO_OPTIONS

#if     ( !VERS_P3 && !VERS_PWB )
static  pcchar_t        __near  UScore ( Tokens );
#endif  // !VERS_P3 && !VERS_PWB

                                __near  operator pchar_t ();

};



#if     ( !VERS_P3 )
Replicator *    UnDecorator::pArgList;
#endif  // !VERS_P3

Replicator *    UnDecorator::pZNameList                 = 0;
pcchar_t                UnDecorator::gName                              = 0;
pcchar_t                UnDecorator::name                               = 0;
pchar_t                 UnDecorator::outputString               = 0;
int                             UnDecorator::maxStringLength    = 0;

#if     (!NO_OPTIONS)
unsigned short  UnDecorator::disableFlags               = 0;
#endif  // !NO_OPTIONS



pchar_t __far __cdecl __loadds  unDName (       pchar_t outputString,
                                                                                        pcchar_t name,
                                                                                        int maxStringLength     // Note, COMMA is leading following optional arguments

#if     ( !USE_CRT_HEAP )
                                                                                        ,Alloc_t pAlloc
                                                                                        ,Free_t pFree
#endif  // !USE_CRT_HEAP

#if     ( !NO_OPTIONS )
                                                                                        ,unsigned short disableFlags
#endif  // !NO_OPTIONS

                                                                                )
/*
 *      This function will undecorate a name, returning the string corresponding to
 *      the C++ declaration needed to produce the name.  Its has a similar interface
 *      to 'strncpy'.
 *
 *      If the target string 'outputString' is specified to be NULL, a string of
 *      suitable length will be allocated and its address returned.  If the returned
 *      string is allocated by 'unDName', then it is the programmers responsibility
 *      to deallocate it.  It will have been allocated on the far heap.
 *
 *      If the target string is not NULL, then the parameter 'maxStringLength' will
 *      specify the maximum number of characters which may be placed in the string.
 *      In this case, the returned value is the same as 'outputString'.
 *
 *      Both the input parameter 'name' and the returned string are NULL terminated
 *      strings of characters.
 *
 *      If the returned value is NULL, it indicates that the undecorator ran out of
 *      memory, or an internal error occurred, and was unable to complete its task.
 */

{
FTRACE(unDName);
#if     ( VERS_P3 && !STANDALONE )
        //      Abort if input is invalid

        if      ( !outputString || !name || !maxStringLength )
                return  0;
#endif  // ( VERS_P3 && !STANDALONE )

#if     ( !USE_CRT_HEAP )
        //      Must have an allocator and a deallocator (and we MUST trust them)

        if      ( !( pAlloc && pFree ))
                return  0;
        else
                heap.Constructor ( pAlloc, pFree );
#else   // } elif USE_CRT_HEAP {
                heap.Constructor ();
#endif  // USE_CRT_HEAP

        //      Create the undecorator object, and get the result

        UnDecorator     unDecorate (    outputString,
                                                                name,
                                                                maxStringLength
#if     ( !NO_OPTIONS )
                                                                ,disableFlags
#endif  // !NO_OPTIONS
                                                        );
        pchar_t         unDecoratedName = unDecorate;


        // Destruct the heap (would use a destructor, but that causes DLL problems)

        heap.Destructor ();

        //      And return the composed name

        return  unDecoratedName;

}       // End of FUNCTION "unDName"




//      The 'UnDecorator' member functions

inline  __near  UnDecorator::UnDecorator        (       pchar_t output,
                                                                                pcchar_t dName,
                                                                                int maxLen
#if     ( !NO_OPTIONS )
                                                                                ,unsigned short disable
#endif  // !NO_OPTIONS
                                                                        )
{
FTRACE(UnDecorator::UnDecorator);
#if     STDEBUG
        if      ( dName )
        {
                while   ( *dName == ' ' )
                        dName++;


                pchar_t s       = gnew char[ strlen ( dName ) + 1 ];


                if      ( name = s )
                        do
                        {
                                if      (( *s = *dName ) != ' ' )
                                        s++;
                        }       while   ( *dName++ );
        }
        else
                name    = 0;
#else   // } elif !STDEBUG {
        name                    = dName;
#endif  // !STDEBUG

        gName                   = name;
        maxStringLength = maxLen;
        outputString    = output;
        pZNameList              = &ZNameList;

#if     ( !VERS_P3 )
        pArgList                = &ArgList;
#endif  // !VERS_P3

#if     ( !NO_OPTIONS )
        disableFlags    = disable;
#endif  // !NO_OPTIONS

}       // End of "UnDecorator" CONSTRUCTOR '()'


inline  __near  UnDecorator::operator pchar_t ()
{
FTRACE(UnDecorator::pchar_t);
        DName           result;
        DName           unDName;


        //      Find out if the name is a decorated name or not.  Could be a reserved
        //      CodeView variant of a decorated name

        if      ( name )
        {
                if      (( *name == '?' ) && ( name[ 1 ] == '@' ))
                {
#if     ( !NO_COMPILER_NAMES )
                        gName   += 2;
                        result  = "CV: " + getDecoratedName ();
#else   // } elif NO_COMPILER_NAMES
                        result  = DN_invalid;
#endif  // NO_COMPILER_NAMES

                }       // End of IF then
                else
                        result  = getDecoratedName ();

        }       // End of IF then

        //      If the name was not a valid name, then make the name the same as the original
        //      It is also invalid if there are any remaining characters in the name

        if              ( result.status () == DN_error )
                return  0;

#if     ( !VERS_P3 )
        elif    ( *gName || ( result.status () == DN_invalid ))
                unDName = name; // Return the original name
#else   // } elif VERS_P3 {
        elif    ( !*gName || ( *gName != '@' ) || ( result.status () == DN_invalid ))
                unDName = "";   // Blank
#endif  // VERS_P3

        else
                unDName = result;

#if     ( !VERS_P3 || STANDALONE )
        //      Construct the return string

        if      ( !outputString )
        {
                maxStringLength = unDName.length () + 1;
                outputString    = rnew char[ maxStringLength ];

        }       // End of IF

        if      ( outputString )
#endif  // ( !VERS_P3 || STANDALONE )

                unDName.getString ( outputString, maxStringLength );

        //      Return the result

        return  outputString;

}       // End of "UnDecorator" OPERATOR 'pchar_t'



DName   __near  UnDecorator::getDecoratedName ( void )
{
FTRACE(getDecoratedName);
        //      Ensure that it is intended to be a decorated name

        if              ( *gName == '?' )
        {
                //      Extract the basic symbol name

                gName++;        // Advance the original name pointer


                DName   symbolName      = getSymbolName ();

#if     ( !VERS_P3 )
                int             udcSeen         = symbolName.isUDC ();
#endif  // !VERS_P3

                //      Abort if the symbol name is invalid

                if      ( !symbolName.isValid ())
                        return  symbolName;

                //      Extract, and prefix the scope qualifiers

                if      ( *gName && ( *gName != '@' ))
                        symbolName      = getScope () + "::" + symbolName;

#if     ( !VERS_P3 )
                if      ( udcSeen )
                        symbolName.setIsUDC ();

                //      Now compose declaration

                if      ( symbolName.isEmpty ())
                        return  symbolName;
                elif    ( !*gName || ( *gName == '@' ))
                {
                        if      ( *gName )
                                gName++;

                        return  composeDeclaration ( symbolName );

                }       // End of ELIF then
                else
                        return  DN_invalid;
#else   // } elif VERS_P3 {
                return  symbolName;
#endif  // VERS_P3

        }       // End of IF then
        elif    ( *gName )
                return  DN_invalid;
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getDecoratedName"



inline  DName   __near  UnDecorator::getSymbolName ( void )
{
FTRACE(getSymbolName);
        if      ( *gName == '?' )
        {
                gName++;

                return  getOperatorName ();

        }       // End of IF then
        else
                return  getZName ();

}       // End of "UnDecorator" FUNCTION "getSymbolName"



DName   __near  UnDecorator::getZName ( void )
{
FTRACE(getZName);
        int             zNameIndex      = *gName - '0';


        //      Handle 'zname-replicators', otherwise an actual name

        if      (( zNameIndex >= 0 ) && ( zNameIndex <= 9 ))
        {
                gName++;        // Skip past the replicator

                //      And return the indexed name

                return  ( *pZNameList )[ zNameIndex ];

        }       // End of IF then
        else
        {
                //      Extract the 'zname' to the terminator

                DName   zName ( gName, '@' );   // This constructor updates 'name'


                //      Add it to the current list of 'zname's

                if      ( !pZNameList->isFull ())
                        *pZNameList     += zName;

                //      And return the symbol name
                return  zName;

        }       // End of IF else
}       // End of "UnDecorator" FUNCTION "getZName"



inline  DName   __near  UnDecorator::getOperatorName ( void )
{
FTRACE(getOperatorName);
        DName   operatorName;

#if     ( !VERS_P3 )
        int             udcSeen = FALSE;
#endif  // VERS_P3

        //      So what type of operator is it ?

        switch  ( *gName++ )
        {
        case 0:
                gName--;                // End of string, better back-track

                return  DN_truncated;

        case OC_ctor:
        case OC_dtor:   // The constructor and destructor are special
                {
                        //      Use a temporary.  Don't want to advance the name pointer

                        pcchar_t        pName   = gName;


                        operatorName    = getZName ();
                        gName                   = pName;

                        if      ( !operatorName.isEmpty () && ( gName[ -1 ] == OC_dtor ))
                                operatorName    = '~' + operatorName;

                        return  operatorName;

                }       // End of CASE 'OC_ctor,OC_dtor'
                break;

        case OC_new:
        case OC_delete:
        case OC_assign:
        case OC_rshift:
        case OC_lshift:
        case OC_not:
        case OC_equal:
        case OC_unequal:
                        operatorName    = nameTable[ gName[ -1 ] - OC_new ];
                break;

        case OC_udc:

#if     ( !VERS_P3 )
                        udcSeen = TRUE;
#endif  // !VERS_P3

                //      No break

        case OC_index:
        case OC_pointer:
        case OC_star:
        case OC_incr:
        case OC_decr:
        case OC_minus:
        case OC_plus:
        case OC_amper:
        case OC_ptrmem:
        case OC_divide:
        case OC_modulo:
        case OC_less:
        case OC_leq:
        case OC_greater:
        case OC_geq:
        case OC_comma:
        case OC_call:
        case OC_compl:
        case OC_xor:
        case OC_or:
        case OC_land:
        case OC_lor:
        case OC_asmul:
        case OC_asadd:
        case OC_assub:                  // Regular operators from the first group
                        operatorName    = nameTable[ gName[ -1 ] - OC_index + ( OC_unequal - OC_new + 1 )];
                break;

        case '_':
                        switch  ( *gName++ )
                        {
                        case 0:
                                gName--;                // End of string, better back-track

                                return  DN_truncated;

                        case OC_asdiv:
                        case OC_asmod:
                        case OC_asrshift:
                        case OC_aslshift:
                        case OC_asand:
                        case OC_asor:
                        case OC_asxor:  // Regular operators from the extended group
                                        operatorName    = nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
                                break;

#if     ( !NO_COMPILER_NAMES )
                        case OC_vftable:
                        case OC_vbtable:
                        case OC_vcall:
                                return  nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

                        case OC_metatype:
                        case OC_guard:
                        case OC_uctor:
                        case OC_udtor:
                        case OC_vdeldtor:
                        case OC_defctor:
                        case OC_sdeldtor:
                        case OC_vctor:
                        case OC_vdtor:
                        case OC_vallctor:       // Special purpose names
                                return  nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
#endif  // !NO_COMPILER_NAMES

                        default:
                                return  DN_invalid;

                        }       // End of SWITCH
                break;

        default:
                return  DN_invalid;

        }       // End of SWITCH

#if     ( !VERS_P3 )
        //      This really is an operator name, so prefix it with 'operator'

        if      ( udcSeen )
                operatorName.setIsUDC ();
        elif    ( !operatorName.isEmpty ())
#endif  // !VERS_P3
                operatorName    = "operator" + operatorName;

        return  operatorName;

}       // End of "UnDecorator" FUNCTION "getOperatorName"



DName   __near  UnDecorator::getScope ( void )
{
FTRACE(getScope);
        int             first   = TRUE;
        DName   scope;


        //      Get the list of scopes

        while   (( scope.status () == DN_valid ) && *gName && ( *gName != '@' ))
        {       //      Insert the scope operator if not the first scope

                if      ( first )
                        first   = FALSE;
                else
                        scope   = "::" + scope;

                //      Determine what kind of scope it is

                if      ( *gName == '?' )

#if     ( !VERS_P3 )
                        switch  ( *++gName )
                        {
                        case '?':
                                        scope   = '`' + getDecoratedName () + '\'' + scope;
                                break;

                        case '$':
#if     ( !VERS_PWB )
                                        gName++;
                                        scope   = getTemplateName () + scope;
                                break;
#else   // } elif VERS_PWB {
                                return  DN_invalid;
#endif  // VERS_PWB

                        default:
                                        scope   = getLexicalFrame () + scope;
                                break;

                        }       // End of SWITCH
#else   // } elif VERS_P3 {
                        return  DN_invalid;
#endif  // VERS_P3

                else
                        scope   = getZName () + scope;

        }       // End of WHILE

        //      Catch error conditions

        switch  ( *gName )
        {
        case 0:
                        if      ( first )
                                scope   = DN_truncated;
                        else
                                scope   = DName ( DN_truncated ) + "::" + scope;
                break;

        case '@':               // '@' expected to end the scope list
                break;

        default:
                        scope   = DN_invalid;
                break;

        }       // End of SWITCH

        //      Return the composed scope

        return  scope;

}       // End of "UnDecorator" FUNCTION "getScope"



#if     ( !VERS_P3 )
DName   __near  UnDecorator::getDimension ( void )
{
FTRACE(getDimension);
        if              ( !*gName )
                return  DN_truncated;
        elif    (( *gName >= '0' ) && ( *gName <= '9' ))
                return  DName ((unsigned long)( *gName++ - '0' + 1 ));
        else
        {
                unsigned long   dim     = 0L;


                //      Don't bother detecting overflow, it's not worth it

                while   ( *gName != '@' )
                {
                        if              ( !*gName )
                                return  DN_truncated;
                        elif    (( *gName >= 'A' ) && ( *gName <= 'P' ))
                                dim     = ( dim << 4 ) + ( *gName - 'A' );
                        else
                                return  DN_invalid;

                        gName++;

                }       // End of WHILE

                //      Ensure integrity, and return

                if      ( *gName++ != '@' )
                        return  DN_invalid;             // Should never get here

                return  dim;

        }       // End of ELIF else
}       // End of "UnDecorator" FUNCTION "getDimension"


inline_pwb      int     __near  UnDecorator::getNumberOfDimensions ( void )
{
FTRACE(getNumberOfDimensions);
        if              ( !*gName )
                return  0;
        elif    (( *gName >= '0' ) && ( *gName <= '9' ))
                return  (( *gName++ - '0' ) + 1 );
        else
        {
                int     dim     = 0;


                //      Don't bother detecting overflow, it's not worth it

                while   ( *gName != '@' )
                {
                        if              ( !*gName )
                                return  0;
                        elif    (( *gName >= 'A' ) && ( *gName <= 'P' ))
                                dim     = ( dim << 4 ) + ( *gName - 'A' );
                        else
                                return  -1;

                        gName++;

                }       // End of WHILE

                //      Ensure integrity, and return

                if      ( *gName++ != '@' )
                        return  -1;             // Should never get here

                return  dim;

        }       // End of ELIF else
}       // End of "UnDecorator" FUNCTION "getNumberOfDimensions"


#if     ( !VERS_PWB )
DName   __near  UnDecorator::getTemplateName ( void )
{
FTRACE(getTemplateName);
        DName   templateName    = "template " + getZName ();


        if      ( !templateName.isEmpty ())
                templateName    += '<' + getArgumentList () + '>';

        //      Return the completed 'template-name'

        return  templateName;

}       // End of "UnDecorator" FUNCTION "getTemplateName"
#endif  // !VERS_PWB


#if defined(COFF)
//inline        DName   __near  UnDecorator::composeDeclaration ( const DName & symbol )
//
// The above line was replaced by the line below because the COFF linker
// can't handle COMDATs
//
DName   __near  UnDecorator::composeDeclaration ( const DName & symbol )
#else
inline  DName   __near  UnDecorator::composeDeclaration ( const DName & symbol )
#endif
{
FTRACE(composeDeclaration);
        DName                   declaration;
        unsigned int    typeCode        = getTypeEncoding ();
        int                             symIsUDC        = symbol.isUDC ();


        //      Handle bad typeCode's, or truncation

        if              ( TE_isbadtype ( typeCode ))
                return  DN_invalid;
        elif    ( TE_istruncated ( typeCode ))
                return  ( DN_truncated + symbol );

        //      This is a very complex part.  The type of the declaration must be
        //      determined, and the exact composition must be dictated by this type.

        //      Is it any type of a function ?
        //      However, for ease of decoding, treat the 'localdtor' thunk as data, since
        //      its decoration is a function of the variable to which it belongs and not
        //      a usual function type of decoration.

#if     ( NO_COMPILER_NAMES )
        if      ( TE_isthunk ( typeCode ))
                return  DN_invalid;

        if      ( TE_isfunction ( typeCode ))
#else   // } elif !NO_COMPILER_NAMES {
        if      ( TE_isfunction ( typeCode ) && !( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode )))
#endif  // !NO_COMPILER_NAMES

        {
                //      If it is based, then compose the 'based' prefix for the name

                if      ( TE_isbased ( typeCode ))
#if     ( !VERS_PWB )
                        if      ( doMSKeywords () && doAllocationModel ())
                                declaration     = ' ' + getBasedType ();
                        else
#endif  // !VERS_PWB
                                declaration     |= getBasedType ();     // Just lose the 'based-type'

#if     ( !NO_COMPILER_NAMES )
                //      Check for some of the specially composed 'thunk's

                if      ( TE_isthunk ( typeCode ) && TE_isvcall ( typeCode ))
                {
                        declaration     += symbol + '{' + getCallIndex () + ',';
                        declaration     += getVCallThunkType () + "}' ";

                }       // End of IF then
                else
#endif  // !NO_COMPILER_NAMES
                {
                        DName   vtorDisp;
                        DName   adjustment;
                        DName   thisType;

#if     ( !NO_COMPILER_NAMES )
                        if      ( TE_isthunk ( typeCode ))
                        {
                                if      ( TE_isvtoradj ( typeCode ))
                                        vtorDisp        = getDisplacement ();

                                adjustment      = getDisplacement ();

                        }       // End of IF else
#endif  // !NO_COMPILER_NAMES

                        //      Get the 'this-type' for non-static function members

                        if      ( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
#if     ( !VERS_PWB )
                                if      ( doThisTypes ())
                                        thisType        = getThisType ();
                                else
#endif  // !VERS_PWB
                                        thisType        |= getThisType ();

#if     ( !VERS_PWB )
                        if      ( doMSKeywords ())
                        {
                                //      Attach the calling convention

                                if      ( doAllocationLanguage ())
                                        declaration     = getCallingConvention () + declaration;        // What calling convention ?
                                else
                                        declaration     |= getCallingConvention ();     // Just lose the 'calling-convention'

                                //      Any model specifiers ?

                                if      ( doAllocationModel ())
                                        if              ( TE_isnear ( typeCode ))
                                                declaration     = UScore ( TOK_nearSp ) + declaration;
                                        elif    ( TE_isfar ( typeCode ))
                                                declaration     = UScore ( TOK_farSp ) + declaration;

                        }       // End of IF
                        else
#endif  // !VERS_PWB
                                declaration     |= getCallingConvention ();     // Just lose the 'calling-convention'

                        //      Now put them all together

                        if      ( !symbol.isEmpty ())
                                if      ( !declaration.isEmpty ())                      // And the symbol name
                                        declaration     += ' ' + symbol;
                                else
                                        declaration     = symbol;


                        //      Compose the return type, catching the UDC case

                        DName * pDeclarator     = 0;
                        DName   returnType;


                        if      ( symIsUDC )            // Is the symbol a UDC operator ?
                                declaration     += "`" + getReturnType () + "' ";
                        else
                        {
                                pDeclarator     = gnew DName;
                                returnType      = getReturnType ( pDeclarator );

                        }       // End of IF else

#if     ( !NO_COMPILER_NAMES )
                        //      Add the displacements for virtual function thunks

                        if      ( TE_isthunk ( typeCode ))
                        {
                                if      ( TE_isvtoradj ( typeCode ))
                                        declaration     += "`vtordisp{" + vtorDisp + ',';
                                else
                                        declaration     += "`adjustor{";

                                declaration     += adjustment + "}' ";

                        }       // End of IF
#endif  // !NO_COMPILER_NAMES

                        //      Add the function argument prototype

                        declaration     += '(' + getArgumentTypes () + ')';

                        //      If this is a non-static member function, append the 'this' modifiers

                        if      ( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
                                declaration     += thisType;

                        //      Add the 'throw' signature
#if     ( !VERS_PWB )
                        if      ( doThrowTypes ())
                                declaration     += getThrowTypes ();
                        else
#endif  // !VERS_PWB
                                declaration     |= getThrowTypes ();    // Just lose the 'throw-types'

#if     ( !VERS_PWB )
                        //      If it has a declarator, then insert it into the declaration,
                        //      sensitive to the return type composition

                        if      ( doFunctionReturns () && pDeclarator )
                        {
                                *pDeclarator    = declaration;
                                declaration             = returnType;

                        }       // End of IF
#endif  // !VERS_PWB
                }       // End of IF else
        }       // End of IF then
        else
        {
                declaration     += symbol;

                //      Catch the special handling cases

#if     ( !NO_COMPILER_NAMES )
                if              ( TE_isvftable ( typeCode ))
                        return  getVfTableType ( declaration );
                elif    ( TE_isvbtable ( typeCode ))
                        return  getVbTableType ( declaration );
                elif    ( TE_isguard ( typeCode ))
                        return  ( declaration + '{' + getGuardNumber () + "}'" );
                elif    ( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode ))
                        declaration     += "`local static destructor helper'";
                elif    ( TE_ismetaclass ( typeCode ))
#pragma message ( "NYI:  Meta Class" )
#else   // } elif NO_COMPILER_NAMES {
                if      ( TE_isvftable ( typeCode )
                                || TE_isvbtable ( typeCode )
                                || TE_isguard ( typeCode )
                                || TE_ismetaclass ( typeCode ))
#endif  // NO_COMPILER_NAMES
                        return  DN_invalid;

                //      All others are decorated as data symbols

                declaration     = getExternalDataType ( declaration );

        }       // End of IF else

#if     ( !VERS_PWB )
        //      Prepend the 'virtual' and 'static' attributes for members

        if      ( TE_ismember ( typeCode ))
        {
                if      ( doMemberTypes ())
                {
                        if      ( TE_isstatic ( typeCode ))
                                declaration     = "static " + declaration;

                        if      ( TE_isvirtual ( typeCode ) || ( TE_isthunk ( typeCode ) && ( TE_isvtoradj ( typeCode ) || TE_isadjustor ( typeCode ))))
                                declaration     = "virtual " + declaration;

                }       // End of IF

                //      Prepend the access specifiers

                if      ( doAccessSpecifiers ())
                        if              ( TE_isprivate ( typeCode ))
                                declaration     = "private: " + declaration;
                        elif    ( TE_isprotected ( typeCode ))
                                declaration     = "protected: " + declaration;
                        elif    ( TE_ispublic ( typeCode ))
                                declaration     = "public: " + declaration;

        }       // End of IF
#endif  // !VERS_PWB

#if     ( !NO_COMPILER_NAMES )
        //      If it is a thunk, mark it appropriately

        if      ( TE_isthunk ( typeCode ))
                declaration     = "[thunk]:" + declaration;
#endif  // !NO_COMPILER_NAMES

        //      Return the composed declaration

        return  declaration;

}       // End of "UnDecorator" FUNCTION "composeDeclaration"


inline  int             __near  UnDecorator::getTypeEncoding ( void )
{
FTRACE(getTypeEncoding);
        unsigned int    typeCode        = 0u;


        //      Strip any leading '_' which indicates that it is based

        if      ( *gName == '_' )
        {
                TE_setisbased ( typeCode );

                gName++;

        }       // End of IF

        //      Now handle the code proper :-

        if              (( *gName >= 'A' ) && ( *gName <= 'Z' ))        // Is it some sort of function ?
        {
                int     code    = *gName++ - 'A';


                //      Now determine the function type

                TE_setisfunction ( typeCode );  // All of them are functions ?

                //      Determine the calling model

                if      ( code & TE_far )
                        TE_setisfar ( typeCode );
                else
                        TE_setisnear ( typeCode );

                //      Is it a member function or not ?

                if      ( code < TE_external )
                {
                        //      Record the fact that it is a member

                        TE_setismember ( typeCode );

                        //      What access permissions does it have

                        switch  ( code & TE_access )
                        {
                        case TE_private:
                                        TE_setisprivate ( typeCode );
                                break;

                        case TE_protect:
                                        TE_setisprotected ( typeCode );
                                break;

                        case TE_public:
                                        TE_setispublic ( typeCode );
                                break;

                        default:
                                        TE_setisbadtype ( typeCode );
                                        return  typeCode;

                        }       // End of SWITCH

                        //      What type of a member function is it ?

                        switch  ( code & TE_adjustor )
                        {
                        case TE_adjustor:
                                        TE_setisadjustor ( typeCode );
                                break;

                        case TE_virtual:
                                        TE_setisvirtual ( typeCode );
                                break;

                        case TE_static:
                                        TE_setisstatic ( typeCode );
                                break;

                        case TE_member:
                                break;

                        default:
                                        TE_setisbadtype ( typeCode );
                                        return  typeCode;

                        }       // End of SWITCH
                }       // End of IF
        }       // End of IF then
        elif    ( *gName == '$' )       // Extended set ?  Special handling
        {
                //      What type of symbol is it ?

                switch  ( *( ++gName ))
                {
                case 'A':       // A destructor helper for a local static ?
                                TE_setislocaldtor ( typeCode );
                        break;

                case 'B':       // A VCall-thunk ?
                                TE_setisvcall ( typeCode );
                        break;

                case 0:
                                TE_setistruncated ( typeCode );
                        break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':       // Construction displacement adjustor thunks
                        {
                                int     code    = *gName - '0';


                                //      Set up the principal type information

                                TE_setisfunction ( typeCode );
                                TE_setismember ( typeCode );
                                TE_setisvtoradj ( typeCode );

                                //      Is it 'near' or 'far' ?

                                if      ( code & TE_far )
                                        TE_setisfar ( typeCode );
                                else
                                        TE_setisnear ( typeCode );

                                //      What type of access protection ?

                                switch  ( code & TE_access_vadj )
                                {
                                case TE_private_vadj:
                                                TE_setisprivate ( typeCode );
                                        break;

                                case TE_protect_vadj:
                                                TE_setisprotected ( typeCode );
                                        break;

                                case TE_public_vadj:
                                                TE_setispublic ( typeCode );
                                        break;

                                default:
                                                TE_setisbadtype ( typeCode );
                                                return  typeCode;

                                }       // End of SWITCH
                        }       // End of CASE '0,1,2,3,4,5'
                        break;

                default:
                                TE_setisbadtype ( typeCode );
                                return  typeCode;

                }       // End of SWITCH

                //      Advance past the code character

                gName++;

        }       // End of ELIF then
        elif    (( *gName >= TE_static_d ) && ( *gName <= TE_metatype ))        // Non function decorations ?
        {
                int     code    = *gName++;


                TE_setisdata ( typeCode );

                //      What type of symbol is it ?

                switch  ( code )
                {
                case ( TE_static_d | TE_private_d ):
                                TE_setisstatic ( typeCode );
                                TE_setisprivate ( typeCode );
                        break;

                case ( TE_static_d | TE_protect_d ):
                                TE_setisstatic ( typeCode );
                                TE_setisprotected ( typeCode );
                        break;

                case ( TE_static_d | TE_public_d ):
                                TE_setisstatic ( typeCode );
                                TE_setispublic ( typeCode );
                        break;

                case TE_global:
                                TE_setisglobal ( typeCode );
                        break;

#if     ( !VERS_PWB )
                case TE_guard:
                                TE_setisguard ( typeCode );
                        break;

                case TE_local:
                                TE_setislocal ( typeCode );
                        break;

                case TE_vftable:
                                TE_setisvftable ( typeCode );
                        break;

                case TE_vbtable:
                                TE_setisvbtable ( typeCode );
                        break;

                case TE_metatype:
#pragma message ( "NYI:  MetaClass Information" )
#else   // } elif VERS_PWB {
                case TE_guard:
                case TE_local:
                case TE_vftable:
                case TE_vbtable:
                case TE_metatype:
#endif  // VERS_PWB

                default:
                                TE_setisbadtype ( typeCode );

                                return  typeCode;

                }       // End of SWITCH
        }       // End of ELIF then
        elif    ( *gName )
                TE_setisbadtype ( typeCode );
        else
                TE_setistruncated ( typeCode );

        //      Return the composed type code

        return  typeCode;

}       // End of "UnDecorator" FUNCTION "getTypeEncoding"



DName   __near  UnDecorator::getBasedType ( void )
{
FTRACE(getBasedType);
#if     ( !VERS_PWB )
        DName   basedDecl ( UScore ( TOK_basedLp ));
#else   // } elif VERS_PWB {
        DName   basedDecl;
#endif  // VERS_PWB

        //      What type of 'based' is it ?

        if      ( *gName )
        {
                switch  ( *gName++ )
                {
#if     ( !VERS_PWB )
                case BT_segname:
                                basedDecl       += UScore ( TOK_segnameLpQ ) + getSegmentName () + "\")";
                        break;

                case BT_segment:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_segment );
                        break;

                case BT_void:
                                basedDecl       += "void";
                        break;

                case BT_self:
                                basedDecl       += UScore ( TOK_self );
                        break;

                case BT_nearptr:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_nearP );
                        break;

                case BT_farptr:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_farP );
                        break;

                case BT_hugeptr:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_hugeP );
                        break;

                case BT_segaddr:
                                basedDecl       += "NYI:<segment-address-of-variable>";
                        break;
#else   // } elif VERS_PWB {
                case BT_segname:
                                basedDecl       |= getZName ();
                        break;

                case BT_segment:
                case BT_void:
                case BT_self:
                case BT_nearptr:
                case BT_farptr:
                case BT_hugeptr:
                case BT_segaddr:
                        break;
#endif  // VERS_PWB

                case BT_basedptr:
#pragma message ( "NOTE: Reserved.  Based pointer to based pointer" )
                                return  DN_invalid;

                }       // End of SWITCH
        }       // End of IF else
        else
                basedDecl       += DN_truncated;

#if     ( !VERS_PWB )
        //      Close the based syntax

        basedDecl       += ") ";
#endif  // !VERS_PWB

        //      Return completed based declaration

        return  basedDecl;

}       // End of "UnDecorator" FUNCTION "getBasedType"



DName   __near  UnDecorator::getECSUName ( void )
{
FTRACE(getECSUName);
        DName   ecsuName;


        //      Get the beginning of the name

        if      ( *gName == '?' )
        {
#if     ( !VERS_PWB )
                gName++;
                ecsuName        = getTemplateName ();
#else   // } elif VERS_PWB {
                return  DN_invalid;
#endif  // VERS_PWB

        }       // End of IF then
        else
                ecsuName        = getZName ();

        //      Now the scope (if any)

        if      (( ecsuName.status () == DN_valid ) && *gName && ( *gName != '@' ))
                ecsuName        = getScope () + "::" + ecsuName;

        //      Skip the trailing '@'

        if              ( *gName == '@' )
                gName++;
        elif    ( *gName )
                ecsuName        = DN_invalid;
        elif    ( ecsuName.isEmpty ())
                ecsuName        = DN_truncated;
        else
                ecsuName        = DName ( DN_truncated ) + "::" + ecsuName;

        //      And return the complete name

        return  ecsuName;

}       // End of "UnDecorator" FUNCTION "getECSUName"


inline  DName   __near  UnDecorator::getEnumName ( void )
{
FTRACE(getEnumName);
#if     ( !VERS_PWB )
        DName   ecsuName;
#endif  // !VERS_PWB

        if      ( *gName )
        {
#if     ( !VERS_PWB )
                //      What type of an 'enum' is it ?

                switch  ( *gName )
                {
                case ET_schar:
                case ET_uchar:
                                ecsuName        = "char ";
                        break;

                case ET_sshort:
                case ET_ushort:
                                ecsuName        = "short ";
                        break;

                case ET_sint:
                        break;

                case ET_uint:
                                ecsuName        = "int ";
                        break;

                case ET_slong:
                case ET_ulong:
                                ecsuName        = "long ";
                        break;

                default:
                        return  DN_invalid;

                }       // End of SWITCH

                //      Add the 'unsigned'ness if appropriate

                switch  ( *gName++ )
                {
                case ET_uchar:
                case ET_ushort:
                case ET_uint:
                case ET_ulong:
                                ecsuName        = "unsigned " + ecsuName;
                        break;

                }       // End of SWITCH

                //      Now return the composed name

                return  ecsuName + getECSUName ();
#else   // } elif VERS_PWB {
                if      ( *gName++ == ET_sint )
                        return  getECSUName ();
                else
                        return  DN_invalid;
#endif  // VERS_PWB

        }       // End of IF then
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getEnumName"



DName   __near  UnDecorator::getCallingConvention ( void )
{
FTRACE(getCallingConvention);
        if      ( *gName )
        {
                unsigned int    callCode        = ((unsigned int)*gName++ ) - 'A';


                //      What is the primary calling convention

                if      (( callCode <= CC_interrupt ))
                {
#if     ( !VERS_PWB )
                        DName   callType;


                        //      Now, what type of 'calling-convention' is it, 'interrupt' is special ?

                        if      ( doMSKeywords ())
                                if      ( callCode == CC_interrupt )
                                        callType        = UScore ( TOK_interrupt );
                                else
                                {
                                        switch  ( callCode & ~CC_saveregs )
                                        {
                                        case CC_cdecl:
                                                        callType        = UScore ( TOK_cdecl );
                                                break;

                                        case CC_pascal:
                                                        callType        = UScore ( TOK_pascal );
                                                break;

                                        case CC_syscall:
                                                        callType        = UScore ( TOK_syscall );
                                                break;

                                        case CC_stdcall:
                                                        callType        = UScore ( TOK_stdcall );
                                                break;

                                        case CC_fastcall:
                                                        callType        = UScore ( TOK_fastcall );
                                                break;

                                        }       // End of SWITCH

                                        //      Has it also got 'saveregs' marked ?

                                        if      ( callCode & CC_saveregs )
                                                callType        += ' ' + UScore ( TOK_saveregs );

                                }       // End of IF else

                        //      And return

                        return  callType;
#else   // } elif VERS_PWB {
                        return  DN_valid;
#endif  // VERS_PWB

                }       // End of IF then
                else
                        return  DN_invalid;

        }       // End of IF then
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getCallingConvention"



DName   __near  UnDecorator::getReturnType ( DName * pDeclarator )
{
FTRACE(getReturnType);
        if      ( *gName == '@' )       // Return type for constructors and destructors ?
        {
                gName++;

                return  DName ( pDeclarator );

        }       // End of IF then
        else
                return  getDataType ( pDeclarator );

}       // End of "UnDecorator" FUNCTION "getReturnType"



DName   __near  UnDecorator::getDataType ( DName * pDeclarator )
{
FTRACE(getDataType);
        DName   superType ( pDeclarator );


        //      What type is it ?

        switch  ( *gName )
        {
        case 0:
                        return  ( DN_truncated + superType );

        case DT_void:
                        gName++;

                        if      ( superType.isEmpty ())
                                return  "void";
                        else
                                return  "void " + superType;

        case '?':
                {
                        int     ecsuMods;


                        gName++;        // Skip the '?'

                        ecsuMods        = getECSUDataIndirectType ();
                        superType       = getECSUDataType ( ecsuMods ) + ' ' + superType;

                        return  superType;

                }       // End of CASE '?'

        default:
                        return  getPrimaryDataType ( superType );

        }       // End of SWITCH
}       // End of "UnDecorator" FUNCTION "getDataType"



DName   __near  UnDecorator::getPrimaryDataType ( const DName & superType )
{
FTRACE(getPrimaryDataType);
        DName   cvType;


        switch  ( *gName )
        {
        case 0:
                        return  ( DN_truncated + superType );

        case PDT_volatileReference:
                        cvType  = "volatile";

                        if      ( !superType.isEmpty ())
                                cvType  += ' ';

                // No break

        case PDT_reference:
                {
                        DName   super ( superType );


                        gName++;

                        return  getReferenceType ( cvType, super.setPtrRef ());

                }       // End of CASE 'PDT_reference'

        default:
                        return  getBasicDataType ( superType );

        }       // End of SWITCH
}       // End of "UnDecorator" FUNCTION "getPrimaryDataType"



DName   __near  UnDecorator::getArgumentTypes ( void )
{
FTRACE(getArgumentTypes);
        switch  ( *gName )
        {
        case AT_ellipsis:
                        return  ( gName++, "..." );

        case AT_void:
#if     ( !VERS_PWB )
                        return  ( gName++, "void" );
#else   // } elif VERS_PWB {
                        return  ( gName++, DName ());
#endif  // VERS_PWB

        default:
                {
                        DName   arguments ( getArgumentList ());


                        //      Now, is it a varargs function or not ?

                        if      ( arguments.status () == DN_valid )
                                switch  ( *gName )
                                {
                                case 0:
                                                return  arguments;

                                case AT_ellipsis:
                                                return  ( gName++, arguments + ",..." );

                                case AT_endoflist:
                                                return  ( gName++, arguments );

                                default:
                                                return  DN_invalid;

                                }       // End of SWITCH
                        else
                                return  arguments;

                }       // End of DEFAULT
        }       // End of SWITCH
}       // End of "UnDecorator" FUNCTION "getArgumentTypes"


inline_pwb      DName   __near  UnDecorator::getArgumentList ( void )
{
FTRACE(getArgumentList);
        int             first   = TRUE;
        DName   aList;


        while   (( aList.status () == DN_valid ) && ( *gName != AT_endoflist ) && ( *gName != AT_ellipsis ))
        {
                //      Insert the argument list separator if not the first argument

                if      ( first )
                        first   = FALSE;
                else
                        aList   += ',';


                //      Get the individual argument type

                if      ( *gName )
                {
                        int             argIndex        = *gName - '0';


                        //      Handle 'argument-replicators', otherwise a new argument type

                        if      (( argIndex >= 0 ) && ( argIndex <= 9 ))
                        {
                                gName++;        // Skip past the replicator

                                //      Append to the argument list

                                aList   += ( *pArgList )[ argIndex ];

                        }       // End of IF then
                        else
                        {
                                //      Extract the 'argument' type

                                DName   arg ( getPrimaryDataType ( DName ()));


                                //      Add it to the current list of 'argument's

                                if      ( !pArgList->isFull ())
                                        *pArgList       += arg;

                                //      Append to the argument list

                                aList   += arg;

                        }       // End of IF else
                }       // End of IF then
                else
                {
                        aList   += DN_truncated;

                        break;

                }       // End of IF else
        }       // End of WHILE

        //      Return the completed argument list

        return  aList;

}       // End of "UnDecorator" FUNCTION "getArgumentList"



DName   __near  UnDecorator::getThrowTypes ( void )
{
FTRACE(getThrowTypes);
        if      ( *gName )
#if     ( !VERS_PWB )
                if      ( *gName == AT_ellipsis )       // Handle ellipsis here to suppress the 'throw' signature
                        return  ( gName++, DName ());
                else
                        return  ( " throw(" + getArgumentTypes () + ')' );
        else
                return  ( DName ( " throw(" ) + DN_truncated + ')' );
#else   // } elif VERS_PWB {
                if      ( *gName++ == AT_ellipsis )
                        return  DName ();
                else
                        return  DN_invalid;
        else
                return  DN_truncated;
#endif  // VERS_PWB

}       // End of "UnDecorator" FUNCTION "getThrowTypes"



DName   __near  UnDecorator::getBasicDataType ( const DName & superType )
{
FTRACE(getBasicDataType);
        if      ( *gName )
        {
                unsigned char   bdtCode = *gName++;
                int                             pCvCode = -1;
                DName                   basicDataType;


                //      Extract the principal type information itself, and validate the codes

                switch  ( bdtCode )
                {
                case BDT_schar:
                case BDT_char:
                case ( BDT_char   | BDT_unsigned ):
                                basicDataType   = "char";
                        break;

                case BDT_short:
                case ( BDT_short  | BDT_unsigned ):
                                basicDataType   = "short";
                        break;

                case BDT_int:
                case ( BDT_int    | BDT_unsigned ):
                                basicDataType   = "int";
                        break;

                case BDT_long:
                case ( BDT_long   | BDT_unsigned ):
                                basicDataType   = "long";
                        break;

                case BDT_segment:
#if     ( !VERS_PWB )
                                basicDataType   = UScore ( TOK_segment );
#else   // } elif VERS_PWB {
                                basicDataType   = "__segment";
#endif  // VERS_PWB
                        break;

                case BDT_float:
                                basicDataType   = "float";
                        break;

                case BDT_longdouble:
                                basicDataType   = "long ";

                        // No break

                case BDT_double:
                                basicDataType   += "double";
                        break;

                case BDT_pointer:
                case ( BDT_pointer | BDT_const ):
                case ( BDT_pointer | BDT_volatile ):
                case ( BDT_pointer | BDT_const | BDT_volatile ):
                                pCvCode = ( bdtCode & ( BDT_const | BDT_volatile ));
                        break;

                default:
                                gName--;        // Backup, since 'ecsu-data-type' does it's own decoding

                                basicDataType   = getECSUDataType ();

                                if      ( basicDataType.isEmpty ())
                                        return  basicDataType;
                        break;

                }       // End of SWITCH

                //      What type of basic data type composition is involved ?

                if      ( pCvCode == -1 )       // Simple ?
                {
                        //      Determine the 'signed/unsigned'ness

                        switch  ( bdtCode )
                        {
                        case ( BDT_char   | BDT_unsigned ):
                        case ( BDT_short  | BDT_unsigned ):
                        case ( BDT_int    | BDT_unsigned ):
                        case ( BDT_long   | BDT_unsigned ):
                                        basicDataType   = "unsigned " + basicDataType;
                                break;

                        case BDT_schar:
                                        basicDataType   = "signed " + basicDataType;
                                break;

                        }       // End of SWITCH

                        //      Add the indirection type to the type

                        if      ( !superType.isEmpty ())
                                basicDataType   += ' ' + superType;

                        //      And return the completed type

                        return  basicDataType;

                }       // End of IF then
                else
                {
                        DName   cvType;
                        DName   super ( superType );


                        //      Is it 'const/volatile' qualified ?

                        if              ( pCvCode & BDT_const )
                        {
                                cvType  = "const";

                                if      ( pCvCode & BDT_volatile )
                                        cvType  += " volatile";

                        }       // End of IF then
                        elif    ( pCvCode & BDT_volatile )
                                cvType  = "volatile";

                        //      Construct the appropriate pointer type declaration

                        return  getPointerType ( cvType, super.setPtrRef ());

                }       // End of IF else
        }       // End of IF then
        else
                return  ( DN_truncated + superType );

}       // End of "UnDecorator" FUNCTION "getBasicDataType"



DName   __near  UnDecorator::getECSUDataType ( int ecsuMods )
{
FTRACE(getECSUDataType);
        DName                   ecsuDataType;


        //      Get the 'model' modifiers if applicable

        if      ( ecsuMods )
                if              ( ecsuMods == ECSU_invalid )
                        return  DN_invalid;
                elif    ( ecsuMods == ECSU_truncated )
                        ecsuDataType    = DN_truncated;
#if     ( !VERS_PWB )
                else
                        switch  ( ecsuMods & ECSU_modelmask )
                        {
                        case ECSU_near:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = UScore ( TOK_nearSp );
                                break;

                        case ECSU_far:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = UScore ( TOK_farSp );
                                break;

                        case ECSU_huge:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = UScore ( TOK_hugeSp );
                                break;

                        case ECSU_based:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = getBasedType ();
                                        else
                                                ecsuDataType    |= getBasedType ();     // Just lose the 'based-type'
                                break;

                        }       // End of SWITCH
#else   // } elif VERS_PWB {
                elif    (( ecsuMods & ECSU_modelmask ) == ECSU_based )
                        ecsuDataType    |= getBasedType ();
#endif  // VERS_PWB

        //      Extract the principal type information itself, and validate the codes

        switch  ( *gName++ )
        {
        case 0:
                        gName--;        // Backup to permit later error recovery to work safely

                        return  "`unknown ecsu'" + ecsuDataType + DN_truncated;

        case BDT_union:
                        if      ( 1 )   // Non-redundant control flow trick
                                ecsuDataType    = "union " + ecsuDataType;
                        else

        case BDT_struct:
                        if      ( 1 )   // Non-redundant control flow trick
                                ecsuDataType    = "struct " + ecsuDataType;
                        else

        case BDT_class:
                        if      ( 1 )   // Non-redundant control flow trick
                                ecsuDataType    = "class " + ecsuDataType;

                        //      Get the UDT 'const/volatile' modifiers if applicable

                        //      Get the 'class/struct/union' name

                        ecsuDataType    += getECSUName ();
                break;

        case BDT_enum:
                        ecsuDataType    = "enum " + ecsuDataType + getEnumName ();
                break;

        default:
                        return  DN_invalid;

        }       // End of SWITCH

        //      And return the formed 'ecsu-data-type'

        return  ecsuDataType;

}       // End of "UnDecorator" FUNCTION "getECSUDataType"



DName   __near  UnDecorator::getPtrRefType ( const DName & cvType, const DName & superType, int isPtr )
{
FTRACE(getPtrRefType);
        //      Doubles up as 'pointer-type' and 'reference-type'

        if      ( *gName )
                if      ( IT_isfunction ( *gName ))     // Is it a function or data indirection ?
                {
                        //      Since I haven't coded a discrete 'function-type', both
                        //      'function-indirect-type' and 'function-type' are implemented
                        //      inline under this condition.

                        int             fitCode = *gName++ - '6';


                        if              ( fitCode == ( '_' - '6' ))
                        {
                                if      ( *gName )
                                {
                                        fitCode = *gName++ - 'A' + FIT_based;

                                        if      (( fitCode < FIT_based ) || ( fitCode > ( FIT_based | FIT_far | FIT_member )))
                                                fitCode = -1;

                                }       // End of IF then
                                else
                                        return  ( DN_truncated + superType );

                        }       // End of IF then
                        elif    (( fitCode < FIT_near ) || ( fitCode > ( FIT_far | FIT_member )))
                                fitCode = -1;

                        //      Return if invalid name

                        if      ( fitCode == -1 )
                                return  DN_invalid;


                        //      Otherwise, what are the function indirect attributes

                        DName   thisType;
                        DName   fitType = ( isPtr ? '*' : '&' );


                        if      ( !cvType.isEmpty () && ( superType.isEmpty () || superType.isPtrRef ()))
                                fitType += cvType;

                        if      ( !superType.isEmpty ())
                                fitType += superType;

                        //      Is it a pointer to member function ?

                        if      ( fitCode & FIT_member )
                        {
                                fitType = "::" + fitType;

                                if      ( *gName )
                                        fitType = ' ' + getScope ();
                                else
                                        fitType = DN_truncated + fitType;

                                if      ( *gName )
                                        if      ( *gName == '@' )
                                                gName++;
                                        else
                                                return  DN_invalid;
                                else
                                        return  ( DN_truncated + fitType );
#if     ( !VERS_PWB )
                                if      ( doThisTypes ())
                                        thisType        = getThisType ();
                                else
#endif  // !VERS_PWB
                                        thisType        |= getThisType ();

                        }       // End of IF

                        //      Is it a based allocated function ?

                        if      ( fitCode & FIT_based )
#if     ( !VERS_PWB )
                                if      ( doMSKeywords ())
                                        fitType = ' ' + getBasedType () + fitType;
                                else
#endif  // !VERS_PWB
                                        fitType |= getBasedType ();     // Just lose the 'based-type'

                        //      Get the 'calling-convention'
#if     ( !VERS_PWB )
                        if      ( doMSKeywords ())
                        {
                                fitType = getCallingConvention () + fitType;

                                //      Is it a near or far function pointer

                                fitType = UScore ((( fitCode & FIT_far ) ? TOK_farSp : TOK_nearSp )) + fitType;

                        }       // End of IF then
                        else
#endif  // !VERS_PWB
                                fitType |= getCallingConvention ();     // Just lose the 'calling-convention'

                        //      Parenthesise the indirection component, and work on the rest

                        fitType = '(' + fitType + ')';

                        //      Get the rest of the 'function-type' pieces

                        DName * pDeclarator     = gnew DName;
                        DName   returnType ( getReturnType ( pDeclarator ));


                        fitType += '(' + getArgumentTypes () + ')';

#if     ( !VERS_PWB )
                        if      ( doThisTypes () && ( fitCode & FIT_member ))
                                fitType += thisType;

                        if      ( doThrowTypes ())
                                fitType += getThrowTypes ();
                        else
#endif  // !VERS_PWB
                                fitType |= getThrowTypes ();    // Just lose the 'throw-types'

                        //      Now insert the indirected declarator, catch the allocation failure here

                        if      ( pDeclarator )
                                *pDeclarator    = fitType;
                        else
                                return  ERROR;

                        //      And return the composed function type (now in 'returnType' )

                        return  returnType;

                }       // End of IF then
                else
                {
                        //      Otherwise, it is either a pointer or a reference to some data type

                        DName   innerType ( getDataIndirectType ( superType, ( isPtr ? '*' : '&' ), cvType ));


                        return  getPtrRefDataType ( innerType, isPtr );

                }       // End of IF else
        else
        {
                DName   trunk ( DN_truncated );


                trunk   += ( isPtr ? '*' : '&' );

                if      ( !cvType.isEmpty ())
                        trunk   += cvType;

                if      ( !superType.isEmpty ())
                {
                        if      ( !cvType.isEmpty ())
                                trunk   += ' ';

                        trunk   += superType;

                }       // End of IF

                return  trunk;

        }       // End of IF else
}       // End of "UnDecorator" FUNCTION "getPtrRefType"



DName   __near  UnDecorator::getDataIndirectType ( const DName & superType, char prType, const DName & cvType, int thisFlag )
{
FTRACE(getDataIndirectType);
        if              ( *gName )
        {
                unsigned int    ditCode = ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));


                gName++;                // Skip to next character in name

                //      Is it a valid 'data-indirection-type' ?

                if      (( ditCode <= ( DIT_const | DIT_volatile | DIT_modelmask | DIT_member )))
                {
                        DName   ditType ( prType );


                        //      If it is a member, then these attributes immediately precede the indirection token

                        if      ( ditCode & DIT_member )
                        {
                                //      If it is really 'this-type', then it cannot be any form of pointer to member

                                if      ( thisFlag )
                                        return  DN_invalid;

                                //      Otherwise, extract the scope for the PM

                                ditType         = "::" + ditType;

                                if      ( *gName )
                                        ditType = ' ' + getScope ();
                                else
                                        ditType = DN_truncated + ditType;

                                //      Now skip the scope terminator

                                if              ( !*gName )
                                        ditType += DN_truncated;
                                elif    ( *gName++ != '@' )
                                        return  DN_invalid;

                        }       // End of IF
#if     ( !VERS_PWB )
                        //      Add the 'model' attributes (prefixed) as appropriate

                        if      ( doMSKeywords ())
                                switch  ( ditCode & DIT_modelmask )
                                {
                                case DIT_near:
                                                ditType = UScore ( TOK_near ) + ditType;
                                        break;

                                case DIT_far:
                                                ditType = UScore ( TOK_far ) + ditType;
                                        break;

                                case DIT_huge:
                                                ditType = UScore ( TOK_huge ) + ditType;
                                        break;

                                case DIT_based:
                                                //      The 'this-type' can never be 'based'

                                                if      ( thisFlag )
                                                        return  DN_invalid;

                                                ditType = getBasedType () + ditType;
                                        break;

                                }       // End of SWITCH
                        elif    (( ditCode & DIT_modelmask ) == DIT_based )
#else   // } elif VERS_PWB {
                        if      (( ditCode & DIT_modelmask ) == DIT_based )
#endif  // VERS_PWB
                                ditType |= getBasedType ();     // Just lose the 'based-type'

                        //      Handle the 'const' and 'volatile' attributes

                        if      ( ditCode & DIT_volatile )
                                ditType = "volatile " + ditType;

                        if      ( ditCode & DIT_const )
                                ditType = "const " + ditType;

                        //      Append the supertype, if not 'this-type'

                        if      ( !thisFlag )
                                if              ( !superType.isEmpty ())
                                {
                                        //      Is the super context included 'cv' information, ensure that it is added appropriately

                                        if      ( superType.isPtrRef () || cvType.isEmpty ())
                                                ditType += ' ' + superType;
                                        else
                                                ditType += ' ' + cvType + ' ' + superType;

                                }       // End of IF then
                                elif    ( !cvType.isEmpty ())
                                        ditType += ' ' + cvType;

                        //      Finally, return the composed 'data-indirection-type' (with embedded sub-type)

                        return  ditType;

                }       // End of IF then
                else
                        return  DN_invalid;

        }       // End of IF then
        elif    ( !thisFlag && !superType.isEmpty ())
        {
                //      Is the super context included 'cv' information, ensure that it is added appropriately

                if      ( superType.isPtrRef () || cvType.isEmpty ())
                        return  ( DN_truncated + superType );
                else
                        return  ( DN_truncated + cvType + ' ' + superType );

        }       // End of ELIF then
        elif    ( !thisFlag && !cvType.isEmpty ())
                return  ( DN_truncated + cvType );
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getDataIndirectType"


inline  int             __near  UnDecorator::getECSUDataIndirectType ()
{
FTRACE(getECSUDataIndirectType);
        if      ( *gName )
        {
                unsigned int    ecsuCode        = *gName++ - 'A';


                //      Is it a valid 'ecsu-data-indirection-type' ?

                if      (( ecsuCode <= ( ECSU_const | ECSU_volatile | ECSU_modelmask )))
                        return  ( ecsuCode | ECSU_valid );
                else
                        return  ECSU_invalid;

        }       // End of IF then
        else
                return  ECSU_truncated;

}       // End of "UnDecorator" FUNCTION "getECSUDataIndirectType"


inline  DName   __near  UnDecorator::getPtrRefDataType ( const DName & superType, int isPtr )
{
FTRACE(getPtrRefDataType);
        //      Doubles up as 'pointer-data-type' and 'reference-data-type'

        if      ( *gName )
        {
                //      Is this a 'pointer-data-type' ?

                if      ( isPtr && ( *gName == PoDT_void ))
                {
                        gName++;        // Skip this character

                        if      ( superType.isEmpty ())
                                return  "void";
                        else
                                return  "void " + superType;

                }       // End of IF

                //      Otherwise it may be a 'reference-data-type'

                if      ( *gName == RDT_array ) // An array ?
                {
                        DName * pDeclarator     = gnew DName;


                        if      ( !pDeclarator )
                                return  ERROR;

                        gName++;


                        DName   theArray ( getArrayType ( pDeclarator ));


                        if      ( !theArray.isEmpty ())
                                *pDeclarator    = superType;

                        //      And return it

                        return  theArray;

                }       // End of IF

                //      Otherwise, it is a 'basic-data-type'

                return  getBasicDataType ( superType );

        }       // End of IF then
        else
                return  ( DN_truncated + superType );

}       // End of "UnDecorator" FUNCTION "getPtrRefDataType"


inline  DName   __near  UnDecorator::getArrayType ( DName * pDeclarator )
{
FTRACE(getArrayType);
        DName   superType ( pDeclarator );


        if      ( *gName )
        {
                int     noDimensions    = getNumberOfDimensions ();


                if      ( !noDimensions )
                        return  getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );
                else
                {
                        DName   arrayType;


                        while   ( noDimensions-- )
                                arrayType       += '[' + getDimension () + ']';

                        //      If it is indirect, then parenthesise the 'super-type'

                        if      ( !superType.isEmpty ())
                                arrayType       = '(' + superType + ')' + arrayType;

                        //      Return the finished array dimension information

                        return  getBasicDataType ( arrayType );

                }       // End of IF else
        }       // End of IF
        elif    ( !superType.isEmpty ())
                return  getBasicDataType ( '(' + superType + ")[" + DN_truncated + ']' );
        else
                return  getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );

}       // End of "UnDecorator" FUNCTION "getArrayType"


inline          DName           __near  UnDecorator::getLexicalFrame ( void )           {       return  '`' + getDimension () + '\'';   }
inline          DName           __near  UnDecorator::getStorageConvention ( void )      {       return  getDataIndirectType (); }
inline          DName           __near  UnDecorator::getDataIndirectType ()                     {       return  getDataIndirectType ( DName (),  0, DName ());  }
inline_lnk      DName           __near  UnDecorator::getThisType ( void )                       {       return  getDataIndirectType ( DName (), 0, DName (), TRUE );    }

inline  DName   __near  UnDecorator::getPointerType ( const DName & cv, const DName & name )
{       return  getPtrRefType ( cv, name, TRUE );       }

inline  DName   __near  UnDecorator::getReferenceType ( const DName & cv, const DName & name )
{       return  getPtrRefType ( cv, name, FALSE );      }


#if     ( !VERS_PWB )
inline  DName           __near  UnDecorator::getSegmentName ( void )            {       return  getZName ();    }
#endif  // !VERS_PWB


#if     ( !NO_COMPILER_NAMES )
inline  DName           __near  UnDecorator::getDisplacement ( void )           {       return  getDimension ();        }
inline  DName           __near  UnDecorator::getCallIndex ( void )                      {       return  getDimension ();        }
inline  DName           __near  UnDecorator::getGuardNumber ( void )            {       return  getDimension ();        }

inline  DName   __near  UnDecorator::getVbTableType ( const DName & superType )
{       return  getVfTableType ( superType );   }


inline  DName   __near  UnDecorator::getVCallThunkType ( void )
{
FTRACE(UnDecorator::getVCallThunkType);
        DName   vcallType       = '{';


        //      Get the 'this' model, and validate all values

        switch  ( *gName )
        {
        case VMT_nTnCnV:
        case VMT_nTfCnV:
        case VMT_nTnCfV:
        case VMT_nTfCfV:
        case VMT_nTnCbV:
        case VMT_nTfCbV:
                        vcallType       += UScore ( TOK_nearSp );
                break;

        case VMT_fTnCnV:
        case VMT_fTfCnV:
        case VMT_fTnCfV:
        case VMT_fTfCfV:
        case VMT_fTnCbV:
        case VMT_fTfCbV:
                        vcallType       += UScore ( TOK_farSp );
                break;

        case 0:
                        return  DN_truncated;

        default:
                        return  DN_invalid;

        }       // End of SWITCH

        //      Always append 'this'

        vcallType       += "this, ";

        //      Get the 'call' model

        switch  ( *gName )
        {
        case VMT_nTnCnV:
        case VMT_fTnCnV:
        case VMT_nTnCfV:
        case VMT_fTnCfV:
        case VMT_nTnCbV:
        case VMT_fTnCbV:
                        vcallType       += UScore ( TOK_nearSp );
                break;

        case VMT_nTfCnV:
        case VMT_fTfCnV:
        case VMT_nTfCfV:
        case VMT_fTfCfV:
        case VMT_nTfCbV:
        case VMT_fTfCbV:
                        vcallType       += UScore ( TOK_farSp );
                break;

        }       // End of SWITCH

        //      Always append 'call'

        vcallType       += "call, ";

        //      Get the 'vfptr' model

        switch  ( *gName++ )    // Last time, so advance the pointer
        {
        case VMT_nTnCnV:
        case VMT_nTfCnV:
        case VMT_fTnCnV:
        case VMT_fTfCnV:
                        vcallType       += UScore ( TOK_nearSp );
                break;

        case VMT_nTnCfV:
        case VMT_nTfCfV:
        case VMT_fTnCfV:
        case VMT_fTfCfV:
                        vcallType       += UScore ( TOK_farSp );
                break;

        case VMT_nTnCbV:
        case VMT_nTfCbV:
        case VMT_fTnCbV:
        case VMT_fTfCbV:
                        vcallType       += getBasedType ();
                break;

        }       // End of SWITCH

        //      Always append 'vfptr'

        vcallType       += "vfptr}";

        //      And return the resultant 'vcall-model-type'

        return  vcallType;

}       // End of "UnDecorator" FUNCTION "getVCallThunk"


inline  DName   __near  UnDecorator::getVfTableType ( const DName & superType )
{
FTRACE(UnDecorator::getVfTableType);
        DName   vxTableName     = superType;


        if      ( vxTableName.isValid () && *gName )
        {
                vxTableName     = getStorageConvention () + ' ' + vxTableName;

                if      ( vxTableName.isValid ())
                {
                        if      ( *gName != '@' )
                        {
                                vxTableName     += "{for ";

                                while   ( vxTableName.isValid () && *gName && ( *gName != '@' ))
                                {
                                        vxTableName     += '`' + getScope () + '\'';

                                        //      Skip the scope delimiter

                                        if      ( *gName == '@' )
                                                gName++;

                                        //      Close the current scope, and add a conjunction for the next (if any)

                                        if      ( vxTableName.isValid () && ( *gName != '@' ))
                                                vxTableName     += "s ";

                                }       // End of WHILE

                                if      ( vxTableName.isValid ())
                                {
                                        if      ( !*gName )
                                                vxTableName     += DN_truncated;

                                        vxTableName     += '}';

                                }       // End of IF
                        }       // End of IF

                        //      Skip the 'vpath-name' terminator

                        if      ( *gName == '@' )
                                gName++;

                }       // End of IF
        }       // End of IF then
        elif    ( vxTableName.isValid ())
                vxTableName     = DN_truncated + vxTableName;

        return  vxTableName;

}       //      End of "UnDecorator" FUNCTION "getVfTableType"
#endif  // !NO_COMPILER_NAMES


inline  DName   __near  UnDecorator::getExternalDataType ( const DName & superType )
{
FTRACE(UnDecorator::getExternalDataType);
        //      Create an indirect declarator for the the rest

        DName * pDeclarator     = gnew DName ();
        DName   declaration     = getDataType ( pDeclarator );


        //      Now insert the declarator into the declaration along with its 'storage-convention'

        *pDeclarator    = getStorageConvention () + ' ' + superType;

        return  declaration;

}       //      End of "UnDecorator" FUNCTION "getExternalDataType"
#endif  // !VERS_P3

#if     ( !NO_OPTIONS )
inline  int                     __near  UnDecorator::doUnderScore ()                            {       return  !( disableFlags & UNDNAME_NO_LEADING_UNDERSCORES );     }
inline  int                     __near  UnDecorator::doMSKeywords ()                            {       return  !( disableFlags & UNDNAME_NO_MS_KEYWORDS );     }
inline  int                     __near  UnDecorator::doFunctionReturns ()                       {       return  !( disableFlags & UNDNAME_NO_FUNCTION_RETURNS );        }
inline  int                     __near  UnDecorator::doAllocationModel ()                       {       return  !( disableFlags & UNDNAME_NO_ALLOCATION_MODEL );        }
inline  int                     __near  UnDecorator::doAllocationLanguage ()            {       return  !( disableFlags & UNDNAME_NO_ALLOCATION_LANGUAGE );     }

#if     0
inline  int                     __near  UnDecorator::doMSThisType ()                            {       return  !( disableFlags & UNDNAME_NO_MS_THISTYPE );     }
inline  int                     __near  UnDecorator::doCVThisType ()                            {       return  !( disableFlags & UNDNAME_NO_CV_THISTYPE );     }
#endif

inline  int                     __near  UnDecorator::doThisTypes ()                                     {       return  (( disableFlags & UNDNAME_NO_THISTYPE ) != UNDNAME_NO_THISTYPE );       }
inline  int                     __near  UnDecorator::doAccessSpecifiers ()                      {       return  !( disableFlags & UNDNAME_NO_ACCESS_SPECIFIERS );       }
inline  int                     __near  UnDecorator::doThrowTypes ()                            {       return  !( disableFlags & UNDNAME_NO_THROW_SIGNATURES );        }
inline  int                     __near  UnDecorator::doMemberTypes ()                           {       return  !( disableFlags & UNDNAME_NO_MEMBER_TYPE );     }
inline  int                     __near  UnDecorator::doReturnUDTModel ()                        {       return  !( disableFlags & UNDNAME_NO_RETURN_UDT_MODEL );        }
#endif  // !NO_OPTIONS


#if     ( !VERS_P3 && !VERS_PWB )
pcchar_t        __near  UnDecorator::UScore ( Tokens tok  )
{
FTRACE(UnDecorator::UScore);
#if     ( !NO_OPTIONS )
        return  ( doUnderScore () ? tokenTable[ tok ] : tokenTable[ tok ] + 2 );
#else   // } elif NO_OPTIONS {
        return  tokenTable[ tok ];
#endif  // NO_OPTIONS

}       // End of "UnDecorator" FUNCTION "UScore"
#endif  // !VERS_P3 && !VERS_PWB


#include        "undname.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\undname.inl ===
/*
 *	This module contains the definitions for the inline functions used by the
 *	name undecorator.  It is intended that this file should be included
 *	somewhere in the source file for the undecorator to maximise the chance
 *	that they will be truly inlined.
 */

//	The following class is a special node class, used in the implementation
//	of the internal chaining mechanism of the 'DName's

class	charNode;
class	pcharNode;
class	pDNameNode;
class	DNameStatusNode;


#if	( NO_VIRTUAL )
enum	NodeType
{
	charNode_t,
	pcharNode_t,
	pDNameNode_t,
	DNameStatusNode_t

};
#endif	// NO_VIRTUAL


class	DNameNode
{
private:

#if	NO_VIRTUAL
		NodeType			typeIndex;
#endif	// NO_VIRTUAL

		DNameNode *			next;

protected:

#if	( !NO_VIRTUAL )
					__near	DNameNode ();
#else	// } elif NO_VIRTUAL {
					__near	DNameNode ( NodeType );
#endif	// NO_VIRTUAL

					__near	DNameNode ( const DNameNode & );

public:

virtual	int			__near	length () const PURE;
virtual	pchar_t		__near	getString ( pchar_t, int ) const PURE;
		DNameNode *	__near	clone ();
		DNameNode *	__near	nextNode () const;

		DNameNode &	__near	operator += ( DNameNode * );

};


class	charNode		: public DNameNode
{
private:
		char				me;

public:
					__near	charNode ( char );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pcharNode		: public DNameNode
{
private:
		pchar_t				me;
		int					myLen;

public:
					__near	pcharNode ( pcchar_t, int = 0 );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pDNameNode		: public DNameNode
{
private:
		DName *				me;

public:
					__near	pDNameNode ( DName * );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	DNameStatusNode	: public DNameNode
{
private:
#define	TruncationMessage		(" ?? ")
#define	TruncationMessageLength	(4)

		DNameStatus			me;
		int					myLen;

public:
					__near	DNameStatusNode ( DNameStatus );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};



//	Memory allocation functions
			
inline	void __far *	__near __pascal	operator new ( size_t sz, HeapManager &, int noBuffer )
{	return	heap.getMemory ( sz, noBuffer );	}

void __far *	__near	HeapManager::getMemory ( size_t sz, int noBuffer )
{
FTRACE(HeapManager::getMemory);
	//	Align the allocation on an appropriate boundary

	sz	= (( sz + PACK_SIZE ) & ~PACK_SIZE );

	if	( noBuffer )
	{
#if	STDEBUG
actual += sz;
#endif	// STDEBUG

#if	( !USE_CRT_HEAP )
		return	( *pOpNew )( sz );
#else	// } elif USE_CRT_HEAP {
		return	malloc ( sz );
#endif	// USE_CRT_HEAP

	}		// End of IF then
	else
	{
		//	Handler a potential request for no space

		if	( !sz )
			sz	= 1;
#if	STDEBUG
requested += sz;
#endif	// STDEBUG

		if	( blockLeft < sz )
		{
			//	Is the request greater than the largest buffer size ?

			if	( sz > memBlockSize )
				return	0;		// If it is, there is nothing we can do


			//	Allocate a new block

			Block *	pNewBlock	= rnew Block;


			//	Did the allocation succeed ?  If so connect it up

			if	( pNewBlock )
			{
				//	Handle the initial state

				if	( tail )
					tail	= tail->next	= pNewBlock;
				else
					head	= tail			= pNewBlock;

				//	Compute the remaining space

				blockLeft	= memBlockSize - sz;

			}	// End of IF then
			else
				return	0;		// Oh-oh!  Memory allocation failure

		}	// End of IF then
		else
			blockLeft	-= sz;	// Deduct the allocated amount

		//	And return the buffer address

		return	&( tail->memBlock[ blockLeft ]);

	}	// End of IF else
}	// End of "HeapManager" FUNCTION "getMemory(unsigned int,int)"




//	Friend functions of 'DName'

DName	__near __pascal	operator + ( char c, const DName & rd )
{	return	DName ( c ) + rd;	}

DName	__near __pascal	operator + ( DNameStatus st, const DName & rd )
{	return	DName ( st ) + rd;	}

DName	__near __pascal	operator + ( pcchar_t s, const DName & rd )
{	return	DName ( s ) + rd;	}


//	The 'DName' constructors

inline_p3	__near	DName::DName ()					{	node	= 0;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0;	}
inline		__near	DName::DName ( DNameNode * pd )	{	node	= pd;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0;	}

__near	DName::DName ( char c )
{
FTRACE(DName::DName(char));
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	node	= 0;

	//	The NULL character is boring, do not copy

	if	( c )
		doPchar ( &c, 1 );

}	// End of "DName" CONSTRUCTOR '(char)'


#if	1
__near	DName::DName ( const DName & rd )
{
#if	STDEBUG
FTRACE(DName::DName(const DName&));
	shallowCopies++;
#endif	// STDEBUG

	stat	= rd.stat;
	isIndir	= rd.isIndir;
	isAUDC	= rd.isAUDC;
	node	= rd.node;

}	// End of "DName" CONSTRUCTOR '(const DName&)'
#endif

#if	( !VERS_P3 )
__near	DName::DName ( DName * pd )
{
FTRACE(DName::DName(DName*));
	if	( pd )
	{
		node	= gnew pDNameNode ( pd );
		stat	= ( node ? DN_valid : ERROR );

	}	// End of IF else
	else
	{
		stat	= DN_valid;
		node	= 0;

	}	// End of IF else

	isIndir	= 0;
	isAUDC	= 0;

}	// End of "DName" CONSTRUCTOR '( DName* )'
#endif	// !VERS_P3


__near	DName::DName ( pcchar_t s )
{
FTRACE(DName::DName(pcchar_t));
	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;

	if	( s )
		doPchar ( s, strlen ( s ));

}	// End of "DName" CONSTRUCTOR '(pcchar_t)'


__near	DName::DName ( pcchar_t & name, char terminator )
{
FTRACE(DName::DName(pcchar_t&,char));
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	node	= 0;

	//	Is there a string ?

	if	( name )
		if	( *name )
		{
			int	len	= 0;


			//	How long is the string ?

			for	( pcchar_t s = name; *name && ( *name != terminator ); name++ )
				if	( isValidIdentChar ( *name ))
					len++;
				else
				{
					stat	= DN_invalid;

					return;

				}	// End of IF else

			//	Copy the name string fragment

			doPchar ( s, len );

			//	Now gobble the terminator if present, handle error conditions

			if	( *name )
			{
				if	( *name++ != terminator )
				{
					stat	= ERROR;
					node	= 0;

				}	// End of IF then
				else
					stat	= DN_valid;

			}	// End of IF then
			elif	( status () == DN_valid )
				stat	= DN_truncated;

		}	// End of IF then
		else
			stat	= DN_truncated;
	else
		stat	= DN_invalid;

}	// End of "DName" CONSTRUCTOR '(pcchar_t&,char)'


#if	( !VERS_P3 )
__near	DName::DName ( unsigned long num )
{
FTRACE(DName::DName(unsigned long));
	char	buf[ 11 ];
	char *	pBuf	= buf + 10;


	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;

	//	Essentially, 'ultoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	do
	{
		*( --pBuf )	= (char)(( num % 10 ) + '0' );
		num			/= 10UL;

	}	while	( num );

	doPchar ( pBuf, ( 10 - (int)( pBuf - buf )));

}	// End of "DName" CONSTRUCTOR '(unsigned long)'
#endif	// !VERS_P3


__near	DName::DName ( DNameStatus st )
{
FTRACE(DName::DName(DNameStatus));
	stat	= ((( st == DN_invalid ) || ( st == DN_error )) ? st : DN_valid );
	node	= gnew DNameStatusNode ( st );
	isIndir	= 0;
	isAUDC	= 0;

	if	( !node )
		stat	= ERROR;

}	// End of "DName" CONSTRUCTOR '(DNameStatus)'



//	Now the member functions for 'DName'

int		__near	DName::isValid () const		{	return	(( status () == DN_valid ) || ( status () == DN_truncated ));	}
int		__near	DName::isEmpty () const		{	return	(( node == 0 ) || !isValid ());	}

inline	DNameStatus	__near	DName::status () const	{	return	(DNameStatus)stat;	}	// The cast is to keep Glockenspiel quiet

#if	( !VERS_P3 )
inline	DName &	__near	DName::setPtrRef ()			{	isIndir	= 1;	return	*this;	}
inline	int		__near	DName::isPtrRef () const	{	return	isIndir;	}
inline	int		__near	DName::isUDC () const		{	return	( !isEmpty () && isAUDC );	}
inline	void	__near	DName::setIsUDC ()			{	if	( !isEmpty ())	isAUDC	= TRUE;	}
#endif	// !VERS_P3

int	__near	DName::length () const
{
FTRACE(DName::length);
	int	len	= 0;


	if	( !isEmpty ())
		for	( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			len	+= pNode->length ();

	return	len;

}	// End of "DName" FUNCTION "length"


pchar_t	__near	DName::getString ( pchar_t buf, int max ) const
{
FTRACE(DName::getString);
	if		( !isEmpty ())
	{
		//	Does the caller want a buffer allocated ?

		if	( !buf )
		{
			max	= length () + 1;
			buf	= gnew char[ max ];	// Get a buffer big enough

		}	// End of IF then

		//	If memory allocation failure, then return no buffer

		if	( buf )
		{
			//	Now, go through the process of filling the buffer (until max is reached)

			int			curLen	= max;
			DNameNode *	curNode	= node;
			pchar_t		curBuf	= buf;


			while	( curNode && ( curLen > 0 ))
			{
				int		fragLen	= curNode->length ();
				pchar_t	fragBuf	= 0;


				//	Skip empty nodes

				if	( fragLen )
				{
					//	Handle buffer overflow

					if	(( curLen - fragLen ) < 0 )
						fragLen	= curLen;

					//	Now copy 'len' number of bytes of the piece to the buffer

					fragBuf	= curNode->getString ( curBuf, fragLen );

					//	Should never happen, but handle it anyway

					if	( fragBuf )
					{
						//	Update string position

						curLen	-= fragLen;
						curBuf	+= fragLen;

					}	// End of IF
				}	// End of IF

				//	Move on to the next name fragment

				curNode	= curNode->nextNode ();

			}	// End of WHILE

			*curBuf	= 0;	// Always NULL terminate the resulting string

		}	// End of IF
	}	// End of IF then
	elif	( buf )
		*buf	= 0;

	//	Return the buffer

	return	buf;

}	// End of "DName" FUNCTION "getString(pchar_t,int)"


#if	( !VERS_P3 )
DName	__near	DName::operator + ( char ch ) const
{
FTRACE(DName::+(char));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= ch;
	else
		local	+= ch;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(char)"
#endif	// !VERS_P3


DName	__near	DName::operator + ( pcchar_t str ) const
{
FTRACE(DName::+(pcchar_t));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= str;
	else
		local	+= str;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(pcchar_t)"


DName	__near	DName::operator + ( const DName & rd ) const
{
FTRACE(DName::+(const DName&));
	DName	local ( *this );


	if		( local.isEmpty ())
		local	= rd;
	elif	( rd.isEmpty ())
		local	+= rd.status ();
	else
		local	+= rd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(const DName&)"


#if	( !VERS_P3 )
DName	__near	DName::operator + ( DName * pd ) const
{
FTRACE(DName::+(DName*));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= pd;
	else
		local	+= pd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DName*)"


DName	__near	DName::operator + ( DNameStatus st ) const
{
FTRACE(DName::+(DNameStatus));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= st;
	else
		local	+= st;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DNameStatus)"



DName &	__near	DName::operator += ( char ch )
{
FTRACE(DName::+=(char));
	if	( ch )
		if	( isEmpty ())
			*this	= ch;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew charNode ( ch );
			else
				stat	= ERROR;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(char)"


DName &	__near	DName::operator += ( pcchar_t str )
{
FTRACE(DName::+=(pcchar_t));
	if	( str && *str )
		if	( isEmpty ())
			*this	= str;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew pcharNode ( str );
			else
				stat	= ERROR;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(pcchar_t)"
#endif	// !VERS_P3


DName &	__near	DName::operator += ( const DName & rd )
{
FTRACE(DName::+=(const DName&));
	if	( rd.isEmpty ())
		*this	+= rd.status ();
	else
		if	( isEmpty ())
			*this	= rd;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= rd.node;
			else
				stat	= ERROR;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(const DName&)"


#if	( !VERS_P3 )
DName &	__near	DName::operator += ( DName * pd )
{
FTRACE(DName::+=(DName*));
	if	( pd )
		if		( isEmpty ())
			*this	= pd;
		elif	(( pd->status () == DN_valid ) || ( pd->status () == DN_truncated ))
		{
			DNameNode *	pNew	= gnew pDNameNode ( pd );


			if	( pNew )
			{
				node	= node->clone ();

				if	( node )
					*node	+= pNew;

			}	// End of IF then
			else
				node	= 0;

			if	( !node )
				stat	= ERROR;

		}	// End of IF then
		else
			*this	+= pd->status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DName*)"


DName &	__near	DName::operator += ( DNameStatus st )
{
FTRACE(DName::+=(DNameStatus));
	if	( isEmpty () || (( st == DN_invalid ) || ( st == DN_error )))
		*this	= st;
	else
	{
		DNameNode *	pNew	= gnew DNameStatusNode ( st );


		if	( pNew )
		{
			node	= node->clone ();

			if	( node )
				*node	+= pNew;

		}	// End of IF then
		else
			node	= 0;

		if	( !node )
			stat	= ERROR;

	}	// End of IF else

	//	Return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DNameStatus)"



DName &	__near	DName::operator |= ( const DName & rd )
{
FTRACE(DName::=(const DName&));
	//	Attenuate the error status.  Always becomes worse.  Don't propogate truncation

	if	(( status () != DN_error ) && !rd.isValid ())
		stat	= rd.status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '|=(const DName&)'



DName &	__near	DName::operator = ( char ch )
{
FTRACE(DName::=(char));
	isIndir	= 0;
	isAUDC	= 0;

	doPchar ( &ch, 1 );

	return	*this;

}	// End of "DName" OPERATOR '=(char)'
#endif	// !VERS_P3


DName &	__near	DName::operator = ( pcchar_t str )
{
FTRACE(DName::=(pcchar_t));
	isIndir	= 0;
	isAUDC	= 0;

	doPchar ( str, strlen ( str ));

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(pcchar_t)'


DName &	__near	DName::operator = ( const DName & rd )
{
FTRACE(DName::=(const DName&));
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
#if	STDEBUG
		shallowAssigns++;
#endif	// STDEBUG

		stat	= rd.stat;
		isIndir	= rd.isIndir;
		isAUDC	= rd.isAUDC;
		node	= rd.node;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(const DName&)'


#if	( !VERS_P3 )
DName &	__near	DName::operator = ( DName * pd )
{
FTRACE(DName::=(DName*));
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
		if	( pd )
		{
			isIndir	= 0;
			isAUDC	= 0;
			node	= gnew pDNameNode ( pd );

			if	( !node )
				stat	= ERROR;

		}	// End of IF then
		else
			*this	= ERROR;

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DName*)'


DName &	__near	DName::operator = ( DNameStatus st )
{
FTRACE(DName::=(DNameStatus));
	if	(( st == DN_invalid ) || ( st == DN_error ))
	{
		node	= 0;

		if	( status () != DN_error )
			stat	= st;

	}	// End of IF then
	elif	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		isIndir	= 0;
		isAUDC	= 0;
		node	= gnew DNameStatusNode ( st );

		if	( !node )
			stat	= ERROR;

	}	// End of ELIF then

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DNameStatus)'
#endif	// !VERS_P3


//	Private implementation functions for 'DName'

void	__near	DName::doPchar ( pcchar_t str, int len )
{
FTRACE(DName::doPchar);
	if	( !(( status () == DN_invalid ) || ( status () == DN_error )))
		if		( node )
			*this	= ERROR;
		elif	( str && len )
		{
			//	Allocate as economically as possible

			switch	( len )
			{
			case 0:
					stat	= ERROR;
				break;

			case 1:
					node	= gnew charNode ( *str );

					if	( !node )
						stat	= ERROR;
				break;

			default:
					node	= gnew pcharNode ( str, len );

					if	( !node )
						stat	= ERROR;
				break;

			}	// End of SWITCH
		}	// End of ELIF
		else
			stat	= DN_invalid;

}	// End of "DName" FUNCTION "doPchar(pcchar_t,int)"



//	The member functions for the 'Replicator'

inline	int	__near	Replicator::isFull () const		{	return	( index == 9 );	}
inline	__near		Replicator::Replicator ()
:	ErrorDName ( DN_error ), InvalidDName ( DN_invalid )
{	index	= -1;	}



Replicator &	__near	Replicator::operator += ( const DName & rd )
{
FTRACE(Replicator::+=);
	if	( !isFull () && !rd.isEmpty ())
	{
		DName *	pNew	= gnew DName ( rd );


		//	Don't update if failed

		if	( pNew )
			dNameBuffer[ ++index ]	= pNew;

	}	// End of IF

	return	*this;

}	// End of "Replicator" OPERATOR '+=(const DName&)'


const DName &	__near	Replicator::operator [] ( int x ) const
{
FTRACE(Replicator::[]);
	if		(( x < 0 ) || ( x > 9 ))
		return	ErrorDName;
	elif	(( index == -1 ) || ( x > index ))
	{
		(void)ERROR;

		return	InvalidDName;

	}	// End of ELIF then
	else
		return	*dNameBuffer[ x ];

}	// End of "Replicator" OPERATOR '[](int)'



//	The member functions for the 'DNameNode' classes

#if	( !NO_VIRTUAL )
__near	DNameNode::DNameNode ()
#else	// } elif NO_VIRTUAL {
__near	DNameNode::DNameNode ( NodeType ndTy )
:	typeIndex ( ndTy )
#endif	// NO_VIRTUAL
{	next	= 0;	}

inline	__near	DNameNode::DNameNode ( const DNameNode & rd )	{	next	= (( rd.next ) ? rd.next->clone () : 0 );	}

inline	DNameNode *	__near	DNameNode::nextNode () const		{	return	next;	}

DNameNode *	__near	DNameNode::clone ()
{
#if	STDEBUG
FTRACE(DNameNode::clone);
	clones++;
#endif	// STDEBUG

	return	gnew pDNameNode ( gnew DName ( this ));
}

#if	( STDEBUG || NO_VIRTUAL )
int	__near	DNameNode::length () const
{	//	Pure function, should not be called
FTRACE(DNameNode::length);

#if ( NO_VIRTUAL )
	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->length ();

	case pcharNode_t:
		return	((pcharNode*)this )->length ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->length ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->length ();

	}	// End of SWITCH
#endif	// NO_VIRTUAL

	return	0;
}


pchar_t	__near	DNameNode::getString ( pchar_t s, int l ) const
{	//	Pure function, should not be called
FTRACE(DNameNode::getString);

#if ( NO_VIRTUAL )
	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getString ( s, l );

	case pcharNode_t:
		return	((pcharNode*)this )->getString ( s, l );

	case pDNameNode_t:
		return	((pDNameNode*)this )->getString ( s, l );

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getString ( s, l );

	}	// End of SWITCH
#endif	// NO_VIRTUAL

	return	0;
}
#endif	// STDEBUG || NO_VIRTUAL


DNameNode &	__near	DNameNode::operator += ( DNameNode * pNode )
{
FTRACE(DNameNode::+=(DNameNode*));
	if	( pNode )
	{
		if	( next )
		{
			//	Skip to the end of the chain

			for	( DNameNode* pScan = next; pScan->next; pScan = pScan->next )
				;

			//	And append the new node

			pScan->next	= pNode;

		}	// End of IF then
		else
			next	= pNode;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DNameNode" OPERATOR '+=(DNameNode*)'



//	The 'charNode' virtual functions

inline_p3	__near	charNode::charNode ( char ch )
#if	( NO_VIRTUAL )
:	DNameNode ( charNode_t )
#endif	// NO_VIRTUAL
{	me	= ch;	}

inline	int	__near	charNode::length () const		{	return	1;	}

inline_pwb
inline_lnk
pchar_t	__near	charNode::getString ( pchar_t buf, int len ) const
{
FTRACE(charNode::getString);
	if	( buf && len )
		*buf	= me;
	else
		buf		= 0;

	//	Now return the character

	return	buf;

}	// End of "charNode" FUNCTION "getString(pchar_t,int)"



//	The 'pcharNode' virtual functions

inline	int	__near	pcharNode::length () const		{	return	myLen;	}


__near	pcharNode::pcharNode ( pcchar_t str, int len )
#if ( NO_VIRTUAL )
:	DNameNode ( pcharNode_t )
#endif	// NO_VIRTUAL
{
FTRACE(pcharNode::pcharNode);
	//	Get length if not supplied

	if	( !len && str )
		len	= strlen ( str );

	//	Allocate a new string buffer if valid state

	if	( len && str )
	{
		me		= gnew char[ len ];
		myLen	= len;

		if	( me )
			strncpy ( me, str, len );

	}	// End of IF then
	else
	{
		me		= 0;
		myLen	= 0;

	}	// End of IF else
}	// End of "pcharNode" CONSTRUCTOR '(pcchar_t,int)'


inline_pwb
inline_lnk
pchar_t	__near	pcharNode::getString ( pchar_t buf, int len ) const
{
FTRACE(pcharNode::getString);
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > pcharNode::length ())
		len	= pcharNode::length ();

	//	Do the copy as appropriate

	return	(( me && buf && len ) ? strncpy ( buf, me, len ) : 0 );

}	// End of "pcharNode" FUNCTION "getString(pchar_t,int)"



//	The 'pDNameNode' virtual functions

inline_p3	__near	pDNameNode::pDNameNode ( DName * pName )
#if	( NO_VIRTUAL )
:	DNameNode ( pDNameNode_t )
#endif	// NO_VIRTUAL
{	me	= (( pName && (( pName->status () == DN_invalid ) || ( pName->status () == DN_error ))) ? 0 : pName );	}

inline	int	__near	pDNameNode::length () const					{	return	( me ? me->length () : 0 );	}

inline_pwb
inline_lnk
pchar_t	__near	pDNameNode::getString ( pchar_t buf, int len ) const
{	return	(( me && buf && len ) ? me->getString ( buf, len ) : 0 );	}



//	The 'DNameStatusNode' virtual functions

inline_p3	__near	DNameStatusNode::DNameStatusNode ( DNameStatus stat )
#if	( NO_VIRTUAL )
:	DNameNode ( DNameStatusNode_t )
#endif	// NO_VIRTUAL
{	me	= stat;	myLen	= (( me == DN_truncated ) ? TruncationMessageLength : 0 );	}

inline	int	__near	DNameStatusNode::length () const	{	return	myLen;	}

inline_pwb
inline_lnk
pchar_t	__near	DNameStatusNode::getString ( pchar_t buf, int len ) const
{
FTRACE(DNameStatusNode::getString);
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > DNameStatusNode::length ())
		len	= DNameStatusNode::length ();

	//	Do the copy as appropriate

	return	((( me == DN_truncated ) && buf && len ) ? strncpy ( buf, TruncationMessage, len ) : 0 );

}	// End of "DNameStatusNode" FUNCTION "getString(pchar_t,int)"



static	unsigned int	__near __pascal	strlen ( pcchar_t str )
{
	for	( unsigned int len = 0; *str; str++ )
		len++;

	return	len;

}	// End of FUNCTION "strlen"


static	pchar_t			__near __pascal	strncpy ( pchar_t dst, pcchar_t src, unsigned int len )
{
	for	( char __far * d = dst; ( len && ( *d = *src )); d++, src++, len-- )
		;

	return	dst;

}	// End of FUNCTION "strncpy"


#if	STDEBUG
void	CallTrace::Dump ( const DName & rd, pcchar_t sym, int line )
{
	if ( trace && !inTrace )
	{
		inTrace	= 1;
		rd.getString ( buf, 512 );
		buf[ rd.length ()] = 0;
		indent ( mark );
		fprintf ( fp, " > DName     '%s' #%d: '%s' == '%s'\n",  name, line, sym, buf );
		fflush ( fp );
		inTrace	= 0;
	}
}

void	CallTrace::Dump ( const DNameNode & rd, pcchar_t sym, int line )
{
	if ( trace && !inTrace )
	{
		inTrace	= 1;
		rd.getString ( buf, 512 );
		buf[ rd.length ()] = 0;
		indent ( mark );
		fprintf ( fp, " > DNameNode '%s' #line %d : '%s' == '%s'\n", name, line, sym, buf );
		fflush ( fp );
		inTrace	= 0;
	}
}

void	CallTrace::Dump ( unsigned long ul, pcchar_t sym, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > ulong     '%s' #line %d : '%s' == '0x%08.08LX'\n",  name, line, sym, ul );
		fflush ( fp );
	}
}

void	CallTrace::Dump ( void* p, pcchar_t sym, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > void*     '%s' #line %d : '%s' == '%p'\n",  name, line, sym, p );
		fflush ( fp );
	}
}

void	CallTrace::Dump ( const char* p, pcchar_t sym, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > char*     '%s' #line %d : '%s' == '%s'\n",  name, line, sym, p );
		fflush ( fp );
	}
}

void	CallTrace::Track ( pcchar_t file, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > Track     '%s' : #line %d \"%s\"\n", name, line, file );
		fflush ( fp );
	}
}

void	CallTrace::LogError ( int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > Log Error '%s' : #line %d\n", name, line );
		fflush ( fp );
	}
}

void	CallTrace::Message ( pcchar_t msg, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > Message   '%s' : #line %d \"%s\"\n", name, line, msg );
		fflush ( fp );
	}
}
#endif	// STDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\vm.h ===
/* SCCSID = @(#)vm.h    4.2 86/07/21 */
/*
 *  vm.h
 *
 *  The following macros are used to define
 *  the virtual memory model.
 */

/* Definition for FPN type (file page number */
typedef unsigned short  FPN;
#define LG2FPN          1
/* Length of long in bits */
#define LONGLN          (BYTELN*sizeof(long))
/* Log (base 2) of page size */
#define LG2PAG          9
/* Log (base 2) of memory size */
#define LG2MEM          31
/* Length of page in bytes */
#define PAGLEN          (1U << LG2PAG)
/* Page offset of virtual address */
#define OFFSET(x)       ((short)((x) & ~(~0L << LG2PAG)))
/* Page number of virtual address */
#define PAGE(x)         ((x) >> LG2PAG)
/* Virtual address of page table entry for some virtual address x */
#define PTADDR(x)       (((x) >> (LG2PAG - LG2FPN)) & (~0L << LG2FPN))
/* Page number of page table entry for some virtual address x */
#define PTPAGE(x)       ((x) >> (LG2PAG + LG2PAG - LG2FPN))
/* Upper virtual address limit of PT0 */
#define LG2LP0          (LG2MEM - LG2PAG + LG2FPN)
#define LIMPT0          (1L << LG2LP0)
/* Upper virtual address limit of PT1 */
#define LG2LP1          (LG2LP0 - LG2PAG + LG2FPN)
#define LIMPT1          (1L << LG2LP1)
/* Upper virtual address limit of PT2 */
#define LG2LP2          (LG2LP1 - LG2PAG + LG2FPN)
#define LIMPT2          (1L << LG2LP2)
/* Length of PT2 in entries (longs) */
#define PT2LEN          (1L << (LG2LP1 - LG2PAG))
/* Maximum number of page buffers (hash table can be chars if MAXBUF <= 128) */
#if CPU386
#define MAXBUF          128
#elif OSEGEXE
#define MAXBUF          96
#else
#define MAXBUF          64
#endif

/* Virtual memory area definitions */
/*
 *      REMEMBER !!!!!!!!!!!!!!!!!!
 *
 *          EVERY item you store in virtual memory MUST !!!!!
 *          meet the condition PAGLEN % sizeof(your-item) == 0.
 */


#define AREASYMS        LIMPT0          /* Symbol table VM area start */
#define AREASRCLIN      (AREASYMS + (RBMAX << SYMSCALE))
                                        /* $$SRCLINES area start */
#define AREAPROPLST     (AREASRCLIN + (1L << 20))
#define AREABAKPAT      (AREAPROPLST + LXIVK)

#if EXE386

/* Begin area definitions for linear-executable */

#define AREAIMPS        (AREABAKPAT + LXIVK)
                                        /* Imported names table area */
#define AREAEAT         (AREAIMPS + 10*MEGABYTE)
                                        /* Export Address Table area */
#define AREAEATAUX      (AREAEAT + MEGABYTE)
                                        /* Auxiliary Data Table area */
#define AREAEP          (AREAEATAUX + MEGABYTE)
                                        /* Entry point area */
#define LG2BKT          6               /* Log of hash bucket size */
#define BKTLEN          (1 << LG2BKT)   /* Bucket length in bytes */
#define AREAHRC         (AREAEP + (LXIVK * sizeof(EPTYPE)))
                                        /* Chained relocation hash tables */
#define AREARC          (AREAHRC + MEGABYTE)
                                        /* Chained relocation hash buckets */
#define AREANAMEPTR     (AREARC + ((long) BKTLEN << WORDLN))
                                        /* Export Name Pointer Table */
#define NAMEPTRSIZE     MEGABYTE        /* 1Mb */
#define AREAORD         (AREANAMEPTR + NAMEPTRSIZE)
                                        /* Export Ordinal Table */
#define ORDTABSIZE      8*LXIVK         /* 0.5Mb */
#define AREAEXPNAME     (AREAORD + ORDTABSIZE)
                                        /* Export Name Table */
#define EXPNAMESIZE     64*MEGABYTE     /* 64Mb */
#define AREAST          (AREAEXPNAME + EXPNAMESIZE)
#define AREAMOD         (AREAST + LXIVK)
                                        /* Module Reference Table Area */
#define AREAHD          (AREAMOD + MEGABYTE)
#define AREAPDIR        (AREAHD + MEGABYTE)
#define AREAIMPMOD      (AREAPDIR + MEGABYTE)
#define AREAFPAGE       (AREAIMPMOD + MEGABYTE)
#define AREACV          (AREAFPAGE + MEGABYTE)
#define AREASORT        (AREACV + (32*MEGABYTE))
#define AREAEXESTR      (AREASORT + LXIVK)
#define AREACONTRIBUTION (AREAEXESTR + LXIVK)
#define AREAPAGERANGE   (AREACONTRIBUTION + LXIVK)
#define AREACVDNT       (AREAPAGERANGE + (8*MEGABYTE))
#define AREAFSA         (AREACVDNT + LXIVK)
                                        /* Segment area start */
#define AREASA(sa)      (mpsaVMArea[sa]) /* Virtual address of nth object */
#define AREAFREE        (0xffffffffL)
                                        /* First free VM address */
#else

/* Begin area definitions for protect-mode exes */

#define AREANRNT        (AREABAKPAT + LXIVK)
#define AREARNT         (AREANRNT + LXIVK)
#define AREAIMPS        (AREARNT + LXIVK)
                                        /* Imported names table area */
#define AREAET          (AREAIMPS + LXIVK)
                                        /* Entry Table area */
#define AREAEP          (AREAET + LXIVK)/* Entry point area */
#define LG2BKT          6               /* Log of hash bucket size */
#define BKTLEN          (1 << LG2BKT)   /* Bucket length in bytes */
#define AREAHRC         (AREAEP + (LXIVK * sizeof(EPTYPE)))
                                        /* Chained relocation hash tables */
#define AREARC          (AREAHRC + ((long) SAMAX * PAGLEN / 2))
                                        /* Chained relocation hash buckets */
#define AREAST          (AREARC + ((long) BKTLEN << WORDLN))
#define AREAMOD         (AREAST + LXIVK)/* Module Reference Table Area */
#define AREASORT        (AREAMOD + LXIVK)
#define AREAEXESTR      (AREASORT + (LXIVK << 2))
#define AREACONTRIBUTION (AREAEXESTR + LXIVK)
#define AREACVDNT       (AREACONTRIBUTION + LXIVK)
#define AREAFSA         (AREACVDNT + LXIVK)
#define AREASA(sa)      (AREAFSA + ((long) (sa) << WORDLN))
                                        /* Virtual address of nth segment */
#define AREAFREE        (AREAFSA + ((long) SAMAX << WORDLN))
                                        /* First free VM address */
#define AREACV          (AREAPACKRGRLE + MEGABYTE)
#endif

/* Virtual memory area definitions for DOS 3 exes */
#define AREAFSG         AREAFSA         /* Segment area start */
#define AREARGRLE       (AREAFSG + ((long) GSNMAX << 16))
                                        /* Relocation table area start */
#define LG2ARLE         17              /* Log (base 2) of reloc table size */
#define AREAPACKRGRLE   (AREARGRLE + (IOVMAX * (1L << LG2ARLE)))
                                        /* Packed relocation area start */

#define VPLIB1ST        (1L << (LG2MEM - LG2PAG))
                                        /* First page of library area
                                        *  NOTE: This page number cannot
                                        *  be derived from any legal virtual
                                        *  address.  Libraries will always be
                                        *  accessed by page number.
                                        */

/* Index of virtual page touched most recently */
short                   picur;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\implib\makefile.inc ===
!ifdef GENERATE_NEW_ERROR_FILES
..\impliber.c ..\impliber.h: ..\impliber.txt
        cd ..
        .\mkmsg -hex -h impliber.h -c impliber.c impliber.txt
        cd implib

..\implib.c: ..\implib.y ..\newexe.h ..\verimp.h ..\impliber.h
        cd ..
# myacc hard-codes temp file names, so we need to
# make sure this run and the one from ..\link16\makefile.inc
# don't happen at the same time on multiprocessor boxes.
        sleep 5
        .\myacc implib.y
        cd implib
!else
..\impliber.c ..\impliber.h:

..\implib.c:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\link16\makefile.inc ===
!ifdef GENERATE_NEW_ERROR_FILES
..\l3216msg.c ..\lnkmsg.h: ..\lnkmsg.eng ..\lnk5msg.lst
        cd ..
        findstr /g:lnk5msg.lst lnkmsg.eng > link16\l3216msg.msg
        mkmsg -hex -h lnkmsg.h -c l3216msg.c  link16\l3216msg.msg
        cd link16

..\newdef.c: ..\newdef.y ..\newexe.h ..\vm.h ..\config.h
        cd ..
        myacc newdef.y
        cd link16
!else

..\l3216msg.c ..\lnkmsg.h:
..\newdef.c:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\links\link.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define SHARE_ALL   (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)

int NumberOfLinks(char *FileName)
{

    FILE_STANDARD_INFORMATION FileInfo;

    WCHAR                     FileNameBuf[MAX_PATH + 50];

    HANDLE                    FileHandle;

    NTSTATUS                  Status;

    IO_STATUS_BLOCK           Iosb;

    OBJECT_ATTRIBUTES         Obj;

    UNICODE_STRING            uPrelimFileName,
                              uFileName;

    RtlCreateUnicodeStringFromAsciiz(&uPrelimFileName, FileName);

    lstrcpy(FileNameBuf, L"\\DosDevices\\");
    lstrcat(FileNameBuf, uPrelimFileName.Buffer);
    RtlInitUnicodeString(&uFileName, FileNameBuf);

    InitializeObjectAttributes(&Obj, &uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenFile(&FileHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        return 0;
    }

    Status = NtQueryInformationFile(FileHandle, &Iosb, &FileInfo,
        sizeof(FileInfo), FileStandardInformation);

    NtClose(FileHandle);

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        return 0;
    }

    return FileInfo.NumberOfLinks;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\linkd\linkd.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    linkd.c

    Simple utility to manipulate name graftings at directories.

Author:

    Felipe Cabrera    (Cabrera)   271-Aug-1997

Revision History:


--*/

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>              //  exit
#include <io.h>                  //  _get_osfhandle
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <locale.h>             //  setlocale


//
//  Functions forward referenced.
//


void
ScanArgs (
    int argc,
    char **argv
    );

void
__cdecl
printmessage (
    DWORD messageID,
    ...
    );

void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    );

BOOL
MassageLinkValue (
    IN LPCWSTR lpLinkName,
    IN LPCWSTR lpLinkValue,
    OUT PUNICODE_STRING NtLinkName,
    OUT PUNICODE_STRING NtLinkValue,
    OUT PUNICODE_STRING DosLinkValue
    );

void
__cdecl
printmessage (
    DWORD messageID,
    ...
    );

void
__cdecl
DisplayMsg (
    DWORD MsgNum,
    ...
    );

int
FileIsConsole (
    int fh
    );

//
//  I/O stream  handles and variables.
//

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

//
//  Core control state vars
//

BOOL     NeedHelp;
BOOL     DoCreate;
BOOL     DoDelete;
BOOL     DoQuery;
BOOL     DoEnumerate;

#include "linkdmsg.h"

TCHAR Buf[1024];                            // for displaying stuff

//
//  Main
//

void
__cdecl
main(
    int  argc,
    char **argv
    )

{
    CHAR    lBuf[16];
    DWORD   dwCodePage;
    LANGID  LangId;

    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;

    UNICODE_STRING UnicodeName;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;

    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    IO_STATUS_BLOCK IoStatusBlock;
    BOOL TranslationStatus;

    PVOID FreeBuffer;
    PVOID FreeBuffer2;

    FILE_DISPOSITION_INFORMATION Disposition;

    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer = NULL;
    ULONG ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;
    USHORT ReparseDataLength = 0;

    WCHAR WFileName[MAX_PATH + 2];
    WCHAR WFileNameTwo[MAX_PATH + 2];
    UCHAR Command[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];

    ULONG FsControlCode     = 0;
    ULONG CreateOptions     = 0;
    ULONG CreateDisposition = 0;
    ULONG DesiredAccess     = SYNCHRONIZE;

    //
    //  Build up state vector in global booleans.
    //

    ScanArgs(argc, argv);

    //
    // printf( "argc = %d NeedHelp = %d DoCreate = %d DoDelete = %d DoQuery = %d DoEnumerate = %d\n",
    //       argc, NeedHelp, DoCreate, DoDelete, DoQuery, DoEnumerate );
    //

    //
    //  Since FormatMessage checks the current TEB's locale, and the Locale for
    //  CHCP is initialized when the message class is initialized, the TEB has to
    //  be updated after the code page is changed successfully.
    //
    //  Why are we doing this, you ask.  Well, the FE guys have plans to add
    //  more than one set of language resources to this module, but not all
    //  the possible resources.  So this limited set is what they plan for.
    //  If FormatMessage can't find the right language, it falls back to
    //  something hopefully useful.
    //

    dwCodePage = GetConsoleOutputCP();

    sprintf(lBuf, ".%d", dwCodePage);

    switch( dwCodePage )
    {
    case 437:
        LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
        break;
    case 932:
        LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
        break;
    case 949:
        LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
        break;
    case 936:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
        break;
    case 950:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
        break;
    default:
        LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
        lBuf[0] = '\0';
        break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    setlocale(LC_ALL, lBuf);

    //
    //  Set the appropriate handles.
    //

    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN) ? TRUE : FALSE;

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT) ? TRUE : FALSE;

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR) ? TRUE : FALSE;

    //
    //  OK, we know the state of the command, do work
    //

    //
    // printf( "The parameters specified were: [0]%s [1]%s\n", argv[0], argv[1] );
    //

    //
    //  If they asked for help, or did something that indicates they don't
    //  understand how the program works, print help and exit.
    //

    if (NeedHelp) {
        printmessage( MSG_LINKD_HELP );
        exit(1);
    }

    //
    //  The enumeration of all mount points is not yet supported.
    //

    if (DoEnumerate) {
       printmessage( MSG_LINKD_HELP );
       exit(1);
    }

    //
    //  The following three calls require, at least, to have the SourceName of the operation.
    //  Thus, we have one NT file name that we will operate on.
    //  Change the string to Unicode and store it locally. Use it latter to open the file.
    //

    SzToWsz( WFileName, argv[1] );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            WFileName,
                            &UnicodeName,
                            NULL,
                            NULL
                            );

    if (!TranslationStatus) {
        printmessage( MSG_LINKD_WRONG_NAME );
        exit (1);
    }

    FreeBuffer = UnicodeName.Buffer;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // printf( "Transformed unicode str is %Z\n", &UnicodeName );
    //

    //
    //  Now go do the appropriate actions.
    //

    if (DoCreate) {

        //
        //  Set the code of the FSCTL operation.
        //

        FsControlCode = FSCTL_SET_REPARSE_POINT;

        //
        //  Set the open/create options for a directory.
        //

        CreateOptions = FILE_OPEN_REPARSE_POINT;

        //
        //  Set the tag to mount point.
        //

        ReparsePointTag = IO_REPARSE_TAG_MOUNT_POINT;

        //
        //  Open to set the reparse point.
        //

        DesiredAccess |= FILE_WRITE_DATA;
        CreateDisposition = FILE_OPEN;             // the file must be present

        Status = NtCreateFile(
                     &Handle,
                     DesiredAccess,
                     &ObjectAttributes,
                     &IoStatusBlock,
                     NULL,                         // pallocationsize (none!)
                     FILE_ATTRIBUTE_NORMAL,        // attributes to be set if created
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     CreateDisposition,
                     CreateOptions,
                     NULL,                         // EA buffer (none!)
                     0
                     );

        //
        //  Create a directory if you do not find it.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            DesiredAccess = SYNCHRONIZE;
            CreateDisposition = FILE_CREATE;
            CreateOptions = FILE_DIRECTORY_FILE;

            Status = NtCreateFile(
                         &Handle,
                         DesiredAccess,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         NULL,                         // pallocationsize (none!)
                         FILE_ATTRIBUTE_NORMAL,        // attributes to be set if created
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         CreateDisposition,
                         CreateOptions,
                         NULL,                         // EA buffer (none!)
                         0
                         );

            if (!NT_SUCCESS(Status)) {
                printmessage( MSG_LINKD_CREATE_FAILED );
                exit (1);
            }

            //
            //  Close the handle and re-open.
            //

            NtClose( Handle );

            CreateOptions = FILE_OPEN_REPARSE_POINT;
            DesiredAccess |= FILE_WRITE_DATA;
            CreateDisposition = FILE_OPEN;             // the file must be present

            Status = NtCreateFile(
                         &Handle,
                         DesiredAccess,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         NULL,                         // pallocationsize (none!)
                         FILE_ATTRIBUTE_NORMAL,        // attributes to be set if created
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         CreateDisposition,
                         CreateOptions,
                         NULL,                         // EA buffer (none!)
                         0
                         );

        }

        RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );

        if (!NT_SUCCESS(Status)) {

            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_OPEN_FAILED, Buf);
            // printmessage( MSG_LINKD_OPEN_FAILED );
            exit (1);
        }

        //
        //  Build the appropriate buffer for mount points and for symbolic links.
        //

        if ((ReparsePointTag == IO_REPARSE_TAG_MOUNT_POINT) ||
            (ReparsePointTag == IO_REPARSE_TAG_SYMBOLIC_LINK)) {

            //
            //  The value of the mount point or of the symbolic link comes in argv[2].
            //

            SzToWsz( WFileName, argv[1] );
            SzToWsz( WFileNameTwo, argv[2] );

            //
            //  Innitialize the DosName buffer.
            //

            DosLinkValue.Buffer = FullPathLinkValue;
            DosLinkValue.MaximumLength = sizeof( FullPathLinkValue );
            DosLinkValue.Length = 0;

            //
            //  Massage all the names.
            //

            if (!MassageLinkValue( WFileName, WFileNameTwo, &NtLinkName, &NtLinkValue, &DosLinkValue )) {

                if (DosLinkValue.Length == 0) {
                    printmessage( MSG_LINKD_WRONG_NAME );
                }
                else {
                    printmessage( MSG_LINKD_PATH_NOT_FOUND );
                }

                RtlFreeUnicodeString( &NtLinkName );
                RtlFreeUnicodeString( &NtLinkValue );

                exit (1);
            }

            //
            // printf( "NtLinkName %Z\n", &NtLinkName );
            // printf( "NtLinkValue %Z\n", &NtLinkValue );
            // printf( "DosLinkValue is %Z\n", &DosLinkValue );
            // printf( "NtLinkValue.Length %d DosLinkValue.Length %d sizeof(UNICODE_NULL) %d\n",
            //        NtLinkValue.Length, DosLinkValue.Length, sizeof(UNICODE_NULL) );
            //

            RtlFreeUnicodeString( &NtLinkName );

            //
            //  Set the reparse point with mount point or symbolic link tag and determine
            //  the appropriate length of the buffer.
            //

            //
            // printf( "FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) - REPARSE_DATA_BUFFER_HEADER_SIZE %d\n",
            //       (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) - REPARSE_DATA_BUFFER_HEADER_SIZE) );
            //

            ReparseDataLength = (USHORT)((FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) -
                                REPARSE_DATA_BUFFER_HEADER_SIZE) +
                                NtLinkValue.Length + sizeof(UNICODE_NULL) +
                                DosLinkValue.Length + sizeof(UNICODE_NULL));

            //
            // printf( "ReparseDataLength %d\n", ReparseDataLength );
            //

            //
            //  Allocate a buffer to set the reparse point.
            //

            ReparseBufferHeader = (PREPARSE_DATA_BUFFER)RtlAllocateHeap(
                                                            RtlProcessHeap(),
                                                            HEAP_ZERO_MEMORY,
                                                            REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength
                                                            );

            if (ReparseBufferHeader == NULL) {

                NtClose( Handle );
                RtlFreeUnicodeString( &NtLinkValue );
                printmessage( MSG_LINKD_NO_MEMORY );
                exit (1);
            }

            //
            //  Setting the buffer is common for both tags as their buffers have identical fields.
            //

            ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
            ReparseBufferHeader->Reserved = 0;
            ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
            ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = NtLinkValue.Length;
            ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = NtLinkValue.Length + sizeof( UNICODE_NULL );
            ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = DosLinkValue.Length;
            RtlCopyMemory(
                ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                NtLinkValue.Buffer,
                NtLinkValue.Length
                );
            RtlCopyMemory(
                (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                NtLinkValue.Length + sizeof(UNICODE_NULL),
                DosLinkValue.Buffer,
                DosLinkValue.Length
                );

            RtlFreeUnicodeString( &NtLinkValue );
        }

        //
        //  Set the tag in common, once for all possible cases.
        //

        ReparseBufferHeader->ReparseTag = ReparsePointTag;

        //
        //  Set the reparse point.
        //

        Status = NtFsControlFile(
                     Handle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FsControlCode,
                     ReparseBufferHeader,
                     REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseBufferHeader->ReparseDataLength,
                     NULL,                // no output buffer
                     0                    // output buffer length
                     );

        //
        //  Close the file.
        //

        NtClose( Handle );

        if (!NT_SUCCESS(Status)) {

            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_SET_OPERATION_FAILED, Buf);
            // printmessage( MSG_LINKD_SET_OPERATION_FAILED );
            exit (1);
        }

        SzToWsz( WFileName, argv[1] );
        swprintf(&Buf[0], TEXT("%s"), WFileName);
        DisplayMsg(MSG_LINKD_CREATE_OPERATION_SUCCESS, Buf);
        // printmessage( MSG_LINKD_CREATE_OPERATION_SUCCESS );
    }

    if (DoDelete) {

        FILE_DISPOSITION_INFORMATION Disposition = {TRUE};

        //
        // Open the file for delete access.
        // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
        // This will get a handle to the entity whether the appropriate filter is or not in place.
        //

        Status = NtOpenFile(
                     &Handle,
                     (ACCESS_MASK)DELETE,
                     &ObjectAttributes,
                     &IoStatusBlock,
                     FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                     FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                     );

        if (!NT_SUCCESS(Status)) {

            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_OPEN_FAILED, Buf);
            // printmessage( MSG_LINKD_OPEN_FAILED );
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            exit(1);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

        //
        // Delete the file
        //

        Status = NtSetInformationFile(
                     Handle,
                     &IoStatusBlock,
                     &Disposition,
                     sizeof(Disposition),
                     FileDispositionInformation
                     );

        NtClose(Handle);

        if (!NT_SUCCESS(Status)) {
            printmessage( MSG_LINKD_DELETE_OPERATION_FAILED );
            exit(1);
        }

        printmessage( MSG_LINKD_DELETE_OPERATION_SUCCESS );
    }

    if (DoQuery) {

        //
        //  Set the code of the FSCTL operation.
        //

        FsControlCode = FSCTL_GET_REPARSE_POINT;

        //
        //  We do not specify whether it is a file or a directory to get either.
        //

        DesiredAccess = FILE_READ_DATA | SYNCHRONIZE;
        CreateOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;

        //
        //  Open the reparse point for query.
        //

        Status = NtOpenFile(
                     &Handle,
                     DesiredAccess,
                     &ObjectAttributes,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     CreateOptions
                     );
        //
        //  Free the name buffer as we are done with it.
        //

        RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );

        if (!NT_SUCCESS(Status)) {

            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_OPEN_FAILED, Buf);
            // printmessage( MSG_LINKD_OPEN_FAILED );
            exit (1);
        }

        //
        //  Query the reparse point.
        //
        //  We are use the approach of passing a buffer of well-known length:
        //  MAXIMUM_REPARSE_DATA_BUFFER_SIZE

        //
        //  Allocate a buffer and get the information.
        //

        ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
        ReparseBuffer = RtlAllocateHeap(
                            RtlProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            ReparseDataLength
                            );

        if (ReparseBuffer == NULL) {
            printmessage( MSG_LINKD_NO_MEMORY );
            exit (1);
        }

        //
        //  Now go and get the data.
        //

        Status = NtFsControlFile(
                     Handle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FsControlCode,        // no input buffer
                     NULL,                 // input buffer length
                     0,
                     (PVOID)ReparseBuffer,
                     ReparseDataLength
                     );

        //
        // printf( "Status %x IoStatusBlock.Status %x IoStatusBlock.Information %x\n", Status, IoStatusBlock.Status, IoStatusBlock.Information );
        //

        if (!NT_SUCCESS(Status)) {
            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_GET_OPERATION_FAILED, Buf);
            NtClose( Handle );
            RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
            exit (1);
        }

        //
        //  Close the file and free the buffer.
        //

        NtClose( Handle );

        //
        //  Display the buffer.
        //

        ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;

        if ((ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) ||
            (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK)) {

            USHORT Offset = 0;

            NtLinkValue.Buffer = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[Offset];
            NtLinkValue.Length = ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength;
            Offset = NtLinkValue.Length + sizeof(UNICODE_NULL);
            DosLinkValue.Buffer = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[Offset/sizeof(WCHAR)];
            DosLinkValue.Length = ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength;

            //
            // printf( "NtLinkValue.Length %d DosLinkValue.Length %d\n", NtLinkValue.Length, DosLinkValue.Length );
            // printf( " NtLinkValue:  %Z\n", &NtLinkValue );
            // printf( "DosLinkValue:  %Z\n", &DosLinkValue );
            //

            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_DISPLAY_NL_A, Buf);

            swprintf(&Buf[0], TEXT("%s"), DosLinkValue.Buffer);
            DisplayMsg(MSG_LINKD_DISPLAY_NL, Buf);
        }

        else {
            SzToWsz( WFileName, argv[1] );
            swprintf(&Buf[0], TEXT("%s"), WFileName);
            DisplayMsg(MSG_LINKD_GET_OPERATION_FAILED, Buf);
        }

        //
        //  Free the buffer.
        //

        RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
    }

    //
    // Final exit point.
    //

    exit (0);
}  // main




//
//  Changing a file name to wide characters.
//

void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
} // SzToWsz


//
//  Name transformations to create a legitimate mount point or a symbolic link.
//

BOOL
MassageLinkValue(
    IN LPCWSTR lpLinkName,
    IN LPCWSTR lpLinkValue,
    OUT PUNICODE_STRING NtLinkName,
    OUT PUNICODE_STRING NtLinkValue,
    OUT PUNICODE_STRING DosLinkValue
    )
{
    PWSTR FilePart;
    PWSTR s, sBegin, sBackupLimit, sLinkName;
    NTSTATUS Status;
    USHORT nSaveNtNameLength;
    ULONG nLevels;

    //
    // Initialize output variables to NULL
    //

    RtlInitUnicodeString( NtLinkName, NULL );
    RtlInitUnicodeString( NtLinkValue, NULL );

    //
    // Translate link name into full NT path.
    //

    if (!RtlDosPathNameToNtPathName_U( lpLinkName,
                                       NtLinkName,
                                       &sLinkName,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    //
    // All done if no link value.
    //

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        return TRUE;
        }

    //
    // If the target is a device, do not allow the link.
    //

    if (RtlIsDosDeviceName_U( (PWSTR)lpLinkValue )) {
        return FALSE;
        }

    //
    // Convert to DOS path to full path, and get Nt representation
    // of DOS path.
    //

    if (!RtlGetFullPathName_U( lpLinkValue,
                               DosLinkValue->MaximumLength,
                               DosLinkValue->Buffer,
                               NULL
                             )
       ) {
        return FALSE;
        }
    DosLinkValue->Length = wcslen( DosLinkValue->Buffer ) * sizeof( WCHAR );

    //
    // Verify that the link value is a valid NT name.
    //

    if (!RtlDosPathNameToNtPathName_U( DosLinkValue->Buffer,
                                       NtLinkValue,
                                       NULL,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    return TRUE;
}  // MassageLinkValue


VOID
ScanArgs(
    int     argc,
    char    **argv
    )
/*++

Routine Description:

    ScanArgs - parse command line arguments, and set control flags
                to reflect what we find.

    Sets:
         NeedHelp;
         DoCreate;
         DoDelete;
         DoQuery;
         DoEnumerate;

Arguments:

    argc - count of command line args

    argv - argument vector

Return Value:

--*/
{
    int i;

    NeedHelp = FALSE;
    DoCreate = FALSE;
    DoDelete = FALSE;
    DoQuery = FALSE;
    DoEnumerate = FALSE;

    //
    //  The valid calls are:
    //
    //     linkd  sourceName valueName     -- create a directory name grafting
    //     linkd  sourceName /d            -- delete a directory name grafting
    //     linkd  sourceName               -- to query the value of the name grafting
    //     linkd  /?                       -- print help
    //     linkd                           -- to enumerate all the name graftings
    //


    if (argc > 3) {
        NeedHelp = TRUE;
        goto done;
    }

    if (argc == 1) {
        DoEnumerate = TRUE;
        goto done;
    }

    if (argc == 2) {

        if ( (argv[1][0] == '/') &&
             (argv[1][1] == '?') &&
             (strlen(argv[1]) == 2) ) {
            NeedHelp = TRUE;
            goto done;
        }

        DoQuery = TRUE;
        goto done;
    }

    if (argc == 3) {

        if ( (argv[2][0] == '/') &&
             ((argv[2][1] == 'd') || (argv[2][1] == 'D')) &&
             (strlen(argv[2]) == 2) ) {
            DoDelete = TRUE;
            goto done;
        }

        DoCreate = TRUE;
        goto done;
    }

done:
    return;
} // ScanArgs


//
// Call FormatMessage and dump the result.  All messages to Stdout
//
void
__cdecl
printmessage (
    DWORD messageID,
    ...
    )
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                  messagebuffer, 4095, &ap);

    wprintf(messagebuffer);

    va_end(ap);
}  // printmessage


TCHAR DisplayBuffer[4096];
CHAR DisplayBuffer2[4096];

void
__cdecl
DisplayMsg (
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MsgNum, 0,
        DisplayBuffer, 4096, &ap);

    if (ConsoleOutput) {
        success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hOutput, (LPVOID)DisplayBuffer2, len,
                 &bytes_written, NULL);
    }

    if (!success || bytes_written != len) {
        status = GetLastError();
    }

    va_end(ap);
} // DisplayMsg


int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

} // FileIsConsole
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\lcut.c ===
#include <stdio.h>
#include <malloc.h>
#include <windows.h>
#include "list.h"


void
UpdateHighLighted (
    int dlen,
    int end
    )
{
    int     i;
    long    l;

    ScrLock   (1);
    if (vHighLen + dlen == 0  &&  vHighLen) {
        i = vAttrHigh;
        vAttrHigh = vAttrList;
        vHLBot = vHLTop;
        UpdateHighNoLock ();
        vAttrHigh = (WORD) i;
    }
    vHighLen += dlen;
    UpdateHighNoLock ();
    ScrUnLock ();

    switch (end) {
        case 1:
            l = vHighTop + (vHighLen < 0 ? vHighLen : 0);
            if (l < vTopLine) {
                vTopLine = l;
                SetUpdate (U_ALL);
            }
            break;
        case 2:
            l = vHighTop + (vHighLen > 0 ? vHighLen : 0);
            if (l > vTopLine+vLines-1) {
                vTopLine = l - vLines + 1;
                SetUpdate (U_ALL);
            }
            break;
        case 3:
            l = vHighTop + vHighLen;
            if (l < vTopLine) {
                vTopLine = l;
                SetUpdate (U_ALL);
            } else if (l > vTopLine+vLines-1) {
                vTopLine = l - vLines + 1;
                SetUpdate (U_ALL);
            }
            break;
    }
}


void
UpdateHighClear ()
{
    int     i;

    ScrLock (1);

    if (vHLTop)
        for (i=vHLTop; i <= vHLBot; i++)
            if (i >= 1  &&  i <= vLines)
                setattr1 (i, (char) vAttrList);

    vHLTop = vHLBot = 0;
    vHighTop = -1L;

    ScrUnLock ();
}


void
MarkSpot ()
{
    UpdateHighClear ();
    vHighTop = vTopLine + vLines / 2;
    if (vHighTop >= vLastLine)
        vHighTop = vLastLine - 1;
    vHighLen = 0;
    UpdateHighLighted (0, 0);
}


void
UpdateHighNoLock ()
{
    int     TopLine, BotLine;
    int     i;

    if (vHighLen == 0) {
        if (vHLTop)
            setattr1 (vHLTop, (char) vAttrList);
        if (vHighTop < vTopLine  ||  vHighTop > vTopLine+vLines-1) {
            vHLTop = vHLBot = 0;
            return;
        }
        vHLTop = vHLBot = (char)(vHighTop - vTopLine + 1);
        setattr1 (vHLTop, (char)vAttrHigh);
        return;
    }


    if (vHighLen < 0) {
        TopLine = (int)(vHighTop + vHighLen - vTopLine);
        BotLine = (int)(vHighTop - vTopLine);
    } else {
        TopLine = (int)(vHighTop - vTopLine);
        BotLine = (int)(vHighTop + vHighLen - vTopLine);
    }

    TopLine ++;
    BotLine ++;

    for (i=1; i <= vLines; i++) {
        if (i >= TopLine &&  i <= BotLine) {
            if (i < vHLTop  ||  i > vHLBot)
                setattr1 (i, (char)vAttrHigh);
        } else
            if (i >= vHLTop  &&  i <= vHLBot)
            setattr1 (i, (char)vAttrList);
    }

    vHLTop = (char)(TopLine < 1 ? 1 : TopLine);
    vHLBot = (char)(BotLine > vLines ? (int)vLines : BotLine);
}


void
FileHighLighted ()
{
    char    *data;
    char    s[50];
    char    c, lastc;
    FILE    *fp;

    long    hTopLine;
    long    CurLine, BotLine;
    long    LastOffset, CurOffset;


    if (vHighTop < 0L)      //     || vHighLen == 0
        return;

    GetInput ("File As> ", s, 40);
    if (s[0] == 0) {
        SetUpdate (U_HEAD);
        return;
    }
    fp = fopen( s, "a+b" );
    ckerr (fp == NULL, "Could not create or open file");

    DisLn (0, (Uchar)vLines+1, "Saving...");

    if (vHighLen < 0) {
        CurLine = vHighTop + vHighLen;
        BotLine = vHighTop;
    } else {
        CurLine = vHighTop;
        BotLine = vHighTop + vHighLen;
    }

    hTopLine = vTopLine;
    vTopLine = CurLine;
    QuickRestore ();            /* Jump to starting line    */
    while (InfoReady () == 0) {     /* Set extern values        */
        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }

    lastc = 0;
    BotLine ++;
    CurOffset  = vpBlockTop->offset + vOffTop;
    LastOffset = vprgLineTable[BotLine/PLINES][BotLine%PLINES];

    while (CurOffset++ < LastOffset) {
        data = vpBlockTop->Data;
        data += vOffTop;
        c = *data;
        if (c == '\n'  ||  c == '\r') {
            if ((c == '\n' && lastc == '\r') || (c == '\r' && lastc == '\n'))
                lastc = 0;
            else {
                lastc = c;
                fputc ('\r', fp);
                fputc ('\n', fp);
            }
        } else  fputc (lastc=c, fp);

        vOffTop++;
        if (vOffTop >= BLOCKSIZE) {
            ckdebug (vpBlockTop->flag == F_EOF, "internal error");
            while (vpBlockTop->next == NULL) {
                vpCur = vpBlockTop;
                vReaderFlag = F_DOWN;
                SetEvent   (vSemReader);
                WaitForSingleObject(vSemMoreData, WAITFOREVER);
                ResetEvent(vSemMoreData);
            }
            vOffTop = 0;
            vpBlockTop = vpBlockTop->next;
        }
    }

    fclose (fp);
    vTopLine = hTopLine;
    QuickRestore ();
    SetUpdate (U_ALL);
}


void
HUp ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop > 0L  &&  vHighTop+vHighLen > 0L)
        UpdateHighLighted (-1, 3);
}

void
HDn ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop+vHighLen < vLastLine)
        UpdateHighLighted (+1, 3);
}


void
HPgDn ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop+vHighLen+vLines < vLastLine)
        UpdateHighLighted (+vLines, 3);
}

void
HPgUp ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop > 0L  &&  vHighTop+vHighLen-vLines > 0L)
        UpdateHighLighted (-vLines, 3);
}


void
HSDn ()     /* Highlight Slide dn 1     */
{
    if (vHighTop < vLastLine && vHighTop >= 0L &&
        vHighTop+vHighLen < vLastLine) {
        vHighTop++;
        UpdateHighLighted (0, 2);
    }
}

void
HSUp()      /* Highlight Slike up 1     */
{
    if (vHighTop > 0L  &&  vHighTop+vHighLen > 0L) {
        vHighTop--;
        UpdateHighLighted (0, 1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\links\links.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define GetFileAttributeError 0xFFFFFFFF

int NumberOfLinks(char *FileName);

void __cdecl main (int ArgNumber, char **Args)
{
    DWORD Attributes = GetFileAttributeError;
    int Counter = 0;
    char *File;

    if (ArgNumber > 1) {

        for (Counter = 1; Counter < ArgNumber; Counter++) {
            DWORD dwErr;

            Attributes = GetFileAttributes(Args[Counter]);
            if (Attributes == GetFileAttributeError) {
                dwErr = GetLastError();
                fprintf(stderr, "Error opening %s: %d\n", Args[Counter], dwErr);
                exit(dwErr);
            }

            File = _strlwr(_fullpath( NULL, Args[Counter], 0));

            fprintf(stdout, "%s: %d\n", File, NumberOfLinks(File));
         }

    } else {
        fprintf(stderr, "\nUsage: %s file [file]\n", Args[0]);
    }

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\linit.c ===
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <stdlib.h>
#include <windows.h>
#include "list.h"


static char  iniFlag = 0;       /* If ini found, but not list change to 1   */
                                /* Will print a warning upon exit           */
char szScrollBarUp[2];
char szScrollBarDown[2];
char szScrollBarOff[2];
char szScrollBarOn[2];

void
init_list ()
{
    LPVOID      lpParameter = NULL;
    DWORD       dwThreadId;

    switch (GetConsoleCP()) {
        case 932:
            szScrollBarUp[0] =  '\x1c';
            szScrollBarDown[0] = '\x07';
            szScrollBarOff[0] = '\x1a';
            szScrollBarOn[0] = '\x14';
            break;

        default:
            szScrollBarUp[0] = '\x18';
            szScrollBarDown[0] = '\x19';
            szScrollBarOff[0] = '\xB1';
            szScrollBarOn[0] = '\xDB';
            break;
    }

    /*
     * Init Misc
     */
    ResetEvent (vSemSync);
    ResetEvent (vSemMoreData);

    /*
     * Init screen parameters
     */

    GetConsoleScreenBufferInfo( vStdOut,
                                &vConsoleOrigScrBufferInfo );

    vConsoleOrigScrBufferInfo.dwSize.X=
        vConsoleOrigScrBufferInfo.srWindow.Right-
        vConsoleOrigScrBufferInfo.srWindow.Left + 1;
    vConsoleOrigScrBufferInfo.dwSize.Y=
        vConsoleOrigScrBufferInfo.srWindow.Bottom-
        vConsoleOrigScrBufferInfo.srWindow.Top + 1;
    vConsoleOrigScrBufferInfo.dwMaximumWindowSize=
        vConsoleOrigScrBufferInfo.dwSize;

    set_mode( 0, 0, 0 );

    /*
     *  Start reading the first file. Displaying can't start until
     *  the ini file (if one is found) is processed.
     */
    vReaderFlag = F_NEXT;

    /*
     *  Init priority setting for display & reader thread.
     *
     *      THREAD_PRIORITY_NORMAL       = reader thread normal pri.
     *      THREAD_PRIORITY_ABOVE_NORMAL = display thread pri
     *      THREAD_PRIORITY_HIGHEST      = reader thread in boosted pri.
     */
    vReadPriNormal = THREAD_PRIORITY_NORMAL;
    SetThreadPriority( GetCurrentThread(),
                       THREAD_PRIORITY_ABOVE_NORMAL );
    vReadPriBoost = THREAD_PRIORITY_NORMAL;


    /*
     *  Start reader thread
     */
    CreateThread( NULL,
                  STACKSIZE,
                  (LPTHREAD_START_ROUTINE) ReaderThread,
                  NULL, // lpParameter,
                  0, // THREAD_ALL_ACCESS,
                  &dwThreadId );


    /*
     *  Read INI information.
     */
    vSetWidth = vWidth;                     /* Set defaults             */
    vSetLines = vLines + 2;

    FindIni ();
    if (vSetBlks < vMaxBlks)
        vSetBlks  = DEFBLKS;

    vSetThres = (long) (vSetBlks/2-2) * BLOCKSIZE;

    /*
     *  Must wait for reader thread to at least read in the
     *  first block. Also, if the file was not found and only
     *  one file was specifed the reader thread will display
     *  an error and exit... if we don't wait we could have
     *  changed the screen before this was possible.
     */
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);

    /*
     *  Now that ini file has been read. Set parameters.
     *  Pause reader thread while adjusting buffer size.
     */
    SyncReader ();

    vMaxBlks    = vSetBlks;
    vThreshold  = vSetThres;
    vReaderFlag = F_CHECK;
    SetEvent   (vSemReader);

    /*
     *  Now set to user's default video mode
     */

    set_mode (vSetLines, vSetWidth, 0);

    SetConsoleActiveScreenBuffer( vhConsoleOutput );
}


/***
 *  Warning: Reader thread must not be running when this routine
 *  is called.
 */
void
AddFileToList (
    char *fname
    )
{
    unsigned    rbLen;
    HANDLE      hDir;
    struct {
        WIN32_FIND_DATA rb;
        char    overflow[256];          /* HACK! OS/2 1.2? longer       */
    } x;
    struct Flist *pOrig, *pSort;
    char        *pTmp, *fpTmp;
    char        s[256];                /* Max filename length          */
    BOOL        fNextFile;

    rbLen = sizeof (x);                 /* rb+tmp. For large fnames     */
    pOrig = NULL;
    if (strpbrk (fname, "*?"))  {   /* Wildcard in filename?    */
                                    /* Yes, explode it      */
        hDir = FindFirstFile (fname, &x.rb);
        fNextFile = ( hDir == INVALID_HANDLE_VALUE )? FALSE : TRUE;
        pTmp = strrchr (fname, '\\');
        if (pTmp == NULL)   pTmp = strrchr (fname, ':');
        if (pTmp)   pTmp[1] = 0;

        while (fNextFile) {
            if( ( x.rb.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 ) {
                //
                // The file found is not a directory
                //
                if (pTmp) {
                    strcpy (s, fname);      /* Was there a releative path?  */
                    strcat (s, x.rb.cFileName); /* Yes, it's needed for Open    */
                    AddOneName (s);
                } else {
                    AddOneName (x.rb.cFileName);
                }
            }
            fNextFile = FindNextFile (hDir, &x.rb);
            if (pOrig == NULL)
                pOrig = vpFlCur;
        }
    }

    if (!pOrig)                         /* Did not explode, then add    */
        AddOneName (fname);             /* original name to list        */
    else {                              /* Yes, then sort the new fnames*/
        while (pOrig != vpFlCur) {
            pSort = pOrig->next;
            for (; ;) {
                if (strcmp (pOrig->fname, pSort->fname) > 0) {
                    /*
                     * Can simply switch names at this time, since no
                     * other information has been stored into the new
                     * file structs
                     */
                    fpTmp = pOrig->fname;
                    pOrig->fname = pSort->fname;
                    pSort->fname = fpTmp;
                    fpTmp = pOrig->rootname;
                    pOrig->rootname = pSort->rootname;
                    pSort->rootname = fpTmp;
                }
                if (pSort == vpFlCur)
                    break;
                pSort = pSort->next;
            }
            pOrig = pOrig->next;
        }
    }
}


void
AddOneName (
    char *fname
    )
{
    struct Flist *npt;
    char    *pt;
    char    s[30];
    int     i;

    npt =  (struct Flist *) malloc (sizeof (struct Flist));
    if (!npt) {
        printf("Out of memory\n");
        exit(1);
    }
    npt->fname = _strdup (fname);

    pt = strrchr (fname, '\\');
    pt = pt == NULL ? fname : pt+1;
    i = strlen (pt);
    if (i > 20) {
        memcpy (s,    pt, 17);
        strcpy (s+17, "...");
        npt->rootname = _strdup (s);
    } else
        npt->rootname = _strdup (pt);

    npt->FileTime.dwLowDateTime = (unsigned)-1;      /* Cause info to be invalid     */
    npt->FileTime.dwHighDateTime = (unsigned)-1;     /* Cause info to be invalid     */
    npt->HighTop  = -1;
    npt->SlimeTOF = 0L;
    npt->Wrap     = 0;
    npt->prev  = vpFlCur;
    npt->next  = NULL;
    memset (npt->prgLineTable, 0, sizeof (long *) * MAXTPAGE);

    if (vpFlCur) {
        if (vpFlCur->next) {
            npt->next = vpFlCur->next;
            vpFlCur->next->prev = npt;
        }
        vpFlCur->next = npt;
    }
    vpFlCur = npt;
}


void
FindIni ()
{
    static  char    Delim[] = " :=;\t\r\n";
    FILE    *fp;
    char    *env, *verb, *value;
    char    s [200];
    long    l;

    env = getenv ("INIT");
    if (env == NULL)
        return;
    
    if ((strlen(env) + sizeof ("\\TOOLS.INI") + 1) > 200)
        return;

    strcpy (s, env);
    strcat (s, "\\TOOLS.INI");
    fp = fopen (s, "r");
    if (fp == NULL)
        return;

    iniFlag = 1;
    while (fgets (s, 200, fp) != NULL) {
        if ((s[0] != '[')||(s[5] != ']'))
            continue;
        _strupr (s);
        if (strstr (s, "LIST") == NULL)
            continue;
        /*
         *  ini file found w/ "list" keyword. Now read it.
         */
        iniFlag = 0;
        while (fgets (s, 200, fp) != NULL) {
            if (s[0] == '[')
                break;
            if (s[0] == ';')
                continue;
            verb  = strtok (s, Delim);
            value = strtok (NULL, Delim);
            if (verb == NULL)
                continue;
            if (value == NULL)
                value = "";

            _strupr (verb);
            if (strcmp (verb, "TAB") == 0)          vDisTab = (Uchar)atoi(value);
            else if (strcmp (verb, "WIDTH")   == 0) vSetWidth = atoi(value);
            else if (strcmp (verb, "HEIGHT")  == 0) vSetLines = atoi(value);
            else if (strcmp (verb, "LCOLOR")  == 0) vAttrList = (WORD)xtoi(value);
            else if (strcmp (verb, "TCOLOR")  == 0) vAttrTitle= (WORD)xtoi(value);
            else if (strcmp (verb, "CCOLOR")  == 0) vAttrCmd  = (WORD)xtoi(value);
            else if (strcmp (verb, "HCOLOR")  == 0) vAttrHigh = (WORD)xtoi(value);
            else if (strcmp (verb, "KCOLOR")  == 0) vAttrKey  = (WORD)xtoi(value);
            else if (strcmp (verb, "BCOLOR")  == 0) vAttrBar  = (WORD)xtoi(value);
            else if (strcmp (verb, "BUFFERS") == 0)  {
                        l = atoi (value) * 1024L / ((long) BLOCKSIZE);
                        vSetBlks = (int)l;
            }
            else if (strcmp (verb, "HACK") == 0)    vIniFlag |= I_SLIME;
            else if (strcmp (verb, "NOBEEP") == 0)  vIniFlag |= I_NOBEEP;
        }
        break;
    }
    fclose (fp);
}


/*** xtoi - Hex to int
 *
 *  Entry:
 *      pt -    pointer to hex number
 *
 *  Return:
 *      value of hex number
 *
 */
unsigned
xtoi (
    char *pt
    )
{
    unsigned    u;
    char        c;

    u = 0;
    while (c = *(pt++)) {
        if (c >= 'a'  &&  c <= 'f')
            c -= 'a' - 'A';
        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F'))
            u = u << 4  |  c - (c >= 'A' ? 'A'-10 : '0');
    }
    return (u);
}


void
CleanUp (
    void
    )
{
    SetConsoleActiveScreenBuffer( vStdOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\ldisp.c ===
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <windows.h>
#include "list.h"


extern  void  DisTopDown(void);

void
Update_head ()
{
    char    s[80], t[20], u[20];

    /*
     *  Display file location (line #)
     */
    t[0] = 0;
    if (vLastLine < NOLASTLINE)
        sprintf (t, " of %ld", vLastLine);

    if (vIndent)
        sprintf (u,  "Col %d-%d", vIndent, vIndent+vWidth-1);
    else
        strcpy (u, "           ");

    sprintf (s, "Line: %ld%s  %s    ", vTopLine, t, u);
    dis_str (22, 0, s);
}


void
Update_display ()
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    /*
     *  Is the full display in memory?
     *  If not, block on MoreData.
     */
    while (InfoReady () == 0) {
        if (ScrLock (0) == 0)  {
            Update_head ();
            DisLn (vWidth-6, vLines+1, "WAIT");
            ScrUnLock ();
        }
        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }

    /*
     *  Value which InfoReady set:
     *  vpCur, vOffTop, vpBlockTop, vrgNewLen.
     *  Also complete video range is in memory. It should
     *  stay there. The reader thread should not be discarding
     *  data on the screen. Only at the other end of the chain.
     *  (home may have a race condition... should check this)
     */

    DisTopDown();

    dwWriteCoord.X = 0;
    dwWriteCoord.Y = 1;
    WriteConsoleOutputCharacter( vhConsoleOutput,
                                ( LPSTR ) vScrBuf+vWidth,
                                vSizeScrBuf-vWidth,
                                dwWriteCoord,
                                &dwNumWritten );
    if (vHighTop >= 0L)
        UpdateHighNoLock ();
}


void
calc_percent ()
{
    char    c;
    long    l;

    if (vTopLine+vLines >= vLastLine) {
        l = 100;
    } else {
        if (vTopLine == 0L) {
            l = 0L;
        } else {
            l = (vpCalcBlock->offset+vOffTop)*100L/(vFInfo.nFileSizeLow-vScrMass);
            if (l > 100L)
                l = 100;
        }
    }

    /*
     * Update thumb on scroll bar
     */
    c = (char)(((long) (vLines - 3) * l + 5L) / 100L);
    if  (c < 0)
        c = 0;
    else if (c > (char)(vLines - 3))
        c = (char)(vLines-3);
    c += 2;                         /* Adjust to first scroll bar line  */
    if (vLastBar != c) {
        dis_str ((Uchar)(vWidth-1), (Uchar)(vLastBar), szScrollBarOff);
        dis_str ((Uchar)(vWidth-1), vLastBar = c, szScrollBarOn);
    }
}


void
DrawBar ()
{
    int     i, off;

    off = vWidth-1;
    dis_str ((Uchar)off,      1, szScrollBarUp);
    dis_str ((Uchar)off,      2, szScrollBarOn);
    dis_str ((Uchar)off, (Uchar)vLines, szScrollBarDown);
    for (i=3; i < vLines; i++)
        dis_str ((Uchar)off, (Uchar)i, szScrollBarOff);

    vLastBar = 2;     /* Top line + 1     */
    return ;
}


void
fancy_percent ()
{
    int hOffTop;

    if (ScrLock (0))
        return;

    hOffTop = vOffTop;      /* Setup for calc   */
    vOffTop = 0;
    vpCalcBlock = vpBlockTop;
    calc_percent ();

    vOffTop  = hOffTop;

    ScrUnLock ();
}


/*** dis_str - Displays string at corrds given
 *
 */
void
dis_str (
    Uchar x,
    Uchar y,
    char* s
    )
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;
    int     len;

    len = strlen (s);
    memcpy (vScrBuf+y*vWidth+x, s, len);

    dwWriteCoord.X = x;
    dwWriteCoord.Y = y;
    WriteConsoleOutputCharacter( vhConsoleOutput,
                                s,
                                strlen( s ),
                                dwWriteCoord,
                                &dwNumWritten );
}


/*** DisLn - Displays string at corrds given, clear to EOL
 *
 *
 */
void
DisLn (
    int x,
    int y,
    char* s
    )
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    if (y == vLines+1)
        vStatCode |= S_UPDATE | S_CLEAR;

    dwWriteCoord.X = (SHORT)x;
    dwWriteCoord.Y = (SHORT)y;

    ScrLock( 1 );

    WriteConsoleOutputCharacter( vhConsoleOutput,
                                s,
                                strlen( s ),
                                dwWriteCoord,
                                &dwNumWritten );

    dwWriteCoord.X += (SHORT) strlen( s );
    FillConsoleOutputCharacter( vhConsoleOutput,
                                0x20,
                                vWidth - dwWriteCoord.X,
                                dwWriteCoord,
                                &dwNumWritten );

    ScrUnLock ();
}


void
setattr (
    int line,
    char attr
    )
{
    COORD dwWriteCoord;
    DWORD       dwNumWritten;

    if (line == 0  ||  line == vLines+1)
        vStatCode |= S_UPDATE;

    dwWriteCoord.X = 0;
    dwWriteCoord.Y = (SHORT)line;
    FillConsoleOutputCharacter( vhConsoleOutput,
                                ' ',
                                vWidth,
                                dwWriteCoord,
                                &dwNumWritten );

    FillConsoleOutputAttribute( vhConsoleOutput,
                                attr,
                                vWidth,
                                dwWriteCoord,
                                &dwNumWritten );

    // Scroll Bar is in last Column

    dwWriteCoord.X = (SHORT)(vWidth-1);
    FillConsoleOutputCharacter( vhConsoleOutput,
                                ' ',
                                1,
                                dwWriteCoord,
                                &dwNumWritten );

    FillConsoleOutputAttribute( vhConsoleOutput,
                                vAttrBar,
                                1,
                                dwWriteCoord,
                                &dwNumWritten );

}


void
setattr1 (
    int line,
    char attr
    )

{
    COORD dwWriteCoord;
    DWORD       dwNumWritten;


    dwWriteCoord.X = 0;
    dwWriteCoord.Y = (SHORT)line;
    FillConsoleOutputAttribute( vhConsoleOutput,
                                attr,
                                vWidth-1,
                                dwWriteCoord,
                                &dwNumWritten );
}


void
setattr2 (
    int line,
    int start,
    int len,
    char attr
    )
{
    COORD dwWriteCoord;
    DWORD       dwNumWritten;

    dwWriteCoord.X = (SHORT)start;
    dwWriteCoord.Y = (SHORT)line;

    ScrLock (1);

    FillConsoleOutputAttribute( vhConsoleOutput,
                                attr,
                                len,
                                dwWriteCoord,
                                &dwNumWritten );
    ScrUnLock ();
}


/*** ScrLock - With levels for multiple threads
 *
 *  n = 0   - Return 0 if locked, 1 if not locked. Do not wait.
 *  1   - Return when screen locked
 */
int
ScrLock (
    int n
    )
{
    n=0;  // to get rid of warning message

    WaitForSingleObject(vSemLock, WAITFOREVER);
    ResetEvent(vSemLock);
    vcntScrLock++;
    SetEvent (vSemLock);
    return (0);
}

void
ScrUnLock ()
{
    WaitForSingleObject(vSemLock, WAITFOREVER);
    ResetEvent(vSemLock);
    --vcntScrLock;
    SetEvent (vSemLock);
}


void
SpScrUnLock ()
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    if (vStatCode & S_CLEAR)
        setattr (vLines+1, (char)vAttrCmd);

    if (vStatCode & S_UPDATE) {
        dis_str ((Uchar)(vWidth - ST_ADJUST), 0, vDate); /* warning: also print vdate*/
        DisLn (0, (Uchar)(vLines+1), "Command> ");  /* in lread.c       */
        DisLn (0, (Uchar)(vLines+2), "");           /* in lread.c       */
        vStatCode &= ~(S_CLEAR|S_UPDATE|S_WAIT);
    }

    /*
     *  If no file, then make error blink
     */

    if (vFInfo.nFileSizeLow == -1L) {
        dwWriteCoord.X = (SHORT)(vWidth-ST_ADJUST);
        dwWriteCoord.Y = 0;

        FillConsoleOutputAttribute( vhConsoleOutput,
                                    (WORD) (vAttrTitle | BACKGROUND_INTENSITY),
                                    ST_ADJUST,
                                    dwWriteCoord,
                                    &dwNumWritten );
    }

    /*
     *  Calculate file position. (percent to EOF)
     */
    calc_percent ();

    if (vSpLockFlag) {
        vSpLockFlag = 0;
        ScrUnLock ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\list.c ===
/*** List.c
 *
 */

#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include "list.h"
#include "..\he\hexedit.h"


BOOL IsValidKey (PINPUT_RECORD  pRecord);
void DumpFileInHex (void);

static char Name[] = "Ken Reneris. List Ver 1.0.";

struct Block  *vpHead = NULL;   /* Current first block                      */
struct Block  *vpTail = NULL;   /* Current last block                       */
struct Block  *vpCur  = NULL;   /* Current block for display 1st line       */
                                /* (used by read ahead to sense)            */
struct Block  *vpBCache = NULL; /* 'free' blocks which can cache reads      */
struct Block  *vpBOther = NULL; /* (above) + for other files                */
struct Block  *vpBFree  = NULL; /* free blocks. not valid for caching reads */

int     vCntBlks;               /* No of blocks currently is use by cur file*/

int     vAllocBlks = 0;         /* No of blocks currently alloced           */
int     vMaxBlks     = MINBLKS; /* Max blocks allowed to alloc              */
long    vThreshold   = MINTHRES*BLOCKSIZE;  /* Min bytes before read ahead  */

HANDLE  vSemBrief    = 0L;      /* To serialize access to Linked list info  */
HANDLE  vSemReader   = 0L;      /* To wakeup reader thread when threshold   */
HANDLE  vSemMoreData = 0L;      /* Blocker for Disp thread if ahead of read */
HANDLE  vSemSync     = 0L;      /* Used to syncronize to sync to the reader */


USHORT  vReadPriNormal;         /* Normal priority for reader thread        */
unsigned  vReadPriBoost;        /* Boosted priority for reader thread       */
char      vReaderFlag;          /* Insructions to reader                    */

HANDLE  vFhandle = 0;           /* Current file handle                      */
long      vCurOffset;           /* Current offset in file                   */
char      vpFname [40];         /* Current files name                       */
struct Flist *vpFlCur =NULL;    /* Current file                             */
USHORT  vFType;                 /* Current files handle type                */
WIN32_FIND_DATA vFInfo;         /* Current files info                       */
char      vDate [30];           /* Printable dat of current file            */

char      vSearchString [50];   /* Searching for this string                */
char      vStatCode;            /* Codes for search                         */
long      vHighTop = -1L;       /* Current topline of hightlighting         */
int       vHighLen;             /* Current bottom line of hightlighting     */
char      vHLTop = 0;           /* Last top line displayed as highlighted   */
char      vHLBot = 0;           /* Last bottom line displayed as highlighed */
char      vLastBar;             /* Last line for thumb mark                 */
int       vMouHandle;           /* Mouse handle (for Mou Apis)              */


HANDLE  vhConsoleOutput;        // Handle to the console
char *vpOrigScreen;             /* Orinal screen contents                   */
int     vOrigSize;              /* # of bytes in orignal screen             */
USHORT  vVioOrigRow = 0;        /* Save orignal screen stuff.               */
USHORT  vVioOrigCol = 0;

int     vSetBlks     = 0;       /* Used to set INI value                    */
long    vSetThres    = 0L;      /* Used to set INI value                    */
int     vSetLines;              /* Used to set INI value                    */
int     vSetWidth;              /* Used to set INI value                    */
CONSOLE_SCREEN_BUFFER_INFO       vConsoleCurScrBufferInfo;
CONSOLE_SCREEN_BUFFER_INFO       vConsoleOrigScrBufferInfo;

/* Screen controling... used to be static in ldisp.c    */
char      vcntScrLock = 0;      /* Locked screen count                      */
char      vSpLockFlag = 0;      /* Special locked flag                      */
HANDLE    vSemLock = 0;         /* To access vcntScrLock                    */

char      vUpdate;
int       vLines = 23;          /* CRTs no of lines                         */
int       vWidth = 80;          /* CRTs width                               */
int       vCurLine;             /* When processing lines on CRT             */
Uchar     vWrap = 254;          /* # of chars to wrap at                    */
Uchar     vIndent = 0;          /* # of chars dispaly is indented           */
Uchar     vDisTab = 8;          /* # of chars per tab stop                  */
Uchar     vIniFlag = 0;         /* Various ini bits                         */


Uchar     vrgLen   [MAXLINES];  /* Last len of data on each line            */
Uchar     vrgNewLen[MAXLINES];  /* Temp moved to DS for speed               */
char      *vScrBuf;             /* Ram to build screen into                 */
ULONG     vSizeScrBuf;
int       vOffTop;              /* Offset into data for top line            */
unsigned  vScrMass = 0;         /* # of bytes for last screen (used for %)  */
struct Block *vpBlockTop;       /* Block for start of screen (dis.asm) overw*/
struct Block *vpCalcBlock;      /* Block for start of screen                */
long      vTopLine   = 0L;      /* Top line on the display                  */

#define FOREGROUND_WHITE (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)
#define BACKGROUND_WHITE (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE)

#define HIWHITE_ON_BLUE (BACKGROUND_BLUE | FOREGROUND_WHITE | FOREGROUND_INTENSITY)

WORD      vAttrTitle = HIWHITE_ON_BLUE;
WORD      vAttrList  = BACKGROUND_BLUE  | FOREGROUND_WHITE;
WORD      vAttrHigh  = BACKGROUND_WHITE | FOREGROUND_BLUE;
WORD      vAttrKey   = HIWHITE_ON_BLUE;
WORD      vAttrCmd   = BACKGROUND_BLUE  | FOREGROUND_WHITE;
WORD      vAttrBar   = BACKGROUND_BLUE  | FOREGROUND_WHITE;

WORD      vSaveAttrTitle = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrList = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrHigh = BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
WORD      vSaveAttrKey  = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrCmd  = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrBar  = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;

char    vChar;                  /* Scratch area                             */
char   *vpReaderStack;          /* Readers stack                            */



long    vDirOffset;             /* Direct offset to seek to                 */
                                /* table                                    */
long    vLastLine;              /* Absolute last line                       */
long    vNLine;                 /* Next line to process into line table     */
long *vprgLineTable [MAXTPAGE]; /* Number of pages for line table           */

HANDLE  vStdOut;
HANDLE  vStdIn;


char MEMERR[]= "Malloc failed. Out of memory?";

void __cdecl
main (
    int argc,
    char **argv
    )
{
    void usage (void);
    char    *pt;
    DWORD   dwMode;


    if (argc < 2)
        usage ();

    while (--argc) {
        ++argv;
        if (*argv[0] != '-'  &&  *argv[0] != '/')  {
            AddFileToList (*argv);
            continue;
        }
        pt = (*argv) + 2;
        if (*pt == ':') pt++;

        switch ((*argv)[1]) {
            case 'g':                   // Goto line #
            case 'G':
                if (!atol (pt))
                    usage ();

                vIniFlag |= I_GOTO;
                vHighTop = atol (pt);
                vHighLen = 0;
                break;

            case 's':                   // Search for string
            case 'S':
                vIniFlag |= I_SEARCH;
                strncpy (vSearchString, pt, 40);
                vSearchString[39] = 0;
                vStatCode |= S_NEXT | S_NOCASE;
                InitSearchReMap ();
                break;

            default:
                usage ();
        }
    }

    if ((vIniFlag & I_GOTO)  &&  (vIniFlag & I_SEARCH))
        usage ();

    if (!vpFlCur)
        usage ();

    while (vpFlCur->prev)
        vpFlCur = vpFlCur->prev;
    strcpy (vpFname, vpFlCur->rootname);

    vSemBrief = CreateEvent( NULL,
                             MANUAL_RESET,
                             SIGNALED,NULL );
    vSemReader = CreateEvent( NULL,
                              MANUAL_RESET,
                              SIGNALED,NULL );
    vSemMoreData = CreateEvent( NULL,
                                MANUAL_RESET,
                                SIGNALED,NULL );
    vSemSync = CreateEvent( NULL,
                            MANUAL_RESET,
                            SIGNALED,NULL );
    vSemLock = CreateEvent( NULL,
                            MANUAL_RESET,
                            SIGNALED,NULL );

    if( !(vSemBrief && vSemReader &&vSemMoreData && vSemSync && vSemLock) ) {
        printf("Couldn't create events \n");
        ExitProcess (0);          // Have to put an error message here
    }

    vhConsoleOutput = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
                                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                NULL,
                                                CONSOLE_TEXTMODE_BUFFER,
                                                NULL );

    if( vhConsoleOutput == (HANDLE)(-1) ) {
        printf( "Couldn't create handle to console output \n" );
        ExitProcess (0);
    }

    vStdIn = GetStdHandle( STD_INPUT_HANDLE );
    GetConsoleMode( vStdIn, &dwMode );
    SetConsoleMode( vStdIn, dwMode | ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT );
    vStdOut = GetStdHandle( STD_OUTPUT_HANDLE );

    init_list ();
    vUpdate = U_NMODE;

    if (vIniFlag & I_SEARCH)
        FindString ();

    if (vIniFlag & I_GOTO)
        GoToMark ();

    main_loop ();
}


void
usage (
    void
    )
{
    puts ("list [-s:string] [-g:line#] filename, ...");
    CleanUp();
    ExitProcess(0);

}


/*** main_loop
 *
 */
void
main_loop ()
{
    int     i;
    int         ccnt = 0;
    char        SkipCnt=0;
    WORD        RepeatCnt=0;
    INPUT_RECORD    InpBuffer;
    DWORD           cEvents;
    BOOL            bSuccess;
    BOOL            bKeyDown = FALSE;

    for (; ;) {
        if (RepeatCnt <= 1) {
            if (vUpdate != U_NONE) {
                if (SkipCnt++ > 5) {
                    SkipCnt = 0;
                    SetUpdate (U_NONE);
                } else {

                    cEvents = 0;
                    bSuccess = PeekConsoleInput( vStdIn,
                                      &InpBuffer,
                                      1,
                                      &cEvents );

                    if (!bSuccess || cEvents == 0) {
                        PerformUpdate ();
                        continue;
                    }
                }
            }

            // there's either a charactor available from peek, or vUpdate is U_NONE

            bSuccess = ReadConsoleInput( vStdIn,
                              &InpBuffer,
                              1,
                              &cEvents );

            if (InpBuffer.EventType != KEY_EVENT) {

//                TCHAR s[1024];

                switch (InpBuffer.EventType) {
#if 0
                    case WINDOW_BUFFER_SIZE_EVENT:

                        sprintf (s,
                                 "WindowSz X=%d, Y=%d",
                                 InpBuffer.Event.WindowBufferSizeEvent.dwSize.X,
                                 InpBuffer.Event.WindowBufferSizeEvent.dwSize.Y );
                        DisLn   (20, (Uchar)(vLines+1), s);
                        break;
#endif


                    case MOUSE_EVENT:

#if 0
                        sprintf (s,
                                 "Mouse (%d,%d), state %x, event %x",
                                 InpBuffer.Event.MouseEvent.dwMousePosition.X,
                                 InpBuffer.Event.MouseEvent.dwMousePosition.Y,
                                 InpBuffer.Event.MouseEvent.dwButtonState,
                                 InpBuffer.Event.MouseEvent.dwEventFlags );
#endif

                        if (InpBuffer.Event.MouseEvent.dwEventFlags == MOUSE_WHEELED)
                        {
                            //  HiWord of ButtonState is signed int, in increments of 120 (WHEEL_DELTA).
                            //  Map each 'detent' to a 4 line scroll in the console window.
                            //  Rolling away from the user should scroll up (dLines should be negative).
                            //  Since rolling away generates a positive dwButtonState, the negative sign
                            //  makes rolling away scroll up, and rolling towards you scroll down.

                            SHORT dLines = -(SHORT)(HIWORD(InpBuffer.Event.MouseEvent.dwButtonState)) / (WHEEL_DELTA / 4);

                            vTopLine += dLines;

                            //  make sure to stay between line 0 and vLastLine

                            if (vTopLine+vLines > vLastLine)
                                vTopLine = vLastLine-vLines;
                            if (vTopLine < 0)
                                vTopLine = 0;

                            SetUpdateM (U_ALL);
                        }

//                        DisLn   (20, (Uchar)(vLines+1), s);
                        break;


                    default:
#if 0
                        sprintf (s, "Unkown event %d", InpBuffer.EventType);
                        DisLn   (20, (Uchar)(vLines+1), s);
#endif
                        break;
                }


                continue;
            }

            if (!InpBuffer.Event.KeyEvent.bKeyDown)
                continue;                       // don't move on upstrokes

            if (!IsValidKey( &InpBuffer ))
                continue;

            RepeatCnt = InpBuffer.Event.KeyEvent.wRepeatCount;
            if (RepeatCnt > 20)
                RepeatCnt = 20;
        } else
            RepeatCnt--;


        // First check for a known scan code
        switch (InpBuffer.Event.KeyEvent.wVirtualKeyCode) {
            case 0x21:                                              /* PgUp */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &    // shift up
                    SHIFT_PRESSED ) {
                    HPgUp ();
                }
                else if (InpBuffer.Event.KeyEvent.dwControlKeyState &      // ctrl up
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                    if (NextFile (-1, NULL)) {
                        vStatCode |= S_UPDATE;
                        SetUpdate (U_ALL);
                    }

                }
                else {
                    if (vTopLine != 0L) {
                        vTopLine -= vLines-1;
                        if (vTopLine < 0L)
                            vTopLine = 0L;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x26:                                              /* Up   */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &    // shift or ctrl up
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HUp ();
                }
                else {                                  // Up
                    if (vTopLine != 0L) {
                        vTopLine--;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x22:                                  /* PgDn */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &      // shift down
                    SHIFT_PRESSED ) {
                    HPgDn ();
                }
                else if (InpBuffer.Event.KeyEvent.dwControlKeyState & // next file
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                    if (NextFile (+1, NULL)) {
                        vStatCode |= S_UPDATE;
                        SetUpdate (U_ALL);
                    }

                }
                else {                                     // PgDn
                    if (vTopLine+vLines < vLastLine) {
                        vTopLine += vLines-1;
                        if (vTopLine+vLines > vLastLine)
                            vTopLine = vLastLine - vLines;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x28:                                  /* Down */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // shift or ctrl down
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HDn ();
                }
                else {                                  // Down
                    if (vTopLine+vLines < vLastLine) {
                        vTopLine++;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x25:                                  /* Left */
                if (vIndent == 0)
                    continue;
                vIndent = (Uchar)(vIndent < vDisTab ? 0 : vIndent - vDisTab);
                SetUpdateM (U_ALL);
                continue;
            case 0x27:                                  /* Right */
                if (vIndent >= (Uchar)(254-vWidth))
                    continue;
                vIndent += vDisTab;
                SetUpdateM (U_ALL);
                continue;
            case 0x24:                                  /* HOME */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // shift or ctrl home
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HSUp ();
                }
                else {
                    if (vTopLine != 0L) {
                        QuickHome ();
                        SetUpdate (U_ALL);
                    }
                }
                continue;
            case 0x23:                                  /* END  */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // shift or ctrl end
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HSDn ();
                }
                else {
                    if (vTopLine+vLines < vLastLine) {
                        QuickEnd        ();
                        SetUpdate (U_ALL);
                    }
                }
                continue;

            case 0x72:                                  /* F3       */
                FindString ();
                SetUpdate (U_ALL);
                continue;
            case 0x73:                                  /* F4       */
                vStatCode = (char)((vStatCode^S_MFILE) | S_UPDATE);
                vDate[ST_SEARCH] = (char)(vStatCode & S_MFILE ? '*' : ' ');
                SetUpdate (U_HEAD);
                continue;

            case 69:
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // ALT-E
                    ( RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED ) ) {
                    i = vLines <= 41 ? 25 : 43;
                    if (set_mode (i, 0, 0))
                        SetUpdate (U_NMODE);
                }
                continue;
            case 86:                                    // ALT-V
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &
                    ( RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED ) ) {
                    i = vLines >= 48 ? 25 : 60;
                    if (set_mode (i, 0, 0))
                    {
                        SetUpdate (U_NMODE);
                        continue;
                    }
                    if (i == 60)
                        if (set_mode (50, 0, 0))
                            SetUpdate (U_NMODE);
                }
                continue;
            case 0x70:                              /* F1       */
                ShowHelp ();
                SetUpdate (U_NMODE);
                continue;
            case 24:                                /* Offset   */
                if (!(vIniFlag & I_SLIME))
                    continue;
                SlimeTOF  ();
                SetUpdate (U_ALL);
                continue;
            case 0x77:                              // F8
            case 0x1b:                              // ESC
            case 0x51:                              // Q or q
                CleanUp();
                ExitProcess(0);

        }


        // Now check for a known char code...

        switch (InpBuffer.Event.KeyEvent.uChar.AsciiChar) {
            case '?':
                ShowHelp ();
                SetUpdate (U_NMODE);
                continue;
            case '/':
                vStatCode = (char)((vStatCode & ~S_NOCASE) | S_NEXT);
                GetSearchString ();
                FindString ();
                continue;
            case '\\':
                vStatCode |= S_NEXT | S_NOCASE;
                GetSearchString ();
                FindString ();
                continue;
            case 'n':
                vStatCode = (char)((vStatCode & ~S_PREV) | S_NEXT);
                FindString ();
                continue;
            case 'N':
                vStatCode = (char)((vStatCode & ~S_NEXT) | S_PREV);
                FindString ();
                continue;
            case 'c':
            case 'C':                   /* Clear marked line    */
                UpdateHighClear ();
                continue;
            case 'j':
            case 'J':                   /* Jump to marked line  */
                GoToMark ();
                continue;
            case 'g':
            case 'G':                   /* Goto line #          */
                GoToLine ();
                SetUpdate (U_ALL);
                continue;
            case 'm':                   /* Mark line  or Mono   */
            case 'M':
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // ALT-M
                    ( RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED ) ) {
                    i = set_mode (vSetLines, vSetWidth, 1);
                    if (!i)
                        i = set_mode (0, 0, 1);
                    if (!i)
                        i = set_mode (25, 80, 1);
                    if (i)
                        SetUpdate (U_NMODE);
                }
                else {
                    MarkSpot ();
                }
                continue;
            case 'p':                   /* Paste buffer to file */
            case 'P':
                FileHighLighted ();
                continue;
            case 'f':                   /* get a new file       */
            case 'F':
                if (GetNewFile ())
                    if (NextFile (+1, NULL))
                        SetUpdate (U_ALL);

                continue;
            case 'h':                   /* hexedit              */
            case 'H':
                DumpFileInHex();
                SetUpdate (U_NMODE);
                continue;
            case 'w':                                           /* WRAP */
            case 'W':
                ToggleWrap ();
                SetUpdate (U_ALL);
                continue;
            case 'l':                                       /* REFRESH */
            case 'L':                                       /* REFRESH */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // ctrl L
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                    SetUpdate (U_NMODE);
                }
                continue;
            case '\r':                                          /* ENTER*/
                SetUpdate (U_HEAD);
                continue;

            default:
                continue;
        }

    }   /* Forever loop */
}


void
SetUpdate(
    int i
    )
{
    while (vUpdate>(char)i)
        PerformUpdate ();
    vUpdate=(char)i;
}


void
PerformUpdate (
    )
{
    if (vUpdate == U_NONE)
        return;

    if (vSpLockFlag == 0) {
        vSpLockFlag = 1;
        ScrLock (1);
    }

    switch (vUpdate) {
        case U_NMODE:
            ClearScr ();
            DisLn    (0, 0, vpFname);
            DrawBar  ();
            break;
        case U_ALL:
            Update_display ();
            break;
        case U_HEAD:
            Update_head ();
            break;
        case U_CLEAR:
            SpScrUnLock ();
            break;
    }
    vUpdate --;
}


NTSTATUS fncRead(HANDLE, DWORD, DWORD, char *, ULONG *);
NTSTATUS fncWrite(HANDLE, DWORD, DWORD, char *, ULONG *);

void
DumpFileInHex(
    void
    )
{
    struct  HexEditParm     ei;
    ULONG   CurLine;

    SyncReader ();

    memset ((char *) &ei, 0, sizeof (ei));
    ei.handle = CreateFile( vpFlCur->fname,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL );

    if (ei.handle == INVALID_HANDLE_VALUE) {
        ei.handle = CreateFile( vpFlCur->fname,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    }

    if (ei.handle == INVALID_HANDLE_VALUE) {
        SetEvent   (vSemReader);
        return ;
    }

    //
    // Save current settings for possible restore
    //

    vpFlCur->Wrap     = vWrap;
    vpFlCur->HighTop  = vHighTop;
    vpFlCur->HighLen  = vHighLen;
    vpFlCur->TopLine  = vTopLine;
    vpFlCur->Loffset  = GetLoffset();
    vpFlCur->LastLine = vLastLine;
    vpFlCur->NLine    = vNLine;

    memcpy (vpFlCur->prgLineTable, vprgLineTable, sizeof (long *) * MAXTPAGE);

    vFInfo.nFileSizeLow = 0;
    setattr2 (0, 0, vWidth, (char)vAttrTitle);

    //
    // Setup for HexEdit call
    //

    if (vHighTop >= 0) {                    // If highlighted area,
        CurLine = vHighTop;                 // use that for the HexEdit
        if (vHighLen < 0)                   // location
            CurLine += vHighLen;
    } else {
        CurLine = vTopLine;
    }

    ei.ename    = vpFname;
    ei.ioalign  = 1;
    ei.flag     = FHE_VERIFYONCE;
    ei.read     = fncRead;
    ei.write    = fncWrite;
    ei.start    = vprgLineTable[CurLine/PLINES][CurLine%PLINES];
    ei.totlen   = SetFilePointer (ei.handle, 0, NULL, FILE_END);
    ei.Console  = vhConsoleOutput;          // our console handle
    ei.AttrNorm = vAttrList;
    ei.AttrHigh = vAttrTitle;
    ei.AttrReverse = vAttrHigh;
    HexEdit (&ei);

    CloseHandle (ei.handle);

    //
    // HexEdit is done, let reader and return to listing
    //

    vReaderFlag = F_NEXT;                   // re-open current file
                                            // (in case it was editted)

    SetEvent   (vSemReader);
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);
    QuickRestore ();        /* Get to the old location      */
}


int
NextFile (
    int    dir,
    struct Flist   *pNewFile)
{
    struct  Flist *vpFLCur;
    long         *pLine;

    vpFLCur = vpFlCur;
    if (pNewFile == NULL) {
        if (dir < 0) {
            if (vpFlCur->prev == NULL) {
                beep ();
                return (0);
            }
            vpFlCur = vpFlCur->prev;

        } else if (dir > 0) {

            if (vpFlCur->next == NULL) {
                beep ();
                return (0);
            }
            vpFlCur = vpFlCur->next;
        }
    } else
        vpFlCur = pNewFile;

    SyncReader ();

    /*
     * Remove current file from list, if open error
     * occured and we are moving off of it.
     */
    if (vFInfo.nFileSizeLow == -1L      &&      vpFLCur != vpFlCur) {
        if (vpFLCur->prev)
            vpFLCur->prev->next = vpFLCur->next;
        if (vpFLCur->next)
            vpFLCur->next->prev = vpFLCur->prev;

        FreePages  (vpFLCur);

        free ((char*) vpFLCur->fname);
        free ((char*) vpFLCur->rootname);
        free ((char*) vpFLCur);

    } else {

        /*
         *  Else, save current status for possible restore
         */
        vpFLCur->Wrap     = vWrap;
        vpFLCur->HighTop  = vHighTop;
        vpFLCur->HighLen  = vHighLen;
        vpFLCur->TopLine  = vTopLine;
        vpFLCur->Loffset  = GetLoffset();
        vpFLCur->LastLine = vLastLine;
        vpFLCur->NLine    = vNLine;

        memcpy (vpFLCur->prgLineTable, vprgLineTable, sizeof (long *) * MAXTPAGE);

        if (vLastLine == NOLASTLINE)    {
                pLine = vprgLineTable [vNLine/PLINES] + vNLine % PLINES;
        }
    }

    vFInfo.nFileSizeLow = 0;
        setattr2 (0, 0, vWidth, (char)vAttrTitle);

    vHighTop    = -1L;
    UpdateHighClear ();

    vHighTop    = vpFlCur->HighTop;
    vHighLen    = vpFlCur->HighLen;

    strcpy (vpFname, vpFlCur->rootname);
    DisLn   (0, 0, vpFname);

    vReaderFlag = F_NEXT;

    SetEvent   (vSemReader);
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);

    if (pNewFile == NULL)
        QuickRestore ();        /* Get to the old location      */

    return (1);
}

void
ToggleWrap(
    )
{
    SyncReader ();

    vWrap = (Uchar)(vWrap == (Uchar)(vWidth - 1) ? 254 : vWidth - 1);
    vpFlCur->FileTime.dwLowDateTime = (unsigned)-1;          /* Cause info to be invalid     */
    vpFlCur->FileTime.dwHighDateTime = (unsigned)-1;      /* Cause info to be invalid     */
    FreePages (vpFlCur);
    NextFile  (0, NULL);
}



/*** QuickHome - Deciede which HOME method is better.
 *
 *  Roll que backwards or reset it.
 *
 */

void
QuickHome ()
{

    vTopLine = 0L;                                      /* Line we're after */
    if (vpHead->offset >= BLOCKSIZE * 5)                /* Reset is fastest */
        QuickRestore ();

    /* Else Read backwards  */
    vpCur = vpHead;
}

void
QuickEnd ()
{
    vTopLine = 1L;

    while (vLastLine == NOLASTLINE) {
        if (_abort()) {
            vTopLine = vNLine - 1;
            return ;
        }
        fancy_percent ();
        vpBlockTop  = vpCur = vpTail;
        vReaderFlag = F_DOWN;

        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }
    vTopLine = vLastLine - vLines;
    if (vTopLine < 0L)
        vTopLine = 0L;
    QuickRestore ();
}

void
QuickRestore ()
{
    long    l;
    long    indx1 = vTopLine/PLINES;
    long    indx2 = vTopLine%PLINES;

    SyncReader ();

    if(indx1 < MAXTPAGE) {
        l = vprgLineTable[indx1][indx2];
    } else {
        puts("Sorry, This file is too big for LIST to handle. MAXTPAGE limit exceeded\n");
        CleanUp();
        ExitProcess(0);
    }

    if ((l >= vpHead->offset)  &&
        (l <= vpTail->offset + BLOCKSIZE))
    {
        vReaderFlag = F_CHECK;              /* Jump location is alread in   */
                                            /* memory.                      */
        SetEvent (vSemReader);
        return ;
    }

    /*  Command read for direct placement   */
    vDirOffset = (long) l - l % ((long)BLOCKSIZE);
    vReaderFlag = F_DIRECT;
    SetEvent   (vSemReader);
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);
}


/*** InfoRead - return on/off depending if screen area is in memory
 *
 *  Also sets some external value to prepair for the screens printing
 *
 *  Should be modified to be smarter about one line movements.
 *
 */
int
InfoReady(
    void
    )
{
    struct Block *pBlock;
    LONG  *pLine;
    long    foffset, boffset;
    int     index, i, j;

    /*
     *  Check that first line has been calced
     */
    if (vTopLine >= vNLine) {
        if (vTopLine+vLines > vLastLine)            /* BUGFIX. TopLine can  */
            vTopLine = vLastLine - vLines;          /* get past EOF.        */

        vReaderFlag = F_DOWN;
        return (0);
    }

    pLine = vprgLineTable [(int)vTopLine / PLINES];
    index = (int)(vTopLine % PLINES);
    foffset = *(pLine+=index);

    /*
     *  Check that last line has been calced
     */
    if (vTopLine + (i = vLines) > vLastLine) {
        i = (int)(vLastLine - vTopLine + 1);
        for (j=i; j < vLines; j++)                  /* Clear ending len */
            vrgNewLen[j] = 0;
    }

    if (vTopLine + i > vNLine) {
        vReaderFlag = F_DOWN;
        return (0);
    }

    /*
     *  Put this loop in assembler.. For more speed
     *  boffset = calc_lens (foffset, i, pLine, index);
     */

    boffset = foffset;
    for (j=0; j < i; j++) {                        /* Calc new line len*/
        pLine++;
        if (++index >= PLINES) {
            index = 0;
            pLine = vprgLineTable [vTopLine / PLINES + 1];
        }
        boffset += (long)((vrgNewLen[j] = (Uchar)(*pLine - boffset)));
    }
    vScrMass = (unsigned)(boffset - foffset);


    /*
     *  Check for both ends of display in memory
     */
    pBlock = vpCur;

    if (pBlock->offset <= foffset) {
        while (pBlock->offset + BLOCKSIZE <= foffset)
            if ( (pBlock = pBlock->next) == NULL) {
                vReaderFlag = F_DOWN;
                return (0);
            }
        vOffTop    = (int)(foffset - pBlock->offset);
        vpBlockTop = vpCalcBlock = pBlock;

        while (pBlock->offset + BLOCKSIZE <= boffset)
            if ( (pBlock = pBlock->next) == NULL)  {
                vReaderFlag = F_DOWN;
                return (0);
            }
        if (vpCur != pBlock) {
            vpCur = pBlock;
            vReaderFlag = F_CHECK;
            SetEvent (vSemReader);
        }
        return (1);
    } else {
        while (pBlock->offset > foffset)
            if ( (pBlock = pBlock->prev) == NULL) {
                vReaderFlag = F_UP;
                return (0);
            }
        vOffTop    = (int)(foffset - pBlock->offset);
        vpBlockTop = vpCalcBlock = pBlock;

        while (pBlock->offset + BLOCKSIZE <= boffset)
            if ( (pBlock = pBlock->next) == NULL)  {
                vReaderFlag = F_DOWN;
                return (0);
            }
        if (vpCur != pBlock) {
            vpCur = pBlock;
            vReaderFlag = F_CHECK;
            SetEvent (vSemReader);
        }
        return (1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\list.h ===
/*** list.h
 *
 */

#define BLOCKSIZE   (4*1024)    /* Bytes of data in each block */
                                /* WARNING:    This value is also in the *.asm listing  */

#define STACKSIZE   3096        /* Stack size for threads */
#define MAXLINES    200         /* Max lines on a CRT */
#define PLINES      (65536/4)   /* # of line lens per page */
#define MAXTPAGE    500         /* ??? lines max  (PLINES*MAXTPAGE) */

#define MINBLKS     10          /* Min blocks allowed */
#define MINTHRES     4          /* Min threshold */
#define DEFBLKS     40          /* Default blocks allowed */
#define DEFTHRES    17          /* Default threshold */

#define CMDPOS      9

#define ERR_IN_WINDOW 494       /* Vio wincompat error */
#define NOLASTLINE  0x7fffffffL

/************ Handy Defs ************/
#define CFP char *
#define LFP long *
#define CP  char *
#define Ushort  unsigned short
#define Uslong  unsigned long
#define Uchar unsigned char
#define SEMPT (HSEM)
#define WAITFOREVER ((unsigned)-1L)
#define DONTWAIT   0L

#ifndef NTSTATUS
#define NTSTATUS unsigned long
#endif

#define SIGNALED  TRUE
#define NOT_SIGNALED  FALSE
#define MANUAL_RESET  TRUE

#define T_HEATHH 0

extern char MEMERR[];

#ifndef DEBUG
    #define ckdebug(rcode,mess) { \
  if (rcode) { \
      ListErr (__FILE__, __LINE__, #rcode, rcode, mess); \
      } \
  }
#else
    #define ckdebug(rcode,mess)   ;
#endif

#define ckerr(rcode,mess) { \
    if (rcode) { \
  ListErr (__FILE__, __LINE__, #rcode, rcode, mess); \
  } \
    }



/****************** Declerations ********************/


void main_loop (void);
void init_list (void);
void FindIni (void);
void CleanUp ();
DWORD ReaderThread (DWORD);
DWORD RedrawWait (LPVOID);
unsigned xtoi (char *);

struct Block *alloc_block (long);
void  MoveBlk (struct Block **, struct Block **);

char *alloc_page  (void);
void AddFileToList (char *);
void AddOneName (char *);
void ReadDirect (long);
void ReadNext (void);
void add_more_lines (struct Block *, struct Block *);
void ReadPrev (void);
void ReadBlock (struct Block *, long);
void GoToMark (void);
void GoToLine (void);
void SlimeTOF (void);
void QuickHome  (void);
void QuickEnd   (void);
void QuickRestore (void);
void ToggleWrap (void);
void SetUpdate (int);
void ShowHelp (void);
void GetInput (char *, char *, int);
void beep (void);
int  _abort (void);
void ClearScr (void);
int set_mode (int, int, int);
void ListErr (char *, int, char *, int, char *);
void PerformUpdate  (void);
void fancy_percent  (void);
// void update_display (void);
void Update_head   (void);
int  InfoReady    (void);
void DrawBar (void);
void DisLn (int, int, char*);
void dis_str (Uchar, Uchar, char *);
void setattr   (int, char);
int  GetNewFile      (void);
void NewFile     (void);
void SyncReader    (void);
void ScrUnLock  (void);
int  ScrLock    (int);
void SpScrUnLock (void);
void Update_display (void);
void setattr1   (int, char);
void setattr2   (int, int, int, char);
void UpdateHighClear (void);
void MarkSpot (void);
void UpdateHighNoLock (void);
void FileHighLighted (void);
int  SearchText (char);
void GetSearchString (void);
void InitSearchReMap (void);
void FindString (void);
void HUp (void);
void HDn (void);
void HPgDn (void);
void HPgUp (void);
void HSUp (void);
void HSDn (void);
char *GetErrorCode   (int);

struct Block  {
    long    offset;         /* Offset in file which this block starts */
    USHORT  size;           /* No of bytes in this block */
    struct Block *next;     /* Next block */
    struct Block *prev;     /* Previous block */
    char    *Data;          /* The data in the block */
    char    flag;           /* End of file flag */
    struct Flist *pFile;    /* File which this buff is associated with */
} ;                         /* The structure used by *.asm */
#define F_EOF 1

extern HANDLE vhConsoleOutput;

extern struct Block  *vpHead;
extern struct Block  *vpTail;
extern struct Block  *vpCur;
extern struct Block  *vpBFree;
extern struct Block  *vpBCache;
extern struct Block  *vpBOther;

extern int      vCntBlks;
extern int      vAllocBlks;
extern int      vMaxBlks;
extern long     vThreshold;

extern HANDLE     vSemBrief;
extern HANDLE     vSemReader;
extern HANDLE     vSemMoreData;
extern HANDLE     vSemSync;

extern USHORT       vReadPriNormal;
extern unsigned     vReadPriBoost;
extern char     vReaderFlag;
#define F_DOWN      1
#define F_UP        2
#define F_HOME      3
#define F_DIRECT    4
#define F_END       5
#define F_NEXT      6
#define F_SYNC      7
#define F_CHECK     8

#define U_NMODE     4
#define U_ALL       3
#define U_HEAD      2
#define U_CLEAR     1
#define U_NONE      0
#define SetUpdateM(a)  {   \
  while (vUpdate>a) \
      PerformUpdate (); \
  vUpdate=a;    \
    }


#define S_NEXT      0x01  /* Searching for next */
#define S_PREV      0x02  /* Searching for prev */
#define S_NOCASE    0x04  /* Searching in any case */
#define S_UPDATE    0x08
#define S_CLEAR     0x10  /* Redisplay last line */
#define S_WAIT      0x80  /* 'wait' is displayed on last line */
#define S_MFILE     0x20  /* muti-file search selected */
#define S_INSEARCH  0x40  /* in search */

/* Init flags     */
#define I_SLIME     0x01  /* Allow alt-o to work */
#define I_NOBEEP    0x02  /* Don't beep about things */

#define I_SEARCH    0x04  /* Cmd line search */
#define I_GOTO      0x08  /* Cmd line goto */


struct  Flist {
    char    *fname, *rootname;
    struct  Flist   *prev, *next;

    /*
     *  Data to save for each file.
     *  (saved so when the file is "re-looked" at this information
     *  is remembered.)     In progress.. this is not done.
     *  This data all has corrisponding "v" (global) values.
     *
     *  Warning: In most places the reader thread must be frozen
     *  before manipulating this data.
     */
    Uchar   Wrap;           /* Wrap setting for this file   */
    long    HighTop;        /* Current topline of hightlighting   */
    int     HighLen;        /* Current bottom line of hightlighting */

    long    TopLine;        /* Top Line number for offset   */

    long    Loffset;        /* Offset of last block processed into line */
          /* table          */
    long    LastLine;       /* Absolute last line     */
    long    NLine;          /* Next line to process into line table */
    long *prgLineTable [MAXTPAGE]; /* Number of pages for line table  */

    FILETIME  FileTime;     /* Used to determine if info is out of date */
    long    SlimeTOF;       /* Hack to adjust idea of TOF for this file */

    /*
     *  Used to buffer reads across files
     */
} ;

extern struct Flist *vpFlCur;
int  NextFile    (int, struct Flist *);
void FreePages (struct Flist *);

extern HANDLE       vFhandle;
extern long       vCurOffset;
extern char       vpFname[];
extern USHORT       vFType;
extern WIN32_FIND_DATA    vFInfo;
extern char  vDate [];
#define ST_SEARCH   0
#define ST_MEMORY   2
#define ST_ADJUST   25-2        // NT - jaimes - 03/04/91
                                // -2: Year is represeted by 4 digits
                                // instead instead of 2

extern char  vSearchString[];
extern char  vStatCode;
extern long  vHighTop;
extern int   vHighLen;
extern char  vHLTop;
extern char  vHLBot;
extern char  vLastBar;
extern int   vMouHandle;


extern char  *vpOrigScreen;
extern int   vOrigSize;
extern USHORT vVioOrigRow;
extern USHORT vVioOrigCol;
extern USHORT  vOrigAnsi;
extern int     vSetBlks;
extern long    vSetThres;
extern int     vSetLines;
extern int     vSetWidth;
extern CONSOLE_SCREEN_BUFFER_INFO   vConsoleCurScrBufferInfo;
extern CONSOLE_SCREEN_BUFFER_INFO   vConsoleOrigScrBufferInfo;

extern char  vcntScrLock;
extern char  vSpLockFlag;
extern HANDLE  vSemLock;

extern char  vUpdate;
extern int   vLines;
extern int   vWidth;
extern int   vCurLine;
extern Uchar   vWrap;
extern Uchar   vIndent;
extern Uchar   vDisTab;
extern Uchar   vIniFlag;

extern unsigned  vVirtOFF;
extern unsigned  vVirtLEN;
extern unsigned  vPhysSelec;
extern unsigned  vPhysLen;

extern LPSTR   vpSavRedraw;
extern Uchar   vrgLen   [];
extern Uchar   vrgNewLen[];
extern char  *vScrBuf;
extern ULONG   vSizeScrBuf;
extern int   vOffTop;
extern unsigned  vScrMass;
extern struct Block *vpBlockTop;
extern struct Block *vpCalcBlock;
extern long  vTopLine;
extern WORD  vAttrTitle;
extern WORD  vAttrList;
extern WORD  vAttrHigh;
extern WORD  vAttrCmd;
extern WORD  vAttrKey;
extern WORD  vAttrBar;

extern WORD  vSaveAttrTitle;
extern WORD  vSaveAttrList;
extern WORD  vSaveAttrHigh;
extern WORD  vSaveAttrCmd;
extern WORD  vSaveAttrKey;
extern WORD  vSaveAttrBar;

extern char    vChar;
extern char   *vpReaderStack;

extern long    vDirOffset;
long    GetLoffset(void);
void    SetLoffset(long);

extern long     vLastLine;
extern long     vNLine;
extern long     *vprgLineTable[];
extern HANDLE   vStdOut;
extern HANDLE   vStdIn;

extern char szScrollBarUp[2];
extern char szScrollBarDown[2];
extern char szScrollBarOff[2];
extern char szScrollBarOn[2];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\lread.c ===
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <windows.h>
#include "list.h"

// ReaderThread - Reads from the file
//
//  This thread is woken up by clearing SemReader,
//  then vReaderFlag instructs the thread on the course of
//  action to take.  When displaying gets to close to the end
//  of the buffer pool, vReadFlag is set and this thread is
//  started.

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
ReaderThread (
    DWORD dwParameter
    )
{
    unsigned    rc, code, curPri = 0;
    UNREFERENCED_PARAMETER(dwParameter);

    for (; ;) {

        //  go into 'boosted' pririoty until we start
        //  working on 'non-critical' read ahead. (Ie, far away).

        if (curPri != vReadPriBoost) {
            SetThreadPriority( GetCurrentThread(),
                               vReadPriBoost );
            curPri = vReadPriBoost;
        }
        WaitForSingleObject(vSemReader, WAITFOREVER);
        ResetEvent(vSemReader);
        code = vReaderFlag;
        for (; ;) {

            //  Due to this loop, a new command may have arrived
            //  which takes presidence over the automated command

            rc = WaitForSingleObject (vSemReader, DONTWAIT);
            if (rc == 0)                // New command has arrived
                break;

            switch (code)  {
                case F_NEXT:                        // NEXT FILE
                    NewFile ();
                    ReadDirect (vDirOffset);

                    //  Hack... adjust priority to make first screen look
                    //  fast.  (Ie, reader thread will have lower priority
                    //  at first; eventhough the display is really close
                    //  to the end of the buffer)

                    SetThreadPriority( GetCurrentThread(),
                                       vReadPriNormal );

                    break;
                case F_HOME:                        // HOME of FILE
                    vTopLine = 0L;
                    ReadDirect (0L);
                    break;
                case F_DIRECT:
                    ReadDirect (vDirOffset);
                    break;
                case F_DOWN:
                    ReadNext ();
                    break;
                case F_UP:
                    ReadPrev ();
                    break;
                case F_END:
                    break;
                case F_SYNC:
                    ResetEvent(vSemMoreData);
                    SetEvent(vSemSync);
                    WaitForSingleObject(vSemReader, WAITFOREVER);
                    ResetEvent(vSemReader);

                    ResetEvent(vSemSync);       // Reset trigger for
                                                // Next use.
                    code = vReaderFlag;
                    continue;               // Execute Syncronized command

                case F_CHECK:               // No command.
                    break;
                default:
                    ckdebug (1, "Bad Reader Flag");
            }
            //  Command has been processed.
            //  Now check to see if read ahead is low, if so set
            //  command and loop.

            if (vpTail->offset - vpCur->offset < vThreshold &&
                vpTail->flag != F_EOF) {
                    code = F_DOWN;              // Too close to ending
                    continue;
            }
            if (vpCur->offset - vpHead->offset < vThreshold  &&
                vpHead->offset != vpFlCur->SlimeTOF) {
                    code = F_UP;                // Too close to begining
                    continue;
            }

            //  Not critical, read ahead logic.  The current file

            // Normal priority (below display thread) for this
            if (curPri != vReadPriNormal) {
                SetThreadPriority( GetCurrentThread(),
                                   vReadPriNormal );
                curPri = vReadPriNormal;
            }

            if (vCntBlks == vMaxBlks)               // All blks in use for
                break;                              // this one file?

            if (vpTail->flag != F_EOF) {
                code = F_DOWN;
                continue;
            }
            if (vpHead->offset != vpFlCur->SlimeTOF)  {
                code = F_UP;
                continue;
            }


            if (vFhandle != 0) {            // Must have whole file read in
                CloseHandle (vFhandle);     // Close the file, and set flag
                vFhandle   = 0;
                if (!(vStatCode & S_INSEARCH)) {
                    ScrLock     (1);
                        Update_head ();
                    vDate [ST_MEMORY] = 'M';
                    dis_str ((Uchar)(vWidth - ST_ADJUST), 0, vDate);
                    ScrUnLock ();
                }
            }
            break;                          // Nothing to do. Wait
        }
    }
    return(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//  WARNING:  Microsoft Confidential!!!

void
NewFile ()
{
    char        s [60];
    char        h, c;
    SYSTEMTIME SystemTime;
    FILETIME    LocalFileTime;

    long      *pLine;
    HANDLE           TempHandle;

    struct Block **pBlk, **pBlkCache;


    if (vFhandle)
        CloseHandle (vFhandle);


    vFType     = 0;
    vCurOffset = 0L;

    //  WARNING:  Microsoft Confidential!!!

    strcpy (s, "Listing ");
    strcpy (s+8, vpFname);

    //  Design change per DougHo.. open files in read-only deny-none mode.

    vFhandle = CreateFile( vpFlCur->fname,
                           GENERIC_READ,
                           FILE_SHARE_READ|FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL );

    if (vFhandle  == (HANDLE)(-1)) {
        if (vpFlCur->prev == NULL && vpFlCur->next == NULL) {
                                                // Only one file specified?
            printf ("Could not open file '%Fs': %s",
                         (CFP) vpFlCur->fname, GetErrorCode( GetLastError() ));

            CleanUp();
            ExitProcess(0);
        }
        vFhandle = 0;                           // Error. Set externals to "safe"
        vFInfo.nFileSizeLow = (unsigned)-1L;    // settings.  Flag error by setting
        vNLine     = 1;                         // file_size = -1
        vLastLine  = NOLASTLINE;
        vDirOffset = vTopLine  = 0L;
        SetLoffset(0L);

        memset (vprgLineTable, 0, sizeof (long *) * MAXTPAGE);
        vprgLineTable[0] = (LFP) alloc_page ();
        if (!vprgLineTable[0]) {
            return;
        }
        vprgLineTable[0][0] = 0L;       // 1st line always starts @ 0

        strncpy (vDate, GetErrorCode( GetLastError() ), 20);
        vDate[20] = 0;
        return ;
    }

    TempHandle = FindFirstFile( vpFlCur->fname,
                                &vFInfo );
    if( TempHandle == (HANDLE)(-1) ){
        ckerr (GetLastError(), "FindFirstFile");
    if (!FindClose( TempHandle ))
        ckerr (GetLastError(), "FindCloseFile");
    }

    FileTimeToLocalFileTime( &(vFInfo.ftLastWriteTime), &LocalFileTime );
    FileTimeToSystemTime( &LocalFileTime, &SystemTime );
    h = (char)SystemTime.wHour;
    c = 'a';
    if (h >= 12) {
        c = 'p';         // pm
        if (h > 12)      // convert 13-23 --> 1pm-11pm
            h -= 12;
    }
    if (h == 0)          // convert 0 --> 12am
        h = 12;

    sprintf (vDate, "%c%c %c%c%c%c %2d/%02d/%02d  %2d:%02d%c",
          // File is in memory
          // Search is set for mult files

          vStatCode & S_MFILE      ? '*' : ' ',                         // File is in memory
          vFType & 0x8000          ? 'N' : ' ',                         // Network
          vFInfo.dwFileAttributes & FILE_ATTRIBUTE_NORMAL ? 'R' : ' ',  // Readonly
          vFInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ? 'H' : ' ',  // Hidden
          vFInfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM ? 'S' : ' ',  // System
          ' ',                                                          // Vio
          SystemTime.wMonth,
          SystemTime.wDay,
          SystemTime.wYear,
          h,
          SystemTime.wMinute,
          c);

    pBlkCache = &vpBCache;
    if (CompareFileTime( &vFInfo.ftLastWriteTime, &vpFlCur->FileTime ) != 0) {
        vpFlCur->NLine    = 1L;                 // Something has changed.
        vpFlCur->LastLine = NOLASTLINE;         // Scrap the old info, and
        vpFlCur->HighTop  = -1;                 // start over
        vpFlCur->TopLine  = 0L;
        vpFlCur->Loffset  = vpFlCur->SlimeTOF;

        FreePages  (vpFlCur);
        memset (vpFlCur->prgLineTable, 0, sizeof (long *) * MAXTPAGE);
        vpFlCur->FileTime = vFInfo.ftLastWriteTime;
        pBlkCache = &vpBFree;           // Move blks to free list, not cache list
    }

    // Restore last known information

    vTopLine    = vpFlCur->TopLine;
    SetLoffset(vpFlCur->Loffset);
    vLastLine   = vpFlCur->LastLine;
    vNLine      = vpFlCur->NLine;
    vOffTop     = 0;
    if (vpFlCur->Wrap)
        vWrap   = vpFlCur->Wrap;

        memcpy (vprgLineTable, vpFlCur->prgLineTable, sizeof (long *) * MAXTPAGE);

        if (vLastLine == NOLASTLINE)  {
            pLine = vprgLineTable [vNLine/PLINES] + vNLine % PLINES;
        }

        if (vprgLineTable[0] == NULL) {
            vprgLineTable[0] = (LFP) alloc_page ();
            if (!vprgLineTable[0]) {
                return;
            }
            vprgLineTable[0][0] = vpFlCur->SlimeTOF;
        }

        vDirOffset      = vprgLineTable[vTopLine/PLINES][vTopLine%PLINES];
        vDirOffset -= vDirOffset % ((long)BLOCKSIZE);


    //  Adjust buffers..
    //  Move cur buffers to other list
    //  Move cache buffers to other list
    //  Scan other list for cache blks, and move to cache (or free) list

    if (vpHead) {
        vpTail->next = vpBOther;        // move them into the other
        vpBOther = vpHead;              // list
        vpHead = NULL;
    }

    pBlk = &vpBCache;
    while (*pBlk)
        MoveBlk (pBlk, &vpBOther) ;

    pBlk = &vpBOther;
    while (*pBlk) {
        if ((*pBlk)->pFile == vpFlCur)
             MoveBlk (pBlk, pBlkCache);
        else pBlk  = &(*pBlk)->next;
    }
}



// ReadDirect - Moves to the direct position in the file
//
//  First check to see if start of buffers have direct position file,
//  if so then do nothing.  If not, clear all buffers and start
//  reading blocks.

void
ReadDirect (
    long offset
    )
{
    WaitForSingleObject(vSemBrief, WAITFOREVER);
    ResetEvent(vSemBrief);

    if (vpHead) {
        vpTail->next = vpBCache;        // move them into the cache
        vpBCache = vpHead;              // list
    }

    vpTail = vpHead = vpCur = alloc_block (offset);
    vpHead->next = vpTail->prev = NULL;
    vCntBlks = 1;

    //  Freeing is complete, now read in the first block.
    //  and process lines.

    ReadBlock (vpHead, offset);

    // maybe it fixes the bug

    vpBlockTop = vpHead;

    if (GetLoffset() <= vpHead->offset)
        add_more_lines (vpHead, NULL);

     SetEvent (vSemBrief);
     SetEvent (vSemMoreData);           // Signal another BLK read
}



// ReadNext - To read further into file

void
ReadNext ()
{
    struct Block *pt;
    long   offset;

    if (vpTail->flag == F_EOF)  {
                                        // No next to get, Trip
        SetEvent (vSemMoreData);        // moredata just in case
        return;                         // t1 has blocked on it
                                        // No next to get, Trip
    }
    offset = vpTail->offset+BLOCKSIZE;

    //  Get a block

    if (vCntBlks == vMaxBlks) {
        WaitForSingleObject(vSemBrief, WAITFOREVER);
        ResetEvent(vSemBrief);
        if (vpHead == vpCur) {
            SetEvent (vSemBrief);
            if ((GetLoffset() > vpTail->offset) && (GetLoffset() <= (vpTail->offset + BLOCKSIZE))) {
                offset = GetLoffset();
            }
            ReadDirect  (offset);
            return;
        }
        pt = vpHead;
        vpHead = vpHead->next;
        vpHead->prev = NULL;
        SetEvent (vSemBrief);
    } else
        pt = alloc_block (offset);

    pt->next = NULL;

    //  Before linking record into chain, or signaling MoreData
    //  line info is processed

    ReadBlock (pt, offset);
    if (GetLoffset() <= pt->offset)
        add_more_lines (pt, vpTail);

    WaitForSingleObject(vSemBrief, WAITFOREVER);
    ResetEvent(vSemBrief);              // Link in new
    vpTail->next = pt;                  // block, then
    pt->prev = vpTail;                  // signal
    vpTail = pt;
    SetEvent (vSemBrief);
    SetEvent (vSemMoreData);            // Signal another BLK read
}

void
add_more_lines (
    struct Block *cur,
    struct Block *prev
    )
{
    char        *pData;
    long        *pLine;
    Uchar       LineLen;
    Uchar       c;
    unsigned    LineIndex;
    unsigned    DataIndex;
    enum{ CT_ANK, CT_LEAD, CT_TRAIL } charType = CT_ANK;
    BOOL        fLastBlock;
    static UINT cp = 0;
    long        xNLine;

    // doesn't work w/ tabs... it should count the line len
    // with a different param, and figure in the TABs

    if (vLastLine != NOLASTLINE)
        return;

    if (vNLine/PLINES >= MAXTPAGE) {
        puts("Sorry, This file is too big for LIST to handle - MAXTPAGE limit exceeded\n");
        CleanUp();
        ExitProcess(0);
    }

    //  Find starting data position

    if (GetLoffset() < cur->offset) {
        DataIndex = (unsigned)(BLOCKSIZE - (GetLoffset() - prev->offset));
        pData = prev->Data + BLOCKSIZE - DataIndex;
        fLastBlock = FALSE;
    } else {
        DataIndex = cur->size;      // Use cur->size, in case EOF
        pData = cur->Data;
        fLastBlock = TRUE;
    }

    //  Get starting line length table position

    LineIndex = (unsigned)(vNLine % PLINES);
    pLine = vprgLineTable [vNLine / PLINES] + LineIndex;
    LineLen   = 0;

    if (cp==0) {
        cp = GetConsoleCP();
    }

    //  Look for lines in the file

    for (; ;) {
        c = *(pData++);

        switch (cp) {
            case 932:
                if( charType != CT_LEAD )
                    charType = IsDBCSLeadByte(c) ? CT_LEAD : CT_ANK;
                else
                    charType = CT_TRAIL;
                break;
            default:
                break;
        }

        if (--DataIndex == 0) {
            if (fLastBlock)
                break;                          // Last block to scan?
            DataIndex = cur->size;              // No, move onto next
            pData = cur->Data;                  // Block of data
            fLastBlock = TRUE;
        }

        LineLen++;

        if ((c == '\n') ||
            (c == '\r') ||
            (LineLen == vWrap) ||
            ((LineLen == vWrap-1) && (charType != CT_LEAD) && IsDBCSLeadByte(*pData))
           )
        {
            // Got a line. Check for CR/LF sequence, then record
            // it's length.

            if ( (c == '\n'  &&  *pData == '\r')  ||
                 (c == '\r'  &&  *pData == '\n'))
            {
                LineLen++;
                pData++;
                if (--DataIndex == 0) {
                    if (fLastBlock)
                        break;
                    DataIndex = cur->size;
                    pData = cur->Data;
                    fLastBlock = TRUE;
                }
            }

            SetLoffset(GetLoffset() + LineLen);
            *(pLine++) = GetLoffset();
            LineLen = 0;
            vNLine++;
            if (++LineIndex >= PLINES) {        // Overflowed table
                LineIndex = 0;
                vprgLineTable[vNLine / PLINES] = pLine = (LFP) alloc_page();
            }
        }
    }

    //  Was last line just processed?
    //  ... 0 len lines past EOF

    if (cur->flag & F_EOF) {
        if (LineLen) {
            SetLoffset(GetLoffset() + LineLen);
            *(pLine++) = GetLoffset();
            vNLine++;
            LineIndex++;
        }

        vLastLine = vNLine-1;
        xNLine = vNLine;
        for (c=0; c<MAXLINES; c++) {
            xNLine++;
            if (++LineIndex >= PLINES) {
                LineIndex = 0;
                vprgLineTable[xNLine / PLINES] = pLine = (LFP) alloc_page();
                }
                *(pLine++) = GetLoffset();
        }

        // Free the memory we don't need
    }
}



// ReadPrev - To read backwards into file

void
ReadPrev ()
{
    struct Block *pt;
    long   offset;

    if (vpHead->offset == 0L)   {       // No next to get, Trip
        SetEvent (vSemMoreData);        // moredata just in case
        return;                         // t1 has blocked on it
    }
    if (vpHead->offset == 0L)  {        // No next to get, Trip
        return;                         // t1 has blocked on it
    }
    offset = vpHead->offset-BLOCKSIZE;

    //  Get a block

    if (vCntBlks == vMaxBlks) {
        WaitForSingleObject(vSemBrief, WAITFOREVER);
        ResetEvent(vSemBrief);
        if (vpHead == vpCur) {
            SetEvent (vSemBrief);
            ReadDirect  (offset);
            return;
        }
        pt = vpTail;
        vpTail = vpTail->prev;
        vpTail->next = NULL;
        SetEvent (vSemBrief);
    } else
        pt = alloc_block (offset);

    pt->prev = NULL;

    ReadBlock (pt, offset);
    WaitForSingleObject(vSemBrief, WAITFOREVER);
    ResetEvent(vSemBrief);              // Link in new
    vpHead->prev = pt;                  // block, then
    pt->next = vpHead;                  // signal
    vpHead = pt;
    SetEvent (vSemBrief);
    SetEvent (vSemMoreData);            // Signal another BLK read
}



// ReadBlock - Read in one block

void
ReadBlock (
    struct Block *pt,
    long offset
    )
{
    long     l;
    DWORD       dwSize;


    if (pt->offset == offset)
        return;

    pt->offset = offset;

    if (vFhandle == 0) {                // No file?
        pt->size = 1;
        pt->flag = F_EOF;
        pt->Data[0] = '\n';
        return;
    }

    if (offset != vCurOffset) {
        l = SetFilePointer( vFhandle, offset, NULL, FILE_BEGIN );
        if (l == -1) {
            ckerr (GetLastError(), "SetFilePointer");
        }
    }
    if( !ReadFile (vFhandle, pt->Data, BLOCKSIZE, &dwSize, NULL) ) {
        ckerr ( GetLastError(), "ReadFile" );
    }
    pt->size = (USHORT) dwSize;
    if (pt->size != BLOCKSIZE) {
         pt->Data[pt->size++] = '\n';
         memset (pt->Data + pt->size, 0, BLOCKSIZE-pt->size);
         pt->flag = F_EOF;
         vCurOffset += pt->size;
    } else {
        pt->flag = 0;
        vCurOffset += BLOCKSIZE;
    }
}


void
SyncReader ()
{
    vReaderFlag = F_SYNC;
    SetEvent   (vSemReader);
    WaitForSingleObject(vSemSync, WAITFOREVER);
    ResetEvent(vSemSync);
}


// These functions are used for the call to HexEdit()

NTSTATUS
fncRead (
    HANDLE  h,
    DWORD   loc,
    char    *data,
    DWORD   len,
    ULONG   *ploc
    )
{
    DWORD   l, br;

    l = SetFilePointer (h, loc, NULL, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!ReadFile (h, data, len, &br, NULL))
        return GetLastError();

    return (br != len ? ERROR_READ_FAULT : 0);
}


NTSTATUS
fncWrite (
    HANDLE  h,
    DWORD   loc,
    char    *data,
    DWORD   len,
    ULONG   ploc
    )
{
    DWORD    l, bw;

    l = SetFilePointer (h, loc, NULL, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!WriteFile (h, data, len, &bw, NULL))
        return GetLastError();

    return (bw != len ? ERROR_WRITE_FAULT : 0);
}


long CurrentLineOffset;

long GetLoffset() {
    return(CurrentLineOffset);
}

void SetLoffset(long l) {
    CurrentLineOffset = l;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\lsearch.c ===
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include "list.h"

static char ReMap [256];
#define FOUND       0
#define NOT_FOUND   1
#define ABORT       2

int
GetNewFile ()
{
    char    FileName [160];
    struct  Flist   *pOrig;

    SyncReader ();
    GetInput ("File...> ", FileName, 160);
    if (FileName[0] == 0)  {
        SetUpdate (U_HEAD);
        SetEvent (vSemReader);
        return (0);
    }
    pOrig = vpFlCur;
    AddFileToList (FileName);
    vpFlCur = pOrig;
    SetEvent (vSemReader);
    return (1);
}

void
GetSearchString ()
{
    UpdateHighClear ();
    GetInput ("String.> ", vSearchString, 40);
    InitSearchReMap ();
}


void
InitSearchReMap ()
{
    unsigned  i;

    if (vStatCode & S_NOCASE)
        _strupr (vSearchString);

    /*
     *  Build ReMap
     */
    for (i=0; i < 256; i++)
        ReMap[i] = (char)i;

    if (vStatCode & S_NOCASE)
        for (i='a'; i <= 'z'; i++)
            ReMap[i] = (char)(i - ('a' - 'A'));
}


void
FindString()
{
    char    eof, dir_next;
    long    offset, lrange, line, l, hTopLine;
    struct  Flist   *phCurFile, *pFile;

    if (vSearchString[0] == 0)  {
        SetUpdate (U_HEAD);
        return ;
    }

    SetUpdate (U_NONE);
    DisLn (CMDPOS, (Uchar)(vLines+1), "Searching");
    vStatCode |= S_INSEARCH;
    dir_next   = (char)(vStatCode & S_NEXT);

    /*
     *  Get starting point for search in the current file.
     *  Save current file, and location.
     */
    hTopLine  = vTopLine;
    phCurFile = vpFlCur;

    if (vHighTop >= 0L)
        vTopLine = vHighTop;
    if (vStatCode & S_NEXT)
        vTopLine++;
    if (vTopLine >= vNLine)
        vTopLine = vNLine-1;

    QuickRestore ();      /* Jump to starting line    */

    for (; ;) {
        /*
        *  Make sure starting point is in memory
        */
        while (InfoReady () == 0) {     /* Set extern values  */
            ResetEvent   (vSemMoreData);
            SetEvent   (vSemReader);
            WaitForSingleObject(vSemMoreData, WAITFOREVER);
            ResetEvent(vSemMoreData);
        }

        if (! dir_next) {
            if (vOffTop)
                vOffTop--;
            else if (vpBlockTop->prev) {
                vpBlockTop = vpBlockTop->prev;
                vOffTop    = vpBlockTop->size;
            }
        }

        vTopLine = 1L;


        /*
        *  Do the search.
        *  Use 2 different routines, for speed.
        *
        *  Uses vpBlockTop & vOffTop. They are set up by setting TopLine
        *  then calling InfoReady.
        */
        eof = (char)SearchText (dir_next);

        if (eof != FOUND)
            vTopLine = hTopLine;

        /* Multi-file search?  Yes, go onto next file     */
        if (eof == NOT_FOUND  &&  (vStatCode & S_MFILE)) {
            if (vStatCode & S_NEXT) {
                if ( (pFile = vpFlCur->next) == NULL)
                    break;
                NextFile (0, pFile);        /* Get file       */
                hTopLine = vTopLine;        /* Save position      */
                vTopLine = line = 0;        /* Set search position  */
            } else {
                if ( (pFile = vpFlCur->prev) == NULL)
                    break;
                NextFile (0, pFile);
                hTopLine = vTopLine;
                if (vLastLine == NOLASTLINE) {  /* HACK. if EOF is unkown   */
                    dir_next = S_NEXT;      /* goto prev file, but scan */
                    vTopLine = line = 0;    /* from TOF to EOF      */
                } else {
                    vTopLine = (line = vLastLine) - vLines;
                    dir_next = 0;           /* else, scan from EOF to   */
                    if (vTopLine < 0)       /* TOF.         */
                        vTopLine = 0;
                }
            }
            QuickRestore ();        /* Display 1 page of new    */
            SetUpdate (U_ALL);      /* new file. then set scan  */
            SetUpdate (U_NONE);     /* position       */
            vTopLine = line;
            continue;
        }

        break;          /* Done searching     */
    }

    /*
     *  If not found (or abort), then resotre position
     */
    vStatCode &= ~S_INSEARCH;
    if (eof) {
        if (phCurFile != vpFlCur)   /* Restore file & position      */
            NextFile (0, phCurFile);
        QuickRestore ();

        SetUpdate (U_ALL);      /* Force screen update, to fix  */
        SetUpdate (U_NONE);     /* scroll bar position.     */
        DisLn (CMDPOS, (Uchar)(vLines+1), eof == 1 ? "* Text not found *" : "* Aborting Search *");
        if (eof == 1)
            beep ();
        return ;
    }

    // Search routine adjusts vpBlockTop & vOffTop to next(prev)
    // occurance of string.  Now the line # must be set.

    offset = vpBlockTop->offset + vOffTop;

    lrange = vNLine/4 + 2;
    line   = vNLine/2;
    while (lrange > 4L) {
        l = vprgLineTable[line/PLINES][line%PLINES];
        if (l < offset) {
            if ( (line += lrange) > vNLine)
                line = vNLine;
        } else {
            if ( (line -= lrange) < 0L)
                line = 0L;
        }
        /*  lrange >>= 1;  */
        lrange = (lrange>>1) + 1;
    }
    line += 7;

    while (vprgLineTable[line/PLINES][line%PLINES] > offset)
        line--;

    vHighTop = line;
    vHighLen = 0;

    /*
     *  Was found. Adjust to be in center of CRT
     */
    GoToMark ();
}

int
SearchText (
    char dir
    )
{
    char  *data;
    char  *data1;
    int     i;
    Uchar   c, d;

    for (; ;) {
        data = vpBlockTop->Data;
        data += vOffTop;

        if (ReMap [(unsigned char)*data] == vSearchString[0]) {
            data1 = data;
            i = vOffTop;
            d = 1;
            for (; ;) {
                c = vSearchString[d++];
                if (c == 0)
                    return (FOUND);

                if (++i >= BLOCKSIZE) {
                    while (vpBlockTop->next == NULL) {
                        vpCur = vpBlockTop;
                        vReaderFlag = F_DOWN;
                        SetEvent   (vSemReader);
                        WaitForSingleObject(vSemMoreData, WAITFOREVER);
                        ResetEvent(vSemMoreData);
                    }
                    i = 0;

                    data1 = vpBlockTop->next->Data;

                } else {

                    data1++;
                }

                if (ReMap [(unsigned char)*data1] != (char)c)
                    break;
            }
        }
        if (dir) {
            vOffTop++;
            if (vOffTop >= BLOCKSIZE) {
                if (vpBlockTop->flag == F_EOF)
                    return (NOT_FOUND);
                fancy_percent ();
                if (_abort ())
                    return (ABORT);
                while (vpBlockTop->next == NULL) {
                    vpCur = vpBlockTop;
                    vReaderFlag = F_DOWN;
                    SetEvent   (vSemReader);
                    WaitForSingleObject(vSemMoreData, WAITFOREVER);
                    ResetEvent(vSemMoreData);
                }
                vOffTop = 0;
                vpBlockTop = vpBlockTop->next;
            }
        } else {
            vOffTop--;
            if (vOffTop < 0) {
                if (vpBlockTop->offset == 0L)
                    return (NOT_FOUND);
                fancy_percent ();
                if (_abort ())
                    return (ABORT);
                while (vpBlockTop->prev == NULL) {
                    vpCur = vpBlockTop;
                    vReaderFlag = F_UP;
                    SetEvent   (vSemReader);
                    WaitForSingleObject(vSemMoreData, WAITFOREVER);
                    ResetEvent(vSemMoreData);
                }
                vOffTop = BLOCKSIZE - 1;
                vpBlockTop = vpBlockTop->prev;
            }
        }
    }
}


void
GoToMark ()
{
    long    line;

    if (vHighTop < 0L)
        return ;

    line = vHighTop;
    UpdateHighClear ();

    vTopLine = 1;
    vHighTop = line;
    line = vHighTop - vLines / 2;

    while (line >= vNLine) {
        if (! (vLastLine == NOLASTLINE)) {  /* Mark is past EOF?  */
            vHighTop = vLastLine - 1;   /* Then set it to EOF.  */
            break;
        }
        if (_abort()) {
            line = vNLine-1;
            break;
        }
        fancy_percent ();     /* Wait for marked line */
        vpBlockTop  = vpCur = vpTail;   /* to be processed  */
        vReaderFlag = F_DOWN;
        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }

    if (line > vLastLine - vLines)
        line = vLastLine - vLines;

    if (line < 0L)
        line = 0L;

    vTopLine = line;
    vHLBot   = vHLTop = 0;
    QuickRestore ();
    SetUpdate (U_ALL);
}


void
GoToLine ()
{
    char    LineNum [10];
    long    line;

    GetInput ("Line #.> ", LineNum, 10);
    if (LineNum[0] == 0)
        return;
    line = atol (LineNum);
    vHighTop = line;
    vHighLen = 0;

    GoToMark ();
}


void
SlimeTOF ()
{
    char    Text [10];
    long    KOff;

    SyncReader ();
    GetInput ("K Off..> ", Text, 40);
    KOff  = atol (Text) * 1024;
    KOff -= KOff % BLOCKSIZE;
    if (Text[0] == 0  ||  KOff == vpFlCur->SlimeTOF) {
        SetEvent (vSemReader);
        return;
    }

    vpFlCur->SlimeTOF = KOff;
    vpFlCur->FileTime.dwLowDateTime = (unsigned)-1;    /* Cause info to be invalid     */
    vpFlCur->FileTime.dwHighDateTime = (unsigned)-1;  /* Cause info to be invalid */
    FreePages (vpFlCur);
    NextFile  (0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\lmisc.c ===
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "list.h"

BOOL IsValidKey (PINPUT_RECORD  pRecord);
int     set_mode1(PCONSOLE_SCREEN_BUFFER_INFO pMode, int mono);

void
ShowHelp (
    void
    )
{
static struct {
    int     x, y;
    char    *text;
} *pHelp, rgHelp[] = {
     0,  0, "List - Help",
    40,  0, "Rev 1.0j",

     0,  1, "Keyboard:",
     0,  2, "Up, Down, Left, Right",
     0,  3, "PgUp   - Up one page",
     0,  4, "PgDn   - Down one page",
     0,  5, "Home   - Top of listing",
     0,  6, "End    - End of listing",

     0,  8, "W      - Toggle word wrap",
     0,  9, "^L     - Refresh display",
     0, 10, "Q, ESC - Quit",

     0, 12, "/      - Search for string",
     0, 13, "\\      - Search for string. Any case",
     0, 14, "F4     - Toggle multifile search",
     0, 15, "n, F3  - Next occurance of string",
     0, 16, "N      - Previous occurance of string",
     0, 18, "C      - Clear highlight line",
     0, 19, "J      - Jump to highlighted line",
     0, 20, "M      - Mark highlighed",

    38,  1, "[list] - in tools.ini",
    40,  2, "width     - Width of crt",
    40,  3, "height    - Height of crt",
    40,  4, "buffer    - K to use for buffers (200K)",
    40,  5, "tab       - Tab alignment #",
    40,  6, "tcolor    - Color of title line",
    40,  7, "lcolor    - Color of listing",
    40,  8, "hcolor    - Color of highlighted",
    40,  9, "bcolor    - Color of scroll bar",
    40, 10, "ccolor    - Color of command line",
    40, 11, "kcolor    - Color of keyed input",
    40, 12, "nobeep    - Disables beeps",

    40, 14, "^ Up   - Pull copy buffer up",
    40, 15, "^ Down - Pull copy buffer down",
    40, 16, "^ Home - Slide copy buffer up",
    40, 17, "^ End  - Slide copy buffer down",
    40, 18, "G      - Goto Line number",

    40, 20, "^ PgUp - Previous File",
    40, 21, "^ PgDn - Next File",
    40, 22, "F      - New File",

     0,  0, NULL
} ;

    int     Index;
    int     hLines, hWidth;
    INPUT_RECORD    InpBuffer;
    DWORD dwNumRead;

    //
    //  Block reader thread.
    //
    SyncReader ();
    hLines = vLines;
    hWidth = vWidth;
    set_mode (25, 80, 0);
    ClearScr ();

    for (pHelp = rgHelp; pHelp->text; pHelp++)
        dis_str ((Uchar)(pHelp->x), (Uchar)(pHelp->y), pHelp->text);

    setattr (vLines+1, (char)vAttrList);
    setattr (vLines+2, (char)vAttrCmd);
    DisLn (0, (UCHAR)vLines+2, "Press enter.");
    for (; ;) {
        ReadConsoleInput( vStdIn,
                          &InpBuffer,
                          1,
                          &dwNumRead );
        if( IsValidKey( &InpBuffer ) &&
            ( ( InpBuffer.Event.KeyEvent.wVirtualKeyCode == 0x0d ) ||
              ( InpBuffer.Event.KeyEvent.wVirtualKeyCode == 0x1b ) ) ) {
                break;
        }
    }

    //
    // Free reader thread
    //
    for( Index = 0; Index < MAXLINES; Index++ ) {
        vrgLen[Index] = ( Uchar )vWidth-1;
    }
    set_mode (hLines+2, hWidth, 0);
    setattr (vLines+1, (char)vAttrCmd);
    setattr (vLines+2, (char)vAttrList);
    vReaderFlag = F_CHECK;
    SetEvent   (vSemReader);
}


void
GetInput (
    char *prompt,
    char *string,
    int len
    )
{
    COORD   dwCursorPosition;
    DWORD   cb;

    SetUpdate (U_NONE);
    DisLn (0, (Uchar)(vLines+1), prompt);

    setattr2 (vLines+1, CMDPOS, len, (char)vAttrKey);
    if (!ReadFile( vStdIn, string, len, &cb, NULL ))
        return;

    if( (string[cb - 2] == 0x0d) || (string[cb - 2] == 0x0a) ) {
        string[cb - 2] = 0;     // Get rid of CR LF
    }

    setattr2 (vLines+1, CMDPOS, len, (char)vAttrCmd);

    string[ cb - 1] = 0;
    if (string[0] < ' ')
        string[0] = 0;

    dwCursorPosition.X = CMDPOS;
    dwCursorPosition.Y = (SHORT)(vLines+1);
    SetConsoleCursorPosition( vhConsoleOutput, dwCursorPosition );
}

void
beep (
    void
    )
{
    if (vIniFlag & I_NOBEEP)
        return;
}


int
_abort (
    void
    )
{
    INPUT_RECORD    InpBuffer;
    DWORD dwNumRead;
    static char     WFlag = 0;

    if (! (vStatCode & S_WAIT) ) {
        DisLn ((Uchar)(vWidth-6), (Uchar)(vLines+1), "WAIT");
        vStatCode |= S_WAIT;
    }

    if( PeekConsoleInput( vStdIn, &InpBuffer, 1, &dwNumRead ) && dwNumRead ) {
        ReadConsoleInput( vStdIn, &InpBuffer, 1, &dwNumRead );
        if( IsValidKey( &InpBuffer ) ) {
            return( 1 );
        }
    }
    return( 0 );
}


void
ClearScr ()
{
    COORD   dwCursorPosition;
    COORD   dwWriteCoord;
    DWORD           dwNumWritten;
    SMALL_RECT      ScrollRectangle;
    SMALL_RECT      ClipRectangle;
    COORD           dwDestinationOrigin;
    CHAR_INFO       Fill;

    setattr (0, (char)vAttrTitle);

    dwWriteCoord.X = 0;
    dwWriteCoord.Y = 1;

    FillConsoleOutputCharacter( vhConsoleOutput,
                                ' ',
                                vWidth*(vLines),
                                dwWriteCoord,
                                &dwNumWritten );


    FillConsoleOutputAttribute( vhConsoleOutput,
                                vAttrList,
                                vWidth*(vLines),
                                dwWriteCoord,
                                &dwNumWritten );

    ScrollRectangle.Left = (SHORT)(vWidth-1);
    ScrollRectangle.Top = 1;
    ScrollRectangle.Right = (SHORT)(vWidth-1);
    ScrollRectangle.Bottom = (SHORT)(vLines);
    ClipRectangle.Left = (SHORT)(vWidth-2);
    ClipRectangle.Top = 1;
    ClipRectangle.Right = (SHORT)(vWidth+1);
    ClipRectangle.Bottom = (SHORT)(vLines);
    dwDestinationOrigin.X = (SHORT)(vWidth-2);
    dwDestinationOrigin.Y = 1;
    Fill.Char.AsciiChar = ' ';
    Fill.Attributes = vAttrBar;

    ScrollConsoleScreenBuffer(
            vhConsoleOutput,
            &ScrollRectangle,
            &ClipRectangle,
            dwDestinationOrigin,
            &Fill );



    setattr (vLines+1, (char)vAttrCmd);

    dwCursorPosition.X = CMDPOS;
    dwCursorPosition.Y = (SHORT)(vLines+1);
    SetConsoleCursorPosition( vhConsoleOutput, dwCursorPosition );

    vHLBot = vHLTop = 0;
}


int
set_mode (
    int nlines,
    int ncols,
    int mono
    )
{
    WORD    attrib;
    int     i;

    CONSOLE_SCREEN_BUFFER_INFO  Mode, Mode1;

    if (!GetConsoleScreenBufferInfo( vhConsoleOutput,
                                &Mode )) {
        printf("Unable to get screen buffer info, code = %x \n", GetLastError());
        exit(-1);
    }

    Mode1 = Mode;

    if (nlines) {
        Mode.dwSize.Y = (SHORT)nlines;
        Mode.srWindow.Bottom = (SHORT)(Mode.srWindow.Top + nlines - 1);
        Mode.dwMaximumWindowSize.Y = (SHORT)nlines;
    }
    if (ncols) {
        Mode.dwSize.X = (SHORT)ncols;
        Mode.srWindow.Right = (SHORT)(Mode.srWindow.Left + ncols - 1);
        Mode.dwMaximumWindowSize.X = (SHORT)ncols;
    }
    if (mono) {                     // Toggle mono setting?
        attrib = vAttrTitle;
        vAttrTitle = vSaveAttrTitle;
        vSaveAttrTitle = attrib;
        attrib = vAttrList;
        vAttrList = vSaveAttrList;
        vSaveAttrList = attrib;
        attrib = vAttrHigh;
        vAttrHigh = vSaveAttrHigh;
        vSaveAttrHigh = attrib;
        attrib = vAttrKey;
        vAttrKey = vSaveAttrKey;
        vSaveAttrKey = attrib;
        attrib = vAttrCmd;
        vAttrCmd = vSaveAttrCmd;
        vSaveAttrCmd = attrib;
        attrib = vAttrBar;
        vAttrBar = vSaveAttrBar;
        vSaveAttrBar = attrib;
    }

    //
    //  Try to set the hardware into the correct video mode
    //

    if ( !set_mode1 (&Mode, mono) ) {
        return( 0 );
    }

    vConsoleCurScrBufferInfo = Mode;

    vLines = Mode.dwSize.Y - 2;             /* Not top or bottom line   */
    vWidth = Mode.dwSize.X;

    if (vScrBuf) {
        free (vScrBuf);
        vScrBuf=NULL;
    }

    vSizeScrBuf = (vLines) * (vWidth);
    vScrBuf = malloc (vSizeScrBuf);

    vLines--;

    for (i=0; i < vLines; i++)
       vrgLen[i] = (Uchar)(vWidth-1);

    return (1);
}


int
set_mode1 (
    PCONSOLE_SCREEN_BUFFER_INFO pMode,
    int     mono
    )
{
    mono = 0;       // To get rid of warning message

    ClearScr();
    return( SetConsoleScreenBufferSize( vhConsoleOutput, pMode->dwSize ) );
}


struct Block *
alloc_block(
    long offset
    )
{
    struct Block  *pt, **pt1;

    if (vpBCache)  {
        pt1 = &vpBCache;
        for (; ;) {                             /* Scan cache       */
            if ((*pt1)->offset == offset) {
                pt   = *pt1;                    /* Found in cache   */
                *pt1 = (*pt1)->next;            /* remove from list */
                goto Alloc_Exit;                /* Done.            */
            }

            if ( (*pt1)->next == NULL)  break;
            else  pt1=&(*pt1)->next;
        }
        /* Warning: don't stomp on pt1!  it's used at the end to
         * return a block from the cache if everything else is in use.
         */
    }

    /*
     *  Was not in cache, so...
     *  return block from free list, or...
     *  allocate a new block, or...
     *  return block from other list, or...
     *  return from far end of cache list.
     *      [works if cache list is in sorted order.. noramly is]
     */
    if (vpBFree) {
        pt      = vpBFree;
        vpBFree = vpBFree->next;
        goto Alloc_Exit1;
    }

    if (vAllocBlks != vMaxBlks) {
        pt = (struct Block *) malloc (sizeof (struct Block));
        ckerr (pt == NULL, MEMERR);

        pt->Data = GlobalAlloc( 0, BLOCKSIZE );
        ckerr( !pt->Data, MEMERR );

        vAllocBlks++;
        goto Alloc_Exit1;
    }

    if (vpBOther) {
        pt       = vpBOther;
        vpBOther = vpBOther->next;
        goto Alloc_Exit1;
    }


    /* Note: there should be a cache list to get here, if not   */
    /* somebody called alloc_block, and everything was full     */
    ckdebug (!vpBCache, "No cache");

    if (offset < vpBCache->offset) {    /* Look for far end of cache    */
        pt   = *pt1;                    /* Return one from tail         */
        *pt1 = NULL;
        goto Alloc_Exit1;
    }                                   /* else,                        */
    pt = vpBCache;                      /* Return one from head         */
    vpBCache = vpBCache->next;
    goto Alloc_Exit1;


Alloc_Exit1:
    pt->offset = -1L;

Alloc_Exit:
    pt->pFile = vpFlCur;
    vCntBlks++;
    return (pt);
}


void
MoveBlk (
    struct Block **pBlk,
    struct Block **pHead
    )
{
    struct Block *pt;

    pt = (*pBlk)->next;
    (*pBlk)->next = *pHead;
    *pHead = *pBlk;
    *pBlk  = pt;
}

char *
alloc_page()
{
    char        *pt;

    pt = (char *)malloc( 64*1024 );
    return (pt);
}


void
FreePages(
    struct Flist *pFl
    )
{
    int   i;
    long  * fpt;

    for (i=0; i < MAXTPAGE; i++) {
        fpt = pFl->prgLineTable [i];
        if (fpt == 0L)  break;
        free ( fpt );
        pFl->prgLineTable[i] = NULL;
    }
}


void
ListErr (
    char *file,
    int line,
    char *cond,
    int value,
    char *mess
    )
{
    char    s[80];

    printf ("ERROR in file %s, line %d, %s = %d, %s (%s)\n",
                file, line, cond, value, mess, GetErrorCode (value));
    gets (s);
    CleanUp();
    ExitProcess(0);
}


char *
GetErrorCode(
    int code
    )
{
    static  struct  {
        int     errnum;
        char    *desc;
    } EList[] = {
        2, "File not found",
        3, "Path not found",
        4, "Too many open files",
        5, "Access denied",
        8, "Not enough memory",
       15, "Invalid drive",
       21, "Device not ready",
       27, "Sector not found",
       28, "Read fault",
       32, "Sharing violation",
      107, "Disk changed",
      110, "File not found",
      123, "Invalid name",
      130, "Invalid for direct access handle",
      131, "Seek on device",
      206, "Filename exceeds range",

       -1, "Char DEV not supported",
       -2, "Pipe not supported",
        0, NULL
    };

    static  char  s[15];
    int     i;


    for (i=0; EList[i].errnum != code; i++)
        if (EList[i].errnum == 0) {
            sprintf (s, "Error %d", code);
            return (s);
        }
    return (EList[i].desc);
}



BOOL
IsValidKey (
    PINPUT_RECORD  pRecord
    )
{
    if ( (pRecord->EventType != KEY_EVENT) ||
         !(pRecord->Event).KeyEvent.bKeyDown ||
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0) ||        // ALT
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0x10) ||     // SHIFT
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0x11) ||     // CONTROL
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0x14) ) {    // CAPITAL
            return( FALSE );
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\list\newldis.c ===
#include <malloc.h>
#include <windows.h>
// #include <wincon.h>
#include "list.h"


static  unsigned char*  pData;
static  ULONG   ulBlkOffset;
static  char*   pBuffer;

typedef enum {
  CT_LEAD = 0,
  CT_TRAIL = 1,
  CT_ANK = 2,
  CT_INVALID = 3,
} DBCSTYPE;

DBCSTYPE    DBCScharType( char* str, int index )
{

//  TT .. ??? maybe LEAD or TRAIL
//  FT .. second == LEAD
//  FF .. second == ANK
//  TF .. ??? maybe ANK or TRAIL

    if ( index >= 0 ){
        char* pos = str+index;
        DBCSTYPE candidate = (IsDBCSLeadByte( *pos-- ) ? CT_LEAD : CT_ANK);
        BOOL maybeTrail = FALSE;
        for ( ; pos >= str; pos-- ){
            if ( !IsDBCSLeadByte( *pos ) )
                break;
            maybeTrail ^= 1;
        }
        return maybeTrail ? CT_TRAIL : candidate;
    }
    return CT_INVALID;
}


void
BuildLine(
          ULONG  ulRow,
          char*  pchDest
         )
{
    ULONG   ulIndentation;
    ULONG   ulBufferIndex;
    ULONG   ulDataLeft;
    ULONG   ulNumberOfSpaces;
    unsigned char*  pTOL = pData;

    ulBufferIndex = 0;
    ulDataLeft = vrgNewLen[ ulRow ];
    ulIndentation = vIndent;
    while ( (ulBufferIndex < (ULONG)(vWidth - 1)) && ulDataLeft ) {
        if ( ulBlkOffset >= BLOCKSIZE ) {
            ulBlkOffset = ulBlkOffset % BLOCKSIZE;
            while (vpBlockTop->next == NULL) {
                vReaderFlag = F_DOWN;
                SetEvent   (vSemReader);
                WaitForSingleObject(vSemMoreData, WAITFOREVER);
                ResetEvent(vSemMoreData);
            }
            vpBlockTop = vpBlockTop->next;
            pData = vpBlockTop->Data + ulBlkOffset;
            pTOL = pData;
        }

        if ( ulIndentation ) {
            if ( *pData++ == 0x09 ) {
                ulIndentation -= vDisTab - (ulIndentation % vDisTab);
            } else {
                ulIndentation--;
            }
        } else {
            if (*pData >= 0x20) {
                *pchDest++ = *pData++;
                if ((ulBufferIndex == 0) &&
                    vIndent &&
                    (DBCScharType(pTOL, (int)(pData-1-pTOL)) == CT_TRAIL)
                   )
                {
                    *(pchDest-1) = 0x20;
                }
                ulBufferIndex++;
            } else if ( (*pData == 0x0d) || (*pData == 0x0a) ) {
                *pchDest++ = 0x20;
                pData++;
                ulBufferIndex++;
            } else if (*pData == 0x09) {
                ulNumberOfSpaces = vDisTab - ulBufferIndex % vDisTab;
                while (ulNumberOfSpaces && ( ulBufferIndex < (ULONG)( vWidth - 1 ) ) ) {
                    *pchDest++ = 0x20;
                    ulBufferIndex++;
                    ulNumberOfSpaces--;
                }
                pData++;
            } else {
                *pchDest++ = *pData++;
                ulBufferIndex++;
            }
        }
        ulDataLeft--;
        ulBlkOffset++;
    }

    if (DBCScharType(pTOL, (int)(pData-1-pTOL)) == CT_LEAD){
        ulDataLeft++;
        ulBlkOffset--;
        ulBufferIndex--;
        pData--;
        pchDest--;
    }

    pData += ulDataLeft;
    ulBlkOffset += ulDataLeft;
    while (ulBufferIndex < (ULONG)(vWidth -1)) {
        *pchDest++ = 0x20;
        ulBufferIndex++;
    }
}


void
DisTopDown(
           void
          )
{
    ULONG   ulRow;
    char    *pt;

    pData = vpBlockTop->Data;
    pData += vOffTop;
    ulBlkOffset = vOffTop;

    pt = vScrBuf+vWidth;

    for (ulRow=0; ulRow < (ULONG)vLines; ulRow++ ) {
        BuildLine (ulRow, pt);
        pt += vWidth;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\loc\loc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    loc.h

Abstract:

    This is the main include file for the loc utility.

Author:

    Darryl Havens (darrylh) 6-Nov-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\loc\loc.c ===
#include "loc.h"

/* Statistic variables */
unsigned int lines;             /* lines of text */
unsigned int locs;              /* lines of code */
unsigned int semis;             /* semicolons */
unsigned int clocs;             /* commented lines of code */
unsigned int cls;               /* comment lines */

unsigned int  totfiles = 0;     /* #files */
unsigned long totlines = 0L;    /* total lines of text */
unsigned long totlocs = 0L;     /* total lines of code */
unsigned long totsemis = 0L;    /* total semicolons */
unsigned long totclocs = 0L;    /* total commented lines of code */
unsigned long totcls = 0L;      /* total comment lines */

char *pTotStr;

char linebuf[ 256 ];

int fBanner, fErr, fDetail, fRbrace;
FILE *locout;

FILE *fh;
char buf[2];

char ReadChar( void ) {
    if (buf[0] != (char)EOF) {
        buf[0] = buf[1];
        buf[1] = (char)fgetc( fh );
        }

    return( buf[0] );
}

char PeekChar( void ) {
    if (buf[0] != (char)EOF) {
        return( buf[ 1 ] );
        }
    else {
        return( (char)EOF );
        }
}


void
ProcessFile(
    char *pName,
    struct findType *pbuf,
    void *Args
    )
{
    unsigned int CommentFound, CommentLevel, CountChars;
    register char *s;
    char c, QuoteChar;

    if (!(fh = fopen( pName, "rt" ))) {
        fprintf( stderr, "*** Unable to read file - %s\n", pName );
        fErr = TRUE;
        return;
        }
    buf[0] = 0;
    buf[1] = 0;
    ReadChar();

    if (!fBanner) {
        fprintf( locout, "%-14s %7s %7s %9s %7s %7s %7s %8s\n",
                         "",
                         "", "", "Commented",
                         "Comment", "Comment", "", "LOC/semi" );
        fprintf( locout, "%-14s %7s %7s %9s %7s %7s %7s %8s\n",
                         fDetail ? "File Name" : "Component Name",
                         "Lines", "LOCS", "LOCS",
                         "Lines", "Ratio", "Semis", "Ratio" );
        fBanner = TRUE;
        }

    lines = 0;
    locs = 0;
    semis = 0;
    clocs = 0;
    cls = 0;
    CommentLevel = 0;
    QuoteChar = 0;
    CountChars = 0;
    CommentFound = FALSE;
    while ((c = ReadChar()) != (char)EOF) {
        if (c == '\n') {
            lines++;
            if (CountChars) {
                if (CommentFound) {
                    clocs++;
                    }

                locs++;
                CountChars = 0;
                }
            else
            if (CommentFound) {
                cls++;
                }

            CommentFound = FALSE;
            }
        else
        if (c == '/') {
            if (PeekChar() == '*') {
                CommentLevel++;
                ReadChar();
                while ((c = ReadChar()) != (char)EOF) {
                    if (c == '/') {
                        if (PeekChar() == '*') {
                            ReadChar();
                            CommentLevel++;
                            }
                        else {
                            CommentFound = TRUE;
                            }
                        }
                    else
                    if (c == '*') {
                        if (PeekChar() == '/') {
                            ReadChar();
                            if (!--CommentLevel) {
                                break;
                                }
                            }
                        else {
                            CommentFound = TRUE;
                            }
                        }
                    else
                    if (c == '\n') {
                        lines++;
                        if (CommentFound) {
                            cls++;
                            CommentFound = 0;
                            }
                        }
                    else
                    if (c > ' ') {
                        CommentFound = TRUE;
                        }
                    }
                }
            else
            if (PeekChar() == '/') {
                ReadChar();
                while ((c = PeekChar()) != '\n') {
                    if (c == (char)EOF) {
                        break;
                        }
                    else
                    if (ReadChar() > ' ') {
                        CommentFound = TRUE;
                        }
                    }
                }
            else {
                CountChars++;
                }
            }
        else
        if (c == '\'' || c == '\"') {
            QuoteChar = c;
            CountChars++;
            while ((c = ReadChar()) != (char)EOF) {
                CountChars++;
                if (c == '\\') {
                    ReadChar();
                    }
                else
                if (c == QuoteChar) {
                    if (PeekChar() == QuoteChar) {
                        CountChars++;
                        ReadChar();
                        }
                    else {
                        break;
                        }
                    }
                else
                if (c == '\n') {
                    lines++;
                    locs++;
                    }
                }
            }
        else
        if (fRbrace && (c == '}')) {
            if (CountChars) {
                CountChars++;
                }
            }
        else {
            if (c == ';') {
                semis++;
                }
            if (CountChars || c > ' ') {
                CountChars++;
                }
            }
        }

    if (fDetail)
        fprintf( locout, "%7u %7u %9u %7u %7.2f %7u %8.2f %s\n",
                 lines, locs, clocs, cls,
                 ((float) cls + (float) clocs / 2) / (float)( locs ? locs : 1),
                 semis,
                 (float) locs / (float)(semis ? semis : 1) , pName);

    totfiles++;
    totlines += lines;
    totlocs += locs;
    totsemis += semis;
    totclocs += clocs;
    totcls += cls;

    fclose( fh );
}

void
DoTotals() {
    if (totfiles)
        fprintf( locout, "%-14s %7lu %7lu %9lu %7lu %7.2f %7lu %8.2f\n",
                 pTotStr ? pTotStr : "Totals",
                 totlines, totlocs, totclocs, totcls,
                 ((float) totcls + (float) totclocs / 2) /
                                        (float)(totlocs ? totlocs : 1),
                 totsemis,
                 (float) totlocs / (float)(totsemis ? totsemis : 1) );

    if (pTotStr) {
        free( pTotStr );
        pTotStr = NULL;
        }

    totfiles = 0;
    totlocs = 0L;
    totsemis = 0L;
    totclocs = 0L;
    totcls = 0L;
}


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    FILE *fh;
    char *p, buf[ 128 ], *p1;
    int i;

    ConvertAppToOem( argc, argv );
    fErr = FALSE;
    fDetail = TRUE;
    fRbrace = TRUE;
    pTotStr = NULL;
    locout = stdout;

    for (i=1; i<argc; i++) {
        p = argv[ i ];
        if (*p == '/' || *p == '-') {
            while (*++p)
                switch (toupper( *p )) {
                case 'S':   {
                    fDetail = FALSE;
                    break;
                    }

                case 'B':   {
                    fRbrace = FALSE;
                    break;
                    }

                case 'F':   {
                    strcpy( buf, argv[ ++i ] );
                    p1 = strbscan( buf, "." );
                    if (!*p1)
                        strcpy( p1, ".loc" );

                    if (fh = fopen( buf, "r" )) {
			while (fgetl( buf, 128, fh )) {
                            if (buf[ 0 ] == '*') {
                                DoTotals();
                                pTotStr = MakeStr( strbskip( buf, "*" ) );
                                }
                            else
                            if (buf[ 0 ])
                                forfile( buf, -1, ProcessFile, NULL );
                            }

                        DoTotals();
                        fclose( fh );
                        }
                    else {
                        fprintf( stderr, "Unable to open response file - %s\n",
                                         buf );
                        fErr = TRUE;
                        }

                    break;
                    }

                default: {
                    fprintf( stderr, "*** Invalid switch - /%c\n", *p );
                    fErr = TRUE;
                    }
                }
            }
        else
            forfile( p, -1, ProcessFile, NULL );
        }

    if (fErr) {
        fprintf( stderr, "Usage: LOC [/S] [/F responseFile] fileTemplates ...\n" );
        fprintf( stderr, "    /S  - summary only (no individual file counts)\n" );
        fprintf( stderr, "    /B  - old mode, counting lone } lines as LOCs\n" );
        fprintf( stderr, "    /F  - read file templates from responseFile\n" );
        }
    else
        DoTotals();

    return( 0 );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\listmung\listmung.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    listmung.c

Abstract:

    This is the main module for a stubfile generation utility

Author:

    Sanford Staab (sanfords) 22-Apr-1992

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <windef.h>

#define STRING_BUFFER_SIZE 120
char StringBuffer[STRING_BUFFER_SIZE];
char ItemBuffer[STRING_BUFFER_SIZE];
char ItemBuffer2[STRING_BUFFER_SIZE];
char *ListName, *TemplateName;
FILE *ListFile, *TemplateFile;

char szBEGINTRANSLATE[] = "BeginTranslate";
char szENDTRANSLATE[] = "EndTranslate";
char szENDTRANSLATEQLPC[] = "EndTranslateQLPC";

BOOL IsTranslateTag(char * pBuffer)
{
    return (_strnicmp(pBuffer, szBEGINTRANSLATE, sizeof(szBEGINTRANSLATE)-1) == 0)
            || (_strnicmp(pBuffer, szENDTRANSLATE, sizeof(szENDTRANSLATE)-1) == 0);
}

BOOL IsCommentOrTag(char * pBuffer)
{
    return ((*pBuffer == ';') || IsTranslateTag(pBuffer));
}

int
ProcessParameters(
    int argc,
    char *argv[]
    )
{
    char c, *p;

    while (*++argv != NULL) {

        p = *argv;

        //
        // if we have a delimiter for a parameter, case throught the valid
        // parameter. Otherwise, the rest of the parameters are the list of
        // input files.
        //

        if (*p == '/' || *p == '-') {

            //
            // Switch on all the valid delimiters. If we don't get a valid
            // one, return with an error.
            //

            c = *++p;

            switch (toupper( c )) {
            default:
                return 0;
            }

        } else {

            ListName = *argv++;
            TemplateName = *argv++;

            return (ListName && TemplateName);
        }
    }

    return 0;
}


BOOL mysubstr(
char *s,
char *find,
char *put)
{
    char *p;
    if (p = strstr(s, find)) {
        strcpy(p, put);
        strcpy(p + strlen(put), p + strlen(find));  // find > put!
        return(TRUE);
    }
    return(FALSE);
}


VOID myprint(
char *s,
char *item,
int index)
{
    if (strstr(s, "%d") || mysubstr(s, "%%INDEX%%", "%d")) {
        printf(s, item, index);
    } else {
        printf(s, item);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   myfgets
//
//  Synopsis:  Calls fgets to read a string from a file.
//              It ignores empty lines or lines starting with a blank character
//
//              This is needed when the input file was generated by the
//               compiler preprocessor. Using the preprocessor allows us
//               to use #idfdef, #inlcude, etc in the original list file.
//
//  Arguments:  [pszBuff] -- Buffer to store the string
//              [iBuffSize] -- Buffer size
//              [pFile] -- Pointer to the file to read
//
//  Return      [pszRet] -- Pointer to pszBuff if succesful read. NULL otherwise.
//----------------------------------------------------------------------------
char * myfgets(
char * pszBuff,
int iBuffSize,
FILE * pFile)
{
    char *pszRet;
    while (pszRet = fgets(pszBuff, iBuffSize, pFile)) {
        if ((*pszRet == '\n') || (*pszRet == ' ')) {
            continue;
        } else {
            break;
        }
    }

    return pszRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   SkipCommentsAndTags
//
//  Synopsis:  Calls myfgets to read a string from a file.
//              It ignores lines starting with ; (ie, comments) and lines
//               containing the Begin/EndTranslate tags.
//
//  Arguments:  [pszBuff] -- Buffer to store the string
//              [iBuffSize] -- Buffer size
//              [pFile] -- Pointer to the file to read
//
//  Return      [pszRet] -- Pointer to pszBuff if succesful read. NULL otherwise.
//----------------------------------------------------------------------------
char * SkipCommentsAndTags(
char * pszBuff,
int iBuffSize,
FILE * pFile)
{
    char *pszRet;
    while (pszRet = myfgets(pszBuff, iBuffSize, pFile)) {
        if (IsCommentOrTag(pszRet)) {
            continue;
        } else {
            break;
        }
    }

    return pszRet;
}

void
ProcessTemplate( void )
{
    char *s;
    char *pchItem;
    char *pchLastItem;
    int index;

    s = fgets(StringBuffer,STRING_BUFFER_SIZE,TemplateFile);

    while ( s ) {
        if (mysubstr(s, "%%FOR_ALL_UPPER%%", "%-45s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    pchItem = _strupr(pchItem);
                    if (IsTranslateTag(ItemBuffer)) {
                        myprint(s, pchItem, index);
                    } else {
                        myprint(s, pchItem, index++);
                    }
                } else {
                    printf("// %s", ItemBuffer);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL%%", "%s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    myprint(s, pchItem, index++);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL_QLPC%%", "%s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    if (_strnicmp(ItemBuffer, szENDTRANSLATEQLPC, sizeof(szENDTRANSLATEQLPC)-1) == 0)
                        break;
                    myprint(s, pchItem, index++);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL_LPC%%", "%s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    if (_strnicmp(ItemBuffer, szENDTRANSLATEQLPC, sizeof(szENDTRANSLATEQLPC)-1) == 0)
                        break;
                }
            }
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    myprint(s, pchItem, index++);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL_BUT_LAST%%", "%s")) {
            rewind(ListFile);
            index = 0;
            pchLastItem = SkipCommentsAndTags(ItemBuffer, STRING_BUFFER_SIZE, ListFile);
            if (pchLastItem != NULL) {
                pchLastItem[strlen(pchLastItem) - 1] = '\0';  // strip off \n
                while (pchItem = myfgets(ItemBuffer2, STRING_BUFFER_SIZE, ListFile)) {
                    if (!IsCommentOrTag(pchItem)) {
                        pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                        myprint(s, pchLastItem, index++);     // Write previous line
                        strcpy(pchLastItem, pchItem);         // Save current line
                    }
                }
            } else {
                fprintf(stderr,"LISTMUNG: FOR_ALL_BUT_LAST: no lines found\n");
            }

        } else if (mysubstr(s, "%%FOR_LAST%%", "%s")) {
            rewind(ListFile);
            index = 0;
            pchLastItem = SkipCommentsAndTags(ItemBuffer, STRING_BUFFER_SIZE, ListFile);
            if (pchLastItem != NULL) {
                pchLastItem[strlen(pchLastItem) - 1] = '\0';  // strip off \n
                while (pchItem = myfgets(ItemBuffer2, STRING_BUFFER_SIZE, ListFile)) {
                    if (!IsCommentOrTag(pchItem)) {
                        pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                        strcpy(pchLastItem, pchItem);         // Save current line
                        index++;
                    }
                }
                myprint(s, pchLastItem, index);         // Write Last line.
            } else {
                fprintf(stderr,"LISTMUNG: FOR_LAST: no lines found\n");
            }

        } else {
            printf("%s", s);
        }
        s = fgets(StringBuffer,STRING_BUFFER_SIZE,TemplateFile);
    }
}



int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    if (!ProcessParameters( argc, argv )) {

        fprintf( stderr, "Stub File Generation Utility. Version: 1.1\n" );
        fprintf( stderr, "usage: listmung <symbol_list_file> <template>\n" );
        fprintf( stderr, " Converts the elements in the list file into an output file\n" );
        fprintf( stderr, " where the template dictates the format.  The following strings\n");
        fprintf( stderr, " are substituted apropriately:\n");
        fprintf( stderr, " %%FOR_ALL%%\n");
        fprintf( stderr, " %%FOR_ALL_UPPER%%\n");
        fprintf( stderr, " %%FOR_ALL_BUT_LAST%%\n");
        fprintf( stderr, " %%FOR_LAST%%\n");
        fprintf( stderr, " %%INDEX%%\n");
        fprintf( stderr, " output is to stdout.\n");

        return 1;

    }

    if ( (ListFile = fopen(ListName,"r")) == 0) {
        fprintf(stderr,"LISTMUNG: Unable to open list file.\n");
        return 1;
    }

    if ( (TemplateFile = fopen(TemplateName,"r")) == 0) {
        fprintf(stderr,"LISTMUNG: Unable to open template file.\n");
        return 1;
    }

    ProcessTemplate();

    fclose(ListFile);
    fclose(TemplateFile);

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\logerr\logerr.cpp ===
//+-----------------------------------------------------------------------------
//
// File				logerr.cpp
// 
// Contents			Error and output logging to avoid broken nmake
//					This program reassigns stderr and stdout to two files 
//					named TMPERR and tmpout, executes a given command and
//					appends the error and output messages to logerr.err
//					and logerr.log respectively.
//
//					Returns 1 (which stops the execution of nmake) only if
//					logerr.err is not accesible. All other i/o errors are
//	 				logged to logerr.err.
// 
// Author & Date    adinas  02/18/98 create file
//                  adinas  04/15/98 update to the new bingen's error values
//                  bensont 04/05/00 
//
//-------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include <winerror.h>
#include <windows.h>
#include <string.h>
#include "iodll.h"
#include <ntverp.h>


#define LOGFILE            "LOGFILE"	// The exactly string of the system environment variable name
#define ERRFILE            "ERRFILE"	// The exactly string of the system environment variable name
#define TEMPEXT            ".temp"
#define DEFAULT_LOGFILE "logerr.log"	// Default log filename
#define DEFAULT_ERRFILE "logerr.err"	// Default err filename

#define MAX_FNAME_LEN       MAX_PATH     // Maximum length of the log/err filename string
#define MAX_CMD_LEN             2048	 // Maximum length of the command-line string
#define LAST_KNOWN_WRN            11	 // Maximum warning number known by logerr
#define LAST_KNOWN_ERR           130     // Maximum error number known by logerr
#define IODLL_UNKNOWN              1	 // Used for unknown IODLL errors or warning
#define SYSTEM                     1	 // Used for bingen errors with code > LAST_ERROR

CHAR * pszCmdLine = NULL;
CHAR szCommand[MAX_CMD_LEN];
CHAR szLine[MAX_CMD_LEN];

CHAR szLogfile[MAX_FNAME_LEN];  // Log filename, ex "logerr.log"
CHAR szTempLogfile[MAX_FNAME_LEN];  // Temp Log filename, ex "logerr.err.temp"
CHAR szErrfile[MAX_FNAME_LEN];  // Error filename, ex "logerr.err"
CHAR szTempErrfile[MAX_FNAME_LEN];  // Temp Error filename, ex "logerr.err.temp"

FILE *bak_std_out = stdout;		// Backup stdout 
FILE *bak_std_err = stderr;		// Backup stdin

FILE *out_stream = NULL;             // Stream for the new stdout
FILE *out_stream_temp = NULL;             // Stream for the new stdout
FILE *err_stream = NULL;             // Stream for the err file
FILE *err_stream_temp = NULL;        // Stream for the new stderr

int returnval  = 0;             // Return value
DWORD errorlevel = 0;
BOOL Status;
BOOL bReportError = FALSE;
BOOL bBuildCommand = FALSE;


// Define macros for printing
//     fatal error messages (FATAL)  at stderr
//     fatal error messages (SFATAL) in logerr.log and logerr.err
//     error messages       (ERRMSG) in logerr.log and logerr.err
//     error number         (ERRNO)  in logerr.log and logerr.err
//     warning messages     (WRNMSG) in logerr.log
//     no messages          (NOMSG)  in logerr.log

#define FATAL(err,msg) \
fprintf(bak_std_err,"fatal error: %s %s",err,msg); \
returnval=1;

#define SFATAL(err,msg) \
fprintf(bak_std_out,"fatal error: %s %s",err,msg); \
fprintf(bak_std_err,"fatal error: %s %s",err,msg); \
returnval=1;

#define ERRMSG(err,msg)	\
fprintf(stderr,"ERROR %s: %s\n",#err,msg); \
fprintf(stdout,"ERROR %s: %s\n",#err,msg);
	
#define ERRNO(err,msg)	\
fprintf(stderr,"ERROR %d: %s\n",err,msg); \
fprintf(stdout,"ERROR %d: %s\n",err,msg);

#define WRNMSG(wrn,msg) \
fprintf(stdout,"WARNING %s: %s\n",#wrn,msg);

#define WRNNO(wrn,msg) \
fprintf(stdout,"WARNING %d: %s\n",wrn,msg);

#define NOMSG(msg) \
fprintf(stdout,"%s\n",msg);

// Print the command preceeded by ERROR or WARNING
// if errorlevel is non zero.
// Use ReportCmdExit for all commands but bingen.
// For bingen, use ReportBingenExit.
int __cdecl ReportCmdExit( INT errorlevel, CHAR* szCmdline );
int __cdecl ReportBingenExit ( INT errorlevel, CHAR* szCmdline );
int __cdecl ReportBuildExit ( INT errorlevel, CHAR* szCmdline );
int __cdecl ReportRsrcExit ( INT errorlevel, CHAR* szCmdline );

void __cdecl strlower(char *s);
char * __cdecl strnchr(char *s, char c);
int  __cdecl GetEnvVar(char *envvarname, char *valuebuffer, char *defaultvalue, int bufsize);
void __cdecl AppendDump(FILE *Master, CHAR *Transfile, BOOL bLogError);

//+--------------------------------------------------------------
//
// Function: main
//
//---------------------------------------------------------------

int 
__cdecl main(
		int argc,
		char* argv[] )
{
	SSIZE_T len = 0;			// The string length of the first item (command) of the command line

	// PROCESS_INFORMATION piProcInfo;
	// STARTUPINFO siStartInfo;

	// If no argument, print the help.
	if ( argc !=2 ) goto Help;

	pszCmdLine = strnchr(argv[1], ' ');

Help:;
	// Provide help for using the tool, if required
	if ( argc <= 1 ||
			0 == strcmp( argv[1], "/?" ) ||
			0 == strcmp( argv[1], "-?" ) ||
			NULL == pszCmdLine ) {

		fprintf( stderr, "Usage:\tlogerr \"<command line>\"\n");
		fprintf( stderr, "Ex:\tlogerr \"xcopy /vf c:\\tmp\\myfile.txt .\"\n");

		returnval = 1;
		goto Error;
	}

	// Get Environment, LOGFILE, ERRFILE and ComSpec
	if (    (GetEnvVar(LOGFILE, szLogfile, DEFAULT_LOGFILE, MAX_FNAME_LEN) == 0) ||
			(GetEnvVar(ERRFILE, szErrfile, DEFAULT_ERRFILE, MAX_FNAME_LEN) == 0))
		goto Error;

	// Evaluate templog filename
	strcpy(szTempLogfile, szLogfile);
	strcpy(&szTempLogfile[strlen(szTempLogfile)], TEMPEXT);

	// Evaluate temperr filename
	strcpy(szTempErrfile, szErrfile);
	strcpy(&szTempErrfile[strlen(szTempErrfile)], TEMPEXT);

	// Prepare the output / error output file handle

	if ( (out_stream = fopen( szLogfile, "at")) == NULL) {
		FATAL(szLogfile, "Failed to open log file.");
		goto Error;
	}

	if ( (out_stream_temp = freopen(szTempLogfile, "w+t", stdout)) == NULL) {
		FATAL(szTempLogfile, "Failed to open temp error file.");
		goto Error;
	}

	if ( (err_stream = fopen(szErrfile, "a+t")) == NULL) {
		FATAL(szErrfile, "Failed to open error file.");
		goto Error;
	}

	if ( (err_stream_temp = freopen(szTempErrfile, "w+t", stderr)) == NULL) {
		FATAL(szTempErrfile, "Failed to open temp error file.");
		goto Error;
	}

	fseek(out_stream, 0, SEEK_END);
	fseek(err_stream, 0, SEEK_END);


	// Get the argument as command line (pszCmdLine)
	if (strlen(pszCmdLine) >= MAX_CMD_LEN ) { //- default_cmd_len - strlen(buf)
		FATAL(pszCmdLine, "The Full Command is too long !!!");
		goto Error;
	}

	// Get the first word as command (szCommand)
	len = strchr(pszCmdLine, ' ') - pszCmdLine;
	if (len < 0) len = strlen(pszCmdLine);
	if (len >= MAX_CMD_LEN) {
		FATAL(pszCmdLine,"The First Command is too long !!!");
		goto Error;
	}

	// system to execute the program
	strncpy(szCommand, pszCmdLine, len);
	strlower(szCommand);

	errorlevel=system( pszCmdLine );
		if ( strcmp( szCommand, "bingen" ) == 0) 
			bReportError = ReportBingenExit( errorlevel, pszCmdLine );
		else if ( _stricmp( szCommand, "rsrc" ) == 0)
			bReportError = ReportRsrcExit( errorlevel, pszCmdLine );
		else if ( _stricmp( szCommand, "build" ) == 0) {
			bReportError = ReportBuildExit( errorlevel, pszCmdLine );
			bBuildCommand = TRUE;
		} else
			bReportError = ReportCmdExit( errorlevel, pszCmdLine );

	// Temp Error file complete, set to err_stream
	SetStdHandle(STD_ERROR_HANDLE, err_stream);
	if (NULL != err_stream_temp)
		fclose(err_stream_temp);
	else {
		FATAL(szTempErrfile, "Failed to close error file.");
		goto Error;
	}

	// Temp Error file complete, set to err_stream
	SetStdHandle(STD_OUTPUT_HANDLE, out_stream);
	if (NULL != out_stream_temp) 
		fclose(out_stream_temp);
	else {
		FATAL(szTempLogfile, "Failed to close log file.");
		goto Error;
	}
	
	if (bReportError) {
		fprintf(err_stream, "ERROR %d: %s\n", errorlevel, pszCmdLine);
		fprintf(out_stream, "ERROR %d: %s\n", errorlevel, pszCmdLine);
	} else {
		fprintf(out_stream, "%s\n", pszCmdLine);
	}

	AppendDump(out_stream, szTempLogfile, 0);

	if (bBuildCommand)
		AppendDump(out_stream, "Build.log", 0);

	AppendDump(out_stream, szTempErrfile, 1);

	if (bBuildCommand) 
		AppendDump(err_stream, "Build.err", 1);

Error:
	SetStdHandle(STD_ERROR_HANDLE, bak_std_out);
	SetStdHandle(STD_OUTPUT_HANDLE, bak_std_err);

	if (NULL != err_stream)
		fclose(err_stream);
	if (NULL != out_stream)
		fclose(out_stream);

	// Delete the temporary files

	_unlink (szTempErrfile);
	_unlink (szTempLogfile);

	return returnval;

} // main

int
__cdecl ReportBingenExit(
				INT errorlevel,
				CHAR* szCmdline
						 ) {

	int result=FALSE;
    switch (errorlevel) {

    case ERROR_NO_ERROR:
        // NOMSG(szCmdline);
        break;

    case ERROR_RW_NO_RESOURCES:
        WRNMSG(ERROR_RW_NO_RESOURCES,szCmdline);
        break;

    case ERROR_RW_VXD_MSGPAGE:
        WRNMSG(ERROR_RW_VXD_MSGPAGE,szCmdline);
        break;

    case ERROR_IO_CHECKSUM_MISMATCH:
        WRNMSG(ERROR_IO_CHECKSUM_MISMATCH,szCmdline);
        break;

    case ERROR_FILE_CUSTOMRES:
        WRNMSG(ERROR_FILE_CUSTOMRES,szCmdline);
        break;

    case ERROR_FILE_VERSTAMPONLY:
        WRNMSG(ERROR_FILE_VERSTAMPONLY,szCmdline);
        break;

    case ERROR_RET_RESIZED:
        WRNMSG(ERROR_RET_RESIZED,szCmdline);
        break;

    case ERROR_RET_ID_NOTFOUND:
        WRNMSG(ERROR_RET_ID_NOTFOUND,szCmdline);
        break;

    case ERROR_RET_CNTX_CHANGED:
        WRNMSG(ERROR_RET_CNTX_CHANGED,szCmdline);
        break;

    case ERROR_RET_INVALID_TOKEN:
        WRNMSG(ERROR_RET_INVALID_TOKEN,szCmdline);
        break;

    case ERROR_RET_TOKEN_REMOVED:
        WRNMSG(ERROR_RET_TOKEN_REMOVED,szCmdline);
        break;

    case ERROR_RET_TOKEN_MISMATCH:
        WRNMSG(ERROR_RET_TOKEN_MISMATCH,szCmdline);
        break;

    case ERROR_HANDLE_INVALID:
        ERRMSG(ERROR_HANDLE_INVALID,szCmdline);
		result = TRUE;
        break;

    case ERROR_READING_INI:
        ERRMSG(ERROR_READING_INI,szCmdline);
		result = TRUE;
        break;

    case ERROR_NEW_FAILED:
        ERRMSG(ERROR_NEW_FAILED,szCmdline);
		result = TRUE;
        break;

    case ERROR_OUT_OF_DISKSPACE:
        ERRMSG(ERROR_OUT_OF_DISKSPACE,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_OPEN:
        ERRMSG(ERROR_FILE_OPEN,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_CREATE:
        ERRMSG(ERROR_FILE_CREATE,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_INVALID_OFFSET:
        ERRMSG(ERROR_FILE_INVALID_OFFSET,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_READ:
        ERRMSG(ERROR_FILE_READ,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_WRITE:
        ERRMSG(ERROR_FILE_WRITE,szCmdline);
		result = TRUE;
        break;

    case ERROR_DLL_LOAD:
        ERRMSG(ERROR_DLL_LOAD,szCmdline);
		result = TRUE;
        break;

    case ERROR_DLL_PROC_ADDRESS:
        ERRMSG(ERROR_DLL_PROC_ADDRESS,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_LOADIMAGE:
        ERRMSG(ERROR_RW_LOADIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_PARSEIMAGE:
        ERRMSG(ERROR_RW_PARSEIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_GETIMAGE:
        ERRMSG(ERROR_RW_GETIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_NOTREADY:
        ERRMSG(ERROR_RW_NOTREADY,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_BUFFER_TOO_SMALL:
        ERRMSG(ERROR_RW_BUFFER_TOO_SMALL,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_INVALID_FILE:
        ERRMSG(ERROR_RW_INVALID_FILE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_IMAGE_TOO_BIG:
        ERRMSG(ERROR_RW_IMAGE_TOO_BIG,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_TOO_MANY_LEVELS:
        ERRMSG(ERROR_RW_TOO_MANY_LEVELS,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALIDITEM:
        ERRMSG(ERROR_IO_INVALIDITEM,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALIDID:
        ERRMSG(ERROR_IO_INVALIDID,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALID_DLL:
        ERRMSG(ERROR_IO_INVALID_DLL,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_TYPE_NOT_SUPPORTED:
        ERRMSG(ERROR_IO_TYPE_NOT_SUPPORTED,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALIDMODULE:
        ERRMSG(ERROR_IO_INVALIDMODULE,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_RESINFO_NULL:
        ERRMSG(ERROR_IO_RESINFO_NULL,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_UPDATEIMAGE:
        ERRMSG(ERROR_IO_UPDATEIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_FILE_NOT_SUPPORTED:
        ERRMSG(ERROR_IO_FILE_NOT_SUPPORTED,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_SYMPATH_NOT_FOUND:
        ERRMSG(ERROR_FILE_SYMPATH_NOT_FOUND,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_MULTILANG:
        ERRMSG(ERROR_FILE_MULTILANG,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_SYMBOLFILE_NOT_FOUND:
        ERRMSG(ERROR_IO_SYMBOLFILE_NOT_FOUND,szCmdline);
		result = TRUE;
        break;

    default:
        break;
    };

    if (errorlevel > LAST_KNOWN_WRN && errorlevel <= LAST_WRN) {
        WRNMSG(IODLL_UNKNOWN,szCmdline);
    }
    if (errorlevel > LAST_KNOWN_ERR && errorlevel <= LAST_ERROR) {
		result = TRUE;
        ERRMSG(IODLL_UNKNOWN,szCmdline);
    }
    if (errorlevel > LAST_ERROR) {
		result = TRUE;
        ERRMSG(SYSTEM,szCmdline);
    }

    return result;

} // ReportBingenExit

int
__cdecl ReportCmdExit (
			INT errorlevel,
			CHAR* szCmdline) {

	int result=FALSE;

    switch (errorlevel) {
    case 0:
		// NOMSG(szCmdline);
		break;
    default:
		// ERRNO(errorlevel,szCmdline);
		result = TRUE;
    }
    return result;

} // ReportCmdExit

int
__cdecl ReportRsrcExit(
				INT errorlevel,
				CHAR* szCmdline
						 ) {
	int result=FALSE;

    switch (errorlevel) {

    case 0:
        // NOMSG(szCmdline);
        break;
    case 1:
        WRNNO(1,szCmdline );
        break;
    default:
        ERRNO(errorlevel,szCmdline );
		result = TRUE;
        break;
    } // switch
	return result;
}

int
__cdecl ReportBuildExit(
				INT errorlevel,
				CHAR* szCmdline
						 ) {
	int result=FALSE;

    switch (errorlevel) {

    case 0:
        // NOMSG(szCmdline);
        break;
    default:
        // ERRNO(errorlevel,szCmdline );
		result = TRUE;
        break;
    } // switch
	return result;
}

char * __cdecl strnchr(char *s, char c) {
	while(*s==c);
	return (*s==NULL)?NULL:s;
}


int __cdecl GetEnvVar(char *envvarname, char *valuebuffer, char *defaultvalue, int bufsize) {

	int ret = 0;

	// ret == 0 => undefine ERRFILE, set to default
	// ret > MAX_FNAME_LEN => out of buffersize, set to fatal error
	if ((ret=GetEnvironmentVariable(envvarname, valuebuffer, bufsize)) == 0)
		strcpy(valuebuffer, defaultvalue);
	else if (ret > bufsize) {
		FATAL(envvarname,"The Environment Variable's value is too long!!!");
		return 0;
	}
	return 1;
}

void __cdecl strlower(char *s) {
	while(*s) {
		if(isalpha(*s)) *s|=0x20;
		s++;
	}
}

void __cdecl AppendDump(FILE *Master, CHAR *Transfile, BOOL bLogError) {
	SSIZE_T len = 0;
	FILE *Transaction;

	if ((Transaction=fopen(Transfile, "rt")) == NULL) {
 			return;
	}

	while (fgets(szLine, sizeof(szLine) - sizeof(szLine[0]), Transaction)) {

		// Remove double \n
		for (len = strlen(szLine); --len >=0 && szLine[len] < ' '; szLine[len]=0);

		// Next Line if is empty line
		if (len < 1) continue;

		if (0 != ferror(Transaction)) {
			SFATAL(Transfile,"Unable to open for reading");
			return;
		} // if

		// Write to log file
		fprintf(Master, "\t%s\n", szLine);

		// Write to error file if need
		if (bLogError && bReportError) fprintf(err_stream, "\t%s\n", szLine);
	}

	if( ferror( Transaction ) )      {
		FATAL(pszCmdLine,"Temp error file broken !!!");
	}         

	if (NULL != Transaction)
		fclose(Transaction);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\logerr\makefile.inc ===
# Empty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\data.c ===
/*****************************************************************************
 *
 * data.c
 *
 *****************************************************************************/

#include "m4.h"

CTOK ctokArg;
F g_fTrace;
HASH g_hashMod = 37;
PDIV g_pdivArg;
PDIV g_pdivExp;
PDIV g_pdivErr;
PDIV g_pdivOut;
PDIV g_pdivNul;
PDIV g_pdivCur;
PSTM g_pstmCur;
PPMAC mphashpmac;
PTOK ptokMax;
PTOK ptokTop;
PTOK rgtokArgv;

DeclareStaticTok(tokEof, 2, StrMagic(tchEof));
DeclareStaticTok(tokEoi, 2, StrMagic(tchEoi));
DeclareStaticTok(tokColonTab, 2, TEXT(":\t"));
DeclareStaticTok(tokEol, cbEol, EOL);
DeclareStaticTok(tokRparColonSpace, 3, TEXT("): "));
DeclareStaticTok(tokTraceLpar, 6, TEXT("trace("));

BYTE rgbIdent[128] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 00 - 0F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 10 - 1F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 20 - 2F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, /* 30 - 3F */
    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 40 - 4F */
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 3, /* 50 - 5F */
    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 60 - 6F */
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, /* 70 - 7F */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\crackle.c ===
/*****************************************************************************
 *
 * crackle.c
 *
 *  User-defined macros.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  opcAddDollar
 *
 *  Add a $* or $@ to the current token buffer.
 *
 *****************************************************************************/

DeclareOpc(opcAddDollar)
{
    if (itok > 1) {
        AddExpTch(tchComma);
    }
    if (dw) {
        AddExpTch(tchLquo);
    }
    AddExpPtok(ptok);
    if (dw) {
        AddExpTch(tchRquo);
    }
}

/*****************************************************************************
 *
 *  TraceArgv
 *
 *  Trace a macro call.  Collect the output in the Exp hold and smear it
 *  to stderr when it's all ready.
 *
 *****************************************************************************/

void STDCALL
TraceArgv(ARGV argv)
{
    TOK tok;
    OpenExpPtok(&tok);
    AddExpPtok(&tokTraceLpar);
    AddExpPtok(&tokRparColonSpace);
    AddExpPtok(ptokArgv(0));
    if (ctokArgv) {
        AddExpTch('(');
        EachOpcArgvDw(opcAddDollar, argv, 0); /* Dump in $* format */
        AddExpTch(')');
    }
    AddExpPtok(&tokEol);
    CsopExpDopPdivPtok(AddPdivPtok, g_pdivErr, &tok);
    FlushPdiv(g_pdivErr);
}

/*****************************************************************************
 *
 *  PushSubstPtokArgv
 *
 *  Produce a macro expansion and shove the result back into the stream.
 *
 *****************************************************************************/

void STDCALL
PushSubstPtokArgv(PTOK ptok, ARGV argv)
{
    PTCH ptch;
    TOK tok;

    OpenExpPtok(&tok);

    for (ptch = ptchPtok(ptok); ptch < ptchMaxPtok(ptok); ptch++) {
        if (*ptch != '$' || ptch == ptchMaxPtok(ptok) - 1) {
            JustAddIt:
            AddExpTch(*ptch);
        } else {
            switch (ptch[1]) {

            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                if (ptch[1] - '0' <= ctokArgv) {
                    AddExpPtok(ptokArgv(ptch[1] - '0'));
                }
                break;

            case '#':                   /* $# = argc */
                AddExpAt(ctokArgv);     /* Note: Add, not Push! */
                break;

            case '*':                   /* $* = comma list */
                EachOpcArgvDw(opcAddDollar, argv, 0);
                break;

            case '@':                   /* $@ = quoted comma list */
                EachOpcArgvDw(opcAddDollar, argv, 1);
                break;

            default:
                goto JustAddIt;         /* Just add the '$' */
            }
            ptch++;
        }
    }

    CsopExpDopPdivPtok((DIVOP)PushZPtok, 0, &tok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\assert.c ===
/*****************************************************************************
 *
 * assert.c
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  PrintPtszPtszVa
 *
 *  Perform printf-style formatting, but much more restricted.
 *
 *      %s - null-terminated string
 *      %P - snapped TOKEN structure
 *      %d - decimal number
 *
 *****************************************************************************/

UINT STDCALL
PrintPtszPtszVa(PTSTR ptszBuf, PCTSTR ptszFormat, va_list ap)
{
    PTSTR ptsz = ptszBuf;
    PTOK ptok;

    for (;;) {
        if (*ptszFormat != '%') {
            *ptsz++ = *ptszFormat;
            if (*ptszFormat == TEXT('\0'))
                return (UINT)(ptsz - ptszBuf - 1);
            ptszFormat++;
            continue;
        }

        /*
         *  Found a formatting character.
         */
        ptszFormat++;
        switch (*ptszFormat) {

        /*
         *  %s - null-terminated string
         */
        case 's':
            ptsz += PrintPtchPtchV(ptsz, TEXT("%s"), va_arg(ap, PCTSTR));
            break;

        /*
         *  %d - decimal integer
         */
        case 'd':
            ptsz += PrintPtchPtchV(ptsz, TEXT("%d"), va_arg(ap, int));
            break;

        /*
         *  %P - snapped token
         */
        case 'P':
            ptok = va_arg(ap, PTOK);
            AssertSPtok(ptok);
            Assert(fClosedPtok(ptok));
            CopyPtchPtchCtch(ptsz, ptok->u.ptch, ptok->ctch);
            ptsz += ptok->ctch;
            break;

        case '%':
            *ptsz++ = TEXT('%');
            break;

        default:
            Assert(0); break;
        }
        ptszFormat++;
    }
}

/*****************************************************************************
 *
 *  Die
 *
 *  Squirt a message and die.
 *
 *****************************************************************************/

NORETURN void CDECL
Die(PCTSTR ptszFormat, ...)
{
    TCHAR tszBuf[1024];
    va_list ap;
    CTCH ctch;

    va_start(ap, ptszFormat);
    ctch = PrintPtszPtszVa(tszBuf, ptszFormat, ap);
    va_end(ap);

    cbWriteHfPvCb(hfErr, tszBuf, cbCtch(ctch));

    exit(1);
}

#ifdef DEBUG
/*****************************************************************************
 *
 *  AssertPszPszLn
 *
 *  An assertion just failed.  pszExpr is the expression, pszFile is the
 *  filename, and iLine is the line number.
 *
 *****************************************************************************/

NORETURN int STDCALL
AssertPszPszLn(PCSTR pszExpr, PCSTR pszFile, int iLine)
{
    Die(TEXT("Assertion failed: `%s' at %s(%d)") EOL, pszExpr, pszFile, iLine);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ls\ls.c ===
/* ls - fancy schmancy dir list program
 *
 * HISTORY:
 * 17-Mar-87    danl    Added q switch
 *   4/15/86  daniel lipkie  Allow /s as well as /1 (one) to do single col
 *   4/23/86  daniel lipkie  Add /v switch
 *   5/02/86  daniel lipkie  savepath, do strlen(pat), not strlen(*pat)
 *   5/05/86  daniel lipkie  Allow - as well as / as switch char
 *
 *  31-Jul-1986 mz  Add in net aware-ness.  ls \\mach\path works now.
 *                  Discard bogus C stat() function and do times correctly.
 *  01-Aug-1986 dl  If invokes as l, then do ls /l
 *  23-Jan-1987 bw  Add 286DOS support
 *  30-Oct-1987 bw  Changed 'DOS5' to 'OS2'
 *  08-Dec-1988 mz  Chance to use OS2.H
 *
 *  03-Aug-1990 davegi  Removed 'F' from [s]printf format
 *                      descriptors (OS/2 2.0)
 *                      Changed Move to memmove
 *                      Removed redundant check for '-' switch character
 *  18-Oct-1990 w-barry Removed 'dead' code.
 */


#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <stdio.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

char *attrs = "drahsoecp";

int amsk[] = {
    FILE_ATTRIBUTE_DIRECTORY,
    FILE_ATTRIBUTE_READONLY,
    FILE_ATTRIBUTE_ARCHIVE,
    FILE_ATTRIBUTE_HIDDEN,
    FILE_ATTRIBUTE_SYSTEM,
    FILE_ATTRIBUTE_OFFLINE,
    FILE_ATTRIBUTE_ENCRYPTED,
    FILE_ATTRIBUTE_COMPRESSED,
    FILE_ATTRIBUTE_REPARSE_POINT,
    0
};
char *prattrs[] = {
    "%s*"
};

char pramsk[] = {
    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY,
    0
};

flagType fD = FALSE;                    /* TRUE => do only specified dir not sub */
flagType fSubDir = FALSE;               /* TRUE => recurse on subdirs         */
flagType fL = FALSE;                    /* TRUE => long listing               */
flagType fSingle = FALSE;               /* TRUE => single column output       */
flagType fVisOnly = FALSE;              /* TRUE => ignore FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_SYSTEM FILE_ATTRIBUTE_VOLUME_LABEL, no *  */
flagType fQuiet = FALSE;                /* TRUE => no summary                 */
flagType fFull = FALSE;                 /*  TRUE => display full names        */
flagType fUTC = FALSE;                  /*  TRUE => display using UTC         */


/*  Sort type   */
#define TYS_ALPHA   0
#define TYS_SIZE    1
#define TYS_TIME    2
int tySort = TYS_ALPHA;                 /*  type of sort                      */
flagType fReverse = FALSE;              /* TRUE => sort is reversed           */

struct fppath {
    struct fppath far *next;
    struct fppat  far *pat;
    struct fpfile far *first;
    int maxlen;
    int cntFiles;
    int cntEntries;
    long bytes;
    long bytesAlloc;
    long bPerA;
    int fToLower;
    int cchName;
    char name[1];
    };

struct fppat {
    struct fppat far *next;
    int cchName;
    char name[1];
    };

struct fpfile {
    struct fpfile far *next;
    long len;
    DWORD attr;
    time_t mtime;
    int cchName;
    char name[1];
    };

struct fppath far *toppath, far *curpath;
unsigned totalloc = 0;
char tmpfile1[MAX_PATH], tmpfile2[MAX_PATH];
char szStarDotStar[] = "*.*";

/**     Procedure prototypes
 */
char far *alloc (int nb);
long AllocSize (char *p);
void savefile (char *p, struct findType *b, void *dummy);
void savepath (char *p, char *pat);
void savepat (struct fppath far *toppath, char *pat);
struct fppath far *freepath (struct fppath far *p);
struct fppat far *freepat (struct fppat far *p);
struct fpfile far *freefile (struct fpfile far *p);
struct fpfile far *nfile (int n, struct fpfile far *p);
flagType fIsDir (char *p);

/*  alloc - allocate random memory.  Die cleanly if no more memory is
 *  available.
 *
 *  nb          number of bytes to allocate
 *
 *  returns:    pointer to bytes allocated if successful
 *              displays error message and dies otherwise
 */
char far *alloc (int nb)
{
    char far *p;

    p = (char far *) malloc (nb);
    if (p != NULL) {
        memset (p, 0, nb);
        totalloc += nb;
        return p;
        }

    printf ("alloc out of memory - used: %u  need: %d\n", totalloc, nb);
    exit (1);
    return NULL;
}

/*  AllocSize - determine size of allocation granularity
 *
 *  p           character pointer to name string
 *
 *  Returns     long number of bytes per allocation unit
 */

long AllocSize (char *p)
{
    DWORD dwSecPerClus;
    DWORD dwBytePerSec;
    DWORD dwFreeClus;
    DWORD dwTotalClus;

    if (!GetDiskFreeSpace (p, &dwSecPerClus, &dwBytePerSec, &dwFreeClus, &dwTotalClus)) {
//      fprintf (stderr, "GetDiskFreeSpace (%s) returned %d\n", p, GetLastError ());
        return 1;
        }

    return dwBytePerSec * dwSecPerClus;
}


void savefile (char *p, struct findType *b, void * dummy)
{
    int i, j;
    register struct fpfile far *tmp, far *tmp1;
    struct fpfile far *tmp2;
    char *psz;
    SYSTEMTIME DateTime;

    if (!curpath)
        return;

    if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        if (!strcmp (b->fbuf.cFileName, "..") || !strcmp (b->fbuf.cFileName, "."))
            return;

    if (fVisOnly) {
        if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | 8 ))
            return;
        RSETFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY);
        }

    if (fFull)
        psz = p;
    else
        psz = b->fbuf.cFileName;
    i = strlen (psz);
    if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        i += 2;
    tmp = (struct fpfile far *) alloc (sizeof (*tmp) + i);
    if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        sprintf (tmpfile1, "[%s]", psz);
    else
        strcpy (tmpfile1, psz);
    tmp->cchName = strlen (tmpfile1) + 1;
    memmove (tmp->name, tmpfile1, tmp->cchName);
    if (curpath->fToLower)
        lower (tmp->name);
    tmp->next = NULL;
    tmp->attr = b->fbuf.dwFileAttributes;
    tmp->len  = b->fbuf.nFileSizeLow;

    if (fL || tySort == TYS_TIME) {
        if ( fUTC ) {
            FileTimeToSystemTime( &b->fbuf.ftLastWriteTime, &DateTime );
            }
        else {
            FILETIME LocalFileTime;
            FileTimeToLocalFileTime( &b->fbuf.ftLastWriteTime, &LocalFileTime );
            FileTimeToSystemTime( &LocalFileTime, &DateTime );
            }
        tmp->mtime = (time_t)date2l( DateTime.wYear,
                                     DateTime.wMonth,
                                     DateTime.wDay,
                                     DateTime.wHour,
                                     DateTime.wMinute,
                                     DateTime.wSecond
                                   );
        }

    if (TESTFLAG (tmp->attr, pramsk[0]))
        for (j = 1; pramsk[j]; j++)
            if (TESTFLAG (tmp->attr, pramsk[j])) {
                i += strlen (prattrs[j-1]) - 3;
                break;
                }

    curpath->maxlen = max (curpath->maxlen, i);

    if (!TESTFLAG (tmp->attr, FILE_ATTRIBUTE_DIRECTORY))
        curpath->cntFiles++;

    curpath->cntEntries++;

    tmp1 = curpath->first;
    tmp2 = NULL;
    while (tmp1) {
        switch (tySort) {
        case TYS_SIZE:
            i = tmp1->len > tmp->len;
            break;
        case TYS_ALPHA:
            memmove (tmpfile1, tmp1->name, tmp1->cchName);
            memmove (tmpfile2, tmp->name, tmp->cchName);
            i = _strcmpi (tmpfile1, tmpfile2) > 0;
            break;
    case TYS_TIME:
        i = (unsigned long)tmp1->mtime < (unsigned long)tmp->mtime;
            break;
            }
        if ((i && !fReverse) || (!i && fReverse))
            break;
        tmp2 = tmp1;
        tmp1 = tmp1->next;
        }
    tmp->next = tmp1;
    if (tmp2)
        tmp2->next = tmp;
    else
        curpath->first = tmp;

    if (fSubDir && TESTFLAG (tmp->attr, FILE_ATTRIBUTE_DIRECTORY))
        savepath (p, szStarDotStar);

    dummy;
}

/*  savepat - make sure that pat is in the top-level path set */
void savepat (struct fppath far *toppath, char *pat)
{
    int i;
    struct fppat far *tmp, far *tmp1, far *tmp2;

    if (!pat)
        pat = szStarDotStar;
    i = strlen (pat);
    tmp = (struct fppat far *) alloc (sizeof (*tmp) +i);
    tmp->cchName = strlen (pat) + 1;
    memmove (tmp->name, pat, tmp->cchName);
    tmp->next = NULL;
    tmp1 = toppath->pat;
    tmp2 = NULL;
    while (tmp1) {
        memmove (tmpfile1, tmp1->name, tmp1->cchName);
        if (!_strcmpi (pat, tmpfile1)) {
            free (tmp);
            return;
            }
        else {
            tmp2 = tmp1;
            tmp1 = tmp1->next;
            }
        }
    if (tmp2)
        tmp2->next = tmp;
    else
        toppath->pat = tmp;
}

/*  savepath - add a path and matching files into the file set
 *
 *  p           directory for files
 *  pat         pattern to match
 */
void savepath (char *p, char *pat)
{
    static char  dirbuf[MAX_PATH], nambuf[14];
    int i;
    struct fppath far *tmp, far *tmp1, far *tmp2;
    char far *fp;
    DWORD dwFileSystemFlags;

    if (p)
        rootpath (p, dirbuf);
    else
    if (fPathChr (*pat) || *pat == '.' || (strlen (pat) >= 2 && pat[1] == ':')) {
        rootpath (pat, dirbuf);
        fileext (dirbuf, nambuf);
        path (dirbuf+2, dirbuf+2);
        pat = nambuf;
        }
    else
        curdir (dirbuf, 0);
    p = dirbuf + strlen (dirbuf) - 1;
    if (fPathChr (*p)) {
        if (fPathChr (*pat) || !*pat)
            *p = 0;
        }
    else
    if (*pat && !fPathChr (*pat))
        strcpy (++p, "\\");
    i = strlen (dirbuf);
    tmp = (struct fppath far *) alloc (sizeof (*tmp) + i);
    tmp->cchName = strlen (dirbuf) + 1;
    memmove (fp = tmp->name, dirbuf, tmp->cchName);
    tmp->next = NULL;
    tmp->pat = NULL;
    tmp->first = NULL;
    tmp->cntFiles = 0;
    tmp->cntEntries = 0;
    tmp->maxlen = 0;
    tmp->bytes = 0L;
    tmp->bytesAlloc = 0L;
    tmp->bPerA = AllocSize (dirbuf);


Retry:
    if (!GetVolumeInformation (dirbuf, NULL, 0, NULL, NULL,
                               &dwFileSystemFlags, NULL, 0)) {
        if (GetLastError() == ERROR_DIR_NOT_ROOT) {
           p = dirbuf + strlen (dirbuf) - 1;

           if (fPathChr(*p)) {
               *p = 0;

               p = strrchr(dirbuf, '\\');

               if (p) {
                   p[1] = 0;
                   goto Retry;
               }
           }
        }

        dwFileSystemFlags = 0;
        }
    tmp->fToLower = dwFileSystemFlags != 0 ? FALSE : TRUE;

    while (*fp)
        if (fPathChr (*fp++)) {
            fp[-1] = '\\';
            }
    tmp1 = toppath;
    tmp2 = NULL;
    while (tmp1) {
        memmove (tmpfile1, tmp1->name, tmp1->cchName);
        memmove ( tmpfile2, tmp->name, tmp->cchName);
        switch (_strcmpi (tmpfile1, tmpfile2)) {
        case 0:
            free (tmp);
            tmp = NULL;
            break;
        case 1:
            break;
        default:
            tmp2 = tmp1;
            tmp1 = tmp1->next;
            continue;
            }
        break;
        }
    if (tmp) {
        tmp->next = tmp1;
        if (tmp2)
            tmp2->next = tmp;
        else
            toppath = tmp;
        }
    else
        tmp = tmp1;
    savepat (tmp, pat);
    sprintf (dirbuf, "%s%s", tmp->name, pat);
    tmp2 = curpath;
    curpath = tmp;
    forfile(dirbuf, -1, savefile, NULL);
    curpath = tmp2;
}

struct fppath far *freepath (struct fppath far *p)
{
    struct fppath far *p1;

    p1 = p->next;
    free (p);
    return p1;
}

struct fppat far *freepat (struct fppat far *p)
{
    struct fppat far *p1;

    p1 = p->next;
    free (p);
    return p1;
}

struct fpfile far *freefile (struct fpfile far *p)
{
    struct fpfile far *p1;

    p1 = p->next;
    free (p);
    return p1;
}

struct fpfile far *nfile (int n, struct fpfile far *p)
{
    while (n--)
        if ((p = p->next) == NULL)
            break;
    return p;
}


flagType fIsDir (char *p)
{
    int a = GetFileAttributes( p );

    if (a != -1)
        return (flagType) TESTFLAG (a, FILE_ATTRIBUTE_DIRECTORY);
    return FALSE;
}

int __cdecl main (int c, char *v[])
{
    int i, j, k, rows, cols, len;
    flagType fGrand;
    char buf[MAX_PATH], buf2[MAX_PATH], tbuf[MAX_PATH];
    struct fppat  far *pat;
    struct fpfile far *file;
    char *p;
    long totbytes, totalloc, t;
    time_t mtime;
    unsigned totfiles;

    /* Make a call to set the video buffering to null */
    //setvbuf( stdout, NULL, _IONBF, 0 );

    ConvertAppToOem( c, v );
    filename (*v, buf);   /* remove path part, if any */
    if (!strcmpis (buf, "l"))
        fL = TRUE;
    SHIFT (c, v);
    while (c != 0 && fSwitChr (* (p = *v))) {
        while (*++p)
            switch (*p) {
            case 'F':
                fFull = TRUE;
                break;
            case 'u':
                fUTC = TRUE;
                break;
            case 'r':
                fReverse = TRUE;
                break;
            case 'q':
                fQuiet = TRUE;
                break;
            case 'R':
                fSubDir = TRUE;
                break;
            case 'd':
                fD = TRUE;
                break;
            case 'l':
                fL = TRUE;
                break;
            case 't':
                tySort = TYS_TIME;
                break;
            case '1':
            case 's':
                fSingle = TRUE;
                break;
            case 'S':
                tySort = TYS_SIZE;
                break;
            case 'v':
                fVisOnly = TRUE;
                break;
            default:
                printf ("Usage: LS [/FrqRdlt1sSvu] [files]\n");
                exit (1);
            }
        SHIFT (c, v);
        }

    if (c == 0) {
        c++; v--;
        *v = szStarDotStar;
        }
    curpath = toppath = NULL;
    while (c) {
        pname (*v);
        p = *v + strlen (*v) - 1;
        if (fPathChr (*p))
            savepath (*v, szStarDotStar);
        else
        if (*p == ':') {
            if (strlen (*v) != 2)
                break;
            savepath (*v, szStarDotStar);
            }
        else
        if (fIsDir (*v))
            savepath (*v, fD ? "" : szStarDotStar);
        else
            savepath (NULL, *v);
        SHIFT (c, v);
        }
    curpath = toppath;
    totbytes = 0L;
    totalloc = 0L;
    totfiles = 0;
    fGrand = FALSE;
    while (curpath) {
        len = curpath->maxlen;

        /*  only do the space padding if we are going to print
         *  more than one file per line
         */

        cols = len+2;
        if (fL)
            cols += 17 + 1 + STAMPLEN;
        cols = min (cols, 78);

        /*  (cols) = columns of text per item
         *  (len) = length of name field
         *
         *  convert from columns of text to columns per screen
         */
        cols = 79 / (cols + 1);
        if (fSingle || cols == 1) {
            strcpy (buf, "%s");
            cols = 1;
            }
        else
            sprintf (buf, "%%-%ds ", len+1);

        rows = (curpath->cntEntries + cols - 1) / cols;    /* number of rows */

        if (curpath != toppath) {
            fGrand = TRUE;
            putchar ('\n');
            }
        if (!fQuiet) {
            pat = curpath->pat;
            printf ("    %s%s", curpath->name, pat->name);
            while (pat = freepat (pat))
                printf (" %s", pat->name);
            putchar('\n');
        }
        if (!curpath->first)
            printf ("no files\n");
        else {
            for (i = 0; i < rows; i++) {
                for (j = 0; j < cols; j++) {
                    if ((file = nfile (i+j*rows, curpath->first)) == NULL)
                        break;
                    if (fL) {
                        char *pTime;
                        for (k=0; amsk[k]; k++)
                            if (TESTFLAG (file->attr, amsk[k]))
                                putchar(attrs[k]);
                            else
                                putchar('-');
                        mtime = file->mtime;
                        pTime = ctime(&mtime);
                        if ( pTime ) {
                            strcpy(tbuf, ctime (&mtime));
                        } else {
                            strcpy(tbuf, "??? ??? ?? ??:??:?? ????\n");
                        }
                        tbuf[strlen (tbuf) -1] = '\0';
                        printf (" %9ld %s ", file->len, tbuf);
                        }


                    if (TESTFLAG (file->attr, pramsk[0])) {
                        sprintf(buf2, "%s*", file->name);
                    } else  {
                        sprintf(buf2, "%s", file->name);
                    }
                    curpath->bytes += file->len;
                    t = file->len + curpath->bPerA - 1;
                    t = t / curpath->bPerA;
                    t = t * curpath->bPerA;
                    curpath->bytesAlloc += t;
                    printf (buf, buf2);
                    }
                putchar('\n');
                }
            }
        if (!fQuiet && curpath->cntFiles) {
            printf ("    %ld (%ld) bytes in %d files\n", curpath->bytesAlloc,
                    curpath->bytes, curpath->cntFiles);
            totbytes += curpath->bytes;
            totalloc += curpath->bytesAlloc;
            totfiles += curpath->cntFiles;
            }
        curpath = freepath (curpath);
        }
    if (!fQuiet && fGrand)
        printf ("\nTotal of %ld (%ld) bytes in %d files\n", totalloc, totbytes, totfiles);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\at.c ===
/*****************************************************************************
 *
 * at.c
 *
 *  Arithmetic types.
 *
 *****************************************************************************/

#include "m4.h"

F STDCALL fWhiteTch(TCH tch);

/*****************************************************************************
 *
 *  AddExpAt
 *
 *  Add the (unsigned) arithmetic value to the Exp hold.
 *
 *  Since the value is never very large, we may as well be recursive.
 *
 *****************************************************************************/

void STDCALL
AddExpAt(AT at)
{
    if (at > 9) {
        AddExpAt(at / 10);
    }
    AddExpTch((TCH)(TEXT('0') + at % 10));
}

/*****************************************************************************
 *
 *  PushAtRadixCtch
 *
 *  Push onto the input stream the specified arithmetic value, in the
 *  requested radix, padded with zeros to the requested width.
 *
 *  The type is always considered signed.
 *
 *  If a negative value needs to be padded, the zeros are inserted after
 *  the leading minus sign.
 *
 *      QUIRK!  Under AT&T, the leading minus sign does *not* contribute
 *      to the count!  I emulate this quirk...
 *
 *      FEATURE!  If the radix is invalid, force it to 10.  AT&T doesn't
 *      check the radix, but I will.
 *
 *      QUIRK!  Under AT&T, a negative width is treated as zero.
 *      I emulate this quirk...
 *
 *  INTERESTING HACK!  Since characters are pushed LIFO, we can generate
 *  the entire output string without needing to use a hold or anything
 *  else gross like that.
 *
 *****************************************************************************/

void STDCALL
PushAtRadixCtch(AT atConvert, unsigned radix, CTCH ctch)
{
    AT at;

    if ((int)ctch < 0) {
#ifdef WARN_COMPAT
        Warn("Negative eval width %d silently converted to zero");
#endif
        ctch = 0;
    }

    if (radix < 2 || radix > 36) {
#ifdef WARN_COMPAT
        Warn("Invalid radix %d silently converted to 10");
#endif
        radix = 10;
    }

    at = atConvert < 0 ? -atConvert : atConvert;

    do {
        TCH tch = (TCH)((unsigned long)at % radix);
        at = (unsigned long)at / radix;
        if (tch < 10) {
            PushTch((TCH)(tch + '0'));
        } else {
            PushTch((TCH)(tch + 'A' - 10));
        }
        ctch--;
    } while (at);
    while ((int)ctch > 0) {
        PushTch('0');
        --ctch;
    }
    if (atConvert < 0) {
        PushTch('-');
    }
}

/*****************************************************************************
 *
 *  PushAt
 *
 *  Common case where we want to display the value in base 10
 *  with no padding.
 *
 *****************************************************************************/

void STDCALL
PushAt(AT at)
{
    PushAtRadixCtch(at, 10, 0);
}

/*****************************************************************************
 *
 *  SkipWhitePtok
 *
 *  Skip leading whitespace in a token, *MODIFYING* the token in place.
 *
 *****************************************************************************/

void STDCALL
SkipWhitePtok(PTOK ptok)
{
    AssertSPtok(ptok);
    Assert(fScratchPtok(ptok));
    while (!fNullPtok(ptok) && fWhiteTch(*ptchPtok(ptok))) {
        EatHeadPtokCtch(ptok, 1);
    }
}

/*****************************************************************************
 *
 *  atRadixPtok
 *
 *  Parse a number out of a token, given the radix.  Leading whitespace
 *  must already have been streipped.
 *
 *  The token is *MODIFIED* to point to the first unconsumed character.
 *  If no valid digits are found, then zero is returned and the token
 *  is unchanged.
 *
 *****************************************************************************/

AT STDCALL
atRadixPtok(unsigned radix, PTOK ptok)
{
    AT at = 0;
    while (!fNullPtok(ptok)) {
        AT atDigit = (TBYTE)*ptchPtok(ptok) - '0';
        if ((unsigned)atDigit > 9) {
            atDigit = ((TBYTE)*ptchPtok(ptok) | 0x20) - 'a';
            if ((unsigned)atDigit > 5) {
                break;
            }
            atDigit += 10;
        }
        if ((unsigned)atDigit > radix) {
            break;
        }
        at = at * radix + atDigit;

        EatHeadPtokCtch(ptok, 1);
    }
    return at;
}

/*****************************************************************************
 *
 *  fEvalPtokPat
 *
 *      Parse a number out of a token.  Leading whitespace must already have
 *      been stripped.  A leading minus sign is not permitted.  (`eval'
 *      would have already parsed it out as a unary operator.)  A leading
 *      zero forces the value to be parsed as octal; a leading `0x' as hex.
 *
 *      The token is *MODIFIED* to point to the first unconsumed character.
 *      If no valid number is found, then zero is returned.  Otherwise,
 *      nonzero is returned and pat is filled with the parsed value.
 *
 *****************************************************************************/

F STDCALL
fEvalPtokPat(PTOK ptok, PAT pat)
{
    AT at;
    AssertSPtok(ptok);
    Assert(fScratchPtok(ptok));

    if (!fNullPtok(ptok)) {
        PTCH ptchStart;
        unsigned radix;

        /*
         *  Get the radix...
         */
        if (*ptchPtok(ptok) == '0') {
            if (ctchSPtok(ptok) > 2 &&
                (ptchPtok(ptok)[1] | 0x20) == 'x') {
                EatHeadPtokCtch(ptok, 2);
                radix = 16;
            } else {
                radix = 8;
            }
        } else {
            radix = 10;
        }

        ptchStart = ptchPtok(ptok);     /* Remember the start */
        at = atRadixPtok(radix, ptok);
        if (ptchStart == ptchPtok(ptok)) {
            if (radix == 16) {
                EatHeadPtokCtch(ptok, (CTCH)-2); /* Restore the `0x' */
            }
            return 0;
        } else {
            *pat = at;
            return 1;
        }
    }
    return 0;                           /* No number found */
}

/*****************************************************************************
 *
 *  atTraditionalPtok
 *
 *  Parse a number out of a token.  Leading whitespace is ignored.
 *  A leading minus sign is permitted.  Octal and hex notation is
 *  not permitted.  No space is permitted between the optional
 *  minus sign and the digit string.  An invalid input is parsed as zero.
 *
 *****************************************************************************/

AT STDCALL PURE
atTraditionalPtok(PCTOK ptok)
{
    TOK tok;

    AssertSPtok(ptok);
    DupStaticPtokPtok(&tok, ptok);
  D(tok.tsfl |= tsflScratch);

    SkipWhitePtok(&tok);
    if (!fNullPtok(&tok)) {
        AT at;
        BOOL fSign;
        if (*ptchPtok(&tok) == '-') {
            fSign = 1;
            EatHeadPtokCtch(&tok, 1);
        } else {
            fSign = 0;
        }
        at = atRadixPtok(10, &tok);
        if (fSign) {
            at = -at;
        }
        return at;
    } else {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\define.c ===
/*****************************************************************************
 *
 * define.c
 *
 *  Builtins related to object definitions.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  opDefineOrPushdef
 *
 *      Common worker for opDefine and opPushdef.
 *
 *      If we are not pushing, then we must pop off the previous value
 *      in order to free its memory, before pushing the new definition.
 *
 *      QUIRK!  GNU m4 emits a warning if $# > 2.  AT&T silently ignores
 *      extra arguments.  I side with AT&T on this one.
 *
 *      QUIRK!  GNU m4 emits `$0' if $# = 0.  AT&T silently ignores
 *      the entire macro call.  I side with GNU on this one.
 *
 *      WARNING!  main.c::DefinePtsz assumes that we don't look at
 *      argv[0] if the correct number of parameters are passed!
 *
 *****************************************************************************/

void STDCALL
opDefineOrPushdef(ARGV argv, BOOL fPush)
{
    if (ctokArgv > 0) {
        /*
         *  Ensure that we don't mess with argv[0].
         */
      D(SIG sigOld = argv[0].sig);
      D(argv[0].sig = 0);
        if (fIdentPtok(ptokArgv(1))) {
            PMAC pmac = pmacGetPtok(ptokArgv(1));
            if (!fPush) {
                if (pmac->pval) {
                    PopdefPmac(pmac);   /* Pop off previous value */
                }
            }
            PushdefPmacPtok(pmac, ptokArgv(2));
#ifdef STRICT_M4
            if (ctokArgv > 2) {
                Warn("extra arguments ignored");
            }
#endif
        } else {
            Die("invalid macro name");
        }
      D(argv[0].sig = sigOld);
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opDefine
 *
 *      Set the expansion of $1 to $2, destroying any previous value.
 *
 *  opPushdef
 *
 *      Same as opDefine, except pushes the previous value.
 *
 *****************************************************************************/

DeclareOp(opDefine)
{
    opDefineOrPushdef(argv, 0);
}

DeclareOp(opPushdef)
{
    opDefineOrPushdef(argv, 1);
}

/*****************************************************************************
 *
 *  opPopdef
 *
 *      Restores the most recently pushed definition.
 *
 *      If the macro name is invalid, fail silently.
 *
 *****************************************************************************/

DeclareOpc(opcPopdef)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        Assert(pmac->pval);
        if (pmac->pval->pvalPrev) {
            PopdefPmac(pmac);
        } else {
            FreePmac(pmac);
        }
    }
}

DeclareOp(opPopdef)
{
    EachOpcArgvDw(opcPopdef, argv, 0);
}

/*****************************************************************************
 *
 *  opUndefine
 *
 *      Removes the definitions of all its arguments.
 *
 *****************************************************************************/

DeclareOpc(opcUndefine)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        FreePmac(pmac);
    }
}

DeclareOp(opUndefine)
{
    EachOpcArgvDw(opcUndefine, argv, 0);
}


/*****************************************************************************
 *
 *  opDefn
 *
 *      Returns the quoted definition of its argument(s), concatenated
 *      from left to right.
 *
 *****************************************************************************/

DeclareOpc(opcDefn)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        PushQuotedPtok(&pmac->pval->tok);
    }
}

DeclareOp(opDefn)
{
    EachReverseOpcArgvDw(opcDefn, argv, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\builtin.c ===
/*****************************************************************************
 *
 * builtin.c
 *
 *  Builtin macros.
 *
 *****************************************************************************/

#include "m4.h"

extern TOK tokColonTab;
extern TOK tokEol;

/*****************************************************************************
 *
 *  opIfdef
 *
 *      If $1 is defined, then return $2, else $3.
 *
 *      If $# < 2, then there's no point in returning anything at all.
 *
 *      The extra ptokNil covers us in the case where $# is 2.
 *
 *      QUIRK!  GNU m4 emits a warning if $# < 2.  AT&T remains silent.
 *      I side with AT&T on this one.
 *
 *      QUIRK!  GNU m4 emits `$0' if $# = 0.  AT&T silently ignores
 *      the entire macro call.  I side with GNU on this one.
 *
 *****************************************************************************/

DeclareOp(opIfdef)
{
    if (ctokArgv >= 2) {
        if (pmacFindPtok(ptokArgv(1))) {
            PushPtok(ptokArgv(2));
        } else {
            PushPtok(ptokArgv(3));
        }
    } else if (ctokArgv == 0) {
        PushQuotedPtok(ptokArgv(0));
    } else {
#ifdef STRICT_M4
        Warn("wrong number of arguments to %P", ptokArgv(0));
#endif
    }
}

/*****************************************************************************
 *
 *  opIfelse
 *
 *      If $1 and $2 are identical, then return $3.
 *      If there are only four arguments, then return $4.
 *      Else, shift three and restart.
 *
 *      If there are fewer than three arguments, then return nothing.
 *
 *      The extra ptokNil saves us in the cases where $# = 2 + 3n.
 *
 *      QUIRK!  GNU m4 emits a warning if $# = 2 + 3n.  AT&T remains silent.
 *      I side with AT&T on this one.
 *
 *****************************************************************************/

DeclareOp(opIfelse)
{
    if (ctokArgv >= 3) {                /* Need at least three for starters */
        ITOK itok = 1;
        do {
            if (fEqPtokPtok(ptokArgv(itok), ptokArgv(itok+1))) {
                PushPtok(ptokArgv(itok+2)); /* ptokNil saves us here */
                return;
            }
            itok += 3;
        } while (itok <= ctokArgv - 1); /* While at least two args left */
        if (itok == ctokArgv) {         /* If only one left... */
            PushPtok(ptokArgv(itok));
        } else {
            Assert(itok == ctokArgv + 1); /* Else must be zero left */
        }
        return;
    }
}

/*****************************************************************************
 *
 *  opShift
 *
 *      Return all but the first argument, quoted and pushed back with
 *      commas in between.  We push them in reverse order so that they
 *      show up properly.
 *
 *****************************************************************************/

DeclareOpc(opcShift)
{
    if (itok > 1) {
        PushQuotedPtok(ptok);
        if (itok > 2) {
            PushTch(tchComma);
        }
    }
}

DeclareOp(opShift)
{
    EachReverseOpcArgvDw(opcShift, argv, 0);
}

/*****************************************************************************
 *
 *  opLen
 *
 *  Returns the length of its argument.
 *  The extra ptokNil covers us in the case where $# is zero.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $# is zero, but
 *  GNU m4 will emit `$0' so as to reduce potential conflict with an
 *  identically-spelled language keyword.  I side with GNU on this one.
 *
 *  SOMEDAY! -- this quirk should be an op attribute.
 *
 *
 *****************************************************************************/

DeclareOp(opLen)
{
    if (ctokArgv) {
#ifdef STRICT_M4
        if (ctokArgv != 1) {
            Warn("wrong number of arguments to %P", ptokArgv(0));
        }
#endif
        PushAt(ctchArgv(1));
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opTraceon
 *
 *  With no arguments, turns on global tracing.
 *  Otherwise, turns on local tracing on the specified macros.
 *
 *  opTraceoff
 *
 *  Turns off global tracing, and also turns off local tracing on the
 *  specified macros (if any).
 *
 *****************************************************************************/

DeclareOpc(opcTraceonoff)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        pmac->pval->fTrace = dw;
    }
}

DeclareOp(opTraceon)
{
    if (ctokArgv == 0) {
        g_fTrace = 1;
    } else {
        EachOpcArgvDw(opcTraceonoff, argv, 1);
    }
}

DeclareOp(opTraceoff)
{
    g_fTrace = 0;
    EachOpcArgvDw(opcTraceonoff, argv, 0);
}


/*****************************************************************************
 *
 *  opDnl
 *
 *  Gobbles all characters up to and including the next newline.
 *
 *  If EOF is reached, push the EOF back and stop.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $# > 0.  GNU m4
 *  issues a warning.  I side with AT&T on this one.
 *
 *****************************************************************************/

DeclareOp(opDnl)
{
    TCH tch;
#ifdef STRICT_M4
    if (ctokArgv != 0) {
        Warn("wrong number of arguments to %P", ptokArgv(0));
    }
#endif
    while ((tch = tchGet()) != '\n') {
        if (tch == tchMagic) {
            TCH tch = tchGet();
            if (tch == tchEof) {
                PushPtok(&tokEof);      /* Eek!  Does this actually work? */
                break;
            }
        }
    }
}

/*****************************************************************************
 *
 *  opChangequote - not implemented
 *  opChangecom - not implemented
 *  opUndivert - not implemented
 *  opSyscmd - not implemented
 *  opSysval - not implemented
 *  opMaketemp - not implemented
 *  opM4exit - not implemented
 *  opM4wrap - not implemented
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  opDivert
 *
 *  We currently support only two diversions:
 *
 *   0      = stdout
 *   1-9    = unsupported
 *  <anything else> = /dev/null
 *
 *  This is just barely enough to get DirectX building.
 *
 *****************************************************************************/

DeclareOp(opDivert)
{
#ifdef STRICT_M4
    if (ctokArgv != 1) {
        Warn("wrong number of arguments to divert");
    }
#endif

    if (ctokArgv > 0) {
        PTOK ptok = ptokArgv(1);
        if (ptok->ctch == 1 && ptok->u.ptch[0] == TEXT('0')) {
            g_pdivCur = g_pdivOut;
        } else {
            g_pdivCur = g_pdivNul;
        }
    }
}

/*****************************************************************************
 *
 *  opDivnum
 *
 *  We currently support only two diversions:
 *
 *   0      = stdout
 *   1-9    = unsupported
 *  <anything else> = /dev/null
 *
 *  This is just barely enough to get DirectX building.
 *
 *****************************************************************************/

DeclareOp(opDivnum)
{
#ifdef STRICT_M4
    if (ctokArgv != 0) {
        Warn("wrong number of arguments to %P", ptokArgv(0));
    }
#endif
    PushAt(g_pdivCur == g_pdivOut ? 0 : -1);
}

/*****************************************************************************
 *
 *  opErrprint
 *
 *  Prints its argument on the dianostic output file.
 *  The extra ptokNil covers us in the case where $# is zero.
 *
 *  QUIRK!  AT&T m4 silently ignores excess arguments.  GNU m4 emits
 *  all arguments, separated by spaces.  I side with AT&T on this one.
 *
 *****************************************************************************/

DeclareOp(opErrprint)
{
#ifdef STRICT_M4
    if (ctokArgv != 1) {
        Warn("wrong number of arguments to errprint");
    }
#endif
    AddPdivPtok(g_pdivErr, ptokArgv(1));
    FlushPdiv(g_pdivErr);
}

/*****************************************************************************
 *
 *  opDumpdef
 *
 *  With no arguments, dumps all definitions.
 *  Otherwise, dumps only the specified macros.
 *
 *  QUIRK!  When given multiple arguments, AT&T m4 dumps the macros in
 *  the order listed.  GNU m4 dumps them in reverse order.  (!)
 *  I side with AT&T on this one.
 *
 *****************************************************************************/

void STDCALL
DumpdefPmac(PMAC pmac)
{
    PTCH ptch, ptchMax;

    AddPdivPtok(g_pdivErr, &pmac->tokName);
    AddPdivPtok(g_pdivErr, &tokColonTab);

    ptch = ptchPtok(&pmac->pval->tok);
    ptchMax = ptchMaxPtok(&pmac->pval->tok);
    for ( ; ptch < ptchMax; ptch++) {
        AddPdivTch(g_pdivErr, *ptch);   /* SOMEDAY -- internals! - do they show up okay? */
    }
    AddPdivPtok(g_pdivErr, &tokEol);
}

DeclareOpc(opcDumpdef)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        DumpdefPmac(pmac);
    }
}

DeclareOp(opDumpdef)
{
    if (ctokArgv == 0) {
        EachMacroOp(DumpdefPmac);
    } else {
        EachOpcArgvDw(opcDumpdef, argv, 0);
    }
    FlushPdiv(g_pdivErr);
}

/*****************************************************************************
 *
 *  opInclude
 *  opSinclude
 *
 *  Pushes the contents of the file named in the argument.
 *  Sinclude says nothing if the file is inaccessible.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $1 is null, but
 *  GNU m4 issues an error (no such file or directory).  I side with
 *  GNU on this one.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $# is zero, but
 *  GNU m4 will emit `$0' so as to reduce potential conflict with an
 *  identically-spelled language keyword.  I side with GNU on this one.
 *
 *  QUIRK!  AT&T m4 silently ignores arguments $2 onward.  GNU emits
 *  a warning but continues.  I side with AT&T on this one.
 *
 *****************************************************************************/

void STDCALL
opIncludeF(ARGV argv, BOOL fFatal)
{
    if (ctokArgv) {
        PTCH ptch = ptchDupPtok(ptokArgv(1));
        if (ptch) {
            if (hfInputPtchF(ptch, fFatal) == hfNil) {
                FreePv(ptch);
            }
#ifdef STRICT_M4
            if (ctokArgv != 1) {
                Warn("excess arguments to built-in %P ignored", ptokArgv(0));
            }
#endif
        }
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

DeclareOp(opInclude)
{
    opIncludeF(argv, 1);
}

DeclareOp(opSinclude)
{
    opIncludeF(argv, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\divert.c ===
/*****************************************************************************
 *
 * divert.c
 *
 *  Diversions.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  fFlushPdiv
 *
 *      Flush a file diversion.
 *
 *****************************************************************************/

TCH ptszTmpDir[MAX_PATH];

void STDCALL
FlushPdiv(PDIV pdiv)
{
    AssertPdiv(pdiv);
    Assert(fFilePdiv(pdiv));

    if (pdiv->hf == hfNil) {
        pdiv->ptchName = ptchAllocCtch(MAX_PATH);
        if (GetTempFileName(ptszTmpDir, TEXT("m4-"), 0, pdiv->ptchName)) {
            pdiv->hf = hfCreatPtch(pdiv->ptchName);
            if (pdiv->hf == hfNil) {
                Die("cannot create temp file");
            }
        } else {
            Die("cannot create temp file");
        }
    }
    WriteHfPtchCtch(pdiv->hf, pdiv->ptchMin, ctchPdiv(pdiv));
    pdiv->ptchCur = pdiv->ptchMin;
}

#if 0
cbCtch(pdiv->ptchMax - pdiv->ptchMin));
    if (cb == cbErr || cb != cbCtch(pdiv->ptchMax - pdiv->ptchMin)) {
        Die("error writing file");
    }
#endif

/*****************************************************************************
 *
 *  UnbufferPdiv
 *
 *      Make a diversion unbuffered.  This is done to stdout when input
 *      is coming from an interactive device.
 *
 *****************************************************************************/

void STDCALL
UnbufferPdiv(PDIV pdiv)
{
    AssertPdiv(pdiv);
    Assert(fFilePdiv(pdiv));

    FreePv(pdiv->ptchMin);
    pdiv->ptchMin = 0;
    pdiv->ptchCur = 0;
    pdiv->ptchMax = 0;
}

/*****************************************************************************
 *
 *  GrowPdivCtch
 *
 *      Extend a hold to have at least ctch free characters.
 *
 *****************************************************************************/

void STDCALL
GrowPdivCtch(PDIV pdiv, CTCH ctch)
{
    PTCH ptch;

    AssertPdiv(pdiv);
    Assert(pdiv->ptchCur >= pdiv->ptchMin);
    Assert(pdiv->ptchCur <= pdiv->ptchMax);

    ctch = (CTCH)ROUNDUP(((UINT_PTR)(pdiv->ptchMax - pdiv->ptchMin)) + ctch, ctchGrow);
    ptch = ptchReallocPtchCtch(pdiv->ptchMin, ctch);

    pdiv->ptchCur = (pdiv->ptchCur - pdiv->ptchMin) + ptch;
    pdiv->ptchMax = ptch + ctch;
    pdiv->ptchMin = ptch;
}

/*****************************************************************************
 *
 *  RoomifyPdivCtch
 *
 *      Try to make room in a diversion for ctch characters, either by
 *      extending it or by flushing it.
 *
 *      File diversions are flushed to make room, but if that proves
 *      not enough, we return even though the required amount of space
 *      is not available.  It is the caller's duty to check for this
 *      case and recover accordingly.
 *
 *      Memory diversions are reallocated.
 *
 *****************************************************************************/

void STDCALL
RoomifyPdivCtch(PDIV pdiv, CTCH ctch)
{
    AssertPdiv(pdiv);
    if (fFilePdiv(pdiv)) {
        FlushPdiv(pdiv);
    } else {
        GrowPdivCtch(pdiv, ctch);
    }
}

/*****************************************************************************
 *
 *  pdivAlloc
 *
 *****************************************************************************/

PDIV STDCALL
pdivAlloc(void)
{
    PDIV pdiv = pvAllocCb(sizeof(DIV));
    pdiv->ptchMin = ptchAllocCtch(ctchGrow);
    pdiv->ptchCur = pdiv->ptchMin;
    pdiv->ptchMax = pdiv->ptchMin + ctchGrow;
    pdiv->ptchName = 0;
    pdiv->hf = hfNil;
  D(pdiv->cSnap = 0);
  D(pdiv->sig = sigDiv);
    return pdiv;
}

/*****************************************************************************
 *
 *  OpenPdivPtok
 *
 *      Prepare to load a new token into the diversion.  The ptok is
 *      partially initialized to record the point at which it began.
 *
 *      The diversion must be unsnapped and must be a memory diversion.
 *      (Data in file diversion buffers can go away when the diversion
 *      is flushed.)
 *
 *****************************************************************************/

void STDCALL
OpenPdivPtok(PDIV pdiv, PTOK ptok)
{
#ifdef  DEBUG
    AssertPdiv(pdiv);
    Assert(!pdiv->cSnap);
    Assert(!fFilePdiv(pdiv));
  D(ptok->sig = sigUPtok);
    ptok->tsfl = 0;
    ptok->ctch = (CTCH)-1;              /* Keep people honest */
#endif
    SetPtokItch(ptok, ctchPdiv(pdiv));
}

/*****************************************************************************
 *
 *  AddPdivPtok
 *  AddPdivTch
 *
 *      Append a (snapped) token or character to the diversion.
 *
 *      Note that in the file diversion case, we need to watch out
 *      for tokens which are larger than our diversion buffer.
 *
 *****************************************************************************/

void STDCALL
AddPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertSPtok(ptok);
    if (ctchSPtok(ptok) > ctchAvailPdiv(pdiv)) {
        RoomifyPdivCtch(pdiv, ctchSPtok(ptok));
        if (ctchSPtok(ptok) > ctchAvailPdiv(pdiv)) {
            Assert(fFilePdiv(pdiv));
            WriteHfPtchCtch(pdiv->hf, ptchPtok(ptok), ctchSPtok(ptok));
            return;
        }
    }
    CopyPtchPtchCtch(pdiv->ptchCur, ptchPtok(ptok), ctchSPtok(ptok));
    pdiv->ptchCur += ctchSPtok(ptok);
    Assert(pdiv->ptchCur <= pdiv->ptchMax);
}

void STDCALL
AddPdivTch(PDIV pdiv, TCHAR tch)
{
    AssertPdiv(pdiv);
    if (pdiv->ptchCur >= pdiv->ptchMax) {
        RoomifyPdivCtch(pdiv, 1);
    }
    *pdiv->ptchCur++ = tch;
    Assert(pdiv->ptchCur <= pdiv->ptchMax);
}

/*****************************************************************************
 *
 *  ClosePdivPtok
 *
 *      Conclude the collection of a token in a diversion.  The token
 *      that is returned is not snapped.
 *
 *****************************************************************************/

void STDCALL
ClosePdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertUPtok(ptok);
    Assert(!fClosedPtok(ptok));
    SetPtokCtch(ptok, ctchPdiv(pdiv) - itchPtok(ptok));
}

/*****************************************************************************
 *
 *  PopPdivPtok
 *
 *      Pop a snapped token off a memory diversion.  Anything snapped after
 *      the token is also popped away.
 *
 *      Note that if the token has been modified, this will not necessarily
 *      pop off everything.
 *
 *****************************************************************************/

void STDCALL
PopPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertSPtok(ptok);
    Assert(!fHeapPtok(ptok));
    Assert(ptchPtok(ptok) >= pdiv->ptchMin);
    Assert(ptchPtok(ptok) <= pdiv->ptchCur);
    pdiv->ptchCur = ptchPtok(ptok);
  D(pdiv->cSnap = 0);
}

/*****************************************************************************
 *
 *  ptchPdivPtok
 *
 *      Return a pointer to the first character of a diversion-relative
 *      unsnapped token.
 *
 *****************************************************************************/

PTCH STDCALL
ptchPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertUPtok(ptok);
    return pdiv->ptchMin + itchPtok(ptok);
}

/*****************************************************************************
 *
 *  SnapPdivPtok
 *
 *      Convert an unsnapped hold-relative token to a snapped token.
 *
 *****************************************************************************/

void STDCALL
SnapPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertUPtok(ptok);
    SetPtokPtch(ptok, ptchPdivPtok(pdiv, ptok));
  D(pdiv->cSnap++);
}

/*****************************************************************************
 *
 *  UnsnapPdivPtok
 *
 *      Convert a snapped token back to an unsnapped hold-relative token.
 *
 *****************************************************************************/

void STDCALL
UnsnapPdivPtok(PDIV pdiv, PTOK ptok)
{
    ITCH itch;
    AssertPdiv(pdiv);
    AssertSPtok(ptok);
    itch = (ITCH)(ptchPtok(ptok) - pdiv->ptchMin);
  D(ptok->sig = sigUPtok);
    SetPtokItch(ptok, itch);
  D(pdiv->cSnap--);
}

/*****************************************************************************
 *
 *  CsopPdivDopPdivPtok
 *
 *  A common idiom is
 *
 *  CloseXxxPtok(ptok);
 *  SnapXxxPtok(&tok);
 *  Op(Yyy, &tok);
 *  PopXxxPtok(&tok);
 *
 *  so the Csop (csop = close, snap, op, pop) function does it all for you.
 *
 *****************************************************************************/

void STDCALL
CsopPdivDopPdivPtok(PDIV pdivSrc, DIVOP op, PDIV pdivDst, PTOK ptok)
{
    AssertPdiv(pdivSrc);
    AssertUPtok(ptok);
    ClosePdivPtok(pdivSrc, ptok);
    SnapPdivPtok(pdivSrc, ptok);
    op(pdivDst, ptok);
    PopPdivPtok(pdivSrc, ptok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\gc.c ===
/*****************************************************************************
 *
 * gc.c
 *
 *  The garbage-collector.
 *
 *****************************************************************************/

#include "m4.h"

#ifndef Gc

/*****************************************************************************
 *
 *  WalkPv
 *
 *  Mark an arbitrary object.
 *
 *****************************************************************************/

void STDCALL
WalkPv(PVOID pv)
{
    if (pv) {
        PAR par = parPv(pv);
        Assert(par->tm == g_tmNow - 1);
        par->tm = g_tmNow;
        AssertPar(par);                 /* This catches double-references */
    }
}

/*****************************************************************************
 *
 *  WalkPtok
 *
 *  Walk a token.  The token itself is not walked, but its contents are.
 *  (Because tokens are typically embedded inside other objects.)
 *
 *****************************************************************************/

void STDCALL
WalkPtok(PTOK ptok)
{
    if (ptok) {
        if (!fStaticPtok(ptok)) {
            Assert(fHeapPtok(ptok));
            WalkPv(ptchPtok(ptok));
        }
    }
}

/*****************************************************************************
 *
 *  WalkPval
 *
 *  Walk a value.
 *
 *****************************************************************************/

void STDCALL
WalkPval(PVAL pval)
{
    if (pval) {
        WalkPv(pval);
        WalkPtok(&pval->tok);
    }
}

/*****************************************************************************
 *
 *  WalkPmac
 *
 *  Walk a macro.
 *
 *****************************************************************************/

void STDCALL
WalkPmac(PMAC pmac)
{
    if (pmac) {
        PVAL pval;
        WalkPv(pmac);
        WalkPtok(&pmac->tokName);
        for (pval = pmac->pval; pval; pval = pval->pvalPrev) {
            WalkPval(pval);
        }
    }
}

/*****************************************************************************
 *
 *  WalkPstm
 *
 *  Walk a stream.
 *
 *  The compiler knows how to optimize tail recursion.
 *
 *****************************************************************************/

void STDCALL
WalkPstm(PSTM pstm)
{
    if (pstm) {
        WalkPv(pstm);
        WalkPv(pstm->ptchMin);
        WalkPv(pstm->ptchName);
        WalkPstm(pstm->pstmNext);
    }
}

/*****************************************************************************
 *
 *  WalkPdiv
 *
 *  Walk a diversion.
 *
 *****************************************************************************/

void STDCALL
WalkPdiv(PDIV pdiv)
{
    if (pdiv) {
        WalkPv(pdiv);
        WalkPv(pdiv->ptchMin);
        WalkPv(pdiv->ptchName);
    }
}

/*****************************************************************************
 *
 *  Sweep
 *
 *  Sweep through memory, looking for garbage.
 *
 *****************************************************************************/

void STDCALL
Sweep(void)
{
    PAR par;
    for (par = parHead->parNext; par != parHead; par = par->parNext) {
        Assert(par->tm == g_tmNow);     /* Memory should have been walked! */
    }
}

/*****************************************************************************
 *
 *  Gc
 *
 *  The garbage collector is mark-and-sweep.
 *
 *  Walk all the root objects, recursing into sub-objects, until everything
 *  is marked with the current (fake) timestamp.  Then walk through the
 *  memory arenas.  Anything not marked with the current timestamp is garbage.
 *
 *****************************************************************************/

TM g_tmNow;

void STDCALL
Gc(void)
{
    g_tmNow++;
    if (mphashpmac) {
        WalkPv(mphashpmac);
        EachMacroOp(WalkPmac);
    }
    WalkPv(rgtokArgv);
    WalkPv(rgcellEstack);
    WalkPstm(g_pstmCur);
    WalkPdiv(g_pdivArg);
    WalkPdiv(g_pdivExp);
    WalkPdiv(g_pdivOut);
    WalkPdiv(g_pdivErr);
    WalkPdiv(g_pdivNul);
    Sweep();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\divert.h ===
/*****************************************************************************
 *
 *  divert.h
 *
 *  Diversions
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Diversions
 *
 *  A DIV (diversion) is a place where characters are thrown.  There are
 *  two kinds of diversions, corresponding to how data come out of them.
 *  Although the same basic functions operate on diversions, the two types
 *  are used for quite different purposes.
 *
 *  File diversions are managed by the `divert' and `undivert' builtins
 *  and hold data that will be regurgitated later all at one go,
 *  possibly into another diversion.  File diversions consists of a
 *  fixed-size holding buffer, which when filled is dumped to a
 *  temporary file.  When the diversion is regurgitated, the file is
 *  closed, rewound, and spit back.  (Watch out! for the degenerate
 *  case where a file is undiverted back into itself.)  Note that small
 *  file diversions may never actually result in a file being created.
 *  The name of the temporary file must be held so that the file can
 *  be deleted once it is no longer needed.  (If this were UNIX, we
 *  could use the open/unlink trick...)
 *
 *  Memory diversions hold data that will be managed in a last in
 *  first out (stack-like) manner.  Memory diversions consist of a
 *  dynamically-sized holding buffer, whose size grows to accomodate
 *  the amount of stuff thrown into it.  Since memory diversions
 *  can be reallocated, you have to be careful about holding pointers
 *  into the buffer.
 *
 *  Thus was born the concept of `snapping'.  Tokens which live inside
 *  a diversion live their lives as `unsnapped' tokens, which means that
 *  they refer to bytes in a manner that is not sensitive to potential
 *  reallocations of their associated diversion.  However, accessing
 *  `unsnapped' tokens is relatively slow, so you can `snap' a token
 *  into its diversion, which speeds up access to the token, but the
 *  penalty is that the diversion cannot be reallocated while it contains
 *  any snapped tokens, which means that you cannot add new characters
 *  to the diversion.
 *
 *  The cSnap field in a memory diversion records how many snapped tokens
 *  still refer to the diversion.  Only when the snap count drops to zero
 *  can the diversion be modified.
 *
 *****************************************************************************/

typedef struct DIVERSION {
  D(SIG     sig;)               /* Signature */
    PTCH    ptchCur;            /* Current free character in diversion buffer */
    PTCH    ptchMax;            /* One past end of diversion buffer */
    PTCH    ptchMin;            /* Beginning of diversion buffer */
    HF      hf;                 /* File handle or hNil */
    PTCH    ptchName;           /* Name of temp file (0 if memory diversion) */
  D(int     cSnap;)
} DIV, *PDIV;
typedef CONST DIV *PCDIV;

#define ctchGrow 2048           /* Amount by which holds grow */

#define sigDiv sigABCD('D', 'i', 'v', 'n')
#define AssertPdiv(pdiv) AssertPNm(pdiv, Div)

#define fFilePdiv(pdiv) ((pdiv)->ptchName)

/*****************************************************************************
 *
 *  ctchPdiv
 *
 *  Returns the number of characters in the diversion buffer.  Note
 *  that this is relatively useless for file diversions since part
 *  of the data may be on disk.
 *
 *****************************************************************************/

INLINE CTCH
ctchPdiv(PCDIV pdiv)
{
    return (CTCH)(pdiv->ptchCur - pdiv->ptchMin);
}

/*****************************************************************************
 *
 *  ctchAvailPdiv
 *
 *  Returns the number of characters available in the diversion buffer.
 *
 *****************************************************************************/

INLINE CTCH
ctchAvailPdiv(PCDIV pdiv)
{
    return (CTCH)(pdiv->ptchMax - pdiv->ptchCur);
}

/*****************************************************************************
 *
 *  DesnapPdiv
 *
 *  Destroy a snapped token.  You can't just throw it away because that
 *  messes up the snap-ness bookkeeping.  NOTE! that a desnapped token
 *  becomes invalid the moment you add something new to the diversion.
 *
 *****************************************************************************/

INLINE void
DesnapPdiv(PDIV pdiv)
{
    AssertPdiv(pdiv);
  D(pdiv->cSnap--);
}

void STDCALL UnbufferPdiv(PDIV pdiv);
void STDCALL FlushPdiv(PDIV pdiv);
PDIV STDCALL pdivAlloc(void);
void STDCALL OpenPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL AddPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL AddPdivTch(PDIV pdiv, TCH tch);
void STDCALL ClosePdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL PopPdivPtok(PDIV pdiv, PTOK ptok);
PTCH STDCALL ptchPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL SnapPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL UnsnapPdivPtok(PDIV pdiv, PTOK ptok);
typedef void (STDCALL *DIVOP)(PDIV pdiv, PTOK ptok);
void STDCALL CsopPdivDopPdivPtok(PDIV pdivSrc, DIVOP op, PDIV pdivDst, PTOK ptok);

/*
 *  Some predefined holds and ways to get to them.
 *
 *  The most important hold is the `Arg' hold.  This is where
 *  macro parameters are collected and parsed.  Note! that the
 *  `Arg' hold is snapped during macro expansion.
 *
 *  Another popular hold is the `Exp' hold.  This is where
 *  macro expansions are held until a final home can be found.
 *
 *  This would be a lot easier if we supported currying...
 *
 */

extern PDIV g_pdivArg;

#define OpenArgPtok(ptok)       OpenPdivPtok(g_pdivArg, ptok)
#define CloseArgPtok(ptok)      ClosePdivPtok(g_pdivArg, ptok)
#define AddArgPtok(ptok)        AddPdivPtok(g_pdivArg, ptok)
#define AddArgTch(tch)          AddPdivTch(g_pdivArg, tch)
#define ptchArgPtok(ptok)       ptchPdivPtok(g_pdivArg, ptok)
#define SnapArgPtok(ptok)       SnapPdivPtok(g_pdivArg, ptok)
#define UnsnapArgPtok(ptok)     UnsnapPdivPtok(g_pdivArg, ptok)
#define DesnapArg()             DesnapPdiv(g_pdivArg)
#define PopArgPtok(ptok)        PopPdivPtok(g_pdivArg, ptok)
#define CsopArgDopPdivPtok(op, pdiv, ptok) \
                                CsopPdivDopPdivPtok(g_pdivArg, op, pdiv, ptok)

extern PDIV g_pdivExp;

#define OpenExpPtok(ptok)       OpenPdivPtok(g_pdivExp, ptok)
#define CloseExpPtok(ptok)      ClosePdivPtok(g_pdivExp, ptok)
#define AddExpPtok(ptok)        AddPdivPtok(g_pdivExp, ptok)
#define AddExpTch(tch)          AddPdivTch(g_pdivExp, tch)
#define ptchExpPtok(ptok)       ptchPdivPtok(g_pdivExp, ptok)
#define SnapExpPtok(ptok)       SnapPdivPtok(g_pdivExp, ptok)
#define UnsnapExpPtok(ptok)     UnsnapPdivPtok(g_pdivExp, ptok)
#define DesnapExp()             DesnapPdiv(g_pdivExp)
#define PopExpPtok(ptok)        PopPdivPtok(g_pdivExp, ptok)
#define CsopExpDopPdivPtok(op, pdiv, ptok) \
                                CsopPdivDopPdivPtok(g_pdivExp, op, pdiv, ptok)

extern PDIV g_pdivErr;
extern PDIV g_pdivOut;
extern PDIV g_pdivNul;
extern PDIV g_pdivCur;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\each.c ===
/*****************************************************************************
 *
 * each.c
 *
 *  Walking argument lists.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 * EachOpcArgvDw
 * EachReverseOpcArgvDw
 *
 *  Call opc once for each argument in the argv.  dw is reference data.
 *
 *  EachOpcArgvDw walks the list forwards; EachReverseOpcArgvDw backwards.
 *
 *****************************************************************************/

void STDCALL
EachOpcArgvDw(OPC opc, ARGV argv, DWORD dw)
{
    IPTOK iptok;
    for (iptok = 1; iptok <= ctokArgv; iptok++) {
        opc(ptokArgv(iptok), iptok, dw);
    }
}

void STDCALL
EachReverseOpcArgvDw(OPC opc, ARGV argv, DWORD dw)
{
    IPTOK iptok;
    for (iptok = ctokArgv; iptok >= 1; iptok--) {
        opc(ptokArgv(iptok), iptok, dw);
    }
}

/*****************************************************************************
 *
 * EachMacroOp
 *
 *  Call op once for each macro in current existence.
 *
 *****************************************************************************/

void STDCALL
EachMacroOp(MOP mop)
{
    HASH hash;
    for (hash = 0; hash < g_hashMod; hash++) {
        PMAC pmac;
        for (pmac = mphashpmac[hash]; pmac; pmac = pmac->pmacNext) {
            mop(pmac);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\io.h ===
/*****************************************************************************
 *
 *  io.h
 *
 *****************************************************************************/

#ifdef  POSIX

        typedef int HF;
        #define hfNil (-1)
        #define hfIn  0
        #define hfOut 1
        #define hfErr 2

        #define hfOpenPtchOf    open
        #define hfCreatPtch(p)  creat(p, 0600)
        #define cbReadHfPvCb    read
        #define cbWriteHfPvCb   write
        #define CloseHf         close
        #define OF_READ         O_RDONLY
        #define OF_WRITE        O_WRONLY

        #define fInteractiveHf  isatty

        #define c_tszNullDevice TEXT("/dev/null")

#else

        typedef HFILE HF;
        #define hfNil ((HF)HFILE_ERROR)
        #define hfIn  ((HF)(UINT_PTR)GetStdHandle(STD_INPUT_HANDLE))
        #define hfOut ((HF)(UINT_PTR)GetStdHandle(STD_OUTPUT_HANDLE))
        #define hfErr ((HF)(UINT_PTR)GetStdHandle(STD_ERROR_HANDLE))

        #define hfOpenPtchOf    _lopen
        #define hfCreatPtch(p)  _lcreat(p, 0)
        #define cbReadHfPvCb    _lread
        #define CloseHf         _lclose

        #define c_tszNullDevice TEXT("nul")

        /*
         *  _lwrite has the quirk that writing zero bytes causes the file
         *  to be truncated.  (Instead of just plain writing zero bytes.)
         */
        INLINE CB
        cbWriteHfPvCb(HF hf, PCVOID pv, CB cb) {
            if (cb) {
                return _lwrite(hf, pv, cb);
            } else {
                return 0;
            }
        }

        #define fInteractiveHf(hf) (GetFileType((HANDLE)IntToPtr(hf)) == FILE_TYPE_CHAR)

#endif

void STDCALL WriteHfPvCb(HF hf, PCVOID pv, CB cb);

INLINE void
WriteHfPtchCtch(HF hf, PCTCH ptch, CTCH ctch)
{
    WriteHfPvCb(hf, ptch, cbCtch(ctch));
}

#ifdef POSIX
UINT GetTempFileName(PCSTR, PCSTR, UINT, PTCH);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\eval.c ===
/*****************************************************************************
 *
 * eval.c
 *
 *  Arithmetical evaluation.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  First, a warm-up:  Increment and decrement.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  opIncr
 *  opDecr
 *
 *  Returns the value of its argument, augmented or diminished by unity.
 *  The extra ptokNil covers us in the case where $# is zero.
 *
 *****************************************************************************/

void STDCALL
opAddItokDat(ARGV argv, DAT dat)
{
    AT at = atTraditionalPtok(ptokArgv(1));
#ifdef STRICT_M4
    if (ctokArgv != 1) {
        Warn("wrong number of arguments to %P", ptokArgv(0));
    }
#endif
    PushAt(at+dat);
}

DeclareOp(opIncr)
{
    opAddItokDat(argv, 1);
}

DeclareOp(opDecr)
{
    opAddItokDat(argv, -1);
}

/*****************************************************************************
 *
 *  Now the gross part:  Eval.
 *
 *  Expression evaluation is performed by a parser which is a mix of
 *  shift-reduce and recursive-descent.  (Worst of both worlds.)
 *
 *  The precedence table for our expression language reads
 *
 *          (...)               grouping        > primary
 *          + -                 unary
 *          **                  exponentiation
 *          * / %               multiplicative
 *          + -                 additive
 *          << >>               shift
 *          == != > >= < <=     relational
 *          !                   logical-negate
 *          ~                   bit-negate
 *          &                   bit-and
 *          ^                   bit-xor
 *          |                   bit-or
 *          &&                  logical-and
 *          ||                  logical-or
 *
 *
 *  COMPAT -- AT&T style uses ^ for exponentiation; we use it for xor
 *
 *  NOTE: "the rest is bogus" went the original comment.  I forget what
 *  I meant by that.
 *
 *  The precedence table for the C-style expression language reads
 *
 *          (...)               grouping        \ primary
 *          + - ~ !             unary           /
 *          * / %               multiplative    \
 *          + -                 additive         \
 *          << >>               shift            |
 *          < > <= >=           relational       |
 *          == !=               equality          \ secondary
 *          &                   bit-and           /
 *          ^                   bit-xor          |
 *          |                   bit-or           |
 *          &&                  logical-and      /
 *          ||                  logical-or      /
 *          ? :                 ternary         > tertiary
 *
 *  Recursive descent is performed on the primary/secondary/tertiary
 *  scale, but shift-reduce is performed within the secondary phase.
 *
 *  The reason is that the operators in the secondary phase are
 *  (1) binary, and (2) non-recursive.  These two properties
 *  make shift-reduce easy to implement.
 *
 *  Primaries are recursive, so they are easier to implement in
 *  recursive-descent.  Tertiaries would clog up the shift-reduce
 *  grammar, so they've been moved to recursive-descent as well.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  EachEop
 *
 *      Before calling this macro, define the following macros, each of
 *      which will be called with three arguments,
 *
 *              nm = operator name as a C identifier (e.g., "Add")
 *              op = operator name as a bare token (e.g., "+")
 *              cb = length of operator name
 *
 *      The macros should be
 *
 *              x1 -- for native C unary operators
 *              x1a -- for native C unary operators which have binary aliases
 *              x2 -- for native C binary operators
 *              x2a -- for native C binary operators which have unary aliases
 *              x2n -- for non-native C binary operators
 *              xp -- for phantom operators,
 *                      in which case op and cb are useless
 *
 *      The order in which operators appear is important for the purpose
 *      of tokenization.  Longer operators must precede shorter ones.
 *
 *****************************************************************************/

#define EachEop() \
        x2(Shl, <<, 2) \
        x2(Shr, >>, 2) \
        x2(Le, <=, 2) \
        x2(Ge, >=, 2) \
        x2(Eq, ==, 2) \
        x2(Ne, !=, 2) \
        x2(Land, &&, 2) \
        x2(Lor, ||, 2) \
        x2n(Exp, **, 2) \
        x2(Mul, *, 1) \
        x2(Div, /, 1) \
        x2(Mod, %, 1) \
        x2a(Add, +, 1)                  /* These two must be */ \
        x2a(Sub, -, 1)                  /* in exactly this order */ \
        x2(Lt, <, 1) \
        x2(Gt, >, 1) \
        x2(Band, &, 1) \
        x2(Bxor, ^, 1) \
        x2(Bor, |, 1) \
        x1(Lnot, !, 1) \
        x1(Bnot, ~, 1) \
        x1a(Plu, +, x)                  /* These two must be */ \
        x1a(Neg, -, x)                  /* in exactly this order */ \
        xp(Flush, @, 0) \
        xp(Boe, @, 0) \


/*****************************************************************************
 *
 *  MakeEop
 *
 *      Each binary operator has a handler which returns the combined
 *      value.
 *
 *      Each unary operator has a handler which returns the operator
 *      applied to its single argument.
 *
 *      All the operators are C native, except for Exp, which is handled
 *      directly.
 *
 *****************************************************************************/

typedef AT (STDCALL *EOP1)(AT at);
typedef AT (STDCALL *EOP2)(AT a, AT b);

#define x1(nm, op, cb) AT STDCALL at##nm##At(AT at) { return op at; }
#define x1a(nm, op, cb) AT STDCALL at##nm##At(AT at) { return op at; }
#define x2(nm, op, cb) AT STDCALL at##nm##AtAt(AT a, AT b) { return a op b; }
#define x2a(nm, op, cb) AT STDCALL at##nm##AtAt(AT a, AT b) { return a op b; }
#define x2n(nm, op, cb)
#define xp(nm, op, cb)

EachEop()

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n
#undef xp

/*****************************************************************************
 *
 *  atExpAtAt
 *
 *      Implement the exponentiation operator.
 *
 *      QUIRK!  AT&T returns 1 if $2 < 0.  GNU raises an error.
 *      I side with AT&T on this, only out of laziness.
 *
 *****************************************************************************/

AT STDCALL
atExpAtAt(AT a, AT b)
{
    AT at = 1;
    while (b > 0) {
        if (b & 1) {
            at = at * a;
        }
        a = a * a;
        b = b / 2;
    }
    return at;
}

TOK tokExpr;                            /* Current expression context */

/*****************************************************************************
 *
 *  MakeEopTab
 *
 *      Table of operators and operator precedence.  Each entry in the
 *      table contains the name, length, handler, precedence, and
 *      flags that describe what kind of operator it is.
 *
 *      Items are listed in precedence order here; the EachBop will
 *      emit the table corrctly.
 *
 *****************************************************************************/

typedef enum EOPFL {
    eopflUn = 1,
    eopflBin = 2,
    eopflAmb = 4,
} EOPFL;

typedef UINT PREC;                      /* Operator precedence */

typedef struct EOPI {
    PTCH ptch;
    CTCH ctch;
    union {
        EOP1 eop1;
        EOP2 eop2;
    } u;
    PREC prec;
    EOPFL eopfl;
} EOPI, *PEOPI;

#define MakeEopi(nm, ctch, pfn, prec, eopfl) \
    { TEXT(nm), ctch, { (EOP1)pfn }, prec, eopfl },

enum {
    m4precNeg = 14, m4precPlu = 14,
    m4precExp = 13,
    m4precMul = 12, m4precDiv = 12, m4precMod = 12,
    m4precAdd = 11, m4precSub = 11,
    m4precShl = 10, m4precShr = 10,
    m4precEq  = 9, m4precNe  = 9,
    m4precGt  = 9, m4precGe  = 9,
    m4precLt  = 9, m4precLe  = 9,
    m4precLnot = 8,
    m4precBnot = 7,
    m4precBand = 6,
    m4precBxor = 5,
    m4precBor = 4,
    m4precLand = 3,
    m4precLor = 2,
    m4precFlush = 1,                    /* Flushing out everything but Boe */
    m4precBoe = 0,                      /* Beginning-of-expression */
};

#define x1(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define x1a(nm, op, cb)
#define x2(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define x2a(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define x2n(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define xp(nm, op, cb)

    EachEop()

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n
#undef xp

#define x1(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##At, m4prec##nm, eopflUn)
#define x1a(nm, op, cb) MakeEopi(0, 0, at##nm##At, m4prec##nm, eopflUn)
#define x2(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##AtAt, m4prec##nm, eopflBin)
#define x2a(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##AtAt, m4prec##nm, eopflAmb + eopflBin) /* initially bin */
#define x2n(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##AtAt, m4prec##nm, eopflBin)
#define xp(nm, op, cb) MakeEopi(0, 0, 0, m4prec##nm, 0)

EOPI rgeopi[] = {
    EachEop()
};

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n
#undef xp

#define x1(nm, op, cb) ieopi##nm,
#define x1a(nm, op, cb) ieopi##nm,
#define x2(nm, op, cb) ieopi##nm,
#define x2a(nm, op, cb) ieopi##nm,
#define x2n(nm, op, cb) ieopi##nm,
#define xp(nm, op, cb) ieopi##nm,

typedef enum IEOPI {
    EachEop()
    ieopMax,
} IEOPI;

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n

#define peopiBoe (&rgeopi[ieopiBoe])
#define peopiFlush (&rgeopi[ieopiFlush])

/*****************************************************************************
 *
 *  fPrimary, fSecondary, fTertiary
 *
 *      Forward declarations for the recursive-descent parser.
 *
 *      Each parses a token/expression of the appropriate class
 *      and leaves it on the top of the expression stack, or
 *      returns 0 if the value could not be parsed.
 *
 *****************************************************************************/

F STDCALL fPrimary(void);
F STDCALL fSecondary(void);
#define fTertiary fSecondary

/*****************************************************************************
 *
 *  Cells
 *
 *      The expression stack consists of structures which, for lack of
 *      a better name, are called `cells'.  Each cell can hold either
 *      an expression operator or an integer, distinguished by the fEopi
 *      field.
 *
 *      In keeping with parser terminology, the act of pushing something
 *      onto the stack is called `shifting'.  Collapsing objects is called
 *      `reducing'.
 *
 *****************************************************************************/

typedef struct CELL {
    F fEopi;
    union {
        PEOPI peopi;
        AT at;
    } u;
} CELL, *PCELL;
typedef UINT CCELL, ICELL;

PCELL rgcellEstack;                     /* The expression stack */
PCELL pcellMax;                         /* End of the stack */
PCELL pcellCur;                         /* Next free cell */

INLINE PCELL
pcellTos(ICELL icell)
{
    Assert(pcellCur - 1 - icell >= rgcellEstack);
    return pcellCur - 1 - icell;
}

/*****************************************************************************
 *
 *  Stack munging
 *
 *      Quickie routines that poke at the top-of-stack.
 *
 *****************************************************************************/

INLINE F fWantOp(void) { return !pcellTos(1)->fEopi; }

INLINE F fOpTos(ICELL icell) { return pcellTos(icell)->fEopi; }

INLINE PEOPI
peopiTos(ICELL icell)
{
    Assert(fOpTos(icell));
    return pcellTos(icell)->u.peopi;
}

INLINE AT
atTos(ICELL icell)
{
    Assert(!fOpTos(icell));
    return pcellTos(icell)->u.at;
}

INLINE F fBinTos(ICELL icell) { return peopiTos(icell)->eopfl & eopflBin; }
INLINE F  fUnTos(ICELL icell) { return peopiTos(icell)->eopfl & eopflUn;  }
INLINE F fAmbTos(ICELL icell) { return peopiTos(icell)->eopfl & eopflAmb; }
INLINE PREC precTos(ICELL icell) { return peopiTos(icell)->prec; }

INLINE void
UnFromAmb(ICELL icell)
{
    Assert(fOpTos(icell));
    pcellTos(icell)->u.peopi += (ieopiPlu - ieopiAdd);
}


/*****************************************************************************
 *
 *  ShiftCell
 *
 *      Shift a cell onto the expression stack.
 *
 *      QShiftCell shifts in a cell assuming that the stack is already
 *      big enough to handle it.
 *
 *****************************************************************************/

void STDCALL
QShiftCell(UINT_PTR uiObj, F fEopi)
{
    Assert(pcellCur < pcellMax);
    pcellCur->fEopi = fEopi;
    if (fEopi) {
        pcellCur->u.peopi = (PEOPI)uiObj;
    } else {
        pcellCur->u.at = (INT)uiObj;
    }
    pcellCur++;
}

void STDCALL
ShiftCell(UINT_PTR uiObj, F fEopi)
{
    if (pcellCur >= pcellMax) {
        CCELL ccell = (CCELL)(pcellMax - rgcellEstack + 128); /* Should be enough */
        rgcellEstack = pvReallocPvCb(rgcellEstack, ccell * sizeof(CELL));
        pcellCur = rgcellEstack + ccell - 128;
        pcellMax = rgcellEstack + ccell;
    }
    QShiftCell(uiObj, fEopi);
}

#define ShiftPeopi(peopi) ShiftCell((UINT_PTR)(peopi), 1)
#define ShiftAt(at) ShiftCell((UINT_PTR)(at), 0)

#define QShiftPeopi(peopi) QShiftCell((UINT_PTR)(peopi), 1)
#define QShiftAt(at) QShiftCell((UINT_PTR)(at), 0)

#define Drop(icell) (pcellCur -= (icell))

/*****************************************************************************
 *
 *  ReducePrec
 *
 *      Reduce until everything with higher precedence has been cleaned off.
 *
 *      Tos(0) should be a fresh operator.
 *      Everything underneath should be a valid partial evaluation.
 *
 *****************************************************************************/

void STDCALL
Reduce(void)
{
    PEOPI peopi;

    Assert(fOpTos(0));                  /* Tos(0) should be an op */
    Assert(!fOpTos(1));                 /* Tos(1) should be an int */
    Assert(fOpTos(2));                  /* Tos(2) should be an op */

    peopi = peopiTos(0);                /* Save this */
    Drop(1);                            /* before we drop it */

    while (precTos(1) > peopi->prec) {
        AT at;
        if (fUnTos(1)) {
            at = peopiTos(1)->u.eop1(atTos(0));
            Drop(2);                    /* Drop the op and the arg */
        } else {
            Assert(fBinTos(1));
            Assert(!fOpTos(2));
            at = peopiTos(1)->u.eop2(atTos(2), atTos(0));
            Drop(3);                    /* Drop the op and two args */
        }
        QShiftAt(at);                   /* Shift the answer back on */
        Assert(!fOpTos(0));             /* Tos(0) should be an int */
        Assert(fOpTos(1));              /* Tos(1) should be an op */
    }
    QShiftPeopi(peopi);                 /* Restore the original op */
}

/*****************************************************************************
 *
 *  fPrimary
 *
 *      Parse the next expression token and shift it onto the expression
 *      stack.  Zero is returned if there is no next token, or the token
 *      is invalid.
 *
 *      Here is where parenthesized expressions are handled, in a
 *      recursive-descent manner.
 *
 *      Ambiguous operators (ones which can be either unary or binary)
 *      are returned as binary.
 *
 *****************************************************************************/

F STDCALL
fPrimary(void)
{
    SkipWhitePtok(&tokExpr);            /* Skip leading whitespace */


    /*
     * First see if we can find an operator.
     */
    {
        PEOPI peopi;
        for (peopi = rgeopi; peopi < &rgeopi[ieopiPlu]; peopi++) {
            if (peopi->ctch <= ctchSPtok(&tokExpr) &&
                fEqPtchPtchCtch(ptchPtok(&tokExpr), peopi->ptch,
                                peopi->ctch)) {
                EatHeadPtokCtch(&tokExpr, peopi->ctch); /* Eat the op */
                ShiftPeopi(peopi);
                return 1;
            }
        }
    }

    /*
     * Didn't find an operator.  Look for an integer.
     */
    {
        AT at;
        if (fEvalPtokPat(&tokExpr, &at)) {
            ShiftAt(at);
            return 1;
        }
    }

    /*
     * Not an integer either.  Maybe a parenthesized expression.
     */
    {
        if (ptchPtok(&tokExpr)[0] == '(') {
            EatHeadPtokCtch(&tokExpr, 1); /* Eat the paren */
            if (fTertiary()) {          /* Leaves answer on top of stack */
                if (ptchPtok(&tokExpr)[0] == ')') {
                    EatHeadPtokCtch(&tokExpr, 1); /* Eat the paren */
                    return 1;
                } else {
                    return 0;
                }
            } else {
                return 0;               /* Trouble down below */
            }
        }
    }

    /*
     * Unrecognized token.  Return failure.
     */
    return 0;
}

/*****************************************************************************
 *
 *  fSecondary
 *
 *      Parse an expression from the expression stream, leaving the
 *      result on the top of the expression stack.
 *
 *****************************************************************************/

F STDCALL
fSecondary(void)
{
    ShiftPeopi(peopiBoe);               /* Beginning-of-expression marker */

    while (fPrimary()) {
        if (fWantOp()) {
            if (fOpTos(0)) {
                if (fBinTos(0)) {
                    Reduce();
                } else {
                    return 0;           /* Unary operator unexpected */
                }
            } else {
                return 0;               /* Integer unexpected */
            }
        } else {                        /* Integer expected */
            if (fOpTos(0)) {
                if (fAmbTos(0)) {
                    UnFromAmb(0);       /* Disambiguify */
                    ;                   /* Unary operator already shifted */
                } else if (fUnTos(0)) {
                    ;                   /* Unary operator already shifted */
                } else {
                    return 0;           /* Binary operator unexpected */
                }
            } else {
                ;                       /* Integer already shifted */
            }
        }
    }

    if (fOpTos(0)) {
        return 0;                       /* Ended in partial expression */
    }

    {
        AT at;

        ShiftPeopi(peopiFlush);         /* Flush out the rest of the expr */
        Reduce();                       /* to get a single number back */
        Assert(peopiTos(0) == peopiFlush);
        at = atTos(1);
        Assert(peopiTos(2) == peopiBoe); /* Should be back to start */
        Drop(3);
        ShiftAt(at);
    }
    return 1;

}

/*****************************************************************************
 *
 *  opEval
 *
 *      Evaluate the first expr.
 *
 *      QUIRK!  AT&T m4 considers a consisting entirely of whitespace to
 *      evaluate to zero.  (Probably due to a default accumulator in the
 *      initial state of the evaluator.)  GNU considers it an error.
 *      I side with GNU on this one.
 *
 *      QUIRK!  If a negative width is passed, AT&T silently treats it
 *      as zero.  GNU raises an error.  I side with A&T out of laziness.
 *
 *      QUIRK!  If a width greater than around 8000 is passed, AT&T
 *      silently treats it as zero.  GNU uses the full value.  I side
 *      with GNU on this one.
 *
 *****************************************************************************/

DeclareOp(opEval)
{
    if (ctokArgv) {
        SetStaticPtokPtchCtch(&tokExpr, ptchArgv(1), ctchArgv(1));
      D(tokExpr.tsfl |= tsflScratch);
        if (fTertiary()) {
            PushAtRadixCtch(atTos(0), (unsigned)atTraditionalPtok(ptokArgv(2)),
                            ctokArgv >= 3 ? atTraditionalPtok(ptokArgv(3)) :0);
            Drop(1);
            Assert(pcellCur == rgcellEstack);
        } else {
            TOK tokPre;
            SetStaticPtokPtchCtch(&tokPre, ptchArgv(1),
                                  ctchArgv(1) - ctchSPtok(&tokExpr));
            Die("Expression error at %P <<error>> %P", &tokPre, &tokExpr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\hash.c ===
/*****************************************************************************
 *
 * hash.c
 *
 *  Hashing tokens.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  hashPtok
 *
 *  Hash a token.
 *
 *  For now, use some hash function.
 *
 *****************************************************************************/

HASH STDCALL
hashPtok(PCTOK ptok)
{
    HASH hash = 0;
    PTCH ptch;
    for (ptch = ptchPtok(ptok); ptch < ptchMaxPtok(ptok); ptch++) {
        hash += (hash << 1) + (hash >> 1) + *ptch;
    }
    return hash % g_hashMod;
}

/*****************************************************************************
 *
 *  InitHash
 *
 *****************************************************************************/

void STDCALL
InitHash(void)
{
    mphashpmac = pvAllocCb(g_hashMod * sizeof(PMAC));
    bzero(mphashpmac, g_hashMod * sizeof(PMAC));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\io.c ===
/*****************************************************************************
 *
 *  io.c
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  WriteHfPvCb
 *
 *  Write bytes to a stream or die.
 *
 *****************************************************************************/

void STDCALL
WriteHfPvCb(HF hf, PCVOID pv, CB cb)
{
    CB cbRc = cbWriteHfPvCb(hf, pv, cb);

    /* Don't Die() if we couldn't write to hfErr or we will recurse to death */
    if (cb != cbRc && hf != hfErr) {
        Die("error writing");
    }
}

#ifdef POSIX
/*****************************************************************************
 *
 *  GetTempFileName
 *
 *****************************************************************************/

UINT
GetTempFileName(PCSTR pszPath, PCSTR pszPrefix, UINT uiUnique, PTCH ptchBuf)
{
    sprintf(ptchBuf, "%s/%sXXXXXX", pszPath, pszPrefix);
    return (UINT)mktemp(ptchBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\m4.h ===
/*****************************************************************************
 *
 *  m4.h
 *
 *****************************************************************************/

#ifdef  POSIX
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <limits.h>
        #include <string.h>
        #include <unistd.h>
        typedef char TCHAR, *PTCH;
        typedef const char *PCSTR;
        typedef unsigned char TBYTE, BYTE, *PBYTE;
        typedef unsigned int UINT;
        typedef unsigned long DWORD;
        typedef int BOOL, HFILE;
        typedef void *PVOID;
        #define VOID void
        #define CONST const
        #define TEXT(lit) lit
        #define MAX_PATH PATH_MAX
        #define max(a,b) (((a) > (b)) ? (a) : (b))
        #define min(a,b) (((a) < (b)) ? (a) : (b))

        #define EOL TEXT("\n")
        #define cbEol 1
#else
        #include <windows.h>
        #define EOL TEXT("\r\n")
        #define cbEol 2
#endif

#include <stddef.h>                     /* offsetof */

/*****************************************************************************
 *
 *  Dialectical variation
 *
 *****************************************************************************/

#ifdef DBG
#define DEBUG
#endif

/*****************************************************************************
 *
 *  Baggage - Stuff I carry everywhere.
 *
 *  Stuff that begin with underscores are bottom-level gizmos which tend
 *  to get wrapped by functions with the same name.
 *
 *****************************************************************************/

#if defined(_MSC_VER)

        #define STDCALL __stdcall
        #undef CDECL                    /* <windows.h> defines it wrong */
        #define CDECL __cdecl
        #define INLINE static __inline  /* Inlines are always static */
        #define NORETURN
        #define PURE

        #define _pvAllocCb(cb) LocalAlloc(LMEM_FIXED, cb)
        #define _pvZAllocCb(cb) LocalAlloc(LMEM_FIXED + LMEM_ZEROINIT, cb)
        #define _pvReallocPvCb(pv, cb) LocalReAlloc(pv, cb, LMEM_MOVEABLE)
        #define _FreePv(pv) LocalFree(pv)
        #define PrintPtchPtchVa wvsprintf
        #define PrintPtchPtchV wsprintf
        #define exit ExitProcess
        #define strlen lstrlen
        #define strcmp lstrcmp
        #define bzero ZeroMemory

#elif defined(__GNUC__)

        #define STDCALL
        #define CDECL
        #define INLINE static __inline__ /* Inlines are always static */
        #define NORETURN __NORETURN
        #define PURE __CONSTVALUE

        #define _pvAllocCb(cb) malloc(cb)
        #define _pvZAllocCb(cb) calloc(cb, 1)
        #define _pvReallocPvCb(pv, cb) realloc(pv, cb)
        #define _FreePv(pv) free(pv)
        #define PrintPtchPtchVa vsprintf
        #define PrintPtchPtchV sprintf

#endif

typedef TCHAR TCH, *PTSTR;              /* More basic types */
typedef UINT ITCH;
typedef UINT CTCH;
typedef UINT CB;
typedef BOOL F;
typedef PVOID PV;
typedef CONST VOID *PCVOID;
typedef CONST TCH *PCTCH, *PCTSTR;

#define cbCtch(ctch)    ((ctch) * sizeof(TCHAR))
#define ctchCb(cb)      ((cb) / sizeof(TCHAR))
#define ctchMax         ((CTCH)~0)

#define CopyPtchPtchCtch(ptchDst, ptchSrc, ctch) \
        memcpy(ptchDst, ptchSrc, cbCtch(ctch))
#define MovePtchPtchCtch(ptchDst, ptchSrc, ctch) \
        memmove(ptchDst, ptchSrc, cbCtch(ctch))
#define fEqPtchPtchCtch(ptchDst, ptchSrc, ctch) \
        !memcmp(ptchDst, ptchSrc, cbCtch(ctch))

#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))

/*
 * Round cb up to the nearest multiple of cbAlign.  cbAlign must be
 * a power of 2 whose evaluation entails no side-effects.
 */
#define ROUNDUP(cb, cbAlign) ((((cb) + (cbAlign) - 1) / (cbAlign)) * (cbAlign))

/*
 * Returns the number of elements in an array.
 */

#define cA(a) (sizeof(a)/sizeof(a[0]))

/*****************************************************************************
 *
 *  assert.c
 *
 *****************************************************************************/

void NORETURN CDECL Die(PCTSTR pszFormat, ...);
int NORETURN STDCALL AssertPszPszLn(PCSTR pszExpr, PCSTR pszFile, int iLine);

#ifdef  DEBUG

#define AssertFPsz(c, psz) ((c) ? 0 : AssertPszPszLn(psz, __FILE__, __LINE__))
#define Validate(c)     ((c) ? 0 : AssertPszPszLn(#c, __FILE__, __LINE__))
#define D(x)            x

#else

#define AssertFPsz(c, psz)
#define Validate(c)     (c)
#define D(x)

#endif

#define Assert(c)       AssertFPsz(c, #c)

typedef unsigned long SIG;              /* Signatures */

#define sigABCD(a,b,c,d) ((a) + ((b)<<8) + ((c)<<16) + ((d)<<24))
#define AssertPNm(p, nm) AssertFPsz((p)->sig == (sig##nm), "Assert"#nm)

/*****************************************************************************
 *
 *  tchMagic - Super-secret value used to signal out-of-band info
 *
 *****************************************************************************/

#define tchMagic    '\0'                /* Out-of-band marker */

#include "io.h"                         /* File I/O stuff */
#include "m4ctype.h"                    /* Character types */
#include "tok.h"                        /* Tokens */
#include "mem.h"                        /* Memory and GC */
#include "divert.h"                     /* Diversions */
#include "stream.h"                     /* Files, streams */

/*****************************************************************************
 *
 *  A VAL records a macro's value, either the current value or a pushed
 *  value.
 *
 *      tok - text value (HeapAllocate'd)
 *      fTrace - nonzero if this instance should be traced
 *      pvalPrev - link to previous value
 *
 *  A MACRO records an active macro.
 *
 *      tokName - macro name (HeapAllocate'd)
 *      pval - macro value
 *
 *  A TSFL records the state of a token (token state flags).
 *
 *****************************************************************************/


typedef struct VALUE VAL, *PVAL;

struct VALUE {
  D(SIG     sig;)
    TOK     tok;
    BOOL    fTrace;
    PVAL    pvalPrev;
};

#define sigPval sigABCD('V', 'a', 'l', 'u')
#define AssertPval(pval) AssertPNm(pval, Pval)

typedef struct MACRO MAC, *PMAC, **PPMAC;

struct MACRO {
  D(SIG     sig;)
    PMAC    pmacNext;
    TOK     tokName;
    PVAL    pval;
};

#define sigPmac sigABCD('M', 'a', 'c', 'r')
#define AssertPmac(pmac) AssertPNm(pmac, Pmac)

extern PPMAC mphashpmac;

/*****************************************************************************
 *
 *  operators
 *
 *      Each operator is called as op(argv), where argv is the magic
 *      cookie for accessing argument vector.
 *
 *      To access the parameters, use the following macros:
 *
 *      ctokArgv        -- Number of arguments provided, not including $0.
 *
 *      ptokArgv(i)     -- Access the i'th parameter
 *
 *      Note that it is safe to pass a pptok because the call stack does
 *      not grow during macro expansion.  Therefore, the token array
 *      cannot get reallocated.
 *
 *      For convenience, ptokArgv(ctokArgv+1) is always ptokNil.
 *
 *****************************************************************************/

typedef PTOK ARGV;                      /* Argument vector cookie */

#define ptokArgv(i) (&argv[i])
#define ptchArgv(i) ptchPtok(ptokArgv(i))
#define ctchArgv(i) ctchSPtok(ptokArgv(i))
#define ctokArgv    ((ITOK)ctchUPtok(ptokArgv(-1)))
#define SetArgvCtok(ctok) SetPtokCtch(ptokArgv(-1), ctok)

#define DeclareOp(op) void STDCALL op(ARGV argv)
#define DeclareOpc(opc) void STDCALL opc(PTOK ptok, ITOK itok, DWORD dw)

typedef void (STDCALL *OP)(ARGV argv);
typedef void (STDCALL *OPC)(PTOK ptok, ITOK itok, DWORD dw);
typedef void (STDCALL *MOP)(PMAC pmac);

void STDCALL EachOpcArgvDw(OPC opc, ARGV argv, DWORD dw);
void STDCALL EachReverseOpcArgvDw(OPC opc, ARGV argv, DWORD dw);
void STDCALL EachMacroOp(MOP mop);

extern OP rgop[];

/*****************************************************************************
 *
 *  hash.c - Hashing
 *
 *****************************************************************************/

typedef unsigned long HASH;

extern HASH g_hashMod;

HASH STDCALL hashPtok(PCTOK ptok);
void STDCALL InitHash(void);

/*****************************************************************************
 *
 * obj.c - Basic object methods
 *
 *****************************************************************************/

void STDCALL PopdefPmac(PMAC pmac);
void STDCALL PushdefPmacPtok(PMAC pmac, PCTOK ptok);
void STDCALL FreePmac(PMAC pmac);
PMAC STDCALL pmacFindPtok(PCTOK ptok);
PMAC STDCALL pmacGetPtok(PCTOK ptok);
F STDCALL PURE fEqPtokPtok(PCTOK ptok1, PCTOK ptok2);
F STDCALL PURE fIdentPtok(PCTOK ptok);
PTCH STDCALL ptchDupPtch(PCTCH ptch);
PTCH STDCALL ptchDupPtok(PCTOK ptok);

/*****************************************************************************
 *
 *  at.c - Arithmetic types
 *
 *****************************************************************************/

typedef int AT;                         /* AT = arithmetic type */
typedef AT *PAT;                        /* Pointer to AT */
typedef int DAT;                        /* Delta to AT */

void STDCALL SkipWhitePtok(PTOK ptok);
void STDCALL AddExpAt(AT at);
void STDCALL PushAtRadixCtch(AT atConvert, unsigned radix, CTCH ctch);
void STDCALL PushAt(AT at);
F STDCALL PURE fEvalPtokPat(PTOK ptok, PAT at);
AT STDCALL PURE atTraditionalPtok(PCTOK ptok);

/*****************************************************************************
 *
 *  eval.c - Arithmetic evaluation
 *
 *****************************************************************************/

extern struct CELL *rgcellEstack;

/*****************************************************************************
 *
 *  crackle.c - Macro expansion
 *
 *****************************************************************************/

void STDCALL PushSubstPtokArgv(PTOK ptok, ARGV argv);
void STDCALL TraceArgv(ARGV argv);

/*****************************************************************************
 *
 *  main.c - Boring stuff
 *
 *****************************************************************************/

HF STDCALL hfInputPtchF(PTCH ptch, F fFatal);

/*****************************************************************************
 *
 *  predef.c - Predefined (a.k.a. built-in) macros
 *
 *****************************************************************************/

void STDCALL InitPredefs(void);

/*****************************************************************************
 *
 *  EachOp
 *
 *      Before calling this macro, define the macro `x' to do whatever
 *      you want.
 *
 *  EachOpX
 *
 *      Same as EachOp, except that it also includes the Eof magic.
 *
 *****************************************************************************/

#define EachOp() \
    x(Define, define) \
    x(Undefine, undefine) \
    x(Defn, defn) \
    x(Pushdef, pushdef) \
    x(Popdef, popdef) \
    x(Ifdef, ifdef) \
    x(Shift, shift) \
/*  x(Changequote, changequote) */ \
/*  x(Changecom, changecom) */ \
    x(Divert, divert) \
/*  x(Undivert, undivert) */ \
    x(Divnum, divnum) \
    x(Dnl, dnl) \
    x(Ifelse, ifelse) \
    x(Incr, incr) \
    x(Decr, decr) \
    x(Eval, eval) \
    x(Len, len) \
    x(Index, index) \
    x(Substr, substr) \
    x(Translit, translit) \
    x(Include, include) \
    x(Sinclude, sinclude) \
/*  x(Syscmd, syscmd) */ \
/*  x(Sysval, sysval) */ \
/*  x(Maketemp, maketemp) */ \
/*  x(M4exit, m4exit) */ \
/*  x(M4wrap, m4wrap) */ \
    x(Errprint, errprint) \
    x(Dumpdef, dumpdef) \
    x(Traceon, traceon) \
    x(Traceoff, traceoff) \
    x(Patsubst, patsubst) /* GNU extension that the d3d guys rely on */ \

#define EachOpX() EachOp() x(Eof, eof) x(Eoi, eoi)

#define x(cop, lop) DeclareOp(op##cop);
EachOpX()
#undef x

enum MAGIC {
#define x(cop, lop) tch##cop,
    EachOpX()
#undef x
    tchMax,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\main.c ===
/*****************************************************************************
 *
 * main.c
 *
 *  Main program.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  InitDiversions
 *
 *****************************************************************************/

void STDCALL
InitDiversions(void)
{
    g_pdivOut = pdivAlloc();
    g_pdivOut->hf = hfOut;
    g_pdivOut->ptchName = ptchDupPtch(TEXT("<stdout>"));

    if (fInteractiveHf(g_pdivOut->hf)) {
        UnbufferPdiv(g_pdivOut);
    }

    g_pdivErr = pdivAlloc();
    g_pdivErr->hf = hfErr;
    g_pdivErr->ptchName = ptchDupPtch(TEXT("<stderr>"));

    g_pdivNul = pdivAlloc();
    g_pdivNul->hf = hfOpenPtchOf(c_tszNullDevice, OF_WRITE);
    g_pdivNul->ptchName = ptchDupPtch(TEXT("<nul>"));

    g_pdivArg = pdivAlloc();
    g_pdivExp = pdivAlloc();

    g_pdivCur = g_pdivOut;
}

/*****************************************************************************
 *
 *  hfPathOpenPtch
 *
 *      Open a file, searching the -I include path if necessary.
 *
 *****************************************************************************/

LPTSTR g_ptszIncludePath;

HF STDCALL
hfPathOpenPtch(PTCH ptch)
{
    /* First try in the current directory */
    HFILE hf = hfOpenPtchOf(ptch, OF_READ);
    if (hf == hfNil) {
        /* If that failed, then look on the g_ptszIncludePath (if any) */
        if (g_ptszIncludePath) {
            TCHAR tszNewPath[MAX_PATH];
            if (SearchPath(g_ptszIncludePath, ptch, NULL, MAX_PATH, tszNewPath, NULL)) {
                hf = hfOpenPtchOf(tszNewPath, OF_READ);
            }
        }
    }
    return hf;
}

/*****************************************************************************
 *
 *  hfInputPtchF
 *
 *      Push the requested file onto the input stream, returning the
 *      file handle, or hfNil on failure.  The filename should be on
 *      the heap.  If fFatal is set, then die if the file could not be
 *      opened.
 *
 *****************************************************************************/

HF STDCALL
hfInputPtchF(PTCH ptch, F fFatal)
{
    HFILE hf = hfPathOpenPtch(ptch);
    if (hf != hfNil) {
        pstmPushHfPtch(hf, ptch);
    } else {
        if (fFatal) {
#ifdef ATT_ERROR
            Die("can't open file");
#else
            Die("Cannot open %s: %s", ptch, strerror(errno));
#endif
        }
    }
    return hf;
}

/*****************************************************************************
 *
 *  InputHfPtsz
 *
 *      Push the requested file onto the input stream, with appropriate
 *      end-of-input markers.
 *
 *      If hf is not hfNil, then it is the file handle to push and
 *      ptch is the friendly to associate with it.
 *
 *      If hf is hfNil, then ptch is a filename which should be opened and
 *      pushed.
 *
 *****************************************************************************/

void STDCALL
InputHfPtsz(HF hf, PTCH ptch)
{
    pstmPushStringCtch(2);
    PushPtok(&tokEoi);
    ptch = ptchDupPtch(ptch);
    if (ptch) {
        if (hf == hfNil) {
            hfInputPtchF(ptch, 1);
        } else {
            pstmPushHfPtch(hf, ptch);
        }
    }
}

/*****************************************************************************
 *
 *  DefinePtsz
 *
 *      Handle a macro definition on the command line.
 *
 *      The macro name consists of everything up to the `='.
 *
 *      If there is no `=', then everything is the name and the value
 *      is null.
 *
 *      We need four tok's in our fake argv:
 *
 *      argv[-1] = $#
 *      argv[0]  = `define' (we don't bother setting this)
 *      argv[1]  = var
 *      argv[2]  = value
 *
 *****************************************************************************/

void STDCALL
DefinePtsz(PTSTR ptszVar)
{
    PTSTR ptsz, ptszValue;
    int itok;
    TOK rgtok[4];

    for (itok = 0; itok < cA(rgtok); itok++) {
      D(rgtok[itok].sig = sigUPtok);
      D(rgtok[itok].tsfl = 0);
    }

    SetPtokCtch(&rgtok[0], 3);

    /*
     *  Look for the = if we have one.
     */
    for (ptsz = ptszVar; *ptsz; ptsz++) {
        if (*ptsz == TEXT('=')) {
            *ptsz = TEXT('\0');
            ptszValue = ptsz + 1;
            goto foundval;
        }
    }

    ptszValue = ptsz;

foundval:;

    SetStaticPtokPtchCtch(&rgtok[3], ptszValue, strlen(ptszValue));
    SetStaticPtokPtchCtch(&rgtok[2], ptszVar, strlen(ptszVar));

    opDefine(&rgtok[1]);

}

/*****************************************************************************
 *
 *  SetIncludePathPtsz
 *
 *      Set the include path, which will be used to resolve filenames.
 *
 *****************************************************************************/

const TCHAR c_tszIncludePath[] =
TEXT("Error: Cannot specify -I more than once.  (If you need multiple") EOL
TEXT("       directories, separate them with a semicolon.)") EOL
;

BOOL STDCALL
SetIncludePathPtsz(PTSTR ptszPath)
{
    if (g_ptszIncludePath) {
        cbWriteHfPvCb(hfErr, c_tszIncludePath, cbCtch(cA(c_tszIncludePath) - 1));
        return FALSE;
    }
    g_ptszIncludePath = ptszPath;
    return TRUE;
}

/*****************************************************************************
 *
 *  Usage
 *
 *  Quick usage string.
 *
 *****************************************************************************/

const TCHAR c_tszUsage[] =
TEXT("Usage: m4 [-?] [-Dvar[=value]] [filename(s)]") EOL
EOL
TEXT("Win32 implementation of the m4 preprocessor.") EOL
EOL
TEXT("-?") EOL
TEXT("    Displays this usage string.") EOL
EOL
TEXT("-Dvar[=value]") EOL
TEXT("    Defines an M4 preprocessor symbol with optional initial value.") EOL
TEXT("    If no initial value is supplied, then the symbol is define with") EOL
TEXT("    a null value.") EOL
EOL
TEXT("[filename(s)]") EOL
TEXT("    Optional list of files to process.  If no files are given, then") EOL
TEXT("    preprocesses from stdin.  The result is sent to stdout.") EOL
EOL
TEXT("See m4.man for language description.") EOL
TEXT("See m4.txt for implementation description.") EOL
;

/*****************************************************************************
 *
 *  main
 *
 *****************************************************************************/

int CDECL
main(int argc, char **argv)
{
    InitHash();
    InitPredefs();
    InitDiversions();

    Gc();

    ++argv, --argc;                     /* Eat $0 */

    /*
     *  Process the command line options.
     */
    for ( ; argc && argv[0][0] == TEXT('-') && argv[0][1]; argv++, argc--) {
        switch (argv[0][1]) {
        case TEXT('D'):
            DefinePtsz(argv[0]+2);
            break;

        case TEXT('I'):
            if (!SetIncludePathPtsz(argv[0]+2)) {
                return 1;
            }
            break;

        default:                        /* Unknown - show usage */
            cbWriteHfPvCb(hfErr, c_tszUsage, cbCtch(cA(c_tszUsage) - 1));
            return 1;


        }
    }

    if (argc == 0) {
        argc = 1;
        argv[0] = TEXT("-");            /* Append imaginary "-" */
    }

    for ( ; argc; argv++, argc--) {
        if (argv[0][0] == '-' && argv[0][1] == '\0') {
            InputHfPtsz(hfIn, TEXT("<stdin>"));
        } else {
            InputHfPtsz(hfNil, argv[0]);
        }

        for (;;) {
            TOK tok;
            TYP typ = typXtokPtok(&tok);
            if (typ == typMagic) {
                if (ptchPtok(&tok)[1] == tchEoi) {
                    break;
                }
            } else {
                AddPdivPtok(g_pdivCur, &tok);
            }
            PopArgPtok(&tok);
        }
        Gc();

    }

    FlushPdiv(g_pdivOut);
    FlushPdiv(g_pdivErr);
    /*
     *  No point in flushing the null device.
     */
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\mem.h ===
/*****************************************************************************
 *
 *  mem.h
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Arenas
 *
 *  Memory is allocated in chunks called arenas.  Arenas contain extra
 *  bookkeeping in DEBUG to help catch common memory problems like
 *  overruns and memory leaks.  (It doesn't catch dangling pointers,
 *  though.)
 *
 *****************************************************************************/

typedef unsigned TM;    /* Artificial time */

typedef struct ARENA AR, *PAR;

struct ARENA {
#ifdef DEBUG
    PAR parNext;        /* Next arena */
    PAR parPrev;        /* Previous arena */
    CB cb;              /* Size of rgb */
    TM tm;              /* Timestamp used to track memory leaks */
#endif
    BYTE rgb[4];        /* The actual data */
};

typedef CONST AR *PCAR;

#define parPv(pv) pvSubPvCb(pv, offsetof(AR, rgb))

#ifdef DEBUG
extern TM g_tmNow;
extern AR g_arHead;
#define parHead (&g_arHead)
#endif

#ifdef DEBUG
void STDCALL AssertPar(PCAR par);
#else
#define AssertPar(par)
#endif
void STDCALL FreePv(PVOID pv);
PVOID STDCALL pvAllocCb(CB cb);
PVOID STDCALL pvReallocPvCb(PVOID pv, CB cb);

INLINE PTCH STDCALL
ptchAllocCtch(CTCH ctch)
{
    return pvAllocCb(cbCtch(ctch));
}

INLINE PTCH STDCALL
ptchReallocPtchCtch(PTCH ptch, CTCH ctch)
{
    return pvReallocPvCb(ptch, cbCtch(ctch));
}

/*****************************************************************************
 *
 *  Garbage collection
 *
 *****************************************************************************/

#ifdef DEBUG
void STDCALL Gc(void);
#else
#define Gc()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\m4ctype.h ===
/*****************************************************************************
 *
 *  ctype.h
 *
 *  Character type classification.
 *
 *****************************************************************************/

extern BYTE rgbIdent[];

#define tchLquo         '`'
#define tchRquo         '\''
#define tchLpar         '('
#define tchRpar         ')'
#define tchComma        ','

#define fLquoTch(tch) ((tch) == tchLquo)
#define fRquoTch(tch) ((tch) == tchRquo)
#define fLcomTch(tch) ((tch) == '#')
#define fRcomTch(tch) ((tch) == '\n')
#define fMagicTch(tch) ((tch) == tchMagic)

#define tchMaxMagic 30          /* Must be co-ordinated with predef.c */

#define fValidMagicTch(tch) ((TBYTE)(tch) < tchMaxMagic)

INLINE F
fIdentTch(TCH tch)
{
    return ((TBYTE)tch < 128 && rgbIdent[tch]);
}

INLINE F
fInitialIdentTch(TCH tch)
{
    return ((TBYTE)tch < 128 && (rgbIdent[tch] & 2));
}

INLINE F
fWhiteTch(TCH tch)
{
    return tch == ' ' || tch == '\r' || tch == '\n' || tch == '\t';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\obj.c ===
/*****************************************************************************
 *
 * obj.c
 *
 *  Mid-level memory management -- objects.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  FreePtok
 *
 *  Free the memory associated with a token.
 *
 *****************************************************************************/

INLINE void
FreePtok(PTOK ptok)
{
    AssertSPtok(ptok);
    Assert(fHeapPtok(ptok));
    FreePv(ptchPtok(ptok));
  D(ptok->sig = 0);
  D(ptok->tsfl = 0);
}

/*****************************************************************************
 *
 *  PopdefPmac
 *
 *  Pop the topmost value node (definition) off a macro.
 *
 *****************************************************************************/

void STDCALL
PopdefPmac(PMAC pmac)
{
    PVAL pval;

    AssertPmac(pmac);
    AssertPval(pmac->pval);

    pval = pmac->pval->pvalPrev;
    FreePtok(&pmac->pval->tok);
    FreePv(pmac->pval);
    pmac->pval = pval;

}

/*****************************************************************************
 *
 *  ptchDupPtok
 *
 *  Copy a token into the heap as a C-style string, returning a pointer
 *  to the copy.
 *
 *****************************************************************************/

PTCH STDCALL
ptchDupPtok(PCTOK ptok)
{
    PTCH ptch;
    AssertSPtok(ptok);
    ptch = ptchAllocCtch(ctchSPtok(ptok) + 1);
    if (ptch) {
        CopyPtchPtchCtch(ptch, ptchPtok(ptok), ctchSPtok(ptok));
        ptch[ctchSPtok(ptok)] = '\0';
    }
    return ptch;
}

/*****************************************************************************
 *
 *  ptchDupPtch
 *
 *      Duplicate a null-terminated string onto the heap.  This doesn't
 *      happen often, so speed is not an issue.
 *
 *****************************************************************************/

PTCH STDCALL
ptchDupPtch(PCTCH ptch)
{
    TOK tok;
    SetStaticPtokPtchCtch(&tok, ptch, strlen(ptch));
    return ptchDupPtok(&tok);
}

/*****************************************************************************
 *
 *  DupPtokPtok
 *
 *  Copy a token into the heap, returning the new token location in
 *  the first argument.  (Remember, first argument is always destination;
 *  second argument is always source.)
 *
 *****************************************************************************/

void STDCALL
DupPtokPtok(PTOK ptokDst, PCTOK ptokSrc)
{
    Assert(ptokDst != ptokSrc);
    AssertSPtok(ptokSrc);
  D(ptokDst->sig = sigSPtok);
    ptokDst->u.ptch = ptchAllocCtch(ctchSPtok(ptokSrc));
    ptokDst->ctch = ctchSPtok(ptokSrc);
  D(ptokDst->tsfl = tsflClosed | tsflHeap);
    CopyPtchPtchCtch(ptchPtok(ptokDst), ptchPtok(ptokSrc), ctchSPtok(ptokSrc));
}

/*****************************************************************************
 *
 *  PushdefPmacPtok
 *
 *  Push a new value node (definition) onto a macro.
 *
 *  The ptok is cloned.
 *
 *****************************************************************************/

void STDCALL
PushdefPmacPtok(PMAC pmac, PCTOK ptok)
{
    PVAL pval;

    AssertPmac(pmac);

    pval = pvAllocCb(sizeof(VAL));
  D(pval->sig = sigPval);
    pval->fTrace = 0;                   /* Redefinition resets trace */
    DupPtokPtok(&pval->tok, ptok);
    pval->pvalPrev = pmac->pval;
    pmac->pval = pval;
}


/*****************************************************************************
 *
 *  FreePmac
 *
 *  Free a macro structure and all its dependents.  Also removes it from the
 *  hash table.
 *
 *  Macros are not freed often, so we can afford to be slow.
 *
 *****************************************************************************/

void STDCALL
FreePmac(PMAC pmac)
{
    HASH hash;
    PMAC pmacDad;

    AssertPmac(pmac);

    hash = hashPtok(&pmac->tokName);

    pmacDad = pvSubPvCb(&mphashpmac[hash], offsetof(MAC, pmacNext));
    AssertPmac(pmacDad->pmacNext);
    while (pmacDad->pmacNext != pmac) {
        Assert(pmacDad->pmacNext);      /* Macro not in hash table */
        pmacDad = pmacDad->pmacNext;
        AssertPmac(pmacDad->pmacNext);
    }

    pmacDad->pmacNext = pmac->pmacNext; /* Unlink */

    while (pmac->pval) {                /* Free any values */
        PopdefPmac(pmac);
    }

    FreePtok(&pmac->tokName);

    FreePv(pmac);

}

/*****************************************************************************
 *
 *  pmacFindPtok
 *
 *  Locate a macro node corresponding to the supplied token.  If no such
 *  macro exists, then return 0.
 *
 *****************************************************************************/

PMAC STDCALL
pmacFindPtok(PCTOK ptok)
{
    PMAC pmac;
    for (pmac = mphashpmac[hashPtok(ptok)]; pmac; pmac = pmac->pmacNext) {
        if (fEqPtokPtok(&pmac->tokName, ptok)) {
            break;
        }
    }
    return pmac;
}

/*****************************************************************************
 *
 *  pmacGetPtok
 *
 *  Locate a macro node corresponding to the supplied token.  If no such
 *  macro exists, create one.
 *
 *  This happens only during macro definition, so it can be slow.
 *
 *****************************************************************************/

PMAC STDCALL
pmacGetPtok(PCTOK ptok)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (!pmac) {
        HASH hash;
        pmac = pvAllocCb(sizeof(MAC));
      D(pmac->sig = sigPmac);
        pmac->pval = 0;
        DupPtokPtok(&pmac->tokName, ptok);
        hash = hashPtok(ptok);
        pmac->pmacNext = mphashpmac[hash];
        mphashpmac[hash] = pmac;
    }
    return pmac;
}

/*****************************************************************************
 *
 *  fEqPtokPtok
 *
 *  Determine whether two tokens are completely identical.
 *
 *  The tokens must be snapped.
 *
 *****************************************************************************/

F STDCALL
fEqPtokPtok(PCTOK ptok1, PCTOK ptok2)
{
    AssertSPtok(ptok1);
    AssertSPtok(ptok2);
    return (ctchSPtok(ptok1) == ctchSPtok(ptok2)) &&
            fEqPtchPtchCtch(ptchPtok(ptok1), ptchPtok(ptok2), ctchSPtok(ptok1));
}

/*****************************************************************************
 *
 *  fIdentPtok
 *
 *  Determine whether the token is a valid identifier.
 *
 *  The token must be snapped.
 *
 *****************************************************************************/

/* SOMEDAY! not quite right; thinks that `0' is an identifier */

F STDCALL
fIdentPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    if (ctchSPtok(ptok)) {
        PTCH ptch = ptchPtok(ptok);
        do {
            if (!fIdentTch(*ptch)) {
                return 0;
            }
        } while (++ptch < ptchMaxPtok(ptok));
        return 1;
    } else {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\predef.c ===
/*****************************************************************************
 *
 * predef.c
 *
 *  Predefined macros.
 *
 *****************************************************************************/

#include "m4.h"

OP rgop[] = {
#define x(cop, lop) op##cop,
EachOpX()
#undef x
};

PTCH mptchptch[] = {
#define x(cop, lop) #lop,
EachOp()
#undef x
};

/*****************************************************************************
 *
 *  opEof, opEoi
 *
 *  Doesn't actually do anything.
 *
 *****************************************************************************/

DeclareOp(opEof)
{
}

DeclareOp(opEoi)
{
}

/*****************************************************************************
 *
 *  InitPredefs
 *
 *  Add definitions for all the predefined macros.
 *
 *****************************************************************************/

void STDCALL
InitPredefs(void)
{
    TCH rgtch[2];
    TOK tokSym;
    TOK tokVal;
#define tch rgtch[1]
    PMAC pmac;

    rgtch[0] = tchMagic;
    for (tch = 0; tch < tchEof; tch++) {
        SetStaticPtokPtchCtch(&tokSym, mptchptch[tch], strlen(mptchptch[tch]));
        SetStaticPtokPtchCtch(&tokVal, rgtch, 2);
        pmac = pmacGetPtok(&tokSym);
        Assert(!pmac->pval);            /* Should be a fresh token */
        PushdefPmacPtok(pmac, &tokVal);
    }
}
#undef tch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\mem.c ===
/*****************************************************************************
 *
 * mem.c
 *
 *  Low-level memory management.
 *
 *****************************************************************************/

#include "m4.h"

#ifdef DEBUG
    AR g_arHead = { parHead, parHead };
    #define cbExtra     (offsetof(AR, rgb)+1)
#else
    #define cbExtra             0
#endif


#ifdef DEBUG

/*****************************************************************************
 *
 *  InsertPar
 *
 *  Insert an arena record onto the list.
 *
 *****************************************************************************/

void InsertPar(PAR par)
{
    par->parPrev = parHead;
    par->parNext = parHead->parNext;
    parHead->parNext->parPrev = par;
    parHead->parNext = par;
}

/*****************************************************************************
 *
 *  UnlinkPar
 *
 *  Unlink an arena from the chain.
 *
 *****************************************************************************/

void STDCALL
UnlinkPar(PAR par)
{
    Assert(par->parNext->parPrev == par);
    Assert(par->parPrev->parNext == par);
    par->parNext->parPrev = par->parPrev;
    par->parPrev->parNext = par->parNext;
  D(par->rgb[par->cb] = 0xFF);
  D(par->tm = (TM)-1);
}

/*****************************************************************************
 *
 *  InitParCb
 *
 *  Initialize the arena fields that will be asserted later.
 *
 *****************************************************************************/

void STDCALL
InitParCb(PAR par, CB cb)
{
    par->cb = cb;
    par->rgb[cb] = 0xCC;                /* Overflow at end */
    par->tm = g_tmNow;                  /* Underflow at beginning */
}

/*****************************************************************************
 *
 *  AssertPar
 *
 *  Check that the arena is still okay.
 *
 *****************************************************************************/

void STDCALL
AssertPar(PCAR par)
{
    Assert(par->rgb[par->cb] == 0xCC);  /* Overflow at end */
    Assert(par->tm == g_tmNow);         /* Underflow at beginning */
    Assert(par->parNext->parPrev == par);
    Assert(par->parPrev->parNext == par);
}

/*****************************************************************************
 *
 *  MemCheck
 *
 *  Walk the entire list of memory arenas, making sure all is well.
 *
 *****************************************************************************/

void STDCALL
MemCheck(void)
{
    PAR par;
    for (par = parHead->parNext; par != parHead; par = par->parNext) {
        AssertPar(par);
    }
}

#else

#define InsertPar(par)
#define UnlinkPar(par)
#define InitParCb(par, cb)
#define MemCheck()

#endif

/*****************************************************************************
 *
 *  FreePv
 *
 *  Free an arbitrary hunk of memory.
 *
 *  The incoming pointer really is the rgb of an arena.
 *
 *****************************************************************************/

void STDCALL
FreePv(PVOID pv)
{
    MemCheck();
    if (pv) {
        PAR par = parPv(pv);
        AssertPar(par);
        UnlinkPar(par);
#ifdef DEBUG
        if (par->cb >= 4) {
            par->rgb[3]++;              /* Kill the signature */
        }
#endif
        _FreePv(par);
    }
    MemCheck();
}

/*****************************************************************************
 *
 *  pvAllocCb
 *
 *  Allocate a hunk of memory.
 *
 *  We really allocate an arena, but return the rgb.
 *
 *  We allow allocation of zero bytes, which allocates nothing and returns
 *  NULL.
 *
 *****************************************************************************/

PVOID STDCALL
pvAllocCb(CB cb)
{
    PAR par;
    MemCheck();
    if (cb) {
        par = _pvAllocCb(cb + cbExtra);
        if (par) {
            InitParCb(par, cb);
            InsertPar(par);
        } else {
            Die("out of memory");
        }
        MemCheck();
        return &par->rgb;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  pvReallocPvCb
 *
 *  Change the size of a hunk of memory.
 *
 *****************************************************************************/

PVOID STDCALL
pvReallocPvCb(PVOID pv, CB cb)
{
    MemCheck();
    if (pv) {
        PAR par = parPv(pv);
        Assert(cb);
        AssertPar(par);
        UnlinkPar(par);
        par = _pvReallocPvCb(par, cb + cbExtra);
        if (par) {
            InitParCb(par, cb);
            InsertPar(par);
        } else {
            Die("out of memory");
        }
        MemCheck();
        return &par->rgb;
    } else {
        return pvAllocCb(cb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\stream.c ===
/*****************************************************************************
 *
 * stream.c
 *
 *  Management of input streams.
 *
 *****************************************************************************/

#include "m4.h"

#define tsCur 0
#define tsNormal 0

/*****************************************************************************
 *
 *  FreePstm
 *
 *  Free the memory associated with a stream.
 *
 *****************************************************************************/

void STDCALL
FreePstm(PSTM pstm)
{
    AssertPstm(pstm);
    Assert(pstm->hf == hfNil);
    if (pstm->ptchName) {
        FreePv(pstm->ptchName);
    }
    FreePv(pstm->ptchMin);
    FreePv(pstm);
}

/*****************************************************************************
 *
 *  Reading from the stream
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  ptchFindPtchCtchTch
 *
 *  Locate the first occurrence of a character in a buffer.
 *  Returns 0 if the character is not found.
 *
 *****************************************************************************/

#ifdef UNICODE

PTCH STDCALL
ptchFindPtchCtchTch(PCTCH ptch, CTCH ctch, TCH tch)
{
    for ( ; ctch; ptch++, ctch--) {
        if (*ptch == tch) {
            return ptch;
        }
    }
    return 0;
}

#else

#define ptchFindPtchCtchTch(ptch, ctch, tch) memchr(ptch, tch, ctch)

#endif

/*****************************************************************************
 *
 *  ctchDemagicPstmCtch
 *
 *  Quote all occurences of tchMagic in the stream.  This is called only
 *  when you're probably already in trouble, so performance is not an issue.
 *
 *  Entry:
 *
 *      pstm->ptchMin -> Beginning of buffer
 *      pstm->ptchMax -> End of buffer
 *      ctch = number of characters to convert
 *
 *  Returns:
 *
 *      number of characters converted and left in the buffer
 *      pstm->ptchMin -> Beginning of buffer
 *      pstm->ptchMax -> End of buffer
 *
 *      NOTE! that this procedure may reallocate the buffer.
 *
 *****************************************************************************/

/* SOMEDAY! - This causes NULs to come out as tchzero, whatever that is! */

CTCH STDCALL
ctchDemagicPstmCtch(PSTM pstm, CTCH ctch)
{
    PTCH ptchIn, ptchOut, ptchMax, ptchNew;

    AssertPstm(pstm);
    ptchNew = ptchAllocCtch(ctch * 2);  /* Worst-case output buffer */
    ptchMax = pstm->ptchMin + ctch;
    ptchOut = ptchNew;
    ptchIn = pstm->ptchMin;
    while (ptchIn < ptchMax) {
        if (*ptchIn == tchMagic) {
            *ptchOut++ = tchMagic;
        }
        *ptchOut++ = *ptchIn++;
    }
    FreePv(pstm->ptchMin);
    pstm->ptchMin = ptchNew;
    pstm->ptchMax = ptchNew + ctch * 2;
    return (CTCH)(ptchOut - pstm->ptchMin);
}

/*****************************************************************************
 *
 *  fFillPstm
 *
 *  Refill a stream from its file, if possible.
 *
 *  Each file ends with an artificial EOF token, so that we can detect
 *  bad things like files that end with incomplete comments or quotes,
 *  and so that the last word of one file does not adjoin the first word
 *  of the next.
 *
 *****************************************************************************/

BOOL STDCALL
fFillPstm(PSTM pstm)
{
    AssertPstm(pstm);
    if (pstm->hf != hfNil) {
        CB cb;
        CTCH ctch;
        Assert(pstm->ptchMax - pstm->ptchMin >= ctchFile);
        cb = cbReadHfPvCb(pstm->hf, pstm->ptchMin, cbCtch(ctchFile));
        if (cb == cbErr) {
            Die("error reading file");
        }
        ctch = ctchCb(cb);
        if (cbCtch(ctch) != cb) {
            Die("odd number of bytes in UNICODE file");
        }
        if (ctch) {
            if (ptchFindPtchCtchTch(pstm->ptchMin, ctch, tchMagic)) {
                ctch = ctchDemagicPstmCtch(pstm, ctch);
            }
            pstm->ptchCur = pstm->ptchMax - ctch;
            MovePtchPtchCtch(g_pstmCur->ptchCur, g_pstmCur->ptchMin, ctch);
        } else {                        /* EOF reached */
            CloseHf(pstm->hf);
            pstm->hf = hfNil;
            PushPtok(&tokEof);          /* Eek!  Does this actually work? */
        }
        return 1;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  tchPeek
 *
 *  Fetch but do not consume the next character in the stream.
 *
 *****************************************************************************/

TCH STDCALL
tchPeek(void)
{
    AssertPstm(g_pstmCur);
    while (g_pstmCur->ptchCur >= g_pstmCur->ptchMax) {  /* Rarely */
        Assert(g_pstmCur->ptchCur == g_pstmCur->ptchMax);
        if (!fFillPstm(g_pstmCur)) {
            PSTM pstmNew = g_pstmCur->pstmNext;
            Assert(pstmNew != 0);
            FreePstm(g_pstmCur);        /* Closes file, etc */
            g_pstmCur = pstmNew;
        }
    }
    return *g_pstmCur->ptchCur;
}

/*****************************************************************************
 *
 *  tchGet
 *
 *  Fetch and consume the next character in the stream.
 *
 *  LATER - update line number
 *
 *****************************************************************************/

TCH STDCALL
tchGet(void)
{
    TCH tch = tchPeek();
    Assert(*g_pstmCur->ptchCur == tch);
    g_pstmCur->ptchCur++;
    return tch;
}

/*****************************************************************************
 *
 *  Pushing
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  UngetTch
 *
 *  Ungetting a character is the same as pushing it, except that it goes
 *  onto the file stream rather than onto the string stream.
 *
 *  LATER - update line number
 *
 *****************************************************************************/

void STDCALL
UngetTch(TCH tch)
{
    AssertPstm(g_pstmCur);
    Assert(g_pstmCur->ptchCur <= g_pstmCur->ptchMax);
    Assert(g_pstmCur->ptchCur > g_pstmCur->ptchMin);
    g_pstmCur->ptchCur--;
    Assert(*g_pstmCur->ptchCur == tch);
}

/*****************************************************************************
 *
 *  pstmPushStringCtch
 *
 *  Push a fresh string stream of the requested size.
 *
 *****************************************************************************/

PSTM STDCALL
pstmPushStringCtch(CTCH ctch)
{
    PSTM pstm;

    Assert(ctch);
    pstm = pvAllocCb(sizeof(STM));
    pstm->pstmNext = g_pstmCur;
    pstm->hf = hfNil;
    pstm->ptchName = 0;
    pstm->ptchMin = ptchAllocCtch(ctch);
    pstm->ptchCur = pstm->ptchMax = pstm->ptchMin + ctch;
  D(pstm->sig = sigStm);
    g_pstmCur = pstm;
    return pstm;
}

/*****************************************************************************
 *
 *  pstmPushHfPtch
 *
 *  Push a fresh file stream with the indicated name.
 *
 *****************************************************************************/

PSTM STDCALL
pstmPushHfPtch(HFILE hf, PTCH ptch)
{
    PSTM pstm = pstmPushStringCtch(ctchFile);
    pstm->hf = hf;
    pstm->ptchName = ptch;
    return pstm;
}

/*****************************************************************************
 *
 *  PushPtok
 *  PushZPtok
 *
 *  Push a token buffer onto the stream, possibly allocating a new
 *  top-of-stream if the current top-of-stream isn't big enough to
 *  handle it.
 *
 *  PushZPtok takes a dummy pdiv argument.
 *
 *  LATER - Should also alloc new tos if current tos is a file.
 *  This keeps line numbers happy.
 *
 *****************************************************************************/

void STDCALL
PushPtok(PCTOK ptok)
{
    AssertPstm(g_pstmCur);
/*    Assert(tsCur == tsNormal); */     /* Make sure tokenizer is quiet */
    if (ctchSPtok(ptok) > (CTCH)(g_pstmCur->ptchCur - g_pstmCur->ptchMin)) {
        pstmPushStringCtch(max(ctchSPtok(ptok), ctchMinPush));
    }
    g_pstmCur->ptchCur -= ctchSPtok(ptok);
    Assert(g_pstmCur->ptchCur >= g_pstmCur->ptchMin); /* Buffer underflow! */
    CopyPtchPtchCtch(g_pstmCur->ptchCur, ptchPtok(ptok), ctchSPtok(ptok));
}

void STDCALL
PushZPtok(PDIV pdiv, PCTOK ptok)
{
    PushPtok(ptok);
}

/*****************************************************************************
 *
 *  PushTch
 *
 *  Push a single character.  We do this by creating a scratch token.
 *
 *****************************************************************************/

void STDCALL
PushTch(TCH tch)
{
    TOK tok;
    SetStaticPtokPtchCtch(&tok, &tch, 1);
    PushPtok(&tok);
}

/*****************************************************************************
 *
 *  PushQuotedPtok
 *
 *  Push a token buffer onto the stream, quoted.
 *
 *****************************************************************************/

void STDCALL
PushQuotedPtok(PCTOK ptok)
{
/*    Assert(tsCur == tsNormal); */     /* Make sure tokenizer is quiet */
/* SOMEDAY -- should be ptokLquo and ptokRquo once we support changing quotes */
    PushTch(tchRquo);
    PushPtok(ptok);
    PushTch(tchLquo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\tok.h ===
/*****************************************************************************
 *
 *  tok.h
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Tokens
 *
 *  A TOK records a block of characters.
 *
 *      itch =  hold-relative offset to beginning of value (if unsnapped)
 *      ptch -> beginning of value (if snapped)
 *      ctch =  number of tchar's in value
 *
 *  A UTok is an unsnapped token.  An STok is a snapped token.
 *
 *****************************************************************************/

typedef UINT TSFL;          /* Token state flags */
#define tsflClosed      1   /* ctch can be used */
#define tsflHeap        2   /* ptch points into process heap */
#define tsflStatic      4   /* ptch points into process static data */
#define tsflScratch     8   /* token is modifiable */

typedef struct TOKEN {
  D(SIG     sig;)
  union {
    PTCH    ptch;
    ITCH    itch;
  } u;
    CTCH    ctch;
  D(TSFL    tsfl;)
} TOK, *PTOK, **PPTOK;
typedef CONST TOK *PCTOK;
typedef int IPTOK, ITOK;
typedef unsigned CTOK;

#define sigUPtok sigABCD('U', 'T', 'o', 'k')
#define sigSPtok sigABCD('S', 'T', 'o', 'k')
#define AssertUPtok(ptok) AssertPNm(ptok, UPtok)
#define AssertSPtok(ptok) AssertPNm(ptok, SPtok)

#define StrMagic(tch) { tchMagic, tch }
#define comma ,

#define DeclareStaticTok(nm, cch, str) \
    static TCH rgtch##nm[cch] = str; \
    TOK nm = { D(sigSPtok comma) rgtch##nm, cch, D(tsflClosed|tsflStatic) }

#define ctokGrow    256     /* Growth rate of token buffer */
extern PTOK rgtokArgv;      /* The token pool */

/*****************************************************************************
 *
 *  Meta-function
 *
 *  fXxPtok(ptok) defines an inline function which returns nonzero
 *  if the corresponding bit is set.  Meaningful only in DEBUG,
 *  because the information is not tracked in retail.
 *
 *****************************************************************************/

#ifdef DEBUG

#define fXxPtokX(xx) \
    INLINE F f##xx##Ptok(PCTOK ptok) { return ptok->tsfl & tsfl##xx; }
#define fXxPtok(xx) fXxPtokX(xx)

fXxPtok(Closed)
fXxPtok(Heap)
fXxPtok(Static)
fXxPtok(Scratch)

#undef fXxPtok
#undef fXxPtokX

#endif
/*****************************************************************************
 *
 *  ptchPtok
 *
 *  Returns a pointer to the first character in the ptok.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE PTCH
ptchPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    return ptok->u.ptch;
}

/*****************************************************************************
 *
 *  itchPtok
 *
 *  Returns the index of the first character in the ptok.
 *  The token must not be snapped.
 *
 *****************************************************************************/

INLINE ITCH
itchPtok(PCTOK ptok)
{
    AssertUPtok(ptok);
    return ptok->u.itch;
}

/*****************************************************************************
 *
 *  SetPtokItch
 *
 *  Set the itch for a ptok.
 *  The token must not be snapped.
 *
 *****************************************************************************/

INLINE void
SetPtokItch(PTOK ptok, ITCH itch)
{
    AssertUPtok(ptok);
    ptok->u.itch = itch;
}

/*****************************************************************************
 *
 *  SetPtokCtch
 *
 *  Set the ctch for a ptok.
 *  This closes the token.
 *
 *****************************************************************************/

INLINE void
SetPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertUPtok(ptok);
    Assert(!fClosedPtok(ptok));
    ptok->ctch = ctch;
#ifdef DEBUG
    ptok->tsfl |= tsflClosed;
#endif
}

/*****************************************************************************
 *
 *  SetPtokPtch
 *
 *  Set the ptch for a ptok.
 *  This snaps the token.
 *
 *****************************************************************************/

INLINE void
SetPtokPtch(PTOK ptok, PTCH ptch)
{
    AssertUPtok(ptok);
    ptok->u.ptch = ptch;
  D(ptok->sig = sigSPtok);
}


/*****************************************************************************
 *
 *  ctchUPtok
 *
 *  Returns the number of characters in the token.
 *  The token must not be snapped.
 *
 *****************************************************************************/

INLINE CTCH
ctchUPtok(PCTOK ptok)
{
    AssertUPtok(ptok);
    Assert(fClosedPtok(ptok));
    return ptok->ctch;
}

/*****************************************************************************
 *
 *  ctchSPtok
 *
 *  Returns the number of characters in the token.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE CTCH
ctchSPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    Assert(fClosedPtok(ptok));
    return ptok->ctch;
}

/*****************************************************************************
 *
 *  fNullPtok
 *
 *  Returns nonzero if the token is empty.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE F
fNullPtok(PCTOK ptok)
{
    return ctchSPtok(ptok) == 0;
}

/*****************************************************************************
 *
 *  ptchMaxPtok
 *
 *  Returns a pointer to one past the last character in the token.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE PTCH
ptchMaxPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    return ptchPtok(ptok) + ctchSPtok(ptok);
}

/*****************************************************************************
 *
 *  EatHeadPtokCtch
 *
 *  Delete ctch characters from the beginning of the token.
 *  A negative number regurgitates characters.
 *
 *  The token must be snapped.
 *
 *  NOTE!  This modifies the token.
 *
 *****************************************************************************/

INLINE void
EatHeadPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertSPtok(ptok);
    Assert(ctch <= ctchSPtok(ptok));
    Assert(fScratchPtok(ptok));
    ptok->u.ptch += ctch;
    ptok->ctch -= ctch;
}

/*****************************************************************************
 *
 *  EatTailPtokCtch
 *
 *  Delete ctch characters from the end of the token.
 *
 *  The token must be snapped.
 *
 *  NOTE!  This modifies the token.
 *
 *****************************************************************************/

INLINE void
EatTailPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertSPtok(ptok);
    Assert(ctch <= ctchSPtok(ptok));
    Assert(fScratchPtok(ptok));
    ptok->ctch -= ctch;
}

/*****************************************************************************
 *
 *  EatTailUPtokCtch
 *
 *  Delete ctch characters from the end of the token.
 *
 *  The token must not be snapped.
 *
 *  NOTE!  This modifies the token.
 *
 *****************************************************************************/

INLINE void
EatTailUPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertUPtok(ptok);
    Assert(ctch <= ctchUPtok(ptok));
    Assert(fScratchPtok(ptok));
    ptok->ctch -= ctch;
}

/*****************************************************************************
 *
 *  SetStaticPtokPtchCtch
 *
 *  Initialize everything for a static token.
 *
 *****************************************************************************/

INLINE void
SetStaticPtokPtchCtch(PTOK ptok, PCTCH ptch, CTCH ctch)
{
  D(ptok->sig = sigUPtok);
  D(ptok->tsfl = tsflClosed | tsflStatic);
    SetPtokPtch(ptok, (PTCH)ptch);
    ptok->ctch = ctch;
}

/*****************************************************************************
 *
 *  DupStaticPtokPtok
 *
 *      Copy a snapped token into a static one.
 *
 *****************************************************************************/

INLINE void
DupStaticPtokPtok(PTOK ptokDst, PCTOK ptokSrc)
{
    AssertSPtok(ptokSrc);
    SetStaticPtokPtchCtch(ptokDst, ptchPtok(ptokSrc), ctchSPtok(ptokSrc));
}

/*****************************************************************************
 *
 *  Token Types
 *
 *****************************************************************************/

typedef enum TYP {
    typQuo,             /* Quoted string (quotes stripped) or comment */
    typId,              /* Identifier */
    typMagic,           /* Magic */
    typPunc,            /* Punctuation */
} TYP;

/*****************************************************************************
 *
 *  token.c
 *
 *****************************************************************************/

TYP STDCALL typGetPtok(PTOK ptok);

/*****************************************************************************
 *
 *  xtoken.c
 *
 *****************************************************************************/

extern PTOK ptokTop, ptokMax;
#define itokTop() ((ITOK)(ptokTop - rgtokArgv))
extern CTOK ctokArg;
extern F g_fTrace;
TYP STDCALL typXtokPtok(PTOK ptok);

extern TOK tokTraceLpar, tokRparColonSpace, tokEol;
extern TOK tokEof, tokEoi;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\token.c ===
/*****************************************************************************
 *
 * token.c
 *
 *  Tokenization.
 *
 *  The tokenizer always returns unsnapped tokens.
 *
 *  We avoid the traditional tokenizer problems of ``giant comment'' and
 *  ``giant string'' by using a dynamic token buffer.
 *
 *  All tokens are stacked into the token buffer.  If you need the token
 *  to be persistent, you have to save it somewhere else.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  typGetComTch
 *
 *      Scan and consume a comment token, returning typQuo
 *      because comments and quotes are essentially the same thing.
 *      tch contains the open-comment.
 *
 *      Comments do not nest.
 *
 *****************************************************************************/

TYP STDCALL
typGetComTch(TCH tch)
{
    AddArgTch(tch);                     /* Save the comment start */
    do {
        tch = tchGet();
        AddArgTch(tch);
        if (tch == tchMagic) {
            /* Ooh, regurgitating a magic token - these consist of two bytes */
            tch = tchGet();
            if (tch == tchEof) {
                Die("EOF in comment");
            }
            AddArgTch(tch);
        }
    } while (!fRcomTch(tch));
    return typQuo;
}

/*****************************************************************************
 *
 *  typGetQuoTch
 *
 *      Scan and consume a quote token, returning typQuo.
 *      tch contains the open-quote.
 *
 *****************************************************************************/

TYP STDCALL
typGetQuoTch(TCH tch)
{
    int iDepth = 1;
    for (;;) {
        tch = tchGet();
        if (tch == tchMagic) {
            /* SOMEDAY -- Should unget so that Die won't see past EOF */

            /* Ooh, regurgitating a magic token - these consist of two bytes */
            tch = tchGet();
            if (tch == tchEof) {
                Die("EOF in quote");
            }
            AddArgTch(tchMagic);        /* Add the magic prefix */
                                        /* Fallthrough will add tch */
        } else if (fLquoTch(tch)) {
            ++iDepth;
        } else if (fRquoTch(tch)) {
            if (--iDepth == 0) {
                break;                  /* Final Rquo found */
            }
        }
        AddArgTch(tch);
    }
    return typQuo;
}

/*****************************************************************************
 *
 *  typGetIdentTch
 *
 *      Scan and consume an identifier token, returning typId.
 *      tch contains the first character of the identifier.
 *
 *****************************************************************************/

TYP STDCALL
typGetIdentTch(TCH tch)
{
    do {
        AddArgTch(tch);
        tch = tchGet();
    } while (fIdentTch(tch));
    UngetTch(tch);
    return typId;
}

/*****************************************************************************
 *
 *  typGetMagicTch
 *
 *      Scan and consume a magic token, returning the token type.
 *      Magics are out-of-band gizmos that get inserted into the
 *      input stream via the tchMagic escape.
 *
 *****************************************************************************/

TYP STDCALL
typGetMagicTch(TCH tch)
{
    AddArgTch(tch);
    tch = tchGet();
    Assert(fValidMagicTch(tch));
    AddArgTch(tch);
    return typMagic;
}

/*****************************************************************************
 *
 *  typGetPuncTch
 *
 *      Scan and consume a punctuation token, returning the token type.
 *
 *      It is here that comments are recognized.
 *
 *
 *  LATER - It is here where consecutive typPunc's are coalesced.
 *  This would speed up top-level scanning.
 *  Be careful not to coalesce a comma!
 *  Lparen is okay because xtok handles that one.
 *  Whitespace is also okay because xtok handles those too.
 *
 *****************************************************************************/

TYP STDCALL
typGetPuncTch(TCH tch)
{
    AddArgTch(tch);
    return typPunc;
}

/*****************************************************************************
 *
 *  typGetPtok
 *
 *      Scan and consume a snapped token, returning the token type.
 *
 *****************************************************************************/

TYP STDCALL
typGetPtok(PTOK ptok)
{
    TCH tch;
    TYP typ;

    OpenArgPtok(ptok);

    tch = tchGet();

    if (fInitialIdentTch(tch)) {
        typ = typGetIdentTch(tch);
    } else if (fLcomTch(tch)) {
        typ = typGetComTch(tch);
    } else if (fLquoTch(tch)) {
        typ = typGetQuoTch(tch);
    } else if (fMagicTch(tch)) {
        typ = typGetMagicTch(tch);
    } else {
        typ = typGetPuncTch(tch);
    }
    CloseArgPtok(ptok);
    SnapArgPtok(ptok);
    return typ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\stream.h ===
/*****************************************************************************
 *
 *  stream.h
 *
 *****************************************************************************/

/*****************************************************************************
 *
 * File handles
 *
 *****************************************************************************/

#define cbErr ((CB)-1)

/*****************************************************************************
 *
 *  Streams
 *
 *  A STREAM is something that produces characters (not tokens).
 *
 *  Streams can be (and frequently are) chained.  When a stream
 *  runs out of characters, the stream pointed to by pstmNext
 *  becomes the new source of characters.
 *
 *  For example, when you perform an `include', a new file stream
 *  is created and pushed onto the head of the stream list.  When
 *  a macro is expanded, a new string stream is created and pushed
 *  onto the head of the stream list.
 *
 *****************************************************************************/

typedef struct STREAM STM, *PSTM;
struct STREAM {                 /* stm */

  D(SIG     sig;)               /* Signature */
    PTCH    ptchCur;            /* Next byte to return from stream */
    PTCH    ptchMax;            /* One past last byte in stream */
    PTCH    ptchMin;            /* Beginning of stream buffer */
    HF      hf;                 /* File handle (or hfNil if not a file) */
    PTCH    ptchName;           /* Name of file */
    PSTM    pstmNext;           /* Next stream in the chain */

};

#define sigStm sigABCD('S', 't', 'r', 'm')
#define AssertPstm(pstm) AssertPNm(pstm, Stm)

TCH STDCALL tchPeek(void);
TCH STDCALL tchGet(void);
void STDCALL UngetTch(TCH tch);
PSTM STDCALL pstmPushStringCtch(CTCH ctch);
PSTM STDCALL pstmPushHfPtch(HFILE hf, PTCH ptch);
void STDCALL PushPtok(PCTOK ptok);
void STDCALL PushZPtok(PDIV pdiv, PCTOK ptok);
void STDCALL PushTch(TCH tch);
void STDCALL PushQuotedPtok(PCTOK ptok);

extern PSTM g_pstmCur;          /* Current head of stream chain */

#define ctchMinPush     1024    /* minimum string stream size */
#define ctchFile        4096    /* minimum file stream size */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mapmsg\mapmsg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mapmsg.c

Abstract:

    This utility will create an input file for MC from specially
    formatted include files.  This is used to create DLL's which can be
    used by the message utilities to get message text to display.

    The format of the header files is:

    :
    :
    #define <basename> <basenumber>
    :
    :
    #define <errornum> <basenumber> + <number> /* text of message */
/*
    Example:

    #define NETBASE 1000
    #define NerrFOO NETBASE+1 /* A FOO has been encountered at %1 * /
/*
    The mapping tries to be generous about whitespace and parenthesis.
    It will also handle comments across several lines. Some important points:
         - all continuations must begin with [WS]'*'
           any whitespace at the beginning of a message is removed
           unless the -p command line option is specified.
         - #define .....
                 /*
                  * FOO
                  */
/*         is handled correctly.

    The command line to MAPMSG is:

           mapmsg [-p] [-a appendfile] <system name> <basename> <inputfile>

    Example:

           mapmsg NET NERRBASE neterr.h > neterr.mc

    The <system name> is the 3 character name required by the mkmsg
    input. The output is written to stdout. If the append file
    is given, the output is appropriately appended to an existing
    mkmsgf source file.

    An optional @X, X: {E, W, I, P} can be the 1st non-WS chars of the
    comment field.  The letter (E, W, I, or P) will be the message type.
    See MKMSGF documentation for an explaination of the message types.
    The default type is E.

    The @X must appear on the same line as the #define.

    Examples:

    #define NerrFOO NETBASE+1 /* @I A FOO has been encountered * /
/*
    #define NERR_Foo NETBASE + 2    /* @P
    The prompt text: %0 */
/*
    The resulting entry in the message file input file will be

    NETnnnnI: A FOO has been encountered

    Use the DOS message file source convention of XXXnnnn?:  for
    placeholder messages.

    Author:

    This was ported from the Lanman utility that was used to create input
    files for mkmsgf by:

    Dan Hinsley (danhi)    29-Jul-1991

Revision History:

    Ronald Meijer (ronaldm) 17-Mar-1993
        Added -p option to preserve leading white space characters

--*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include "mapmsg.h"

#define USAGE "syntax: mapmsg [-p] [-a appendfile] <system name> <basename> <inputfile>\n"

int Append = FALSE; /* was the -a switch specified */
int Preserve = FALSE; /* TRUE if the -p switch is set */

int
__cdecl main(
    int argc,
    PCHAR * argv
    )
{
    int Base;

    // Check for -p[reserve whitespace] option

    if (argc > 1)
    {
        if (_stricmp(argv[1], "-p") == 0)
        {
            ++argv;
            --argc;
            Preserve = TRUE;
        }
    }

    if (argc == 6)
    {
        if (_stricmp(argv[1], "-a") != 0)
        {
            fprintf(stderr, USAGE);
            return(1);
        }
        if (freopen(argv[2], "r+", stdout) == NULL)
        {
            fprintf(stderr, "Cannot open '%s'\n", argv[2]);
            return(1);
        }
        argv += 2;
        argc -= 2;
        Append = TRUE;
    }
    /* check for valid command line */
    if (argc != 4)
    {
        fprintf(stderr, USAGE);
        return(1);
    }
    if (freopen(argv[3], "r", stdin) == NULL)
    {
        fprintf(stderr, "Cannot open '%s'\n", argv[3]);
        return(1);
    }

    if (GetBase(argv[2], &Base))
    {
        fprintf(stderr, "Cannot locate definition of <basename> in '%s'\n", argv[3]);
        return(1);
    }

    /* now process the rest of the file and map it */
    MapMessage(Base, argv[2]);

    return(0);
}

int
GetBase(
    PCHAR String,
    int * pBase
    )
/*++

Routine Description:

GetBase - find the line defining the value of the base number.

Arguments:

  String is the string to match.
  pBase  is a pointer of where to put the value.

Return Value:

  Return 0 if string found, 1 if not.

Notes:

  The global variable, chBuff is used w/in this routine.

  The pattern to look for is:
      [WS] #define [WS] <string> [WS | '('] <number> .....

--*/
{
    PCHAR p;
    size_t len;

    len = strlen(String);
    while(gets(chBuff))
    {
        p = chBuff;
        SKIPWHITE(p);
        if (strncmp(p, "#define", 7) == 0)
        {
            p += 7;
            SKIPWHITE(p);
            if (strncmp(String, p, len) == 0 && strcspn(p, " \t") == len)
            {
               /* found the definition ... skip to number */
               p += len;
               SKIP_W_P(p);
               if ( !isdigit(*p))
               {
                   ReportError(chBuff, "Bad <base> definition");
               }
               *pBase = atoi(p);
               return(0);
            }
        }
    }

    return(1);
}

VOID
MapMessage(
    int Base,
    PCHAR BaseName
    )
/*++

Routine Description:

 MapMessage - map the definition lines.

Arguments:

  Base     is the base number
  BaseName is the text form of base

Return Value:

  None

Notes:

  The global variable, chBuff is used w/in this routine.

  Make sure that the numbers are strictly increasing.

--*/
{
    CHAR auxbuff[BUFSIZ];
    int num;
    int first = TRUE;
    int next;
    PCHAR text;
    CHAR define[41];
    PCHAR p;
    CHAR type;

    /* Make certain the buffer is always null-terminated */

    define[sizeof(define)-1] = '\0';

    /* print the header */
    if (!Append)
    {
        printf(";//\n");
        printf(";// Net error file for basename %s = %d\n", BaseName, Base);
        printf(";//\n");
    }
    else
    {
        /* get last number and position to end of file */
        first = FALSE;
        next = 0;
        if (fseek(stdout, 0L, SEEK_END) == -1) {
            return;
        }
    }

    /* for each line of the proper format */
    while (GetNextLine(BaseName, chBuff, define, &num, &text, &type))
    {
        num += Base;
        if (first)
        {
            first = FALSE;
            next = num;
        }

        /* make sure that the numbers are monotonically increasing */
        if (num > next)
        {
            if (next == num - 1)
            {
                fprintf(stderr, "(warning) Missing error number %d\n", next);
            }
            else
            {
                fprintf(stderr, "(warning) Missing error numbers %d - %d\n",
                                                    next, num-1);
            }
            next = num;
        }
        else if (num < next)
        {
            ReportError(chBuff, "Error numbers not strictly increasing");
        }
        /* rule out comment start alone on def line */
        if (text && *text == 0)
        {
            ReportError(chBuff, "Bad comment format");
        }
        /*
         * catch the cases where there is no open comment
         * or the open comment just contains a @X
         */
        if (text == NULL)
        {
            text = gets(auxbuff);
            SKIPWHITE(text);
            if ((type == '\0') && (strncmp(text, "/*", 2) == 0))
            {
                if (text[2] == 0)
                {
                    gets(auxbuff);
                }
                else
                {
                    text += 1;
                }
                strcpy(chBuff, text);
                text = chBuff;
                SKIPWHITE(text);
                if (*text++ != '*')
                {
                    ReportError(chBuff, "Comment continuation requires '*'");
                }
            }
            else if ((type) && (*text == '*'))
            {
                if (text[1] == 0)
                {
                    gets(auxbuff);
                }
                strcpy(chBuff, text);
                text = chBuff;
                SKIPWHITE(text);
                if (*text++ != '*')
                {
                    ReportError(chBuff, "Comment continuation requires '*'");
                }
            }
            else
            {
                ReportError(chBuff, "Bad comment format");
            }
        }

        /* Strip off trailing trailing close comment */
        while (strstr(text, "*/") == NULL)
        {
            /* multi-line message ... comment MUST
             * be continued with '*'
             */
            p = gets(auxbuff);
            SKIPWHITE(p);
            if (*p != '*')
            {
                ReportError(auxbuff, "Comment continuation requires '*'");
            }
            if (*++p == '/')
            {
                break;
            }
            // abort if the current text length + add text + "\n" is > the max
            if (strlen(text) + strlen(p) + 1 > MAXMSGTEXTLEN)
            {
                ReportError(text, "\nMessage text length too long");
            }

            strcat(text, "\n");

            //
            // Get rid of leading spaces on continuation line,
            // unless -p specified
            //

            if (!Preserve)
            {
                SKIPWHITE(p);
            }
            strcat(text, p);
        }
        if ((p=strstr(text, "*/")) != NULL)
        {
            *p = 0;
        }
        TrimTrailingSpaces(text);

        //
        // Get rid of leading spaces on first line, unless -p specified
        //

        p = text;

        if (!Preserve) {
            SKIPWHITE(p);
            if (!p) {
                p = text;
            }
        }
        printf("MessageId=%04d SymbolicName=%s\nLanguage=English\n"
            "%s\n.\n", num, define, p);
        ++next;
    }
}

int
GetNextLine(
    PCHAR BaseName,
    PCHAR pInputBuffer,
    PCHAR pDefineName,
    int * pNumber,
    PCHAR * pText,
    PCHAR pType
    )
/*++

Routine Description:

  GetNextLine - get the next line of the proper format, and parse out
             the error number.

  The format is assumed to be:

      [WS] #define [WS] <name> [WS | '('] <basename> [WS | ')'] \
          '+' [WS | '('] <number> [WS | ')'] '/*' [WS] [@X] [WS] <text>


Arguments:

  BaseName     is the basename.
  pInputBuffer is a pointer to an input buffer
  pDefineName  is a pointer to where the manifest constant name pointer goes
  pNumber      is a pointer to where the <number> goes.
  pText        is a pointer to where the text pointer goes.
  pType        is a pointer to the message type (set to 0 if no @X on line).

Return Value:

  Returns 0 at end of file, non-zero otherwise.

--*/
{
    size_t len = strlen(BaseName);
    PCHAR savep = pInputBuffer;
    PCHAR startdefine;

    while (gets(savep))
    {
        pInputBuffer = savep;
        SKIPWHITE(pInputBuffer);
        if (strncmp(pInputBuffer, "#define", 7) == 0)
        {
            pInputBuffer += 7;
            SKIPWHITE(pInputBuffer);

            /* get manifest constant name */
            startdefine = pInputBuffer;
            pInputBuffer  += strcspn(pInputBuffer, " \t");
            *pInputBuffer = '\0';
            pInputBuffer++;
            strncpy(pDefineName, startdefine, 40);

            SKIP_W_P(pInputBuffer);
            /* match <basename?> */
            if (strncmp(BaseName, pInputBuffer, len) == 0 &&
                strcspn(pInputBuffer, " \t)+") == len)
            {
                pInputBuffer += len;
                SKIP_W_P(pInputBuffer);
                if (*pInputBuffer == '+')
                {
                    ++pInputBuffer;
                    SKIP_W_P(pInputBuffer);
                    /* the number !! */
                    if (!isdigit(*pInputBuffer))
                    {
                        ReportError(savep, "Bad error file format");
                    }
                    *pNumber = atoi(pInputBuffer);
                    SKIP_NOT_W_P(pInputBuffer);
                    SKIP_W_P(pInputBuffer);
                    if (strncmp(pInputBuffer, "/*", 2))
                    {
                        *pText = NULL;
                        *pType = '\0';
                        return(1);
                    }

                    pInputBuffer += 2;
                    SKIPWHITE(pInputBuffer);
                    if (*pInputBuffer == '@')
                    {
                        *pType = *(pInputBuffer+1);
                        pInputBuffer += 2;
                        SKIPWHITE(pInputBuffer);
                    }
                    else
                    {
                        *pType = '\0';
                    }
                    if (*pInputBuffer)
                    {
                        *pText = pInputBuffer;
                    }
                    else
                    {
                        *pText = NULL;
                    }

                    return(1);
                }
            }
        }
    }

    return(0);
}

void
ReportError(
    PCHAR pLineNumber,
    PCHAR Message
    )
/*++

Routine Description:

 ReportError - report a fatal error.

Arguments:

  pLineNumber is the offending input line.
  Message     is a description of what is wrong.

Return Value:

  None

--*/
{
    fprintf(stderr, "\a%s:%s\n", Message, pLineNumber);
    exit(1);
}

void
TrimTrailingSpaces(
    PCHAR Text
    )
/*++

Routine Description:

 TrimTrailingSpaces - strip off the end spaces.

Arguments:

 Text - the text to remove spaces from

Return Value:

 None

--*/
{
    PCHAR p;

    /* strip off trailing space */
    while (((p=strrchr(Text, ' ')) && p[1] == 0) ||
            ((p=strrchr(Text, '\t')) && p[1] == 0))
    {
        *p = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mapmsg\mapmsg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mapmsg.h

Abstract:

    This module contains defines and function prototypes for the mapmsg utility

Author:

    Dan Hinsley (danhi) 29-Jul-1991

Revision History:

--*/
#define TRUE 1
#define FALSE 0

#define MAXMSGTEXTLEN 2048           // maximum message text length

CHAR chBuff[MAXMSGTEXTLEN + 1];      // buffer storing msg text

/* skip past white space */
#define SKIPWHITE(s) s+=strspn(s, " \t");

/* skip up to white space */
#define SKIP_NOT_WHITE(s) s+=strcspn(s, " \t");

/* skip past white space and parenthesis */
#define SKIP_W_P(s) s+=strspn(s, " \t()");

/* skip up to white space and parenthesis */
#define SKIP_NOT_W_P(s) s+=strcspn(s, " \t()");

/* internal function prototypes */
int __cdecl main(int, PCHAR *);
int GetBase(PCHAR, int *);
VOID MapMessage(int, PCHAR);
VOID ReportError(PCHAR, PCHAR);
int GetNextLine(PCHAR, PCHAR, PCHAR, int *, PCHAR *, PCHAR);
VOID TrimTrailingSpaces(PCHAR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\string.c ===
/*****************************************************************************
 *
 * string.c
 *
 *  String builtin macros.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  opSubstr
 *
 *      Return the substring of $1 starting from $2 and continuing for
 *      $3 characters.  If $3 is not supplied, then return the entire
 *      remainder of the string.
 *
 *      If $2 is out of range, then nothing is returned.
 *
 *      If $3 is a negative number, then treat it as zero.
 *
 *      The extra ptokNil covers us in the case where $# is 1.
 *
 *****************************************************************************/

DeclareOp(opSubstr)
{
    if (ctokArgv) {
        TOK tok;
        ITCH itch = (ITCH)atTraditionalPtok(ptokArgv(2));
        if (itch < ctchSPtok(ptokArgv(1))) {
            CTCH ctch;
            if (ctokArgv >= 3) {
                ctch = atTraditionalPtok(ptokArgv(3));
                if ((int)ctch < 0) {
                    ctch = 0;
                }
            } else {
                ctch = ctchMax;
            }
            ctch = min(ctch, ctchSPtok(ptokArgv(1)) - itch);
            Assert(itch + ctch <= ctchSPtok(ptokArgv(1)));
            SetStaticPtokPtchCtch(&tok, ptchPtok(ptokArgv(1)) + itch, ctch);
            PushPtok(&tok);
        }
    } else {
#ifdef STRICT_M4
        Warn("wrong number of arguments to %P", ptokArgv(0));
#endif
    }
}

/*****************************************************************************
 *
 *  opIndex
 *
 *      Return the zero-based location of the first occurrence of $2 in $1,
 *      or -1 if the substring does not appear.  If there are multiple
 *      matches, the leftmost one is returned.
 *
 *      The extra ptokNil covers us in the case where $# is 1.
 *
 *      QUIRK!  AT&T returns -1 if $1 and $2 are both null strings.
 *      GNU returns 0, which is what I do also.
 *
 *****************************************************************************/

/* SOMEDAY! -- need minimum and maximum arg count */

DeclareOp(opIndex)
{
    if (ctokArgv) {
        /*
         *  Note carefully: itch and itchMac need to be ints
         *  because itchMac can underflow if you try to search
         *  for a big string inside a small string.
         */
        int itch;
        int itchMac = ctchSPtok(ptokArgv(1)) - ctchSPtok(ptokArgv(2));
        for (itch = 0; itch <= itchMac; itch++) {
            if (fEqPtchPtchCtch(ptchPtok(ptokArgv(1)) + itch,
                                ptchPtok(ptokArgv(2)),
                                ctchSPtok(ptokArgv(2)))) {
                PushAt(itch);
                return;
            }
        }
        PushAt(-1);
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opTranslit
 *
 *      For each character in the $1, look for a match in $2.  If found,
 *      produce the corresponding character from $3.  If there is no
 *      such character, then produce nothing.
 *
 *      Note that the algorithm must be as specified, in order for
 *
 *              translit(abc,ab,ba)
 *
 *      to result in `bac'.
 *
 *      We actually walk $1 backwards so we can push directly instead
 *      of having to build a temporary token.  But the walking of $2
 *      must be in the forward direction, so that `translit(a,aa,bc)'
 *      results in `b' and not `c'.
 *
 *      ptokNil saves us in the case where $# = 1.
 *
 *      QUIRK!  If given only one argument, AT&T emits $1 unchanged.
 *      GNU emits nothing!  AT&T is obviously correct, so I side
 *      with them on this one.
 *
 *****************************************************************************/

DeclareOp(opTranslit)
{
    if (ctokArgv) {
        ITCH itch = ctchArgv(1);
        while ((int)--itch >= 0) {
            TCH tch = ptchArgv(1)[itch];
            ITCH itch;
            for (itch = 0; itch < ctchArgv(2); itch++) {
                if (ptchArgv(2)[itch] == tch) {
                    if (itch < ctchArgv(3)) {
                        PushTch(ptchArgv(3)[itch]);
                    }
                    break;
                }
            }
            if (itch >= ctchArgv(2)) {
                PushTch(tch);
            }
        }
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opPatsubst
 *
 *      Scan $1 for any occurrences of $2.  If found, replace them with $3.
 *      If $3 is omitted, then the string is deleted.
 *
 *      As a special case, if $2 is the null string, then $3 is inserted
 *      at the beginning of the string and between each character of $1.
 *
 *      NOTE!  This is a GNU extension.
 *
 *      NOTE!  GNU supports regular expressions for $2.  We support only
 *      literal strings.
 *
 *      NOTE!  Scanning is required to be forwards, so we temporarily expand
 *      into the Exp hold, then pop it off when we're done.
 *
 *      QUIRK!  If given only one argument, GNU emits nothing!
 *      This is clearly wrong, so I emit $1.
 *
 *****************************************************************************/

DeclareOp(opPatsubst)
{
    if (ctokArgv) {
        CTCH ctchSrc = ctchArgv(1);
        PTCH ptchSrc = ptchArgv(1);

        CTCH ctchPat = ctchArgv(2); /* ptokNil saves us here */
        PTCH ptchPat = ptchArgv(2);

        TOK tok;
        OpenExpPtok(&tok);

        while (ctchSrc >= ctchPat) {
            if (fEqPtchPtchCtch(ptchPat, ptchSrc, ctchPat)) {
                if (ctokArgv >= 3) {
                    AddExpPtok(ptokArgv(3));
                }
                if (ctchSrc == 0) {
                    AddExpTch(*ptchSrc);
                    ctchSrc--;
                    ptchSrc++;
                } else {
                    ctchSrc -= ctchPat;
                    ptchSrc += ctchPat;
                }
            } else {
                AddExpTch(*ptchSrc);
                ctchSrc--;
                ptchSrc++;
            }
        }

        /* Flush out what's left of the string */
        while (ctchSrc) {
            AddExpTch(*ptchSrc);
            ctchSrc--;
            ptchSrc++;
        }

        CsopExpDopPdivPtok((DIVOP)PushZPtok, 0, &tok);

    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\m4\xtoken.c ===
/*****************************************************************************
 *
 * xtoken.c
 *
 *  Expanding tokens via macro expansion.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  ptokGet
 *
 *  Allocate the next available token in the argv array, possibly realloc'ing
 *  the array as well.
 *
 *****************************************************************************/

PTOK STDCALL
ptokGet(void)
{
    if (ptokTop >= ptokMax) {
        ITOK itok = itokTop();
        PTOK ptok;
        ctokArg += ctokGrow;
        ptok = pvReallocPvCb(rgtokArgv, ctokArg * sizeof(TOK));
        ptokTop = ptok + itok;
        ptokMax = ptok + ctokArg;
        rgtokArgv = ptok;
        Assert(ptokTop < ptokMax);
    }
#ifdef DEBUG
    ptokTop->tsfl = 0;
  D(ptokTop->sig = sigUPtok);
#endif
    return ptokTop++;
}

/*****************************************************************************
 *
 *  PopPtok
 *
 *  Free all the tokens in the token array starting at ptok.
 *
 *****************************************************************************/

void STDCALL
PopPtok(PTOK ptok)
{
    Assert(ptok >= rgtokArgv && ptok < ptokTop);
    ptokTop = ptok;
}

/*****************************************************************************
 *
 *  CrackleArgv
 *
 *  All the arguments to a macro have been parsed, collected, and snapped.
 *  All that's left to do is dispatch it.
 *
 *  If the macro has no value, it got undefined behind our back.
 *  Emit the macro name with any possible arguments, quoted.
 *  In other words, pretend its expansion is ``$0ifelse($#,0,,($*))''.
 *
 *  If the macro value is precisely a magic, then do the magic.
 *
 *  Otherwise, perform substitution into the macro value.
 *
 *****************************************************************************/

void STDCALL
CrackleArgv(ARGV argv)
{
    PMAC pmac = pmacFindPtok(ptokArgv(0));
    if (pmac) {                         /* Found a real macro */

        if (g_fTrace | pmac->pval->fTrace) { /* Not a typo */
            TraceArgv(argv);
        }

        if (ctchSPtok(&pmac->pval->tok) == 2 &&
            ptchPtok(&pmac->pval->tok)[0] == tchMagic) { /* Builtin */
            Assert(fValidMagicTch(ptchPtok(&pmac->pval->tok)[1]));
            rgop[ptchPtok(&pmac->pval->tok)[1]](argv);
        } else {                        /* User-level macro */
            PushSubstPtokArgv(&pmac->pval->tok, argv);
        }
    } else {                            /* Macro vanished behind our back */
        /* SOMEDAY -- DefCracklePtok */ /* not even quoted! */
        PushPtok(ptokArgv(0));          /* Just dump its name */
    }
}

/*****************************************************************************
 *
 *  argvParsePtok
 *
 *  Parse a macro and its arguments, leaving everything unsnapped.
 *
 *  Entry:
 *
 *      ptok -> token that names the macro
 *
 *  Returns:
 *      argv = argument vector cookie
 *
 *****************************************************************************/

ARGV STDCALL
argvParsePtok(PTOK ptok)
{
    ITOK itok;
    ARGV argv;

    ptokGet();                          /* ctok */
    itok = itokTop();                   /* Unsnap it in case it grows */
    *ptokGet() = *ptok;                 /* $0 */

    if (tchPeek() == tchLpar) {
        TOK tok;

        tchGet();                       /* Eat the lparen */

        do {                            /* Collect arguments */
            int iDepth;
            /*
             *  Eat leading whitespace.  Note that this is *not*
             *  via expansion.  Only literal leading whitespace
             *  is eaten.
             */
#ifdef fWhiteTch
#error fWhiteTch cannot be a macro
#endif
            while (fWhiteTch(tchPeek())) {
                tchGet();
            }

            /*
             *  If the argv buffer moves, ptokTop will move with it,
             *  so it's safe to read directly into it.
             */

            OpenArgPtok(ptokGet());
          D(ptokTop[-1].tsfl |= tsflScratch);

            /*
             * The loop is complicated by the need to maintain
             * proper parenthesis nesting during argument collection.
             */
            iDepth = 0;
            for (;;) {
                TYP typ = typXtokPtok(&tok);
                /* SOMEDAY -- Assert the hold buffer and stuff */
                if (typ == typPunc) {
                    if (ptchPtok(&tok)[0] == tchLpar) {
                        ++iDepth;
                    } else if (ptchPtok(&tok)[0] == tchRpar) {
                        if (--iDepth < 0) {
                            break;      /* End of argument */
                        }
                    } else if (ptchPtok(&tok)[0] == tchComma && iDepth == 0) {
                        break;          /* End of argument */
                    }
                }
                DesnapArg();
            }
            DesnapArg();
            CloseArgPtok(ptokTop-1);    /* $n */
            EatTailUPtokCtch(ptokTop-1, 1); /* That comma doesn't count */

        } while (ptchPtok(&tok)[0] == tchComma);

    }

    argv = rgtokArgv + itok;            /* Hooray, we have an argv! */
    SetArgvCtok(itokTop() - itok - 1);  /* $# (ctokArgv uses argv) */

    OpenArgPtok(ptokGet());             /* Create extra null arg */
    CloseArgPtok(ptokTop-1);            /* SOMEDAY - could be better */

    return argv;
}


/*****************************************************************************
 *
 *  XmacPtok
 *
 *  Parse and expand a macro, pushing the expansion back onto
 *  the input stream.
 *
 *  Entry:
 *
 *      ptok -> token that names the macro
 *
 *  Exit:
 *      None
 *
 *****************************************************************************/

void STDCALL
XmacPtok(PTOK ptok)
{
    ITOK itok;
    ARGV argv;

    UnsnapArgPtok(ptok);                /* Unsnap it because it's gonna move */

    argv = argvParsePtok(ptok);         /* Argv is not yet snapped */

    for (itok = 0; itok <= ctokArgv + 1; itok++) { /* $0 to $(n+1) */
        SnapArgPtok(ptokArgv(itok));    /* Snap the args */
    }

    CrackleArgv(argv);                  /* Dispatch the macro */

    PopArgPtok(ptokArgv(0));
    PopPtok(ptokArgv(-1));              /* Pop off the args */

    /* Part of this nutritious breakfast */
}


/*****************************************************************************
 *
 *  XtokPtok
 *
 *  Read and expand tokens until something unexpandable comes back,
 *  which is returned unsnapped.
 *
 *****************************************************************************/

TYP STDCALL
typXtokPtok(PTOK ptok)
{
    TYP typ;
    /*
     *  While the next token is a macro, expand it.
     */
    while ( (typ = typGetPtok(ptok)) == typId && pmacFindPtok(ptok)) {
        Gc();
        XmacPtok(ptok);
        Gc();
    }
    return typ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mapsym\mapsym.h ===
//  MAPSYM.H
//
//      MAPSYM.EXE header file
//
//  History is too long and ancient to recount!

#include <pshpack1.h>           // All structures byte padded

#define MAPSYM_VERSION		  6     // Version 6.0 is ported to console
#define MAPSYM_RELEASE            2
#define FIELDOFFSET(type, field)  offsetof(type,field)
#define CBOFFSET		  sizeof(unsigned short)  /* sym offset size */
#define CBOFFSET_BIG		  3			  /* big sym offset */

/*
 * Debug Symbol Table Structures (as written to a .sym file)
 * ---------------------------------------------------------
 *
 * For each symbol table (map): (MAPDEF)
 */

struct mapdef_s {
    unsigned short md_spmap;	  /* 16 bit SEG ptr to next map (0 if end) */
    unsigned char  md_abstype;	  /*  8 bit map/abs sym flags */
    unsigned char  md_pad;	  /*  8 bit pad */
    unsigned short md_segentry;	  /* 16 bit entry point segment value */
    unsigned short md_cabs;	  /* 16 bit count of constants in map */
    unsigned short md_pabsoff;	  /* 16 bit ptr to constant offsets */
    unsigned short md_cseg;	  /* 16 bit count of segments in map */
    unsigned short md_spseg;	  /* 16 bit SEG ptr to segment chain */
    unsigned char  md_cbnamemax;  /*  8 bit maximum symbol name length */
    unsigned char  md_cbname;	  /*  8 bit symbol table name length */
    unsigned char  md_achname[1]; /* <n> name of symbol table (.sym ) */
};

#define CBMAPDEF	FIELDOFFSET(struct mapdef_s, md_achname)

struct endmap_s {
    unsigned short em_spmap;	/* end of map chain (SEG ptr 0) */
    unsigned char  em_rel;	/* release */
    unsigned char  em_ver;	/* version */
};
#define CBENDMAP	sizeof(struct endmap_s)


/*
 * For each segment/group within a symbol table: (SEGDEF)
 */

struct segdef_s {
    unsigned short gd_spsegnext;  /* 16 bit SEG ptr to next segdef (0 if end),
				     relative to mapdef */
    unsigned short gd_csym;	  /* 16 bit count of symbols in sym list */
    unsigned short gd_psymoff;	  /* 16 bit ptr to symbol offsets array,
				     16 bit SEG ptr if MSF_BIG_GROUP set,
				     either relative to segdef */
    unsigned short gd_lsa;	  /* 16 bit Load Segment address */
    unsigned short gd_in0;	  /* 16 bit instance 0 physical address */
    unsigned short gd_in1;	  /* 16 bit instance 1 physical address */
    unsigned short gd_in2;	  /* 16 bit instance 2 physical address */
    unsigned char  gd_type;	  /* 16 or 32 bit symbols in group */
    unsigned char  gd_pad;	  /* pad byte to fill space for gd_in3 */
    unsigned short gd_spline;	  /* 16 bit SEG ptr to linedef,
				     relative to mapdef */
    unsigned char  gd_fload;	  /*  8 bit boolean 0 if seg not loaded */
    unsigned char  gd_curin;	  /*  8 bit current instance */
    unsigned char  gd_cbname;	  /*  8 bit Segment name length */
    unsigned char  gd_achname[1]; /* <n>  name of segment or group */
};

/* values for md_abstype, gd_type */

#define MSF_32BITSYMS	0x01	/* 32-bit symbols */
#define MSF_ALPHASYMS	0x02	/* symbols sorted alphabetically, too */

/* values for gd_type only */

#define MSF_BIGSYMDEF	0x04	/* bigger than 64K of symdefs */

/* values for md_abstype only */

#define MSF_ALIGN32	0x10	/* 2MEG max symbol file, 32 byte alignment */
#define MSF_ALIGN64	0x20	/* 4MEG max symbol file, 64 byte alignment */
#define MSF_ALIGN128	0x30	/* 8MEG max symbol file, 128 byte alignment */
#define MSF_ALIGN_MASK	0x30

#define CBSEGDEF	FIELDOFFSET(struct segdef_s, gd_achname)


/*
 *  Followed by a list of SYMDEF's..
 *  for each symbol within a segment/group: (SYMDEF)
 */

struct symdef16_s {
    unsigned short sd16_val;	    /* 16 bit symbol addr or const */
    unsigned char  sd16_cbname;     /*  8 bit symbol name length */
    unsigned char  sd16_achname[1]; /* <n> symbol name */
};
#define CBSYMDEF16	FIELDOFFSET(struct symdef16_s, sd16_achname)

struct symdef_s {
    unsigned long sd_lval;	 /* 32 bit symbol addr or const */
    unsigned char sd_cbname;	 /*  8 bit symbol name length */
    unsigned char sd_achname[1]; /* <n> symbol name */
};
#define CBSYMDEF	FIELDOFFSET(struct symdef_s, sd_achname)

/*
 * Also followed by a list of LINDEF's..
 */

struct linedef_s {
    unsigned short ld_splinenext; /* 16 bit SEG ptr to next (0 if last),
				     relative to mapdef */
    unsigned short ld_pseg;	  /* 16 bit ptr to segdef_s (always 0) */
    unsigned short ld_plinerec;	  /* 16 bit ptr to linerecs,
				     relative to linedef */
    unsigned short ld_itype;	  /* line rec type 0, 1, or 2 */
    unsigned short ld_cline;	  /* 16 bit count of line numbers */
    unsigned char  ld_cbname;	  /*  8 bit file name length */
    unsigned char  ld_achname[1]; /* <n> file name */
};
#define CBLINEDEF	FIELDOFFSET(struct linedef_s, ld_achname)

/* Normal line record (ld_itype == 0) */

struct linerec0_s {
    unsigned short lr0_codeoffset; /* start offset for this linenumber */
    unsigned long  lr0_fileoffset; /* file offset for this linenumber */
};

/* Special line record - 16 bit (ld_itype == 1) */

struct linerec1_s {
    unsigned short lr1_codeoffset; /* start offset for this linenumber */
    unsigned short lr1_linenumber; /* linenumber */
};

/* Special line record - 32 bit (ld_itype == 2) */

struct linerec2_s {
    unsigned long lr2_codeoffset;  /* start offset for this linenumber */
    unsigned short lr2_linenumber; /* linenumber */
};

/* NOTE: the codeoffset should be the first item in all the linerecs */

/* Union of line record types */

union linerec_u {
	struct linerec0_s lr0;
	struct linerec1_s lr1;
	struct linerec2_s lr2;
};

#define FALSE   0
#define TRUE    1

#define MAXSEG		1024
#define MAXLINENUMBER	100000
#define MAXNAMELEN	32
#define MAXSYMNAMELEN   127         /* sd_cbname is a char */
#define MAXLINERECNAMELEN 255       /* ld_cbname is a char */
#define MAPBUFLEN	512

#define LPAREN		'('
#define RPAREN		')'

#define _64K	0x10000L
#define _1MEG	0x100000L
#define _16MEG	0x1000000L

/*
 * Debug Symbol Table Structures (as stored in memory)
 */

struct sym_s {
    struct sym_s    *sy_psynext; /* ptr to next sym_s record */
    struct symdef_s  sy_symdef;	 /* symbol record */
};

struct line_s {
    struct line_s    *li_plinext; /* ptr to line number list */
    union linerec_u  *li_plru;	  /* pointer to line number offsets */
    unsigned long     li_cblines; /* size of this linedef and it's linerecs */
    unsigned long     li_offmin;  /* smallest offset */
    unsigned long     li_offmax;  /* largest offset */
    struct linedef_s  li_linedef; /* to line number record */
};

struct seg_s {
    unsigned short  se_redefined;  /* non0 if we have renamed this segment */
				   /*	  to a group name */
    struct sym_s   *se_psy;	   /* ptr to sym_s record chain */
    struct sym_s   *se_psylast;	   /* ptr to last sym_s record in chain */
    struct line_s  *se_pli;	   /* ptr to line number list */
    unsigned short  se_cbsymlong;  /* sizeof of long names ( > 8 bytes) COFF */
    unsigned long   se_cbsyms;	   /* size of symdef records */
    unsigned long   se_cblines;    /* size of all linedefs and linerecs */
    unsigned long   se_cbseg;	   /* size of segment */
    struct segdef_s se_segdef;	   /* segdef record */
};

struct map_s {
    unsigned short  mp_cbsymlong;  /* size of long names ( > 8 bytes) COFF */
    unsigned short  mp_cbsyms;	   /* size of abs symdef records */
    struct mapdef_s mp_mapdef;	   /* mapdef record */
};

#define OURBUFSIZ	1024

#define MT_NOEXE	0x0000	/* maptype values */
#define MT_PE		0x0001
#define MT_OLDPE	0x0002
#define MT_SYMS		0x0080	/* coff symbols present */
#define MT_CVSYMS	0x0040	/* CodeView symbols present */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asm86.h ===
/* asm86.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#include "asmconf.h"
#include "asmdebug.h"
#include <setjmp.h>


#ifdef MSDOS
# define PSEP           '\\'
# define ALTPSEP        '/'
# define BINOPEN        (O_CREAT | O_TRUNC | O_WRONLY | O_BINARY)
# define BINSTDIO       "b"
# define TEXTREAD       (O_RDONLY | O_BINARY)
# define OBJ_EXT        ".obj"
# define NLINE          "\r\n"
#else
# define PSEP           '/'
# define ALTPSEP        '\\'
# define BINOPEN       (O_CREAT | O_TRUNC | O_WRONLY)
# define BINSTDIO
# define TEXTREAD      O_RDONLY
# define OBJ_EXT       ".o"
# define NLINE         "\n"
#endif /* MSDOS */

# ifdef MSDOS
#  define DEF_OBJBUFSIZ 8
#  define DEF_INCBUFSIZ 2
#  define DEF_SRCBUFSIZ 8
# else
#  define DEF_OBJBUFSIZ 1
#  define DEF_INCBUFSIZ 1
#  define DEF_SRCBUFSIZ 1
# endif /* MSDOS */

# define DEF_LISTWIDTH  79

#ifdef XENIX286
# define DEF_LISTCON    TRUE
#else
# define DEF_LISTCON    FALSE
#endif /* XENIX286 */


#define DEF_CREFING     FALSE
#define DEF_DEBUG       FALSE
#define DEF_DUMPSYM     TRUE
#define DEF_LSTING      FALSE
#define DEF_OBJING      TRUE
#define DEF_ORIGCON     FALSE
#define DEF_SEGA        FALSE
#define DEF_VERBOSE     FALSE

#define SYMMAX          63
#define ELSEMAX         20
#define INCLUDEMAX      10
#define PROCMAX         20
#define NUMLIN          58
#define EMITBUFSIZE     1023
#define EMITBUFMAX      1022

#define highWord(l)     (*((USHORT *)&l+1))
#define LST_EXT         ".lst"

#undef NULL
#define NULL            0
#define FALSE           0
#define TRUE            1

#define MAXCHR          27
#define LINEMAX         200
#define LBUFMAX         512
#define LISTMAX         32
#define TITLEWIDTH      61
#define LSTDATA         7
#define LSTMAX          25
#define ESSEG           0
#define CSSEG           1
#define SSSEG           2
#define DSSEG           3
#define FSSEG           4
#define GSSEG           5
#define NOSEG           6

#define FH_CLOSED       -1          /* Used to mark a file temporarily closed */

/* scanatom positioning options */

#define SCEND   0       /* position at end of token                     */
#define SCSKIP  1       /* position at end of white space               */


/* case sensitivity flags */

#define CASEU   0       /* force case to upper case                           */
#define CASEL   1       /* leave symbol case alone                            */
#define CASEX   2       /* force all symbols except EXTRN and PUBLIC to upper */


/* opcode types */

#define PGENARG         0       /* general two argument opcodes         */
#define PCALL           1       /* call                                 */
#define PJUMP           2       /* jump                                 */
#define PSTACK          3       /* stack manipulation                   */
#define PRETURN         4       /* return                               */
#define PRELJMP         5       /* relative jumps                       */
#define PNOARGS         6       /* no argument opcodes                  */
#define PREPEAT         7       /* repeat                               */
#define PINCDEC         8       /* increment/decrement                  */
#define PINOUT          9       /* in/out                               */
#define PARITH         10       /* arithmetic opcodes                   */
#define PESC           11       /* escape                               */
#define PXCHG          12       /* exchange                             */
#define PLOAD          13       /* load                                 */
#define PMOV           14       /* moves                                */
#define PSHIFT         15       /* shifts                               */
#define PXLAT          16       /* translate                            */
#define PSTR           17       /* string                               */
#define PINT           18       /* interrupt                            */
#define PENTER         19       /* enter                                */
#define PBOUND         20       /* bounds                               */
#define PCLTS          21       /*                                      */
#define PDESCRTBL      22       /*                                      */
#define PDTTRSW        23       /*                                      */
#define PARSL          24       /*                                      */
#define PARPL          25       /*                                      */
#define PVER           26       /*                                      */
#define PMOVX          27       /* movzx, movsx                         */
#define PSETCC         28       /* setle, setge, etc                    */
#define PBIT           29       /* bt, bts, etc                         */
#define PBITSCAN       30       /* bsf, bsr                             */

/* leave some room */
#define OPCODPARSERS   37       /* number of non 8087/286 parsers       */


/* fltparsers, 8087 opcode types */

#define FNOARGS         37
#define F2MEMSTK        38
#define FSTKS           39
#define FMEMSTK         40
#define FSTK            41
#define FMEM42          42
#define FMEM842         43
#define FMEM4810        44
#define FMEM2           45
#define FMEM14          46
#define FMEM94          47
#define FWAIT           48
#define FBCDMEM         49


/* masks for opcode types */

#define M_PGENARG       (1L << PGENARG)
#define M_PCALL         (1L << PCALL)
#define M_PJUMP         (1L << PJUMP)
#define M_PSTACK        (1L << PSTACK)
#define M_PRETURN       (1L << PRETURN)
#define M_PRELJMP       (1L << PRELJMP)
#define M_PNOARGS       (1L << PNOARGS)
#define M_PREPEAT       (1L << PREPEAT)
#define M_PINCDEC       (1L << PINCDEC)
#define M_PINOUT        (1L << PINOUT)
#define M_PARITH        (1L << PARITH)
#define M_PESC          (1L << PESC)
#define M_PXCHG         (1L << PXCHG)
#define M_PLOAD         (1L << PLOAD)
#define M_PMOV          (1L << PMOV)
#define M_PSHIFT        (1L << PSHIFT)
#define M_PXLAT         (1L << PXLAT)
#define M_PSTR          (1L << PSTR)
#define M_PINT          (1L << PINT)
#define M_PENTER        (1L << PENTER)
#define M_PBOUND        (1L << PBOUND)
#define M_PCLTS         (1L << PCLTS)
#define M_PDESCRTBL     (1L << PDESCRTBL)
#define M_PDTTRSW       (1L << PDTTRSW)
#define M_PARSL         (1L << PARSL)
#define M_PARPL         (1L << PARPL)
#define M_PVER          (1L << PVER)


/* dkind */

/* low 4 bits reserved for dkinds 0-15 reseved for .model */

#define NL              0
#define IGNORECASE      0x10        /* ignorecase for if's */

#define BLKBEG          0x20        /* macro */
#define CONDBEG         0x40        /* condition */
#define CONDCONT        0x80        /* elseif */


/* assembler directive types */

#define TNAME           1
#define TPUBLIC         2
#define TEXTRN          3
#define TEND            4
#define TORG            5
#define TEVEN           6
#define TPURGE          7
#define TPAGE           8
#define TRADIX          9
#define TLIST           10
#define TXLIST          11
#define TLALL           12
#define TXALL           13
#define TSALL           14
#define TCREF           15
#define TXCREF          16
#define TTFCOND         17
#define TLFCOND         18
#define TSFCOND         19
#define TIF             20
#define TIFE            21
#define TIFDEF          22
#define TIFNDEF         23
#define TIFDIF          24
#define TIFIDN          25
#define TIF1            26
#define T8086           27
#define T8087           28
#define T287            29
#define T186            30
#define T286C           31
#define T286P           32
#define TLOCAL          33
#define TIF2            34
#define TIFNB           35
#define TIFB            36
#define TENDIF          37
#define TIRP            38
#define TIRPC           39
#define TREPT           40
#define TENDM           41
#define TERR            42
#define TERR1           43
#define TERR2           44
#define TERRB           45
#define TERRDEF         46
#define TERRDIF         47
#define TERRE           48
#define TERRNZ          49
#define TERRIDN         50
#define TERRNB          51
#define TERRNDEF        52
#define T386C           53
#define T386P           54
#define T387            55
#define TALIGN          56
#define TASSUME         57
#define TFPO            99

/* 1st only */

#define TEXITM          60
#define TINCLUDE        61
#define TSUBTTL         62
#define TELSE           63
#define TTITLE          64
#define TCOMMENT        65
#define TOUT            66


/* 1st or 2nd */

/* note that TDW has to be the last in the group */
#define TDB             70
#define TDD             71
#define TDQ             72
#define TDT             73
#define TDF             74
#define TDW             75


/* 2nd only */ /* note--datadsize assumes TDx and TMACRO are adjacent */

#define TMACRO          76
#define TEQU            77
#define TSUBSTR         78
#define TCATSTR         79
#define TSIZESTR        80
#define TINSTR          81
#define TSEGMENT        82
#define TENDS           83
#define TPROC           84
#define TENDP           85
#define TGROUP          86
#define TLABEL          87
#define TSTRUC          88
#define TRECORD         89

/* other directives */

#define TSEQ            90
#define TALPHA          91

#define TMODEL          92
#define TMSEG           93
#define TMSTACK         94
#define TDOSSEG         95
#define TINCLIB         96
#define TCOMM           97
#define TMSFLOAT        98

#ifdef MSDOS
#define ERRFILE         stdout
#else
#define ERRFILE         stderr
#endif

/* operator list */

#define OPLENGTH        0
#define OPSIZE          1
#define OPWIDTH         2
#define OPMASK          3
#define OPOFFSET        4
#define OPSEG           5
#define OPTYPE          6
#define OPSTYPE         7
#define OPTHIS          8
#define OPHIGH          9
#define OPLOW          10
#define OPNOT          11
#define OPSHORT        12
#define OPAND          13
#define OPEQ           14
#define OPGE           15
#define OPGT           16
#define OPLE           17
#define OPLT           18
#define OPMOD          19
#define OPNE           20
#define OPOR           21
#define OPPTR          22
#define OPSHL          23
#define OPSHR          24
#define OPXOR          25
#define OPNOTHING      26
#define OPDUP          27
#define OPLPAR         28
#define OPRPAR         29
#define OPLANGBR       30
#define OPRANGBR       31
#define OPLBRK         32
#define OPRBRK         33
#define OPDOT          34
#define OPCOLON        35
#define OPMULT         36
#define OPDIV          37
#define OPPLUS         38
#define OPMINUS        39
#define OPUNMINUS      40
#define OPUNPLUS       41


/* processor types */

#define P86             0x01    /* all 8086/8088 instructions   */
#define P186            0x02    /*   + 186                      */
#define P286            0x04    /*   + 286 unprotected          */
#define FORCEWAIT       0x10    /* keep FWAIT on these 287 instructions */
#define PROT            0x80    /* protected mode instructions  */
                                /* See also F_W, S_W in asmtab.h */

/* For NT the .MSFLOAT keyword has been removed */
/* Therefore PXNONE can't be set (Jeff Spencer 11/2/90) */
#define PXNONE          0x00    /* MSFLOAT, no coprocessor */
#define PX87            0x01    /* 8087 */
#define PX287           0x04    /* 80287 */
#define PX387           0x08    /* 80387 */

#ifdef V386
#define P386            0x08    /*   + 386 unprotected          */
#endif


/* cross-reference information */

#define CREFEND         0       /* member of enumerated set             */
#define REF             1       /* member of enumerated set             */
#define DEF             2       /* member of enumerated set             */
#define CREFINF         3       /* number of cross reference types      */


/* cross-reference selection */

#define CREF_SINGLE     1       /* generate single file cross reference   */
#define CREF_MULTI      2       /* generate multiple file cross reference */

/* Symbol reference type */

#define REF_NONE        0       /* symbol reference type is none  */
#define REF_READ        1       /* symbol reference type is read  */
#define REF_WRITE       2       /* symbol reference type is write */
#define REF_XFER        3       /* symbol reference type is jump  */
#define REF_OTHER       4       /* symbol reference type is other */



/* number of arguments for opcodes */

#define NONE            0       /* no arguments                         */
#define MAYBE           1       /* may have arguments                   */
#define ONE             2       /* one argument                         */
#define TWO             3       /* two arguments                        */
#define VARIES          4       /* variable number                      */


/* opcode argument class */

#define FIRSTDS         0
#define SECONDDS        1
#define STRINGOPCODE    2


/* symbol attributes */

#define CDECL_           0
#define XTERN           1
#define DEFINED         2
#define MULTDEFINED     3
#define NOCREF          4
#define BACKREF         5
#define PASSED          6
#define GLOBAL          7


/* masks for attributes */

#define M_GLOBAL        (1 << GLOBAL)
#define M_XTERN         (1 << XTERN)
#define M_DEFINED       (1 << DEFINED)
#define M_MULTDEFINED   (1 << MULTDEFINED)
#define M_NOCREF        (1 << NOCREF)
#define M_BACKREF       (1 << BACKREF)
#define M_PASSED        (1 << PASSED)
#define M_CDECL         (1 << CDECL_)


/* symbol kinds */

#define SEGMENT         0
#define GROUP           1
#define CLABEL          2
#define PROC            3
#define REC             4
#define STRUC           5
#define EQU             6
#define DVAR            7
#define CLASS           8
#define RECFIELD        9
#define STRUCFIELD      10
#define MACRO           11
#define REGISTER        12


/* masks for symbol kinds */

#define M_SEGMENT       (1 << SEGMENT)
#define M_GROUP         (1 << GROUP)
#define M_CLABEL        (1 << CLABEL)
#define M_PROC          (1 << PROC)
#define M_REC           (1 << REC)
#define M_STRUC         (1 << STRUC)
#define M_EQU           (1 << EQU)
#define M_DVAR          (1 << DVAR)
#define M_CLASS         (1 << CLASS)
#define M_RECFIELD      (1 << RECFIELD)
#define M_STRUCFIELD    (1 << STRUCFIELD)
#define M_MACRO         (1 << MACRO)
#define M_REGISTER      (1 << REGISTER)



/* Special values for symtype - which normaly is the size of the type */

#define CSNEAR          ((USHORT)(~0))    /* type for near proc/label */
#define CSNEAR_LONG     ((long)(~0))      /* For use after CSNEAR has been sign extened */
#define CSFAR           ((USHORT)(~1))    /* .. far .. */
#define CSFAR_LONG      ((long)(~1))      /* .. far .. */

/* equ types */

#define ALIAS           0
#define TEXTMACRO       1
#define EXPR            2


/* register kinds */

#define BYTREG          0       /* byte register                        */
#define WRDREG          1       /* word register                        */
#define SEGREG          2       /* segment register                     */
#define INDREG          3       /* index register                       */
#define STKREG          4       /* stack register                       */
#ifdef V386
#define DWRDREG         5       /* double word register                 */
#define CREG            6       /* 386 control, debug, or test register */
#endif


/* masks for register kinds */

#define M_BYTREG        (1 << BYTREG)
#define M_WRDREG        (1 << WRDREG)
#define M_SEGREG        (1 << SEGREG)
#define M_INDREG        (1 << INDREG)
#define M_STKREG        (1 << STKREG)
#ifdef V386
#define M_DWRDREG       (1 << DWRDREG)
#define M_CREG          (1 << CREG)
#endif


/* source type */

#define RREADSOURCE     0       /* read line from file */
#define RMACRO          1       /* macro expansion */

/* source line handlers  */

#define HPARSE          0       /* parse line */
#define HMACRO          1       /* build macro */
#define HIRPX           2       /* build irp/irpx */
#define HCOMMENT        3       /* copy comment lines */
#define HSTRUC          4       /* build struc definition */


/* codeview debugging obj generation */

#define CVNONE          0
#define CVLINE          1
#define CVSYMBOLS       2


/* Predefined type index component parts for codeview*/

#define BT_UNSIGNED     1       /* Basic types */
#define BT_REAL         2
#define BT_ASCII        5

#define BT_DIRECT       0       /* Address type */
#define BT_NEARP        1
#define BT_FARP         2

#define BT_sz1          0       /* Size */
#define BT_sz2          1
#define BT_sz4          2

#define makeType(type, mode, size)  (0x0080 | mode << 5 | type << 2 | size)
#define isCodeLabel(pSY)            (pSY->symtype >= CSFAR)

                                /* tags for fProcArgs, controls frame building*/
#define ARGS_NONE       0       /* no arguments */
#define ARGS_REG        1       /* register save list */
#define ARGS_PARMS      2       /* parms present */
#define ARGS_LOCALS     3       /* locals present */

#define CLANG 1                 /* langType tag for C */
#define STRUC_INIT      -1      /* special mark for clabel.proclen to indicate
                                 * a structure initialization */
/* listing type */

#define SUPPRESS        0
#define LISTGEN         1
#define LIST            2


/* parameter types */

#define CHRTXT          0
#define PLIST           1
#define MACROS          2


/* type of entry on parse stack */

#define OPERATOR        0
#define OPERAND         1
#define ENDEXPR         2


/* okind */

#define ICONST          0
#define ISYM            1
#define IUNKNOWN        2
#define ISIZE           3
#define IRESULT         4


/* ftype */

#define FORREF          1       /* symbol is forward reference          */
#define UNDEFINED       2       /* symbol is undefined                  */
#define KNOWN           4       /* symbol is known                      */
#define XTERNAL         8       /* symbol is external                   */
#define INDETER        10       /* symbol value is indeterminate        */


/* tset */

#define UNKNOWN         0
#define HIGH            1
#define LOW             2
#define DATA            3
#define CODE            4
#define RCONST          5
#define REGRESULT       6
#define SHRT            7       /* Was SHORT, but that conflicted with the type */
#define SEGRESULT       8
#define GROUPSEG        9
#define FORTYPE        10
#define PTRSIZE        11
#define EXPLOFFSET     12
#define FLTSTACK       13
#define EXPLCOLON      14
#define STRUCTEMPLATE  15


/* masks for above  */

#define M_UNKNOWN       (1 << UNKNOWN)         // 0x0001
#define M_HIGH          (1 << HIGH)            // 0x0002
#define M_LOW           (1 << LOW)             // 0x0004
#define M_DATA          (1 << DATA)            // 0x0008
#define M_CODE          (1 << CODE)            // 0x0010
#define M_RCONST        (1 << RCONST)          // 0x0020
#define M_REGRESULT     (1 << REGRESULT)       // 0x0040
#define M_SHRT          (1 << SHRT)            // 0x0080
#define M_SEGRESULT     (1 << SEGRESULT)       // 0x0100
#define M_GROUPSEG      (1 << GROUPSEG)        // 0x0200
#define M_FORTYPE       (1 << FORTYPE)         // 0x0400
#define M_PTRSIZE       (1 << PTRSIZE)         // 0x0800
#define M_EXPLOFFSET    (1 << EXPLOFFSET)      // 0x1000
#define M_FLTSTACK      (1 << FLTSTACK)        // 0x2000
#define M_EXPLCOLON     (1 << EXPLCOLON)       // 0x4000
#define M_STRUCTEMPLATE ((USHORT)(1 << STRUCTEMPLATE))   // 0x8000


/* fixup types */

#define FPOINTER        0       /* four bytes offset and segment        */
#define FOFFSET         1       /* two bytes relative to context        */
#define FBASESEG        2       /* two bytes segment address            */
#define FGROUPSEG       3       /* two bytes segment address of group   */
#define FCONSTANT       4       /* one or two bytes of constant data    */
#define FHIGH           5       /* one byte high part of offset         */
#define FLOW            6       /* one byte low part of offset          */
#define FNONE           7       /* no offset                            */

#ifndef V386
#define FIXLIST         8       /* number of fixup types                */
#else
#define F32POINTER      8       /* 6 bytes offset and segment--for 386  */
#define F32OFFSET       9       /* 4 bytes offset--for 386              */
#define DIR32NB         10      /* DIR32NB fixup type for FPO           */
#define FIXLIST         11      /* number of fixup types                */
#endif


/* masks for fixup types */

#define M_F32POINTER    (1 << F32POINTER)
#define M_F32OFFSET     (1 << F32OFFSET)
#define M_FPOINTER      (1 << FPOINTER)
#define M_FOFFSET       (1 << FOFFSET)
#define M_FBASESEG      (1 << FBASESEG)
#define M_FGROUPSEG     (1 << FGROUPSEG)
#define M_FCONSTANT     (1 << FCONSTANT)
#define M_FHIGH         (1 << FHIGH)
#define M_FLOW          (1 << FLOW)
#define M_FNONE         (1 << FNONE)


/* record for DUP lists */

#define NEST            0       /* Dup item is nested                   */
#define ITEM            1       /* Dup item is regular size             */
#define LONG            2       /* Dup item is long size                */


/* assembler exit codes */

#define EX_NONE         0       /* no error                                */
#define EX_ARGE         1       /* argument error                          */
#define EX_UINP         2       /* unable to open input file               */
#define EX_ULST         3       /* unable to open listing file             */
#define EX_UOBJ         4       /* unable to open object file              */
#define EX_UCRF         5       /* unable to open cross reference file     */
#define EX_UINC         6       /* unable to open include file             */
#define EX_ASME         7       /* assembly errors                         */
#define EX_MEME         8       /* memory allocation error                 */
#define EX_REAL         9       /* real number input not allowed           */
#define EX_DSYM         10      /* error defining symbol from command line */
#define EX_INT          11      /* assembler interrupted                   */

#define TERMINATE(message, exitCode)\
        terminate( (SHORT)((exitCode << 12) | message), NULL, NULL, NULL )

#define TERMINATE1(message, exitCode, a1)\
        terminate( (SHORT)((exitCode << 12) | message), a1, NULL, NULL )


                            /* Bit flags or'ed into the error numbers */
#define E_WARN1   ((USHORT)(1 << 12)) /* level 1 warning */
#define E_WARN2   ((USHORT)(2 << 12)) /* level 2 warning */
#define E_PASS1   ((USHORT)(8 << 12)) /* pass 1 error */
#define E_ERRMASK 0x0fff    /* low 12 bits contain error code */


/* error code definitions */

#define E_BNE   1           /* block nesting error           */
#define E_ECL  (2|E_WARN1)  /* extra characters on line      */
#define E_RAD  (3|E_PASS1)  /* ?register already defined     */
#define E_UST   4           /* unknown type specifier        */
#define E_RSY  (5|E_PASS1)  /* redefinition of symbol        */
#define E_SMD   6           /* symbol multiply defined       */
#define E_PHE   7           /* phase error                   */
#define E_ELS   8           /* already had ELSE clause       */
#define E_NCB   9           /* not in conditional block      */
#define E_SND   10          /* symbol not defined            */
#define E_SYN   11          /* syntax error                  */
#define E_TIL   12          /* type illegal in context       */
#define E_NGR   13          /* need group name               */
#define E_PS1  (14|E_PASS1) /* must be declared in pass 1    */
#define E_TUL   15          /* symbol type usage illegal     */
#define E_SDK   16          /* symbol already different kind */
#define E_RES  (17|E_WARN1) /* symbol is reserved word       */
#define E_IFR  (18|E_PASS1) /* forward reference is illegal  */
#define E_MBR   19          /* must be register              */
#define E_WRT   20          /* wrong register type           */
#define E_MSG   21          /* must be segment or group      */
/*#define E_SNS   22 obsolete: symbol has no segment         */
#define E_MSY   23          /* must be symbol type           */
#define E_ALD   24          /* already locally defined       */
#define E_SPC   25          /* segment parameters changed    */
#define E_NPA   26          /* not proper align /combine type */
#define E_RMD   27          /* reference to multiply defined */
#define E_OPN   28          /* operand was expected          */
#define E_OPR   29          /* operator was expected         */
#define E_DVZ   30          /* division by 0 or overflow     */
#define E_SCN   31          /* shift count negative          */
#define E_OMM  (32|E_WARN1) /* operand types must match      */
#define E_IUE   33          /* illegal use of external       */
/*#define E_RFM   34 obsolete: must be record field name     */
#define E_RRF   35          /* must be record or fieldname   */
#define E_OHS   36          /* operand must have size        */
#define E_NOP  (37|E_WARN2) /* nops generated                */
#define E_LOS   39          /* left operand must have segmnt */
#define E_OOC   40          /* one operand must be constant  */
#define E_OSA   41          /* operands must be same or 1 abs*/
/*#define E_NOE   42 obsolete: normal type operand expected  */
#define E_CXP   43          /* constant was expected         */
#define E_OSG   44          /* operand must have segment     */
#define E_ASD   45          /* must be associated with data  */
#define E_ASC   46          /* must be associated with code  */
#define E_DBR   47          /* already have base register    */
#define E_DIR   48          /* already have index register   */
#define E_IBR   49          /* must be index or base register*/
#define E_IUR   50          /* illegal use of register       */
#define E_VOR   51          /* value out of range            */
#define E_NIP   52          /* operand not in IP segment     */
#define E_IOT   53          /* improper operand type         */
#define E_JOR   54          /* relative jump out of range    */
/*#define E_IDC   55 obsolete: index displ must be constant  */
#define E_IRV   56          /* illegal register value        */
#define E_NIM   57          /* no immediate mode             */
#define E_IIS  (58|E_WARN1) /* illegal size for item         */
#define E_BRI   59          /* byte register is illegal      */
#define E_CSI   60          /* CS register illegal usage     */
#define E_AXL   61          /* must be AX or AL              */
#define E_ISR   62          /* improper use of segment reg   */
#define E_NCS   63          /* no or unreachable CS          */
#define E_OCI   64          /* operand combination illegal   */
#define E_JCD   65          /* near JMP /CALL to differend CS */
#define E_NSO   66          /* label can't have seg override */
#define E_OAP   67          /* must have opcode after prefix */
#define E_OES   68          /* can't override ES segment     */
#define E_CRS   69          /* can't reach with segment reg  */
#define E_MSB   70          /* must be in segment block      */
#define E_NEB   71          /* can't use EVEN or BYTE seg    */
#define E_FOF   72          /* forward needs override or far */
#define E_IDV   73          /* illegal value for DUP count   */
#define E_SAE   74          /* symbol already external       */
#define E_DTL   75          /* DUP too large for linker      */
#define E_UID   76          /* usage of ?(indeterminate) bad */
#define E_MVD   77          /* more values than defined with */
#define E_OIL   78          /* only initialize list legal    */
#define E_DIS   79          /* directive illegal in struc    */
#define E_ODI   80          /* override with DUP is illegal  */
#define E_FCO   81          /* fields cannot be overriden    */
/*#define E_RFR   83 obsolete: register can't be forward ref */
#define E_CEA   84          /* circular chain of EQU aliases */
#define E_7OE   85          /* 8087 opcode can't be emulated */
#define E_EOF  (86|E_PASS1|E_WARN1) /* end of file, no END directive */
#define E_ENS   87          /* data emitted with no segment  */
#define E_EP1   88          /* error if pass1                */
#define E_EP2   89          /* error if pass2                */
#define E_ERR   90          /* error                         */
#define E_ERE   91          /* error if expr = 0             */
#define E_ENZ   92          /* error if expr != 0            */
#define E_END   93          /* error if symbol not defined   */
#define E_ESD   94          /* error if symbol defined       */
#define E_EBL   95          /* error if string blank         */
#define E_ENB   96          /* error if string not blank     */
#define E_EID   97          /* error if strings identical    */
#define E_EDF   98          /* error if strings different    */
#define E_OWL   99          /* overide is too long           */
#define E_LTL  (100|E_PASS1)/* line too long                 */
#define E_IMP  (101|E_WARN1)/* impure memory reference       */
#define E_MDZ  (102|E_WARN1)/* missing data; zero assumed    */
#define E_286  (103|E_WARN1)/* segment near (or at) 64K limit*/
#define E_AP2   104         /* Align must be power of 2      */
#define E_JSH  (105|E_WARN2)/* shortened jump (warning)      */
#define E_EXP   106         /* expected "<what was expected>"*/
#define E_LNL   107         /* line too long                 */
#define E_NDN   108         /* non-digit in number           */
#define E_EMS   109         /* empty string                  */
#define E_MOP   110         /* missing operand               */
#define E_PAR   111         /* open parenthesis or bracket   */
#define E_NMC   112         /* not in macro expansion        */
#define E_UEL   113         /* unexpected end of line        */
#define E_CPU   114         /* can't change cpu type after first segment    */
#define E_ONW  (115|E_WARN2)/* operand size does not match wordsize (warning) */
#define E_ANW  (116|E_WARN2)/* address size does not match wordsize (warning) */
#define E_INC  (117|E_PASS1)/* include file not found */
#define E_FPO1 (118|E_PASS1)
#define E_FPO2 (119|E_WARN1)
#define E_MAX   120         /* number of error messages                     */

/* symbol name entry */

struct idtext {
        SHORT   hashval;        /* value of hash function */
        char    id[1];          /* name */
        };


/* parse stack entry  */

struct dscrec {
        DSCREC  *previtem;      /* previous item on stack */
        UCHAR   prec;           /* precedence */
        char    itype;          /* type of entry */

        union   {
                /* OPERAND */
                struct psop {

                    SYMBOL FARSYM *dsegment;    /* segment of result */
                    SYMBOL FARSYM *dcontext;    /* context(CS) of label
                                                   or current segment register*/
                    SYMBOL FARSYM *dextptr;     /* pointer to external */
                    USHORT        dlength;
                    USHORT        rm;           /* register/index mode */
                    USHORT        dtype;        /* copy of dtype */
                    OFFSET        doffset;      /* offset */
                    USHORT        dsize;        /* size */
                    char          mode;         /* mode bits */
                    char          w;            /* word/byte mode */
                    char          s;            /* sign extend */
                    char          sized;        /* TRUE if has size */
                    char          seg;          /* segment register, etc */
                    char          dflag;        /* copy of dflag */
                    char          fixtype;      /* fixup type */
                    char          dsign;
                  } opnd;

                /* OPERATOR */
                struct  {
                        char oidx;
                        } opr;

                } dsckind;
        };


/* record for dup list */

struct duprec {
    struct duprec FARSYM  *itemlst; /* list of items to dup */
    OFFSET          rptcnt;         /* number of times to repeat */
    USHORT          itemcnt;        /* number of duprecs in itemlist */
    USHORT          type;           /* data type for codeview */
    char            decltype;       /* STRUC data declaration type */
    char            dupkind;        /* dup type */

    union   {
        /* NEXT */
        struct  {
                struct duprec FARSYM *dup;
                } dupnext;

        /* ITEM */
        struct  {
                DSCREC *ddata;
                } dupitem;

        /* LONG */
        struct  {
                char    *ldata;
                UCHAR   llen;
                } duplong;
        } duptype;
};


/* symbol entry */

struct symb {

    SYMBOL FARSYM   *next;          /* pointer to next symbol */
    SYMBOL FARSYM   *alpha;         /* pointer to next symbol alpha ordered */
    SYMBOL FARSYM   *symsegptr;     /* pointer to segment entry for symbol */
    NAME FAR        *nampnt;        /* pointer to name structure */
    NAME            *lcnamp;        /* pointer to lower case name structure */
    OFFSET          offset;
    USHORT          length;
    USHORT          symtype;        /* DB .. DT plus NEAR/FAR */
    UCHAR           attr;           /* GLOBAL .. LOCALSYM */
    char            symkind;        /* SEGMENT .. REGISTER */

    union   {
        /* SEGMENT */
        struct symbseg {
            USHORT          segIndex;       /* must be first */
            SYMBOL FARSYM   *segordered;
            SYMBOL FARSYM   *lastseg;
            SYMBOL FARSYM   *grouptr;
            SYMBOL FARSYM   *nxtseg;
            SYMBOL FARSYM   *classptr;
            OFFSET          seglen;
            OFFSET          locate;
            USHORT          lnameIndex;     /* for class aliaes */
            char            align;
            char            combine;
            char            use32;
            char            hascode;
        } segmnt;

        /* GROUP */
        struct symbgrp {
            USHORT          groupIndex;     /* must be first */
            SYMBOL FARSYM   *segptr;
        } grupe;

        /*  CLABEL */
        struct symbclabel {
            USHORT          type;           /* type index, for codeview */
            SYMBOL FARSYM   *csassume;
            USHORT iProc;                   /* procedure index belonging to */
        } clabel;

        /* PROC */
        struct symbproc {
            USHORT          type;           /* type index, for codeview */
            SYMBOL FARSYM   *csassume;
            USHORT          proclen;
            SYMBOL FARSYM   *pArgs;         /* arguments and locals */
        } plabel;

        /* extern (code & data), comm & class (known as DVAR) */
        struct symbext {
            USHORT          extIndex;       /* must be first */
            SYMBOL FARSYM   *csassume;
            OFFSET          length;         /* so comms > 64K */
            UCHAR           commFlag;       /* used for comm defs */
        } ext;

        /* EQU */
        struct symbequ {
            char equtyp;
            USHORT iProc;                   /* procedure index belonging to */

            union   {
                /* ALIAS */
                struct  {
                    SYMBOL FARSYM *equptr;
                } alias;

                /* TEXTMACRO */
                struct  {
                    char *equtext;
                    USHORT type;             /* CV type for parms/locals */
                } txtmacro;

                /* EXPR */
                struct  {
                    SYMBOL FARSYM   *eassume;
                    char            esign;
                } expr;
            } equrec;
        } equ;

        /* RECFIELD */
        struct symbrecf {
            SYMBOL FARSYM   *recptr;
            SYMBOL FARSYM   *recnxt;
            OFFSET          recinit;        /* Initial Value */
            OFFSET          recmsk;         /* bit mask */
            char            recwid;         /* with in bits */
        } rec;

        /* STRUCFIELD */
        struct symbstrucf {
            SYMBOL FARSYM   *strucnxt;
            USHORT          type;
        } struk;

        /* REC, STRUC, MACRO */
        struct symbrsm {
            union   {
                /* REC */
                struct  {
                    SYMBOL FARSYM   *reclist;
                    char            recfldnum;
                } rsmrec;

                /* STRUC */
                struct  {
                    SYMBOL FARSYM         *struclist;
                    struct duprec FARSYM  *strucbody;
                    USHORT                strucfldnum;
                    USHORT                type;
                    USHORT                typePtrNear;
                    USHORT                typePtrFar;
                } rsmstruc;

                /* MACRO */
                struct  {
                    TEXTSTR FAR     *macrotext;
                    UCHAR           active;
                    UCHAR           delete;
                    UCHAR           parmcnt;
                    UCHAR           lclcnt;
                } rsmmac;
            } rsmtype;
        } rsmsym;

        /* REGISTER */
        struct symbreg {
            char regtype;
        } regsym;

    } symu;
};


/* textstring descriptor */

struct textstr {
        TEXTSTR FAR     *strnext;       /* next string in list */
        char            size;           /* allocated size      */
        char            text[1];        /* text of string      */
        };

typedef union PV_u {

        char *pActual;                  /* pointer to actual parm value */
        char localName[4];              /* or local name cache */
} PV;

typedef struct MC_s {                   /* Macro parameter build/call struct */

        TEXTSTR FAR     *pTSHead;       /* Head of linked body lines */
        TEXTSTR FAR     *pTSCur;        /* Current body line */

        UCHAR           flags;          /* macro type */
        UCHAR           iLocal;         /* index of first local */
        USHORT          cbParms;        /* byte count of parms string */
        USHORT          localBase;      /* first local # to use */
        USHORT          count;          /* count of excution loops */

        char            *pParmNames;    /* parameter names during build */
        char            *pParmAct;      /* actual parm names during expansion*/

        char            svcondlevel;    /* condlevel at macro call */
        char            svlastcondon;   /* lastcondon at macro call */
        char            svelseflag;     /* elseflag at macro call */

        PV              rgPV[1];        /* parm index to point to actual */
} MC;

/*      data descriptor entry */

struct dsr {
        DSCREC  *valrec;
        struct  duprec  FARSYM *dupdsc;
        char    longstr;
        char    flag;
        char    initlist;
        char    floatflag;
        char    *dirscan;
        OFFSET   i;
};

struct eqar {
        SYMBOL FARSYM *equsym;
        DSCREC  *dsc;
        UCHAR   *dirscan;
        UCHAR   svcref;
};


struct datarec {
        OFFSET datalen;
        USHORT type;
        SYMBOL FARSYM *labelptr;
        char buildfield;
};


struct fileptr {
        FILE            *fil;
        struct fileptr  *prevfil;
        short           line;
        char            *name;
        };

 struct objfile {
        int             fh;
        char FARIO      *pos;
        char FARIO      *buf;
        SHORT           cnt;
        SHORT           siz;
        char            *name;
 };


/* BUFFER CONTROL BLOCK - Information concerning a file buffer */

#ifdef BCBOPT
typedef struct BCB {
    struct BCB    * pBCBNext;       /* next BCB for file */
    struct BCB    * pBCBPrev;       /* last BCB allocated */
    char FARIO    * pbuf;           /* pointer to buffer */
    long            filepos;        /* current position in file */
    char            fInUse;         /* Set during pass 2 if buffer is active */
} BCB;
#endif


/* FCB - Information concerning a particular file */

typedef struct FCB {
    int             fh;             /* file handle */
    long            savefilepos;    /* file position if file closed temporarily */
    struct FCB    * pFCBParent;     /* parent file */
    struct FCB    * pFCBChild;      /* child file (bi-directional linked list */
#ifdef BCBOPT
    struct FCB    * pFCBNext;       /* next file to be opened */
    BCB           * pBCBFirst;      /* first BCB for file */
    BCB           * pBCBCur;        /* current BCB for file */
#endif
    char FARIO    * pbufCur;        /* read/write loc in current buffer */
    char FARIO    * ptmpbuf;        /* current position in temp read buffer */
    char FARIO    * buf;            /* temporary read buffer */
    USHORT          ctmpbuf;        /* count of bytes in temporary buffer */
    USHORT          cbbuf;          /* size of buffer */
    USHORT          cbufCur;        /* count of bytes in current buffer */
    USHORT          line;           /* current line number */
    char            fname[1];       /* file name */
} FCB;

typedef struct FASTNAME {
    UCHAR         * pszName;        /* text of the name, upper case if appropriate */
    UCHAR         * pszLowerCase;   /* Mixed case version of pszName */
    USHORT          usHash;         /* hash value of string in pszName */
    UCHAR           ucCount;        /* length of the name */
} FASTNAME;

// Used to store real number initializers
struct realrec {
        UCHAR   num[10];
        USHORT  i;
};


/* Used to parse and generate CODE for 8086 opcodes */
struct parsrec {
        DSCREC         *op1;
        DSCREC         *op2;
        UCHAR           bytval;
        USHORT          wordval;
        DSCREC         *dsc1;
        DSCREC         *dsc2;
        UCHAR           defseg;
        char           *dirscan;
        char    svxcref;
};


struct evalrec {
        struct ar    *p;
        char    parenflag;
        char    evalop;
        char    curitem;
        char    idx;
        DSCREC *curoper;
};

struct exprec {
        struct evalrec *p;
        DSCREC  *valright;
        DSCREC  *valleft;
        UCHAR   stkoper;
        USHORT  t;
        OFFSET  left;
        OFFSET  right;
};


struct fltrec {
        UCHAR   fseg;
        char    args;
        USHORT  stknum;
        USHORT  stk1st;
};

/* reg initialization data */
struct mreg {
        char nm[4];
        UCHAR   rt;
        UCHAR   val;
        };

typedef struct _FPO_DATA {
    unsigned long   ulOffStart;            // offset 1st byte of function code
    unsigned long   cbProcSize;            // # bytes in function
    unsigned long   cdwLocals;             // # bytes in locals/4
    unsigned short  cdwParams;             // # bytes in params/4
    unsigned short  cbProlog : 8;          // # bytes in prolog
    unsigned short  cbRegs   : 3;          // # regs saved
    unsigned short  fHasSEH  : 1;          // TRUE if SEH in func
    unsigned short  fUseBP   : 1;          // TRUE if EBP has been allocated
    unsigned short  reserved : 1;          // reserved for future use
    unsigned short  cbFrame  : 2;          // frame type
} FPO_DATA, *PFPO_DATA;

typedef struct _FPOSTRUCT {
    struct _FPOSTRUCT  *next;
    FPO_DATA            fpoData;
    SYMBOL             *pSym;
    SYMBOL             *pSymAlt;
    USHORT             extidx;
} FPOSTRUCT, *PFPOSTRUCT;


#ifndef ASMGLOBAL
# if defined M8086OPT
 extern UCHAR           *naim;
 extern UCHAR           *svname;
# else
 extern FASTNAME        naim;
 extern FASTNAME        svname;
# endif
 extern UCHAR           X87type;
 extern char            ampersand;
 extern char            addplusflagCur;
 extern char            baseName[];
 extern char            caseflag;
 extern char            checkpure;
 extern char            condflag;
 extern OFFSET          cbProcLocals;
 extern OFFSET          cbProcParms;
 extern UCHAR           cpu;
 extern UCHAR           cputype;
 extern UCHAR           crefinc;
 extern char            crefing;
 extern char            crefnum[];
 extern char            crefopt;
 extern UCHAR           creftype;
 extern char            wordszdefault;
 extern char            emittext;       /* emit linker test if true */
 extern char            debug;          /* true if debug set */
 extern USHORT          dirsize[];
 extern char            displayflag;
 extern char            dumpsymbols;    /* do symbol table display if true */
 extern char            dupflag;
 extern char            elseflag;
 extern char            emulatethis;
 extern char            endbody;
 extern char            equdef;         /* TRUE if equ already defined */
 extern char            equflag;
 extern char            equsel;
 extern USHORT          errorlineno;
 extern char            exitbody;
 extern char            expandflag;
 extern char            fDosSeg;
 extern char            fSimpleSeg;
 extern char            fCheckRes;
 extern UCHAR           fCrefline;
 extern char            fNeedList;
 extern char            fProcArgs;
 extern USHORT          fPass1Err;
 extern char            f386already;
 extern char            fArth32;
 extern char            fSkipList;
 extern char            fSecondArg;
 extern char            farData[];
 extern char            fltemulate;
 extern UCHAR           fKillPass1;
 extern jmp_buf         forceContext;
 extern char            generate;
 extern UCHAR           goodlbufp;
 extern char            impure;
 extern USHORT          iProcCur;
 extern USHORT          iProc;
 extern char            inclcnt;
 extern char            inclFirst;
 extern SHORT           iRegSave;
 extern char            *inclpath[];
 extern char            initflag;
 extern char            labelflag;
 extern SHORT           handler;
 extern char            lastreader;
 extern char            linebuffer[];
 extern char            *linebp;
 extern char            lbuf[];
 extern char            *lbufp;
 extern SHORT           langType;
 extern char            listbuffer[];
 extern char            listblank [];
 extern char            listconsole;
 extern char            listed;
 extern char            listflag;
 extern char            listindex;
 extern char            listquiet;
 extern char            localflag;
 extern char            loption;
 extern char            lsting;
 extern char            moduleflag;

 extern USHORT          nestCur;
 extern USHORT          nestMax;
 extern char            noexp;
 extern char            objectascii[];
 extern char            objing;
 extern char            opctype;
 extern char            opertype;
 extern char            opkind;
 extern char            optyp;
 extern char            origcond;
 extern char            *pText, *pTextEnd;
 extern SYMBOL FARSYM   *pStrucCur;
 extern SYMBOL FARSYM   *pStrucFirst;
 extern char            pass2;          /* true if in pass 2 */
 extern char            popcontext;
 extern char            radix;          /* assumed radix base */
 extern char            radixescape;
 extern char            resvspace;
 extern char            save[];
 extern char            segalpha;
 extern char            segtyp;

 extern char            strucflag;
 extern char            subttlbuf[];
 extern char            swaphandler;
 extern char            titlebuf[];
 extern char            titleflag;
 extern char            titlefn[];
 extern USHORT          tempLabel;
 extern char            unaryset[];
 extern char            xcreflag;
 extern char            xoptoargs[];
 extern char            *atime;
 extern long            linestot;
 extern long            linessrc;
 extern short           pagemajor;
 extern short           pageminor;
 extern short           symbolcnt;
 extern DSCREC          emptydsc;
 extern DSCREC          *fltdsc;
 extern DSCREC          *itemptr;
 extern DSCREC          *resptr;
 extern DSCREC          *startaddr;
 extern struct duprec FARSYM *strucprev;
 extern struct duprec FARSYM *strclastover;
 extern struct duprec FARSYM *strucoveride;
 extern struct fileptr  crf;
 extern struct fileptr  lst;

 extern NAME FAR        *modulename;
 extern TEXTSTR FAR     *rmtline;
 extern SYMBOL FARSYM   *curgroup;
 extern SYMBOL FARSYM   *firstsegment;
 extern SYMBOL FARSYM   *lastsegptr;
 extern SYMBOL FARSYM   *macroptr;
 extern SYMBOL FARSYM   *macroroot;
 extern SYMBOL FARSYM   *procStack[PROCMAX];
 extern SYMBOL FARSYM   *pProcCur;
 extern SYMBOL FARSYM   *pProcFirst;
 extern SYMBOL FARSYM   *pFlatGroup;
 extern short           iProcStack;
 extern SYMBOL FARSYM   *pcproc;
 extern MC              *pMCur;
 extern TEXTSTR FAR     *pLib;
 extern SYMBOL FARSYM   *pcsegment;
 extern SYMBOL FARSYM   *recptr;
 extern char            regSave[8][SYMMAX+1];
 extern SYMBOL FARSYM   *regsegment[6];
 extern SYMBOL FARSYM   *struclabel;
 extern SYMBOL FARSYM   *strucroot;
 extern SYMBOL FARSYM   *symptr;
 extern SYMBOL FARSYM   *symroot[];
 extern UCHAR           delim;
 extern SHORT           errorcode;
 extern UCHAR           fixvalues[];
 extern UCHAR           modrm;
 extern UCHAR           nilseg;
 extern char            opcref;
 extern UCHAR           opcbase;
 extern long            oEndPass1;
 extern UCHAR           xltftypetolen[];
 extern UCHAR           xoptoseg[];
 extern char            *begatom;
 extern USHORT  blocklevel;
 extern OFFSET  clausesize;
 extern USHORT  condlevel;      /* conditional level */
 extern USHORT  count;
 extern USHORT  codeview;
 extern USHORT  crefcount;
 extern USHORT  datadsize[];
 extern USHORT  duplevel;       /* indent for dup listing */
 extern char    *endatom;
 extern USHORT  errornum;       /* error count */
 extern USHORT  externnum;
 extern UCHAR   fPutFirstOp;
 extern USHORT  fltfixmisc[4][2];
 extern USHORT  fltselect[4][2];
 extern USHORT  groupnum;
 extern USHORT  lastcondon;
 extern UCHAR   linelength;     /* length of line */
 extern USHORT  lnameIndex;
 extern USHORT  localbase;
 extern USHORT  macrolevel;
 extern USHORT  operprec;
 extern USHORT  pagelength;
 extern USHORT  pageline;
 extern USHORT  pagewidth;
 extern OFFSET  pcmax;
 extern OFFSET  pcoffset;
 extern USHORT  segidx;
 extern USHORT  segmentnum;
 extern USHORT  typeIndex;
 extern USHORT  temp;
 extern OFFSET  val;
 extern USHORT  varsize;
 extern USHORT  warnnum;        /* warning count */
 extern USHORT  warnlevel;      /* warning level */
 extern USHORT  warnCode;
 extern USHORT  xltsymtoresult[];
 extern OFFSET  CondJmpDist;    /* conditional jump distance (for error) */

 extern char    segName[];
 extern char    procName[];

# ifdef M8086
  extern char   qname[];        /* native coded in asmhelp.asm */
  extern char   qlcname[];      /* "" */
  extern char   qsvname[];      /* "" */
  extern char   qsvlcname[];    /* "" */

  extern SHORT   objerr;
  extern char   srceof;
  extern char   fNotStored;

  extern USHORT obufsiz;

# endif /* M8086 */

extern struct objfile  obj;
extern FCB * pFCBCur;          /* Current file being read */

#ifdef BCBOPT
extern BCB * pBCBAvail;        /* List of deallocatable file buffers */
extern FCB * pFCBInc;          /* Next include file */
extern UCHAR fBuffering;       /* TRUE if storing lines for pass 2 */
#endif

extern FCB * pFCBMain;         /* main file */


# ifndef XENIX286
  extern char           terse;
# endif


#ifndef V386

 #define wordsize 2            /* becomes a constant for 16 bit only segments */
#else
 extern SHORT     wordsize;

#endif

#endif /* ASMGLOBAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmalloc.c ===
/* asmalloc.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986, 1987.  all rights reserved
**
** randy nevin
** michael hobbs 7/87
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
**
** Storage allocation/deallocation
**
**	dalloc, dfree
**	talloc, tfree
**	nearalloc, faralloc, pBCBalloc, freefarbuf
 */

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"

/*
 *	dalloc/dfree
 *
 *	Allocation/deallocation of descriptor nodes.  Uses a list of
 *	deallocated descriptors available for allocation.
 */

/* dscfree list descriptor */

struct dscfree {
	struct dscfree	*strnext;	/* next string in list */
	UCHAR		size;		/* allocated size      */
	UCHAR		text[1];	/* text of string      */
	};
static struct dscfree *dscrfree = (struct dscfree *)NULL;

#define nearheap(fp) ((int)(((long)(char far *)&pcoffset) >> 16) == highWord(fp))

/*
 *	dalloc - allocate descriptor from temporary list
 */

DSCREC * PASCAL CODESIZE
dalloc (
){
	register struct dscfree *t;

	if (!(t = dscrfree))
	     t = (struct dscfree *)nalloc( sizeof(DSCREC), "dalloc");
	else
	    dscrfree = t->strnext;

	return((DSCREC *)t);
}



/*
 *	dfree - return descriptor to free list
 */

VOID PASCAL CODESIZE
dfree (
	UCHAR *p
){
	register struct dscfree *tp;

	tp = (struct dscfree *)p;
	tp->strnext = dscrfree;
	dscrfree = tp;
}



/*
 *	talloc, tfree
 *
 *	Allocation\deallocation of memory.
 *	Allocation is made with minimum size of TEMPMAX bytes.
 *	Any allocation request for <= TEMPMAX bytes will be made
 *	by grabbing a block off the free list.	Deallocation of these
 *	blocks returns them to the free list.  For blocks larger than
 *	TEMPMAX bytes, nalloc() and free() are called.
 */

#define TEMPMAX 32

static TEXTSTR FAR *tempfree = (TEXTSTR FAR *)NULL;


#ifndef M8086

/*
 *	talloc - allocate space from temporary list
 */

UCHAR * PASCAL
talloc(
	UINT nbytes
){
	register TEXTSTR *t;

	if (nbytes > TEMPMAX)
		t = (TEXTSTR *) nalloc(nbytes, "talloc");
	else if (!(t = tempfree))
		t = (TEXTSTR *) nalloc (TEMPMAX, "talloc");

	else
	    tempfree = t->strnext;

	return ((UCHAR *)t);
}


/*
 *	tfree - return temp allocation to free list
 */
VOID PASCAL
tfree (
      UCHAR *ap,
      UINT nbytes
){
	register TEXTSTR *tp;

	if (nbytes > TEMPMAX)
		free (ap);
	else {
		tp = (TEXTSTR *)ap;
		tp->strnext = tempfree;
		tempfree = tp;
	}
}

#else

/*
 *	talloc - allocate space from temporary list
 */

UCHAR FAR * PASCAL CODESIZE
talloc(
	USHORT nbytes
){
	TEXTSTR FAR *t;

	if (nbytes > TEMPMAX)
		t = (TEXTSTR FAR *) falloc(nbytes, "talloc");
	else if (!(t = tempfree))
		t = (TEXTSTR FAR *) falloc(TEMPMAX, "talloc");

	else
		tempfree = t->strnext;

	return ((UCHAR FAR *)t);
}

/*
 *	tfree - return temp allocation to free list
 */
VOID PASCAL CODESIZE
tfree (
	UCHAR FAR *ap,
	UINT nbytes
){
	register TEXTSTR FAR *tp;

	if (nbytes > TEMPMAX)
		_ffree (ap);
	else {
		tp = (TEXTSTR FAR *)ap;
		tp->strnext = tempfree;
		tempfree = tp;
	}
}

#endif /* NOT M8086 */




#ifndef M8086

/****	nearalloc - normal near memory allocation
 *
 *	nearalloc (usize, szfunc)
 *
 *	Entry	usize = number of bytes to allocate
 *		szfunc = name of calling routine
 *	Returns Pointer to block if successful
 *	Calls	malloc(), memerror()
 *	Note	Generates error if malloc unsuccessful
 *		IF NOT M8086, nalloc AND falloc MAP TO THIS FUNCTION
 */

UCHAR * CODESIZE PASCAL
nearalloc(
    UINT usize,
    char * szfunc
){
    register char * pchT;

    if (!(pchT = malloc(usize)))
	memerror(szfunc);

    return(pchT);
}


#else


/****	nearalloc - normal near memory allocation
 *
 *	nearalloc (usize)
 *
 *	Entry	usize = number of bytes to allocate
 *	Returns Pointer to block if successful
 *	Calls	malloc(), memerror()
 *	Note	Generates error if malloc unsuccessful
 */

UCHAR * CODESIZE PASCAL
nearalloc(
    USHORT usize
){
    register char * pchT;

    if (!(pchT = malloc(usize)))
	outofmem();

    return(pchT);
}



/****	faralloc - Routine for normal far memory allocation
 *
 *	faralloc (usize)
 *
 *	Entry	usize = number of bytes to allocate
 *	Returns Pointer to block if successful
 *	Calls	_fmalloc(), nearheap(), freefarbuf(), memerror(), _ffree()
 *	Note	Should call instead of _fmalloc(),
 *		at least after the first call to pBCBalloc() has been made.
 *		Not called by pBCBalloc.
 *		Generates error if memory full
 */

UCHAR FAR * CODESIZE PASCAL
faralloc(
    USHORT usize
){
    char FAR * fpchT;

#ifdef BCBOPT
    /* need check of _fmalloc 'ing into near heap too */

    while ( (!(fpchT = _fmalloc(usize)) || nearheap(fpchT)) && pBCBAvail) {

	fBuffering = FALSE;		/* can't buffer any more */

	if (fpchT)
	    _ffree(fpchT);

	freefarbuf();
    }
#endif

#ifdef FLATMODEL   /* If 32 bit small model then use normal malloc */
    fpchT = malloc(usize);
#else
    fpchT = _fmalloc(usize);
#endif
    if (!fpchT)
	outofmem();

    return (fpchT);
}



#ifdef BCBOPT
/****	pBCBalloc - allocate a BCB and associated buffer
 *
 *	pBCBalloc ()
 *
 *	Entry	fBuffering must be TRUE
 *	Returns pointer to BCB (connected to buffer if bufalloc() successful)
 *	Calls	bufalloc()
 *	Note	Returns a BCB even if buffer allocation fails
 *		Returns NULL only after Out-of-memory error
 */

BCB * FAR PASCAL
pBCBalloc(
    UINT cbBuf
){
    register BCB * pBCBT;
    char FARIO * pfchT;

    pBCBT = (BCB *) nearalloc(sizeof(BCB));

#ifndef XENIX286

    if ((pfchT = _fmalloc(cbBuf)) && nearheap(pfchT)) {

	_ffree(pfchT);
	pfchT = NULL;
    }

    if (!(pfchT)) 
#else
	pfchT = NULL;
#endif

    {

	fBuffering = FALSE;	    /* can't buffer anymore */
	pBCBT->filepos = 0;

    } 
#ifndef XENIX286
    else {

	pFCBCur->cbufCur = cbBuf;
	pBCBT->pBCBPrev = pBCBAvail;
	pBCBAvail = pBCBT;
    }
#endif

    pFCBCur->pbufCur = pBCBT->pbuf = pfchT;
    pBCBT->pBCBNext = NULL;
    pBCBT->fInUse = 0;
    return(pBCBT);
}
#endif //BCBOPT

#ifdef BCBOPT
/****	freefarbuf - free a file buffer
 *
 *	freefarbuf ()
 *
 *	Entry
 *	Returns
 *	Calls	_ffree()
 *	Note	Frees the last-allocated file buffer
 */

freefarbuf(
){

    while (pBCBAvail && pBCBAvail->fInUse)
	pBCBAvail = pBCBAvail->pBCBPrev;

    if (pBCBAvail) {
#ifdef XENIX286
	free(pBCBAvail->pbuf);
#else
	_ffree(pBCBAvail->pbuf);
#endif
	pBCBAvail->pbuf = NULL;
	pBCBAvail = pBCBAvail->pBCBPrev;
    }
}
#endif //BCBOPT
#endif /* M8086 */





#if 0

/*	sleazy way to check for valid heap
 *	_mcalls tells how calls to malloc were made so that
 *	a countdown breakpoint can be set for _mcalls iterations
 */

extern	char *_nmalloc();

long _mcalls;

UCHAR *
malloc (
	UINT n
){
	register UINT fb;
	fb = _freect(0);      /* walks near heap - usually loops if corrupt */
	_mcalls++;
	return (_nmalloc(n));
}

#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mapsym\mapsym.c ===
//  MAPSYM.C
//
//      where "filename" is .MAP file produced by MSlink.
//
//
// Modifications
//              21 Jun 84       Reuben Borman
//     - Declared a static buffer for mapfh for use by the runtime I/O.
//          Previously, mapfh was being read unbuffered because all the heap
//          was being grabbed beforehand.
//              30 Nov 88       Thomas Fenwick
//     - added detection and support for LINK32 map files.
//              14 Mar 95       Jon Thomason
//     - Made into a console app (mapsym32), removed coff support, 'modernized'
//		17 Apr 96	Greg Jones
//     - Added -t option to include static symbols
//		13 May 96	Raymond Chen
//     - Version 6.01: Fix underflow bug if group consists entirely of
//                     unused line numbers.
//     - Version 6.02: Fix overflow bug if symbol exceeds 127 chars.
//                     (The limit is theoretically 255, but hdr.exe barfs
//                     if more than 127)
//

#include <ctype.h>
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include "mapsym.h"
#include <common.ver>

#define ZEROLINEHACK            // suppress N386 generated 0 line numbers

// Globals
int cbOffsets = CBOFFSET;
int cbMapOffset = 4;

FILE *mapfh;
char MapfhBuf[OURBUFSIZ];
char achMapfn[512];
char *pszMapfn;         /* MAP input file */

FILE *exefh;
char ExefhBuf[OURBUFSIZ];
char *pszExefn;         /* PE EXE input file */

FILE *outfh;
char OutfhBuf[OURBUFSIZ];
char achOutfn[512];
char *pszOutfn;         /* sym or PE EXE output file */

char Buf[MAPBUFLEN];
char achZeroFill[128];

char fLogo = 1;         /* set if want logo */
char f32BitMap;         /* set if map created by link32.exe */
char fMZMap;            /* set if map created from old exe map */
char fList;         /* set if want to see stuff */
char fLine = 1;         /* set if want line number info */
char fAlpha;            /* set if want alpha symbol sort */
char fDebug;            /* debug flag */
char fEdit;         /* NTSD hack flag */
char fModname;          /* set if force module name override */
char fQuiet;            /* suppress module name warning */
char fStatic;           /* set if want static symbols */

int fByChar;            /* getc()/fgetl() flag */
int cLine;          /* map file line counter */
int cSeg;           /* number of Segments in map */
int iSegLast;
unsigned SegVal;
unsigned uVal;
unsigned long ulCost;       /* Count of stricmp()'s for sorting */
unsigned long ulVal;
unsigned long cbSymFile;

extern struct seg_s *SegTab[];
struct sym_s *pAbs;     /* pointer to constant chain */
struct sym_s *pAbsLast;     /* pointer to last constant */
struct map_s *pMap;
struct endmap_s *pMapEnd;
union linerec_u LineRec[MAXLINENUMBER];
struct seg_s *SegTab[MAXSEG];

/* Indices into a MAP file line for various fields of interest. */
/* The first list doesn't change with maps produced by LINK vs. LINK32 */

#define IB_SEG          1
#define IB_SYMOFF       6
#define IB_SEGSIZE      15      // size position for 16 bit MZ and 32 bit PE/NE
#define IB_SEGSIZE_NE16 11
#define IB_GROUPNAME    10
#define IB_ENTRYSEG     23
#define IB_ENTRYOFF     28

/*
 * The next list changes based upon the type of map produced.  Values
 * for 16-bit maps are given, IB_ADJUST32 must be added for 32-bit maps.
 */

#define IB_SYMTYPE      12
#define IB_SYMNAME      17
#define IB_SEGNAME      22

char *pBufSegSize = &Buf[IB_SEGSIZE];

#define IB_ADJUST32 4   /* adjustment to above indices for 32-bit maps */

char *pBufSymType = &Buf[IB_SYMTYPE];
char *pBufSymName = &Buf[IB_SYMNAME];
char *pBufSegName = &Buf[IB_SEGNAME];


/* Tag strings */

char achEntry[] = "entry point at";
char achLength[] = "Length";
char achLineNos[] = "Line numbers for";
char achOrigin[] = "Origin";
char achPublics[] = "Publics by Valu";
char achStart[] = " Start ";            /* blanks avoid matching module name */
char achStatic[] = " Static symbols";
char achFixups[] = "FIXUPS:";

char achStartMZ[] = " Start  Stop   Length";    /* 16-bit "MZ" old exe */
char achStartNE[] = " Start     Length";        /* 16-bit "NE" new exe */
char achStartPE[] = " Start         Length";    /* 32-bit "PE" */

int alignment = 16;                     /* global alignment value for map */

/* function prototypes */
int             parsefilename(char *pfilename, char *pbuf);
struct map_s*   BuildMapDef(char *mapname, char *buf);
void            BuildSegDef(void);
void            BuildGroupDef(void);
void            BuildLineDef(void);
int             getlineno(void);
unsigned long   getoffset(void);
void            FixLineDef(void);
void            TruncateLineDef(struct line_s *pli, unsigned long ulnext);
void            BuildStaticSyms(void);
void            BuildSymDef(void);
void            WriteSym(void);
int             WriteMapRec(void);
void            WriteSegRec(int i);
void            WriteLineRec(int i);
void            ReadMapLine(void);
void            RedefineSegDefName(unsigned segno, char *segname);
void            WriteOutFile(void *src, int len);
void            WriteSyms(struct sym_s *psy, unsigned csym,
                          unsigned char symtype, unsigned long symbase, char *segname);
struct sym_s*   sysort(struct sym_s *psylist,unsigned csy);
struct sym_s*   sysplit(struct sym_s *psyhead, register unsigned csy);
struct sym_s*   symerge(struct sym_s *psy1, struct sym_s *psy2);
struct sym_s*   sysorted(struct sym_s **ppsyhead);
int             fgetl(char *pbuf, int len, struct _iobuf *fh);
int             NameLen(char *p);
int             HexTouVal(char *p);
int             HexToulVal(char *p);
int             CharToHex(int c);
int             rem_align(unsigned long foo);
int             align(int foo);
void            logo(void);
void            usage(void);
void            xexit(int rc);
int             BuildLineRec1or2(struct line_s* pli, int (*pfngetlineno)(void),
                                 unsigned long (*pfngetoffset)(void));
char*           Zalloc(unsigned int cb);
void            AddSegDef(unsigned int segno, unsigned long segsize,
                          char *segname);
void            AddAbsDef(char *symname);
void            AddSymDef(struct seg_s *pse, char *symname, int fSort);
int             NameSqueeze(char *p);
struct line_s*  AllocLineDef(char *filename, unsigned cbname);
void            AddLineDef(struct line_s *pli, unsigned long lcb);
unsigned long   salign(unsigned long foo);
void            __cdecl error(char *fmt, ...);
void            __cdecl errorline(char *fmt, ...);
int __cdecl     cmpoffset(union linerec_u* plr1, union linerec_u* plr2);


// main

void
_cdecl
main(
    int argc,
    char** argv
    )
{
    char* p;
    int i, rc, chswitch;
    char fentry;                    /* true if entry point was found */
    unsigned long entryp;

    /* process options */

    while (argc > 1 && ((chswitch = *(p = argv[1])) == '-' || *p == '/')) {
        argc--, argv++;
        if (strcmp(&p[1], "nologo") == 0) {
            if (chswitch == '/') {
                usage();                // only allow '/' on old switches
            }
            fLogo = 0;
            continue;
        }
        while (*++p) {
            if (chswitch == '/' && strchr("adlLnNsS", *p) == NULL) {
                usage();                // only allow '/' on old switches
            }
            switch (*p) {
                case 'o':
                    if (pszOutfn || p[1] || argc < 3) {
                        usage();
                    }
                    pszOutfn = argv[1];
                    argc--, argv++;
                    break;

                case 'a':
                    fAlpha = MSF_ALPHASYMS;
                    break;

                case 'd':  fList++;   fDebug++;    break;
                case 'e':             fEdit++;     break;
                case 'l':
                case 'L':  fList++;     break;
                case 'm':             fModname++;  break;
                case 'q':             fQuiet++;    break;
                case 'n':
                case 'N':  fLine = 0;   break;
                case 's':
                case 'S':  break; // Default
                case 't':
                case 'T':  fStatic++;   break;
                default:   usage(); break;
            }
        }
    }
    logo();

    if (argc < 2) {                     /* must have at least one argument */
        usage();
    } else if (argc > 2) {              /* If extra arguments */
        fprintf(stderr, "Warning: ignoring \"%s", argv[2]);
        for (i = 3; i < argc; i++) {
            fprintf(stderr, " %s", argv[i]); /* Print ignored arguments */
        }
        fprintf(stderr, "\"\n");
    }
    argv++;                             /* point to filename arg */

    /* create .sym file name */
    if (pszOutfn == NULL) {
        parsefilename(*argv, achOutfn);
        strcat(pszOutfn = achOutfn, ".sym");

    }

    /* create .map file name */
    strcpy(pszMapfn = achMapfn, *argv);
    if (!parsefilename(pszMapfn, NULL)) {               /* if no extension */
        strcat(pszMapfn, ".Map");
    }

    if (fList) {
        printf("Building %s from %s\n", pszOutfn, pszMapfn);

    }
    if (fLine)
        printf("Line number support enabled\n");
    else
        printf("Line number support disabled\n");

    if (fAlpha) {
        printf("Alphabetic sort arrays included in SYM file\n");
        cbOffsets = 2 * CBOFFSET;
    }

    /* initialize MAP */

    pMapEnd = (struct endmap_s *) Zalloc(sizeof(struct endmap_s));
    pMapEnd->em_ver = MAPSYM_VERSION;           /* version */
    pMapEnd->em_rel = MAPSYM_RELEASE;           /* release */


    // see if input file is a map or coff debug info

    if ((exefh = fopen(pszMapfn, "rb")) == NULL) {
        error("can't open input file: %s", pszMapfn);
        xexit(1);
    }
    setvbuf(exefh, ExefhBuf, _IOFBF, OURBUFSIZ);

    if ((outfh = fopen(pszOutfn, "wb")) == NULL) {
        error("can't create: %s", pszOutfn);
        xexit(1);
    }
    setvbuf(outfh, OutfhBuf, _IOFBF, OURBUFSIZ);

    fclose(exefh);
    if ((mapfh = fopen(pszMapfn, "r")) == NULL) {
        error("can't open input file: %s", pszMapfn);
        xexit(1);
    }
    setvbuf(mapfh, MapfhBuf, _IOFBF, OURBUFSIZ);


    // Skip possible extraneous text at the start of the map file
    // Map file module names have a space in the first column,
    // extraneous text does not.  The module name may not exist,
    // so stop at achStart.
    //    "Stack Allocation = 8192 bytes"       ; extraneous
    //    " modname"                            ; module name
    //    " Start ..."                          ; begin segment list

    do {
        ReadMapLine();     /* read possible module name */
    } while (Buf[0] != ' ');

    // If at achStart, no module name was found.
    // Don't call ReadMapLine() again; BuildSegDef needs achStart
    if (strstr(Buf, achStart) == Buf) {
        pMap = BuildMapDef(pszMapfn, "");
    } else {
        pMap = BuildMapDef(pszMapfn, Buf);
        ReadMapLine();     /* read next line of map file */
    }
    BuildSegDef();         /* build segment definitions */
    BuildGroupDef();       /* build group definitions */
    BuildSymDef();         /* build symbol definitions */

    fentry = 0;

    do {
        if (strstr(Buf, achLineNos)) {
            if (fLine) {
                BuildLineDef();
            }
        } else if (strstr(Buf, achEntry)) {
            if (HexToulVal(&Buf[IB_ENTRYOFF]) < 4) {
                errorline("invalid entry offset");
                xexit(4);
            }
            entryp = ulVal;
            if (!HexTouVal(&Buf[IB_ENTRYSEG])) {
                errorline("invalid entry segment");
                xexit(4);
            }
            pMap->mp_mapdef.md_segentry = (unsigned short)uVal;
            fentry++;
        } else if (strstr(Buf, achStatic) && fStatic) {
            BuildStaticSyms();
        }
    } while (fgetl(Buf, MAPBUFLEN, mapfh));

    if (fentry) {
        printf("Program entry point at %04x:%04lx\n",
               pMap->mp_mapdef.md_segentry,
               entryp);
    } else {
        printf("No entry point, assume 0000:0100\n");
    }
    fclose(mapfh);

    rc = 0;
    WriteSym();             /* write out .SYM file */
    fflush(outfh);
    if (ferror(outfh)) {
        error("%s: write error", pszOutfn);
        rc++;
    }
    fclose(outfh);
    exit(rc);
}


/*
 *      parsefilename - Copy pfilename without path or extension
 *              into pbuf (if pbuf != NULL)
 *
 *      returns non-zero value if extension existed.
 */

int
parsefilename(
             char *pfilename,
             char *pbuf
             )
{
    char *p1, *p2;

    p1 = pfilename;
    if (isalpha(*p1) && p1[1] == ':') {
        p1 += 2;               /* skip drive letter if specified */
    }
    while (p2 = strpbrk(p1, "/\\")) {
        p1 = p2 + 1;            /* skip pathname if specified */
    }
    if (pbuf) {
        strcpy(pbuf, p1);
        if (p2 = strrchr(pbuf, '.')) {
            *p2 = '\0';          /* eliminate rightmost . and any extension */
        }
    }
    return(strchr(p1, '.') != NULL);
}


struct map_s*
    BuildMapDef(
               char* mapname,
               char* buf
               ) {
    unsigned cbname;
    struct map_s *pmp;
    char *pszname;
    char namebuf1[MAPBUFLEN];   // module name from map/exe file name
    char namebuf2[MAPBUFLEN];   // module name from map/exe file contents

    pszname = namebuf1;
    parsefilename(mapname, pszname);

    while (*buf == ' ' || *buf == '\t') {
        buf++;
    }
    if (cbname = strcspn(buf, " \t")) {
        buf[cbname] = '\0';
    }
    if (*buf) {
        parsefilename(buf, namebuf2);
        if (_stricmp(pszname, namebuf2)) {
            if (fModname) {
                pszname = namebuf2;     // use module name from file contents
                if (fList) {
                    printf("using \"%s\" for module name\n", pszname);
                }
            } else if (!fQuiet) {
                errorline("Warning: input file uses \"%s\" for module name, not \"%s\"",
                          namebuf2,
                          pszname);
            }
        }
    } else if (fModname) {
        errorline("Warning: No module name found; using \"%s\" for module name", pszname);
    }

    _strupr(pszname);
    cbname = NameLen(pszname);
    pmp = (struct map_s *) Zalloc(sizeof(struct map_s) + cbname);

    pmp->mp_mapdef.md_abstype = fAlpha;
    pmp->mp_mapdef.md_cbname = (char) cbname;
    strcpy((char *) pmp->mp_mapdef.md_achname, pszname);
    return(pmp);
}


void
BuildSegDef(void)
{
    int i;
    int fDup;

    fDup = 0;
    while (strstr(Buf, achStart) != Buf) {
        ReadMapLine();
    }

    if (strstr(Buf, achStartPE) == Buf) {
        f32BitMap++;
        pBufSymType += IB_ADJUST32;
        pBufSymName += IB_ADJUST32;
        pBufSegName += IB_ADJUST32;
        cbMapOffset += IB_ADJUST32;
        if (fList) {
            printf("32-bit PE map\n");
        }
    } else if (strstr(Buf, achStartMZ) == Buf) {
        fMZMap++;
        if (fList) {
            printf("16-bit MZ map\n");
        }
    } else if (strstr(Buf, achStartNE) == Buf) {
        pBufSegSize = &Buf[IB_SEGSIZE_NE16];
        if (fList) {
            printf("16-bit NE map\n");
        }
    } else {
        errorline("unrecognized map type");
        xexit(4);
    }

    ReadMapLine();

    /* here comes the correction for a small change in PE map files.
       This program's map file parser expects a certain
        map-file layout. Especially it assumes that token start at
        fixed, predefined columns. Well, the "segment name column"
        has changed (one column to the left) and now we try to find out
        if the current mapfile is such a beast.
        !!!!! We make here the assumption that the segment definition
        !!!!! immediately starts behind the "Start  Len" line.

    */

    if (f32BitMap && (*(pBufSegName-1) != ' '))
        pBufSegName--;

    do {
        if (HexToulVal(pBufSegSize) < 4) {
            ulVal = 0;                  // ulVal is the segment size
        }
        if (HexTouVal(&Buf[IB_SEG])) {
            if (cSeg > 0) {
                for (i = 0; i < cSeg; i++) {
                    if ((fDup = (SegTab[i]->se_segdef.gd_lsa == uVal))) {
                        if (SegTab[i]->se_cbseg == 0 && ulVal != 0) {
                            RedefineSegDefName(i, pBufSegName);
                            SegTab[i]->se_cbseg = ulVal;
                        }
                        break;
                    }
                }
            }
            if (!fDup) {
                AddSegDef(uVal, ulVal, pBufSegName);
            }
        }
        ReadMapLine();
    } while (strstr(Buf, achOrigin) != &Buf[1] &&
             strstr(Buf, achPublics) == NULL &&
             strstr(Buf, achEntry) == NULL);

}


void
BuildGroupDef(void)
{
    int i;
    int fRedefine;
    int fDup;

    /* find "origin-group" label in map file which precedes the group list */

    while (strstr(Buf, achOrigin) != &Buf[1]) {
        if (strstr(Buf, achPublics) || strstr(Buf, achEntry)) {
            return;
        }
        ReadMapLine();
    }

    ReadMapLine();

    /* read in group definitions while they exist */

    while (HexTouVal(&Buf[IB_SEG])) {

        /* if not the FLAT group in a link32 map */

        if (fMZMap || uVal || _stricmp(&Buf[IB_GROUPNAME], "FLAT")) {

            fRedefine = 0;

            /* search through segment table for group address */

            for (i = 0; i < cSeg; i++) {
                if (SegTab[i]->se_segdef.gd_lsa == uVal &&
                    SegTab[i]->se_redefined == 0) {

                    RedefineSegDefName(i, &Buf[IB_GROUPNAME]);
                    SegTab[i]->se_redefined = 1;
                    fRedefine++;
                    break;
                }
            }
            if (!fRedefine) {
                for (i = 0; i < cSeg; i++) {
                    fDup = (SegTab[i]->se_segdef.gd_lsa == uVal);
                    if (fDup) {
                        break;
                    }
                }
                if (!fDup) {
                    AddSegDef(uVal, 0L, &Buf[IB_GROUPNAME]);
                }
            }
        }
        ReadMapLine();
    }
}


void
BuildLineDef(void)
{
    struct line_s *pli;
    int cbname;
    int cblr;
    int i;
    char *p;

    /* make sure that there is a source file in parentheses */

    p = pBufSymName;
    while (*p && *p != LPAREN) {
        p++;
    }

    if (*p == LPAREN) {
        i = (int)(p - pBufSymName + 1);        // index start of source file name
    } else {                    /* else no source file, return .obj name */
        if (p = strrchr(pBufSymName, '.')) {
            *p = '\0';          /* throw away ".obj" */
        }
        i = 0;                  /* point to .obj name */
    }
    cbname = NameSqueeze(&pBufSymName[i]);// Squeeze \\, convert /'s to \'s
    pli = AllocLineDef(&pBufSymName[i], cbname);  // pass source name

    // clear line record array; any entry with a line number of zero is empty

    memset(LineRec, 0, sizeof(LineRec));

    /* process line numbers */

    cblr = BuildLineRec1or2(pli, getlineno, getoffset);

    if (cblr) {
        /* size is size of linedef_s + name size + size of line recs */
        AddLineDef(pli, sizeof(struct linedef_s) + cbname + cblr);
    }
}


struct line_s*
    AllocLineDef(
                char* filename,
                unsigned cbname
                ) {
    struct line_s* pli;

    if (pMap->mp_mapdef.md_cbnamemax < (char) cbname) {
        pMap->mp_mapdef.md_cbnamemax = (char) cbname;
    }
    pli = (struct line_s *) Zalloc(sizeof(struct line_s) + cbname);
    pli->li_linedef.ld_cbname = (char) cbname;
    strcpy((char *) pli->li_linedef.ld_achname, filename);
    return(pli);
}


void
AddLineDef(
          struct line_s *pli,
          unsigned long lcb
          )
{
    int i;
    struct seg_s *pse;
    struct seg_s *pselast = 0;
    struct line_s **ppli;
    struct linerec0_s *plr0;
    struct linerec1_s *plr1;
    struct linerec2_s *plr2;
    unsigned long ulfixup;

    /*
     * The linker puts out all the line number information logical segment
     * relative instead of group or physical segment relative unlike the
     * symbol information.  The map file doesn't contain any group member
     * information on the segment so we assume that segments that don't
     * have any symbols belong to last segment that contains symbols.
     * Note that it's possible that *no* segments contain symbols, so
     * care must be taken to ensure that we don't use something that
     * doesn't exist.
     */

    for (i = 0; i < cSeg; i++) {

        /*
         * Save away the last segment table entry that has symbols
         * we are assuming this is the group the segment belongs to.
         */

        if (SegTab[i]->se_psy) {
            pselast = SegTab[i];
        }

        /*
         * Check if the segment table entry matches the segment value
         * gotten from the line number information.  The segment value
         * is segment relative instead of group relative so we may use
         * the last segment with symbols.
         */

        if (SegTab[i]->se_segdef.gd_lsa == SegVal) {
            pse = SegTab[i];

            /*
             * If the segment we just found doesn't have any symbols,
             * we will add the line number info to the last segment
             * saved away that did have symbols (pselast).
             */

            if (pse->se_psy || !pselast) {

                /*
                 * No fixup when the segment has symbols since it is the
                 * "group" and all the code offsets in the line recs are
                 *  relative to it. This is also the case if we haven't found
                         * a segment yet that has symbols.
                 */

                ulfixup = 0;
            } else {

                /*
                 * Calculate the amount each line record will have to be
                 * fixed up by since these linerecs' code offsets are
                 * segment relative instead of group relative like the
                 * symbol info.
                 */
                ulfixup = ((unsigned long)
                           (pse->se_segdef.gd_lsa - pselast->se_segdef.gd_lsa)) << 4;
                pse = pselast;
            }
            break;
        }
    }

    if (i >= cSeg) {
        error("AddLineDef: segment table search failed");
        xexit(4);
    }

    /* if there is a fixup, add it to each line record's code offset */

    if (ulfixup) {
        i = pli->li_linedef.ld_cline;
        switch (pli->li_linedef.ld_itype) {
            case 0:
                plr0 = &pli->li_plru->lr0;
                while (i) {
                    plr0->lr0_codeoffset += (unsigned short)ulfixup;
                    plr0++, i--;
                }
                break;
            case 1:
                plr1 = &pli->li_plru->lr1;
                while (i) {
                    plr1->lr1_codeoffset += (unsigned short)ulfixup;
                    plr1++, i--;
                }
                break;
            case 2:
                plr2 = &pli->li_plru->lr2;
                while (i) {
                    plr2->lr2_codeoffset += ulfixup;
                    plr2++, i--;
                }
                break;
        }
    }

    /*
     * if there was a last segment,
     * add the linedef_s to the segment linedef_s chain
     */

    if (pse) {
        ppli = &pse->se_pli;
        while (*ppli && (*ppli)->li_offmin < pli->li_offmin) {
            ppli = &(*ppli)->li_plinext;
        }
        pli->li_plinext = *ppli;
        *ppli = pli;

        /* adjust table sizes for linedef_s record and line numbers */

        pli->li_cblines = lcb;
    }
}


int
__cdecl
cmpoffset(
         union linerec_u* plr1,
         union linerec_u* plr2
         )
{
    if (fDebug > 1) {
        printf("comparing %08lx line %u with %08lx line %u",
               plr1->lr2.lr2_codeoffset,
               plr1->lr2.lr2_linenumber,
               plr2->lr2.lr2_codeoffset,
               plr2->lr2.lr2_linenumber);
    }
    if (plr1->lr2.lr2_codeoffset < plr2->lr2.lr2_codeoffset) {
        if (fDebug > 1) {
            printf(": -1\n");
        }
        return(-1);
    }
    if (plr1->lr2.lr2_codeoffset > plr2->lr2.lr2_codeoffset) {
        if (fDebug > 1) {
            printf(": 1\n");
        }
        return(1);
    }
    if (fDebug > 1) {
        printf(": 0\n");
    }
    return(0);
}


int
BuildLineRec1or2(
                struct line_s* pli,
                int (*pfngetlineno)(void),
                unsigned long (*pfngetoffset)(void)
                )
{
    register union linerec_u *plru;
    register unsigned short lineno;
    unsigned long offval, offmin, offmax;
    int clr;
    int ilr, ilrmax;
    int cblr;
    char f32 = 0;

    /* read line numbers */

    ilrmax = clr = 0;                   /* count of line records */
    fByChar = 1;                        /* compensate for unread new-line */
    while (lineno = (unsigned short)(*pfngetlineno)()) {

        offval = (*pfngetoffset)();

#ifdef ZEROLINEHACK
        if (lineno == (unsigned short) -1) {
            continue;
        }
#endif
        /*
         * Check for too many line numbers.  Caller will skip
         * the rest (so we don't have to waste time parsing them).
         */

        if (lineno >= MAXLINENUMBER) {
            errorline("too many line numbers in %s, truncated to %d",
                      pli->li_linedef.ld_achname, MAXLINENUMBER);
            break;
        }

        if (fDebug > 1) {
            printf(   "%s: line %hu @%lx\n",
                      pli->li_linedef.ld_achname,
                      lineno,
                      offval);
        }

        /*
         * If any of the offsets are 32 bits, clear the 16 bit flag so
         * 32 bit line recs will be generated.
         */

        if (offval & 0xffff0000L) {
            f32 = 1;
        }
        if (ilrmax < lineno) {
            ilrmax = lineno;
        }

        /*
         * Only update the count if the line number has not already been read.
         */

        if (LineRec[lineno].lr2.lr2_linenumber == 0) {
            clr++;
        }

        /*
         * Put the line info away in 32 bit format, but we will copy it
         * to 16 bit format if none of the offsets are 32 bit.
         */

        LineRec[lineno].lr2.lr2_codeoffset = offval;
        LineRec[lineno].lr2.lr2_linenumber = lineno;
    }

    /*
     * If a segment consists only of unused line numbers, then
     * there is nothing to do.  Stop now, or we will barf big time
     * trying to allocate memory for nothing (and even worse, trying
     * to sort 0 - 1 = 4 billion elements).
     */
    if (clr == 0) {
        return 0;
    }

    /* get size of line record */

    if (f32) {
        cblr = clr * sizeof(struct linerec2_s);
        pli->li_linedef.ld_itype = 2;
    } else {
        cblr = clr * sizeof(struct linerec1_s);
        pli->li_linedef.ld_itype = 1;
    }
    pli->li_linedef.ld_cline = (unsigned short) clr;

    /* allocate space for line numbers */

    pli->li_plru = (union linerec_u *) Zalloc(cblr);

    // compress out unused line numbers, then sort by offset
    ilr = 0;
    offmin = 0xffffffff;
    offmax = 0;
    for (lineno = 0; lineno <= ilrmax; lineno++) {
        if (LineRec[lineno].lr2.lr2_linenumber) {
            offval = LineRec[lineno].lr2.lr2_codeoffset;
            if (offmin > offval) {
                offmin = offval;
            }
            if (offmax < offval) {
                offmax = offval;
            }
            if (fDebug > 1) {
                printf("copying %08lx line %u\n",
                       offval,
                       LineRec[lineno].lr2.lr2_linenumber);
            }
            LineRec[ilr++] = LineRec[lineno];
        }
    }
    pli->li_offmin = offmin;
    pli->li_offmax = offmax;
    ilrmax = ilr - 1;
    if (ilrmax != clr - 1) {
        error("line count mismatch: %u/%u", ilrmax, clr - 1);
    }

    // Sort the line numbers
    qsort((void *)LineRec, (size_t)ilrmax, sizeof(LineRec[0]),
          (int (__cdecl *)(const void *, const void *))cmpoffset);

    /* convert and copy line number information */
    for (lineno = 0, plru = pli->li_plru; lineno <= ilrmax; lineno++) {
        if (f32) {
            memcpy(plru, &LineRec[lineno], sizeof(struct linerec2_s));
            (unsigned char *) plru += sizeof(struct linerec2_s);
        } else {
            plru->lr1.lr1_codeoffset =
            (unsigned short) LineRec[lineno].lr2.lr2_codeoffset;
            plru->lr1.lr1_linenumber = LineRec[lineno].lr2.lr2_linenumber;
            (unsigned char *) plru += sizeof(struct linerec1_s);
        }
    }
    fByChar = 0;
    return(cblr);
}


/*
 *      getlineno - get a decimal source file line number,
 *              ignoring leading tabs, blanks and new-lines.
 */

int
getlineno(void)
{
    register int num = 0;
    register int c;

    do {
        if ((c = getc(mapfh)) == '\n') {
            cLine++;
        }
    } while (isspace(c));

    if (isdigit(c)) {
        do {
            num = num * 10 + c - '0';
            c = getc(mapfh);
        } while (isdigit(c));
#ifdef ZEROLINEHACK
        if (num == 0) {
            num = -1;
        }
#endif
    } else {
        ungetc(c, mapfh);
    }
    return(num);
}


unsigned long
getoffset(void)
{
    register int i;
    register int num;
    unsigned long lnum;

    num = 0;
    for (i = 4; i > 0; i--) {
        num = (num << 4) + CharToHex(getc(mapfh));
    }
    SegVal = num;

    if (getc(mapfh) != ':') {           /* skip colon */
        errorline("expected colon");
        xexit(4);
    }

    lnum = 0;
    for (i = cbMapOffset; i > 0; i--) {
        lnum = (lnum << 4) + (unsigned long) CharToHex(getc(mapfh));
    }
    return(lnum);
}


unsigned long ulmind;
unsigned long ulmaxd;

void
FixLineDef(void)
{
    int i;
    struct line_s *pli;

    for (i = 0; i < cSeg; i++) {
        ulmind = (unsigned long) -1;
        ulmaxd = 0;
        if (pli = SegTab[i]->se_pli) {
            while (pli) {
                if (fDebug) {
                    printf("%s: (%d: %lx - %lx)",
                           pli->li_linedef.ld_achname,
                           pli->li_linedef.ld_cline,
                           pli->li_offmin,
                           pli->li_offmax);
                }
                TruncateLineDef(pli,
                                pli->li_plinext == NULL?
                                pli->li_offmax + 1 :
                                pli->li_plinext->li_offmin);
                if (fDebug) {
                    printf(" (%d: %lx - %lx)\n",
                           pli->li_linedef.ld_cline,
                           pli->li_offmin,
                           pli->li_offmax);
                }
                pli = pli->li_plinext;
            }
        }
        if (fList && (ulmaxd || ulmind != (unsigned long) -1)) {
            printf("Ignoring extraneous line records for Seg %d, offsets %lx - %lx\n",
                   i + 1,
                   ulmind,
                   ulmaxd);
        }
    }
}


void
TruncateLineDef(
               struct line_s *pli,
               unsigned long ulnext
               )
{
    int i, clines;
    union linerec_u *plru, *plrudst;
    unsigned long ulmindel, ulmaxdel, ulmax;

    ulmindel = (unsigned long) -1;
    ulmax = ulmaxdel = 0;
    clines = i = pli->li_linedef.ld_cline;
    plru = plrudst = pli->li_plru;
    if (fDebug > 1) {
        printf("\n");
    }
    switch (pli->li_linedef.ld_itype) {
        case 1:
            while (i-- > 0) {
                if (ulnext <= plru->lr1.lr1_codeoffset) {
                    if (fDebug > 1) {
                        printf("delete1: %04lx %03d\n",
                               plru->lr1.lr1_codeoffset,
                               plru->lr1.lr1_linenumber);
                    }
                    if (ulmindel > plru->lr1.lr1_codeoffset) {
                        ulmindel = plru->lr1.lr1_codeoffset;
                    }
                    if (ulmaxdel < plru->lr1.lr1_codeoffset) {
                        ulmaxdel = plru->lr1.lr1_codeoffset;
                    }
                    clines--;
                } else {
                    if (fDebug > 1) {
                        printf("keep1:   %04lx %03d\n",
                               plru->lr1.lr1_codeoffset,
                               plru->lr1.lr1_linenumber);
                    }
                    if (ulmax < plru->lr1.lr1_codeoffset) {
                        ulmax = plru->lr1.lr1_codeoffset;
                    }
                    plrudst->lr1.lr1_codeoffset = plru->lr1.lr1_codeoffset;
                    plrudst->lr1.lr1_linenumber = plru->lr1.lr1_linenumber;
                    (unsigned char *) plrudst += sizeof(struct linerec1_s);
                }
                (unsigned char *) plru += sizeof(struct linerec1_s);
            }
            break;

        case 2:
            while (i-- > 0) {
                if (ulnext <= plru->lr2.lr2_codeoffset) {
                    if (fDebug > 1) {
                        printf("delete2: %04x %03d\n",
                               plru->lr2.lr2_codeoffset,
                               plru->lr2.lr2_linenumber);
                    }
                    if (ulmindel > plru->lr2.lr2_codeoffset) {
                        ulmindel = plru->lr2.lr2_codeoffset;
                    }
                    if (ulmaxdel < plru->lr2.lr2_codeoffset) {
                        ulmaxdel = plru->lr2.lr2_codeoffset;
                    }
                    clines--;
                } else {
                    if (fDebug > 1) {
                        printf("keep2:   %04x %03d\n",
                               plru->lr2.lr2_codeoffset,
                               plru->lr2.lr2_linenumber);
                    }
                    if (ulmax < plru->lr2.lr2_codeoffset) {
                        ulmax = plru->lr2.lr2_codeoffset;
                    }
                    plrudst->lr2.lr2_codeoffset = plru->lr2.lr2_codeoffset;
                    plrudst->lr2.lr2_linenumber = plru->lr2.lr2_linenumber;
                    (unsigned char *) plrudst += sizeof(struct linerec2_s);
                }
                (unsigned char *) plru += sizeof(struct linerec2_s);
            }
            break;

        default:
            error("bad line record type");
            xexit(1);
    }
    pli->li_linedef.ld_cline = (unsigned short) clines;
    pli->li_offmax = ulmax;
    if (fDebug) {
        printf(" ==> (%lx - %lx)", ulmindel, ulmaxdel);
    }
    if (ulmind > ulmindel) {
        ulmind = ulmindel;
    }
    if (ulmaxd < ulmaxdel) {
        ulmaxd = ulmaxdel;
    }
}


void
BuildStaticSyms(void)
{
    int i;
    struct seg_s *pse;

    /* search for publics or entry point */

    for (;;) {
        if (strstr(Buf, achStatic)) {
            ReadMapLine();
            break;
        } else if (strstr(Buf, achFixups)) {
            return; // no static symbols
        } else {
            ReadMapLine();
        }
    }

    do {
        if (Buf[0] == '\0') {
            fgetl(Buf, MAPBUFLEN, mapfh);
        }
        if (strstr(Buf, achFixups) || strstr(Buf, achLineNos)) {
            break;
        }
        if (Buf[0] != ' ') {
            errorline("unexpected input ignored");
            break;
        }
        if (*pBufSymType == ' ' || *pBufSymType == 'R') {
            if (   !HexTouVal(   &Buf[   IB_SEG])) {
                errorline("invalid segment");
                xexit(4);
            }
            pse = NULL;
            for (i = 0; i < cSeg; i++) {
                if (SegTab[i]->se_segdef.gd_lsa == uVal) {
                    pse = SegTab[i];
                    break;
                }
            }
            if (i >= cSeg) {
                /*
                 *  For some reason, a new C compiler puts information about
                 *  imported modules in the symbol section of the map file.
                 *  He puts those in segment "0", so ignore any lines that
                 *  say they are for segment 0.
                 */
                if (uVal == 0) {
                    continue;   /* this will execute the "while" condition */
                }
                errorline("BuildSymDef: segment table search failed");
                xexit(4);
            }
            if (HexToulVal(&Buf[IB_SYMOFF]) != cbMapOffset) {
                errorline("invalid offset");
                xexit(4);
            }
            AddSymDef(pse, pBufSymName, TRUE);
        }
    } while (fgetl(Buf, MAPBUFLEN, mapfh));
}


void
BuildSymDef(void)
{
    int i;
    struct seg_s *pse;

    /* search for publics or entry point */

    for (;;) {
        if (strstr(Buf, achPublics)) {
            ReadMapLine();
            break;
        } else if (strstr(Buf, achEntry)) {
            error("no public symbols. - Re-link file with /map switch!");
            xexit(4);
        } else {
            ReadMapLine();
        }
    }

    do {
        if (Buf[0] == '\0') {
            fgetl(Buf, MAPBUFLEN, mapfh);
        }
        if (strstr(Buf, achEntry) || strstr(Buf, achLineNos)) {
            break;
        }
        if (Buf[0] != ' ') {
            errorline("unexpected input ignored");
            break;
        }
        if (*pBufSymType == ' ' || *pBufSymType == 'R') {
            if (!HexTouVal(&Buf[IB_SEG])) {
                errorline("invalid segment");
                xexit(4);
            }
            pse = NULL;
            for (i = 0; i < cSeg; i++) {
                if (SegTab[i]->se_segdef.gd_lsa == uVal) {
                    pse = SegTab[i];
                    break;
                }
            }
            if (i >= cSeg) {
                /*
                 *  For some reason, a new C compiler puts information about
                 *  imported modules in the symbol section of the map file.
                 *  He puts those in segment "0", so ignore any lines that
                 *  say they are for segment 0.
                 */
                if (uVal == 0) {
                    continue;   /* this will execute the "while" condition */
                }
                errorline("BuildSymDef: segment table search failed");
                xexit(4);
            }
            if (HexToulVal(&Buf[IB_SYMOFF]) != cbMapOffset) {
                errorline("invalid offset");
                xexit(4);
            }
            AddSymDef(pse, pBufSymName, FALSE);
        } else if (*pBufSymType != 'I') {       /* else if not an import */
            if (HexToulVal(&Buf[IB_SYMOFF]) != cbMapOffset) {
                errorline("invalid offset");
                xexit(4);
            }
            AddAbsDef(pBufSymName);
        }
    } while (fgetl(Buf, MAPBUFLEN, mapfh));

}


void
AddSegDef(
         unsigned segno,
         unsigned long segsize,
         char *segname
         )
{
    unsigned cbname;
    unsigned cballoc;
    struct seg_s *pse;

    cbname = NameLen(segname);

    /*
     *  We allocate at least MAXNAMELEN so group name replacement
     *  won't step on whoever is next in the heap.
     */

    cballoc = MAXNAMELEN;
    if (cbname > MAXNAMELEN) {
        cballoc = cbname;
    }
    pse = (struct seg_s *) Zalloc(sizeof(struct seg_s) + cballoc);
    pse->se_cbseg = segsize;
    pse->se_segdef.gd_lsa = (unsigned short) segno;
    pse->se_segdef.gd_curin = 0xff;
    pse->se_segdef.gd_type = fAlpha;
    pse->se_segdef.gd_cbname = (char) cbname;
    strcpy((char *) pse->se_segdef.gd_achname, segname);

    if (cSeg >= MAXSEG) {
        errorline("segment table limit (%u) exceeded", MAXSEG);
        xexit(4);
    }
    SegTab[cSeg++] = pse;
}


void
RedefineSegDefName(
                  unsigned segno,
                  char *segname
                  )
{
    register unsigned cbname;

    cbname = NameLen(segname);
    segname[cbname] = '\0';     // make sure it's null terminated

    if (fList) {
        printf("%s (segment/group) redefines %s (segment)\n", segname,
               SegTab[segno]->se_segdef.gd_achname);
    }
    if (cbname > MAXNAMELEN && cbname > SegTab[segno]->se_segdef.gd_cbname) {
        errorline("segment/group name too long: %s", segname);
        xexit(4);
    }
    SegTab[segno]->se_segdef.gd_cbname = (char) cbname;
    strcpy((char *) SegTab[segno]->se_segdef.gd_achname, segname);
}


void
AddAbsDef(
         char *symname
         )
{
    unsigned cbname;
    struct sym_s *psy;

    cbname = NameLen(symname);
    if (pMap->mp_mapdef.md_cbnamemax < (char) cbname) {
        pMap->mp_mapdef.md_cbnamemax = (char) cbname;
    }

    psy = (struct sym_s *) Zalloc(sizeof(struct sym_s) + cbname);
    psy->sy_symdef.sd_lval = ulVal;
    psy->sy_symdef.sd_cbname = (char) cbname;
    strcpy((char *) psy->sy_symdef.sd_achname, symname);

    if (pAbs == NULL) {
        pAbs = psy;
    } else {
        pAbsLast->sy_psynext = psy;
    }
    pAbsLast = psy;

    if (cbname > 8) {
        pMap->mp_cbsymlong += cbname + 1;
    }
    pMap->mp_mapdef.md_cabs++;
    pMap->mp_cbsyms += (unsigned short) cbname;
    if (pMap->mp_mapdef.md_abstype & MSF_32BITSYMS) {
        pMap->mp_cbsyms += CBSYMDEF;
    } else {
        pMap->mp_cbsyms += CBSYMDEF16;
        if ((unsigned long) (unsigned short) ulVal != ulVal) {
            pMap->mp_mapdef.md_abstype |= MSF_32BITSYMS;

            // correct the size of the abs symdefs
            pMap->mp_cbsyms += ((CBSYMDEF-CBSYMDEF16) * pMap->mp_mapdef.md_cabs);
        }
    }
    if (pMap->mp_cbsyms + (pMap->mp_mapdef.md_cabs * cbOffsets) >= _64K) {
        error("absolute symbols too large");
        xexit(4);
    }
}


void
AddSymDef(
         struct seg_s *pse,
         char *symname,
         int fSort
         )
{
    unsigned cbname;
    struct sym_s *psy;
    struct sym_s* psyT;
    struct sym_s* psyPrev;
    int cbsegdef;

    cbname = NameLen(symname);
    if (pMap->mp_mapdef.md_cbnamemax < (char) cbname) {
        pMap->mp_mapdef.md_cbnamemax = (char) cbname;
    }
    psy = (struct sym_s *) Zalloc(sizeof(struct sym_s) + cbname);
    psy->sy_symdef.sd_lval = ulVal;
    psy->sy_symdef.sd_cbname = (char) cbname;
    strcpy((char *) psy->sy_symdef.sd_achname, symname);

    if (fSort) {

        /* Find the symbol just greater (or equal) to this new one */

        psyPrev = NULL;
        for (psyT = pse->se_psy ; psyT ; psyT = psyT->sy_psynext) {
            if (ulVal <= psyT->sy_symdef.sd_lval) {
                break;
            }
            psyPrev = psyT;
        }

        // Now that we've found this spot, link it in.  If the previous item
        // is NULL, we're linking it at the start of the list.  If the current
        // item is NULL, this is the end of the list.

        if (!psyPrev) {
            psy->sy_psynext = pse->se_psy;
            pse->se_psy = psy;
        } else {
            psy->sy_psynext = psyT;
            psyPrev->sy_psynext = psy;
        }
        if (!psyT) {
            pse->se_psylast = psy;
        }
    } else {

        /* insert at end of symbol chain */

        if (pse->se_psy == NULL) {
            pse->se_psy = psy;
        } else {
            pse->se_psylast->sy_psynext = psy;
        }
        pse->se_psylast = psy;
    }

    if (cbname > 8) {
        pse->se_cbsymlong += cbname + 1;
    }
    pse->se_segdef.gd_csym++;
    pse->se_cbsyms += cbname;
    if (pse->se_segdef.gd_type & MSF_32BITSYMS) {
        pse->se_cbsyms += CBSYMDEF;
    } else {
        pse->se_cbsyms += CBSYMDEF16;
        if ((unsigned long) (unsigned short) ulVal != ulVal) {
            pse->se_segdef.gd_type |= MSF_32BITSYMS;

            // correct the size of the symdefs
            pse->se_cbsyms += (CBSYMDEF - CBSYMDEF16) * pse->se_segdef.gd_csym;
        }
    }
    cbsegdef = CBSEGDEF + pse->se_segdef.gd_cbname;
    if (cbsegdef + pse->se_cbsyms >= _64K) {
        pse->se_segdef.gd_type |= MSF_BIGSYMDEF;
    }
}

void
WriteSym(void)
{
    int i;

    while (!WriteMapRec()) {
        if ((pMap->mp_mapdef.md_abstype & MSF_ALIGN_MASK) == MSF_ALIGN_MASK) {
            error("map file too large\n");
            xexit(4);
        }
        pMap->mp_mapdef.md_abstype += MSF_ALIGN32;
        alignment *= 2;
        if (fList) {
            printf("Using alignment: %d\n", alignment);
        }
    }
    for (i = 0; i < cSeg; i++) {
        if (SegTab[i]->se_psy) {
            WriteSegRec(i);
            WriteLineRec(i);
        }
    }
    WriteOutFile(pMapEnd, sizeof(*pMapEnd));    /* terminate MAPDEF chain */
}


int
WriteMapRec(void)
{
    int i;
    int cbmapdef;
    long lcbTotal;
    long lcbOff;
    register struct line_s *pli;
    struct seg_s *pse;

    cbSymFile = 0;
    pMap->mp_mapdef.md_cseg = 0;

    cbmapdef = CBMAPDEF + pMap->mp_mapdef.md_cbname;
    pMap->mp_mapdef.md_pabsoff = cbmapdef + pMap->mp_cbsyms;

    lcbTotal = align(cbmapdef + pMap->mp_cbsyms +
                     (pMap->mp_mapdef.md_cabs * cbOffsets));

    // make sure the map file isn't too large
    if (lcbTotal >= (_64K * alignment)) {
        return(FALSE);
    }
    pMap->mp_mapdef.md_spseg = (unsigned short)(lcbTotal / alignment);
    for (i = 0; i < cSeg; i++) {
        if ((pse = SegTab[i])->se_psy) {

            // calculate the symdef offset array size
            if (pse->se_segdef.gd_type & MSF_BIGSYMDEF) {
                lcbOff = align(pse->se_segdef.gd_csym *
                               (cbOffsets + CBOFFSET_BIG - CBOFFSET));
            } else {
                lcbOff = pse->se_segdef.gd_csym * cbOffsets;
            }
            // calculate the size of the linedefs and linerecs
            pli = pse->se_pli;
            pse->se_cblines = 0;
            while (pli) {
                pse->se_cblines += align(pli->li_cblines);
                pli = pli->li_plinext;
            }
            lcbTotal += align(pse->se_cbsyms + pse->se_cblines +
                              lcbOff + CBSEGDEF + pse->se_segdef.gd_cbname);

            // make sure the map file isn't too large
            if (align(lcbTotal) >= (_64K * alignment)) {
                return(FALSE);
            }
            // One more segment in map file
            pMap->mp_mapdef.md_cseg++;

            // Save away the last segment number
            iSegLast = i;
        }
    }
    // make sure the map file isn't too large
    if (align(lcbTotal) >= (_64K * alignment)) {
        return(FALSE);
    }
    pMap->mp_mapdef.md_spmap = (unsigned short)(align(lcbTotal) / alignment);
    WriteOutFile(&pMap->mp_mapdef, cbmapdef);
    if (fList) {
        printf("%s - %d segment%s\n",
               pMap->mp_mapdef.md_achname,
               pMap->mp_mapdef.md_cseg,
               (pMap->mp_mapdef.md_cseg == 1)? "" : "s");
    }
    // output abs symbols and values, followed by their offsets
    WriteSyms(pAbs,
              pMap->mp_mapdef.md_cabs,
              pMap->mp_mapdef.md_abstype,
              0,
              "<Constants>");

    // return that everything is ok
    return(TRUE);
}


void
WriteSyms(
         struct sym_s *psylist,
         unsigned csym,
         unsigned char symtype,
         unsigned long symbase,
         char *segname
         )
{
    register unsigned cb;
    struct sym_s *psy;
    unsigned short svalue;

    for (psy = psylist; psy; psy = psy->sy_psynext) {
        cb = CBSYMDEF + psy->sy_symdef.sd_cbname;
        if ((symtype & MSF_32BITSYMS) == 0) {
            cb -= CBSYMDEF - CBSYMDEF16;
            svalue = (unsigned short) psy->sy_symdef.sd_lval;
            WriteOutFile(&svalue, sizeof(svalue));
            WriteOutFile(&psy->sy_symdef.sd_cbname, cb - CBSYMDEF16 + 1);
        } else {
            WriteOutFile(&psy->sy_symdef.sd_lval, cb);
        }

        /* save offset to symbol */

        psy->sy_symdef.sd_lval = (cbSymFile - cb) - symbase;
        if ((int)psy->sy_symdef.sd_lval >=
            (symtype & MSF_BIGSYMDEF ? _16MEG : _64K)) {
            error("symbol offset array entry too large");
            xexit(4);
        }
    }

    /* if big group, align end of symbols on segment boundary */

    if (symtype & MSF_BIGSYMDEF) {
        WriteOutFile(achZeroFill, rem_align(cbSymFile));
        cb = CBOFFSET_BIG;
    } else {
        cb = CBOFFSET;
    }

    /* write out the symbol offsets, after the symbols */

    for (psy = psylist; psy; psy = psy->sy_psynext) {
        WriteOutFile(&psy->sy_symdef.sd_lval, cb);
    }

    /* sort alphabetically, and write out the sorted symbol offsets */

    if (fAlpha) {
        psylist = sysort(psylist,csym);
        for (psy = psylist; psy; psy = psy->sy_psynext) {
            WriteOutFile(&psy->sy_symdef.sd_lval, cb);
        }
    }

    if (fList && csym) {
        printf("%-16s %4d %d-bit %ssymbol%s\n",
               segname,
               csym,
               (symtype & MSF_32BITSYMS)? 32 : 16,
               (symtype & MSF_BIGSYMDEF)? "big " : "",
               (csym == 1)? "" : "s");
    }

    /* align end of symbol offsets */

    WriteOutFile(achZeroFill, rem_align(cbSymFile));
}


/*
 *  Merge two symbol lists that are sorted alphabetically.
 */

struct sym_s*
    symerge(
           struct sym_s *psy1,                     /* First list */
           struct sym_s *psy2                      /* Second list */
           ) {
    struct sym_s **ppsytail;            /* Pointer to tail link */
    struct sym_s *psy;
    struct sym_s *psyhead;              /* Pointer to head of result */

    psyhead = NULL;                     /* List is empty */
    ppsytail = &psyhead;                /* Tail link starts at head */
    while (psy1 != NULL && psy2 != NULL) {
        /* While both lists are not empty */
        ulCost++;

        /*
         *  Select the lesser of the two head records
         *  and remove it from its list.
         */
        if (_stricmp((char *) psy1->sy_symdef.sd_achname,
                     (char *) psy2->sy_symdef.sd_achname) <= 0) {
            psy = psy1;
            psy1 = psy1->sy_psynext;
        } else {
            psy = psy2;
            psy2 = psy2->sy_psynext;
        }
        *ppsytail = psy;                /* Insert at tail of new list */
        ppsytail = &psy->sy_psynext;    /* Update tail link */
    }
    *ppsytail = psy1;                   /* Attach rest of 1st list to tail */
    if (psy1 == NULL)
        *ppsytail = psy2;               /* Attach rest of 2nd if 1st empty */
    return(psyhead);                    /* Return pointer to merged list */
}


/*
 *  Find as many records at the head of the list as
 *  are already in sorted order.
 */

struct sym_s*
    sysorted(
            struct sym_s **ppsyhead             /* Pointer to head-of-list pointer */
            ) {
    struct sym_s *psy;
    struct sym_s *psyhead;              /* Head of list */

    /*
     *  Find as many records at the head of the list as
     *  are already in sorted order.
     */
    for (psy = psyhead = *ppsyhead; psy->sy_psynext != NULL; psy = psy->sy_psynext) {
        ulCost++;
        if (_stricmp((char *) psy->sy_symdef.sd_achname,
                     (char *) psy->sy_psynext->sy_symdef.sd_achname) > 0)
            break;
    }
    *ppsyhead = psy->sy_psynext;        /* Set head to point to unsorted */
    psy->sy_psynext = NULL;             /* Break the link */
    return(psyhead);                    /* Return head of sorted sublist */
}


/*
 *  Split a list in two after skipping the specified number
 *  of symbols.
 */

struct sym_s *
    sysplit(
           struct sym_s *psyhead,                  /* Head of list */
           unsigned csy                            /* # to skip before splitting (>=1) */
           ) {
    struct sym_s *psy;
    struct sym_s *psyprev;

    /*
     *  Skip the requested number of symbols.
     */
    for (psy = psyhead; csy-- != 0; psy = psy->sy_psynext) {
        psyprev = psy;
    }
    psyprev->sy_psynext = NULL;         /* Break the list */
    return(psy);                        /* Return pointer to second half */
}


/*
 *  Sort a symbol list of the specified length alphabetically.
 */

struct sym_s*
    sysort(
          struct sym_s *psylist,                  /* List to sort */
          unsigned csy                            /* Length of list */
          ) {
    struct sym_s *psy;
    struct sym_s *psyalpha;             /* Sorted list */

    if (csy >= 32) {                    /* If list smaller than 32 */
        psy = sysplit(psylist,csy >> 1);/* Split it in half */
        return(symerge(sysort(psylist,csy >> 1),sysort(psy,csy - (csy >> 1))));
        /* Sort halves and merge */
    }
    psyalpha = NULL;                    /* Sorted list is empty */
    while (psylist != NULL) {           /* While list is not empty */
        psy = sysorted(&psylist);       /* Get sorted head */
        psyalpha = symerge(psyalpha,psy);
        /* Merge with sorted list */
    }
    return(psyalpha);                   /* Return the sorted list */
}


void
WriteSegRec(
           int i
           )
{
    int cbsegdef;
    int cboff;
    unsigned long segdefbase, ulsymoff, uloff;
    struct seg_s *pse = SegTab[i];

    /* compute length of symbols and segment record */

    cbsegdef = CBSEGDEF + pse->se_segdef.gd_cbname;

    /* set the offset array size */

    cboff = pse->se_segdef.gd_csym * cbOffsets;

    /* set segdef-relative pointer to array of symbol offsets */

    ulsymoff = uloff = cbsegdef + pse->se_cbsyms;
    if (pse->se_segdef.gd_type & MSF_BIGSYMDEF) {

        /* alignment symdef offset pointer */

        ulsymoff = align(ulsymoff);
        uloff = ulsymoff / alignment;

        /* set the array offset size to the big group size */

        cboff = pse->se_segdef.gd_csym * (cbOffsets + CBOFFSET_BIG - CBOFFSET);
    }
    if (uloff >= _64K) {
        error("segdef's array offset too large: %08lx", uloff);
        xexit(4);
    }
    pse->se_segdef.gd_psymoff = (unsigned short)uloff;

    /* set pointer to linedef_s(s) attached to this segment def */

    if (pse->se_pli) {
        uloff = align(cbSymFile + ulsymoff + cboff) / alignment;
        if (uloff >= _64K) {
            error("segdef's linedef pointer too large: %08lx\n", uloff);
            xexit(4);
        }
        pse->se_segdef.gd_spline = (unsigned short)uloff;
    }

    /* set relative address for symbol offset calculations */

    segdefbase = cbSymFile;

    /* set pointer to next segdef */

    uloff = align(cbSymFile + ulsymoff + cboff + pse->se_cblines) / alignment;
    if (i == iSegLast) {
        pse->se_segdef.gd_spsegnext = 0;
    } else {
        if (uloff >= _64K) {
            error("segdef next pointer too large: %08lx", uloff);
            xexit(4);
        }
        pse->se_segdef.gd_spsegnext = (unsigned short)uloff;
    }
    WriteOutFile(&pse->se_segdef, cbsegdef);

    /* output symbols and values, followed by their offsets */

    WriteSyms(pse->se_psy,
              pse->se_segdef.gd_csym,
              pse->se_segdef.gd_type,
              segdefbase,
              (char *) pse->se_segdef.gd_achname);
}


void
WriteLineRec(
            int i
            )
{
    register struct line_s *pli = SegTab[i]->se_pli;
    register unsigned cb;
    unsigned short cblr;

    while (pli) {
        cb = sizeof(struct linedef_s) + pli->li_linedef.ld_cbname;
        pli->li_linedef.ld_plinerec = (unsigned short)cb;

        /* compute length of line numbers */

        switch (pli->li_linedef.ld_itype) {
            case 0:
                cblr = pli->li_linedef.ld_cline * sizeof(struct linerec0_s);
                break;
            case 1:
                cblr = pli->li_linedef.ld_cline * sizeof(struct linerec1_s);
                break;
            case 2:
                cblr = pli->li_linedef.ld_cline * sizeof(struct linerec2_s);
                break;
        }

        if (pli->li_plinext) {
            pli->li_linedef.ld_splinenext =
            (unsigned short)(align(cbSymFile + pli->li_cblines) / alignment);
        }

        /* write out linedef_s */

        WriteOutFile(&pli->li_linedef, cb);

        /* write out line number offsets */

        WriteOutFile(pli->li_plru, cblr);

        /* align end of linerecs */

        WriteOutFile(achZeroFill, rem_align(cbSymFile));

        pli = pli->li_plinext;
    }
}


void
ReadMapLine(void)
{
    do {
        if (!fgetl(Buf, MAPBUFLEN, mapfh)) {
            errorline("Unexpected eof");
            xexit(4);
        }
    } while (Buf[0] == '\0');
}


void
WriteOutFile(src, len)
char *src;
int len;
{
    if (len && fwrite(src, len, 1, outfh) != 1) {
        error("write fail on: %s", pszOutfn);
        xexit(1);
    }
    cbSymFile += len;
}


/*
 *      fgetl - return a line from file (no CRLFs); returns 0 if EOF
 */

int
fgetl(
     char *pbuf,
     int len,
     FILE *fh
     )
{
    int c;
    char *p;

    p = pbuf;
    len--;                              /* leave room for nul terminator */
    while (len > 0 && (c = getc(fh)) != EOF && c != '\n') {
        if (c != '\r') {
            *p++ = (char) c;
            len--;
        }
    }
    if (c == '\n') {
        cLine++;
    }
    *p = '\0';
    return(c != EOF || p != pbuf);
}


int
NameLen(
       char* p
       )
{
    char* p1;
    char* plimit;
    int len;

    p1 = p;
    plimit = p + MAXSYMNAMELEN;
    while (*p) {
        if (*p == ' ' || *p == LPAREN || *p == RPAREN || p == plimit) {
            *p = '\0';
            break;
        }
        if (   fEdit    &&    strchr(   "@?",    *p)) {
            *p = '_';
        }
        p++;
    }
    return (int)(p - p1);
}


int
NameSqueeze(
           char* ps
           )
{
    char* pd;
    char* porg;
    char* plimit;

    NameLen(ps);
    porg = pd = ps;
    plimit = porg + MAXLINERECNAMELEN;
    while (pd < plimit && *ps) {
        switch (*pd++ = *ps++) {
            case '/':
                pd[-1] = '\\';
                // FALLTHROUGH

                // remove \\ in middle of path, & .\ at start or middle of path

            case '\\':
                if (pd > &porg[2] && pd[-2] == '\\') {
                    pd--;
                } else if (pd > &porg[1] && pd[-2] == '.' &&
                           (pd == &porg[2] || pd[-3] == '\\')) {
                    pd -= 2;
                }
                break;
        }
    }
    *pd = '\0';
    return (int)(pd - porg);
}


int
HexTouVal(
         char* p
         )
{
    int i;

    for (uVal = 0, i = 0; i < 4; i++) {
        if (!isxdigit(*p)) {
            break;
        }
        if (*p <= '9') {
            uVal = 0x10 * uVal + *p++ - '0';
        } else {
            uVal = 0x10 * uVal + (*p++ & 0xf) + 9;
        }
    }
    return(i > 3);
}


int
HexToulVal(
          char* p
          )
{
    int i;

    for (ulVal = 0, i = 0; i < 8; i++) {
        if (!isxdigit(*p)) {
            break;
        }
        if (isdigit(*p)) {
            ulVal = 0x10 * ulVal + *p++ - '0';
        } else {
            ulVal = 0x10 * ulVal + (*p++ & 0xf) + 9;
        }
    }
    return(i);
}


int
CharToHex(
         int c
         )
{
    if (!isxdigit(c)) {
        errorline("Bad hex digit (0x%02x)", c);
        xexit(1);
    }
    if ((c -= '0') > 9) {
        if ((c += '0' - 'A' + 10) > 0xf) {
            c += 'A' - 'a';
        }
    }
    return(c);
}


int
rem_align(
         unsigned long foo
         )
{
    return((int) ((alignment - (foo % alignment)) % alignment));
}


int
align(
     int foo
     )
{
    int bar;

    bar = foo % alignment;
    if (bar == 0) {
        return(foo);
    }
    return(foo + alignment - bar);
}


char *
Zalloc(
      unsigned cb
      )
{
    char *p;

    if ((p = malloc(cb)) == NULL) {
        error("out of memory");
        xexit(4);
    }
    memset(p, 0, cb);
    return(p);
}

void
logo(void)                              /* sign on */
{

    if (fLogo) {
        fLogo = 0;
        printf("Microsoft (R) Symbol File Generator Version %d.%02d\n",
               MAPSYM_VERSION,
               MAPSYM_RELEASE);
        printf(VER_LEGALCOPYRIGHT_STR ". All rights reserved.\n");
    }
}


void
usage(void)
{
    logo();
    fprintf(stderr, "\nusage: mapsym [-nologo] [-almnst] [[-c pefile] -o outfile] infile\n");
    fprintf(stderr, "  -a         include alphabetic sort arrays\n");
    fprintf(stderr, "  -l         list map file information\n");
    fprintf(stderr, "  -e         edit symbols for NTSD parser\n");
    fprintf(stderr, "  -m         use module name from infile\n");
    fprintf(stderr, "  -n         omit line number information\n");
    fprintf(stderr, "  -nologo    omit signon logo\n");
    fprintf(stderr, "  -o outfile symbol output file\n");
    fprintf(stderr, "  -s         enable line number support [default]\n");
    fprintf(stderr, "  -t         include static symbols\n");
    fprintf(stderr, "infile is a map file \n");
    fprintf(stderr, "outfile is a sym file.\n");
    xexit(1);
}


/*VARARGS1*/
void
__cdecl
error(
     char* fmt,
     ...
     )
{
    va_list argptr;

    va_start(argptr, fmt);
    fprintf(stderr, "mapsym: ");
    vfprintf(stderr, fmt, argptr);
    fprintf(stderr, "\n");
}


/*VARARGS1*/
void
__cdecl
errorline(
         char* fmt,
         ...
         )
{
    va_list argptr;

    va_start(argptr, fmt);
    fprintf(stderr, "mapsym: ");
    fprintf(stderr, "%s", pszMapfn);
    if (cLine) {
        fprintf(stderr, "(%u)", cLine + fByChar);
    }
    fprintf(stderr, ": ");
    vfprintf(stderr, fmt, argptr);
    fprintf(stderr, "\n");
}


void
xexit(
     int rc
     )
{
    if (outfh) {
        fclose(outfh);
        _unlink(pszOutfn);
    }
    exit(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmchksp.c ===
/* asmchksp.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <ctype.h>
#include <float.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmexpr.h"
#include "asmopcod.h"

extern UCHAR opprec [];
VOID CODESIZE setdispmode(struct ar *);
SHORT CODESIZE simpleExpr (struct ar *);
char fValidSym;


/***	createsym - make item entry for symbol
 *
 *	createsym (itemkind,  p);
 *
 *	Entry	itemkind = kind of item
 *		itemsub =
 *		*p = activation record
 *	Exit
 *	Returns
 *	Calls
 *	Note	If symbol, look further to see if EQU, record name
 *		and do appropriate thing.
 */


VOID	PASCAL CODESIZE createsym (
){
	register struct psop *pso;	 /* parse stack operand structure */
	register SYMBOL FARSYM *symp = symptr;
	char aliasAttr = (char) 0xFF;
	struct dscrec *itemptrT;

	pso = &(itemptr->dsckind.opnd);
	if (!symp) {
undefined:
		pso->dflag = UNDEFINED;
		pso->dtype = M_CODE | M_FORTYPE;
		return;
	}

	if (symp->symkind == EQU &&
	    symp->symu.equ.equtyp == ALIAS) {

		 aliasAttr = symptr->attr;

		 symptr = symp = chasealias (symp);
		 if (!symp)
		      goto undefined;
	}
	else if (symp->symkind == REC && (PEEKC () == '<')) {

		itemptrT = itemptr;
		pso->doffset = recordparse ();
		itemptr = itemptrT;
		return;
	}

	/* Assume symbol is defined */

	if (M_XTERN & symp->attr)
		pso->dflag = XTERNAL;

	else if (!(M_DEFINED & symp->attr)) {
		/* Cause error if undefined */
		pso->dflag = UNDEFINED;
		errorn (E_SND);
	}
	else if (!(M_BACKREF & (symp->attr & aliasAttr)))
		pso->dflag = FORREF;
	else
		pso->dflag = KNOWN;

	if (M_MULTDEFINED & symp->attr)
		errorc (E_RMD);

	pso->dsize = symp->symtype;
	pso->dlength = symp->length;
	pso->doffset = symp->offset;
	pso->dcontext = (SYMBOL FARSYM *)NULL;

	if ((symp->symkind == EQU) && (symp->symu.equ.equtyp == EXPR)) {
		pso->dsign = symp->symu.equ.equrec.expr.esign;
		pso->dcontext = symp->symu.equ.equrec.expr.eassume;
	}
	if (1 << symp->symkind & (M_CLABEL | M_PROC))
		if (isCodeLabel(symp) && emittext)
			pso->dcontext = symp->symu.clabel.csassume;

	if (1 << symp->symkind & (M_REGISTER | M_GROUP | M_SEGMENT))
		pso->dsegment = symp;
	else
		pso->dsegment = symp->symsegptr;

	if ((M_XTERN & symp->attr) || (1 << symp->symkind & (M_REC | M_RECFIELD)))
		pso->dextptr = symp;

	pso->dtype = xltsymtoresult[symp->symkind];
	if (symp->symkind == CLABEL ||
	    symp->symkind == EQU && pso->dsegment)

		if (isCodeLabel(symp))
			pso->dtype = M_CODE;
		else
			pso->dtype = M_DATA;

	if (!(M_BACKREF & (symp->attr & aliasAttr)))
		pso->dtype |= M_FORTYPE;

	if ((pso->dtype == xltsymtoresult[REGISTER]) &&
	   (symp->symu.regsym.regtype == STKREG)) {
		/* 8087 support */
		flteval ();
	}

}


/***	evalalpha - evaluate alpha
 *
 *	type = evalpha (p);
 *
 *	Entry	p = pointer to parser activation record
 *	Exit	alpha item added to parse stack
 *	Returns type of item added to parse stack
 *	Calls
 */


UCHAR	PASCAL CODESIZE
evalalpha (
	register struct ar    *p
){
	register struct psop *pso;	/* parse stack operand entry */


	if (! fValidSym)
	    getatom ();

	if (fValidSym == 2 || symsearch ()){

		fValidSym = 0;

		if (symptr->symkind == EQU && symptr->symu.equ.equtyp == TEXTMACRO) {

#ifdef BCBOPT
			goodlbufp = FALSE;
#endif
			expandTM (symptr->symu.equ.equrec.txtmacro.equtext);

			return (getitem (p));
		}
		else if (symptr->symkind == CLASS)
			errorn( E_IOT );
		else {
			addplusflagCur = FALSE;
			createitem (OPERAND, ISYM);
			p->addplusflag = addplusflagCur;

			return (OPERAND);
		}
	}
	fValidSym = 0;

	if (fnoper ())
		if ((opertype == OPNOTHING) || (opertype == OPDUP)) {
			lbufp = begatom;
			dupflag = (opertype == OPDUP);
			return (ENDEXPR);
		}
		else {
			createitem (OPERATOR, ISYM);
			return (OPERATOR);
		}
	else if (*naim.pszName == '.') {
		lbufp = begatom + 1;
		operprec = opprec[opertype = OPDOT];
		createitem (OPERATOR, ISYM);
		return (OPERATOR);
	}
	else if (fnsize ()) {
		createitem (OPERAND, ISIZE);
		return (OPERAND);
	}
	else if ((*naim.pszName == '$') && (naim.pszName[1] == 0)) {
		itemptr = defaultdsc ();
		pso = &(itemptr->dsckind.opnd);
		/* Create result entry */
		pso->doffset = pcoffset;
		pso->dsegment = pcsegment;
		pso->dcontext = pcsegment;
		pso->dtype = M_CODE;
		pso->dsize = CSNEAR;
		return (OPERAND);
	}
	else if ((*naim.pszName == '?') && (naim.pszName[1] == 0)) {
		createitem (OPERAND, IUNKNOWN);
		if (emittext)
			errorc (E_UID);
		return (OPERAND);
	}
	else {
		symptr = (SYMBOL FARSYM *)NULL;
		error (E_SND, naim.pszName);		/* common pass1 error */
		createitem (OPERAND, ISYM);
		return (OPERAND);
	}
}


/* Dup tree is organized left to right horizonatally for each
	  item in a DUP list at the same level( i. e. 5 DUP(1,2,3) ).
	  This is considered the 'list' part. Any item in the list
	  may be another DUP header instead of a data entry, in
	  which case you go down a level and have another list.
 */


/***	scanlist - scan duprec list
 *
 *	scanlist (ptr, disp);
 *
 *	Entry	*ptr = duprec entry
 *		disp = function to execute on entry
 *	Exit	depends upon function
 *	Returns none
 *	Calls
 */


VOID	PASCAL CODESIZE
scanlist (
       struct duprec  FARSYM *ptr,
       VOID   (PASCAL CODESIZE *disp) (struct duprec FARSYM *)
){
	struct duprec  FARSYM *iptr;
	struct duprec  FARSYM *dptr;

	nestCur++;

	while (ptr) {
		/* set pointer to next entry */
		iptr = ptr->itemlst;
		if (ptr->dupkind == NEST)
			/* dptr = pointer to duplicated item */
                        dptr = ptr->duptype.dupnext.dup;
		else
			dptr = (struct duprec FARSYM *)NULL;
		if (!(ptr->rptcnt == 1 && ptr->itemcnt) ||
		    !(strucflag && initflag))
			(*disp) (ptr);
		if (dptr) {
			/* Go thru DUP list */
			scanlist (dptr, disp);
			if (displayflag)
				if (!(ptr->rptcnt == 1 && ptr->itemcnt) ||
				    !(strucflag && initflag))
					enddupdisplay ();
		}
		if (ptr == iptr)  /* corrupt data structure */
			break;

		/* Handle next in list */
		ptr = iptr;
	}
	nestCur--;
}


/***	calcsize - calculate size of DUP list
 *
 *	value = calcsize (ptr);
 *
 *	Entry	*ptr = dup list
 *	Exit	none
 *	Returns size of structure
 *	Calls	calcsize
 */


OFFSET PASCAL CODESIZE
calcsize (
	struct duprec  FARSYM *ptr
){
	unsigned long clsize = 0, nextSize, limit;
	struct duprec FARSYM *p;

	limit = (wordsize == 2)? 0x10000: 0xffffffff;

	for (p = ptr; p; p = p->itemlst) {

	    if (p->dupkind == NEST) {
		    /* Process nested dup */
                    nextSize = calcsize (p->duptype.dupnext.dup);

		    if (nextSize && (p->rptcnt > limit / nextSize))
			errorc(E_VOR);

		    nextSize *= p->rptcnt;
	    }
	    else {
		    if (p->dupkind == LONG) {
			    nextSize = p->duptype.duplong.llen;
			    resvspace = FALSE;
		    }
		    else {
			    /* Size is that of directive */
			    nextSize = p->duptype.dupitem.ddata->dsckind.opnd.dsize;
			    if (p->duptype.dupitem.ddata->dsckind.opnd.dflag != INDETER)
				    resvspace = FALSE;
		    }
	    }

	    if (nextSize > limit - clsize)
			errorc(E_VOR);

	    clsize += nextSize;

	    if (p == p->itemlst)  /* corrupt data structure */
		    break;
	}
	return (clsize);
}

/***	datascan - scan next data item
 *
 *	datascan ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

struct duprec FARSYM * PASCAL CODESIZE
datascan (
     struct datarec *p
){
	register char cc;
	struct dsr     a;

	if (ISBLANK (PEEKC ()))
		skipblanks ();

	a.initlist = a.flag = a.longstr = FALSE;

	/* check for textmacro substitution */
	a.dirscan = lbufp;
	xcreflag--;
	getatom ();

	if (fnsize())
	    goto isASize;

	if (symsrch ())
	   if (symptr->symkind == EQU &&
	       symptr->symu.equ.equtyp == TEXTMACRO) {

		expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
		a.dirscan = begatom;
	   }
	   else if (symptr->symkind == STRUC) {
isASize:
		switchname();
		getatom();

		if (tokenIS("ptr")) {
		    switchname();
		    p->type = fnPtr(datadsize[optyp - TDB]);

		    if (p->type > 512)
			goto noRescan;
		}
	   }
	lbufp = a.dirscan;
noRescan:

	xcreflag++;
	if ((optyp == TDB &&
	    ((cc = PEEKC ()) == '\'' || cc == '"')) &&
	    !initflag)

		datadb (&a);

	if (optyp != TDB && optyp != TDW)
		/* entry can be DD | DQ | DT */
		parselong (&a);

	if (!a.longstr)
		datacon (&a);

	else if (strucflag && initflag)
		errorc( E_OIL );

	if (!a.flag) {
		if (!strucflag || !initflag) {
			a.dupdsc->rptcnt = 1;
			a.dupdsc->itemcnt = 0;
			a.dupdsc->itemlst = (struct duprec FARSYM *)NULL;
		}
	}
	return (a.dupdsc);
}


/***	realeval - evaluate IEEE 8087 floating point number
 *
 *	realeval (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

struct ddecrec {
	USHORT realv[5];
	USHORT intgv[2];
	USHORT cflag;
};

#if !defined FLATMODEL
// Because this is called so seldom and it's so slow anyhow put it in
// a far segment.
# pragma alloc_text (FA_TEXT, realeval)
#endif

VOID PASCAL
realeval (
	struct realrec *p
){
	register char cc, *cp;
	char	numtext[61];
	struct	 ddecrec fltres;
#if !defined NOFLOAT
	float	    *pTmpFloat;
	double	    *pTmpDouble;
	double	    TmpDouble;
	double	    AbsDouble;
	long double *pTmpLongDouble;
	char	    *pEnd;
#endif

	cp = numtext;
	/* Copy the number - must have at least 1 char */
	*cp++ = NEXTC ();  /* get leading sign or 1st char */
	do {
		cc = NEXTC ();
		*cp++ = cc;
	} while (isdigit (cc) || cc == '.');
	if ((cc = MAP (cc)) == 'E') {
		/* Get the next + - or digit */
		*cp++ = NEXTC ();
		/* Copy the exponent over */
		do {
			cc = NEXTC ();
			*cp++ = cc;
		} while (isdigit (cc));
	}
	*cp = '\0';
	BACKC ();

// NOFLOAT is used when there are no floating point libraries available
// Any masm version produced with NOFLOAT defined will cause a divide
// by 0 error to be logged when a real number initializer is used.
#if defined NOFLOAT
	ferrorc( E_DVZ );
#else

	switch(optyp)
	{
	  case TDD:
	    errno = 0;
	    TmpDouble = strtod( numtext, &pEnd );
	    if( errno == ERANGE ){
		ferrorc( E_DVZ );
	    }
	    AbsDouble = TmpDouble > 0 ? TmpDouble : -TmpDouble;
	    if( AbsDouble > FLT_MAX || AbsDouble < FLT_MIN ){
		ferrorc( E_DVZ );
	    }else{
		// Convert the double to a float (8 byte to 4 byte)
		pTmpFloat = (float *)(p->num);
		*pTmpFloat = (float)TmpDouble;
	    }
	    break;
	  case TDQ:
	    pTmpDouble = (double *)(p->num);
	    errno = 0;
	    *pTmpDouble = strtod( numtext, &pEnd );
	    if( errno == ERANGE ){
		ferrorc( E_DVZ );
	    }
	    break;
	  case TDT:
	    pTmpLongDouble = (long double *)(p->num);
	    errno = 0;
	    *pTmpLongDouble = _strtold( numtext, &pEnd );
	    if( errno == ERANGE ){
		ferrorc( E_DVZ );
	    }
	    break;
	default:
		ferrorc(E_TIL);
		break;
	}
#endif
}


/***	simpleExpr - short curcuit expression evaluator
 *
 */

/* following are three protype parse records for the three simple
 * expressions that we simpleExpr understands
 */

#ifdef EXPR_STATS

long cExpr, cHardExpr;
extern char verbose;

#endif

#define SHORT_CIR 1
#if SHORT_CIR

DSCREC consDS = {

	NULL, 0, 0,		/* previtem, prec, type */
      { NULL, NULL, NULL, 0,	/* dsegment, dcontext, dexptr, dlength */
	6,			/* rm */
	1 << RCONST,		/* dtype */
	0, 0, /* 0, */		/* doffset, dsize, type */
	4,			/* mode */
	FALSE, FALSE, FALSE,	/* w, s, sized*/
	NOSEG,			/* seg */
	KNOWN,			/* dflag */
	FCONSTANT,		/* fixtype */
	FALSE			/* dsign */
      }
};

DSCREC regDS = {

	NULL, 0, 0,		/* previtem, prec, type */
      { NULL, NULL, NULL, 0,	/* dsegment, dcontext, dexptr, dlength */
	0,			/* rm */
	1 << REGRESULT, 	/* dtype */
	0, 2, /* 0, */		 /* doffset, dsize, type */
	3,			/* mode */
	TRUE, FALSE, TRUE,	/* w, s, sized*/
	NOSEG,			/* seg */
	KNOWN,			/* dflag */
	FCONSTANT,		/* fixtype */
	FALSE			/* dsign */
      }
};

DSCREC labelDS = {
	NULL, 0, 0,		/* previtem, prec, type */
      { NULL, NULL, NULL, 0,	/* dsegment, dcontext, dexptr, dlength */
	6,			/* rm */
	1 << DATA,		/* dtype */
	0, 2, /* 0, */		/* doffset, dsize, type */
	0,			/* mode */
	TRUE, FALSE, TRUE,	/* w, s, sized*/
	NOSEG,			/* seg */
	KNOWN,			/* dflag */
	FNONE,			/* fixtype */
	FALSE			/* dsign */
      }
};

#if !defined XENIX286 && !defined FLATMODEL
#pragma check_stack-
#endif

SHORT CODESIZE
simpleExpr (
	struct ar *pAR
){
	register DSCREC *pDES;	   /* parse stack operand structure */
	register char kind;
	char cc;
	char *lbufSav;

	fValidSym = noexp = 0;
	lbufSav = lbufp;

#ifdef EXPR_STATS
	cExpr++;
#endif
	if (ISTERM (cc = skipblanks())) {

notSimple:
	    lbufp = lbufSav;
notSimpleLab:

#ifdef EXPR_STATS
	    cHardExpr++;
#endif
	    return (FALSE);
	}

	if (LEGAL1ST (cc)){

	    getatom ();
	    fValidSym++;		/* 1 means valid token */

	    if (! (ISTERM (PEEKC()) || PEEKC() == ',')){

#ifdef EXPR_STATS
	       if (verbose && pass2)
		  fprintf(stdout, "Not a Simple Expression: %s\n", lbufSav);
#endif

		goto notSimpleLab;
	    }

	    if (symsearch ()){

		fValidSym++;		/* 2 means valid symptr */

		if ((kind = symptr->symkind) == REGISTER &&
		   (symptr->symu.regsym.regtype != STKREG)) {

		    pAR->curresult = pDES = dalloc();
		    *pDES = regDS;

		    pDES->dsckind.opnd.dsegment = symptr;

		    switch (symptr->symu.regsym.regtype) {

			case BYTREG:
			    pDES->dsckind.opnd.dsize = 1;
			    pDES->dsckind.opnd.w--;
			    pDES->dsckind.opnd.s++;
			    break;
#ifdef V386
			case CREG:
			    if (opctype != PMOV)
				    errorc(E_WRT);

			case DWRDREG:
			    pDES->dsckind.opnd.dsize = 4;
			    break;
#endif
		    }
		    pDES->dsckind.opnd.rm = (unsigned short)symptr->offset;
		    return(TRUE);
	       }

	       else if (kind == CLABEL || kind == PROC || kind == DVAR ||
		       (kind == EQU && symptr->symu.equ.equtyp == EXPR)) {

		    pAR->curresult = pDES = dalloc();
		    *pDES = labelDS;

		    pDES->dsckind.opnd.doffset = symptr->offset;
		    pDES->dsckind.opnd.dsegment = symptr->symsegptr;

		    if (kind == EQU) {

			if (! (pDES->dsckind.opnd.dcontext =
			       symptr->symu.equ.equrec.expr.eassume) &&
			    ! pDES->dsckind.opnd.dsegment){

			    val = pDES->dsckind.opnd.doffset;

			    *pDES = consDS;
			    pDES->dsckind.opnd.dsign =
				  symptr->symu.equ.equrec.expr.esign;

			    if (!(M_BACKREF & symptr->attr)){
			       pDES->dsckind.opnd.dtype |= M_FORTYPE;
			       pDES->dsckind.opnd.dflag = FORREF;
			    }

			    if (M_XTERN & symptr->attr){
			       pDES->dsckind.opnd.dflag = XTERNAL;
			       pDES->dsckind.opnd.dextptr = symptr;
			       return (TRUE);
			    }

			    goto constEqu;
			}
		    }

		    pDES->dsckind.opnd.dsize = symptr->symtype;
		    pDES->dsckind.opnd.dlength = symptr->length;

		    if (M_XTERN & symptr->attr){
			    pDES->dsckind.opnd.dflag = XTERNAL;
			    pDES->dsckind.opnd.dextptr = symptr;
		    }
		    else if (!(M_DEFINED & symptr->attr)) {
			    /* Cause error if undefined */
			    pDES->dsckind.opnd.dflag = UNDEFINED;
			    pDES->dsckind.opnd.dsize = wordsize;
			    pDES->dsckind.opnd.dtype = M_CODE;
			    errorn (E_SND);
		    }
		    else if (!(M_BACKREF & symptr->attr)){
			    pDES->dsckind.opnd.dflag = FORREF;
			    pDES->dsckind.opnd.dtype |= M_FORTYPE;
		    }
		    if (M_MULTDEFINED & symptr->attr)
			    errorc (E_RMD);

		    if (pDES->dsckind.opnd.dsize < 2) {
			pDES->dsckind.opnd.w--;
			pDES->dsckind.opnd.s++;
		    }
#ifdef V386
		    if (wordsize == 4 ||
		       (symptr->symsegptr && symptr->symsegptr->symu.segmnt.use32 == 4)) {
			pDES->dsckind.opnd.mode = 5;
			pDES->dsckind.opnd.rm--;	/* = 5 */
		    }
#endif

		    if (isCodeLabel(symptr)){

			pDES->dsckind.opnd.dtype = (unsigned short)
			      (pDES->dsckind.opnd.dtype & ~M_DATA | M_CODE);

			if (emittext && kind != EQU)
			    pDES->dsckind.opnd.dcontext =
				  symptr->symu.clabel.csassume;
		    }
		    else {

			pAR->linktype = FNONE;
			pAR->rstype = M_DATA;
			findsegment ((UCHAR)pAR->index, pAR);

			pDES->dsckind.opnd.seg = pAR->segovr;
		    }
		    pDES->dsckind.opnd.fixtype = FOFFSET;

		    return(TRUE);
	       }
#ifdef EXPR_STATS
	       if (verbose && pass2)
		  fprintf(stdout, "Not a Simple Label: %s\n", naim.pszName);
#endif
	    }
	    goto notSimpleLab;
	}

	if (isdigit (cc)){

	    evalconst ();	    /* value in global val */
	    if (! (ISTERM (skipblanks()) || PEEKC() == ','))
		goto notSimple;

	    pAR->curresult = pDES = dalloc();
	    *pDES = consDS;
constEqu:
	    if (pDES->dsckind.opnd.dflag != FORREF) {

		if (val < 128)
		    pDES->dsckind.opnd.s++;

		else {

#ifdef V386				    /* only consider 16 bits */
		    if (wordsize == 2)
			pDES->dsckind.opnd.s = (char)((USHORT)(((USHORT) val & ~0x7F ) == (USHORT)(~0x7F)));
		    else
#endif
			pDES->dsckind.opnd.s = ((val & ~0x7F ) == ~0x7F);
		}
	    }

	    pDES->dsckind.opnd.doffset = val;

	    if (val > 256){
		 pDES->dsckind.opnd.w++;
		 pDES->dsckind.opnd.sized++;
	    }

	    return(TRUE);
	}
	goto notSimple;
}

#if !defined XENIX286 && !defined FLATMODEL
#pragma check_stack+
#endif

#endif

/***	expreval - expression evaluator
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

DSCREC	* PASCAL CODESIZE
expreval (
	UCHAR  *dseg
){
	register struct psop *psoi;	/* parse stack operand structure */
	struct ar     a;
	SHORT i;

	dupflag = FALSE;
	nilseg = NOSEG;
	a.segovr = NOSEG;
	a.index = *dseg;

#if SHORT_CIR
	if (simpleExpr(&a)){
	    fSecondArg++;
	    return (a.curresult);
	}
#endif
	a.exprdone = a.addplusflag = FALSE;
	a.lastitem = (DSCREC *)NULL;

	/* No parens or [] yet, Lowest precedence, haven't found anything yet */

	a.parenlevel = a.bracklevel = a.lastprec = 0;
    a.index = 0;
    a.base = 0;
	noexp = 1;

	/* Start expression loop */

	while (!a.exprdone){

	    switch (getitem (&a)) {

		case OPERAND:
			itemptr->previtem = a.lastitem;
			a.lastitem = itemptr;
			itemptr->prec = a.lastprec;
			noexp = 0;
			break;

		case OPERATOR:
			exprop (&a);
			noexp = 0;
			break;

		case ENDEXPR:
		    a.exprdone = TRUE;
	    }
	}

	/* Do some easy error checking */

	if (a.parenlevel + a.bracklevel)
		errorc (E_PAR);

	itemptr = (DSCREC *)NULL;

	if (!a.lastitem)
		a.curresult = defaultdsc ();
	else
		evaluate (&a);	/* Evaluate whole expression */

	psoi = &(a.curresult->dsckind.opnd);

	a.rstype = (unsigned short)(psoi->dtype &
		   (M_CODE|M_DATA|M_RCONST|M_REGRESULT|M_SEGRESULT|M_GROUPSEG));

	a.linktype = FNONE;	/* Leave bits for link type */
	a.vmode = 4;
	psoi->sized = FALSE;
	psoi->w = TRUE;
	psoi->s = FALSE;

#ifdef V386
	if ((a.base|a.index) & 0xf8) { /* have 386 index or base */

	    if (a.index) {

		if (!(a.index&8))
		    errorc(E_OCI);

		if ((a.index&7) == 4)
			errorc(E_DBR);

		a.vmode = 10;	/* two register modes */

		/* here we are putting what goes into the SIB
		 * into a.index.  from here on, we have to
		 * to a.index with masks, so we dont trash
		 * the high order stuff
		 * the encoding we derive this from is tricky--
		 * see regcheck() for details -Hans
		 * stick in the index register */

		i = (a.index&7) << 3;

		/* stick in base. ebp if there is none */

		if (a.base){

		    if (!(a.base&8))
			errorc(E_OCI);

		    i |= (a.base&7);
		}
		else {
		    i |= 5;
		    a.vmode = 8;
		}
		/* stick in scale.  *1 if there is none */

		if (a.index&0x70)
		    i |= ((a.index & 0x70) - 0x10) << 2;

		a.index = i;
	    }
	    else if (a.base == (4|8)) { /* esp */
		a.vmode = 10;
		a.index = 044;
	    }
	    else {  /* one register modes */

		a.vmode = 7;
		a.index = (unsigned short)(a.base & 7);
	    }
	    /* note dirty way of checking for BP or SP */

	    if (*dseg != ESSEG && (a.base&6) == 4)
		*dseg = SSSEG;
	} else

#endif	/* V386 */

	if (a.base + a.index){	  /* Have some index or base */

	    a.vmode = 2;

	    /* Assume offset is direct */

	    if (a.base && a.index)		    /* Have both */
		a.index = (unsigned short)(a.base - 3 + a.index - 6);

	    else if (a.base)			    /* Have base address */
		a.index = (a.base == 3)? 7: 6;

	    else				    /* Have only index address*/
		a.index = a.index - 2;

	    if (1 << a.index & (1 << 2 | 1 << 3 | 1 << 6) && *dseg != ESSEG)
	       *dseg = SSSEG;
	}
	/* No indexing */

	else if (a.rstype == xltsymtoresult[REGISTER]) {

		/* Have register */

		a.vmode = 3;
		psoi->sized = TRUE;

		switch(psoi->dsegment->symu.regsym.regtype) {

		case BYTREG:
			psoi->dsize = 1;
			goto mask7;

		case WRDREG:
		case INDREG:
		case SEGREG:
		case STKREG:
			psoi->dsize = 2;
			goto mask7;
#ifdef V386
		case CREG:/* probably should turn this into memref if !386P */
			if (opctype != PMOV)
				errorc(E_WRT);
			psoi->dsize = 4;
			a.index = (unsigned short)psoi->doffset;
			break;

		case DWRDREG:
			psoi->dsize = 4;
#endif
		mask7:
			if ((psoi->doffset > 7) || psoi->dsign)
				errorc (E_IRV);

			/* Set register # */

			a.index = (unsigned short)(psoi->doffset & 7);
			break;

		default:
			errorc(E_WRT);
			break;
		}
	}
	/* Might be segment result */

	else if (a.rstype & (M_SEGRESULT | M_GROUPSEG)) {

	    /* we get here if we had offset operator with segment or group
	     * or offset operator with data and rconst
	     * Result is SEG. Rconst if OFFSET grp:var */

	    if (a.rstype & (M_SEGRESULT | M_EXPLOFFSET)) {
		    psoi->dsize = 2;
		    /* Leave size if not OFFSET or */
		    psoi->sized = TRUE;
	    }
	    a.linktype = FOFFSET;
	    if ((M_GROUPSEG & a.rstype) && (psoi->fixtype != FOFFSET)) {
		    a.linktype = FGROUPSEG;
		    setdispmode(&a);
	    }
	    if ((a.vmode == 4) && (psoi->fixtype != FOFFSET))
		    a.linktype = FBASESEG;
	}
	else
	    a.index = 6;



	/**** Evaluate offset part of result ****/


	a.base = psoi->doffset;
	if (psoi->fixtype == FOFFSET ||
	    a.vmode == 2 || a.vmode == 7 || a.vmode == 10)

		psoi->dtype |= M_RCONST;

	/* [] implicit const */

	if ((M_RCONST & psoi->dtype) &&
	    (a.linktype == FNONE) && (a.vmode != 3)) {

	    /* Need to make sure <s> not set if memory */

	    if (!(psoi->dflag & (FORREF|UNDEFINED|XTERNAL))
	       && !psoi->dsegment && psoi->fixtype == FCONSTANT) {

		psoi->s = (a.base < 128 && !psoi->dsign) ||
			  (a.base < 129 && psoi->dsign);

		if (!(psoi->s || psoi->dsign))

#ifdef V386					/* only consider 16 bits */
		    if (wordsize == 2 && a.vmode < 6)
			psoi->s = (char)((USHORT)(((USHORT) a.base & ~0x7F ) == (USHORT)(~0x7F)));
		    else
#endif
			psoi->s = ((a.base & ~0x7F ) == ~0x7F);
	    }

	    psoi->w = (psoi->dsign && a.base > 256) ||
		      (a.base > 255 && !psoi->dsign);

	    if (a.vmode != 4) {

	       /* This is offset for index */
	       /* If value not known, don't allow shortning to mode 1 */
	       /* Word or byte offset */

	       if (!(M_FORTYPE & psoi->dtype) &&
		     psoi->dsegment == 0 && psoi->s &&
		     a.vmode != 8) {

		   /* one byte offset */

		   a.vmode--;
		   if (a.base == 0 && psoi->dflag == KNOWN) {

		       /* perhaps 0 byte offset */

		       switch(a.vmode) {

			case 1:
			      if (a.index != 6)
				      a.vmode--;
			      break;
			case 6:
			case 9:
			      if ((a.index&7) != 5)
				      a.vmode--;
			      break;
		       }
		   }
	       }
	    }

	    else {  /* Must be immediate */

		if (!psoi->dsegment && !psoi->dcontext)
			a.linktype = FCONSTANT;

		/******????? I'm not exactly sure why
		 * we think we have a size yet.  seems
		 * to me mov BYTE PTR mem,500 is legal
		 */

		 psoi->sized = psoi->w;

		if (!(M_EXPLOFFSET & psoi->dtype) && psoi->dcontext) {

		    /* Have segreg:const */

		    a.vmode = 0;
		    if (!(M_PTRSIZE & psoi->dtype) && psoi->dsize == 0)
		       psoi->dsize = wordsize;
		}
	    }
	}
	else if ((a.rstype & (M_DATA | M_CODE)) && a.linktype == FNONE) {

	 /* Have direct mode and  Want offset */

	    a.linktype = FOFFSET;
	    setdispmode(&a);

	    if (psoi->dsize == CSFAR && emittext)
		a.linktype = FPOINTER;
	}

	if (psoi->dflag == UNDEFINED) {

		/* Forward ref pass 1 */

		if (psoi->dsize == 0)
		    psoi->dsize = wordsize;

		if (!(M_RCONST & psoi->dtype) && a.vmode == 4)
			setdispmode(&a);
	}

	if (!psoi->dsegment ||
	    (1 << a.linktype & (M_FNONE|M_FOFFSET|M_FPOINTER|M_FGROUPSEG))){

	    if (psoi->dcontext &&
		psoi->dcontext->symkind == REGISTER)

		/* Have reg:var */

		if (psoi->dcontext->symu.regsym.regtype == SEGREG) {

		   /* Have segreg:VAR */

		   a.segovr = (char)(psoi->dcontext->offset);
		   psoi->dcontext = regsegment[a.segovr];

		   /* Context is that of segreg */

		   if (!psoi->dsegment && (psoi->dflag != XTERNAL)) {

			psoi->dcontext = NULL;
			psoi->dtype = xltsymtoresult[REC];
			psoi->mode = 4;
			a.linktype = FCONSTANT;
		   }
		}
		else
		    errorc (E_IUR);
	    else		      /* Find if seg:var or  no :, but needed */
		findsegment (*dseg, &a);
	}
	/* bogus error check removed, dcontext can be other then register
	 *
	 * else if (psoi->dcontext &&
	 *	  psoi->dcontext->symu.regsym.regtype == SEGREG)
	 *
	 *   errorc (E_IOT);
	 */

	if (a.segovr != NOSEG)
	    psoi->dtype |= xltsymtoresult[DVAR];

	if (a.vmode == 2 || a.vmode == 7 || a.vmode == 10) {

	    if (a.segovr == NOSEG && *dseg != NOSEG &&
	       (psoi->dsegment || psoi->dflag == XTERNAL))

		    psoi->dcontext = regsegment[*dseg];

	    psoi->dtype |= xltsymtoresult[DVAR];
	}

	if (! (1 << a.linktype & (M_FNONE | M_FCONSTANT)) ||
	      psoi->dflag == XTERNAL) {

	    if (M_HIGH & psoi->dtype)
		    a.linktype = FHIGH;

	    if (M_LOW & psoi->dtype)
		    a.linktype = FLOW;
	}

	if ((psoi->dtype & (M_PTRSIZE | M_HIGH | M_LOW)) ||
	     psoi->dsize && a.vmode != 4) {

	     psoi->sized = TRUE;
	     psoi->w = (psoi->dsize > 1);
	     psoi->s = !psoi->w;
	}
	psoi->seg = a.segovr;
	psoi->mode = (char)(a.vmode);
	psoi->fixtype = a.linktype;
	psoi->rm = a.index;

	if ((M_REGRESULT & a.rstype) && (a.vmode != 3))

	    errorc (E_IUR);	    /* bad use of regs, like CS:SI */

	fSecondArg++;
	return (a.curresult);
}

/* setdispmode -- set up elements of the ar structure to reflect
	the encoding of the disp addressing mode: [BP] or [EBP] means.
	there is a wordsize length displacement following and a zero
	index.
	input : struct ar *a;  a pointer to the upper frame variable
	output : none
	modifies : a->vmode, a->index.
*/
VOID CODESIZE
setdispmode(
	register struct ar *a
){

#ifdef V386

	if (a->vmode > 7) {

	    a->vmode = 8;		   /* scaled index byte, not r/m */
	    a->index = (a->index&~7) | 5;
	}

	else if (wordsize == 4 ||
		highWord(a->curresult->dsckind.opnd.doffset) ||
		(a->curresult->dsckind.opnd.dsegment &&
		 a->curresult->dsckind.opnd.dsegment->symu.segmnt.use32 == 4)) {

	    a->vmode = 5;
	    a->index = (a->index&~7) | 5;
	}
	else
#endif
	{
	    a->vmode = 0;
	    a->index = 6;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmcond.c ===
/* asmcond.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"


static UCHAR PASCAL CODESIZE argsame(void);
static char elsetable[ELSEMAX];

#define F_TRUECOND  1
#define F_ELSE	    2



/***	elsedir - processs <else>
 *
 *	elsedir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
elsedir (
){
	if (elseflag == F_ELSE)
		/* ELSE already given */
		errorc (E_ELS);
	else if (condlevel == 0)
		/* Not in conditional block */
		errorc (E_NCB);
	else if (generate) {
		generate = FALSE;
		lastcondon--;
	}
	else if (lastcondon + 1 == condlevel && elseflag != F_TRUECOND) {
		generate = TRUE;
		lastcondon++;
	}
	elseflag = F_ELSE;
}




/***	endifdir - process <endif> directive
 *
 *	endifdir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
endifdir (
){
	if (!condlevel)
		/* Not in conditional block */
		errorc (E_NCB);
	else {
		if (lastcondon == condlevel)
			lastcondon--;
		condlevel--;
		/* Pop back 1 cond level */
		/* generate if level is true */
		generate = (condlevel == lastcondon);

		if (generate && !condflag && !elseflag && !loption)
		    fSkipList++;

		if (condlevel)
			/* Restore ELSE context */
			elseflag = elsetable[condlevel - 1];
	}
}



/***	argblank - check for blank <...>
 *
 *	flag = argblank ();
 *
 *	Entry
 *	Exit
 *	Returns TRUE if <...> is not blank
 *	Calls
 */


UCHAR PASCAL CODESIZE
argblank (
){
	REG3 char *start;
	register char cc;
	register char *end;

	if ((cc = NEXTC ()) != '<')
		error (E_EXP,"<");
	start = lbufp;
	while (((cc = NEXTC ()) != '>') && (cc != '\0'))
		;
	if (cc != '>') {
		error (E_EXP,">");
		return (FALSE);
	}
	if (((end = lbufp) - 1) == start)
		return (TRUE);

	lbufp = start;
	while ((cc = NEXTC ()) != '>')
		if (cc != ' ') {
			lbufp = end;
			return (FALSE);
		}
	return (TRUE);
}




/***	argscan - return argument of <arg>
 *
 *	count = argscan (str);
 *
 *	Entry	str = pointer to beginning of argument string <....>
 *	Exit	none
 *	Returns number of characters in string <....>
 *	Calls
 */


USHORT PASCAL CODESIZE
argscan (
	register UCHAR *str
){
	register SHORT i;

	if (*str++ != '<') {
		error (E_EXP,"<");
		return(0);
	}
	for (i = 2; *str && *str != '>'; i++, str++) ;

	if (*str != '>')
		error (E_EXP,">");

	return (i);
}




/***	argsame - check for both arguments of <....> same
 *
 *	flag = argsame ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls	argscan
 */


static UCHAR PASCAL CODESIZE
argsame (
){
	register SHORT c1;
	register SHORT c2;
	char *p1;
	char *p2;

	p1 = lbufp;
	c1 = argscan (p1);
	lbufp += c1;
	skipblanks ();
	if (NEXTC () != ',')
		error (E_EXP,"comma");
	skipblanks ();
	p2 = lbufp;
	c2 = argscan (p2);
	lbufp += c2;

	if (c1 == c2)
		return( (UCHAR)(! ( (opkind & IGNORECASE)?
                         _memicmp( p1, p2, c1 ): memcmp( p1, p2, c1 ) ) ));
	else
		return( FALSE );
}




/***	conddir - process <IFxxx> directives
 *
 *	flag = conddir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	1F1			True if pass 1
 *		IF2			True if pass 2
 *		IF <expr>		True if non-zero
 *		IFE <expr>		True if zero
 *		IFDEF <sym>		True if defined
 *		IFNDEF <sym>		True if undefined
 *		IFB <arg>		True if blank
 *		IFNB <arg>		True if not blank
 *		IFDIF <arg1>,<arg2>	True if args are different
 *		IFIDN <arg1>,<arg2>	True if args are identical
 */


VOID	PASCAL CODESIZE
conddir (
){
	register UCHAR	 condtrue;

	switch (optyp) {
		case TIF1:
			condtrue = !pass2;
			break;
		case TIF2:
			condtrue = pass2;
			break;
		case TIF:
			condtrue = (exprconst () != 0);
			break;
		case TIFE:
			condtrue = !exprconst ();
			break;
		case TIFDEF:
		case TIFNDEF:
			getatom ();
			if (condtrue = symsrch ())
				condtrue = M_DEFINED & symptr->attr;

			if (optyp == TIFNDEF)
				condtrue = !condtrue;
			break;
		case TIFB:
			condtrue = argblank ();
			break;
		case TIFNB:
			condtrue = !argblank ();
			break;
		case TIFIDN:
		case TIFDIF:
			condtrue = argsame ();
			if (optyp == TIFDIF)
				condtrue = !condtrue;
			break;
	}

	if (!(opkind & CONDCONT)) {	/* not ELSEIF form */

	    if (condlevel && condlevel <= ELSEMAX)
		elsetable[condlevel - 1] = elseflag;
	    /* Another conditional */
	    condlevel++;
	    elseflag = FALSE;

	    if (generate)	    /* If generating before this cond */
		if (condtrue) {     /* Another true cond */
		    lastcondon = condlevel;
		    elseflag = F_TRUECOND;
		} else
		    generate = FALSE;
	    else
		/* No errors in false */
		errorcode = 0;

	} else {    /* ELSEIF FORM */

	    if (elseflag == F_ELSE)
		/* ELSE already given */
		errorc (E_ELS);

	    else if (condlevel == 0)
		/* Not in conditional block */
		errorc (E_NCB);

	    else if (generate) {
		generate = FALSE;
		lastcondon--;
		errorcode = 0;

	    } else if (lastcondon + 1 == condlevel && condtrue
	      && elseflag != F_TRUECOND) {
		generate = TRUE;
		lastcondon++;
		elseflag = F_TRUECOND;
	    } else if (!generate)
		errorcode = 0;
	}

	if (errorcode == E_SND){
	    errorcode = E_PS1&E_ERRMASK;
	    fPass1Err++;
	}
}



/***	errdir - process <ERRxxx> directives
 *
 *	errdir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	ERR			Error
 *		ERR1			Error if pass 1
 *		ERR2			Error if pass 2
 *		ERRE <expr>		Error if zero
 *		ERRNZ <expr>		Error if non-zero
 *		ERRDEF <sym>		Error if defined
 *		ERRNDEF <sym>		Error if undefined
 *		ERRB <arg>		Error if blank
 *		ERRNB <arg>		Error if not blank
 *		ERRDIF <arg1>,<arg2>	Error if args are different
 *		ERRIDN <arg1>,<arg2>	Error if args are identical
 */


VOID	PASCAL CODESIZE
errdir (
){
	register UCHAR	errtrue;
	register SHORT	ecode;

	switch (optyp) {
		case TERR:
			errtrue = TRUE;
			ecode = E_ERR;
			break;
		case TERR1:
			errtrue = !pass2;
			ecode = E_EP1;
			break;
		case TERR2:
			errtrue = pass2;
			ecode = E_EP2;
			break;
		case TERRE:
			errtrue = (exprconst () == 0 ? TRUE : FALSE);
			ecode = E_ERE;
			break;
		case TERRNZ:
			errtrue = (exprconst () == 0 ? FALSE : TRUE);
			ecode = E_ENZ;
			break;
		case TERRDEF:
		case TERRNDEF:
			getatom ();
			if (errtrue = symsrch ())
				errtrue = M_DEFINED & symptr->attr;

			if (optyp == TERRNDEF) {
				errtrue = !errtrue;
				ecode = E_END;
			}
			else
				ecode = E_ESD;
			break;
		case TERRB:
			errtrue = argblank ();
			ecode = E_EBL;
			break;
		case TERRNB:
			errtrue = !argblank ();
			ecode = E_ENB;
			break;
		case TERRIDN:
		case TERRDIF:
			errtrue = argsame ();
			if (optyp == TERRDIF) {
				errtrue = !errtrue;
				ecode = E_EDF;
			}
			else
				ecode = E_EID;
			break;
	}
	if (errorcode == E_SND){

		errorcode = E_PS1&E_ERRMASK;
		fPass1Err++;
	}

	if (errtrue)
		errorc (ecode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmconf.h ===
/* asmconf.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** Ported to NT by Jeff Spencer 12/90 (c-jeffs).
*/


/*
**	M8086OPT  - When defined causes the 8086 optimized assembly
**		    language functions in asmhelp.asm to be used rather
**		    than the C version. This should not be defined when
**		    building for NT.
**
**	BCBOPT	  - MASM 5.10A used a cache to hold the source read
**		    from disk. Because of the complexity of this code
**		    and it's negligable speed improvement this
**		    functionality was not duplicated in the NT port of
**		    this code. The constant BCBOPT was used with the
**		    #ifdef preprocessor directive to remove code
**		    associated with the caching system. All code
**		    contained within BCBOPT segments is dead code.
**
**	OS2_2	  - Should be defined when producing a version of
**		    masm to run on OS2 2.0.
**
**	OS2_NT	  - Should be defined when producing a version of
**		    masm to run on NT (any processor). (OS2_2 and
**		    OS2_NT should not be defined at the same time)
**
**	NOFLOAT   - When defined disables the assembly of floating
**		    point constants. This is usefull when the library
**		    fuctions strtod and _strtold aren't available in
**		    the C library and this functionality of MASM isn't
**		    needed.
**
**	FIXCOMPILERBUG - When defined allows some ifdef's to go around
**		    some known compiler bugs. This include both CL386 and
**		    MIPS compiler bugs. (These have been reported but not
**		    fixed as of 12/5/90.)
**
**	XENIX	  - Once upon a time long, long ago was used to build for
**		    XENIX. I garentee this code is broken.
**	XENIX286  - Dito.
**
**	MSDOS	  - Generates a hodge-podge of usefull code.
**		    This is automatically defined for OS2_NT and OS2_2.
*/

#if defined OS2_2 || defined OS2_NT
    /* Do NOT specify M8086OPT */
    #define M8086		    /* Select 8086 */
    #define MSDOS		    /* Allow usefull older code to be generated */
    #define FLATMODEL		    /* MASM to run under 32 bit flat model */
    #define NOFS		    /* Do not use far symbols */
    #define NOCODESIZE		    /* Don't force near/far mix on functions */
#else

    #ifdef MSDOS		    /* Define MSDOS, XENIX286 from command line */
	#define M8086		       /* Select 8086 if MSDOS or XENIX286 */
    #else

	#ifdef XENIX286
	     #define M8086
	#endif

    #endif

#endif

#ifndef NOFS

#define FS			/* Default is Far symbols */
#endif

#ifndef NOV386

#define V386			/* Default is 386 instructions */
#endif

#ifndef NOFCNDEF

#define FCNDEF			/* Default is parameter checking */
#endif


#ifndef NOCODESIZE

#define CODESIZE near
#else
#define CODESIZE

#endif



/* The following defines are a function the prevoius defines */

#if defined OS2_2 || defined OS2_NT

# define DEF_X87	PX87
# define DEF_CASE	CASEU
# define DEF_CPU	P86
# define DEF_FLTEMULATE	FALSE
# define FARIO

#endif /* XENIX286 */


#if defined XENIX286

/* .286c and .287 are defaults  */

# define DEF_X87	PX287
# define DEF_CASE	CASEL
# define DEF_CPU	P286
# define DEF_FLTEMULATE	TRUE
# define FARIO

#endif

#if !defined XENIX286 && !defined OS2_2 && !defined OS2_NT
# define DEF_X87	PX87
# define DEF_CASE	CASEU
# define DEF_CPU	P86
# define DEF_FLTEMULATE	FALSE
# define FARIO		far
#endif /* XENIX286 */



#ifdef FLATMODEL
# define FAR
# define NEAR
#else
# define FAR	       far
# define NEAR	       near
#endif

#ifdef FS
# define FARSYM        far
#else
# define FARSYM
#endif

#if defined FCNDEF && !defined FLATMODEL
# define PASCAL        pascal
#else
# define PASCAL
#endif

#define VOID	       void
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9


#ifdef V386

# define OFFSET 	unsigned long
# define OFFSETMAX	0xffffffffL

#else

#  define OFFSET	unsigned int
#  define OFFSETMAX	0xffffL

#endif

#define SYMBOL	struct symb
#define DSCREC	struct dscrec
#define UCHAR	unsigned char
#define SCHAR	signed char
#define USHORT	unsigned short
#define SHORT	signed short
#define UINT	unsigned int
#define INT	signed int
#define TEXTSTR struct textstr
#define PARAM	struct param
#define NAME	struct idtext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmctype.h ===
/* asmctype.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#define _AB	0x01	/* blank  */
#define _AO	0x02	/* operator */
#define _AL	0x04	/* end of line */
#define _A1	0x08	/* legal as first character of token */
#define _AT	0x10	/* legal as token character */
#define _AF	0x20	/* character is legal as file name */
#define _AS	0x40	/* character is sign  + or - */
#define _AZ	0x80	/* character is line terminator */

#ifndef ASMINP
 extern UCHAR _asmctype_[];
 extern char _asmcupper_[];
#endif /* ASMINP */

#define LEGAL1ST(c)	(_asmctype_[c] & _A1)
#define TOKLEGAL(c)	(_asmctype_[c] & _AT)
#define ISBLANK(c)	(_asmctype_[c] & _AB)
#define ISFILE(c)	(_asmctype_[c] & _AF)
#define ISEOL(c)	(_asmctype_[c] & _AL)
#define ISSIGN(c)	(_asmctype_[c] & _AS)
#define ISTERM(c)	(_asmctype_[c] & _AZ)
#define ISOPER(c)	(_asmctype_[c] & _AO)

#define NEXTC() 	(*lbufp++)
#define PEEKC() 	(*lbufp)
#define BACKC() 	(lbufp--)
#define SKIPC() 	(lbufp++)
#define MAP(c)		(_asmcupper_[c])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmcref.c ===
/* asmcref.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"

static SYMBOL FARSYM   *crefsym;

/***	crefout - output a cref reference/define
 *
 *	crefout();
 *
 *	Entry	(creftype) = cross reference type
 *		*crefsym = symbol to cross reference
 *		(crefing) = cross-reference type
 *	Exit	cross reference information written to cref file
 *	Returns none
 *	Calls	printf
 */


VOID PASCAL
crefout (
){
    USHORT iProc;
    char szline[LINEMAX];

    if (crefing && pass2 && xcreflag > 0) {

	iProc = (crefsym->symkind == EQU)? crefsym->symu.equ.iProc:
	       ((crefsym->symkind == CLABEL)? crefsym->symu.clabel.iProc: 0);

	if (creftype != CREFEND) {
	    STRNFCPY( szline, crefsym->nampnt->id );
	    if (creftype == DEF)
		fprintf( crf.fil, "\x2%c%c%c%c%c%c%s",
		  *((UCHAR FAR *)&crefsym->symtype),
		  *((UCHAR FAR *)&crefsym->symtype + 1),
		  crefsym->attr, (UCHAR) crefsym->symkind,
		  iProc, *((char *)&iProc+1),
		  szline );
	    else
		fprintf(crf.fil, "%c%c%c%c%s", (UCHAR) crefnum[creftype],
		  (fSecondArg)? opcref & 0xf: opcref >> 4,
		  iProc, *((char *)&iProc+1), szline );

	    creftype = CREFEND;
	}
    }
}




/***	crefline - emit end-of-line to cross-reference file
 *
 *	crefline ();
 *
 *	Entry	errorlineno = current line in source
 *		crefcount = current line in listing file
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL
crefline (
){
	register SHORT	 i;

	if (pass2 && fCrefline && (crefing == CREF_SINGLE)) {
		/* Output cref info */
		if (creftype != CREFEND)
			/* Force out last symbol */
			crefout ();
		/** Show this was line * */

		i = (crefopt || !lsting)? pFCBCur->line: crefcount;
		fprintf (crf.fil, "\4%c%c", (char)i, (char)(i>>8));
	}
}




/***	crefnew - set up new cross reference item
 *
 *	crefnew(crefkind);
 *
 *	Entry	crefkind = cross reference type (REF/DEF)
 *		*symptr = symbol to cross reference
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL
crefnew (
	UCHAR	crefkind
){
	if (xcreflag > 0 && !(symptr->attr & M_NOCREF)) {

		creftype = crefkind;
		crefsym = symptr;
	}
}




/***	crefdef - output a reference definition
 *
 *	crefdef();
 *
 *	Entry	*symptr = symbol to output definition for
 *	Exit	none
 *	Returns none
 *	Calls	crefnew, crefout
 */


VOID PASCAL
crefdef (
){
	if (crefing && !(symptr->attr & M_NOCREF)) {
		crefnew( DEF );
		crefout();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmdata.c ===
/* asmdata.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include <ctype.h>
#include "asmindex.h"
#include "asmctype.h"
#include "asmmsg.h"

extern UCHAR mpRealType[];

/* Dup tree is organized left to right horizonatally for each
	  item in a DUP list at the same level( i. e. 5 DUP(1,2,3) ).
	  This is considered the 'list' part. Any item in the list
	  may be another DUP header instead of a data entry, in
	  which case you go down a level and have another list.
 */


char uninitialized[10];
char fInDup;


/***	scanstruc - scan structure tree and execute function
 *
 *	scanstruc (dupr, disp);
 *
 *	Entry	*dupr = duprec structure entry
 *		disp = pointer to function to execute at each node
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
scanstruc (
	struct duprec  FARSYM *dupr,
	VOID   (PASCAL CODESIZE *disp) (struct duprec FARSYM *)
){
	struct duprec FARSYM *ptr;
	struct duprec FARSYM *iptr;
	struct duprec FARSYM *fldptr;
	struct duprec FARSYM *initptr;
	OFFSET strucpc;

	/* save starting address of structure */
	strucpc = pcoffset;
	if (dupr)
		/* Output <n> DUP( */
		(*disp) (dupr);
	/* 1st default value for STRUC */
        fldptr = recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->duptype.dupnext.dup;
	/* 1st initialize value */
	initptr = strucoveride;
	if (initptr) {
		/* process initialization fields for structure */
		while (fldptr) {
                        if (fldptr->itemcnt == 1 && fldptr->duptype.dupnext.dup->itemcnt == 0
			    && initptr->duptype.dupitem.ddata)
				/* Use default */
				ptr = initptr;
			else
				/* Can't override field */
				ptr = fldptr;
			iptr = ptr->itemlst;
			ptr->itemlst = NULL;
			if (displayflag && !dupr) {
				offsetAscii (strucpc);
				listindex = 1;
				/* Display PC */
				copyascii ();

				listindex = LSTDATA;
				if (highWord(strucpc))
				    listindex += 4;
			}
			if (ptr->rptcnt > 1 || ptr->itemcnt > 1)
				/* Output <n> DUP( */
				(*disp) (ptr);
			/* Display field */
			scanlist (ptr, disp);
			if (ptr->rptcnt > 1 || ptr->itemcnt > 1)
				enddupdisplay ();
			if (displayflag && !dupr) {
				/* Calc size of field */
				clausesize = calcsize (ptr);
				if (dupr)
					clausesize *= dupr->rptcnt;
				strucpc += clausesize;
			}
			/* Restore */
			ptr->itemlst = iptr;
			if (displayflag && (listbuffer[LSTDATA] != ' ' ||
			    listbuffer[14] != ' ')) {

				resetobjidx ();
			}
			/* Advance default field */
			fldptr = fldptr->itemlst;
			/* Advance override field */
			initptr = initptr->itemlst;
		}
	}
	if (dupr)
		enddupdisplay ();
}





/***	scandup - scan DUP tree and execute function
 *
 *	scandup (tree, disp);
 *
 *	Entry	*tree = DUP tree
 *		*disp = function to execute at each node of tree
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
scandup (
	struct duprec	FARSYM *tree,
	VOID		(PASCAL CODESIZE *disp)(struct duprec FARSYM *)
){
	if (tree)
	    if (strucflag && initflag)
		/* Want to skip STRUC heading */
		if (tree == recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody)

		    /* This is not <n> DUP(<>) So no DUP prefix */

		    scanstruc ((struct duprec FARSYM *)NULL, disp);

		else	{  /* must set itemcnt in DUP to # fields */

		    tree->itemcnt = recptr->symu.rsmsym.rsmtype.rsmstruc.strucfldnum;
		    scanstruc (tree, disp);
		}
	    else /* Else is not STRUC */

		scanlist (tree, disp);
}




/***	oblitdup - delete DUP entry
 *
 *	oblitdup (node);
 *
 *	Entry	*node = DUP entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
oblitdup (
	struct duprec  FARSYM *node
){
	switch (node->dupkind) {
		case NEST:
			_ffree ((char FARSYM *)node);
			break;
		case ITEM:
			if (node->duptype.dupitem.ddata)
				dfree ((char *)node->duptype.dupitem.ddata );
			_ffree ((char FARSYM *)node);
			break;
		case LONG:
			if (node->duptype.duplong.ldata != uninitialized)
			    free ((char *)node->duptype.duplong.ldata);

			_ffree ((char FARSYM *)node);
			break;
		default:
			TERMINATE(ER_FAT, 99);
	}
}




/***	displlong - display long constant
 *
 *	displaylong (dup);
 *
 *	Entry	*dup = dup entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
displlong (
        struct duprec FARSYM  *dup
){
	register USHORT  cnt;
	register char *p;

        p = dup->duptype.duplong.ldata;

        for (cnt = dup->duptype.duplong.llen; cnt;  cnt--) {

		if (optyp == TDW || optyp == TDD)

		    emitopcode ((UCHAR)p[cnt-1]);
		else
		    emitopcode ((UCHAR)*p++);

		if (optyp != TDB)
		    listindex--;
	}
	if (optyp != TDB)
	    listindex++;
}




/***	begdupdisplay - begin DUP display
 *
 *	begdupdisplay (dup);
 *
 *	Entry	*dup = DUP entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
begdupdisplay (
        struct duprec FARSYM  *dup
){
	/* flush line if data already displayed */

	if ((highWord(pcoffset) && listbuffer[LSTDATA+3] != ' ') ||
	    listbuffer[LSTDATA] != ' ')

	    resetobjidx ();

	listindex = LSTDATA + duplevel;   /* Indent for DUP clause */
	if (highWord(pcoffset))
	    listindex += 4;

        offsetAscii (dup->rptcnt);   /* display repeat count in four bytes */
	copyascii ();
	listbuffer[listindex] = '[';
	duplevel++;		     /* Indent another level */
	resetobjidx (); 	     /* Display DUP repeat line */
}




/***	enddupdisplay - end DUP display
 *
 *	enddupdisplay ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
enddupdisplay (
){
    if (duplevel) {
	duplevel--;

	if (displayflag) {
	     listbuffer[LSTMAX - ((duplevel <= 8)? duplevel: 8)] = ']';
	     resetobjidx ();
	}
    }
}


/***	itemdisplay - display DUP data item
 *
 *	itemdisplay (dup);
 *
 *	Entry	*dup = dup record
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
itemdisplay (
        struct duprec FARSYM  *dup
){
	if (listindex > LSTMAX)
		resetobjidx ();

        if (dup->dupkind == ITEM)

            emitOP (&dup->duptype.dupitem.ddata->dsckind.opnd);
	else
            displlong (dup);

	if (duplevel)
	     resetobjidx ();
}




/***	dupdisplay - display DUP item on listing
 *
 *	dupdisplay (ptr);
 *
 *	Entry	*ptr = DUP entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
dupdisplay (
	struct duprec FARSYM  *ptr
){
	if (ptr->dupkind == NEST)
		begdupdisplay (ptr);
	else
		itemdisplay (ptr);
}




/***	linkfield - add item to list of DUP for current STRUC
 *
 *	linkfield (nitem);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
linkfield (
	struct duprec FARSYM  *nitem
){
	struct duprec FARSYM  *ptr;

	if (strucprev->itemcnt++ == 0)/* 1st item in field */
                strucprev->duptype.dupnext.dup = nitem;
	else {
                ptr = strucprev->duptype.dupnext.dup;
		while (ptr->itemlst)
			ptr = ptr->itemlst;
		/* Add to end of list */
		ptr->itemlst = nitem;
	}
}



/***	longeval - evaluate long non-floating point, non-BCD constant
 *
 *	longeval (base, p);
 *
 *	Entry	delim = delimiter character
 *	Exit
 *	Returns
 *	Calls
 */

#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, longeval)
#endif

VOID PASCAL
longeval (
	USHORT		base,
	register struct realrec  *p
){
	register char cc;
	char	sign;
	USHORT	carry;
	USHORT	t;
	USHORT	i;

	sign = ((cc = NEXTC ()) == '-')? TRUE: FALSE;
	if (ISSIGN (cc))
		cc = MAP (NEXTC ());
	do {
		if ((t = (cc - '0') - ('A' <= cc) * ('A' - '0' - 10)) >= base)
			ferrorc (E_NDN);
		carry = (t += p->num[0] * base) >> 8;
		p->num[0] = t & 255;
		for (i = 1; i < 10; i++) {
			carry = (t = p->num[i] * base + carry) >> 8;
			p->num[i] = t & 255;
		}
		if (carry)
			/* Overflow */
			ferrorc (E_DVZ);
	} while ((cc = MAP (NEXTC ())) != delim);

	if (cc == 0)
		BACKC ();
	if (sign) {
		carry = 1;
		for (i = 0; i < 10; i++) {
			p->num[i] = (unsigned char)((t = (~p->num[i] & 0xff) + carry));
			carry = t >> 8;
		}
		if (datadsize[optyp - TDB] < i && carry)
		       ferrorc (E_DVZ);
	}
}




/***	bcddigit - evaluate bcd digit
 *
 *	bcddigit (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, bcddigit)
#endif

VOID PASCAL
bcddigit (
	struct realrec	  *p
){
	USHORT	v;
	register char cc;

	v = (cc = NEXTC ()) - '0';
	if (!isdigit (cc))
		ferrorc (E_NDN);

	if (isdigit (PEEKC ()))
		bcddigit (p);

	if (p->i & 1)
		v <<= 4;

	p->num[p->i / 2 ] = p->num[p->i / 2 ] + v;
	if (p->i < 18)
		p->i++;
}




/***	bcdeval - evaluate bcd constant
 *
 *	bcdval (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	BCD numbers come out low digit 1st
 */


#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, bcdeval)
#endif

VOID PASCAL
bcdeval (
	struct realrec	  *p
){
	register char cc;


	p->num[9] = ((cc = PEEKC ()) == '-')? 0x80: 0;
	p->i = 0;
	if (ISSIGN (cc))
		SKIPC ();

	bcddigit (p);
	if (p->num[9] & 15)
		ferrorc (E_DVZ);
}


/***	parselong - parse long constant
 *
 *	parselong (p);
 *
 *	Entry	*p = data descriptor entry
 *	Exit	p->longstr = TRUE if long data entry parsed
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
parselong (
	register struct dsr    *p
){
	struct realrec	a;
	register UCHAR *cp;
	register UCHAR cc;
	register USHORT rbase;
	register char expflag;
	SHORT cb;
	char dseen = 0;
	char fNonZero;
	char fSigned = FALSE;

	if (ISBLANK (PEEKC ()))
		skipblanks ();

	p->dirscan = lbufp;
	if (ISSIGN(cc = (NEXTC ()))) {
		fSigned++;
		cc = NEXTC ();
	}

	if (isdigit (cc) || (cc == '.')) {

	    /* Some numeric constant */

	    p->floatflag = (cc == '.');
	    expflag = FALSE;

	    do {
		if ((cc = MAP (NEXTC ())) == 'E')
			expflag = TRUE;
		if (cc == '.')
			p->floatflag = TRUE;

	    } while (isxdigit (cc) || isalpha (cc) ||
		     (expflag && ISSIGN (cc)) || cc == '.');

	    /* save address of end of string and check delimiter */
	    BACKC ();
	    cp = lbufp;
	    p->longstr = ISTERM (cc = skipblanks ()) || cc == ',' ||
			 cc == ')' || cc == '>';
	    lbufp = cp;
	}
	cb = datadsize[optyp - TDB];

	if (p->longstr) {

	    memset(a.num, 0, 10);
	    BACKC ();
	    switch (delim = MAP (NEXTC ())) {
		    case 'B':
			    rbase = 2;
			    break;
		    case 'D':
			    rbase = 10;
			    dseen++;
			    break;
		    case 'H':
			    rbase = 16;
			    break;
		    case 'O':
		    case 'Q':
			    rbase = 8;
			    break;
		    case 'R':
			    /* check width of real constant */
			    rbase = (unsigned short)(lbufp - p->dirscan - 1);
			    if (*(p->dirscan) == '0')
				    rbase--;

			    if (rbase != cb*2)
				    errorc (E_IIS);

			    rbase = 16;
			    p->floatflag = TRUE;
			    break;
		    default:
			    delim = PEEKC ();
			    if (radixescape)
				    rbase = 10;
			    else {
				    rbase = radix;
				    if (p->floatflag)
					rbase = 10;
				    else if (radix == 10 && expflag)
					p->floatflag = TRUE;
			    }
			    break;
	    }
	    lbufp = p->dirscan;
	    if (p->floatflag && rbase != 16)
		realeval (&a);

	    else if (rbase) {
		if (rbase == 10 && optyp == TDT && !dseen)
			bcdeval (&a);
		else {
			longeval (rbase, &a);
			if (delim == '>' || delim == ')' || delim ==',')
				BACKC ();
		}
	    }

	    p->dupdsc =
	      (struct duprec FARSYM *) falloc( sizeof(*p->dupdsc), "parselong");

	    p->dupdsc->dupkind = LONG;
	    p->dupdsc->duptype.duplong.llen = (unsigned char)cb;

	    p->dupdsc->type = typeFet(cb);

	    if (fSigned)
		p->dupdsc->type &= ~(BT_UNSIGNED << 2);

	    if (p->floatflag)
		p->dupdsc->type = mpRealType[cb];

	    cp = nalloc( cb, "parselong");

	    p->dupdsc->duptype.duplong.ldata = cp;
	    for (a.i = 0; a.i < cb; a.i++)
		    *cp++ = a.num[a.i];

	    /* size check if something less the max allowable #  */

	    if (cb != 10) {

		    fNonZero = FALSE;
		    for (cp = a.num,cc = 0; cc < cb; cc++, cp++)
			    fNonZero |= *cp;

		    /* Check for value that has overflowed the defined
		       data types length or values that are entirly
		       greater then the length - ie dw 0F0000H */

		    for (; cc < 10; cc++, cp++)

			    /* == 0xFF passes sign extended negative #'s */

			    if (*cp &&
			       (*cp != 0xFF || !fNonZero))
				    errorc (E_DVZ);
	    }
	}
	else
		/* reset character pointer to allow rescan of line */
		lbufp = p->dirscan;
}




/***	datadup - function
 *
 *	datadup ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
datadup (
	struct dsr *p
){
	register char cc;
	register struct psop *pso;
	struct duprec  FARSYM *dupptr;
	struct duprec  FARSYM *listend;
	struct duprec  FARSYM *dupdsc;
	struct datarec drT;

	/* dup count must be constant and not forward reference */
	fInDup = TRUE;
	forceimmed (p->valrec);
	errorforward (p->valrec);
	pso = &(p->valrec->dsckind.opnd);
	if (pso->dsign || pso->doffset == 0) {
		/* force repeat count to be > 0 */
		pso->doffset = 1;
		errorc (E_IDV);
	}
	dupptr = (struct duprec FARSYM *) falloc (sizeof (*dupptr), "datadup");

	/* No items in DUP list */
	dupptr->itemcnt = 0;
	dupptr->type = 0;
	dupptr->dupkind = NEST;
	dupptr->itemlst = NULL;
        dupptr->duptype.dupnext.dup = NULL;

	/* copy repeat count and release parse stack descriptor */
	dupptr->rptcnt = pso->doffset;
	dfree ((char *)p->valrec );
	listend = NULL;
	if (ISBLANK (PEEKC ()))
		skipblanks ();
	if ((cc = NEXTC ()) != '(') {
		error (E_EXP,"(");
		BACKC ();
	}
	/* Now parse DUP list */
	do {
		dupdsc = datascan (&drT);

		if (! dupptr->type)
		    dupptr->type = dupdsc->type;

		if (!listend)
                        dupptr->duptype.dupnext.dup = dupdsc;
		else
			listend->itemlst = dupdsc;

		listend = dupdsc;
		dupptr->itemcnt++;

		if (ISBLANK (PEEKC ()))
			skipblanks ();

		if ((cc = PEEKC ()) == ',')
			SKIPC ();

		else if (cc != ')') {
			error (E_EXP,")");

			if (!ISTERM(cc))
				*lbufp = ' ';
		}
	} while ((cc != ')') && !ISTERM (cc));
	if (ISTERM (cc))
		error (E_EXP,")");
	else
		SKIPC ();

	fInDup = FALSE;
	return (dupptr);
}





/***	datacon - data constant not string
 *
 *	datacon (p);
 *
 *	Entry	*p = parse stack entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
datacon (
	struct dsr *p
){
	register struct psop *psor;

	/* See if expr or DUP */
	/* Not <n> DUP() */
	p->flag = FALSE;
	if (initflag && (PEEKC () == '<'))
		initrs (p);
	else	{

		/* Not initialize list */

		p->dirscan = lbufp;
		p->valrec = expreval (&nilseg);
		psor = &(p->valrec->dsckind.opnd);

		if (strucflag && !initflag &&
		    (psor->dflag == FORREF || psor->dflag == UNDEFINED))
			/* Forward in struc body */
			errorc (E_IFR);

		if (psor->mode !=4 && !isdirect(psor))
			errorc (E_IOT);

		if (psor->seg != NOSEG)
			errorc (E_IOT);

		if (dupflag) {
			/* Have DUP operator */
			getatom ();
			p->flag = TRUE;
		}
		else if (strucflag && initflag && !p->initlist) {
			lbufp = p->dirscan;
			symptr = recptr;
			p->dupdsc = strucparse ();
			p->initlist = TRUE;
		}
	}
	if (p->flag)
		p->dupdsc = datadup (p);
	else {
		if (!p->initlist || !initflag)
			subr1 (p);
	}
}




/***	subr1 -
 *
 *	subr1 (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
subr1 (
	struct dsr *p
){
	USHORT i;
	register struct psop *psor;
	char *cp;
	long l;

	psor = &(p->valrec->dsckind.opnd);

	if (fSimpleSeg)
	    makeGrpRel (psor);

	/* Not init list */
	if (optyp == TDB)
		valuecheck (&psor->doffset, 0xff);

	else if (optyp == TDW)
		valuecheck (&psor->doffset, (USHORT)0xffff);

	if ((optyp != TDW) && (optyp != TDD) && optyp != TDF) {

		if ((psor->mode != 3) && (psor->mode != 4))
			errorc (E_CXP);

		psor->mode = 4;
		psor->w = FALSE;
		psor->fixtype = FCONSTANT;
	}

	if (initflag)
		errorc (E_OIL);

	p->dupdsc = (struct duprec FARSYM *) falloc (sizeof(*p->dupdsc), "subr1");

	if (!(fInDup && psor->dflag == INDETER) &&
		    !(psor->dsegment || psor->dflag == XTERNAL)) {

		p->dupdsc->dupkind = LONG;
		psor->dsize = p->dupdsc->duptype.duplong.llen = (unsigned char)(datadsize[optyp -  TDB]);
		p->dupdsc->type = typeFet(psor->dsize);

		if (ISSIGN(*p->dirscan))
		    p->dupdsc->type &= ~(BT_UNSIGNED << 2);

		if (psor->dflag == INDETER || psor->doffset == 0) {

		    p->dupdsc->duptype.duplong.ldata = uninitialized;
		}
		else {

		    cp = nalloc (p->dupdsc->duptype.duplong.llen, "subr1");

		    p->dupdsc->duptype.duplong.ldata = cp;
		    if (psor->dsign && psor->doffset)
			    psor->doffset = ~psor->doffset + 1;

		    l = psor->doffset;
		    for (i = 0; i < p->dupdsc->duptype.duplong.llen; i++){
			    *cp++ = (char)l;
			    l >>= 8;
		    }
		}

		dfree ((char *)p->valrec );
	}
	else {
		if (psor->mode != 4 && !isdirect(psor))
			/* Immediate or direct only */
			errorc (E_IOT);

		if ((psor->fixtype == FGROUPSEG || psor->fixtype == FOFFSET) &&
		    ((optyp == TDD && wordsize == 2 && !(psor->dtype&M_EXPLOFFSET)) ||
		      optyp == TDF))

			psor->fixtype = FPOINTER;

		/* Size of item */
		varsize = (unsigned short)psor->dsize;

		psor->dsize = datadsize[optyp - TDB];

		/* If item size is byte, make link output byte too */

		psor->w = TRUE;

		if (psor->dsize == 1) {
		    psor->w--;

		    if (psor->fixtype != FHIGH &&
		       (psor->dflag == XTERNAL || psor->dsegment ||
			psor->dcontext))

			psor->fixtype = FLOW;
		}
		mapFixup(psor);

		*naim.pszName = NULL;
		if (psor->fixtype == FCONSTANT)
		    p->dupdsc->type = typeFet(psor->dsize);
		else
		    p->dupdsc->type = fnPtr(psor->dsize);

		p->dupdsc->dupkind = ITEM;
		p->dupdsc->duptype.dupitem.ddata = p->valrec;
	}
}




/***	initrs - initialize record/structure
 *
 *	initrs (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
initrs (
	struct dsr *p
){
	register char *cp;
	SHORT cb;

	/* Initializing RECORD/STRUC */
	symptr = recptr;
	if (strucflag)
		p->dupdsc = strucparse ();
	else {
		/* Get value of record */
		p->i = recordparse ();
		/* Make long constant */
		p->dupdsc =
		  (struct duprec FARSYM *)falloc (sizeof (*p->dupdsc), "initrs");
		p->dupdsc->dupkind = LONG;
        cb = recptr->symtype;
		p->dupdsc->duptype.duplong.llen = (unsigned char) cb;

		cp = nalloc (cb, "initrs");

		p->dupdsc->duptype.duplong.ldata = cp;
		p->dupdsc->type = typeFet(cb);

		while(cb--){
		    *cp++ = (char)p->i;
		    p->i >>= 8;
		}
	}
	p->initlist = TRUE;
}




/***	datadb - process <db> directive
 *
 *	datadb ();
 *
 *	Entry	*lbufp = beginning quote (\'|\") of string
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
datadb (
	register struct  dsr *p
){
	register USHORT i;
	register char *cp;

	/* Save ptr to start of string */
	p->dirscan = lbufp;
	delim = NEXTC ();
	/* Compute string length */
	i = 0;
	while (!endstring ()) {
		SKIPC ();
		i++;
	}
	/* reset scan pointer */
	lbufp = p->dirscan;
	if (i == 0)
		errorc (E_EMS);
	else if (i > 1) {
		SKIPC ();
		/* Long string */
		p->longstr = TRUE;

		/* Create entry for long string */
		p->dupdsc =
		  (struct duprec FARSYM *)falloc (sizeof (*p->dupdsc), "datadb");

		/* Initialize text area for data */
		p->dupdsc->dupkind = LONG;
		p->dupdsc->type = makeType(BT_ASCII, BT_DIRECT, BT_sz1);
		p->dupdsc->duptype.duplong.llen = (unsigned char)i;
		cp = nalloc ( (USHORT)(p->dupdsc->duptype.duplong.llen + 1), "datadb");
		p->dupdsc->duptype.duplong.ldata = cp;
		for (; i; i--)
			if (!endstring ())
				*cp++ = NEXTC ();
		*cp = 0;
		SKIPC ();
	}
}


/***	dataitem - parse next data item from line
 *
 *	dataitem (p);
 *
 *	Entry	p = pointer to datarec structure
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
dataitem (
	struct datarec	  *p
){
	struct duprec FARSYM *topitem;

	/* Scan , may recurse on DUP */
	topitem = datascan (p);
	/* Display scan now */
	displayflag = TRUE;
	/* Display data */
	scandup (topitem, dupdisplay);
	displayflag = FALSE;

	if (p->datalen == 0)
		p->datalen = topitem->rptcnt;

	if (topitem->dupkind == NEST) {

		/* This item was a DUP */
		resvspace = TRUE;
		/* Get size of DUP list */
		clausesize = calcsize (topitem);
		if (strucflag && initflag)
			resvspace = FALSE;

		if (pass2 && !(resvspace || p->buildfield))
			/* Send to linker */
			if (!emitdup (topitem))
				errorc (E_DTL);

		if (! p->type)
		    p->type = topitem->type;

		if (p->buildfield)
			linkfield (topitem);

		else if (strucflag && initflag) {
			/* Allocating STRUC */
			strucflag = FALSE;
			/* Free overrides */
			scandup (strucoveride, oblitdup);
			/* Turn back on */
			strucflag = TRUE;
			}
		else		/* Not STRUC allocate */
			scandup (topitem, oblitdup);
	}
	else {
		/* Some kind of list */
		clausesize = (topitem->dupkind == ITEM)
			? topitem->duptype.dupitem.ddata->dsckind.opnd.dsize
			: topitem->duptype.duplong.llen;

		if (pass2 && !p->buildfield) {
		    if (topitem->dupkind == ITEM)

		       emitobject (&topitem->duptype.dupitem.ddata->dsckind.opnd);
		    else
		       emitlong (topitem);
		}
		if (! p->type)
		    p->type = topitem->type;

		if (p->buildfield)
			linkfield (topitem);
		else
			oblitdup (topitem);
	}
	/* Add in size of this item */
	pcoffset += clausesize;
	skipblanks ();
}




/***	datadefine -
 *
 *	datadefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
datadefine (
){
	struct datarec	a;
	short cc;

	strucoveride = NULL;
	a.buildfield = (strucflag && !initflag)? TRUE: FALSE;
	a.type = 0;

	if (labelflag) {	/* Have label */
		labelcreate ( (USHORT)2, (UCHAR) (a.buildfield ? (UCHAR) STRUCFIELD : (UCHAR) CLABEL));
		if (errorcode == (E_ERRMASK & E_SDK))
		    return;

		if (strucflag && initflag){
		   a.type = recptr->symu.rsmsym.rsmtype.rsmstruc.type;
		}
	}
	else
		pcdisplay ();

	a.labelptr = symptr;	/* Save ptr to entry */
	a.datalen = 0;		/* Don't know length */
	emittext = FALSE;	/* Prevent link emitter */
	duplevel = 0;

	/* Scan item list */
	if (ISTERM (PEEKC ()))
		errorc (E_OPN);
	else {
	    BACKC ();
	    do {
		SKIPC ();

		if ((cc = skipblanks ()) == ',' || cc == ';' || ISTERM(cc))
			errorc(E_MDZ);

		dataitem (&a);

	    } while (PEEKC () == ',');
	}
	if (labelflag) {
	    a.labelptr->symtype = datadsize[optyp - TDB];

	    if (a.buildfield) {
		/* Making STRUC body */
		if (a.labelptr->symkind == STRUCFIELD) {

		    if (struclabel)
			struclabel->symu.struk.strucnxt = a.labelptr;
		    else
			recptr->symu.rsmsym.rsmtype.rsmstruc.struclist = a.labelptr;

		    /* Constant, no segment */
		    a.labelptr->symsegptr = NULL;
		    /* End of named list */
		    a.labelptr->symu.struk.strucnxt = NULL;
		    a.labelptr->symu.struk.type = a.type;
		    struclabel = a.labelptr;
		}
	    }
	    else
		a.labelptr->symu.clabel.type = a.type;

	    /* Set length */
	    a.labelptr->length = (unsigned short)a.datalen;
	}
	emittext = TRUE;
}


/***	commDefine - define a communal variable
 *
 *	Format: comm {far|near} name:size[:#Ofitems],....
 *
 */


VOID PASCAL CODESIZE
commDefine (
){
	USHORT distance;
	char cT, *pT;
	USHORT symtype;
	SYMBOL FARSYM *pSY;

	getatom ();

	distance = (farData[10] > '0')? CSFAR: CSNEAR;

	if (fnsize ()){ 		    /* look for optional near | far */

	    distance = varsize;
	    getatom ();

	    if (distance < CSFAR)
		errorc (E_UST);
	}

	cT = symFet (); 		    /* fetch name and save for later */
	pSY = symptr;

	if (*naim.pszName == NULL){
	   errorc(E_OPN);
	   return;
	}

	if (NEXTC() != ':')
	    errorc (E_SYN);
					    /* get the size of the item */
	pT = lbufp;
	switchname ();
	getatom();


	if (symFet() && symptr->symkind == STRUC){

	    varsize = symptr->symtype;
	}
	else {
	    lbufp = pT;
	    if (pT = (char *)strchr(pT, ':'))
		*pT = NULL;

	    varsize = (USHORT)exprconst();

	    if (pT)
		*pT = ':';
	}
	if (!varsize)
	    errorc(E_IIS &~E_WARN1);

	if (cT)
	    symptr = pSY;

	externflag (DVAR, cT);
	pSY = symptr;
	pSY->symu.ext.length = 1;
	pSY->symu.ext.commFlag++;

	if (skipblanks() == ':'){	       /* optional size given */

	    fArth32++;				/* allow >64 items */
	    SKIPC();

	    if ((pSY->symu.ext.length = exprconst()) == 0)  /* get the # items */
		  errorc(E_CXP);

	    fArth32--;
	    if (pSY->symu.ext.length * pSY->symtype > 0xffff)
		pSY->symu.ext.commFlag++;	/* for >64K convert to far */
	}

	if (distance == CSFAR)
	    pSY->symu.ext.commFlag++;	       /* 2 means far commdef */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmdir.c ===
/* asmdir.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <stdlib.h>
#include "asm86.h"
#include "asmfcn.h"
#include <fcntl.h>
#include <errno.h>
#include <string.h>

#ifndef XENIX286
    #include <share.h>
    #include <io.h>
#endif

#include "asmctype.h"
#include "asmindex.h"
#include "asmmsg.h"

extern PFPOSTRUCT  pFpoHead;
extern PFPOSTRUCT  pFpoTail;
extern unsigned long numFpoRecords;

SHORT CODESIZE fetLang(void);
int PASCAL CODESIZE trypathname PARMS((char *));
int PASCAL CODESIZE openincfile PARMS(( void ));
VOID PASCAL CODESIZE creatPubName (void);
extern char *siznm[];

/***    setsymbol - set attribute in symbol
 *
 *      setsymbol (bit);
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
setsymbol (
          UCHAR   bit
          )
{
    /* Scan symbol name */

    if (getatom ()) {
        if (!symsrch ())
            errorn (E_SND);

        symptr->attr |= bit;
    }
}




/***    publicitem - scan symbol and make PUBLIC
 *
 *      publicitem ();
 *
 *      Entry   naim = symbol name
 *      Exit    Global attribute set in symbol entry
 *      Returns none
 *      Calls   error, scanatom, symsearch
 */


VOID
PASCAL
CODESIZE
publicitem()
{
    static char newAttr;

    if (getatom ()) {

        newAttr = NULL;
        if (fetLang() == CLANG)
            newAttr = M_CDECL;

        if (!symsrch ()) {

            /* define forward refernced name, so global attribute
             * is available on the end of pass 1 */

            symcreate ( (UCHAR)(M_GLOBAL | newAttr), (UCHAR)PROC);
        } else {
            symptr->attr |= newAttr;

            /*  public is legal for an alias if target ok */
            if (symptr->symkind == EQU &&
                symptr->symu.equ.equtyp == ALIAS)
                if (! (symptr = chasealias (symptr))) {
                    errorc(E_TUL);
                    return;
                }

            if (pass2) {    /* catch forward reference symbol errors */

                if (! (symptr->attr & M_GLOBAL))
                    errorn (E_IFR);

                else if ((symptr->attr&~M_CDECL) == M_GLOBAL ||
                         !(symptr->attr & M_DEFINED))
                    errorn (E_SND);

            }

            switch (symptr->symkind) {
                case PROC:
                case DVAR:
                case CLABEL:
                    if (M_XTERN & symptr->attr)
                        errorc (E_SAE);
                    break;
                case EQU:
                    if (symptr->symu.equ.equtyp != EXPR)
                        errorc (E_TUL);
                    break;
                default:
                    errorc (E_TUL);
            }
        }
        creatPubName();
    }
}


VOID
PASCAL
CODESIZE
creatPubName ()
{
    symptr->attr |= M_GLOBAL;

    if (caseflag == CASEX && symptr->lcnamp == NULL)
        symptr->lcnamp =
#ifdef M8086
        creatlname (naim.pszLowerCase);
#else
        createname (naim.pszLowerCase);
#endif
}


/***    xcrefitem - scan symbol and xcref it
 *
 *      xcrefitem ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
xcrefitem ()
{
    if (pass2 && !loption) {
        setsymbol (M_NOCREF);
        creftype = CREFEND;
    } else
        getatom ();
}




/***    externflag -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
externflag (
           register UCHAR   kind,
           register UCHAR   new
           )
{
    switchname ();
    /* Make name be extern name */
    if (!new) {
        /* Create symbol */
        symcreate (M_XTERN | M_DEFINED,
                   (UCHAR)((kind == CLABEL)? DVAR: kind));

        symptr->symkind = kind;

        if (caseflag == CASEX)
            symptr->lcnamp =
#ifdef M8086
            creatlname (naim.pszLowerCase);
#else
            createname (naim.pszLowerCase);
#endif /* M8086 */
        symptr->symtype = varsize;
        symptr->length = 1;
        if (kind == EQU)
            /* expr type EQU is constant */
            symptr->symu.equ.equtyp = EXPR;
        else
            symptr->symsegptr = pcsegment;

        if (pass2)
            emitextern (symptr);
    }
    checkRes();
    crefdef ();
    if (! (M_XTERN & symptr->attr))
        errorc (E_ALD);
    else {
        if (kind != symptr->symkind || symptr->symtype != varsize ||
            (symptr->length != 1 && kind != EQU) &&
            (symptr->symsegptr != pcsegment &&
             !(fSimpleSeg && varsize == CSFAR)))

            errorn (E_SDK);
        else {
            symptr->attr |= M_XTERN | M_BACKREF;

            if (fSimpleSeg && varsize == CSFAR) {
                symptr->symsegptr = NULL;
            } else if (varsize == CSNEAR ||
                       (varsize == CSFAR && pcsegment))

                symptr->symu.clabel.csassume = regsegment[CSSEG];

        }
    }
}





/***    externitem -
 *
 *      externitem ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

VOID
PASCAL
CODESIZE
externitem ()
{
    register char new;
    char newAttr;

    /* Get name of external */

    if (getatom ()) {

        newAttr = NULL;
        if (fetLang() == CLANG)
            newAttr = M_CDECL;

        new = symFetNoXref ();
        switchname ();          /* Save name of external */

        if (NEXTC () != ':')
            errorc (E_SYN);

        else {
            /* Scan name of extern type */
            getatom ();

            if (tokenIS("abs")) {

                equsel = EXPR;
                varsize = 0;
                externflag (EQU, new);
            } else if (!fnsize ())
                errorc (E_UST);

            else {
                if (varsize >= CSFAR) {
                    /* NEAR | FAR */
                    externflag (CLABEL, new);
                }

                else    /* data reference */

                    externflag (DVAR, new);

            }
            symptr->attr |= newAttr;
        }
    }
}




/***    segcreate - create and initialize segment
 *
 *      segcreate (makeseg);
 *
 *      Entry   makeseg = TRUE if segement is to be make
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
segcreate (
          register UCHAR   makeseg
          )
{

    if (pass2) /* Segment must be defined */
        errorn (E_PS1);

    if (makeseg)
        symcreate (0, SEGMENT);
    else
        symptr->symkind = SEGMENT;

    /* Initialize segment data */
    symptr->symu.segmnt.align = -1;
    symptr->symu.segmnt.use32 = -1;
    symptr->symu.segmnt.combine = 7;
}




/***    addglist - add segment to group list
 *
 *      addglist ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
addglist ()
{
    register SYMBOL FARSYM *p, FARSYM *pSY;

    p = symptr;

    if (pass2)
        if (!(M_DEFINED & p->attr))
            errorn (E_PS1);

        /* Can get segment in 2 group lists unless check
         * symptr->grouptr == curgroup */

    if (p->symu.segmnt.grouptr) {
        if (p->symu.segmnt.grouptr != curgroup)
            /* Trying to put in 2 groups */
            errorc (E_SPC);
        return;
    }
    p->symu.segmnt.grouptr = curgroup;
    pSY = curgroup->symu.grupe.segptr;

    if (!pSY)
        curgroup->symu.grupe.segptr = p;

    else {

        /* scan the list of segments on the group */

        do {
            if (pSY == p)          /* already on list */
                return;

        } while (pSY->symu.segmnt.nxtseg &&
                 (pSY = pSY->symu.segmnt.nxtseg));

        /* Link into list */
        pSY->symu.segmnt.nxtseg = p;
    }
}




/***    groupitem -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
groupitem ()
{

    if (!getatom ())
        error (E_EXP,"segment name");

    else if (!fnoper ()) {

        /* Have a segment name */

        if (!symFet())
            /* Forward segment, make it */
            segcreate (TRUE);

        /* If not segment, could be class so make undef */
        if (symptr->symkind != SEGMENT)

            /* If a class, consider undef instead of wrong kind */
            errorn ((USHORT)((symptr->symkind == CLASS) && !pass2 ?
                             E_IFR : E_SDK));

        else if (symptr->attr & M_DEFINED || !pass2) {
            if (curgroup)
                addglist ();
        } else
            errorn (E_PS1);
    } else {                  /* Have error or SEG <sym> */
        if (opertype != OPSEG)
            /* Symbol can't be reserved */
            errorn (E_RES);
        else {
            /* Have SEG <var> | <label> */
            getatom ();
            if (*naim.pszName == 0)
                error (E_EXP,"variable or label");

            else if (!symFet())
                /* Forward reference bad */
                errorc (E_IFR);

            else if (1 << symptr->symkind &
                     (M_DVAR | M_CLABEL | M_PROC)) {
                /* Segment of variable */

                symptr = symptr->symsegptr;
                if (!symptr)
                    /* Must have segment */
                    errorc (E_OSG);
                else
                    addglist ();
            } else
                /* Wrong type */
                errorc (E_TUL);
        }
    }
}




/***    groupdefine - define segments that form a group
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
groupdefine ()
{
    if (symFet()) {     /* Symbol exists */
        checkRes();
        if (symptr->symkind != GROUP)
            /* Should have been group */
            errorc (E_NGR);

        symptr->attr |= M_BACKREF;
    } else if (pass2)
        /* Must be seen 1st on pass 1 */
        errorn (E_PS1);
    else {
        /* Create group name */
        symcreate (M_DEFINED, GROUP);
    }

    /* CURgroup is used by GROUPitem to know which group segment
       name should be added to. If it is NIL, means that either
       it is pass 2 so list already made or there was an error in
       GROUP name */

    curgroup = NULL;

    if (! pass2) {              /* Don't make list if pass 2 */

        symptr->attr |= M_BACKREF | M_DEFINED;

        if (symptr->symkind == GROUP)
            curgroup = symptr;
    }
    /* Handle segment list */
    BACKC ();
    do {
        SKIPC ();
        groupitem ();
    } while (PEEKC () == ',');
}




/***    setsegment -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
setsegment ()
{
    if (pass2 && !(M_DEFINED & symptr->attr))
        /* undef */
        errorn (E_SND);
    else
        regsegment[lastsegptr->offset] = symptr;
}




/***    assumeitem -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Form of ASSUME item is:
 *              <segreg> : <group> | <segment> | SEG <var> | NOTHING
 *         Will set XXsegment to segment or group pointer. NOTHING
 *         will set to NIL
 */


VOID
PASCAL
CODESIZE
assumeitem ()
{
    register SYMBOL FARSYM *p;
    register short   j;
    //        int segIndex;

    /* Scan segment name */
    getatom ();
    if (PEEKC() != ':') {
        /* NOTHING or error */
        if (fnoper ())

            if (opertype == OPNOTHING) { /* No segments assumed*/

                memset(regsegment, 0, sizeof(regsegment));
            } else
                /* Must have colon */
                error (E_EXP,"colon");
        else
            /* Must have colon */
            error (E_EXP,"colon");
    } else if (!symsearch ())         /* get seg register - Must be defined */
        errorn (E_SND);
    else {
        lastsegptr = p = symptr;             /* At least have defined */

        if (p->symkind != REGISTER ||
            p->symu.regsym.regtype != SEGREG)
            errorn (E_MBR);

        else {          /* Have segment reg so go on */
            /* Save ptr to segment */
            SKIPC ();
            getatom ();
            if (*naim.pszName == 0)
                error (E_EXP,"segment, group, or NOTHING");
            else
                if (!fnoper ()) {

                /* Must be segment or group */

                if (!symFet ())
                    segcreate (TRUE);   /* Make if not found */

                p = symptr;
                if (p->symkind == SEGMENT ||
                    p->symkind == GROUP) {

                    setsegment ();
#ifndef FEATURE
                    if (tokenIS("flat") && (cputype&P386)) {
                        pFlatGroup = symptr;
                        pFlatGroup->symkind = GROUP;
                        pFlatGroup->attr |= M_DEFINED | M_BACKREF;
                        pFlatGroup->symu.grupe.segptr = NULL;
                    }
#endif
                } else
                    errorc (E_MSG);
            } else {
                /* Have NOTHING or SEG */
                if (opertype == OPNOTHING) {
                    regsegment[lastsegptr->offset] = NULL;
                } else if (opertype == OPSEG) {
                    getatom ();
                    if (!symFet ())
                        /* Must be defined on pass 1 */
                        errorn (E_PS1);
                    else {
                        p = symptr;
                        if (!(M_DEFINED & p->attr))
                            errorn (E_PS1);
                        else if (1 << p->symkind &
                                 (M_CLABEL | M_PROC | M_DVAR)) {
                            if (!(M_XTERN & p->attr))
                                symptr = symptr->symsegptr;
                            p = symptr;
                            setsegment ();
                        } else
                            errorc (E_TUL);
                    }
                } else
                    errorn (E_RES);
            }
        }
    }
}




/***    evendir - process <even> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
evendir (
        SHORT arg
        )
{
    register SHORT size;

    if (arg)
        size = arg;
    else
        size = (SHORT)exprconst ();

    if ((size & (size - 1)) != 0 || !size)
        errorc(E_AP2);

    else if (!pcsegment)
        /* Not in segment */
        errorc (E_MSB);

    else if (pcsegment->symu.segmnt.align == 1)
        /* Byte aligned */
        errorc (E_NEB);

    else {
        if (!((USHORT) pcoffset % size))
            return;

        size = size - (USHORT) pcoffset % size;

        while (size--)

            if (!pcsegment->symu.segmnt.hascode)

                emitopcode(0);
            else
                if (size > 0) {
                size--;
                emitopcode(0x87);       /* two byte form is faster */
                emitopcode(0xDB);
            } else
                emitopcode(0x90);
    }
}




/***    namedir - process <name> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
namedir ()
{
    getatom ();
    if (*naim.pszName == 0)
        error (E_EXP,"module name");
    else if (modulename)
        /* Already have one */
        errorc (E_RSY);
    else
        modulename = createname (naim.pszName);
}

/***    includeLib - process include lib directive
 *
 *      Format : includeLib token
 */


VOID
PASCAL
CODESIZE
includeLib()
{
    char *pFirst;
    TEXTSTR FAR *bodyline, FAR *ptr;
    register USHORT siz;

    pFirst = lbufp;

    while (!ISTERM (PEEKC()) && !ISBLANK (PEEKC()))
        SKIPC();

    siz = (USHORT)(lbufp - pFirst);

    if (siz == 0 || siz > 126)
        errorc(E_IIS);

    if (pass2)
        return;

    bodyline = (TEXTSTR FAR *)talloc ((USHORT)(sizeof (TEXTSTR) + siz));

    bodyline->strnext = (TEXTSTR FAR *)NULL;
    bodyline->text[siz] = NULL;

    fMemcpy (bodyline->text, pFirst, siz);

    if (!(ptr = pLib))
        pLib = bodyline;
    else {
        while (ptr->strnext)
            ptr = ptr->strnext;

        ptr->strnext = bodyline;
    }
}



/***    orgdir - process <org> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
orgdir ()
{
    register DSCREC *dsc;

    dsc = expreval (&nilseg);
    if (dsc->dsckind.opnd.dflag == FORREF)
        /* Must be known */
        errorc (E_PS1);
    /*    Can get <code> set and segment NIL, fix */
    else if (dsc->dsckind.opnd.dsegment) {/* code var */

        if (!isdirect(&(dsc->dsckind.opnd)) &&
            dsc->dsckind.opnd.mode != 4)

            /* Not direct */
            errorc (E_IOT);
        if (pcsegment != dsc->dsckind.opnd.dsegment)
            /* Different segment */
            errorc (E_NIP);
    } else {          /* Should be const */
        /* Must be constant */
        forceimmed (dsc);
        if (dsc->dsckind.opnd.dsign)
            /* And plus */
            errorc (E_VOR);
    }
    if (dsc->dsckind.opnd.doffset < pcoffset)
        if (pcmax < pcoffset)
            /* If moving down, save */
            pcmax = pcoffset;
        /* Set new PC */
    pcoffset = dsc->dsckind.opnd.doffset;
    /* Display new PC */
    pcdisplay ();
    dfree ((char *)dsc );
}




/***    purgemacro - process <purge> directive
 *
 *      purgemacro ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
purgemacro ()
{
    getatom ();
    if (!symFet ())
        errorn (E_SND);

    else if (symptr->symkind != MACRO)
        symptr->attr &= ~(M_BACKREF);
    else {
        if (symptr->symu.rsmsym.rsmtype.rsmmac.active)
            symptr->symu.rsmsym.rsmtype.rsmmac.delete = TRUE;
        else
            deletemacro (symptr);
    }
}


/***    deletemacro - delete macro body
 *
 *      deletemacro (p);
 *
 *      Entry   p = pointer to macro symbol entry
 *      Exit    macro body deleted
 *      Returns none
 *      Calls
 */


VOID
PASCAL
CODESIZE
deletemacro (
            SYMBOL FARSYM *p
            )
{
    listfree (p->symu.rsmsym.rsmtype.rsmmac.macrotext);
    p->symu.rsmsym.rsmtype.rsmmac.macrotext = NULL;
    p->symu.rsmsym.rsmtype.rsmmac.active = 0;
    p->symu.rsmsym.rsmtype.rsmmac.delete = FALSE;
}



/***    radixdir - process <radix> directive
 *
 *      radixdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
radixdir ()
{
    register USHORT  rdx;

    /* Force decimal radix */
    radixescape = TRUE;
    /* Get wanted radix */
    rdx = (USHORT)exprconst ();
    if (2 <= rdx && rdx <= 16)
        radix = (char)rdx;
    else
        errorc (E_VOR);
    radixescape = FALSE;
    /* Convert radix to ascii and display */
    offsetAscii ((OFFSET) radix);
    copyascii ();
}




/***    checkline - check line for delimiter
 *
 *      flag = checkline (cc);
 *
 *      Entry   cc = chearacter to check line for
 *      Exit    none
 *      Returns TRUE if cc matched in line
 *              FALSE if cc not matched in line
 *      Calls   none
 */


UCHAR
PASCAL
CODESIZE
checkline (
          register UCHAR cc
          )
{
    register UCHAR nc;

    while (nc = NEXTC())
        if (nc == cc)
            return (TRUE);
    BACKC ();
    return (FALSE);
}




/***    comment - copy characters to end of comment
 *
 *      commentbuild ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
commentbuild ()
{
    if (checkline ((char)delim)) {
        handler = HPARSE;
        swaphandler = TRUE;
    }

    if (!lsting) {
        linebuffer[0] = '\0';
        linelength = 0;
        lbufp = linebuffer;
    }

    listline ();
}




/***    comdir - process <comment> directive
 *
 *      comdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
comdir ()
{
    if (!PEEKC ())
        error (E_EXP,"comment delimiter");
    else {
        /* Save delim char */
        if (!checkline ((char)(delim =  NEXTC ()))) {
            /* Delim is not on same line */
            swaphandler = TRUE;
            handler = HCOMMENT;
        }
    }
    if (!lsting) {
        linebuffer[0] = '\0';
        linelength = 0;
        lbufp = linebuffer;
    }
}




/***    outdir - display remainder of line to console
 *
 *      outdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
outdir ()
{
    if (!listquiet)
        fprintf (stdout, "%s\n", lbufp);
    lbufp = lbuf + strlen (lbuf);
}




/***    enddir - process <end> directive
 *
 *      enddir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
enddir ()
{
    if (!ISTERM (PEEKC ())) {
        /* Have a start addr */
        startaddr = expreval (&nilseg);
        if (!(M_CODE & startaddr->dsckind.opnd.dtype))
            errorc (E_ASC);
    }

#ifdef BCBOPT
    if (fNotStored)
        storeline();
#endif

    if (fSimpleSeg && pcsegment)
        endCurSeg();

    listline();
    longjmp(forceContext, 1);
}




/***    exitmdir - process <exitm> directive
 *
 *      exitmdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
exitmdir ()
{
    if (macrolevel == 0)
        /* Must be in macro */
        errorc (E_NMC);
    else
        /*  set ExitBody since need to see conditionals */
        exitbody = TRUE;
}




/***    trypathname - try to open a file in a directory
 *
 *      trypathname (szPath);
 *
 *      Entry   lbufp = pointer to include file name
 *              szPath = directory to search in
 *      Exit    Include file opened if found.
 *              Fully qualified name in "save"
 *      Returns file handle of file, or -1 if not opened
 *              special handle of -2 means FCB has been allocated
 *      Note    If include file name does not begin with path separator
 *              character, the path separator is appended to include path.
 */

int
PASCAL
CODESIZE
trypathname (
            char * szPath
            )
{
    char           cc;
    int            fh;
    char           *p = save;
    char           *pe = save + LINEMAX - 2;
    char           *ic;
    register FCB * pFCBT;

    ic = szPath;

    if (*ic) {

        while (*ic && p < pe)
            *p++ = *ic++;

        if ((*(p-1) != PSEP) && (*(p-1) != ':'))
            /* include path separator if not in file name */
            *p++ = PSEP;
    }

    for (ic = lbufp; !ISTERM (cc = *ic++) && !ISBLANK (cc) && p < pe ; )

        if (cc == ALTPSEP)
            *p++ = PSEP;
        else
            *p++ = cc;

#ifdef MSDOS
    if (*(p-1) == ':') /* kill 'con:' */
        p--;
#endif
    *p = NULL;

    /* look for an existing include file on pass 2 with a fully qualified
     * name */

#ifdef BCBOPT
    if (pass2) {
        for (pFCBT = pFCBInc->pFCBNext; pFCBT; pFCBT = pFCBT->pFCBNext) {

            if (!memcmp (save, pFCBT->fname, strlen(pFCBT->fname)+1)) {
                pFCBT->pbufCur = NULL;

                if (pFCBT->pBCBCur = pFCBT->pBCBFirst) {

                    pFCBT->pBCBCur->fInUse = 1;

                    if (! (pFCBT->pbufCur = pFCBT->pBCBCur->pbuf))
                        pFCBT->fh = tryOneFile( save );
                } else
                    pFCBT->fh = tryOneFile( save );

                pFCBCur = pFCBT;

                return(-2);
            }
        }
    }
#endif
    return(tryOneFile( save ));
}

int
PASCAL
CODESIZE
tryOneFile(
          UCHAR *fname
          )
{
    int iRet;
    int fTryAgain;

    do {
        fTryAgain = FALSE;
#ifdef XENIX286
        iRet = open (fname, TEXTREAD);
#else
        iRet = _sopen (fname, O_RDONLY | O_BINARY, SH_DENYWR);
#endif
        if ( iRet == -1 && errno == EMFILE ) {    /* If out of file handles */
            if ( freeAFileHandle() ) {
                fTryAgain = TRUE;    /* Keep trying until out of files to close */
            }
        }
    }while ( fTryAgain );
    return( iRet );     /* Return file handle or error */
}



/***    openincfile - try to find and open include file
 *
 *      openincfile ()
 *
 *      Entry   lbufp = pointer to include file name
 *              inclcnt = count of -I paths from command line and INCLUDE e.v.
 *              inclpath[i] = pointer to path to prepend to include file name
 *      Exit    include file opened if found on any path or current directory
 *              Aborts with code EX_UINC if file not found
 *      Returns none
 *      Note    If include file name does not begin with path separator
 *              character, the path separator is appended to include path.
 *              For every attempt to find a file in a path, the alternate
 *              path separator character is used.  This will improve program
 *              portability between DOS and XENIX.
 */

int
PASCAL
CODESIZE
openincfile ()
{
    register char cc;
    int fh;
    SHORT i;

#ifdef MSDOS
    if ((cc = *lbufp) != PSEP && cc != ALTPSEP && cc != '.' &&
        lbufp[1] != ':') {
#else
    if ((cc = *lbufp) != PSEP && cc != ALTPSEP && cc != '.') {
#endif /* MSDOS */

        for (i = inclFirst; i < inclcnt; i++) {
            if ((fh = trypathname (inclpath[i])) != -1) {
                return (fh);
            }
        }

    } else

        if ((fh = trypathname ("")) != -1) {
        return (fh);
    }

    error(E_INC, lbufp);
    errordisplay ();
    closeOpenFiles();

    exit (EX_UINC);
    return 0;
}


/***    includedir - process <include> directive
 *
 *      includedir ();
 *
 *      Entry   lbufp = pointer to include file name
 *      Exit    Opens include file on pass1.  Gets correct buffers on pass 2
 *      Returns none
 *      Notes   Notice the GOTO when correct FCB found in pass2
 */

VOID
PASCAL
CODESIZE
includedir ()
{
    char lastreadT;
    register FCB * pFCBT;
    unsigned long filelen;
    FCB * svInc;
    int fh;


#ifdef BCBOPT
    if (fNotStored)
        storelinepb ();
#endif

    listline();

    /* Get here on pass 1 OR when file names didn't match */

#ifdef BCBOPT
    if ((fh = openincfile()) == -2) {
        pFCBT = pFCBInc = pFCBCur;
        goto gotinclude;
    }
#else
    fh = openincfile();
#endif

    pFCBT = (FCB *)
            nalloc((USHORT)(sizeof(FCB) + strlen(save) + sizeof(char)),"includedir");

    pFCBT->fh = fh;

    strcpy (pFCBT->fname, save);    // Save the file name

    pFCBT->pFCBParent = pFCBCur;  /* Add bidirectional linked list entry */
    pFCBCur->pFCBChild = pFCBT;

#ifdef BCBOPT
    if (!pass2) {
        pFCBT->pFCBNext = NULL;
        pFCBInc->pFCBNext = pFCBT;
        pFCBInc = pFCBT;
    } else
        pFCBT->pbufCur = NULL;
#endif

    if ((filelen = _lseek(pFCBT->fh, 0L, 2 )) == -1L)
        TERMINATE1(ER_ULI, EX_UINP, save);

    /* go back to beginning */
    _lseek(pFCBT->fh, 0L, 0 );

    if (filelen > DEF_INCBUFSIZ << 10)
        pFCBT->cbbuf = DEF_INCBUFSIZ << 10;
    else
        pFCBT->cbbuf = (USHORT) filelen + 1;

    pFCBCur = pFCBT;

    /* get a buffer */

#ifdef BCBOPT
    if (fBuffering && !pass2)
        pFCBT->pBCBFirst = pBCBalloc(pFCBT->cbbuf);
    else
        pFCBT->pBCBFirst = NULL;

    pFCBT->pBCBCur = pFCBT->pBCBFirst;
#endif


#ifdef BCBOPT
    gotinclude:
#endif

    pFCBT->line = 0;
    pFCBT->ctmpbuf = 0;
#ifdef XENIX286
    pFCBT->ptmpbuf = pFCBT->buf = nalloc(pFCBT->cbbuf, "incdir");
#else
    pFCBT->ptmpbuf = pFCBT->buf = falloc(pFCBT->cbbuf, "incdir");
#endif

    if (crefing && pass2)
        fprintf( crf.fil, "\t%s", save );

    lastreadT = lastreader;
    lineprocess(RREADSOURCE, NULL );

    lastreader = lastreadT;
    swaphandler++;                  /* sync local handler with global state */
    fSkipList++;
}




/***    segdefine - process <segment> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Format is:
 *              <name> SEGMENT [align] | [combine] | ['class']
 *                     align:  PARA | BYTE | WORD | PAGE | INPAGE
 *                     combine:PUBLIC | COMMON | STACK | MEMORY | AT <expr>
 */


VOID
PASCAL
CODESIZE
segdefine ()
{
    register char cc;
    register SYMBOL FARSYM *p;
    register SYMBOL FARSYM *pT;

    if (!symFetNoXref ())
        /* Create if new segment */
        segcreate (TRUE);
    else {
        if (symptr->symkind != SEGMENT)
            if (symptr->symkind == CLASS)
                segcreate (FALSE);
            else
                /* Wasn't segment */
                errorn (E_SDK);
    }
    strcpy(&segName[8], naim.pszName);
    p = symptr;
    /* Output CREF info */
    crefdef ();
    if (p->symkind == SEGMENT) {

        if (!(pass2 || (M_BACKREF & p->attr)))
            addseglist (p);

        p->attr |= M_BACKREF | M_DEFINED;
        if (pcsegment) {

            /* Save previous segment info */
            /* Save current segment PC */
            pcsegment->offset = pcoffset;
            pcsegment->symu.segmnt.seglen =
            (pcmax > pcoffset) ? pcmax : pcoffset;
        }
        /* check for nested segment opens */

        for (pT = pcsegment; pT;) {

            if (pT == p) {
                errorc(E_BNE);
                goto badNest;
            }
            pT = pT->symu.segmnt.lastseg;
        }

        /* Save previous segment */
        p->symu.segmnt.lastseg = pcsegment;
        badNest:
        /* Set new current segment  */
        pcsegment = p;
        pcoffset = p->offset;

        /* Set segment maximum offset */
        pcmax = p->symu.segmnt.seglen;

        /* Display where in segment */
        pcdisplay ();

        while (!ISTERM (cc = PEEKC ())) {
            if (cc == '\'')
                segclass (p);
            else if (LEGAL1ST (cc))
                segalign (p);
            else {
                error(E_EXP,"align, combine, or 'class'");
                break;
            }
        }
#ifdef V386
        if (p->symu.segmnt.use32 == (char)-1)
            p->symu.segmnt.use32 = wordszdefault;

        wordsize = p->symu.segmnt.use32;

        defwordsize();

        if (wordsize == 4 && !(cputype & P386))
            errorc(E_CPU);
#endif
    }
    definesym(segName);
    symptr->attr |= M_NOCREF;   /* don't cref @curSeg */
}




/***    addseglist - add segment to list
 *
 *      addseglist (pseg);
 *
 *      Entry   pseg = segment symbol entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
addseglist (
           register SYMBOL FARSYM *pseg
           )
{
    register SYMBOL FARSYM  *tseg;
    register SYMBOL FARSYM * FARSYM *lseg;

    /* Add segment to list */
    if (!firstsegment) {
        firstsegment = pseg;
        pseg->symu.segmnt.segordered = NULL;
        return;
    }
    tseg = firstsegment;
    lseg = &firstsegment;
    for (; tseg; lseg = &(tseg->symu.segmnt.segordered),
        tseg = tseg->symu.segmnt.segordered) {
        if (segalpha) {
            if (STRFFCMP (pseg->nampnt->id, tseg->nampnt->id) < 0) {
                pseg->symu.segmnt.segordered = tseg;
                *lseg = pseg;
                return;
            }
        }
    }
    *lseg = pseg;
    pseg->symu.segmnt.segordered = NULL;
}



/***    segclass - process <segment> 'class' subdirective
 *
 *      segclass (pseg);
 *
 *      Entry   pseg = segment symbol entry
 *              *lbufp = leading ' of class name
 *      Exit
 *      Returns
 *      Calls   scanatom, skipblanks
 *      Note    Format is:
 *              <name> SEGMENT [align] | [combine] | ['class']
 *                     align:  PARA | BYTE | WORD | PAGE | INPAGE
 *                     combine:PUBLIC | COMMON | STACK | MEMORY | AT <expr>
 */


VOID
PASCAL
CODESIZE
segclass (
         register SYMBOL FARSYM *pseg
         )
{
    SKIPC ();
    getatom ();
    if (NEXTC () != '\'')
        /* Don't have right delim */
        error (E_EXP,"'");
    skipblanks ();
    if (symptr->symu.segmnt.classptr) {
        /* Make sure 'class' matches */
        if (!symFet ())
            /* Not same class */
            errorc (E_SPC);
        else if (symptr->symkind != CLASS &&
                 symptr->symkind != SEGMENT &&
                 symptr->symkind != GROUP)
            errorn(E_SDK);
        else if (symptr != pseg->symu.segmnt.classptr)
            errorc (E_SPC);
    } else if (*naim.pszName == 0)
        errorc (E_EMS);

    else if (!symFet ()) {
        symcreate (M_DEFINED, SEGMENT);
        symptr->symkind = CLASS;
    }
    checkRes();
    pseg->symu.segmnt.classptr = symptr;
}




/***    segalign - process <segment> align and combine subdirectives
 *
 *      segalign ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Format is:
 *              <name> SEGMENT [align] | [combine] | [16/32] | ['class']
 *                     align:  PARA | BYTE | WORD | PAGE | INPAGE
 *                     combine:PUBLIC | COMMON | STACK | MEMORY | AT <expr>
 *                     16/32:  USE16 | USE32
 */


VOID
PASCAL
CODESIZE
segalign (
         register SYMBOL FARSYM *pseg
         )
{
    /* Scan align or combine type */
    getatom ();
    if (fnspar ())
        switch (segidx) {
            case IS_BYTE:
            case IS_WORD:
#ifdef V386
            case IS_DWORD:
#endif
            case IS_PAGE:
            case IS_PARA:
                /* Some align field */
                if (pseg->symu.segmnt.align == (char)-1)
                    pseg->symu.segmnt.align = segtyp;
                else if (pseg->symu.segmnt.align != segtyp &&
                         (pseg->symu.segmnt.align != pseg->symu.segmnt.combine ||
                          pseg->symu.segmnt.align))
                    errorc (E_SPC);
                break;
            case IS_MEMORY:
            case IS_PUBLIC:
            case IS_STACK:
            case IS_COMMON:
                if (pseg->symu.segmnt.combine == 7)
                    pseg->symu.segmnt.combine = segtyp;
                else if (pseg->symu.segmnt.combine != segtyp)
                    errorc (E_SPC);
                break;
#ifdef V386
            case IS_USE16:
                if (pseg->symu.segmnt.use32 != (char)-1 &&
                    pseg->symu.segmnt.use32 != 2)
                    errorc (E_SPC);
                if ((cputype&P386)==0)
                    errorc (E_NPA);
                pseg->symu.segmnt.use32 = 2;
                break;
            case IS_USE32:
                if (pseg->symu.segmnt.use32 != (char)-1 &&
                    pseg->symu.segmnt.use32 != 4)
                    errorc (E_SPC);
                if ((cputype&P386)==0)
                    errorc (E_NPA);
                pseg->symu.segmnt.use32 = 4;
                break;
#endif
            default:
                /* Have AT <expr> */
                pseg->symu.segmnt.locate = exprconst ();
                pseg->symu.segmnt.align = 0;
                pseg->symu.segmnt.combine = 0;
        } else {
        /* Not good align or define */
        errorc (E_NPA);
    }
}


/***    procdefine - start procedure block
 *
 *      procdefine ();
 *
 *      Parse the proc statement with optional distance parameters
 */

SYMBOL FARSYM *pArgFirst;       /* pointer to first argument */
SYMBOL FARSYM *pArgCur;         /* pointer to currect argment */
OFFSET offsetCur;               /* current stack offset */
char bp16 [] =" PTR [BP]?";     /* template for text macro creation */
char bp32 [] =" PTR [EBP]?";
char *bp;

VOID
PASCAL
CODESIZE
procdefine ()
{
    /* create PROC name with default size*/

    varsize = dirsize[I_PROC];
    switchname();

    if (getatom ()) {

        if (fnsize ()) {            /* process optional near|far */

            if (varsize < CSFAR)
                errorc (E_TIL);

            if (langType)
                getatom();
        } else if (!langType)
            errorc (E_MSY);

    }
    switchname();

    labelcreate (varsize, PROC);

    if (symptr->symkind != PROC)
        return;

    /* Set previous PROC, make sure no loop possible */

    if (iProcStack < PROCMAX && pcproc != symptr)
        procStack[++iProcStack] = symptr;

    pcproc = symptr;  /* Set ptr to new PROC */
    symptr->length = 1;
    symptr->symu.clabel.type = typeFet(varsize);
    pcproc->symu.plabel.pArgs = NULL;

    if (langType)

        creatPubName();
    else
        return;

    if (iProcStack > 1)           /* nested procs not allowed */
        errorc(E_BNE);

    iProcCur = ++iProc;
    emitline();

    if (! pass2) {

        /* keep a chain of procedures in sorted order so we can output
         * proc's in the correct order for CV */

        if (pProcCur)
            pProcCur->alpha = symptr;
        else
            pProcFirst = symptr;
    }
    pProcCur = symptr;

    /* check and process any "uses reg1 reg2 ... " */

    iRegSave = -1;
    fProcArgs = ARGS_NONE;
    cbProcLocals = 0;
    switchname();

    if (fetLang() == CLANG)
        pProcCur->attr |= M_CDECL;

#ifndef FEATURE
    if (tokenIS("private")) {
        symptr->attr &=  ~M_GLOBAL;
        getatom();
    }
#endif

    if (tokenIS("uses")) {

        char count = 0;

        while (iRegSave < 8 && getatom()) {

            count++;

#ifndef FEATURE
            if (symsrch() && symptr->symkind == EQU
                && symptr->symu.equ.equtyp == TEXTMACRO) {
                expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
                getatom ();
            }

            if (*naim.pszName)
#endif
                strcpy(regSave[++iRegSave], naim.pszName);
        }
        if (!count)
            errorc(E_OPN);
        else
            fProcArgs = ARGS_REG;
    }

    pTextEnd = (char *) -1;
    bp = (wordsize == 2)? bp16: bp32;

    offsetCur = wordsize*2;     /* room for [e]bp and offset of ret addr */
    if (pcproc->symtype == CSFAR)
        offsetCur += wordsize;  /* room for [ ]cs (16 or 32 bits) */

    cbProcParms = cbProcParms - offsetCur;

    scanArgs();

    cbProcParms += offsetCur;
    if (cbProcParms)
        fProcArgs = ARGS_PARMS;

    pcproc->symu.plabel.pArgs = pArgFirst;
    offsetCur = 0;
}

/***    defineLocals
 *
 *      Parse the local statment for stack based variables
 */

VOID
PASCAL
CODESIZE
defineLocals ()
{
    /* check for valid active proc */

    if (!pcproc || fProcArgs < 0)
        return;

    fProcArgs = ARGS_LOCALS;
    getatom();
    scanArgs();

    /* tack on the the end the parm list any locals */

    addLocal(pArgFirst);

    cbProcLocals = offsetCur;
}

/***  addLocal - concatenate a null-terminated list of locals onto a proc
 *
 */

VOID
PASCAL
CODESIZE
addLocal (
         SYMBOL FARSYM *pSY
         )
{
    if (pcproc) {

        if (!(pArgCur = pcproc->symu.plabel.pArgs))
            pcproc->symu.plabel.pArgs = pSY;

        else {

            for (; pArgCur->alpha; pArgCur = pArgCur->alpha);

            pArgCur->alpha = pSY;
        }
    }
}



char *
PASCAL
CODESIZE
xxradixconvert (
               OFFSET  valu,
               register char *p
               )
{
    if (valu / radix) {
        p = xxradixconvert (valu / radix, p);
        valu = valu % radix;
    } else /* leading digit */
        if (valu > 9) /* do leading '0' for hex */
        *p++ = '0';

    *p++ = (char)(valu + ((valu > 9)? 'A' - 10 : '0'));

    return (p);
}

SHORT     mpTypeAlign[] = {  4, 1, 2, 4};


/***    scanArgs - process an argument list into text macros
 *
 *
 */


SHORT
PASCAL
CODESIZE
scanArgs ()
{
    struct eqar eqarT;
    USHORT defKind;
    USHORT defType;
    USHORT defCV;
    USHORT defPtrSize;
    SHORT  fIsPtr;
    char  *pLeftBrack;
    char  *p;

    pArgFirst = pArgCur = NULL;

    if (*naim.pszName)
        goto First;

    do {
        if (PEEKC() == ',')
            SKIPC();

        if (!getatom())
            break;
        First:
        switchname();
        if (!createequ (TEXTMACRO))
            break;

        /* chain in the text macro to this procedure.  You must either
           do a FIFO or LIFO quque depending on calling order */

        if (pProcCur->attr & M_CDECL) {

            if (pArgCur)
                pArgCur->alpha = symptr;
            else
                pArgFirst = symptr;

            symptr->alpha = NULL;
        } else {
            pArgFirst = symptr;
            symptr->alpha = pArgCur;
        }

        pArgCur = symptr;

        if (PEEKC() == '[' && fProcArgs == ARGS_LOCALS) { /* array element given */

            SKIPC();
            for (pLeftBrack = lbufp; PEEKC() && PEEKC() != ']'; SKIPC());

            *lbufp = ',';           /* to stop expression evaluation */
            lbufp = pLeftBrack;
            pArgCur->length = (USHORT)exprconst ();

            *lbufp++ = ']';         /* restore bracket */
        }

        fIsPtr = FALSE;
        defType = varsize = wordsize;

        if (PEEKC() == ':') {       /* parse optional type information */

            SKIPC();
            getatom();

            if (fnsize()) {

                if (varsize >= CSFAR) {     /* near | far given */

                    if (varsize == CSFAR)
                        defType += 2;

                    varsize = wordsize;
                    getatom();

                    if (! tokenIS("ptr"))
                        error(E_EXP, "PTR");

                    getatom();
                } else {
                    defType = varsize;
                    goto notPtr;
                }
            }

            else if (tokenIS("ptr")) {
                if (farData[10] > '0')
                    defType += 2;

                getatom();
            } else
                errorc(E_UST);

            defCV = fnPtr(defType);
        } else
            notPtr:
            defCV = typeFet(defType);

        pArgCur->symu.equ.iProc = iProcCur;
        pArgCur->symtype = defType;
        pArgCur->symu.equ.equrec.txtmacro.type = defCV;

    } while (PEEKC() == ',');

    /* Now that all the parmeters have been scanned, go back through
       the list and assign offsets and create the text macro string */


    bp[strlen(bp)-1] = (fProcArgs == ARGS_LOCALS)? '-': '+';

    for (pArgCur = pArgFirst; pArgCur; pArgCur = pArgCur->alpha) {

        if (fProcArgs == ARGS_LOCALS) {
            offsetCur += (offsetCur % mpTypeAlign[pArgCur->symtype % 4]) +
                         (pArgCur->symtype * pArgCur->length);
            pArgCur->offset = -(long)offsetCur;
        }

        p = xxradixconvert (offsetCur,  &save[100]);
        if (radix == 16)
            *p++ = 'h';
        *p++ = ')';
        *p = NULL;

        strcat( strcat( strcpy (&save[1], siznm[pArgCur->symtype]),
                        bp), &save[100]);
        *save = '(';

        if (fProcArgs != ARGS_LOCALS) {
            pArgCur->offset = offsetCur;
            offsetCur += pArgCur->symtype + wordsize - 1;
            offsetCur -= offsetCur % wordsize;
        }

        if (!pass2)
            pArgCur->symu.equ.equrec.txtmacro.equtext = _strdup(save);
    }
    return 0;
}


/***    procbuild - check for end of PROC block
 *
 *      procbuild ();
 *
 *      Entry   *pcproc = current PROC
 *      Exit    *pcproc = current or previous PROC
 *      Returns none
 *      Calls   endblk, parse
 *      Note    if not end of PROC, parse line as normal.  Otherwise,
 *              terminate block.
 */

SHORT
PASCAL
CODESIZE
procend ()
{
    USHORT size;

    if (!pcproc)
        errorc( E_BNE );

    else if (pcproc->symkind == PROC) {

        if (!symFet() || symptr != pcproc)
            errorc (E_BNE);

        /* Length of PROC */
        size = (USHORT)(pcoffset - pcproc->offset);
        if (pass2 && size != pcproc->symu.plabel.proclen)
            errorc (E_PHE);

        fProcArgs = 0;
        iProcCur = 0;
        pcproc->symu.plabel.proclen = size;
        /* Point to prev PROC */
        pcproc = procStack[--iProcStack];
        pcdisplay ();
    }
    return(0);
}


/* bit flags for segment table */

#define SG_OVERIDE      1       /* name can be overriden */
#define SG_GROUP        2       /* segment belongs to dgroup */

char models[] = "SMALL\0  COMPACT\0MEDIUM\0 LARGE\0  HUGE";
char langs[]  = "C\0      PASCAL\0 FORTRAN\0BASIC";
char textN[] = "_TEXT";
char farTextName[14+5];
SHORT  modelWordSize;

char farCode[] = "@CodeSize=0";  /* text macros for model stuff */
char farData[] = "@DataSize=0";
char modelT[] = ".model";

/* table of segment names and attributes for the model */

struct sSeg {
    char  *sName;       /* segment name */
    UCHAR align;        /* alignment */
    UCHAR combine;      /* combine */
    char  *cName;       /* class name */
    UCHAR flags;        /* internal state flags */

} rgSeg[] = {

    textN,      2, 2, "'CODE'",         SG_OVERIDE,
    "_DATA",    2, 2, "'DATA'",         SG_GROUP,
    "_BSS",     2, 2, "'BSS'",          SG_GROUP,
    "CONST",    2, 2, "'CONST'",        SG_GROUP,
    "STACK",    3, 5, "'STACK'",        SG_GROUP,
    "FAR_DATA", 3, 0, "'FAR_DATA'",     SG_OVERIDE,
    "FAR_BSS",  3, 0, "'FAR_BSS'",      SG_OVERIDE
};


/***    model - process the model directive
 *
 *
 *      Note    Format is:
 *              .MODEL SMALL|MEDIUM|COMPACT|LARGE|HUGE {,C|BASIC|FORTRAN|PASCAL}
 */


VOID
PASCAL
CODESIZE
model ()
{
    register SHORT iModel;
    char buffT[80];

    /* get the model and classify */

    getatom ();

    for (iModel = 0; iModel <= 32; iModel += 8)
        if (tokenIS(&models[iModel]))
            goto goodModel;

    errorc(E_OPN);
    iModel = 0;

    goodModel:
    iModel /= 8;            /* offset into index */
    if (fSimpleSeg && iModel+1 != fSimpleSeg)
        error(E_SMD, modelT);

    fSimpleSeg = iModel + 1;

    if (iModel > 1) {        /* far code */

        farCode[10]++;
        rgSeg[0].sName = strcat(strcpy(farTextName, &baseName[10]), textN);
        dirsize[I_PROC] = CSFAR;
    } else
        rgSeg[0].flags &= ~SG_OVERIDE;


    if (iModel != 0 && iModel != 2 ) {        /* far data */

        farData[10]++;

        if (iModel == 4)            /* huge get a '2' */
            farData[10]++;
    }
#ifdef V386

    if (cputype & P386)
        rgSeg[0].align =
        rgSeg[1].align =
        rgSeg[2].align =
        rgSeg[3].align =
        rgSeg[5].align =
        rgSeg[6].align = 5;         /* make data dword aligned */
#endif
    if (PEEKC() == ',') {   /* language option present */

        SKIPC();
        getatom();

        if (! (langType = fetLang()))
            error(E_EXP, "C|BASIC|FORTRAN|PASCAL");
    }

    if (! pass2) {

        modelWordSize = wordsize;

        /* define the text macros, the _data segment so dgroup may
           defined, dgroup and the assume */

        definesym(farCode);
        definesym(farData);

        definesym(strcat(strcpy(buffT, "@code="), rgSeg[0].sName));

        definesym("@data=DGROUP");      symptr->attr |= M_NOCREF;
        definesym("@fardata=FAR_DATA"); symptr->attr |= M_NOCREF;
        definesym("@fardata?=FAR_BSS"); symptr->attr |= M_NOCREF;

        doLine(".code");
        doLine(".data");
        endCurSeg();

    }
    xcreflag--;
    doLine("assume cs:@code,ds:@data,ss:@data");
    xcreflag++;

}

SHORT
CODESIZE
fetLang()
{
    SHORT iModel;

    for (iModel = 0; iModel <= 24; iModel += 8)
        if (tokenIS(&langs[iModel])) {
            getatom();
            return(iModel/8 + 1);
        }

    return(langType);
}


/***    openSeg - open a segment in the simplified segment
 *
 *
 */


VOID
PASCAL
CODESIZE
openSeg ()
{
    register struct sSeg *pSEG;
    char *pSegName;
    char buffT[80];

    if (!fSimpleSeg)
        error(E_EXP, modelT);

    pSEG = &rgSeg[opkind];
    getatom ();

    if (*naim.pszName) {

        if (! (pSEG->flags & SG_OVERIDE))
            errorc(E_OCI);

        pSegName = naim.pszName;
    } else
        pSegName = pSEG->sName;

    strcat( strcat( strcpy(buffT,
                           pSegName),
                    " segment "),
            pSEG->cName);

    if (pcsegment && opkind != 4)
        endCurSeg();

    doLine(buffT);

    pcsegment->symu.segmnt.combine = pSEG->combine;
    pcsegment->symu.segmnt.align = pSEG->align;

    if (pSEG == &rgSeg[0])
        regsegment[CSSEG] = pcsegment;

#ifdef V386
    pcsegment->symu.segmnt.use32 = (char)modelWordSize;
    wordsize = modelWordSize;
    defwordsize();
#endif

    if (pSEG->flags & SG_GROUP) {

        doLine("DGROUP group @CurSeg");
        pSEG->flags &= ~SG_GROUP;
    }
}

/***    stack - create a stack segment
 *
 *
 */


VOID
PASCAL
CODESIZE
createStack ()
{
    SHORT size;

    if ((size = (SHORT)exprconst()) == 0)
        size = 1024;

    opkind = 4;             /* index into seg table */
    openSeg();
    pcoffset = size;
    endCurSeg();
}

VOID
PASCAL
CODESIZE
endCurSeg ()
{
    xcreflag--;
    doLine("@CurSeg ends");
    xcreflag++;
}



/***    freeAFileHandle
 *
 *      Free's a file handle if possible
 *
 *      When working with deeply nested include files it is possible
 *      to run out of file handles. If this happens this function is
 *      called to temporarily close one of the include files. This is
 *      done by saving the current file position, closing the file and
 *      replacing the file handle with FH_CLOSED. Notice that the data
 *      buffer assosciated with the file is not destroyed. Hence readline
 *      can continue to read data from it until more data is needed from
 *      disk. There are two files that won't be closed, the main file and
 *      the current file.
 *      Associated functions:
 *          readmore -  if neccessary, will reopen and seek to the original
 *                      position the file.
 *          closefile - closes the file if it hasn't been already.
 *
 *      return:  TRUE = Was able to close a file, FALSE = Couldn't
 */

int
PASCAL
CODESIZE
freeAFileHandle ()
{
    register FCB *pFCBTmp;

    if ( !(pFCBTmp = pFCBMain->pFCBChild) ) {
        return( FALSE );    /* The only file open is the main source */
    }
    /* Loop down linked list of nested include files */
    while ( pFCBTmp ) {
        if ( (pFCBTmp->fh != FH_CLOSED) && (pFCBTmp != pFCBCur) ) {
            pFCBTmp->savefilepos = _tell( pFCBTmp->fh );
            _close( pFCBTmp->fh );
            pFCBTmp->fh = FH_CLOSED;
            return( TRUE );
        }
        pFCBTmp = pFCBTmp->pFCBChild;
    }
    return( FALSE );        /* Couldn't find a file to close */
}

int
PASCAL
CODESIZE
fpoRecord ()
{
    unsigned long dwValue[6];
    char          peekChar;
    int           i;
    PFPOSTRUCT    pFpo          = pFpoTail;
    PFPO_DATA     pFpoData      = 0;

    if (PEEKC() != '(') {
        errorc(E_PAR);
        return FALSE;
    }
    SKIPC();
    for (i=0; i<6; i++) {
        dwValue[i] = exprconst();
        peekChar = PEEKC();
        SKIPC();
        if (peekChar != ',') {
            if (i < 5) {
                errorc(E_FPO1);
                return FALSE;
            }
            if (peekChar != ')') {
                errorc(E_PAR);
                return FALSE;
            } else {
                break;
            }
        }
    }
    if (!pcproc) {
        errorc(E_FPO2);
        return FALSE;
    }
    if (pass2) {
        return TRUE;
    }
    if (!pFpoHead) {
        pFpoTail = pFpoHead = (PFPOSTRUCT)malloc(sizeof(FPOSTRUCT));
        if (!pFpoHead) {
            errorc(E_RRF);
            return FALSE;
        }
        pFpo = pFpoTail;
    } else {
        pFpoTail->next = (PFPOSTRUCT)malloc(sizeof(FPOSTRUCT));
        if (!pFpoTail->next) {
            errorc(E_RRF);
            return FALSE;
        }
        pFpo = pFpoTail->next;
        pFpoTail = pFpo;
    }
    numFpoRecords++;
    memset((void*)pFpo,0,sizeof(FPOSTRUCT));
    pFpoData = &pFpo->fpoData;
    if (pcproc->offset != pcoffset) {
        sprintf(naim.pszName, "%s_fpo%d", pcproc->nampnt->id, numFpoRecords);
        strcpy(naim.pszLowerCase, naim.pszName);
        _strlwr(naim.pszLowerCase);
        naim.ucCount = (unsigned char) strlen(naim.pszName);
        naim.usHash = 0;
        labelcreate(CSNEAR, CLABEL);
        pFpo->pSymAlt = symptr;
    } else {
        pFpo->pSymAlt = 0;
    }
    pFpo->pSym              = pcproc;
    pFpoData->ulOffStart    = pcoffset;
    pFpoData->cbProcSize    = 0;
    pFpoData->cdwLocals     = dwValue[0];
    pFpoData->cdwParams     = (USHORT)dwValue[1];
    pFpoData->cbProlog      = (USHORT)dwValue[2];
    pFpoData->cbRegs        = (USHORT)dwValue[3];
    pFpoData->fUseBP        = (USHORT)dwValue[4];
    pFpoData->cbFrame       = (USHORT)dwValue[5];
    pFpoData->fHasSEH       = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmequ.c ===
/* asmequ.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmmsg.h"

/* EQU statement :	 There are 3 basic kinds of EQU:

	1.	To expression
	2.	To symbol( synonym )
	3.	All others are text macros

 */

VOID PASCAL CODESIZE assignconst ( USHORT );

char isGolbal;		/* flag indicating if equ symbol was global */

/***	assignvalue - assign value to symbol
 *
 *	assignvalue ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
assignvalue ()
{
	struct eqar	a;
	register struct psop *pso;
	register SYMBOL FARSYM *sym;
	register DSCREC *dsc;

	switchname ();

	if (createequ(EXPR)) {

	    sym = symptr;
	    sym->attr |= M_BACKREF;	    /* Set we have DEFINED */

	    dsc = (equflag)? itemptr: expreval (&nilseg);
	    pso = &(dsc->dsckind.opnd);

	    if (noexp)
		    errorc (E_OPN);

	    /*	If error, set undefined */
	    if (errorcode && errorcode != E_RES)
		    sym->attr &= ~(M_DEFINED | M_BACKREF);

	    if (equflag && equdef) {
		    if (sym->offset != pso->doffset ||
			sym->symu.equ.equrec.expr.esign != pso->dsign ||
			sym->symsegptr != pso->dsegment)
			    muldef ();
	    }
	    /* If = involves forward, don't set BACKREF */
	    if (M_FORTYPE & pso->dtype){
		    sym->attr &= ~M_BACKREF;

		    if (sym->attr & M_GLOBAL)
			sym->attr &= ~M_GLOBAL;
	    }
	    if (pso->mode != 4 &&
	       !(pso->mode == 0 && pso->rm == 6) &&
	       !(pso->mode == 5 && pso->rm == 5) ||
		pso->dflag == XTERNAL)

		    /* Not right kind of result */
		    errorc (E_IOT);

	    sym->symsegptr = pso->dsegment;
	    sym->symu.equ.equrec.expr.eassume = NULL;
	    if (pso->dtype == M_CODE)
		    sym->symu.equ.equrec.expr.eassume = pso->dcontext;

	    sym->length = 0;
	    sym->offset = pso->doffset;
	    /* Note: change sign */
	    sym->symu.equ.equrec.expr.esign = pso->dsign;
	    sym->symtype = pso->dsize;

	    if ((pso->dtype == M_RCONST || !pso->dsegment) &&
		!(M_PTRSIZE & pso->dtype))
		    sym->symtype = 0;

	    if (fNeedList) {

		listbuffer[1] = '=';
		listindex = 3;
		if (sym->symu.equ.equrec.expr.esign)
			listbuffer[2] = '-';

		offsetAscii (sym->offset);
		copyascii ();
	    }
	    dfree ((char *)dsc );
	}
}




/***	createequ - create entry for equ
 *
 *	flag = createequ (typ, p)
 *
 *	Entry	typ = type of equ
 *	Exit
 *	Returns TRUE if equ created or found of right type
 *		FALSE if equ not created or found and wrong type
 *	Calls	labelcreate, switchname
 */


UCHAR PASCAL CODESIZE
createequ (
	UCHAR typ
){

	equsel = typ;
	switchname ();
	labelcreate (0, EQU);

	/* Make sure not set set fields if wrong type, flag to caller */
	if (symptr->symkind != EQU || symptr->symu.equ.equtyp != typ) {

		errorn (E_SDK);
		return (FALSE);
	}
	else {
		switchname ();
		isGolbal = 0;

		if (equsel == ALIAS){	/* lose public on pointer to alias */

		      isGolbal = symptr->attr & M_GLOBAL ? M_GLOBAL : 0;
		      symptr->attr &= ~M_GLOBAL;
		}

		if (typ != EXPR)
		    symptr->symsegptr = NULL;

		return (TRUE);
	}
}




/***	equtext - make remainder of line into text form of EQU
 *
 *	equtext ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls	error, skipblanks
 */


VOID PASCAL CODESIZE
equtext (
	USHORT cb
){
    register UCHAR *pFirst, *pT, *pOld;

    if (createequ (TEXTMACRO)) {

	/* find end of line & then delete trailing blanks */

	pFirst = lbufp;

	if (cb == ((USHORT)-1)) {
	    for (pT = pFirst; *pT && *pT != ';'; pT++);

	    for (; pT > pFirst && ISBLANK (pT[-1]) ; pT--);

	    lbufp = pT;
	    cb = (USHORT)(pT - pFirst);
	}

	pOld = symptr->symu.equ.equrec.txtmacro.equtext;

	pT = nalloc((USHORT)(cb+1), "equtext");
	pT[cb] = NULL;

	symptr->symu.equ.equrec.txtmacro.equtext =
		    (char *) memcpy(pT, pFirst, cb);
	if (pOld)
	    free (pOld);

	copystring (pT);
    }
}




/***	equdefine - define EQU
 *
 *	equdefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
equdefine ()
{
	register SYMBOL FARSYM *pSY;
	struct eqar	a;
	register char *p;
	USHORT cb;
	UCHAR opc = FALSE;

	listbuffer[1] = '=';
	switchname ();
	a.dirscan = lbufp;

	if (PEEKC () == '<') { /* look for <text macro> */

		p = getTMstring();
		a.dirscan = lbufp;
		lbufp = p;
		equtext ((USHORT)(a.dirscan - p - 1));
		lbufp = a.dirscan;
		return;
	}

	getatom ();
	if ((*naim.pszName == '$') && (naim.pszName[1] == 0))
		*naim.pszName = 0;
	/*Need to check if 1st atom is an operator, otherwise
	  will make OFFSET an alias instead of text. */
	if (fnoper ())
		*naim.pszName = 0;

	if (*naim.pszName && ISTERM (PEEKC ()) && !(opc = opcodesearch ())) {

	    /* Alias */
	    if (createequ (ALIAS)) {

		pSY = symptr;

		if (!symsrch ()) {
		    if (pass2)
			    /* Undefined */
			    errorn (E_SND);
		    /* Don't know symbol yet */
		    pSY->symu.equ.equrec.alias.equptr = NULL;
		}
		else {
		    /* Alias symbol is DEFINED */

		    pSY->attr = (unsigned char)(pSY->attr&~M_BACKREF | symptr->attr&M_BACKREF);

		    if (!pSY->symu.equ.equrec.alias.equptr)
			    pSY->symu.equ.equrec.alias.equptr = symptr;

		    if (pSY->symu.equ.equrec.alias.equptr != symptr) {
			    /* This is multiple definition */
			    symptr = pSY;
			    muldef ();
		    }
		    else {
			    /* See if good */
			    if (pSY = chasealias (pSY))
				pSY->attr |= isGolbal;
		    }
		}
	    }
	}
	else {
	    /* Must be text form or expr */
#ifdef BCBOPT
	    goodlbufp = FALSE;
#endif
	    lbufp = a.dirscan;
	    xcreflag--;
	    emittext = FALSE;

	    if (opc) {		    /* quick patch to allow i.e. SYM equ MOV */
		equtext ((USHORT)-1);
		emittext = TRUE;
		xcreflag++;
		return;
	    }

	    a.dsc = expreval (&nilseg);
	    emittext = TRUE;
	    xcreflag++;

	    /* So don't see double ref */
	    /* force text if OFFSET or : */
	    if (a.dsc->dsckind.opnd.mode != 4 &&
		!(a.dsc->dsckind.opnd.mode == 0 && a.dsc->dsckind.opnd.rm == 6) &&
		!(a.dsc->dsckind.opnd.mode == 5 && a.dsc->dsckind.opnd.rm == 5) ||

		 (errorcode && errorcode != E_SND && errorcode != E_RES) ||

		 (M_EXPLOFFSET|M_EXPLCOLON|M_HIGH|M_LOW) & a.dsc->dsckind.opnd.dtype ||

		 a.dsc->dsckind.opnd.seg != NOSEG ||
		 a.dsc->dsckind.opnd.dflag == XTERNAL) {

		    /* Not good expression */
		    if (errorcode != E_LTL)
			    errorcode = 0;
		    dfree ((char *)a.dsc );
		    lbufp = a.dirscan;
		    equtext ((USHORT)-1);
	    }
	    else {
		    /* This is expression */
		    itemptr = a.dsc;
		    switchname ();
		    equflag = TRUE;
		    assignvalue ();
		    equflag = FALSE;
	    }
	}
}




/***	definesym - define symbol from command line
 *
 *	definesym (p);
 *
 *	Entry	*p = symbol text
 *	Exit	symbol define as EQU with value of 0
 *	Returns none
 *	Calls
 */


void PASCAL
definesym (
	UCHAR *p
){
	struct eqar	a;

	fCheckRes++;
	fSkipList++;

#ifdef BCBOPT
	goodlbufp = FALSE;
#endif

	strcpy (lbufp = save, p);
	getatom ();
	if ((PEEKC() == 0 || PEEKC() == '=') && *naim.pszName) {
		if (PEEKC() == '=')
			SKIPC();

		switchname ();
		equtext ((USHORT)-1);
	}
	else
		errorcode++;

	fSkipList--;
	fCheckRes--;
}



/***	defwordsize - define @WordSize using definesym()
 *
 *	defwordsize ( );
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls	    definesym()
 */


VOID PASCAL
defwordsize ()
{
    static char wstext[] = "@WordSize=0D";

    wstext[10] = wordsize + '0';
    definesym(wstext);
    symptr->attr |= M_NOCREF;	/* don't cref @WordSize */

}




/***	chasealias - return value of alias list
 *
 *	symb = chasealias (equsym);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


SYMBOL FARSYM * PASCAL CODESIZE
chasealias (
	SYMBOL FARSYM *equsym
){
	register SYMBOL FARSYM *endalias;

	endalias = equsym;

	do {
	    /*	Must check to see if EQU to self */

	    if (endalias->symu.equ.equrec.alias.equptr == equsym) {

		    endalias->symu.equ.equrec.alias.equptr = NULL;
		    errorc (E_CEA);
		    return (NULL);
	    }

	    endalias = endalias->symu.equ.equrec.alias.equptr;

	    if (!endalias) {
		errorn (E_SND);
		return(NULL);	    /* This is undefined */
	    }

	} while (!(endalias->symkind != EQU ||
		   endalias->symu.equ.equtyp != ALIAS));

	/* Now check final is ok - Only constant allowed */

	if (endalias->symkind == EQU &&
	    endalias->symu.equ.equtyp != EXPR){

		errorc (E_IOT);
		return (NULL);
	}

	return (endalias);
}



/***	getTMstring - process a string or text macro
 *		      used by substring, catstring, sizestring, & instring
 *
 *	char * getTMstring ();
 *
 *	Entry	lbufp points to beginning of string or TM
 *	Exit
 *	Returns Pointer to string or equtext of TM
 *	Calls
 */


char * PASCAL CODESIZE
getTMstring ()
{
    char    cc;
    register char * p;
    static char   tms [] = "text macro";
    static char   digitsT[33];
    char * ret = NULL;


    skipblanks ();

    p = lbufp;

    if ((cc = *p) == '<' ) {

	ret = p + 1;

	while (*(++p) && (*p != '>'))
	    ;

	if (!*p)
	    error(E_EXP,tms);
	else
	    *(p++) = 0;

	lbufp = p;

    }
    else if (test4TM()) {
	ret = symptr->symu.equ.equrec.txtmacro.equtext;

    }
    else if (cc == '%') {

	pTextEnd = (char *) -1;
	lbufp = p+1;
        *xxradixconvert (exprconst(), digitsT) = NULL;
	return (digitsT);
    }
    else
	error(E_EXP,tms );

    return (ret);
}



/***	substring - process the subStr directive
 *
 *	substring ();
 *
 *	Syntax:
 *
 *	  <ident> subStr <subjectString> , <startIndex> {, <length> }
 *
 *	  Defines <ident> as a TEXTMACRO.
 *	  <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *	  <startIndex>: constant expression between 1 and strlen(subjectString)
 *	  Optional <length>: constant expression between 0 and
 *			     (strlen(subjectString) - startIndex + 1)
 *
 *	Entry	lbufp points to beginning of subjectString
 *	Exit
 *	Returns
 *	Calls	getTMstring
 */


VOID PASCAL CODESIZE
substring ()
{
    struct eqar   a;
    char	  *p;
    register USHORT cb;
    char	  cc;
    register char *subjtext;
    USHORT	    slength;
    USHORT	    startindex = 0;

    listbuffer[1] = '=';
    switchname ();

    /* First find string or text macro */

    if (!(subjtext = getTMstring () ))
	return;

    cb = (USHORT) strlen(subjtext);

    /* then check for start index */

    if (skipblanks () == ',') {
	SKIPC ();
	startindex = (USHORT)(exprconst() - 1);	/* get start index */

    } else
	error(E_EXP,"comma");


    /* then check for length */

    if (skipblanks () == ',') {
	SKIPC ();

	slength = (USHORT)exprconst();		/* get start index */

    } else
	slength = cb - startindex;

    if (startindex > cb || slength > cb - startindex) {
	errorc (E_VOR);
	return;
    }

    p = lbufp;

    lbufp = subjtext + startindex;	/* set lbufp to start of substring */
    equtext(slength);			/* end of string index */

    lbufp = p;

    if (errorcode && symptr)
	symptr->attr &= ~(M_DEFINED | M_BACKREF);
}



/***	catstring - process the catstr directive
 *
 *	catstring ();
 *
 *	Syntax:
 *
 *	  <ident> catStr <subjectString> {, <subjectString> } ...
 *
 *	  Defines <ident> as a TEXTMACRO.
 *	  Each <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
catstring ()
{
    struct eqar   a;
    register USHORT cb;
    char	  *subjtext;
    char	  resulttext[LBUFMAX];
    USHORT	  cbresult = 0;
    register char *p = resulttext;

    listbuffer[1] = '=';
    switchname ();
    *p = '\0';

    /* First find string or text macro */

    do {

	if (!(subjtext = getTMstring () ))
	    break;

	cb = (USHORT) strlen (subjtext);
	cbresult += cb;

	if(cbresult > LBUFMAX) {
	    errorc(E_LTL);
	    break;
	}

	memcpy (p, subjtext, cb + 1);	/* + 1 copies NULL */
	p += cb;

    } while (skipblanks() && NEXTC () == ',');

    p = --lbufp;
    lbufp = resulttext;
    equtext(cbresult);
    lbufp = p;

    if (errorcode)
	symptr->attr &= ~(M_DEFINED | M_BACKREF);
}



/***	assignconst - like assignvalue, only takes value as argument
 *
 *	assignconst (cb);
 *
 *	Entry	USHORT cb == value to assign
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
assignconst (
	USHORT cb
){
    register SYMBOL FARSYM *sym;
    struct eqar   a;

    if (createequ(EXPR)) {

	sym = symptr;

	if (errorcode)
	    sym->attr &= ~(M_DEFINED | M_BACKREF);
	else
	    sym->attr |= M_BACKREF;	    /* Set we have DEFINED */

	sym->symsegptr = NULL;
	sym->symu.equ.equrec.expr.eassume = NULL;
	sym->length = 0;
	sym->offset = cb;

	sym->symu.equ.equrec.expr.esign = 0;
	sym->symtype = 0;

	if (fNeedList) {

	    listbuffer[1] = '=';
	    listindex = 3;

	    offsetAscii (sym->offset);
	    copyascii ();
	}
    }
}


/***	sizestring - process the sizeStr directive
 *
 *	sizestring ();
 *
 *	Syntax:
 *
 *	  <ident> sizeStr <subjectString>
 *
 *	  Defines <ident> as a EXPR.
 *	  The <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
sizestring ()
{
    register USHORT cb = 0;
    char	  *p;

    switchname ();

    /* First find string or text macro */

    if (p = getTMstring () )
	cb = (USHORT) strlen (p);

    assignconst (cb);
}



/***	instring - process the instr directive
 *
 *	instring ();
 *
 *	Syntax:
 *
 *	  <ident> inStr { <startIndex> } , <subjectString> , <searchString>
 *
 *	  Defines <ident> as a TEXTMACRO.
 *	  <startIndex>: constant expression between 1 and strlen(subjectString)
 *	  <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *	  <searchString> must be a TEXTMACRO or a string: " ", < >, ' '
 *
 *	Entry	lbufp points to beginning of subjectString
 *	Exit
 *	Returns
 *	Calls	getTMstring
 */

//char * strstr();


VOID PASCAL CODESIZE
instring ()
{
    register char *p;
    register USHORT cb = 0;
    register char cc;
    char	  *subjtext;
    char	  *searchtext;
    USHORT	    startindex = 1;

    switchname ();

    /* First find start index */

    p = lbufp;

    if ((cc = *p) != '"' && cc != '\'' && cc != '<' && !test4TM ()) {

	lbufp = p;
	startindex = (USHORT)exprconst();	/* get start index */

	if (lbufp != p)
	    if (skipblanks () == ',')
		SKIPC ();
	    else
		error(E_EXP,"comma");

    } else
	lbufp = p;

    if (subjtext = getTMstring () ) {

	cb = (USHORT) strlen(subjtext);

	if (startindex < 1 || startindex > cb)
	    errorc (E_VOR);

	if (skipblanks () == ',')
	    SKIPC ();
	else
	    error(E_EXP,"comma");


	/* then check for searchtext */

	if (searchtext = getTMstring () ) {

	   p = subjtext + startindex - 1;
	   if (p = strstr (p, searchtext))
	       cb = (USHORT)(p - subjtext + 1);
	   else
	       cb = 0;
	}
    }

    assignconst (cb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmemit.c ===
/* asmemit.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <io.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"

#define LINBUFSIZE EMITBUFSIZE - 20         /* line # records can't as big */

#define OMFBYTE(c)      *ebufpos++ = (unsigned char)(c)
#define FIXBYTE(c)      *efixpos++ = (unsigned char)(c)
#define LINBYTE(c)      *elinpos++ = (unsigned char)(c)
#define EBUFOPEN(c)     (ebufpos+(c) <= emitbuf+EMITBUFSIZE)
#define EFIXOPEN(c)     (efixpos+(c) < efixbuffer+EMITBUFSIZE)
#define ELINOPEN(c)     (elinpos+(c) <= elinbuffer+LINBUFSIZE)

UCHAR   emitbuf[EMITBUFSIZE];
UCHAR   efixbuffer[EMITBUFSIZE];
UCHAR   elinbuffer[LINBUFSIZE];
UCHAR   *ebufpos = emitbuf;
UCHAR   *efixpos = efixbuffer;
UCHAR   *elinpos = elinbuffer;
UCHAR   ehoffset = 0;                   /* number of bytes into segment index */
UCHAR   emitrecordtype = 0;
OFFSET  ecuroffset;
USHORT  ecursegment;
long    oOMFCur;
SHORT   FixupOp = 0;
SHORT    LedataOp = 0xA0;

USHORT  linSegment;
UCHAR   fLineUsed32;
SHORT   fUnderScore;
UCHAR   fIniter = TRUE;
UCHAR   fNoMap;                    /* hack to disable fixup mapping for CV */

extern PFPOSTRUCT  pFpoHead;
extern PFPOSTRUCT  pFpoTail;
extern unsigned long numFpoRecords;

VOID CODESIZE edump( VOID );
VOID PASCAL CODESIZE emitoffset( OFFSET, SHORT );

/* The calls to the routines in this module appear in the following group
   order.  Ordering within a group is unspecified:

  Group 1:
           emodule (Pname)

  Group 2:
           emitsymbol (Psymb)

  Group 3:
           emitsegment (Psymb)
           emitglobal (Psymb)
           emitextern (Psymb)

  Group 4:
           emitcbyte (BYTE)
           emitobject(pDSC)
           emitcword (WORD)
           emitdup (???)

  Group 5:
           emitdone (Psymb)

 */




/***    emitsword - feed a word into the buffer
 *
 *      emitsword (w);
 *
 *      Entry   w = word to feed into omf buffer
 *      Exit    word placed in buffer low byte first
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsword (
        USHORT w
){
        OMFBYTE(w);
        OMFBYTE(w >> 8);
}


/* emitoff - write an offset, either 16 or 32 bits, depending upon
 * use32.  note conditional compilation trick with sizeof(OFFSET).
 * with more cleverness, this could be a macro. -Hans */

VOID PASCAL CODESIZE
emitoffset(
        OFFSET off,
        SHORT use32
){
        emitsword((USHORT)off);
        if (sizeof(OFFSET) > 2 && use32)
                emitsword((USHORT)highWord(off));
}

/***    emitSymbol - output name string
 *
 *      Entry
 *          pSY - pointer to symbol table entry to dump
 */


VOID PASCAL CODESIZE
emitSymbol(
        SYMBOL FARSYM *pSY
){
        if (pSY->attr & M_CDECL)
            fUnderScore++;

        if (pSY->lcnamp)
                emitname ((NAME FAR *)pSY->lcnamp);
        else
                emitname (pSY->nampnt);
}

/***    emitname - write FAR name preceeded by length into omf buffer
 *
 *      emitname (name);
 *
 *      Entry   name = FAR pointer to name string
 *      Exit    length of name followed by name written to omf buffer
 *      Returns none
 */


VOID PASCAL CODESIZE
emitname (
        NAME FAR *nam
){
        char FAR *p;

        OMFBYTE(STRFLEN ((char FAR *)nam->id)+fUnderScore);

        if (fUnderScore) {      /* leading _ for C language */
            fUnderScore = 0;
            OMFBYTE('_');
        }

        for (p = (char FAR *)nam->id; *p; p++)
                OMFBYTE(*p);
}


/***    flushbuffer - write out linker record
 *
 *      flushbuffer ();
 *
 *      Entry   ebufpos = next address in emitbuf
 *              emitbuf = data buffer
 *              emitrecordtype = type of omf data in buffer
 *              ehoffset = length of segment index data in buffer
 *      Exit    data written to obj->fil if data in buffer
 *              buffer set empty (ebufpos = emitbuf)
 *              segment index length set to 0
 *      Returns none
 */


VOID PASCAL CODESIZE
flushbuffer ()
{
        /* Don't put out an empty data record, but can do empty
         * anything else */

        if ((emitrecordtype&~1) != 0xA0 ||
            (ebufpos - emitbuf) != ehoffset) /* RN */
                ebuffer (emitrecordtype, ebufpos, emitbuf);

        ebufpos = emitbuf;
        ehoffset = 0;
}




/***    flushfixup, flushline, write out fixup/line record
 *
 *      flushfixup ();
 *
 *      Entry   efixbuffer = fixup buffer
 *              efixpos = address of next byte in fixup buffer
 *      Exit    fixup buffer written to file if not empty
 *              fixup buffer set empty (efixpos = efixbuffer)
 *      Returns none
 */


VOID PASCAL CODESIZE
flushfixup ()
{
        ebuffer (FixupOp, efixpos, efixbuffer);
        FixupOp = 0;
        efixpos = efixbuffer;
}

VOID PASCAL CODESIZE
flushline ()
{
        USHORT recordT;

        recordT = emitrecordtype;

        ebuffer ( (USHORT)(fLineUsed32? 0x95: 0x94), elinpos, elinbuffer);
        elinpos = elinbuffer;
        emitrecordtype = (unsigned char)recordT;
}




/***    emitsetrecordtype - set record type and flush buffers if necessary
 *
 *      emitsetrecordtype (t);
 *
 *      Entry   t = type of omf record
 *      Exit    emit and fixup buffers flushed if t != current record type
 *              segment index written to buffer if data or dup omf record
 *              emit segment set to current segment
 *              emit offset set to offset within current segment
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsetrecordtype (
        UCHAR t
){
        if (emitrecordtype && emitrecordtype != t) {
                /* flush emit and fixup buffers if active and not of same type */
                flushbuffer ();
                flushfixup ();
                switch(t)
                {
                case 0xA0:
                case 0xA1:      /* LEDATA or */
                case 0xA2:      /* LIDATA (dup) record */
                case 0xA3:
                    if (pcsegment) {

                        /* create a new header */
                        ecursegment = pcsegment->symu.segmnt.segIndex;
                        ecuroffset = pcoffset;
                        emitsindex (pcsegment->symu.segmnt.segIndex);

                        /* if we are getting to the end of the buffer
                         * and its a 32 bit segment, we need to start
                         * using 32 bit offsets in the LEDATA header.
                         * -Hans */

                        if (wordsize == 4)
                        {
                                if (t>= 0xA2)
                                        t = 0xA3;
                                /* there is a bug in the current linker--
                                 * all ledata or lidata records within
                                 * a module have to be either 16 or 32.
                                 * comment out optimization until this
                                 * is fixed */
                                else /* if (pcoffset>0x0ffffL-EMITBUFSIZE) */
                                        LedataOp = t = 0xA1;
                        }
                        emitoffset((OFFSET)pcoffset, (SHORT)(t&1));
                        if (t&1)
                                ehoffset += 2; /* RN */
                        break;
                    }
                    else
                        errorc (E_ENS);

                default:
                        break;
                }
        }
        if (t == 0xA4) {
            t = 0xA1;
        }
        emitrecordtype = t;
}




/***    emitsindex - output 'index' of segment, external, etc.
 *
 *      emitsindex (i);
 *
 *      Entry   i = index
 *      Exit    index written to emit buffer
 *              ehoffset = 3 if single byte index
 *              ehoffset = 4 if double byte index
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsindex (
        register USHORT i
){
        ehoffset = 3;
        if (i >= 0x80) {
                OMFBYTE((i >> 8) + 0x80);
                ehoffset++;
        }
        OMFBYTE(i);
}




/***    emodule - output module name record
 *
 *      emodule (pmodule);
 *
 *      Entry   pmodule = pointer to module name
 *      Exit    module name written to obj->fil
 *              current emit segment and offset set to 0
 *      Returns none
 */


VOID PASCAL CODESIZE
emodule (
        NAME FAR *pmodule
){
        char FAR *p;

        emitsetrecordtype (0x80);
        emitname (pmodule);
        flushbuffer ();

        if (fDosSeg) {

            emitsetrecordtype (0x88);
            emitsword((USHORT)(0x9E00 | 0x80));  /* nopurge + class = DOSSEG */
            flushbuffer ();
        }

        if (codeview == CVSYMBOLS){

            /* output speical comment record to handle symbol section */

            emitsetrecordtype (0x88);
            OMFBYTE(0);
            emitsword(0x1a1);
            emitsword('V'<< 8 | 'C');
            flushbuffer ();
        }

        while (pLib) {

            emitsetrecordtype (0x88);
            emitsword((USHORT) (0x9F00 | 0x80));  /* nopurge + class = Library*/

            for (p = (char FAR *)pLib->text; *p; p++)
                   OMFBYTE(*p);

            flushbuffer ();
            pLib = pLib->strnext;
        }

        ecuroffset = 0;             /* initial for pass2 */
        ecursegment = 0;
}




/***    emitlname - put symbols into bufer to form 'lnames' record
 *
 *      emitlname (psym);
 *
 *      Entry   psym = pointer to symbol structure
 *      Exit    current record type set to LNAMES and buffer flushed if
 *              necessary.  The name string is written to the emit buffer.
 *      Returns none
 */


VOID PASCAL CODESIZE
emitlname (
        SYMBOL FARSYM *psym
){
        emitsetrecordtype (0x96);
        if (lnameIndex == 3)        /* 1st time around */
                OMFBYTE(0);         /* output the NULL name */

        if (!EBUFOPEN(STRFLEN (psym->nampnt->id) + 1)) {
                flushbuffer ();
                emitsetrecordtype (0x96);
        }
        emitSymbol(psym);
}




/***    emitsegment - output a segment definition record
 *
 *      emitsegment (pseg);
 *
 *      Entry   pseg = pointer to segment name
 *      Exit    record type set to SEGDEF and emit buffer flushed if necessary.
 *              SEGDEF record written to emit buffer
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsegment (
        SYMBOL FARSYM *pseg
){
        UCHAR   comb;
        UCHAR   algn;
        SHORT   use32=0;

        /* use32 is whether to put out 16 or 32 bit offsets.  it
         * only works if segmnt.use32 is enabled.  the D bit
         * is keyed off segmnt.use32 -Hans */

        if (sizeof(OFFSET)>2 &&
            (pseg->symu.segmnt.use32 > 2) &&
            pseg->symu.segmnt.seglen > 0xffffL)
                use32 = 1;

        emitsetrecordtype ((UCHAR)(0x98+use32)); /* SEGDEF */

        algn = pseg->symu.segmnt.align;
        comb = pseg->symu.segmnt.combine;

#ifdef V386
        if (!use32 && pseg->symu.segmnt.seglen == 0x10000L) /* add 'big' bit? */
                if (pseg->symu.segmnt.use32 > 2)
                        OMFBYTE((algn<<5) + (comb<<2) + 3); /* add 'D' bit */
                else
                        OMFBYTE((algn<<5) + (comb<<2) + 2);
        else
#endif
                if (pseg->symu.segmnt.use32 > 2)
                        OMFBYTE((algn<<5) + (comb<<2) + 1); /* add 'D' bit */
                else
                        OMFBYTE((algn<<5) + (comb<<2));

        if (algn == 0 || algn == (UCHAR)-1) {
                /* segment number of seg */
                emitsword ((USHORT)pseg->symu.segmnt.locate);
                OMFBYTE(0);
        }
        emitoffset(pseg->symu.segmnt.seglen, use32);

        emitsindex (pseg->symu.segmnt.lnameIndex);
        pseg->symu.segmnt.segIndex = segmentnum++;

        /* seg, class number */
        if (!pseg->symu.segmnt.classptr)   /* Use blank name */
                emitsindex (1);
        else
                emitsindex((USHORT)((pseg->symu.segmnt.classptr->symkind == SEGMENT) ?
                            pseg->symu.segmnt.classptr->symu.segmnt.lnameIndex:
                            pseg->symu.segmnt.classptr->symu.ext.extIndex));

        emitsindex (1);
        flushbuffer ();
}




/***    emitgroup - output a group record
 *
 *      emitgroup (pgrp);
 *
 *      Entry   pgrp = pointer to group name
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitgroup (
        SYMBOL FARSYM *pgrp
){
        SYMBOL FARSYM *pseg;

        emitsetrecordtype (0x9A);

        emitsindex (pgrp->symu.grupe.groupIndex);
        pgrp->symu.grupe.groupIndex = groupnum++;

        pseg = pgrp->symu.grupe.segptr;
        while (pseg) {
                if (pseg->symu.segmnt.segIndex){

                        OMFBYTE(((pseg->attr == XTERN)? 0xFE: 0xFF));
                        emitsindex (pseg->symu.segmnt.segIndex);
                }
                pseg = pseg->symu.segmnt.nxtseg;
        }
        flushbuffer ();
}




/***    emitglobal - output a global declaration
 *
 *      emitglobal (pglob);
 *
 *      Entry   pglob = pointer to global name
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitglobal (
        SYMBOL FARSYM *pglob
){
        static SHORT gIndexCur = -1, sIndexCur = -1;
        register SHORT gIndex, sIndex, cbNeeded;
        OFFSET pubvalue;
        SHORT use32 = 0x90;

        pubvalue = pglob->offset;
        if ((unsigned long)pubvalue >= 0x10000l)
                use32 = 0x91;

        /*  A public EQU can be negative, so must adjust value */
        /* this is happening because masm keeps numbers
         * in 17/33 bit sign magnitude representation */

        if ((pglob->symkind == EQU) && pglob->symu.equ.equrec.expr.esign)
                pubvalue = (short)(((use32==0x91? 0xffffffffl : 65535) - pglob->offset) + 1);


        /* Match Intel action, If a global is code, it should
           belong to the group of the CS assume at the time of
           definition, if there is one */

        /* Output group index for data labels too */

        sIndex = gIndex = 0;

        if (((1 << pglob->symkind) & (M_PROC | M_CLABEL))
            && pglob->symu.clabel.csassume
            && pglob->symu.clabel.csassume->symkind == GROUP
            && pglob->symsegptr && pglob->symsegptr->symu.segmnt.grouptr)

            gIndex = pglob->symu.clabel.csassume->symu.grupe.groupIndex;


        if (pglob->symsegptr)
            sIndex = pglob->symsegptr->symu.segmnt.segIndex;

        cbNeeded = STRFLEN ((char FAR *)pglob->nampnt->id) + 13;

        if (gIndex != gIndexCur ||
            sIndex != sIndexCur ||
            emitrecordtype != use32 ||
            !EBUFOPEN(cbNeeded)) {     /* start a new record */

            flushbuffer();
            emitsetrecordtype ((UCHAR)use32);

            gIndexCur = gIndex;
            sIndexCur = sIndex;

            emitsindex (gIndexCur);
            emitsindex (sIndexCur);

            if (sIndex == 0)            /* absolutes require a 0 frame # */
                emitsword (sIndex);
        }

        emitSymbol(pglob);

        emitoffset(pubvalue, (SHORT)(use32&1));
        if (codeview == CVSYMBOLS) {

            if (pglob->symkind == EQU)    /* type not stored */

                emitsindex(typeFet(pglob->symtype));
            else
                emitsindex (pglob->symu.clabel.type);
        }
        else
            emitsindex(0);              /* untyped */
}




/***    emitextern - emit an external
 *
 *      emitextern (psym)
 *
 *      Entry   *psym = symbol entry for external
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitextern (
        SYMBOL FARSYM *psym
){
        USHORT recType;

        recType = 0x8c;

        if (psym->symkind == EQU){

            /* this an extrn lab:abs definition, which is allocated as
             * an EQU record which doesn't have space for a index so
             * it stored in the unused length field */

            psym->length = externnum++;
        }
        else {
            psym->symu.ext.extIndex = externnum++;

            if (psym->symu.ext.commFlag)
                recType = 0xb0;
        }

        fKillPass1 |= pass2;

        emitsetrecordtype ((UCHAR)recType);

        if (!EBUFOPEN(STRFLEN (psym->nampnt->id) + 9)) {
                flushbuffer ();
                emitsetrecordtype ((UCHAR)recType);
        }

        emitSymbol(psym);

        if (codeview == CVSYMBOLS)

            emitsindex(typeFet(psym->symtype));
        else
            OMFBYTE(0);

        if (recType == 0xb0) {          /* output commdef variate */

            if (psym->symu.ext.commFlag == 1) {    /* near item */

                OMFBYTE(0x62);
                                        /* size of field */
                OMFBYTE(0x81);
                emitsword((USHORT)(psym->symu.ext.length * psym->symtype));
            }
            else {
                OMFBYTE(0x61);          /* far item */

                OMFBYTE(0x84);              /* # of elements */
                emitsword((USHORT)psym->symu.ext.length);
                OMFBYTE(psym->symu.ext.length >> 16);

                OMFBYTE(0x81);              /* element size */
                emitsword(psym->symtype);
            }


        }
}


/***    emitfltfix - emit fixup for floating point
 *
 *      emitfltfix (group, extidx);
 *
 *      Entry
 *              *extidx = external id (0 if not assigned)
 *      Exit
 *      Returns
 *      Calls
 */

VOID PASCAL CODESIZE
emitfltfix (
        USHORT group,
        USHORT item,
        USHORT *extidx
){
        register SHORT i;

        if (*extidx == 0) {
                /* Must define it */
                if (!moduleflag)
                        dumpname ();
                /* All fixups are FxyRQQ */
                *extidx = externnum++;
                if (!EBUFOPEN(7))
                        flushbuffer ();
                emitsetrecordtype (0x8C);
                /* Name length */
                OMFBYTE(6);
                OMFBYTE('F');
                OMFBYTE(group);         /* Group I or J */
                OMFBYTE(item);          /* Item  D, W, E, C, S, A */
                OMFBYTE('R');
                OMFBYTE('Q');
                OMFBYTE('Q');
                OMFBYTE(0);
        }
        if (pass2) {            /* Must put out a extern ref */
                if (!EFIXOPEN(5))
                        emitdumpdata ( (UCHAR)LedataOp);
                emitsetrecordtype ( (UCHAR) LedataOp);

                FixupOp = 0x9C + (LedataOp & 1);

                /* output location */
                i = (SHORT)(ebufpos - emitbuf - ehoffset);
                FIXBYTE(0xC4 + (i >> 8));
                FIXBYTE(i);
                FIXBYTE(0x46);

                if (*extidx >= 0x80)      /* Output 2 byte link # */
                        FIXBYTE ((UCHAR)((*extidx >> 8) + 0x80));

                FIXBYTE(*extidx);
        }
}



/***    emitline - output a line number offset pair
 *
 *      emitline(pcOffset)
 *
 *      Entry   pcoffset: code offset to output
 *              src->line: for the current line number
 *      Exit    none
 */

VOID PASCAL CODESIZE
emitline()
{
    static UCHAR fCurrent32;

    if (codeview < CVLINE || !pass2 || !objing || !pcsegment)
        return;

    if (macrolevel == 0 ||
        !fPutFirstOp) {

        fCurrent32 = (emitrecordtype == 0xA1);

        if (linSegment != pcsegment->symu.segmnt.segIndex ||
            ! ELINOPEN(2 + wordsize) ||
            fLineUsed32 != fCurrent32 ) {

            flushline();

            /* Start a new line # segment */

            linSegment = pcsegment->symu.segmnt.segIndex;
            fLineUsed32 = fCurrent32;

            /* start record with group index and segment index */

            LINBYTE(0);                 /* no group */

            if (linSegment >= 0x80)      /* Output 2 byte link # */
                LINBYTE ((UCHAR)((linSegment >> 8) + 0x80));

            LINBYTE(linSegment);
        }

        LINBYTE(pFCBCur->line);             /* First line # */
        LINBYTE(pFCBCur->line >> 8);

        LINBYTE(pcoffset);              /* then offset */
        LINBYTE(pcoffset >> 8);

        if (fLineUsed32) {              /* 32 bit offset for large segments */

            LINBYTE(highWord(pcoffset));
            LINBYTE(highWord(pcoffset) >> 8);
        }
    }
    if (macrolevel != 0)
        fPutFirstOp = TRUE;
}



/***    fixroom - check for space in fix buffer
 *
 *      flag = fixroom (n);
 *
 *      Entry   n = number of bytes to insert in buffer
 *      Exit    none
 *      Returns TRUE if n bytes will fit in buffer
 *              FALSE if n bytes will not fit in buffer
 */


UCHAR PASCAL CODESIZE
fixroom (
        register UCHAR   n
){
        return (EFIXOPEN(n));
}




/***    emitcleanq - check for buffer cleaning
 *
 *      flag = emitcleanq (n);
 *
 *      Entry   n = number of bytes to insert in buffer
 *      Exit    E_ENS error message issued if pcsegment is null
 *      Returns TRUE if
 */


UCHAR PASCAL CODESIZE
emitcleanq (
        UCHAR n
){
        if (!pcsegment)

            errorc (E_ENS);
        else
            return (ecursegment != pcsegment->symu.segmnt.segIndex ||
                pcoffset != ecuroffset ||
                !EBUFOPEN(n));
}




/***    emitdumpdata - clean data buffer and set up for data record
 *
 *      emitdumpdata (recordnum);
 *
 *      Entry   recordnum = record type
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitdumpdata (
        UCHAR recordnum
){
        flushbuffer ();
        /* force dump of buffer */
        emitrecordtype = 0xFF;
        emitsetrecordtype (recordnum);
}




/***    emitcbyte - emit constant byte into segment
 *
 *      emitcbyte (b)
 *
 *      Entry   b = byte
 *              pcsegment = pointer to segment symbol entry
 *              pcoffset = offset into segment
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitcbyte (
        UCHAR b
){
        /* if the segment is changed or the offset is not current or there
           is no room in the buffer then flush buffer and start over */

        if (emitcleanq (1))
                emitdumpdata ((UCHAR)LedataOp);

        emitsetrecordtype ((UCHAR)LedataOp);
        OMFBYTE(b);
        ecuroffset++;
}



/***    emitcword - place a constant word into data record
 *
 *      emitcword (w);
 *
 *      Entry   w = word
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitcword (
        OFFSET w
){
        if (emitcleanq (2))
                emitdumpdata ((UCHAR)LedataOp);

        emitsetrecordtype ((UCHAR)LedataOp);
        emitsword ((USHORT)w);
        ecuroffset += 2;
}

/***    emitcdword - place a constant word into data record
 *
 *      emitcword (w);
 *
 *      Entry   w = word
 *      Exit
 *      Returns
 *      Calls
 */
VOID PASCAL CODESIZE
emitcdword (
        OFFSET w
){
        if (emitcleanq (4))
                emitdumpdata ((UCHAR)LedataOp);

        emitsetrecordtype ((UCHAR)LedataOp);
        emitsword ((USHORT)w);
        emitsword (highWord(w));
        ecuroffset += 4;
}



/***    emitlong - emit a long constant
 *
 *      emitlong (pdsc);
 *
 *      Entry   *pdsc = duprecord
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitlong (
        struct duprec FARSYM *pdsc
){
        UCHAR *cp;
        OFFSET tmpstart;
        OFFSET tmpcurr;
        OFFSET tmplimit;

        tmpstart = pcoffset;
        cp = pdsc->duptype.duplong.ldata;
        tmplimit = (pcoffset + pdsc->duptype.duplong.llen) - 1;
        for (tmpcurr = tmpstart; tmpcurr <= tmplimit; ++tmpcurr) {
                pcoffset = tmpcurr;
                emitcbyte ((UCHAR)*cp++);
        }
        pcoffset = tmpstart;
}


VOID PASCAL CODESIZE
emitnop ()
{
        errorc(E_NOP);
        emitopcode(0x90);
}



/***    emitobject - emit object in dup or iter record to OMF stream
 *
 *      emitobject (pdesc);
 *
 *      Entry   *pdesc = parse stack entry
 *              Global - fInter -> FALSE if in iterated DUP
 */


VOID PASCAL CODESIZE
emitobject (
        register struct psop *pso
){
        register SHORT i;

        if (!pcsegment) {
                errorc (E_ENS);
                return;
        }
        mapFixup(pso);

        if (fIniter) {

            i = LedataOp;
            if (wordsize == 4 || pso->fixtype >= F32POINTER)
                i |= 1;

            emitsetrecordtype ((UCHAR)i);
         }

        /* Data or DUP record */
         if (pso->fixtype == FCONSTANT) {

            if (!fIniter) {
                    if (pso->dsize == 1)
                            OMFBYTE(pso->doffset);
                    else if (pso->dsize == 2)
                            emitsword ((USHORT)pso->doffset);
                    else
                            for (i = pso->dsize; i; i--)
                                    OMFBYTE(0);
            }
            else switch(pso->dsize) {

                case 1:
                        emitcbyte ((UCHAR)pso->doffset);
                        break;
                case 2:
                emit2:
                        emitcword (pso->doffset);
                        break;
                case 4:
                emit4:
                        emitcdword (pso->doffset);
                        break;
                default:
                        /* the indeterminate case had been set up
                           by emit2byte as 2.  we are now leaving
                           it as zero  and doing the mapping here. */

                        if (wordsize==4)
                                goto emit4;
                        else
                                goto emit2;
            }
        }
        else
            emitfixup (pso);
}



/***    emitfixup - emit fixup data into fixup buffer
 *
 *      emitfixup (pso)
 *
 *      Entry  PSO for object
 */


VOID PASCAL CODESIZE
emitfixup (
        register struct psop *pso
){
        UCHAR   fixtype;
        USHORT  dlen;           /* length of operand */
        UCHAR   flen;           /* length of fixup */
        SYMBOL FARSYM *pframe;
        SYMBOL FARSYM *ptarget;
        register USHORT   tmp;
        SHORT i;

        fixtype = fixvalues[pso->fixtype];

        emitgetspec (&pframe, &ptarget, pso);

        /* magic numbers for omf types. */

        dlen = pso->dsize;

        if (ptarget){
            if ((M_XTERN & ptarget->attr) &&
                !pframe && (fixtype == 2 || fixtype == 3))
                    pframe = ptarget;
        }
        else
            return;

        flen = 7;
        if (pso->doffset)                /* target displacement */
                flen += 2 + ((emitrecordtype&1) << 1);

        /* make sure that we have enough room in the various buffers */
        if (fIniter)
                if (emitcleanq ((UCHAR)dlen) || !EFIXOPEN(flen))
                        emitdumpdata ((UCHAR)(LedataOp +2 - 2 * fIniter)); /* RN */

        /* set fixup type--32 or 16 */
        if (emitrecordtype&1)
        {
                if (FixupOp == 0x9C)
                        errorc(E_PHE); /* is there a better message? */
                FixupOp = 0x9D;
        }
        else
        {
                if (FixupOp == 0x9D)
                        errorc(E_PHE); /* is there a better message? */
                FixupOp = 0x9C;
        }
        /* build high byte of location */
        tmp = 0x80 + (fixtype << 2);
        if (!(M_SHRT & pso->dtype))          /* set 'M' bit */
                tmp |= 0x40;

        i = (SHORT)(ebufpos - emitbuf - ehoffset);
        FIXBYTE(tmp + (i >> 8));

        /* build low byte of location */
        FIXBYTE(i);

        /* output fixup data */
        FIXBYTE(efixdat (pframe, ptarget, pso->doffset));

        tmp = (pframe->symkind == EQU) ?
               pframe->length: pframe->symu.ext.extIndex;

        if (tmp >= 0x80)
                FIXBYTE((tmp >> 8) + 0x80);

        FIXBYTE(tmp);

        tmp = (ptarget->symkind == EQU) ?
               ptarget->length: ptarget->symu.ext.extIndex;

        /* send target spec */
        if (tmp >= 0x80)
                FIXBYTE((tmp >> 8) + 0x80);

        FIXBYTE(tmp);

        if (pso->doffset) {
                FIXBYTE(pso->doffset);
                FIXBYTE((UCHAR)(pso->doffset >> 8));
#ifdef V386
                if (FixupOp == 0x9D)
                {
                        FIXBYTE((UCHAR)highWord(pso->doffset));
                        FIXBYTE((UCHAR)(highWord(pso->doffset) >> 8));
                }
#endif
        }
        ecuroffset += dlen;

        /* put zero bytes into data buffer */
        while (dlen--)
                OMFBYTE(0);
}



/***    mapFixup - map relocatable objects into the correct fixup type
 *
 *
 *      Entry   *pdesc = parse stack entry
 *      Returns
 *          Sets fixtype and dsize
 */


VOID PASCAL CODESIZE
mapFixup (
        register struct psop *pso
){

        if (fNoMap)
            return;

        if ((1 << pso->fixtype & (M_FCONSTANT | M_FNONE)) &&
            (pso->dsegment || pso->dflag == XTERNAL))

            pso->fixtype = FOFFSET;

#ifdef V386

         /* Remap OFFSET and POINTERS into there 32 bit types */

        if (pso->mode > 4 || pso->dsize > 4 ||
            (pso->dsegment && pso->dsegment->symkind == SEGMENT &&
             pso->dsegment->symu.segmnt.use32 == 4) ||
            pso->dcontext == pFlatGroup && pso->dsize == 4)

            switch(pso->fixtype) {

            case FOFFSET:

                    if (pso->dsize != 4)
                        errorc(E_IIS & ~E_WARN1);

                    else
                        pso->fixtype = F32OFFSET;
                    break;

            case FPOINTER:
                    if (pso->dsize != 6)
                        errorc(E_IIS & ~E_WARN1);

                    else
                        pso->fixtype = F32POINTER;
                    break;

            /* default is to do no mapping */
            }
#endif
}


/***    emitgetspec - set frame and target of parse entry
 *
 *      emitgetspec (pframe, ptarget, pdesc);
 *
 *      Entry   pframe
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitgetspec (
        SYMBOL FARSYM * *pframe,
        SYMBOL FARSYM * *ptarget,
        register struct psop *pso
){

        if (pso->fixtype != FCONSTANT &&
            pso->dflag == XTERNAL) {

                   *ptarget = pso->dextptr;
                   *pframe = pso->dsegment;

#ifndef FEATURE
                   /* externs without segments and the current assume is to
                    * flat space get a flat space segment frame */

                   if (! *pframe && pso->dextptr &&
                      regsegment[isCodeLabel(pso->dextptr) ? CSSEG: DSSEG] == pFlatGroup)

                        *pframe = pFlatGroup;

#endif
                   if (pso->dcontext)
                           *pframe = pso->dcontext;
        }
        else {

            *ptarget = pso->dsegment;   /* containing segment */
            *pframe = pso->dcontext;    /* context(?) of value */
        }

        if (!*pframe)
                *pframe = *ptarget;
}




/***    efixdat - return fixdat byte
 *
 *      routine  (pframe, ptarget, roffset);
 *
 *      Entry   *pframe =
 *              *ptarget =
 *              roffset =
 *      Exit
 *      Returns
 *      Calls
 */


UCHAR PASCAL CODESIZE
efixdat (
        SYMBOL FARSYM *pframe,
        SYMBOL FARSYM *ptarget,
        OFFSET roffset
){
        register UCHAR   tmp;

        /* build fixdat byte */
        tmp = 0;
        /* 'F' bit is off */
        /* 'T' bit is off */
        if (roffset == 0)       /* 'P' bit is on */
                tmp = 4;

        if (pframe)
                if (M_XTERN & pframe->attr)
                       tmp += 2 << 4;
                else if (pframe->symkind == GROUP)
                       tmp += 1 << 4;

        /* frame part of fixdat */

        if (ptarget)
                if (M_XTERN & ptarget->attr)
                       tmp += 2;
                else if (ptarget->symkind == GROUP)
                       tmp += 1;

        return (tmp);
}



/***    edupitem - emit single dup item and count size
 *
 *      edupitem (pdup);
 *
 *      Entry   *pdup = dup record
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
edupitem (
        struct duprec FARSYM    *pdup
){
        register USHORT len;
        UCHAR *cp;

        if (nestCur > nestMax)
            nestMax++;

        if (ebufpos - emitbuf != EMITBUFSIZE + 1) {
                len = wordsize+2;

            if (pdup->dupkind == LONG)
                len += pdup->duptype.duplong.llen + 1;

            else if (pdup->dupkind == ITEM)
                len += pdup->duptype.dupitem.ddata->dsckind.opnd.dsize + 1;

            if (!EBUFOPEN(len))
                ebufpos = emitbuf + EMITBUFSIZE + 1;

            else {
                emitsword ((USHORT)(pdup->rptcnt));
                /* repeat count */
                if (emitrecordtype & 1)
                        emitsword((USHORT)(pdup->rptcnt >> 16));

                /* block count */
                emitsword (pdup->itemcnt);

                if (pdup->dupkind == LONG) {
                    cp = pdup->duptype.duplong.ldata;
                    len = pdup->duptype.duplong.llen;

                    OMFBYTE(len);

                    do {
                            OMFBYTE(*cp++);
                    } while (--len);
                }
                else if (pdup->dupkind == ITEM) {
                    OMFBYTE(pdup->duptype.dupitem.ddata->dsckind.opnd.dsize);

                        fIniter--;
                        emitobject (&pdup->duptype.dupitem.ddata->dsckind.opnd);
                        fIniter++;
                }
            }
        }
}




/***    emitdup - emit dup record and appropriate fixup record
 *
 *      emitdup (pdup);
 *
 *      Entry   *pdup = dup record
 *      Exit
 *      Returns FALSE if dup is too large to fit in buffer
 *      Calls
 */


UCHAR PASCAL CODESIZE
emitdup (
        struct duprec FARSYM *pdup
){
        SHORT op;

        op = (f386already) ? 0xA3 : 0xA2;
        nestCur = nestMax = 0;

        emitdumpdata ((UCHAR)op);
        emitsetrecordtype ((UCHAR)op);

        /* scan dup tree and emit dup items */
        scandup (pdup, edupitem);

        if (ebufpos - emitbuf == EMITBUFSIZE + 1) {
                ebufpos = emitbuf;
                ehoffset = 0;
                efixpos = efixbuffer;
                return(FALSE);
        }
        else {
                flushbuffer ();
                flushfixup ();
                emitrecordtype = 0xFF;
        }
        return (nestMax <= 18);
}


/***    emitEndPass1 - emit end of pass1 info
 *
 */


VOID PASCAL emitEndPass1()
{

        emitsetrecordtype (0x88);
        oEndPass1 = oOMFCur + 5;   /* note offset of end of pass1 OMF record */

        OMFBYTE(0);
        emitsword(0x100 | 0xA2);
        flushbuffer ();
}



/***    emitdone - produce end record
 *
 *      emitdone (pdesc);
 *
 *      Entry   *pdesc = parse tree entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL
emitdone (
        DSCREC *pdesc
){
        SYMBOL FARSYM *pframe;
        SYMBOL FARSYM *ptarget;
        OFFSET u;
        UCHAR endOMFtype;

        flushline();

        if (!pdesc)
        {
                emitsetrecordtype (0x8A); /* RN */
                /* emit null entry point marked in MOD TYP */
                /* there is a point of contention here.  some people
                 * (and decode.c, old assemblers and other things) say
                 * the low order bit is zero.  others, such as the
                 * omf documentation, say the low order bit should be
                 * 1.  since I dont know, and am trying to be compatable,
                 * I will obey the old tools.  maybe I'll change this
                 * later...             -Hans
                 * OMFBYTE(1); /* RN */

                OMFBYTE(0);
        }
        else {
                fKillPass1++;
                u = pdesc->dsckind.opnd.doffset;
                emitgetspec (&pframe, &ptarget, &pdesc->dsckind.opnd);

                if (!ptarget || !pframe)
                    return;

                endOMFtype = (cputype & P386)? 0x8B: 0x8A;

                if (M_XTERN & ptarget->attr)
                        pframe = ptarget;

                emitsetrecordtype (endOMFtype);

                /* emit entry point information */
                OMFBYTE(0xC1);
                OMFBYTE(efixdat (pframe, ptarget, u) & ~4);

                emitsindex (pframe->symu.segmnt.segIndex);
                emitsindex (ptarget->symu.segmnt.segIndex);

                emitsword((USHORT)u);       /* output offset */

#ifdef V386
                if (endOMFtype == 0x8B)
                        emitsword((USHORT)highWord(u));
#endif
        }
        flushbuffer ();
}

#ifndef M8086OPT

/***    EBYTE - Emit byte macro
 *
 *      EBYTE ( ch )
 *
 *      The bytes are buffered in obj.buf until the buffer fills
 *      then the buffer is written to disk via edump.
 *
 */

#define EBYTE( ch ){\
    if( !obj.cnt){\
        edump();\
    }\
    obj.cnt--;\
    checksum += *obj.pos++ = (char)ch;\
}

/***    ebuffer - write out object buffer
 *
 *      Writes the record type, record length, record data, and checksum to
 *      the obj file. This is done via EBYTE which buffers the writes into
 *      obj.buf.
 *
 *      Modifies    obj.cnt, obj.pos, objerr, emitrecordtype
 *      Exit        none
 *      Returns
 *      Calls       farwrite
 */

VOID CODESIZE
ebuffer (
        USHORT rectyp,
        UCHAR *bufpos,
        UCHAR *buffer
){
    register UCHAR   checksum;
    register i;
    USHORT  nb;


    if ((bufpos != buffer) && objing) {
        nb = (USHORT)(bufpos - buffer + 1);
        oOMFCur += nb + 3;
        checksum = 0;
        EBYTE(rectyp)
        i = nb & 0xFF;
        EBYTE( i )
        i = nb >> 8;
        EBYTE( i )
        while (buffer < bufpos){
            EBYTE( *buffer++ )
        }
        checksum = -checksum;
        EBYTE( checksum );
    }
    emitrecordtype = 0;
}


/***    edump - dump the emit buffer
 *
 *      edump ();
 *
 *      The bytes buffered in obj.buf are dumped to disk. And
 *      the count and buffer position are reinitialized.
 *
 *      Modifies    obj.cnt, obj.pos, objerr
 *      Exit        none
 *      Returns
 *      Calls       farwrite
 */

VOID CODESIZE
edump()
{

# if defined MSDOS && !defined FLATMODEL
    farwrite( obj.fh, obj.buf, (SHORT)(obj.siz - obj.cnt) );
# else
    if (_write( obj.fh, obj.buf, obj.siz - obj.cnt )
            != obj.siz - obj.cnt)
            objerr = -1;
# endif /* MSDOS */

    obj.cnt = obj.siz;
    obj.pos = obj.buf;
}
#endif /* M8086OPT */


#if !defined M8086OPT && !defined FLATMODEL

unsigned short _far _pascal DosWrite( unsigned short, unsigned char far *, unsigned short, unsigned short far *);

VOID farwrite( handle, buffer, count )
 int handle;
 UCHAR FAR * buffer;
 SHORT count;
{
  USHORT usWritten;

    if( DosWrite( handle, buffer, count, &usWritten ) ){
        objerr = -1;
    }
}

#endif

int emitFpo()
{
        struct nameStruct {
                SHORT   hashval;
                char    id[20];
        } nam = {0, ".debug$F"};

        PFPOSTRUCT    pFpo        = pFpoHead;
        SYMBOL        sym;
        UCHAR         comb        = 2;  // public
        UCHAR         algn        = 5;  // relocatable
        USHORT        tmp         = 0;
        unsigned long offset      = 0;
        unsigned long data_offset = 0;

        if (!pFpo) {
            return TRUE;
        }

        /*
         * write out the externs for all fpo procs
         * this must be done during pass1 so that the extdefs
         * are written to the omf file before the pubdefs
         */
        if (!pass2) {
            flushbuffer();
            for (pFpo=pFpoHead; pFpo; pFpo=pFpo->next) {
                pFpo->extidx = externnum++;
                emitsetrecordtype (0x8C);
                emitSymbol(pFpo->pSym);
                OMFBYTE(0);
                flushbuffer();
            }
            return TRUE;
        }

        /*
         * create the lnames record for the .debug$F section
         */
        emitsetrecordtype (0x96);
        memset(&sym,0,sizeof(SYMBOL));
        sym.nampnt = (NAME*) &nam;
        emitSymbol(&sym);
        flushbuffer();

        /*
         * create the segdef record for the .debug$F section
         */
        emitsetrecordtype (0x98);
        OMFBYTE((algn<<5) + (comb<<2) + 1);
        emitoffset(numFpoRecords*sizeof(FPO_DATA), 0);
        emitsindex (lnameIndex);
        emitsindex (1);
        emitsindex (1);
        flushbuffer();

        /*
         * now we have to cruise thru the list of fpo directives and
         * fixup any cases where there are multiple fpo directives for
         * a single procedure.  the procedure size needs to be changed
         * to account for the multiple directives.
         */
        pFpo=pFpoHead;
        flushbuffer();
        do {
            if ((pFpo->next) && (pFpo->next->pSym == pFpo->pSym)) {
                // we must have a group (2 or more) fpo directives
                // that are in the same function so lets fix them
                do {
                    pFpo->fpoData.cbProcSize =
                      pFpo->next->fpoData.ulOffStart - pFpo->fpoData.ulOffStart;
                    pFpo = pFpo->next;
                    // now we must output a pubdef and a extdef for the
                    // fpo record.  this is necessary because otherwise the
                    // linker will resolve the fixups to the first fpo record
                    // function.
                    pFpo->extidx = externnum++;
                    emitsetrecordtype (0x8C);
                    emitSymbol(pFpo->pSymAlt);
                    OMFBYTE(0);
                    flushbuffer();
                    emitglobal(pFpo->pSymAlt);
                } while ((pFpo->next) && (pFpo->next->pSym == pFpo->pSym));
                pFpo->fpoData.cbProcSize =
                   (pFpo->pSym->offset + pFpo->pSym->symu.plabel.proclen) -
                   pFpo->fpoData.ulOffStart;
            }
            else {
                pFpo->fpoData.cbProcSize = pFpo->pSym->symu.plabel.proclen;
            }
            pFpo = pFpo->next;
        } while (pFpo);

        /*
         * finally we scan the list of fpo directives and output the
         * actual fpo records and associated fixups
         */
        for (pFpo=pFpoHead; pFpo; pFpo=pFpo->next) {
            /*
             * emit the fpo record
             */
            emitsetrecordtype (0xA4);
            emitsindex (segmentnum);
            emitoffset(data_offset,1);
            data_offset += sizeof(FPO_DATA);
            offset = pFpo->fpoData.ulOffStart;
            pFpo->fpoData.ulOffStart = 0;
            memcpy((void*)ebufpos, (void*)&pFpo->fpoData, sizeof(FPO_DATA));
            ebufpos += sizeof(FPO_DATA);
            /*
             * emit the fixup record
             */
            emitsetrecordtype (0x9D);
            OMFBYTE(0xB8);   // m=0, loc=14, offset=0
            OMFBYTE(0x00);   // offset=0
            OMFBYTE(0x92);   // f=1, frame=1, t=0, p=0, target=2
            tmp = pFpo->extidx;
            if (tmp >= 0x80) {
                OMFBYTE((tmp >> 8) + 0x80);
            }
            OMFBYTE(tmp);
            OMFBYTE(offset);
            OMFBYTE(offset >>  8);
            OMFBYTE(offset >> 16);
            OMFBYTE(offset >> 24);
        }
        flushbuffer();

        lnameIndex++;
        segmentnum++;

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmdebug.h ===
/* asmdebug.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

/***    Output debugging information
 *      Ross Garmoe
 *      Copyright Microsoft Corporation, 1983
 *      September 27, 9 1983
 *
 *      This package was developed using concepts originally developed by
 *      Mark Zibokowski for the C version of the z editor.
 *
 *      The following set of macros output debugging information to the
 *      debugging file 'd_df'.  Output of debugging information is controlled
 *      by compile time conditionals and flags set by execution time switches.
 *      If the symbol DEBUG is defined at compile time, the macros are
 *      compiled to generate debugging information.  If DEBUG is not defined,
 *      then the macros are not compiled.  At execution time, the value of
 *      the variable 'd_debug' is compared with the value of the defined symbol
 *      DEBFLAG and if any bits match, debugging information is written.
 *      If debugging information is to be written, the information level
 *      specified in the macro is checked against the level specified at run
 *      time and information is written only if the compile level is less than
 *      the level specified at run time.
 *
 *      The macros are used as follows:
 *
 *      Define the global variables 'd_debug', 'd_dlevel', 'd_indent' and 'd_sindent'
 *      as integers and 'd_df' as a pointer to FILE.  In the argument processing
 *      routine set the value of 'd_debug' and 'd_dlevel' and open the trace output
 *      file and point to it with the variable 'd_df'.  'd_debug' , 'd_dlevel' and
 *      'd_indent' must be intialized to zero.
 *
 *      In any file of the program which is to produce debugging output,
 *      include this file 'debug.h' and define the selection symbol DEBFLAG.
 *
 *              #include debug.h
 *              #define DEBFLAG value
 *
 *      Then for any function which is to produce debug output include the
 *      following sets of macro calls.
 *
 *      At fuction entry:
 *
 *                      INDEBUG;
 *                      DEBOUT (level, ( fprintf argument string ));
 *
 *      At all function exits:
 *
 *                      DEBOUT (level, ( fprintf argument string ));
 *                      OUTDEBUG;
 *
 *      At other points of interest:
 *
 *                      DEBOUT (level, ( fprintf argument string ));
 *
 *      Note:   For the entry and exit points, the DEBOUT ((...)); string
 *              is optional.  The INDEBUG and OUTDEBUG macros control the
 *              indentation of the debug output to show the nesting levels of
 *              function calls
 *      Note:   The fprintf argument string is of the form:
 *                      d_df, "format", arg1, arg2,..., argn
 */

#ifdef DEBUG
# define INDEBUG      if(d_debug&DEBFLAG)d_indent++
# define DEBOUT(l,z)  if(d_debug&DEBFLAG&&l<=d_dlevel)\
                     {for(d_sindent=d_indent;d_sindent;d_sindent--)fprintf(d_df," ");\
                     fprintf z ;}else
# define OUTDEBUG     if(d_debug&DEBFLAG)d_indent--
  extern  long    d_debug, d_dlevel, d_indent;          /* debugging flags */
  extern  long    d_sindent;                /* indentation printing temporary */
  extern  FILE    *d_df;                    /* pointer to debug output file */
#else
# define INDEBUG
# define DEBOUT(l,z)
# define OUTDEBUG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmerr.c ===
/* asmerr.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmmsg.h"

#define MSGLEN 50
static char errstring[MSGLEN + 1];

extern  char FAR * FAR messages[];

extern short FAR msgnum[];

static USHORT badoff;

/***    errordisplay - display error
 *
 *      errordisplay();
 *
 *      Entry   debug = debug output flag
 *              pass2 = TRUE if pass 2
 *              listquiet = FALSE if error output to console
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL
errordisplay ()
{
    if  (pass2 || fPass1Err || debug) {
        if (lsting) {
            error_line (lst.fil, pFCBCur->fname, errorlineno);
            fputs(NLINE, lst.fil);
        }
    }
    if (!listquiet){
        error_line (ERRFILE, pFCBCur->fname, errorlineno);
        fputs("\n", ERRFILE);
    }
    if (pass2)
        if (warnCode > 0){      /* if its not a serve error */
                                  /* and were interested in this level*/
            if (warnCode <= warnlevel)
                warnnum++;
        }
        else
            errornum++;
    else if (fPass1Err)
        errornum++;
}


VOID PASCAL CODESIZE
error (
        USHORT code,
        UCHAR *str
){
        if (errorcode && code != E_LTL)
            return;

        fPass1Err = code & E_PASS1;
        warnCode = ((code >> 12) & 0x3);
        code &= E_ERRMASK;

        if (warnCode > warnlevel)
                /* don't bother with this warning; just return */
                return;

        errorcode = code;
        if (str)
                strncpy (strcpy(errstring, ": ")+2, str, MSGLEN-2);
        else
                *errstring = 0;
}


VOID PASCAL CODESIZE
errorn (
        USHORT code
){
        error (code,naim.pszName);
}



VOID PASCAL CODESIZE
errorc (
        USHORT code
){
        error (code,(char *)0);
}

VOID PASCAL
ferrorc (
        USHORT code
){
        error (code,(char *)0);
}



VOID PASCAL CODESIZE
errorcSYN ()
{
        error (E_SYN,(char *)0);
}



/***    error_line - print error message
 *
 *      error_line (code, l, file, line)
 *
 *      Entry   l = listing file
 *              line = line number in source or include file
 */


VOID PASCAL
error_line (
        FILE *l,
        UCHAR *file,
        short line
){
        static char mpWarnCode[3] = {'2', '4', '5'};
        char msgstring[MSGLEN+1], messT[MSGLEN+1];

        if (!messages[errorcode])
                messages[errorcode] = __FMSG_TEXT(msgnum[errorcode]);

        STRNFCPY(msgstring, (errorcode < E_MAX)? messages[errorcode]:
                            (char FAR *) __NMSG_TEXT(ER_UNK));

        if (errorcode == E_JOR) {

                strcpy(messT, msgstring);
                sprintf(msgstring, messT, (long) CondJmpDist);
        }

        fprintf(l, __NMSG_TEXT(ER_STR), file, line,
                warnCode > 0 ? "warning" : "error",
                mpWarnCode[warnCode], (SHORT)(errorcode - 1),
                msgstring, errstring);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmerrtb.c ===
/* asmerrtb.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmmsg.h"

/*  error message table - on 8086 it is in a far segment  */

char FAR *messages[E_MAX] = { NULL, };
short FAR msgnum[] = { /* this table must be in the same order as the
        error codes in asm86.h */
        0,
        ER_BNE,
        ER_ECL,
        ER_RAD,
        ER_UST,
        ER_RSY,
        ER_SMD,
        ER_PHE,
        ER_ELS,
        ER_NCB,
        ER_SND,
        ER_SYN,
        ER_TIL,
        ER_NGR,
        ER_PS1,
        ER_TUL,
        ER_SDK,
        ER_RES,
        ER_IFR,
        ER_MBR,
        ER_WRT,
        ER_MSG,
        0,
        ER_MSY,
        ER_ALD,
        ER_SPC,
        ER_NPA,
        ER_RMD,
        ER_OPN,
        ER_OPR,
        ER_DV0,
        ER_SCN,
        ER_OMM,
        ER_IUE,
        0,
        ER_RRF,
        ER_OHS,
        ER_NOP,
        0,
        ER_LOS,
        ER_OOC,
        ER_OSA,
        0,
        ER_CXP,
        ER_OSG,
        ER_ASD,
        ER_ASC,
        ER_DBR,
        ER_DIR,
        ER_IBR,
        ER_IUR,
        ER_VOR,
        ER_NIP,
        ER_IOT,
        ER_JOR,
        0,
        ER_IRV,
        ER_NIM,
        ER_IIS,
        ER_BRI,
        ER_CSI,
        ER_AXL,
        ER_ISR,
        ER_NCS,
        ER_OCI,
        ER_JCD,
        ER_NSO,
        ER_OAP,
        ER_OES,
        ER_CRS,
        ER_MSB,
        ER_NEB,
        ER_FOF,
        ER_IDV,
        ER_SAE,
        ER_DTL,
        ER_UID,
        ER_MVD,
        ER_OIL,
        ER_DIS,
        ER_ODI,
        ER_FCO,
        0,
        0,
        ER_CEA,
        ER_7OE,
        ER_EOF,
        ER_ENS,
        ER_EP1,
        ER_EP2,
        ER_ERR,
        ER_ERE,
        ER_ERZ,
        ER_END,
        ER_ESD,
        ER_EBL,
        ER_ENB,
        ER_EID,
        ER_EDF,
        ER_OWL,
        ER_LTL,
        ER_IMP,
        ER_MDZ,
        ER_286,
        ER_AP2,
        ER_JSH,
        ER_EXP,
        ER_LNL,
        ER_NDN,
        ER_EMS,
        ER_MOP,
        ER_PAR,
        ER_NMC,
        ER_UEL,
        ER_CPU,
        ER_ONW,
        ER_ANW,
        ER_INC,
        ER_FPO1,
        ER_FPO2
        };

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmexpr.c ===
/* asmexpr.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <ctype.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmexpr.h"
#include "asmmsg.h"

extern UCHAR opprec [];
extern char fValidSym, addplusflagCur;



/***	endstring - check for end of string
 *
 *	flag = endstring ();
 *
 *	Entry	delim = string delimiter character
 *	Exit	none
 *	Returns TRUE if at end of string
 *		FALSE if not at end of string
 *	Calls	error
 *	Note	Double occurances of delimiter character are returned as a
 *		single occurance of the delimiter character.
 */

UCHAR PASCAL CODESIZE
endstring ()
{
	register UCHAR cc;

	if ((cc = PEEKC ()) == 0) {
		/* End of line before delim */
		errorc (E_UEL);
		return (TRUE);
	}
	else if (cc == delim) {
		/* check for escaped quote character */
		SKIPC ();
		if ((cc = PEEKC ()) != delim) {
			BACKC ();
			return (TRUE);
		}
	}
	return (FALSE);
}


/***	oblititem - release parse stack record
 *
 *	oblititem (arg);
 *
 *	Entry	*arg = parse stack record
 *	Exit	parse stack record released
 *	Returns none
 *	Calls	free
 */

VOID PASCAL CODESIZE
oblititem (
	register DSCREC *arg
){
	register char c;

	if ((c = arg->itype) == ENDEXPR || c == OPERATOR || c == OPERAND)
		dfree( (UCHAR *)arg );
}


/***	flteval - Look at ST | ST(i) and create entry
 *
 *	flteval ();
 *
 *	Entry	*ptr = parse stack entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
flteval ()
{
	*itemptr = emptydsc;
	/* ST means ST(0) */
	/* We are 8087 stack */
	itemptr->dsckind.opnd.dtype = M_RCONST | M_FLTSTACK;
	/* Need + if ST(i) */
	addplusflagCur = (PEEKC () == '(');
}


/***	createitem - make item entry
 *
 *	createitem (itemkind, itemsub, p);
 *
 *	Entry	itemkind = kind of item
 *		itemsub =
 *		*p = activation record
 *	Exit
 *	Returns
 *	Calls
 *	Note	If symbol, look further to see if EQU, record name
 *		and do appropriate thing.
 */

VOID PASCAL CODESIZE
createitem (
	UCHAR	itemkind,
	UCHAR	itemsub
){
	register struct psop *pso;	 /* parse stack operand structure */

	switch (itemkind) {
	    case OPERAND:
		    /* Create default record */
		    itemptr = defaultdsc ();
		    pso = &(itemptr->dsckind.opnd);
		    switch (itemsub) {
			    case ICONST:
				    pso->doffset = val;
				    break;
			    case ISIZE:
#ifdef V386
				    pso->doffset = (long) (SHORT) varsize;
#else
				    pso->doffset = varsize;
#endif
				    pso->s++;	  /* note for expr evaluator */
				    break;
			    case IUNKNOWN:
				    pso->dflag = INDETER;
				    break;
			    case ISYM:
				    createsym ();
				    break;
		    }
		    break;
	    case OPERATOR:
		    itemptr = dalloc();
		    itemptr->dsckind.opr.oidx = opertype;
		    break;
	}
	/* Set type of entry */
	itemptr->itype = itemkind;
}


/***	numeric - evaluate numeric string
 *
 *	numeric (count, base, p);
 *
 *	Entry	count = number of characters in string
 *		base = conversion base
 *		*p = activation record
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
numeric (
	SHORT cnt,
	SHORT base
){
	register UCHAR t;
	register long temp = 0;
	OFFSET maxInt;

	maxInt = (fArth32)? OFFSETMAX: 0xffff;

	if (base > 10)
		for (; cnt; cnt--) {
			if ((t = MAP (NEXTC ()) - '0') > 9)
				t -= 'A' - '9' - 1;
			if (t >= base)
				errorc (E_NDN);
			if ((OFFSET)(temp = temp * base + t) > maxInt)
				errorc (E_DVZ);
		}
	else
		for (; cnt; cnt--) {
			if ((t = NEXTC () - '0') >= base)
				errorc (E_NDN);

			if ((OFFSET)(temp = temp * base + t) > maxInt)
				errorc (E_DVZ);
		}
	val = temp;
}


/***	evalconst - evaluate constant
 *
 *	type = evalconst (p);
 *
 *	Entry	*p = parser activation record
 *	Exit	numeric item added to parse stack entry
 *	Returns type of item added to parse stack
 *	Calls
 */

void PASCAL CODESIZE
evalconst ()
{
	register char cc;
	register SHORT i = 0;
	char *endscan, *begscan;
	SHORT rbase;

	begscan = lbufp;
	while (isxdigit (cc = PEEKC ())) {
		SKIPC ();
		i++;
	}
	switch (MAP (cc)) {
		case 'H':
			rbase = 16;
			SKIPC ();
			break;
		case 'O':
		case 'Q':
			rbase = 8;
			SKIPC ();
			break;
		default:
			BACKC ();
			switch (MAP (NEXTC ())) {
				case 'B':
					rbase = 2;
					i--;
					break;
				case 'D':
					rbase = 10;
					i--;
					break;
				default:
					if (cc == '.')
						errorcSYN ();
					if (radixescape)
						rbase = 10;
					else
						rbase = radix;
				break;
			}
		break;
	}
	endscan = lbufp;
	lbufp = begscan;
	numeric (i, rbase);
	lbufp = endscan;
}


/***	evalstring - evaluate quoted string
 *
 *	type = evalstring ();
 *
 *	Entry
 *	Exit	new item added to parse stack
 *	Returns type of item added to stack
 *	Calls
 */

char	PASCAL CODESIZE
evalstring ()
{
	register USHORT  i, max;

	max = 2;
	if (cputype & P386)
	    max += 2;

	delim = NEXTC ();	/* Set delim for string */
	i = 0;
	val = 0;
	while (!endstring () && i <= max) {

		val = (val << 8) + ((UCHAR)NEXTC ());
		i++;
	}
	if (i == 0)
		errorc (E_EMS);

	else if (i > max) {	    /* Too long */
		while (!endstring ())
			SKIPC ();
		errorcSYN ();
	}
	if (PEEKC () == delim)
	    SKIPC ();

	createitem (OPERAND, ICONST);
	return (OPERAND);
}


/***	getitem - get next item on line
 *
 *	getitem (p);
 *
 *	Entry	*p = activation record
 *	Exit	*itemptr = description of item
 *	Returns
 *	Calls
 */

char	PASCAL CODESIZE
getitem (
	struct ar	*p
){
	register char cc;
#ifdef FIXCOMPILERBUG
	char cc1;
#endif

	if (fValidSym)
		return (evalalpha (p));

/* The compiler bug looses the correct value for cc when optimization is
   turned on. This in turn caused an exception to occure near getitem+1C0.
   The bogus code below sidesteps the problem. */
#ifdef FIXCOMPILERBUG  // This was put in to get around a MIPS compiler bug(12/3/90)
	cc1 = skipblanks();
	if (ISTERM (cc1))
		return (ENDEXPR);
	cc = cc1;
#else
	if (ISTERM (cc = skipblanks()))
		return (ENDEXPR);
#endif
	if (LEGAL1ST (cc))
		return (evalalpha (p));

	/* token is not alpha string or .string (.TYPE) operator */

	if (ISOPER (cc)) {
		SKIPC ();
		switch (cc) {
			case '(':
				opertype = OPLPAR;
				break;
			case '+':
				opertype = OPPLUS;
				break;
			case '-':
				opertype = OPMINUS;
				break;
			case '*':
				opertype = OPMULT;
				break;
			case '/':
				opertype = OPDIV;
				break;
			case ')':
				opertype = OPRPAR;
				break;
			case '.':
				errorcSYN ();
				opertype = OPDOT;
				break;
			case ',':	/* should never get here, for density */
				break;
			default:
				if (cc == '[')
					opertype = OPLBRK;
				else if (cc == ']')
					opertype = OPRBRK;
				else if (cc == ':')
					opertype = OPCOLON;
				break;
		}
		operprec = opprec [opertype];
		createitem (OPERATOR, ISYM);
		return (OPERATOR);
	}
	else if (isdigit (cc)){

		evalconst ();
		createitem (OPERAND, ICONST);
		return (OPERAND);
	}

	else if ((cc == '"') || (cc == '\''))
		/* String may be made into constant if <=2 */
		return (evalstring ());
	else
		return (ENDEXPR);
}


/***	defaultdsc - create a default parse stack entry
 *
 *	ptr = defaultdsc ();
 *
 *	Entry	none
 *	Exit	none
 *	Returns *ptr = default parse stack entry
 *	Calls	malloc
 */

DSCREC * PASCAL CODESIZE
defaultdsc ()
{
	register DSCREC *valu;

	valu = dalloc();
	*valu = emptydsc;
	return (valu);
}


VOID PASCAL
makedefaultdsc ()
{
	register struct psop *p;      /* parse stack operand structure */

	emptydsc.itype = OPERAND;
	p = &emptydsc.dsckind.opnd;
	p->dtype = xltsymtoresult[REC];
	p->dflag = KNOWN;
	p->fixtype = FCONSTANT;
}


/***	checksegment - see if sreg is correct segment register for variable
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

char	PASCAL CODESIZE
checksegment (
	UCHAR	sreg,
	register struct	ar	 *p
){
	register SYMBOL FARSYM *segctx;
	register SYMBOL FARSYM *segptr;

	if (sreg != NOSEG) {	/* NOseg never found */

	    /* Current Sreg assume */
	    segctx = regsegment[sreg];

	    /* Assume looking for  left arg to : */
	    segptr = p->curresult->dsckind.opnd.dcontext;

	    if (!segptr)    /* If no :, use segment */
		segptr = p->curresult->dsckind.opnd.dsegment;

	    if (segptr && segctx) {

#ifndef FEATURE
		if (segctx == pFlatGroup)   /* flat space matchs all */
		    goto found;
#endif

		/* if same segorg or ptr is segment ... and Same group */

		if (segctx == segptr ||

		   (segptr->symkind == SEGMENT &&
		    segctx == segptr->symu.segmnt.grouptr)) {
found:
		    p->segovr = sreg;
		    p->curresult->dsckind.opnd.dcontext = segctx;

		    return (TRUE);
		}
	    }
	}
	return (FALSE);
}


/***	findsegment - find segment for variable
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
findsegment (
	UCHAR dseg,
	register struct ar	*p
){
	register struct psop *pso;	/* parse stack operand structure */

	pso = &(p->curresult->dsckind.opnd);
	if ((M_DATA & p->rstype) &&
	    (pso->dsegment || pso->dcontext) &&
	    p->linktype != FCONSTANT && pso->fixtype != FOFFSET && emittext) {
		/* Should find segment */
		if (!checksegment (dseg, p)) {
			/* If not in default */
			checksegment (CSSEG, p);
			checksegment (ESSEG, p);
			checksegment (SSSEG, p);
			checksegment (DSSEG, p);
#ifdef V386
			if (cputype&P386)
			{
				checksegment (FSSEG, p);
				checksegment (GSSEG, p);
			}
#endif
			if (p->segovr == NOSEG)
				/* If not found,UNKNOWN */
				p->segovr = NOSEG+1;
		}
	}
}


/***	exprop - process expression operator
 *
 *	exprop (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
exprop (
	register struct ar *p
){
	register struct dscrec *pTop = itemptr;

	p->curprec = (unsigned char)operprec;	    /* Get prec of new operator */

	if (!p->lastitem)	    /* start */
		pTop->prec = 0;
	else
		pTop->prec = p->lastitem->prec;

	switch (pTop->dsckind.opr.oidx) {

	    case OPRPAR:

		if (--p->parenlevel >= 0)
		    break;

		/* Unmatched right paren is from count dup (xx) */

		p->parenlevel = 0;
		BACKC ();
		dfree((char *)pTop);
		p->exprdone = TRUE;
		return;

	    case OPRBRK:
		if (--p->bracklevel >= 0)
		    break;

		p->exprdone = TRUE;
		return;

	    case OPLPAR:
		 p->parenlevel++;
		 goto leftComm;

	    case OPLBRK:

		 p->bracklevel++;
leftComm:
		/* See if could have no oper in which case kludge + */

		if ((p->lastitem || p->addplusflag) &&
		     p->lastitem->itype != OPERATOR) {

		    /* make + OPERATOR */
		    opertype = OPPLUS;
		    createitem (OPERATOR, ISYM);

		    p->bracklevel--;
		    exprop(p);
		    p->bracklevel++;
		    p->lastprec = 6;
		}
		break;

	    default:
		pTop->prec = p->curprec;
		break;
	}
	p->unaryflag = FALSE;

	if (pTop->dsckind.opr.oidx == OPPLUS ||
	    pTop->dsckind.opr.oidx == OPMINUS) {

	    if (!p->lastitem)
		p->unaryflag = TRUE;

	    else if (p->lastitem->itype == OPERATOR)

		p->unaryflag = !(p->lastitem->dsckind.opr.oidx == OPRPAR ||
				 p->lastitem->dsckind.opr.oidx == OPRBRK);
	}

	if (p->unaryflag ||
	   (p->curprec > p->lastprec &&
	    !(pTop->dsckind.opr.oidx == OPRPAR ||
	      pTop->dsckind.opr.oidx == OPRBRK))) {

	    /* Push OPERATOR */

	    pTop->previtem = p->lastitem;
	    p->lastitem = pTop;

	    if (p->unaryflag) {

		if (pTop->dsckind.opr.oidx == OPPLUS)

		    pTop->dsckind.opr.oidx = OPUNPLUS;
		else
		    pTop->dsckind.opr.oidx = OPUNMINUS;

		pTop->prec = p->lastprec;
		p->lastprec = 10;
	    }
	    else
		p->lastprec = p->curprec;

	    if (pTop->dsckind.opr.oidx == OPLPAR ||
		pTop->dsckind.opr.oidx == OPLBRK)

		p->lastprec = 0;
	}
	else	/* Evaluate top OPERATOR */

	    evaluate (p);
}


/***	forceimmed - generate error if value is not immediate
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
forceimmed (
	register DSCREC	*dsc
){
	if (dsc->dsckind.opnd.mode != 4)
		/* Must be constant */
		errorc (E_CXP);
}


/***	exprconst - check for constant expression
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

OFFSET PASCAL CODESIZE
exprconst ()
{
	char sign;
	register OFFSET  ret;

	ret = exprsmag(&sign);

	if (sign) {

	    /* change to simple unary minus
	     * pso->doffset = 65535 - ret + 1; */

	     ret = -(long)ret;

	     if (!fArth32)
		ret &= 0xffff;
	}

	return (ret);
}


/***	exprsmag - evaluate constant expression and return sign/magnitude
 *
 *	ushort = exprsmag (sign, magnitude);
 *
 *	Entry	none
 *	Exit	sign = TRUE if sign of result is set
 *		magnitude = magnitude of result
 *	Returns 16 bit integer result
 *	Calls	expreval
 */

OFFSET PASCAL CODESIZE
exprsmag (
	char *sign
){
	register struct psop *pso;	/* parse stack operand structure */
	register OFFSET  ret;
	DSCREC	*dsc;

	dsc = expreval (&nilseg);
	forceimmed (dsc);
	pso = &(dsc->dsckind.opnd);
	*sign = pso->dsign;
	ret = pso->doffset;

	dfree ((char *)dsc );
	return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmfcn.h ===
/* asmfcn.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

// Included here because allocs are mapped depending on target
#include <malloc.h>

#ifndef DECLSPEC_NORETURN 
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif


#ifdef FCNDEF

 #define PARMS(p)    p
#else
 #define PARMS(p)           /* no argument checking */

#endif

// UCHAR *strncpy PARMS((UCHAR *, UCHAR *, int));
// UCHAR *strcat PARMS((UCHAR *, UCHAR *));
// UCHAR *strdup PARMS((UCHAR *));
// UCHAR *strcpy PARMS((UCHAR *, UCHAR *));
// int     strcmp PARMS((UCHAR *, UCHAR *));
// int     strlen PARMS((UCHAR *));

// UCHAR *malloc PARMS(( size_t) );
// UCHAR *calloc PARMS(( USHORT, USHORT) );
// VOID  free PARMS(( UCHAR *) );
// UCHAR *realloc PARMS(( UCHAR *, USHORT) );

UCHAR FAR * PASCAL CODESIZE talloc PARMS(( USHORT) );
DSCREC * PASCAL CODESIZE    dalloc PARMS((void));
VOID PASCAL CODESIZE macroexpand PARMS((struct MC_s *));
char * PASCAL CODESIZE passatom PARMS((char *));
char * PASCAL CODESIZE radixconvert PARMS(( OFFSET, char *));
char * PASCAL CODESIZE xxradixconvert PARMS(( OFFSET, char *));
VOID   PASCAL CODESIZE readfile PARMS(( void) );
char * PASCAL CODESIZE scanvalue PARMS((char *));
char * PASCAL CODESIZE storetrans PARMS((UCHAR, char *, char *));
VOID PASCAL CODESIZE addLocal PARMS ((SYMBOL FARSYM *));
UCHAR PASCAL CODESIZE argblank PARMS(( void) );
VOID  PASCAL CODESIZE buildFrame PARMS(( void) );
VOID PASCAL CODESIZE  catstring PARMS(( void ));
UCHAR PASCAL CODESIZE checkendm PARMS(( void) );
UCHAR PASCAL CODESIZE checkline PARMS(( UCHAR) );
VOID PASCAL CODESIZE  commDefine PARMS(( void ));
UCHAR PASCAL CODESIZE createequ PARMS(( UCHAR));
VOID  PASCAL CODESIZE doLine PARMS((char *));
UCHAR PASCAL CODESIZE emitcleanq PARMS(( UCHAR) );
UCHAR PASCAL CODESIZE emitdup PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE emit66 PARMS ((struct psop *,struct psop *));
VOID  PASCAL          emit67 PARMS ((struct psop *,struct psop *));
char PASCAL           emitroomfor PARMS((UCHAR));
VOID PASCAL CODESIZE  endCurSeg PARMS(( void) );
UCHAR PASCAL CODESIZE endstring PARMS(( void) );
void PASCAL CODESIZE  evalconst PARMS((void));
char PASCAL CODESIZE  evalstring PARMS((void));
UCHAR PASCAL CODESIZE fixroom PARMS(( UCHAR) );
char CODESIZE         inset PARMS((char, char *));
char PASCAL CODESIZE  opcodesearch PARMS((void));
SHORT PASCAL CODESIZE  shortrange PARMS((struct parsrec *));
char PASCAL CODESIZE  symsearch PARMS((void));
char        CODESIZE  symsrch PARMS((void));
UCHAR PASCAL CODESIZE testlist PARMS(( void) );
UCHAR PASCAL CODESIZE test4TM PARMS(( void) );
VOID PASCAL CODESIZE addglist PARMS(( void) );
VOID PASCAL CODESIZE addseglist PARMS((SYMBOL FARSYM *));
USHORT PASCAL CODESIZE argscan PARMS(( UCHAR *));
SHORT PASCAL           assignlinknum PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE assignvalue PARMS(( void) );
VOID  PASCAL CODESIZE assumeitem PARMS(( void) );
VOID  PASCAL          bcddigit PARMS((struct realrec *));
VOID  PASCAL          bcdeval PARMS((struct realrec *));
VOID  PASCAL CODESIZE begdupdisplay PARMS((struct duprec FARSYM *));
VOID  PASCAL          bumpline PARMS(( void) );
VOID  PASCAL CODESIZE  byteimmcheck PARMS((struct psop *));
VOID  PASCAL CODESIZE  checkmatch PARMS((DSCREC *, DSCREC *));
SHORT PASCAL CODESIZE  checkRes PARMS((void));
SHORT PASCAL CODESIZE  checksize PARMS((struct parsrec *));
VOID  PASCAL CODESIZE emitnop PARMS((void));
VOID  PASCAL CODESIZE chkheading PARMS(( USHORT) );
VOID  PASCAL closeOpenFiles PARMS(( void ) );
VOID  PASCAL CODESIZE comdir PARMS(( void) );
VOID  PASCAL CODESIZE commentbuild PARMS(( void) );
VOID  PASCAL CODESIZE conddir PARMS(( void) );
VOID  PASCAL CODESIZE copyascii PARMS(( void) );
VOID  PASCAL CODESIZE copystring PARMS((char *));
VOID PASCAL CODESIZE copytext PARMS((char *));
VOID  PASCAL CODESIZE createitem PARMS(( UCHAR, UCHAR));
VOID PASCAL CODESIZE createMC PARMS(( USHORT) );
VOID  PASCAL CODESIZE createsym PARMS((void));
VOID  PASCAL CODESIZE createStack PARMS(( void) );
VOID  PASCAL          crefdef PARMS(( void) );
VOID  PASCAL          crefline PARMS(( void) );
VOID  PASCAL          crefnew PARMS(( UCHAR) );
VOID  PASCAL          crefout PARMS(( void) );
VOID  PASCAL CODESIZE datacon PARMS((struct dsr *));
VOID  PASCAL CODESIZE datadb PARMS((struct dsr *));
VOID  PASCAL CODESIZE datadefine PARMS(( void) );
VOID  PASCAL CODESIZE dataitem PARMS((struct datarec *));
VOID  PASCAL          definesym PARMS(( UCHAR *) );
VOID  PASCAL          defwordsize PARMS( (void) );
VOID  PASCAL CODESIZE defineLocals PARMS(( void) );
VOID  PASCAL CODESIZE deletemacro PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE dfree PARMS((UCHAR *));
VOID  PASCAL          dispdatasize PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE displength PARMS(( OFFSET) );
VOID  PASCAL CODESIZE displlong PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE dispstandard PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE dispsym PARMS(( USHORT, SYMBOL FARSYM *));
VOID  PASCAL CODESIZE disptab PARMS(( void) );
VOID  PASCAL CODESIZE dispword PARMS((OFFSET ));
VOID  PASCAL          dopass PARMS(( void) );
VOID  PASCAL          dumpname PARMS((void));
VOID  PASCAL          dumpCodeview PARMS(( void ));
VOID  PASCAL CODESIZE dupdisplay PARMS((struct duprec FARSYM *));
VOID  CODESIZE        ebuffer PARMS(( USHORT, UCHAR *, UCHAR *));
VOID  PASCAL CODESIZE edupitem PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE elsedir PARMS(( void) );
VOID  PASCAL CODESIZE emitOP PARMS((struct psop *));
VOID PASCAL CODESIZE emitcall PARMS((UCHAR, UCHAR, UCHAR, UCHAR, struct parsrec *));
VOID PASCAL CODESIZE emitcbyte PARMS(( UCHAR) );
VOID PASCAL CODESIZE emitcword PARMS(( OFFSET) );
VOID PASCAL          emitEndPass1 PARMS((void));
VOID PASCAL          emitdone PARMS((DSCREC *));
VOID PASCAL CODESIZE emitdumpdata PARMS(( UCHAR) );
VOID PASCAL CODESIZE emitescape PARMS((DSCREC *, UCHAR));
VOID PASCAL CODESIZE emitextern PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitfixup PARMS((struct psop *));
VOID PASCAL CODESIZE emitfltfix PARMS(( USHORT, USHORT, USHORT *));
VOID PASCAL CODESIZE emitgetspec PARMS((SYMBOL FARSYM * *, SYMBOL FARSYM * *, struct psop *));
VOID PASCAL CODESIZE emitglobal PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitgroup PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitlong PARMS((struct duprec FARSYM *));
VOID PASCAL CODESIZE emitlname PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitline PARMS((void));
VOID PASCAL CODESIZE emitmodrm PARMS(( USHORT, USHORT, USHORT) );
VOID PASCAL CODESIZE emitmove PARMS((UCHAR, char, struct parsrec *));
VOID PASCAL CODESIZE emitname PARMS((NAME FAR *));
VOID PASCAL CODESIZE emitobject PARMS((struct psop *));
VOID PASCAL CODESIZE emitopcode PARMS((UCHAR));
VOID PASCAL CODESIZE emitrest PARMS((DSCREC *));
VOID PASCAL CODESIZE emitsegment PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitsetrecordtype PARMS(( UCHAR) );
VOID PASCAL CODESIZE emitsindex PARMS(( USHORT) );
VOID PASCAL CODESIZE emitsize PARMS((USHORT));
VOID PASCAL CODESIZE emitsword PARMS(( USHORT) );
VOID PASCAL CODESIZE emitSymbol PARMS((SYMBOL FARSYM *));
VOID PASCAL          makedefaultdsc PARMS(( void) );
VOID PASCAL CODESIZE emodule PARMS((NAME FAR *));
VOID PASCAL CODESIZE enddir PARMS(( void) );
VOID PASCAL CODESIZE enddupdisplay PARMS(( void) );
VOID PASCAL CODESIZE endifdir PARMS(( void) );
VOID PASCAL CODESIZE equdefine PARMS(( void) );
VOID PASCAL CODESIZE equtext PARMS((USHORT));
VOID PASCAL CODESIZE error PARMS(( USHORT, UCHAR *) );

DECLSPEC_NORETURN
VOID PASCAL CODESIZE errorc PARMS(( USHORT) );
VOID PASCAL CODESIZE errorcSYN PARMS(( void) );
VOID PASCAL CODESIZE errorn PARMS(( USHORT) );
VOID PASCAL          error_line PARMS((struct _iobuf *, UCHAR *, short) );
VOID PASCAL          errordisplay PARMS(( void) );
VOID PASCAL CODESIZE errorforward PARMS((DSCREC *));
VOID PASCAL CODESIZE errorimmed PARMS((DSCREC *));
VOID PASCAL CODESIZE errorover PARMS((char));
VOID PASCAL CODESIZE errorsegreg PARMS((DSCREC *));
VOID PASCAL CODESIZE evaltop PARMS((struct evalrec *));
VOID PASCAL CODESIZE errdir PARMS(( void) );
VOID PASCAL CODESIZE evendir PARMS(( SHORT) );
VOID PASCAL CODESIZE exitmdir PARMS(( void) );
VOID        CODESIZE expandTM PARMS((char *));
VOID PASCAL CODESIZE externflag PARMS(( UCHAR, UCHAR) );
VOID PASCAL CODESIZE externitem PARMS(( void) );
VOID PASCAL          ferrorc PARMS (( USHORT ));
VOID PASCAL CODESIZE fltmodrm PARMS(( USHORT, struct fltrec *));
VOID PASCAL CODESIZE fltopcode PARMS(( void) );
VOID PASCAL CODESIZE fltscan PARMS((struct fltrec *));
VOID PASCAL CODESIZE fltwait PARMS(( UCHAR) );
VOID PASCAL CODESIZE flushbuffer PARMS(( void) );
VOID PASCAL CODESIZE flushfixup PARMS(( void) );
SHORT PASCAL CODESIZE  fndir PARMS((void));
SHORT PASCAL CODESIZE  fndir2 PARMS((void));
SHORT PASCAL CODESIZE  fnoper PARMS((void));
SHORT PASCAL CODESIZE  fnPtr PARMS((SHORT));
SHORT PASCAL CODESIZE  fnsize PARMS((void));
SHORT PASCAL CODESIZE  fnspar PARMS((void));
VOID PASCAL CODESIZE foldsigns PARMS((struct exprec *));
VOID PASCAL CODESIZE forceaccum PARMS((DSCREC *));
VOID PASCAL CODESIZE forceimmed PARMS((DSCREC *));
VOID        CODESIZE fMemcpy PARMS((void FAR *, void FAR *, SHORT));
VOID  PASCAL CODESIZE  forcesize PARMS((DSCREC *));
int PASCAL CODESIZE freeAFileHandle PARMS( (void) );
VOID PASCAL CODESIZE getinvenv PARMS(( void) );
char * PASCAL CODESIZE getTMstring PARMS ((void));
SHORT PASCAL           getprec PARMS((char));
VOID PASCAL CODESIZE groupdefine PARMS(( void) );
VOID PASCAL CODESIZE groupitem PARMS(( void) );
VOID PASCAL CODESIZE idxcheck PARMS(( UCHAR, struct exprec *));
VOID PASCAL CODESIZE includeLib PARMS(( void) );
VOID PASCAL CODESIZE includedir PARMS(( void) );
VOID PASCAL          initproc PARMS(( void) );
VOID PASCAL CODESIZE initrs PARMS((struct dsr *));
VOID PASCAL CODESIZE instring PARMS((void));
VOID PASCAL CODESIZE irpcopy PARMS(( void) );
VOID PASCAL CODESIZE irpxbuild PARMS(( void) );
VOID PASCAL CODESIZE irpxdir PARMS(( void) );
VOID  PASCAL CODESIZE itemdisplay PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE  labelcreate PARMS((USHORT, char));
SHORT CODESIZE         langFet PARMS(( void));
VOID       CODESIZE  lineExpand PARMS((struct MC_s *, char FAR *));
VOID PASCAL CODESIZE linkfield PARMS((struct duprec FARSYM *));
VOID PASCAL CODESIZE listfree PARMS((TEXTSTR FAR *));
VOID PASCAL          listline PARMS(( void) );
VOID PASCAL          listopen PARMS(( void) );
VOID CODESIZE lineprocess PARMS(( char, MC *));
VOID PASCAL          longeval PARMS(( USHORT, struct realrec *) );
VOID PASCAL CODESIZE macrobuild PARMS(( void) );
VOID PASCAL CODESIZE macrocall PARMS(( void) );
VOID PASCAL CODESIZE macrodefine PARMS(( void) );
SHORT PASCAL          macrolist PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE makeGrpRel PARMS((struct psop *));
VOID                 main PARMS(( int, char **) );
VOID PASCAL CODESIZE model PARMS(( void) );
VOID PASCAL CODESIZE mapFixup PARMS((struct psop *));
VOID PASCAL CODESIZE moveaccum PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE movecreg PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE movereg PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE movesegreg PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE muldef PARMS((void));
VOID PASCAL CODESIZE namedir PARMS(( void) );
VOID PASCAL          newpage PARMS(( void) );
VOID PASCAL CODESIZE numeric PARMS((SHORT, SHORT));
SHORT PASCAL           oblitdata PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE oblitdup PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE oblititem PARMS((DSCREC *));
SHORT PASCAL CODESIZE  opcode PARMS((void));
VOID  PASCAL CODESIZE opdisplay PARMS(( UCHAR) );
VOID  PASCAL CODESIZE openSeg PARMS(( void) );
VOID  PASCAL CODESIZE orgdir PARMS(( void) );
VOID  PASCAL CODESIZE outdir PARMS(( void) );
VOID  PASCAL          pageheader PARMS(( void) );
VOID  PASCAL CODESIZE deleteMC PARMS((struct MC_s *));
VOID  PASCAL CODESIZE  parith PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  parpl PARMS((struct parsrec *));
SHORT PASCAL  CODESIZE firstDirect PARMS((void));
VOID  PASCAL CODESIZE secondDirect PARMS((void));
VOID  PASCAL CODESIZE parselong PARMS((struct dsr *));
VOID  PASCAL CODESIZE parse PARMS((void));
VOID  PASCAL CODESIZE  parsl PARMS((struct parsrec *));
struct BCB * FAR     PASCAL pBCBalloc PARMS((USHORT));
VOID  PASCAL CODESIZE  pbound PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pcdisplay PARMS(( void) );
VOID  PASCAL CODESIZE  pclts PARMS((void));
VOID  PASCAL CODESIZE  pdescrtbl PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pdttrsw PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  penter PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pesc PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pgenarg PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pincdec PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pinout PARMS((struct parsrec *));
VOID PASCAL CODESIZE pint PARMS((struct parsrec *));
SHORT PASCAL CODESIZE  pSHORT PARMS((struct parsrec *));
VOID PASCAL CODESIZE pjump PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pload PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pmov PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pnoargs PARMS((void));
VOID  PASCAL CODESIZE preljmp PARMS((struct parsrec *));
VOID  PASCAL CODESIZE prepeat PARMS((struct parsrec *));
VOID  PASCAL CODESIZE preturn PARMS((struct parsrec *));
VOID PASCAL CODESIZE procdefine PARMS((void));
SHORT PASCAL CODESIZE procend PARMS((void));
VOID  PASCAL CODESIZE pshift PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pstack PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pstr PARMS((struct parsrec *));
VOID  PASCAL CODESIZE ptends PARMS((void));
VOID  PASCAL CODESIZE publicitem PARMS(( void) );
VOID  PASCAL CODESIZE purgemacro PARMS(( void) );
VOID  PASCAL CODESIZE pushpar PARMS((struct evalrec *));
VOID  PASCAL CODESIZE  pver PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pxchg PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pxlat PARMS((struct parsrec *));
VOID PASCAL CODESIZE radixdir PARMS(( void) );
VOID PASCAL CODESIZE rangecheck PARMS((USHORT *, UCHAR));
VOID PASCAL CODESIZE valuecheck PARMS((OFFSET *, USHORT));
VOID PASCAL          realeval PARMS((struct realrec *));
VOID  PASCAL CODESIZE  recorddefine PARMS((void));
VOID  PASCAL CODESIZE  recordinit PARMS((void));
VOID  PASCAL CODESIZE reptdir PARMS(( void) );
VOID  PASCAL CODESIZE resetobjidx PARMS(( void) );
SHORT PASCAL CODESIZE scanatom PARMS( (char) );
SHORT PASCAL CODESIZE scanArgs PARMS(( void) );
VOID  PASCAL CODESIZE scandummy PARMS(( void) );
VOID  PASCAL CODESIZE scandup PARMS((struct duprec FARSYM *, VOID (PASCAL CODESIZE *)(struct duprec FARSYM *)));
SHORT PASCAL           scanextern PARMS((SYMBOL FARSYM *));
SHORT PASCAL           scangroup PARMS((SYMBOL FARSYM *));
SHORT PASCAL           scanglobal PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE scanlist PARMS((struct duprec FARSYM *, VOID (PASCAL CODESIZE *)(struct duprec FARSYM *)));
VOID  PASCAL           scanorder PARMS((SYMBOL FARSYM *, SHORT (PASCAL *)(SYMBOL FARSYM *)));
VOID  PASCAL           scanSorted PARMS((SYMBOL FARSYM *, SHORT (PASCAL *)(SYMBOL FARSYM *)));
VOID  PASCAL CODESIZE scanparam PARMS(( UCHAR) );
VOID  PASCAL          scansegment PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE scanstruc PARMS((struct duprec FARSYM *, VOID (PASCAL CODESIZE *)(struct duprec FARSYM *)));
VOID  PASCAL          scansymbols PARMS((SHORT (PASCAL *)(SYMBOL FARSYM *)));
VOID  PASCAL CODESIZE segalign PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE segclass PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE segcreate PARMS(( UCHAR) );
VOID  PASCAL CODESIZE segdefine PARMS(( void) );
VOID  PASCAL CODESIZE segdisplay PARMS(( USHORT, SYMBOL FARSYM *));
VOID  PASCAL          seglist PARMS((void));
VOID  PASCAL CODESIZE setpage PARMS((void));
VOID  PASCAL CODESIZE setsegment PARMS(( void) );
VOID  PASCAL CODESIZE setsymbol PARMS(( UCHAR) );
SHORT PASCAL          settext PARMS((void));
VOID  PASCAL          showresults PARMS((struct _iobuf *, char, char *) );
VOID  PASCAL CODESIZE signadjust PARMS(( UCHAR, struct exprec *));
VOID  PASCAL CODESIZE sizestring PARMS((void ));
UCHAR        CODESIZE skipblanks PARMS(( void) );
VOID  PASCAL CODESIZE skipline PARMS(( void) );
SHORT PASCAL          sortalpha PARMS((SYMBOL FARSYM *));
SHORT PASCAL          sortsymbols PARMS((void));
VOID                 storeline  PARMS((void));
VOID                 storelinepb PARMS((void));
VOID PASCAL          storetitle PARMS((char *));
SHORT                strffcmp PARMS((char FAR *, char FAR *));
USHORT PASCAL          strflen PARMS((char FAR *));
SHORT PASCAL CODESIZE  strfncpy PARMS((char FAR *, char *));
SHORT CODESIZE         strnfcmp PARMS((char *, char FAR *));
VOID  PASCAL           strnfcpy PARMS((char *, char FAR *));
VOID  PASCAL CODESIZE strucbuild PARMS((void));
VOID  PASCAL CODESIZE  strucdefine PARMS((void));
VOID  PASCAL CODESIZE  strucfill PARMS((void));
VOID  PASCAL CODESIZE  strucinit PARMS((void));
SHORT PASCAL          struclist PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE subr1 PARMS((struct dsr *));
VOID PASCAL CODESIZE substituteTMs PARMS((void));
VOID PASCAL CODESIZE  substring PARMS((void));
VOID CODESIZE         switchname PARMS((void));
VOID PASCAL           symbollist PARMS((void));
VOID PASCAL CODESIZE  symcreate PARMS((UCHAR, char));
char PASCAL CODESIZE  symFet PARMS((void));
char PASCAL CODESIZE  symFetNoXref PARMS((void));
VOID PASCAL CODESIZE  tfree PARMS((UCHAR FAR *, UINT) );
VOID                  terminate PARMS((SHORT, char *, char *, char * ));
SHORT PASCAL CODESIZE tokenIS PARMS ((char *));
int PASCAL CODESIZE   tryOneFile PARMS((UCHAR *));
SHORT PASCAL CODESIZE typeFet PARMS( (USHORT) );
SHORT PASCAL          pfree PARMS((char FAR *));
VOID                  UserInterface ( int, char **, char * );
VOID  PASCAL CODESIZE valcheck PARMS(( UCHAR, UCHAR, struct exprec *));
VOID  PASCAL CODESIZE valconst PARMS((DSCREC *));
VOID  PASCAL          offsetAscii PARMS(( OFFSET ));
SHORT PASCAL           writeobj PARMS((UCHAR));
VOID  PASCAL CODESIZE xchgaccum PARMS((char, struct parsrec *));
VOID  PASCAL CODESIZE xchgreg PARMS((char, struct parsrec *));
VOID  PASCAL CODESIZE xcrefitem PARMS(( void) );
DSCREC * PASCAL CODESIZE defaultdsc PARMS(( void) );
DSCREC * PASCAL CODESIZE expreval PARMS((UCHAR *));
VOID     PASCAL CODESIZE flteval PARMS((void));
DSCREC * PASCAL CODESIZE regcheck PARMS((DSCREC *, UCHAR, struct exprec *));
struct duprec FARSYM * PASCAL CODESIZE createduprec PARMS((void));
struct duprec FARSYM * PASCAL CODESIZE datadup PARMS((struct dsr *));
struct duprec FARSYM * PASCAL CODESIZE datascan PARMS((struct datarec *));
struct duprec FARSYM * PASCAL CODESIZE nodecreate PARMS((void));
struct duprec FARSYM * PASCAL CODESIZE strucerror PARMS((SHORT, struct duprec FARSYM *));
struct duprec FARSYM * PASCAL CODESIZE strucparse PARMS((void));
UCHAR PASCAL CODESIZE  efixdat PARMS((SYMBOL FARSYM *, SYMBOL FARSYM *, OFFSET) );
OFFSET PASCAL CODESIZE calcsize PARMS((struct duprec FARSYM *));
OFFSET PASCAL CODESIZE checkvalue PARMS((SHORT, char, OFFSET));
OFFSET PASCAL CODESIZE exprconst PARMS(( void) );
OFFSET PASCAL CODESIZE exprsmag PARMS((char *));
OFFSET PASCAL CODESIZE recordparse PARMS((void));
USHORT PASCAL CODESIZE segdefault PARMS((char));
OFFSET PASCAL CODESIZE shiftoper PARMS((struct exprec *));
USHORT PASCAL CODESIZE valuesize PARMS((DSCREC *));

NAME FAR * PASCAL CODESIZE createname PARMS((char *));
NAME * PASCAL CODESIZE     creatlname PARMS((char *));

SYMBOL FARSYM * PASCAL CODESIZE chasealias PARMS((SYMBOL FARSYM *));

VOID init386(short);
USHORT CODESIZE isdirect(struct psop *);
VOID initregs(struct mreg *);

int PASCAL CODESIZE emitFpo ();
int PASCAL CODESIZE fpoRecord ();

# ifdef DEBUG
SHORT PASCAL hatoi PARMS((char *));
# endif

# ifdef XENIX286

VOID PASCAL nextarg PARMS((char *));
VOID PASCAL usage PARMS((SHORT));
# endif


# ifdef M8086
#  ifdef MSDOS

VOID farwrite PARMS((int, UCHAR FAR *, SHORT));

#  endif /* MSDOS */

// VOID _ffree PARMS(( UCHAR FAR *) );
// VOID _nfree PARMS(( UCHAR *) );
// extern UCHAR FAR * _fmalloc PARMS(( USHORT) );
// extern UCHAR *_nmalloc PARMS(( USHORT) );
// USHORT _freect PARMS(());
// USHORT _memavl PARMS((void));
SHORT CODESIZE getatom PARMS((void));
SHORT CODESIZE getatomend PARMS((void));
VOID CODESIZE getline PARMS((void));
VOID PASCAL outofmem PARMS((void));
UCHAR * CODESIZE PASCAL  nearalloc PARMS(( USHORT) );
UCHAR FAR * CODESIZE PASCAL faralloc PARMS(( USHORT) );

# else

SHORT PASCAL PASCAL outofmem PARMS((char *));
VOID PASCAL PASCAL scanatom PARMS(( char) );
UCHAR * CODESIZE PASCAL nearalloc PARMS(( USHORT, char *) );

# endif /* M8086 */

#if defined FLATMODEL
# define STRFNCPY(a,b)  strcpy((a),(b))
# define STRNFCPY(a,b)  strcpy((a),(b))
# define STRNFCMP(a,b)  strcmp((a),(b))
# define STRFFCMP(a,b)  strcmp((a),(b))
# define STRFLEN(a)     strlen(a)
# define memerror(a)    outofmem()
# define nalloc(a,b)    nearalloc(a)
# define falloc(a,b)    faralloc(a)
# define _fmalloc(a)    malloc(a)       /* _fmalloc doesn't exist in clib */
# define _ffree(a)      free(a)         /* _ffree doesn't exist in clib */
# define _fmemchr(a,b,c)  memchr((a),(b),(c)) /* _fmemchr doesn't exist in clib */
# define fMemcpy(a,b,c)  memcpy((a),(b),(c))  /* fMemcpy isn't needed */
#else
# define STRFNCPY(a,b)  strfncpy((a),(b))
# define STRNFCPY(a,b)  strnfcpy((a),(b))
# define STRNFCMP(a,b)  strnfcmp((a),(b))
# define STRFFCMP(a,b)  strffcmp((a),(b))
# define STRFLEN(a)     strflen(a)
# define memerror(a)    outofmem()
# define nalloc(a,b)    nearalloc(a)
# define falloc(a,b)    faralloc(a)
#endif

#ifndef M8086OPT
# define getatom()      scanatom(SCSKIP)
# define getatomend()   scanatom(SCEND)
#endif  /* M8086OPT */

#ifdef FLATMODEL

/* Map message functions */
# define __NMSG_TEXT NMsgText
# define __FMSG_TEXT FMsgText
UCHAR NEAR * PASCAL NMsgText( USHORT );
UCHAR FAR *  PASCAL FMsgText( USHORT );

#else

/* These two functions are internal C library functions */
/* They are also included in nmsghdr.c and fmsghdr.c for Xenix */
UCHAR NEAR * PASCAL __NMSG_TEXT( USHORT );
UCHAR FAR * PASCAL __FMSG_TEXT( USHORT );

#endif  /* FLATMODEL */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmflt.c ===
/* asmflt.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmopcod.h"

#define TOLOWER(c)	(c | 0x20)	/* works only for alpha inputs */


/* Handle 8087 opcodes, they have the following types:

	Fnoargs:	No arguments at all.
	F2memstk:	0-2 args; memory 4,8 byte | ST,ST(i) | ST(i),ST
			| blank( equiv ST )
	Fstks:		ST(i),ST
	Fmemstk:	memory 4,8 | ST | ST(i) | blank
	Fstk:		ST(i)
	Fmem42: 	memory 4,8 byte
	Fmem842:	memory 2,4,8 bytes
	Fmem4810	memory 4,8,10 bytes | ST(i)
	Fmem2:		memory 2 byte
	Fmem14: 	memory 14 bytes( don't force size )
	Fmem94: 	memory 94 bytes( don't force size )
	Fwait:		Noargs, output WAIT
	Fbcdmem:	memory Bcd
 */



/***	fltwait - output WAIT for 8087 instruction
 *
 *	fltwait (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
fltwait (
	UCHAR fseg
){
	register SHORT idx;
	char	override;
	register struct psop *pso;

	if (fltemulate) {
		idx = 0;
		/* Check for data and fixup space */
		if (pass2 && (emitcleanq ((UCHAR)(5)) || !fixroom (15)))
			emitdumpdata (0xA1); /* RN */
		if (opctype != FWAIT) {
			override = 0;
			if (fltdsc) {
				pso = &(fltdsc->dsckind.opnd);
				if ((idx = pso->seg) < NOSEG && idx != fseg)
					override = 1;
			}
			if (override)
				emitfltfix ('I',fltfixmisc[idx][0],&fltfixmisc[idx][1]);
			else
				emitfltfix ('I','D',&fltfixmisc[7][1]);
		}
		else {
			emitfltfix ('I','W', &fltfixmisc[8][1]);
			emitopcode(0x90);
		}
	}
	if (fltemulate || cputype&P86 || (cpu & FORCEWAIT)) {
		emitopcode (O_WAIT);
		if (fltemulate && override && idx)
			emitfltfix ('J',fltfixmisc[idx+3][0],&fltfixmisc[idx+3][1]);
	}
}


SHORT CODESIZE
if_fwait()
{
	/* if second byte of opcode is 'N', we don't generate fwait */

	return (TOLOWER(svname.pszName[1]) != 'n');
}



/***	fltmodrm - emit 8087 MODRM byte
 *
 *	fltmodrm (base, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note   The MODRM byte for 8087 opcode:
 *		M M b b b R / M
 *		M = mode, 3 is for non-memory 8087
 *		b = base opcode. Together with ESC gives 6 bit opcode
 *		R/M memory indexing type
 */


VOID PASCAL CODESIZE
fltmodrm (
	register USHORT	base,
	struct fltrec	  *p
){
	register USHORT mod;

	mod = modrm;
	if (!fltdsc) {

	    if (mod < 8)
		    mod <<= 3;

	    if (mod < 0xC0)
		    mod += 0xC0;
	    /* ST(i) mode */
	    emitopcode ((UCHAR)(mod + base + p->stknum));
	}
	else {

	   emitmodrm ((USHORT)fltdsc->dsckind.opnd.mode, (USHORT)(mod + base),
		      fltdsc->dsckind.opnd.rm);

	   emitrest (fltdsc);
	}
}




/***	fltscan - scan operands and build fltdsc
 *
 *	fltscan (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
fltscan (
	register struct fltrec	*p
){
	register struct psop *pso;

	p->args = FALSE;
	fltdsc = NULL;
	skipblanks ();
	if (ISTERM (PEEKC ())) {
		p->fseg = NOSEG;
		p->stknum = 1;
	}
	else {
		p->args = TRUE;
		p->fseg = DSSEG;
		fltdsc = expreval (&p->fseg);
		pso = &(fltdsc->dsckind.opnd);

		if (pso->mode == 3
		  && !(pso->rm == 0 && opcbase == O_FSTSW && modrm == R_FSTSW
		  && (cputype & (P286|P386))))
			errorc (E_IUR); /* Illegal use of reg */

		if (1 << FLTSTACK & pso->dtype) {
			/* Have ST or ST(i) */
			p->stknum = (USHORT)(pso->doffset & 7);
			if (pso->doffset > 7 || pso->dsign)
				/* # too big */
				errorc (E_VOR);
			if (pso->dsegment || pso->dcontext ||
			    pso->dflag == XTERNAL || pso->mode != 4)
				/* Must have a constant */
				errorc (E_CXP);
			/* This means ST(i) */
			pso->mode = 3;
			oblititem (fltdsc);
			fltdsc = NULL;
		}
		else if (pso->mode == 4){

		    /* pass1 error caused invalide mode assignment,
		       map immdiate to direct, error on pass 2 */

		    if (pass2)
			errorc(E_NIM);

		    pso->mode = 2;
		    if (wordsize == 4)
			pso->mode = 7;
		}

	}
}




/***	fltopcode - process 8087 opcode
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
fltopcode ()
{
	struct fltrec	a;
	USHORT	i;
	register struct psop *pso;

	/* Save opcode name */
	switchname ();
	a.stknum = 0;
	/* Scan 1st arg, if any */
	fltscan (&a);

	if (if_fwait() || (opcbase == O_FNOP && modrm == R_FNOP))
	    fltwait (a.fseg);

	if (fltdsc){
		pso = &(fltdsc->dsckind.opnd);
		emit67(pso, NULL);
	}

	switch (opctype) {
	    case FNOARGS:
		    /* No args allowed */
		    a.stknum = 0;
		    if (opcbase == O_FSETPM && modrm == R_FSETPM) {
			    if (!(cputype&PROT))
				    errorcSYN ();
		    }
		    /* Output escape byte */
		    emitopcode (opcbase);
		    fltmodrm (0, &a);
		    if (a.args)
			    /* Operands not allowed */
			    errorc (E_ECL);
		    break;
	    case FWAIT:
		    a.stknum = 0;
		    if (a.args)
			    /* Operands not allowed */
			    errorc (E_ECL);
		    break;
	    case FSTK:
		    if (TOLOWER(svname.pszName[1]) == 'f' && !a.args) /* ffree w/o arg */
			    errorc(E_MOP);
		    /* Output Escape */
		    emitopcode (opcbase);
		    /* Modrm byte */
		    fltmodrm (0, &a);
		    if (fltdsc)
			    /*Must be ST(i) */
			    errorc (E_IOT);
		    break;
	    case FMEM42:
	    case FMEM842:
	    case FMEM2:
	    case FMEM14:
	    case FMEM94:
	    case FBCDMEM:
		    /* All use a memory operand. Some force size */
		    if (fltemulate && !if_fwait())
			    /* Can't emulate */
			    errorc (E_7OE);
		    if (!fltdsc)
			    /* must have arg */
			    errorc (E_IOT);
		    else {
			emitescape (fltdsc, a.fseg);
			if (opctype == FMEM42) {
			    /* Integer 2,4 byte */
			    forcesize (fltdsc);
			    if (pso->dsize == 4)
				    /* 4 byte */
				    emitopcode (opcbase);
			    else {
				    emitopcode ((UCHAR)(opcbase + 4));
				    if (pso->dsize != 2)
					    errorc (E_IIS);
			    }
			}
			else if (opctype == FMEM842) {
			    /* Int 8,4,2 */
			    forcesize (fltdsc);
			    if (pso->dsize == 2 || pso->dsize == 8)
				    emitopcode ((UCHAR)(opcbase + 4));
			    else {
				    emitopcode (opcbase);
				    if (pso->dsize != 4)
					    errorc (E_IIS);
			    }
			}
			else if ((opctype == FMEM2) || (opctype == FBCDMEM)) {
			    if (opctype == FMEM2)
				if (pso->dsize != 2 && pso->dsize)
				    errorc (E_IIS);
				else {
				    if (cputype & (P286|P386) &&
					opcbase == O_FSTSW && modrm == R_FSTSW &&
					pso->mode == 3 && pso->rm == 0) {
					     opcbase = O_FSTSWAX;
					     modrm = R_FSTSWAX;
				    }
				}
			    else if (pso->dsize != 10 && pso->dsize )
				    errorc (E_IIS);
			    emitopcode (opcbase);
			}
			else
				emitopcode (opcbase);
			if ((pso->mode == 3 || pso->mode == 4) &&
			    (opcbase != O_FSTSWAX || modrm != R_FSTSWAX))
				/* Only memory operands */
				errorc (E_IOT);
			if (opctype == FMEM842 && pso->dsize == 8)
				if (TOLOWER(svname.pszName[2]) == 'l')
					fltmodrm (5, &a);
				else
					fltmodrm (4, &a);
			else
				fltmodrm (0, &a);
		    }
		    break;
	    case FSTKS:
		    if (!a.args)
			    /* Operand required */
			    errorc (E_MOP);
		    else if (fltdsc)
			    /* Must be stack */
			    errorc (E_IOT);
		    else {
			    /* ESC */
			    emitopcode (opcbase);
			    /* ST(i) */
			    fltmodrm (0, &a);
			    if (PEEKC () != ',')
				    error (E_EXP,"comma");
				    /* Must have 2 args */
			    /* Get 2nd operand */
			    SKIPC ();
			    fltscan (&a);
			    pso = NULL;
			    if (!a.args || fltdsc)
				    errorc (E_IOT);
			    if (a.stknum)
				    errorc (E_OCI);
		    }
		    break;
	    case FMEM4810:
		    /* Fwait */
		    if (TOLOWER(svname.pszName[1]) == 'l')
			/* FLD */
			if (!fltdsc) {/* Have ST(i) */
				if (!a.args) /* fld w/o arg */
					errorc(E_MOP);
				emitopcode (opcbase);
				fltmodrm (0, &a);
			}
			else {
				/* Any segment override */
				emitescape (fltdsc, a.fseg);
				if (pso->dsize == 10) {
					/* Have temp real */
					emitopcode ((UCHAR)(opcbase + 2));
					fltmodrm (5, &a);
				}
				else {
					/* Have normal real */
					forcesize (fltdsc);
					if (pso->dsize == 8)
						emitopcode ((UCHAR)(opcbase + 4));
					else {
						emitopcode (opcbase);
						if (pso->dsize != 4)
							errorc (E_IOT);
					}
					fltmodrm (0, &a);
				}
			}
		    else if (!fltdsc) {
			    /* Have ST(i) */
			    /* Have FSTP */
			    if (!a.args)
				    errorc( E_IOT );
			    emitopcode ((UCHAR)(opcbase + 4));
			    fltmodrm (0, &a);
		    }
		    else {
			    emitescape (fltdsc, a.fseg);
			    /* Any segment override */
			    if (pso->dsize == 10) {
				    /* Have temp real */
				    emitopcode( (UCHAR)(opcbase + 2) );
				    fltmodrm (4, &a);
			    }
			    else {
				    /* Have normal real */
				    forcesize (fltdsc);
				    if (pso->dsize == 8)
					    emitopcode( (UCHAR)(opcbase + 4) );
				    else
					    emitopcode (opcbase);
				    fltmodrm (0, &a);
			    }
		    }
		    break;
	    case F2MEMSTK:
		    if (!a.args) {
			    /* Have ST(1),ST */
			    emitopcode( (UCHAR)(opcbase + 6) );
			    if ((i = modrm & 7) > 3)
				    modrm = i^1;
			    fltmodrm (0, &a);
		    }
		    else if (!fltdsc) {/* Have stacks */
			    if (a.stknum == 0)
				    emitopcode (opcbase);
			    else {
				    /* Might need to reverse R bit */
				    if ((modrm & 7) > 3) /* Have FSUBx FDIVx */
					    modrm ^= 1;
				    emitopcode( (UCHAR)(opcbase + 4) );
				    /* D bit is set */
			    }
			    /* Save in case ST(i) */
			    a.stk1st = a.stknum;
			    if (PEEKC () != ',')
				    /* Must have , */
				    error (E_EXP,"comma");
			    /* Get 2nd operand */
			    SKIPC ();
			    fltscan (&a);
			    if (fltdsc)
				    /* not stack */
				    errorc (E_IOT);
			    if (a.args && a.stknum && a.stk1st)
				    errorc (E_IOT);
			    if (a.stk1st)
				    a.stknum = a.stk1st;
			    fltmodrm (0, &a);
		    }
		    else {  /* Have real memory */
			    forcesize (fltdsc);
			    emitescape (fltdsc, a.fseg);
			    if (pso->dsize == 8)
				    emitopcode( (UCHAR)(opcbase + 4) );
			    else {
				    emitopcode (opcbase);
				    if (pso->dsize != 4)
					    errorc (E_IIS);
			    }
			    fltmodrm (0, &a);
		    }
		    break;
	    case FMEMSTK:
		    if (!fltdsc)/* Have ST(i) */
			    if (TOLOWER(svname.pszName[1]) == 's') {
				    /* Special case */
				    if (!a.args)
					    errorc( E_IOT );
				    emitopcode( (UCHAR)(opcbase + 4) );
			    }
			    else
				    emitopcode (opcbase);
		    else {
			    /* Have real memory */
			    emitescape (fltdsc, a.fseg);
			    forcesize (fltdsc);
			    if (pso->dsize == 8)
				    emitopcode( (UCHAR)(opcbase + 4) );
			    else {
				    emitopcode (opcbase);
				    if (pso->dsize != 4)
					    errorc (E_IOT);
			    }
		    }
		    fltmodrm (0, &a);
		    break;
	}
	if (fltdsc)
		oblititem (fltdsc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmhelp.asm ===
title	asmhelp - assembler helpers
	page ,132

;--------------------------------------------------------------------
;
;	asmhelp 	fast assembly language helpers for masm
;
;	(C)Copyright 1985 Microsoft Corp.
;
;	Revision history
;
;	04/02/85	Greg Whitten
;			initial version
;				scanatom speedups
;
;--------------------------------------------------------------------

ifndef MSDOS
 ifndef CPDOS
	.286
 endif
endif
	.model medium,c

	if1

alignCode macro
	align 4
	endm

	.xlist
	include mixed.inc
	.list
	.lall

	endif

cLang	=	1
CASEL	=	1
SYMMAX	=	31
TSYMSIZE =	451		; from asmsym.c

LEGAL1ST	=	08h	; legal 1st token character mask
TOKLEGAL	=	10h	; legal token character mask

	.code A_TEXT

	extrn Pascal ERRORC:near
	extrn Pascal CREFNEW:far
	extrn Pascal CREFOUT:far
	extrn Pascal OFFSETASCII:far
	extrn Pascal listline:far
	extrn Pascal crefline:far
	extrn Pascal tryOneFile:far

	extrn _ffree:far

ifndef MSDOS
	extrn read:proc
	extrn write:proc
	extrn lseek:proc
	extrn free:proc
endif

ifdef CPDOS
	extrn	Pascal DosRead:far
	extrn	Pascal DosChgFilePtr:far
	extrn	Pascal DosWrite:far
endif
	.data

	extrn _asmctype_:byte
	extrn _asmcupper_:byte
	extrn _asmTokenMap_:byte
	extrn caseflag:byte
	extrn fCrefline:byte
	extrn fNeedList:byte
	extrn objing:byte
	extrn srceof:byte
	extrn crefing:byte
	extrn emitrecordtype:byte

	extrn linebp:word
	extrn linelength:byte
	extrn linebuffer:byte
	extrn linessrc:word
	extrn listconsole:byte
	extrn begatom:word
	extrn endatom:word
	extrn errorlineno:word
	extrn errorcode:word
	extrn oOMFCur:dword
	extrn handler:byte
	extrn lbufp:word
	extrn pass2:byte
	extrn save:byte
	extrn svname:word
	extrn obj:word
	extrn pFCBCur:word
	extrn naim:word
	extrn objerr:word
	extrn objectascii:word
	extrn iProcCur:word

	extrn symptr:dword
	extrn lsting:byte
	extrn lbuf:byte

ifdef BCBOPT
	extrn hash:word
	extrn lcname:word
	extrn svhash:word
	extrn svlcname:word
	extrn fNoCompact:byte
endif


@CurSeg ends

	assume ds:nothing
	extrn tsym:dword
	assume ds:@data

	.data?

mapstr	    db 10 dup(?)	    ; use this if /Ml

ifdef M8086OPT
qlcname     db SYMMAX+1 dup(?)

	    dw 1 dup(?) 	    ;hash for name
	    db 1 dup(?) 	    ;cb for name
qname	    db SYMMAX+1 dup(?)

qsvlcname   db SYMMAX+1 dup(?)

	    dw 1 dup(?) 	    ;hash for name
	    db 1 dup(?) 	    ;cb for name
qsvname     db SYMMAX+1 dup(?)

endif

ifdef M8086OPT
	    public qlcname, qname, qsvlcname, qsvname
endif

	.data
fEatBlanks  db 1		    ; flag for common getatom & getatomend
cbLeft	    dw 0		    ; count of bytes left in lbuf
rarea	    dw 0		    ; area for DosRead/Write to tell how much it read

	.code A_TEXT

ifdef M8086OPT

;***	getatom ()   ( hash = scanatom() )

nulToken:
	mov	lbufp,si	       ; update buffer pointer
	mov	[di+SYMMAX+4],bh
	pop	di
	pop	si
	retn

getatomComm:

	hProc <getatom near>, <uses si di>

	mov	ax,ds
	mov	es,ax
	mov	di,lbufp
	mov	ax,0920H		; load tab|space into AX
	or	cx,0FFFFH		; large count to CX
	alignCode
skipbeg:
	repe	scasb			; look for space
	xchg	al,ah
	dec	di
	repe	scasb			; then tab
	dec	di
	cmp	byte ptr [di],ah
	je	skipbeg 		; repeat if still space

	xor	ax,ax
	xor	bx,bx
	mov	si,di
	mov	di,lcname

	mov	bl,[si]
	test	byte ptr _asmctype_[bx],LEGAL1ST
	jz	nulToken

	xor	dx,dx			 ; initial hash value
	mov	cx,SYMMAX
	mov	begatom,si		; start of atom

	cmp	bl,'.'			;special case for token starting
	jne	notDot			;with .
	inc	si
	dec	cx
	mov	al,bl
	mov	dx,ax
	stosb
	mov	[di+SYMMAX+3],al
notDot:
	mov	bx,offset _asmTokenMap_ ; character translation table

	cmp	caseflag,CASEL
	je	short tokloop		; Mu or Mx - use MAP version


	alignCode
Mtokloop:
    rept 3
	lodsb				; al = get next character
	stosb				; *lcname++ = cc
	xlat

	mov	[di+SYMMAX+3],al	; *naim++ = cc
	add	dx,ax			; swapped hash += MAP(cc)

	dec	cx
	or	al,al
	jz	short tokdone
	jcxz	skiptok
    endm

	lodsb
	stosb
	xlat

	mov	[di+SYMMAX+3],al
	add	dx,ax

	or	al,al
	loopnz	Mtokloop

	jz	tokdone
	jmp	skiptok

tokloop:
    rept 3
	lodsb				; al = get next character
	stosb				; *lcname++ = cc

	mov	[di+SYMMAX+3],al	; *naim++ = cc
	xlat
	add	dx,ax			; swapped hash += MAP(cc)

	dec	cx
	or	al,al
	jz	short tokdone0
	jcxz	skiptok
    endm

	lodsb
	stosb

	mov	[di+SYMMAX+3],al
	xlat
	add	dx,ax

	or	al,al
	loopnz	tokloop

	jz	tokdone0
	jmp	short skiptok

tokdone0:
	mov	[di+SYMMAX+3],al	; terminate
tokdone:
	mov	[di-1],al
	dec	si
	mov	endatom,si
	jmp	short skipend

skiptok:
	dec	cx

skipnext:
	lodsb				; eat extra characters in token
	xlat
	or	al,al
	jnz	skipnext		; skip token

	mov	endatom,si

	mov	[di],al
	inc	di
	mov	[di+SYMMAX+3],al	; terminate
	dec	si

skipend:				; skip for getatom only
	mov	bx,cx
	mov	di,si
	cmp	fEatBlanks,0
	jz	noEatSemie

	mov	ax,0920H		; load tab|space into AX
	or	cx,0FFFFH		; large count to CX
	alignCode
skipend1:
	repe	scasb			; look for space
	xchg	al,ah
	dec	di
	repe	scasb			; then tab
	dec	di
	cmp	byte ptr [di],ah
	je	skipend1		; repeat if still space

skipend2:				; skip trailing white space
	mov	lbufp,di	       ; update buffer pointer

	xor	ax,ax
	mov	al,SYMMAX-1		; compute token length
	sub	al,bl

	mov	bx,naim
	mov	byte ptr [bx-1],al	; save prefixed cb
	mov	word ptr [bx-3],dx	; save prefixed hash

	hRet

noEatSemie:
	mov	fEatBlanks,1
	jmp	skipend2

	hEndp

;***	getatomend ()	; get an token without skiping trailing spaces

	hProc	<getatomend near>

	mov	fEatBlanks,0
	jmp	getatomComm

	hEndp

endif ;M8086OPT

ifdef M8086OPT
;***	inset (value, setptr)

	hProc	<inset near>, <uses si di>, value:byte, setptr:word

	mov	ax,ds
	mov	es,ax
	cld
	mov	al,value
	mov	di,setptr
	mov	cl,[di]
	inc	di
	xor	ch,ch			; cx = set length
	repne	scasb			; scan for al in es:di
	je	insetT			;   yes - return TRUE
	xor	ax,ax			; return FALSE
insetexit:
	hRet

insetT:	mov	ax,1			; return TRUE
	jmp	short insetexit

	hEndp

endif ;M8086OPT



;***	strffcmp (far1, far2)

	hProc	<strffcmp far>, <uses si di>, far1:dword, far2:dword

	cld
	les	di,far2
	lds	si,far1
	mov	bx,di			; save start of string
	cmpsb				; fast 1st char check
	jnz	ffne
	dec	si
	xor	ax,ax			; search for 0 terminator
	mov	cx,-1
	repne	scasb
	neg	cx			; cx = byte count for compare
	mov	di,bx
	repz	cmpsb
ffne:	mov	al,[si-1]
	sub	al,es:[di-1]		; ax = 0 if equal
	cbw

	push	ss
	pop	ds
	hRet

	hEndp


;***	strnfcmp (near1, far2)

	hProc	<strnfcmp near>, <uses di si>, near1:word, far2:dword

	cld
	mov	si,near1
	les	di,far2
	mov	bx,di			; save start of string
	cmpsb				; fast check on 1st character
	jnz	nfne
	dec	si
	xor	ax,ax			; search for 0 terminator
	mov	cx,-1
	repne	scasb
	neg	cx			; cx = byte count for compare
	mov	di,bx
	repz	cmpsb
nfne:	mov	al,[si-1]
	sub	al,es:[di-1]		; ax = 0 if equal

	hRet

	hEndp

ifdef M8086OPT

;***	switchname ()

	hProc	<switchname near>
	alignCode

	mov	ax,naim 		;; (naim) <--> (svname)
	xchg	ax,svname
	mov	naim,ax
	mov	ax,lcname		;; (lcname) <--> (svlcname)
	xchg	ax,svlcname
	mov	lcname,ax
	hRet

	hEndP

endif ;M8086OPT



ifdef M8086OPT

;***	I/O routines:  readmore, getline, ebuffer, etc.

 objfile struc
  ofh		dw	?
ifdef MSDOS
  pos		dd	?
  buf		dd	?
else
  pos		dw	?
  buf		dw	?
endif ;MSDOS
  cnt		dw	?
  siz		dw	?
  oname 	dw	?
 objfile ends

endif ;M8086OPT



ifdef M8086OPT

;***	ebuffer - write out object buffer
;
;	ebuffer (rectype, bufpos, buffer)

ebyte	macro
	dec	[bx].cnt
	jge	short $+5
	call	edump			; dump buffer
	stosb
	add	ah,al
	endm

	hProc	<ebuffer near>, <uses si di>, rectype:byte, bufpos:word, buffer:word

	mov	si,buffer
	mov	cx,bufpos
	sub	cx,si			; cx = buffer count
	jz	ebufdone
	cmp	objing,0
	je	ebufdone		; return if no object file

	mov	ax,cx
	add	ax,4
	add	word ptr oOMFCur,ax    ; oOMFCur += cbBuffer + 3
	adc	word ptr oOMFCur.2,0
ifndef MSDOS
	mov	ax,ds
	mov	es,ax
endif
	cld
	xor	ax,ax			; ah = 0 (initial checksum)
	mov	al,rectype
	mov	bx,OFFSET obj	       ; bx = obj file data structure pointer
ifdef MSDOS
	les	di,[bx].pos		; es:di = output buffer position
else
	mov	di,[bx].pos		; di = output buffer position
endif
	ebyte				; output record type
	inc	cx			; + 1 for record length
	mov	al,cl
	ebyte
	mov	al,ch
	ebyte				; output record length
	dec	cx			; - 1 for buffer loop
	alignCode
ebufloop:				; output buffer
	lodsb
	ebyte
	loop	ebufloop
	mov	al,ah			; output checksum
	neg	al
	ebyte
ifdef MSDOS
	mov	word ptr [bx].pos,di	; reset buffer position
else
	mov	[bx].pos,di		; reset buffer position
endif

ebufdone:
	mov	emitrecordtype,0
	hRet

	hEndp

;	edump
;
; Save:
;	bx = obj file descriptor pointer
;	ax = (checksum,outputbyte)
;	cx = possible count
;	si = emit buffer position

edump:	push	ax
	push	cx
	push	bx			; save src file descriptor pointer
ifdef MSDOS
	push	ds
	mov	cx,[bx].siz
	mov	ax,[bx].ofh
	lds	dx,[bx].buf
	mov	bh,40h
	xchg	ax,bx
ifdef CPDOS
	push	bx			; file handle
	push	ds			; buffer (selector)
	push	dx			; buffer (offset)
	push	cx			; # bytes to read
	mov	ax,@data
	push	ax			; reply area (selector)
	mov	ax,offset rarea
	push	ax			; reply area (offset)
	call	DosWrite
else
	int	21h
endif
	pop	ds

ifdef CPDOS
	or	ax,ax
	mov	ax,rarea
	jnz	writerr
else
	jc	writerr
endif
	pop	bx
	push	bx
	cmp	ax,[bx].siz
	je	writeok
writerr:
	mov	objerr,-1
writeok:
else
	push	[bx].siz
	push	[bx].buf
	push	[bx].ofh
	call	write		       ; write (ofh,buf,siz)
	add	sp,6
	pop	bx			; need to get bx back.
	push	bx			; write trashes it.  -Hans
	cmp	ax,[bx].siz
	je	writeok
	mov	objerr,-1
writeok:
	mov	ax,ds
	mov	es,ax
	cld				; in case
endif
	pop	bx
	mov	ax,[bx].siz
	dec	ax
	mov	[bx].cnt,ax		; reset buffer position
ifdef MSDOS
	mov	di,word ptr [bx].buf	; di = start of buffer
else
	mov	di,[bx].buf		; di = start of buffer
endif
	pop	cx
	pop	ax
	ret

endif ;M8086OPT




	hProc	<fMemcpy near>, <uses si di>, pDest:dword, pSource:dword, cb:word

	mov	cx,cb
	jcxz	fM1

	mov	dx,ds
	lds	si,pSource
	les	di,pDest
	shr	cx,1
	rep	movsw
	jnc	fM01
	movsb
fM01:
	mov	ds,Dx
fM1:
	hRet
	hEndp


ifdef M8086OPT
	; Native code version of symsrch as in asmsym.c

	hProc	<symsrch near>, <uses si di>

	mov	si,naim
	xor	Dx,Dx
	cmp	byte ptr[si-1],dl
	jne	sy001
	jmp	sy99
sy001:
	mov	Ax,word ptr[si-3]
	mov	Cx,TSYMSIZE
	div	Cx

	mov	Bx,Dx		    ;index into hash table
	shl	Bx,1
	shl	Bx,1
	mov	Ax,SEG tsym
	mov	Es,Ax
	les	di,dword ptr es:[Bx].tsym
	mov	Ax,es
	or	Ax,Ax		    ;if segment 0
	jne	sy002
	jmp	sy991
sy002:
	mov	Ax,word ptr[si-3]
	mov	Dx,si
	xor	Cx,Cx
	jmp	short syLook

	alignCode
syNext:
	les	di,es:[di]	    ; next symbol
	mov	Bx,es
	or	Bx,Bx		    ; continue if segment not 0
	jnz	 sylook
	jmp	 sy99
syLook:
	mov	bx,es:[di].12	    ; pointer to name
	cmp	Ax,es:[Bx]	    ; check hash values
	jne	syNext

	xchg	Bx,di
	mov	cl,[si-1]	    ; lenght to cl
	inc	Cx
	inc	di
	inc	di		    ; skip hash
	repz	cmpsb		    ; check actual strings
	mov	di,Bx		    ; restore pointers
	mov	si,Dx
	jnz	syNext

syFound:
	cmp	byte ptr es:[bx].1bH,12  ; if (p->symkind == CLABEL)
	jne	@F

@@:
	mov	cx,iProcCur
	jcxz	noNest

	push	ax
	cmp	byte ptr es:[bx].1bH,2	; if (p->symkind == CLABEL)
	jne	sy1
	mov	Ax,word ptr es:[bx].22h ;   if (p->iProc)
sy01:
	or	ax,ax
	jz	noNest0
	cmp	cx,Ax			;     if (p->iProc != iProcCur)
	je	noNest0
	pop	ax
	xor	cx,cx
	jmp	syNext
sy1:
	cmp	byte ptr es:[bx].1bH,6	; if (p->symkind == EQU)
	jne	noNest0
	mov	Ax,word ptr es:[bx].1eh ; AX = p->csassume
	jmp	sy01

noNest0:
	pop	ax

noNest:
	mov	word ptr symptr,Bx
	mov	word ptr symptr+2,es
	mov	Ax,1
	cmp	crefing,al
	je	syCref
	hRet			    ;Return true
syCref:
	push	Ax		    ;call crefing routines
	call	crefnew
	call	crefout
	mov	al,1
	jmp	short sy991
sy99:
	xor	Ax,Ax
sy991:
	hRet

	hEndp

endif ;M8086OPT

ifdef M8086OPT

;int	   PASCAL iskey (table)

	hProc	<iskey near>, <uses si di>, table:dword
	hLocal	l1:word, l2:word



	cld
	mov	si,naim
	cmp	caseflag,1	   ;if (caseflag == CASEL) {
	jne	noComputeHash

	xor	Dx,Dx			;nhash = 0;

;|*** for (uc = mapstr, lc = str; *lc; )

	push	ds
	pop	es
	mov	di,OFFSET mapstr
	xor	bh,bh
	mov	ah,bh
	alignCode
$F791:
	lodsb
	or	al,al
	jz	$L2001
	mov	bl,al
	mov	al,BYTE PTR _asmcupper_[bx]
	stosb	
	add	Dx,Ax
	jmp	short $F791
$L2001:

;|*** *uc = 0;

	stosb			;0 terminate string

;|*** uc = mapstr;

	mov	si,OFFSET mapstr
	mov	Cx,di
	sub	Cx,si			;cb of string into Cx
	mov	Ax,Dx			;hash to Ax
	jmp	SHORT storeNhash	;Ax has computed hash

noComputeHash:

	xor	cx,cx
	mov	cl,[si-1]
	inc	Cx			;include NULL
	mov	ax,[si-3]

storeNhash:
	mov	l1,ax	;nhash
	mov	l2,Cx	;cb

;|*** for (p = table->kttable[nhash % table->ktsize]; p; p = p->knext)

	les	bx,table
	mov	di,es:[bx]		;es now contains symbol table segment
	cwd
	idiv	WORD PTR es:[bx+2]
	shl	dx,1
	add	di,dx
	mov	Bx,si		;save uc name

	alignCode
isLook:
	cmp	word ptr es:[di],0
	je	isNotFound
	mov	di,es:[di]

;|*** if ((nhash == p->khash) && (!strcmp (p->kname,uc)))

	mov	Ax,l1		;nhash
	cmp	es:[di+4],Ax
	jne	isLook

	; do an inline string compare

	mov	Dx,di		; save p

	mov	Cx,l2		;cB
	mov	di,WORD PTR es:[di+2]	;Es:di = p->kname

	repe	cmpsb		; compare while equal

	jcxz	isFound

	mov	di,Dx		;restore registers
	mov	si,Bx

	jmp	isLook

;|*** return (p->ktoken);

isFound:
	mov	di,Dx
	mov	Ax,es:[di+6]
	jmp	SHORT isReturn

isNotFound:
	alignCode
	mov	ax,-1
isReturn:
	hRet
	hEndp

endif ;M8086OPT


ifdef M8086OPT
	hProc	<skipblanks near>

	mov	bx,lbufp
	dec	bx
	alignCode
ik1:				       ; skip leading white space
	inc	bx
	mov	al,[Bx]
	cmp	al,' '
	je	ik1
	cmp	al,9
	je	ik1

	mov	lbufp,bx

	hRet

	hEndp
endif

MC  struc	;structure for macro call, see asm86.h for full comments

pTSHead     dd ?
pTSCur	    dd ?

flags	    db ?
iLocal	    db ?
cbParms     dw ?
locBase     dw ?
countMC     dw ?

pParmNames  dw ?
pParmAct    dw ?

svcondlevel db ?
svlastcond  db ?
svelseflag  db ?
	    db ?
rgPV	    dw ?
MC  ends



ifdef M8086OPT

leOverflow2:
	pop	ax

leOverflow:
	push	ss
	pop	ds
	xor	Ax,Ax
	stosb				; terminate line

	mov	ax, 100 		; E_LTL
	push	AX			; print error message
	call	ERRORC
	jmp	leFin2


	; fast version to expand macro bodies / coded in C in asmirp.c

	hProc	<lineExpand near>, <uses si di>, pMC:word, pMacroLine:dword
	assume	es:@data

ifdef BCBOPT
	mov	fNoCompact, 0
endif
	mov	cbLeft, 511	    ; LBUFMAX (asm86.h) - 4
	les	si,pMacroLine	    ; get pointer to macro prototype
	mov	bx,pMC

	mov	dl,[bx].iLocal	    ; dl: local base index
	mov	dh,080H 	    ; dh: local base with high bit set
	add	dh,dl

	lea	bp,[bx].rgPV	    ; bp: pointer to actual arg array
	mov	di,offset lbuf	   ; si: pointer to new line

	push	ds
	mov	Ax,Es
	mov	ds,Ax		    ; set seg regs for ds:si & es:di
	pop	es
	xor	ah,ah
	xor	ch,ch		    ; set loop invariate
le1:
	lodsb			    ; fetch next prefix
	test	al,080H 	    ; check for parm
	jnz	leParmFound

	mov	cl,al
	jcxz	leFinished
	sub	es:[cbLeft],ax
	jc	leOverflow

	repz	movsb		    ; move non parameter entry
	jmp	le1

leParmFound:			    ; argment found
	mov	bl,al		    ; compute index
	shl	bx,1
	shl	bx,1
	and	bx,01FFH	    ; remove shifted high bit
	add	Bx,Bp

	push	ds
	push	es
	pop	ds		    ; save current ds and set to near

	cmp	al,dh		    ; determine  parm type
	jae	leLocalFound

	mov	Bx,word ptr[Bx]     ; fetch pointer to actual
	xchg	Bx,si		    ; save pMacroLine

	lodsb
	mov	cl,al
	jcxz	leNullArg
	sub	cbLeft,ax
	jnc	le2
	jmp	leOverflow2

le2:
	repz	movsb		    ; move parameter entry
leNullArg:
	mov	si,Bx		    ; restore saved pMacroLine
	pop	ds
	xor	ah, ah
	jmp	le1

leLocalFound:
	cmp	word ptr[Bx],0	    ; check to see if the local
	jz	leBuildLocal	    ; is defined

leLocalMove:
	xchg	Bx,si		    ; save pMacroLine
	sub	cbLeft,6
	jnc	le3
	jmp	leOverflow2

le3:
	mov	Ax,'??' 	    ; store leading ??
	stosw
	movsw			    ; and then remaining xxxx
	movsw
	jmp	leNullArg
leBuildLocal:
	push	Dx		    ; call runtime helper to generate name
	push	Bx
	push	Es
	xor	ah,ah
	sub	al,dh

	mov	Bx,Sp		    ; fetch pMC
	mov	Bx,[Bx+8+4+4]
	add	Ax,[Bx].locBase
	xor	Bx,BX

	push	Bx		    ; offsetAscii((long) .. )
	push	Ax
	call	offsetAscii

	pop	Es
	pop	Bx
	pop	Dx

	mov	Ax,objectascii	   ; copy 4 byte local name to cach
	mov	[Bx],AX
	mov	Ax,objectascii+2
	mov	[Bx].2,AX
	jmp	leLocalMove

leFinished:
	mov	ax,es		    ; restore ds
	mov	ds,ax
leFin2:
	mov	linebp,di	   ; set linebp
	mov	si,offset lbuf
	mov	lbufp,si	   ; lbufp= lbuf
	sub	di,si
	mov	cx, di
	mov	linelength, al	   ; linelength = linbp - lbuf

	cmp	fNeedList,0	    ;for listing copy to list buffer
	je	@F
	mov	di,offset linebuffer
	shr	cx,1
	rep	movsw
	rcl	cx,1
	rep	movsb
@@:
	.8086
	hRet



ifndef MSDOS
	.286
endif
	hEndp

endif ;M8086OPT

ifdef M8086OPT

;***	expandTM - expand text macro in naim in lbuf/lbufp
;*
;*	expandTM (equtext);
;*
;*	Entry	equtext = replacement string
;*		naim	= text macro
;*		begatom = first character in lbuf to replace
;*		endatom = first character in lbuf after string to replace
;*	Exit	lbuf	= new line to be parsed
;*	Returns
;*	Calls
;*	Note	Shifts characters from lbufp to make substitution of TM.
;*		Inserts replacement string at begatom
;*/

	hProc	<expandTM near>, <uses si di>, equtext:word
	hLocal	cbEndatom:word, cbNaim:word, cbText:word, fShifted:byte

	cld			    ; String instructions go forward

	mov	ax, ds		    ; Set es to @data
	mov	es, ax		    ;

	xor	ax, ax		    ; Will stop scanning when [di] == [al] == 0
	mov	fshifted, 0	    ; Haven't shifted line yet

	mov	cx, linebp	    ; Calculate cbEndatom == strlen(endatom)
	sub	cx, endatom	    ; but use (linebp - endatom + 1) as method
	inc	cx		    ;
	mov	cbEndatom, cx	    ; Store result in cbEndatom

	mov	cx, endatom	    ; Calculate cbNaim == strlen(naim)
	sub	cx, begatom	    ; but use (endatom - begatom) as method
	mov	cbNaim, cx	    ; Store result in cbNaim

	mov	di, equtext	    ; Calculate cbText == strlen(equtext)
	mov	cx, -1		    ;
	repne	scasb		    ;
	not	cx		    ; [cx] == length of equtext
	dec	cx		    ; don't count NULL
	mov	cbText, cx	    ; Store result in cbText

	cmp	cbNaim, cx	    ; Q: Is replacement longer than name?
	jl	shiftline	    ;	Y: Must shift endatom string to the right

copytext:
	mov	di, begatom	    ; Copy replacement text into lbuf
	mov	si, equtext	    ;
	mov	cx, cbText	    ; Number of bytes to copy
	shr	cx, 1		    ;
	rep	movsw		    ;
	jnc	etm2		    ;
	movsb			    ;
etm2:
	cmp	fShifted, 0	    ; Q: Have already shifted line right?
	jne	etmEnd		    ;	Y: Done

	mov	si, endatom	    ; Q: Is cbNaim == cbText?
	cmp	di, si		    ;
	je	etmEnd		    ;	Y: Done

	mov	cx, cbEndatom	    ;	N: Must shift endatom string left
	shr	cx, 1		    ;
	rep	movsw		    ;
	jnc	etm3		    ;
	movsb			    ;
etm3:
	mov	linebp, di	    ;
	jmp	etmEnd		    ;	Done


shiftline:			    ; Shift string at endatom to right

	mov	cx, cbEndatom	    ; Number of bytes to move
	mov	si, linebp	    ; [si] = end of string in lbuf
	mov	di, si		    ;
	add	di, cbText	    ;
	sub	di, cbNaim	    ; di == si + amount to shift string right
	mov	linebp, di	    ;

	mov	dx, di		    ; check if line too long
	sub	dx, OFFSET lbuf     ;
	cmp	dx, 512 	    ; LBUFMAX (asm86.h)
	jge	eltl		    ; line too long

	std			    ; String instructions go backwards
	rep	movsb		    ; Shift line
	inc	fShifted	    ;
	cld			    ; String instructions go forward again
	jmp	copytext	    ;

eltl:
	mov	ax,100		    ; Error E_LTL Line too long
	push	ax		    ;
	call	ERRORC		    ;
	mov	di, begatom
	mov	byte ptr [di], 0    ; Truncate line

etmEnd:
	mov	ax, begatom	    ; Reset lbufp to point to start of next
	mov	lbufp, ax	    ; token

	hRet
	hEndp

endif ;M8086OPT


ifdef MSDOS
ifdef M8086OPT

;***	farwrite - write with far buffer
;	farwrite(ofh,buf,count);

	hProc	<farwrite far>, handle:word, buffer:dword, count:word

	mov	ax,handle
	mov	cx,count
	push	ds
	lds	dx,buffer
	mov	bh,40h			; write
	xchg	ax,bx
ifdef CPDOS
	push	bx			; file handle
	push	ds			; buffer (selector)
	push	dx			; buffer (offset)
	push	cx			; # bytes to read
	mov	ax,@data
	push	ax			; reply area (selector)
	mov	ax,offset rarea
	push	ax			; reply area (offset)
	call	DosWrite
else
	int	21h
endif
	pop	ds
ifdef CPDOS
	or	ax,ax
	mov	ax, word ptr rarea
	jnz	fwriterr
else
	jc	fwriterr
endif
	cmp	ax,count
	je	fwriteok
fwriterr:
	mov	objerr,-1
fwriteok:
	hRet

	hEndp
endif ;M8086OPT
endif




;***	farAvail ()

ifdef MSDOS
ifndef CPDOS

	hProc	<farAvail far>

	or	Bx,0FFFFH	;request max memory from dos
	mov	ah,48H		;paragraphs left in Bx
	int	21H

	mov	ah,48H		;then allocate it
	int	21H
	jnc	noMem
	xor	Bx,Bx
noMem:
	mov	Ax,16
	cwd
	mul	Bx		;return paragraphs * 16
	hRet

	hEndp

endif
endif


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmexpr.h ===
/* asmexpr.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

/* Types of values desired by operators in evaltop */

#define CALLABS	0	/* unary or binary with null segment		*/
#define CLSIZE	1	/* unary or binary with (left) size		*/
#define CSAME	2	/* binary in same segment and not external	*/
#define CDATA	3	/* unary and data associated			*/
#define CCODE	4	/* unary and code associated			*/
#define CREC	5	/* unary record field or name			*/
#define CSEG	6	/* unary and value must have segment		*/
#define CLSEG	7	/* binary with left value segment assoc.	*/
#define CSIZE	8	/* unary with size				*/
#define CVAR	9	/* unary constant or data			*/
#define CONEABS	10	/* binary with one value constant		*/
#define CSAMABS	11	/* binary in same segment or 2nd constant	*/


/**	parser activation record
 *	This structure is equivalent to the upper frame variables
 *	of the outer Pascal procedure
 */

struct ar {
	DSCREC		*lastitem;
	DSCREC		*curresult;
	SCHAR		*expscan;
	USHORT		index;
	OFFSET		base;
	USHORT		rstype;
	USHORT		vmode;
	UCHAR		segovr;
	UCHAR		evalop;
	SCHAR		bracklevel;
	SCHAR		parenlevel;
	UCHAR		lastprec;
	UCHAR		curprec;
	UCHAR		linktype;
	UCHAR		exprdone;
	UCHAR		unaryflag;
	UCHAR		addplusflag;
	};


UCHAR PASCAL CODESIZE evalalpha PARMS((struct ar *));
VOID PASCAL CODESIZE evaluate PARMS((struct ar *));
VOID PASCAL CODESIZE exprop PARMS((struct ar *));
VOID PASCAL CODESIZE findsegment PARMS(( UCHAR , struct ar *));
char PASCAL CODESIZE  getitem PARMS((struct ar *));
UCHAR PASCAL CODESIZE popoperator PARMS((struct ar *));
DSCREC * PASCAL CODESIZE popvalue PARMS((struct ar *));
VOID  PASCAL CODESIZE valerror PARMS((struct ar *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmeval.c ===
/* asmeval.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmexpr.h"

char parseset[] = {14,
		   OPUNPLUS,  OPPLUS,
		   OPMINUS,   OPUNMINUS,
		   OPHIGH,    OPLOW,
		   OPDOT,     OPOFFSET,
		   OPCOLON,   OPLPAR,
		   OPLBRK,    OPTHIS,
		   OPSHORT,   OPPTR};

/* POPvalue pops a operand from the top of the evaluation stack
	   If the item is not an operand or the stack is empty, an
	   error is generated and a value of 0 is supplied. The operand
	   is returned to the caller in <valu> and is a result type
	   operand. The original operand will not be a result unless it
	   has been already used. The operand entry is destroyed and a
	   result operand is created for constants and symbols( which
	   are not record/struc names or fields ). */




/***	valerror - process error in operand entry
 *
 *	valerror (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */



VOID PASCAL CODESIZE
valerror (
	register struct ar	*p
){
	DSCREC *oldlast;

	/* Operand was expected */
	errorc (E_OPN);
	/* save expr stack */
	oldlast = p->lastitem;
	p->lastitem = defaultdsc ();
	/*  Point to rest */
	p->lastitem->previtem = oldlast;
}




/***	popvalue - pop operand entry off parse stack
 *
 *	dscrec = popvalue (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */



DSCREC * PASCAL CODESIZE
popvalue (
	register struct ar	*p
){
	register DSCREC *valu;

	if (!p->lastitem)
		valerror (p);
	if (p->lastitem->itype != OPERAND)
		valerror (p);
	/* If not operand, insert one at LASTitem */
	/* In case need to convert */
	valu = p->lastitem;
	/* Assume won't convert */
	/* Pop operand off stack */
	p->lastitem = valu->previtem;
	return (valu);
}




/***	popoperator - pop next operator from stack
 *
 *	op = popoperator (p);
 *
 *	Entry	*p = parse stack entry
 *	Exit
 *	Returns operator
 *	Calls
 */


UCHAR PASCAL CODESIZE
popoperator (
	register struct ar	*p
){
	register char op;

	if (!p->lastitem) {
		errorc( E_OPR );  /* expected operator */
		return( (char)OPPLUS );  /* use '+' as default */
	}
	else {
		if (p->lastitem->itype != OPERATOR) {
			errorc( E_OPR );  /* expected operator */
			return( (char)OPPLUS );  /* use '+' as default */
		}
		else {
			/* Return OPERATOR number */
			op = p->lastitem->dsckind.opr.oidx;
			/* Pop OPERATOR off stack */
			itemptr = p->lastitem;
			p->lastitem = p->lastitem->previtem;
			return (op);
		}
	}
}


/* Evaluate is called to evaluate part of the expression. It is
	   usually called just before a lower precedence is pushed, but
	   also when the expression is complete and for close parens of
	   various kinds regadless of precedence. The amount of the
	   expression stack evauated depends on the caller. There are
	   3 cases:

		1. Lower precedence OPERATOR( 3+4*5 AND 3 ). Evaluate
		   back until left paren or precedence<= OPERATOR. If
		   paren, leave on stack.

		2. A paren of some kind( )>] ). Evaluate back to match-
		   ing paren. Leave paren off stack. If any other paren
		   seen, cause error.

		3. End of expression( ENDexpr TRUE ). Evaluate all that
		   is left of expression.

 */

/***	pushpar - push paren or bracket back onto stack
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
pushpar (
	register struct evalrec	*p
){
	itemptr->previtem = p->p->lastitem;
	p->p->lastitem = itemptr;
	/* So OPERATOR not removed */
	itemptr = NULL;
}
/* EVALtop evaluates the top OPERATOR on the stack and its
	   operands and produces CURresult as a result. It assumes that
	   the stack is arranged as follows:

		Operand( If not already result type, will convert )

		OPERATOR( <> will cause error, [ executes as OPERATOR
			  ( will not evaluate, but whether stays on
			  stack is determined by PARENflag )

		Operand ( If not result, will convert. If OPERATOR is
			  unary, will not be looked for. Special check
			  for +/- used as unary. )

	   Any deviation from the above will cause an error to be
	   generated by popvalue/popoperator. */


/***	signadjust - calculate offset and sign of result and put in right operand
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Right and left operands may be switched
 */


VOID PASCAL CODESIZE
signadjust (
	UCHAR	minus,
	register struct exprec *p
){
	register struct psop *psol;	/* parse stack operand structure */
	register struct psop *psor;	/* parse stack operand structure */
	DSCREC	       *t;
	OFFSET maxInt;
	char   fOverflow = FALSE;

	maxInt = (fArth32)? OFFSETMAX: 0xffff;

	psor = &(p->valright->dsckind.opnd);
	psol = &(p->valleft->dsckind.opnd);

	if (psol->s)		  /* arthmethic on data size item - NEAR/FAR */
	    errorc(E_TIL);

	if (minus)
		psor->dsign = !psor->dsign;

	if (psol->dsegment || psol->dflag == XTERNAL ||
	    (M_FLTSTACK & psol->dtype)) {
		/* Want to preserve Left operand */
		t = p->valleft;
		p->valleft = p->valright;
		p->valright = t;
		p->right = p->left;
		p->left = p->valleft->dsckind.opnd.doffset;
		psor = &(p->valright->dsckind.opnd);
		psol = &(p->valleft->dsckind.opnd);
	}
	if (psol->dflag == UNDEFINED)
		psor->dtype = M_CODE | M_FORTYPE;

	if (psor->dflag == UNDEFINED && !(psol->dtype & M_PTRSIZE))
		psol->dsize = 0;

	if (psol->dsign == psor->dsign) {
		/* Signs are same */
		fOverflow = (((maxInt - p->right) + 1) == p->left);
		p->right = p->right + p->left;
	} else if (p->right > p->left)
		/* Different signs */
		p->right = p->right - p->left;
	else {
		p->right = p->left - p->right;
		psor->dsign = !psor->dsign;
	}

	if (p->right == 0 && !fOverflow)
		psor->dsign = FALSE;
	if (psor->dsign && (psor->dtype & M_SEGRESULT))
		errorc (E_OSA);
	psor->doffset = p->right;
}




/***	foldsigns - force evaluating 17 bit signed values back to 16 bits
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
foldsigns (
	register struct exprec	*p
){
	/* the forms inside the comments seem to be trying to manage
	 * things as unsigned short even though they are stored in a
	 * larger field--ie this would be running as a cross assembler
	 * from a 32 bit host to a 16 bit object.  since for the 386,
	 * we keep all this stuff as long, this turns out to be a bad
	 * approach.  so without completely understanding what is going
	 * on, I am doing a simple negate (on the OFFSET field, which
	 * is probably an unsigned long) rather than trying to preserve
	 * the odd typing of the previous version  -Hans, 19/9/86 */

	if (p->valright->dsckind.opnd.dsign)
		/* p->right = 65535 - p->right + 1; */
		p->right = -(long)p->right;
	if (p->valleft)
		if (p->valleft->dsckind.opnd.dsign)
			/* p->left = 65535 - p->left + 1; */
			p->left = -(long)p->left;
}




/***	shiftoper - execute shift left or right
 *
 *	result = shiftoper (p);
 *
 *	Entry	*p = parse stack entry
 *	Exit	none
 *	Returns shifted value
 *	Calls
 */


OFFSET PASCAL CODESIZE
shiftoper (
	register struct exprec	*p
){
	register OFFSET  argl;
	register USHORT  argr;

	argl = p->valleft->dsckind.opnd.doffset;
	if (p->valleft->dsckind.opnd.dsign)
		argl = -(long)argl;
	argr = (USHORT)(p->valright->dsckind.opnd.doffset);
	if (p->valright->dsckind.opnd.dsign) {
		errorc (E_SCN);
		return (argl);
	}
	else if (sizeof(OFFSET)*8 < argr)
		return (0);
	else if (p->stkoper == OPSHL)
		return (argl << argr);
	else
		return (argl >> argr);
}

/* VALcheck is used by all OPERATOR execute routines to make
	   sure their arguments are correct. If the arguments are
	   expected to be some kind of result( i.e. not a structure
	   or record item or data size ), the old argument is destroy-
	   ed and DEFAULTdsc is called to create a substitute. Error
	   messages are also generated on type mismatches. A number
	   of procedures of the form: VALUExxxx are called, these
	   check if the given argument is of that type and if not,
	   generate an error and a value of zero. There is one kludge
	   in this procedure, the LENGTH OPERATOR should work with
	   records and structures, but these are still in the form of
	   <Isym> records so they will work with MASK, ...
	   The operand types are as follows:

	Callabs 	May be unary or binary. In any case, all
			values must have a NIL segment.

	Clsize		May be unary or binary. If unary, value must
			be a size( which is: structure name, -2 .. n
			or BYTE WORD ... ). If binary, left value is
			a size.

	Csame		Is always binary. If not results, coerce them.
			Both must belong to the same segment and not
			be external.

	Cdata		Is always unary. Result must be associated
			with data( Dtype is [data] ). Exception if
			LENGTH OPERATOR and is record or record field
			in which case converts to approriate result
			record.

	Ccode		Is always unary. Result must be associated
			with code( Dtype is [code] ).

	Crec		Is always unary. Value must be record field
			or record name.

	Cseg		Is always unary. Value must have a segment.

	Cvar		Always unary. Value must be constant or data
			or code.

	Clseg		Always binary. The left value must be a
			SEGresult or a segment register.

	Coneabs 	Always binary. One of the values must be a
			constant.

	Csamabs 	Always binary. Either both values have the
			same segment or the second value is a constant

 */




/***	valconst - give error if value is not constant
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
valconst (
	register DSCREC	*arg
){
	if (!(M_RCONST & arg->dsckind.opnd.dtype) ||
	      arg->dsckind.opnd.dsegment ||
	      arg->dsckind.opnd.dflag == XTERNAL)
		/* Not constant */
		errorc (E_CXP);
}


/***	valusize - check size of operand
 *
 *	val = valusize (arg);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


USHORT PASCAL CODESIZE
valuesize (
	register DSCREC *arg
){
	if (!fArth32)
	   arg->dsckind.opnd.doffset = (long) (SHORT) arg->dsckind.opnd.doffset;

	if (arg->dsckind.opnd.doffset == 0) {
		/* 0 means no size */
		errorc (E_OHS);
		return (0);
	}
	else if (arg->dsckind.opnd.doffset >= CSFAR_LONG)
		return (xltsymtoresult[PROC]);
	else
		return (xltsymtoresult[DVAR]);
}




/***	valcheck - check operand value
 *
 *	valcheck (valtype, unary, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
valcheck (
	UCHAR	valtype,
	UCHAR	unary,
	register struct exprec	*p
){
	register struct psop *psol;	/* parse stack operand structure */
	register struct psop *psor;	/* parse stack operand structure */

	psol = &(p->valleft->dsckind.opnd);
	psor = &(p->valright->dsckind.opnd);
	/* Should give error if have 2 externals */
	if (p->valleft)
		if (psol->dflag == XTERNAL && psor->dflag == XTERNAL)
			errorc (E_IUE);
	switch (valtype) {
		case CALLABS:
			valconst (p->valright);
			if (!unary)
				valconst (p->valleft);
			break;
		case CLSIZE:
			if (unary)
				psor->dtype = valuesize (p->valright);
			else
				psol->dtype = valuesize (p->valleft);
			break;
		case CSAME:
			if (psol->dsegment != psor->dsegment)
				errorc (E_OMM);
			break;
		case CDATA:
			if ((p->stkoper != OPLENGTH) || !psor->dextptr
			    || (psor->dflag == XTERNAL)) {
				if (!(M_DATA & psor->dtype) &&
				    (psor->dlength == 0))
					errorc (E_ASD);
			}
			else {
				/* Special case for LENGTH */
				p->valleft = defaultdsc ();
				/* Create value */
				p->valleft->prec = p->valright->prec;
				psol = &(p->valleft->dsckind.opnd);
				psol->dlength = psor->dextptr->length;
				/* Lose old value */
				oblititem (p->valright);
				p->valright = p->valleft;
				p->valleft = NULL;
				psor = psol;
				psol = NULL;
			}
			break;
		case CCODE:
			if (!(M_CODE & p->valright->dsckind.opnd.dtype))
			    errorc (E_ASC);
			break;
		case CREC:
			if (!psor->dextptr || psor->dflag == XTERNAL)
				errorc (E_RRF);
			break;
		case CSEG:
			if (!psor->dsegment && psor->dflag != XTERNAL
			    || (M_REGRESULT & psor->dtype))
				errorc (E_OSG);
			break;
		case CLSEG:
			if (M_SEGRESULT & psol->dtype) {
				/* ??? if (!psor->dsegment || (psor->dtype & M_RCONST))
					errorc (E_IOT); ??? */
			}
			else if (M_REGRESULT & psol->dtype) {
				if (psol->dsegment->symu.regsym.regtype != SEGREG)
					errorc (E_LOS);
			}
			else
				errorc (E_LOS);
			break;
		case CONEABS:
			if (psor->dsegment && psol->dsegment)
				errorc (E_OOC);
			break;
		case CSAMABS:
			if (psor->dsegment &&
			    psol->dsegment != psor->dsegment)
				errorc (E_OSA);
			break;
	}
	p->right = psor->doffset;
	if (p->valleft)
		p->left = psol->doffset;
}




/***	regcheck - check for <arg> a register in [...]
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


DSCREC * PASCAL CODESIZE
regcheck (
	DSCREC	*arg,
	UCHAR	minus,
	register struct exprec	*ptr
){
	struct psop *pso;	   /* parse stack operand structure */
	register struct ar *pAR;
	USHORT	reg;

	pso = &(arg->dsckind.opnd);
	pAR = ptr->p->p;

	if (M_REGRESULT & pso->dtype) {

		/* Is some register */
		if (ptr->p->parenflag || pAR->bracklevel) {

			/* Have index reg in []s */
			/* Lose size based on register */

			pso->dsize = 0;
			reg = (USHORT)(pso->dsegment->offset);

			/* Must be index or ptr reg */

			switch(pso->dsegment->symu.regsym.regtype)
			{
			default:
				errorc (E_IBR);
				break;
			case INDREG:
				if (reg <= 5)

				    /* Have base reg BX | BP */

				    if (pAR->base)
					    errorc (E_DBR);
				    else
					    pAR->base = reg;

				else /* Have index reg DI | SI */

				    if (pAR->index)
					    errorc (E_DIR);
				    else
					    pAR->index = reg;
				break;
#ifdef V386
			case DWRDREG:

				/* Have 386 reg in []s */

				if (minus == 2)
				{
				    if (pAR->index & 0xf)
					    errorc(E_DIR);

				    pAR->index |= 8 | reg;
				}
				else if (pAR->base)
				{
				    if (pAR->index)
					    errorc(E_DIR);

				    if (reg == 4) {

				       /* swap base with index
				       * to allow [index][eSp] */

					pAR->index = (USHORT)(pAR->base);
					pAR->base = 4|8;
				    }
				    else
					pAR->index = reg|8;
				}
				else
				    pAR->base = reg|8;

				break;
#endif /* V386 */
			}
			if (minus == TRUE && (ptr->valright == arg))
				errorc (E_IUR);

			oblititem (arg);
			return (defaultdsc ());
		}
		else {
		    errorc(E_IUR);
		    return (arg);
		}
	}

#ifdef V386   /* scaled indexing modes */

	else if (minus == 2 && (M_RCONST & pso->dtype))
	{
		if (pAR->index&0x70)
			errorc(E_MBR);

		if (highWord(arg->dsckind.opnd.doffset))
			goto scaleErr;

		switch((SHORT) arg->dsckind.opnd.doffset) {

		case 1:
			pAR->index |= 0x10;
			break;
		case 2:
			pAR->index |= 0x20;
			break;
		case 4:
			pAR->index |= 0x30;
			break;
		case 8:
			pAR->index |= 0x40;
			break;

		scaleErr:
		default:
			error(E_EXP, "scale value of 1,2,4 or 8");
		}
		oblititem (arg);
		return (defaultdsc ());
	}
#endif /* V386 */

	else return (arg);
}




/***	idxcheck - check for arg to +- is register
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	See if arg to +/- is register, in which case see if should
 *		be stored in Ridx or Rbas due to []s
 */


VOID PASCAL CODESIZE
idxcheck (
	UCHAR minus,
	register struct exprec	*p
){
	p->valleft = regcheck (p->valleft, minus, p);
	p->valright = regcheck (p->valright, minus, p);
	p->right = p->valright->dsckind.opnd.doffset;
	p->left = p->valleft->dsckind.opnd.doffset;
}



/***	makeGrpRel - make an offset group relative
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
makeGrpRel (
	register struct psop *p
){
	if (!(p->dtype&M_EXPLCOLON) && p->dsegment &&
	    p->dsegment->symkind == SEGMENT && p->dsegment->symu.segmnt.grouptr){

	    p->dtype |= M_GROUPSEG;
	    p->dcontext = p->dsegment->symu.segmnt.grouptr;
	}
}



/***	evaltop - evaluate top entry
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
evaltop (
	struct evalrec *ptr
){
	register struct psop *psol;	/* parse stack operand structure */
	register struct psop *psor;	/* parse stack operand structure */
	struct exprec	a;

	a.p = ptr;
	/* Get right operand */
	a.valright = popvalue (a.p->p);
	itemptr = NULL;
	if (a.p->p->lastitem) {

	    /* Get OPERATOR */
	    a.stkoper = popoperator (a.p->p);
	    a.valleft = NULL;
	    /* assume is unary */
	    if (!inset (a.stkoper, unaryset))
		    /* Not unary OPERATOR */
		    a.valleft = (a.stkoper == OPUNPLUS || a.stkoper == OPUNMINUS)
			    ? defaultdsc() : popvalue (a.p->p);
	    /* Save for EVALtop */
	    a.p->idx = a.stkoper;
	    if (a.valleft)
		    a.valleft->prec = a.valright->prec;
	    psol = &(a.valleft->dsckind.opnd);
	    psor = &(a.valright->dsckind.opnd);

	    switch (a.stkoper) {

	/* All OPERATORs are executed thru this CASE statement. The
	 * VALcheck routine makes sure operands are of the correct
	 * type and may create dummy entries in the case of the real
	 * operand not being of type result when required. The REStype
	 * routine uses it's argument to know what part of the result
	 * record should be kept and the type of the result. Unary
	 * and binary OPERATORs both return their results in VALright. */

	       case OPAND:
	       case OPOR:
	       case OPXOR:
		       /* Make sure operands ok */
		       valcheck (CALLABS, FALSE, &a);
		       /*  Must work on 16 bits */
		       foldsigns (&a);
		       switch (a.stkoper) {
			       case OPAND:
				       psor->doffset = a.left & a.right;
				       break;
			       case OPOR:
				       psor->doffset = a.left | a.right;
				       break;
			       case OPXOR:
				       psor->doffset = a.left ^ a.right;
				       break;
		       }
		       psor->dsign = FALSE;
		       /*  Must clear out Dsign in case was signed value */
		       break;
	       case OPNOT:
		       /* TRUE constant arg */
		       valcheck (CALLABS, TRUE, &a);
		       foldsigns (&a);
		       psor->doffset = ~a.right;
		       psor->dsign = FALSE;
		       if (optyp == TDB &&
			   (psor->doffset & ((OFFSET) ~0xff)) == ((OFFSET) ~0xff))
			       psor->doffset &= 0xFF;
#ifdef V386_noCode

		       if (!(cputype & P386))	       /* truncate result to 16 bits */
			  psor->doffset &= 0xffff;    /* for compatablity */
#endif
		       break;
	       case OPSHL:
	       case OPSHR:
		       valcheck (CALLABS, FALSE, &a);
		       psor->doffset = shiftoper (&a);
		       psor->dsign = FALSE;
		       break;
	       case OPSEG:
		       /* Must have segment */
		       valcheck (CSEG, TRUE, &a);

		       if (psor->dcontext && !(psor->dtype&M_EXPLCOLON))
			   psor->dsegment = psor->dcontext;

		       psor->dtype = (USHORT)((psor->dtype&M_FORTYPE) | M_SEGRESULT| M_RCONST);
		       psor->doffset = 0;
		       psor->dsign = FALSE;

		       break;
	       case OPDOT:
		       /* See if idx reg */
		       idxcheck (FALSE, &a);
		       valcheck (CONEABS, FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       if (psor->dsize)
			       psol->dsize = psor->dsize;
		       /* Adjust signs on records */
		       signadjust (FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       break;
	       case OPUNPLUS:
	       case OPPLUS:
		       /* See if idx reg */
		       idxcheck (FALSE, &a);
		       valcheck (CONEABS, FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       /* Adjust signs on records */
		       signadjust (FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       break;
	       case OPUNMINUS:
	       case OPMINUS:
		       idxcheck (TRUE, &a);
		       if (psor->dsegment == psol->dsegment &&
			   psol->dsegment) {
			       if (psol->dtype & M_SEGRESULT) {
				       psol->dtype = M_SEGRESULT | M_RCONST;
				       psol->doffset = 0;
				       psol->dsign = FALSE;
			       }
			       if (psor->dtype & M_SEGRESULT) {
				       psor->dtype = M_SEGRESULT | M_RCONST;
				       psor->doffset = 0;
				       psor->dsign = FALSE;
			       }
		       }
		       valcheck (CSAMABS, FALSE, &a);
		       signadjust (TRUE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       if (psol->dsegment) {
			       /* clear Dcontext if have var-var */
			       psor->dtype = (USHORT)((psor->dtype &
				   (M_EXPLOFFSET | M_PTRSIZE | M_FORTYPE)) | M_RCONST);
			       psor->dsegment = NULL;
			       psor->dcontext = NULL;
			       psor->dsize = 0;
			       oblititem (a.valleft);
			       a.valleft = NULL;
		       }
		       break;
	       case OPMULT:
#ifdef V386
		       if (M_REGRESULT & (psol->dtype|psor->dtype))
		       {
			   if (cputype&P386) {
			       idxcheck (2, &a);
			       if (a.p->p->index&0x78)
				   break;
			   } else
			       errorc (E_IRV);
		       }
#endif
		       /* fall through */
	       case OPDIV:
		       valcheck (CALLABS, FALSE, &a);
		       /* Both are constant */
		       if (a.stkoper == OPMULT)
			       psor->doffset = a.left * a.right;
		       else if (a.right == 0)
			       errorc (E_DVZ);
		       else
			       psor->doffset = a.left / a.right;
		       if (psor->doffset == 0)
			       psor->dsign = FALSE;
		       else
			       psor->dsign = (psol->dsign != psor->dsign);
		       break;
	       case OPHIGH:
		       if (psor->dtype & M_RCONST) {
			       if (psor->dsign) {
				       psor->doffset = -(long)psor->doffset;
				       psor->dsign = 0;
				       }
			       psor->doffset = psor->doffset >> 8 & 0xff;
		       }
		       psor->dtype |= M_HIGH;

		       goto highlow;

	       case OPLOW:
		       if (psor->dtype & M_RCONST)
			       psor->doffset &= 0xFF;

		       psor->dtype |= M_LOW;

	       highlow:
		       psor->dsize = 1;
		       if ((!(psor->dflag & XTERNAL && psor->dtype & M_EXPLOFFSET))
			 && psor->dsegment
			 && (psor->dtype & (M_EXPLOFFSET | M_SEGRESULT
			     | M_REGRESULT | M_GROUPSEG | M_DATA | M_CODE)))
			       errorc (E_CXP);
		       break;

	       case OPOFFSET:
		       psor->fixtype = FOFFSET;

		       if (!(psor->dsegment || psor->dflag == XTERNAL))
			   errorc(E_OSG|E_WARN2);

		       if (!(M_DATA & psor->dtype))
			       psor->dcontext = NULL;
		       psor->dtype = (USHORT)(
			   (psor->dtype |
			    M_RCONST | M_EXPLOFFSET) & ~(M_SEGRESULT));

		       if (fSimpleSeg)
			   makeGrpRel (psor);

		       /* preserve OFFSET arg size it's a const */
		       if ((psor->dsegment ||
			    psor->dcontext ||
			    psor->dflag == XTERNAL) &&
			   !(M_PTRSIZE & psor->dtype))
			       psor->dsize = 0;
		       break;
	       case OPLENGTH:
	       case OPSIZE:
		       /* Must be data associated */
		       valcheck (CDATA, TRUE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       if (a.stkoper == OPLENGTH)
			       psor->doffset = psor->dlength;
		       else
			       psor->doffset =
				  psor->dsize * psor->dlength;

		       psor->dflag &= ~XTERNAL;
		       break;
	       case OPTYPE:
		       a.right = psor->dsize;
		       oblititem (a.valright);
		       a.valright = defaultdsc ();
		       psor = &(a.valright->dsckind.opnd);
		       psor->doffset = a.right;
		       a.p->p->base = 0;
		       a.p->p->index = 0;
		       break;
	       case OPMASK:
	       case OPWIDTH:
		       /* Must be record or field */
		       valcheck (CREC, TRUE, &a);
		       if (psor->dextptr && psor->dflag != XTERNAL) {
			   if (a.stkoper == OPWIDTH)
			       if (psor->dextptr->symkind == REC)
				   psor->doffset = psor->dextptr->length;
			       else
				   psor->doffset = psor->dextptr->symu.rec.recwid;
			   else if (psor->dextptr->symkind == REC)
			       psor->doffset = psor->dextptr->offset;
			   else
			       psor->doffset = psor->dextptr->symu.rec.recmsk;
		       }
		       break;
	       case OPSTYPE:
		       a.right = 0;
		       if (errorcode == 0) {
			    if (psor->dflag == XTERNAL)
				    a.right |= 0x80;		/* external */
			    if (psor->dflag != UNDEFINED)
				    a.right |= 0x20;		/* defined */
			    if (psor->dtype & M_DATA)
				    a.right |= 0x02;		/* data */
			    if (psor->dtype & M_CODE)
				    a.right |= 0x01;		/* program */

			    if ((a.p->p->base == 0) && (a.p->p->index == 0)) {

				if (psor->dtype == xltsymtoresult[REGISTER])
				    a.right |= 0x10;		/* register */
				else if (psor->dtype & M_RCONST)
				    a.right |= 0x04;		/* constant */
				else if (psor->dtype & M_DATA)
				    a.right |= 0x08;		/* direct */

			    } else {
				a.p->p->base = 0;
				a.p->p->index = 0;
			    }
		       }
		       oblititem (a.valright);
		       a.valright = defaultdsc ();
		       psor = &(a.valright->dsckind.opnd);
		       psor->doffset = a.right;
		       errorcode = 0;
		       break;
	       case OPLPAR:
	       case OPLBRK:
		       if (!(a.p->parenflag || a.p->p->exprdone))
			       pushpar (a.p);
		       else if (a.stkoper == OPLBRK)
			       a.valright = regcheck (a.valright, FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       break;
	       case OPMOD:
		       valcheck (CALLABS, FALSE, &a);
		       if (a.right == 0) {
			       /* div 0 */
			       errorc (E_DVZ);
			       psor->doffset = 0;
			       psor->dsign = FALSE;
		       }
		       else {
			       psor->doffset = a.left % a.right;
			       if (psor->doffset == 0 || !psol->dsign)
				       psor->dsign = FALSE;
			       else
				       psor->dsign = TRUE;
		       }
		       break;
	       case OPTHIS:
		       valcheck (CLSIZE, TRUE, &a);
		       /* Unary, right is size */
		       psor->s = 0;
		       psor->dsize = (USHORT)a.right;
		       psor->doffset = pcoffset;
		       psor->dsegment = pcsegment;
		       if (a.right >= CSFAR_LONG)
			       psor->dcontext = regsegment[CSSEG];
		       break;
	       case OPSHORT:
		       valcheck (CCODE, TRUE, &a);
		       /* Unary, must be code */
		       psor->dtype |= M_SHRT;
		       break;
	       case OPPTR:
		       valcheck (CLSIZE, FALSE, &a);
		       if (psol->doffset >= CSFAR_LONG &&
			  (M_RCONST == psor->dtype ||
			  (psor->dcontext && (M_DATA&psor->dtype && !(M_CODE&psor->dtype))) ))

			       errorc (E_NSO);		    /* Can't code_data */
		       else {
			       psor->dsize = (USHORT)a.left;
			       if ((M_DATA & psol->dtype)
				   && !(M_DATA & psor->dtype))
				       psor->dcontext = NULL;
			       /* Change code/data */
			       psor->dtype = (USHORT)(
				    (psor->dtype & ~(M_CODE | M_DATA) |
				    (psol->dtype & (M_CODE | M_DATA))) &
				    ~(M_FORTYPE) | (M_PTRSIZE));
		       }
		       break;
	       case OPEQ:
	       case OPGE:
	       case OPGT:
	       case OPLE:
	       case OPLT:
	       case OPNE:
		       valcheck (CSAME, FALSE, &a);
		       signadjust (TRUE, &a);
		       /* Do signed R=L-R */
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);

		       if (!fArth32)
			   a.right &= 0xffff;

		       switch (a.stkoper) {
			       case OPEQ:
				       a.right = (a.right == 0);
				       break;
			       case OPGE:
				       a.right = !psor->dsign;
				       break;
			       case OPGT:
				       a.right = (!psor->dsign && a.right);
				       break;
			       case OPLE:
				       a.right = (psor->dsign || a.right == 0);
				       break;
			       case OPLT:
				       a.right = psor->dsign;
				       break;
			       case OPNE:
				       a.right = (a.right != 0);
				       break;
		       }
		       /*  Set Dsign if result TRUE */
		       psor->doffset = a.right;
		       psor->dsign = (a.right == 1);
		       psor->dcontext = NULL;
		       oblititem (a.valleft);
		       a.valleft = NULL;
		       break;
	       case OPCOLON:
		       /* <segment> : <var> */
		       valcheck (CLSEG, FALSE, &a);

		       if  ((a.p->p->bracklevel || a.p->evalop == OPLBRK) &&
			   (M_REGRESULT & (psol->dtype | psor->dtype)))
			   errorc(E_ISR);

		       psor->dtype = (USHORT)((psor->dtype|M_EXPLCOLON|M_DATA) & ~M_RCONST);

		       if (psol->dsegment) {

			   if (psol->dsegment->symkind == GROUP)
			       psor->dtype |= M_GROUPSEG;

			   if (!psor->dsegment &&
			       !(M_REGRESULT & psol->dtype) &&
			       !(a.p->p->base || a.p->p->index))

			       psor->dsegment = psol->dsegment;
		       }

		       psor->dcontext = psol->dsegment;
		       break;

	    } /* operator case */

	    if (!inset (a.stkoper, parseset)) {

		/* Have constant or segment result */

		psor->dlength = 0;

		psor->dsize = 0;
		psor->sized = 0;
		if (a.valleft)
			psol->dsize = 0;

		/* Have constant result( typeless ) */

		if (a.stkoper != OPSEG) {

		    psor->dtype = (USHORT)((psor->dtype & M_FORTYPE) | M_RCONST);
		    psor->dsegment = NULL;

		    if (a.valleft)
			psol->dtype &= ~M_PTRSIZE;
		}
	    }
	    a.p->p->curresult = a.valright;
	    psor = &(a.p->p->curresult->dsckind.opnd);

	    if (!fArth32 && optyp != TDD)
		psor->doffset &= 0xffff;

	    if (a.valleft) {
		/* Might need to copy some info */

		/* Prevent OPERATORs like +, -, . from
		losing the [DATA] flag if it it is the
		Left operand. This is ok, except when
		surrounded by a PTR which will drop
		segment override if not data type */

		if (a.stkoper != OPCOLON)
			psor->dtype |= psol->dtype & (M_DATA | M_CODE);
		if (psor->dflag == KNOWN)
			psor->dflag = psol->dflag;
		if (!psor->dcontext)
			psor->dcontext = psol->dcontext;
		if (psor->dsize == 0)
			psor->dsize = psol->dsize;
		if (psor->fixtype == FCONSTANT)
			psor->fixtype = psol->fixtype;

		psor->dtype |= psol->dtype & (M_PTRSIZE|M_EXPLOFFSET|M_FORTYPE);
		/* Above makes sure PTR or OFFSET is not lost */
		oblititem (a.valleft);
		a.valleft = NULL;
	    }
	}
	else {	/* no operator case */

	    a.p->p->curresult = a.valright;
	    psor = &(a.p->p->curresult->dsckind.opnd);
	    a.p->parenflag = FALSE;
	}

	if (!a.p->p->lastitem) {
	    a.p->p->lastprec = 0;
	    a.p->p->curresult->prec = 0;
	}
	else if (a.p->p->lastitem->itype == OPERATOR) {

	    if ((a.p->p->lastitem->dsckind.opr.oidx == OPLBRK) ||
		(a.p->p->lastitem->dsckind.opr.oidx == OPLPAR))

		/* Stop evaluating back at paren */
		a.p->p->lastprec = 0;

	    else {
		a.p->p->lastprec = a.p->p->lastitem->prec;
		if ((a.p->p->lastitem->dsckind.opr.oidx == OPUNPLUS) ||
		    (a.p->p->lastitem->dsckind.opr.oidx == OPUNMINUS))
			/* Force eval */
			a.p->p->lastitem->prec = a.p->p->lastprec = 20;
	    }
	}
	else
	    a.p->p->lastprec = a.p->p->lastitem->prec;

	if (itemptr) {
	    oblititem (itemptr);
	    itemptr = NULL;
	}

	/* Hook rest of list in */

	a.p->p->curresult->previtem = a.p->p->lastitem;
	a.p->p->lastitem = a.p->p->curresult;

	/* Push result back on */

	if (!a.p->p->curresult->previtem && a.p->p->exprdone)
	    a.p->p->lastitem = NULL;
}




/***	evaluate - evaluate stack
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
evaluate (
	struct ar *p
){
	struct evalrec	a;
	a.p = p;
	a.parenflag = FALSE;
	a.evalop = OPNOTHING;
	/* No paren or match to find */
	a.curoper = itemptr;

	if (a.curoper)
	    a.parenflag = !a.p->exprdone &&
			   (a.curoper->dsckind.opr.oidx == OPRPAR ||
			    a.curoper->dsckind.opr.oidx == OPRBRK);
	if (a.parenflag)
	    a.evalop = (a.curoper->dsckind.opr.oidx == OPRPAR)? OPLPAR: OPLBRK;

	do {	/* Evaluate to OPERATOR */

		evaltop (&a);

	} while (a.p->lastitem && a.p->lastitem->previtem &&
		 (a.p->exprdone ||
		  (!a.parenflag && a.p->lastprec >= a.p->curprec ) ||
		  ( a.parenflag && a.idx != a.evalop)) );

	/* stop if just value on expression stack */
	itemptr = a.curoper;
	if (a.p->lastprec == 0)
		a.p->lastprec = a.p->curresult->prec;

	if (!a.p->exprdone)
	    if (a.parenflag) {/* Push value and set prec */

		if (!a.p->lastitem->previtem)/* start of expr */
			a.p->lastprec = 0;
		else
			a.p->lastprec = a.p->lastitem->previtem->prec;

		/* Restore preced */
		a.p->lastitem->prec = a.p->lastprec;
		oblititem (itemptr);
		itemptr = NULL;

		/* Destroy close paren */
	    }
	    else {	    /* Case 1, OPERATOR eval */
		itemptr->previtem = a.p->lastitem;
		a.p->lastitem = itemptr;

		/* Push OPERATOR */
		if (a.p->lastprec != 20)
			a.p->lastprec = itemptr->prec;
	    }
}

/* Return a descriptor record to help instruction routines
	  generate the right code. The items are as follows:

		mode::	Value 0..4 Corresponds to 8086 mod

			0	No displacement unless rm=6 in which
				case this is direct mode with 2 bytes.
				( Arg is code or data, no indexing )

			1	Memory, 8 bit sign extended displace-
				ment.( Using indexing, Rconst )

			2	Memory, 16 bit displacement.( Using
				indexing, Rconst type )

			3	Register, rm is register code, not
				indexing mode.( Was REGresult )

			4	Immediate mode.( arg was Rconst, no
				indexing )

			386 modes are represented in an analogous way:
			
			3	Register, rm is register code, as above

			4	Immediate, as above

			5	No displacement indirect, unless rm=5,
				in which case this is a direct mode with
				4 byte offset.

			6	Memory, 8 bit signed displacement

			7	Memory, 32 bit signed displacement

			similarly, scaled modes are indicated with
			the next group.  if mode > 7, then rm contains
			the value of the Scaled Index Byte (SIB) and
			rm is implicitly 4.

			8	No displacement indirect, unless rm=5,
				in which case this is a direct mode with
				4 byte offset.

			9	Memory, 8 bit signed displacement

			10	Memory, 32 bit signed displacement

		rm   :: Value 0..7 Corresponds to 8086 or 80386 r/m

		      Value	Register	Index		386 index
			0	AX  AL	EAX	[BX][SI]	[EAX]
			1	CX  CL	ECX	[BX][DI]	[ECX]
			2	DX  DL	EDX	[BP][SI]	[EDX]
			3	BX  BL	EBX	[BP][DI]	[EBX]
			4	SP  AH	ESP	[SI]		not implemented
			5	BP  CH	EBP	[DI]		Direct or [EBP]
			6	SI  DH	ESI	Direct or [BP]	[ESI]
			7	DI  BH	EDI	[BX]		[EDI]

			Ridx contained pointer to index reg( DI | SI )
			Rbas contained pointer to base	reg( BX | BP )
			Both were NIL if no indexing.
			386 registers have 8 added to them while in
			the ar structure's base and index fields.
			this is so we can tell eax from no register
			at all.


		w    :: Boolean  Corresponds to 8086 w flag. TRUE if
			word mode, FALSE if byte mode.

		s    :: TRUE if value is -128..+127
		Dsize	::	Size of var/label or PTR value


		FIXtype ::	Type of fixup to feed to EMITxxx
				routines:

				Fpointer	Label is FAR
				Foffset 	Word, not constant
				Fbaseseg	SEG or seg/group name
				Fgroupseg	Offset to group
				Fconstant	Immediate data
				Fhigh		Take high of offset
				Flow		Take low of offset
				Fnone		No fixup( register )

		Dtype	::	Kind of value. Seg,group, const, Data
		Dflag	::	Value attr, undef,?,extern,forw,...
		Doffset ::	16 bit value of result

		Dsegment::	Copy of Dsegment. Pointer to segment of
				result. If NIL, is constant. Will point
				to segment name or possibly name of
				external if external with no segment.

		Dcontext::	Copy of Dcontext. Pointer to segment
				from which to calculate offset. If :
				OPERATOR used, Dcontext will be left
				arg. If result is code label, will be
				CS assume at time of label define. Else
				will be NIL and then filled in with
				segment register assume that contains
				Dsegment.

		seg ::		Segment register of override. If none
				given, will be 4. If register is not
				known, will be 5.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asminp.c ===
/* asminp.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#define ASMINP		/* prevent external declaration of _asmctype_ */

#include <stdio.h>
#include <io.h>
#include <dos.h>
#include <share.h>
#include <memory.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmmsg.h"
#include "asmfcn.h"
#include <fcntl.h>

extern void closefile(void);

#define DEBFLAG F_INP

#if defined CPDOS && !defined OS2_2 && !defined OS2_NT
unsigned short _far _pascal DosRead( unsigned short, unsigned char far *, unsigned short, unsigned short far *);
#endif


VOID PASCAL getphysline (void);
SHORT PASCAL CODESIZE readmore (void);
SHORT PASCAL CODESIZE incomment( char * );

extern	UCHAR _asmctype_[];
extern	char  _asmcupper_[];
extern	char  _asmTokenMap_[];


/***	skipblanks - skip blanks
 *
 *	skipblanks ()
 *
 *	Returns - the terminating character
 */


#ifndef M8086OPT

UCHAR CODESIZE
skipblanks ()
{
	while (ISBLANK (NEXTC ()))
		;
	return(*--lbufp);
}

#endif


/***	scanatom - extract next atom into name
 *
 *	hash = scanatom (pos)
 *
 *	Entry	pos = SCEND  if position at first character after token
 *		      SCSKIP if position before terminator and not set delim
 *	Exit	naim.pszName = next token zero terminated
 *		       upper case if caseflag = CASEU or CASEX
 *		       case read from file if caseflag = CASEL
 *		naim.pszLowerCase = name in case read from file
 *		naim.usHash = hash value of token in naim.pszName
 *		naim.ucCount = length of string
 *		begatom = pointer to first character of token
 *		endatom = pointer to character after end of token
 *	Returns void
 *	Calls	skipblanks
 */

#ifndef M8086OPT

#define rNEXTC()	(*rlbp++)
#define rPEEKC()	(*rlbp)
#define rBACKC()	(rlbp--)
#define rSKIPC()	(rlbp++)


SHORT PASCAL CODESIZE
scanatom (
	char pos
){
	register char *ptr = naim.pszName;
	register char *lptr = naim.pszLowerCase;
	register char *rlbp = lbufp;
	register char cc;
	register char *n;
	register SHORT h;
	long  tokLen;

	while (ISBLANK (rNEXTC ()))
		;
	rBACKC ();
	h = 0;
	/* Start of atom */
	begatom = rlbp;
	if (LEGAL1ST (rPEEKC ())) {
		n = lptr + SYMMAX;
		cc = rNEXTC ();
		if( cc == '.' ){  /* Special case token starting with dot */
		    h = *ptr++ = *lptr++ = cc;
		    cc = rNEXTC ();
		}
		if (caseflag == CASEL)

			do {
			   h += MAP(*ptr++ = *lptr++ = cc);
			 } while (TOKLEGAL( cc = rNEXTC() ) && lptr < n);
		else
			do {
			   h += (*ptr++ = MAP( *lptr++ = cc ));
			} while (TOKLEGAL( cc = rNEXTC() ) && lptr < n);

		if (TOKLEGAL (cc))
			/* Atom longer than table entry, discard remaining chars */
			while (TOKLEGAL (cc = rNEXTC ()))
				;
		rBACKC ();
		endatom = rlbp;
		if (ISBLANK (cc) && pos != SCEND) {	/* skipblanks() */
			while (ISBLANK (rNEXTC ()))
				;
			rBACKC ();
		}
	}
	*ptr = *lptr = '\0';
	naim.ucCount = (unsigned char)(lptr - naim.pszLowerCase);
	naim.usHash = h;
	lbufp = rlbp;
	tokLen = (long)(lptr - naim.pszLowerCase);    /* Using tokLen gets around a C386 6.00.60 bug */
	return( (SHORT) tokLen );  /* Return length of token */
}

#endif /* M8086OPT */




/***	readfile - read from input or include file
 *
 *	ptr = readfile ();
 *
 *	Entry	none
 *	Exit	lbuf = next input line
 *		lbufp = start of lbuf
 *		line counter for file incremented
 *		linessrc incremented
 *	Returns pointer to end of line
 *	Calls	error
 */


VOID PASCAL CODESIZE
readfile ()
{
	register FCB * pFCBT;

	getline();

	pFCBCur->line++;

	if (srceof) {

	    if (!pFCBCur->pFCBParent) {
		    errorc (E_EOF);
		    fprintf (ERRFILE,__NMSG_TEXT(ER_EO2));

		    if (fSimpleSeg && pcsegment)
			endCurSeg();

		    longjmp(forceContext, 1);

	    } else {

		popcontext = TRUE;

		closefile();

		if (crefing && pass2)
		    fprintf( crf.fil, "%s", pFCBCur->fname );
	    }
	    srceof = 0;
	}
	else
	    linessrc++;
}




/***	getline - read from input or include file
 *
 *	getline()
 *
 *	Returns in lbuf the next complete logical line. A logical line
 *	may consist of one or more lines connected via the \ continuation
 *	character.  This is done as follows. Data is copied from
 *	pFCBCur->tmpbuf. If necessary more data is copied into the
 *	buffer via readmore(). After an entire physical line is read
 *	it is tested as to whether the line is continued on the next
 *	physical line. If not the line is returned in lbuf. Otherwise
 *	the physical line is copied to linebuffer and a call to listline
 *	is made. At which point another physical line is cancatenated
 *	to the line or lines already in lbuf.
 *
 *	Entry	pFCBCur = File currently reading from.
 *		pFCBCur->ctmpbuf = Number of bytes available in buffer
 *				   0 = necessary to read data from disk.
 *		pFCBCur->ptmpbuf = Next position in buffer to copy from.
 *		pFCBCur->line	 = Number of physical line in file
 *
 *	Exit  - lbuf[] holds a complete logical line, with a space appended.
 *	      - linebuffer[] holds last physical line.
 *	      -	lbufp points to the beginning of lbuf.
 *	      - linebp points to null terminator at the end
 *		of the logical line in lbuf.
 *	      -	linelength is number of bytes of last physical line.
 *	      -	pFCBCur->ctmpbuf & ptmpbuf & line are updated.
 *	      -	srceof is true if the end of file was encountered, in
 *		which case the physical line is a null string, and
 *		the logical line is a single space character.
 */

VOID CODESIZE
getline()
{
	char FAR	*p;
	register char	*pchTmp;
	char		*pchPhysLine;
	INT		fFoundEOL;  /* True, if endof line copied */
	register INT	count;
	INT		fLineContinued;
	INT		fGotSome;

	lbufp = lbuf;	 /* Init lbufp for other routines */
	pchPhysLine = lbuf;
	fGotSome = FALSE; // nothing seen yet
	errorlineno = pFCBCur->line + 1;
	pchTmp = lbuf;	 // Where to copy the line

	//if( pFCBMain->line == 126-1 ){
	//    _asm int 3
	//}

	do{

	    fFoundEOL = FALSE;
	    do{

		/* If the buffer is empty fill it */
		if( !pFCBCur->ctmpbuf ){
		    if( readmore() ){	 // TRUE if at EOF
			if( !fGotSome ){
			    srceof = TRUE;
			    linebuffer[0] = '\0';
			    linelength = 0;
			    linebp = lbuf;
			    lbuf[0] = '\0';
			    return;
			}else{
			    pchTmp++;  /* Negate pchTmp-- following this loop */
			    break;    /* Break fFoundEOL loop */
			}
		    }
		}
		fGotSome = TRUE;

		/* Find next LF in buffer */
		p = _fmemchr( pFCBCur->ptmpbuf, '\n', pFCBCur->ctmpbuf );
		if( p ){  /* If LF was found */
		    count = (int)((p - pFCBCur->ptmpbuf) + 1);
		    fFoundEOL = TRUE;
		}else{
		    count = pFCBCur->ctmpbuf;
		}

		/* Check if physical or logical line too long */
		if( (pchTmp - lbuf) + count >= LBUFMAX ||
		    (pchTmp - pchPhysLine) + count >= LINEMAX-4 ){

		    /* Update the position in the buffer */
		    pFCBCur->ptmpbuf += count;	// Update where copying from
		    pFCBCur->ctmpbuf -= (USHORT)count;

		    errorc( E_LNL );	    /* Log the error */

		    /* Return a null string line */
		    linebuffer[0] = '\0';
		    linelength = 0;
		    linebp = lbuf;
		    lbuf[0] = ' ';
		    lbuf[1] = '\0';
		    return;
		}else{
		    /* Copy the line, and update pointers */
		    fMemcpy( pchTmp, pFCBCur->ptmpbuf, count );
		    pchTmp += count;	    // Update where copying to
		    pFCBCur->ctmpbuf -= (USHORT)count;	// Update # bytes left in buffer
		    pFCBCur->ptmpbuf += count;	// Update where copying from
		}

	    }while( !fFoundEOL );

	    pchTmp--; /* Move back to last character (LF) */


/* Strip Carriage Returns that precede LFs */
	    if( *(pchTmp-1) == '\r' ){
		pchTmp--; /* Throw out Carriage return */
	    }

#ifdef MSDOS
    /* Strip Multiple Control-Zs */
	    while( *(pchTmp - 1) == 0x1A ){  /* Check for ^Z */
		pchTmp--;
	    }
#endif
	    if( pchTmp < lbuf ){   /* Remotely possible if Blank line */
		pchTmp = lbuf;
	    }

	    linelength = (unsigned char)(pchTmp - pchPhysLine);
	    if( !pass2 || listconsole || lsting ){
		memcpy( linebuffer, pchPhysLine, linelength );
	    }
	    *( linebuffer + linelength ) = '\0'; //Null terminate the physical line

	    if( *(pchTmp - 1) == '\\' && !incomment( pchTmp ) ){
		pchPhysLine = --pchTmp;  /* Overwrite the '\' */
		fCrefline = FALSE;
		listline();
		fCrefline = TRUE;
		pFCBCur->line++;	/* Line count it physical line count */
		fLineContinued = TRUE;
	    }else{
		fLineContinued = FALSE;
	    }
	}while( fLineContinued );
	*pchTmp++ = ' ';	    /* Replace line feed with space */
	*pchTmp = '\0';		    /* Null terminate line */
	linebp = pchTmp;
	if( lbuf[0] == 12 ){	    /* Overwrite leading ctrl-L with space */
	    lbuf[0] = ' ';
	}
	/* At this point linebp - lbuf == strlen( lbuf )	*/
}

/***	readmore - read from disk into buffer
 *
 *
 *
 *	Entry	pFCBCur = File currently reading from.
 *		pFCBCur->cbbuf = Size of buffer to read into.
 *		pFCBCur->buf = Address of buffer to read into.
 *		pFCBCur->fh = File handle to read from.
 *
 *	Exit	return = TRUE: Not at end of file
 *		   pFCBCur->ptmpbuf = First byte of buffer.
 *		   pFCBCur->ctmpbuf = Number of bytes in buffer.
 *		return = FALSE: At end of file
 *		   No other variables changed.
 */

SHORT PASCAL CODESIZE
readmore ()
{
	SHORT		cb;
	SHORT		fEOF = FALSE;

	/* If the file has been temporarily closed reopen it */
	if( pFCBCur->fh == FH_CLOSED ){
	    if( (pFCBCur->fh = tryOneFile( pFCBCur->fname )) == -1 ){	 /* Open the file */
		TERMINATE1(ER_ULI, EX_UINP, save);  /* Report unable to access file */
	    }
	    /* Seek to old position */
	    if( _lseek( pFCBCur->fh, pFCBCur->savefilepos, SEEK_SET ) == -1L ){
		TERMINATE1(ER_ULI, EX_UINP, save);  /* Report unable to access file */
	    }
	}

#if !defined CPDOS || defined OS2_2 || defined OS2_NT
        cb = (SHORT)_read( pFCBCur->fh, pFCBCur->buf, pFCBCur->cbbuf );
#else
	if( DosRead( pFCBCur->fh, pFCBCur->buf, pFCBCur->cbbuf, &cb ) ){
	    cb = -1;
	}
#endif
	if( cb == 0 ){
	    fEOF = TRUE;	/* End of file found */
	}else if( cb == (SHORT)-1 ){
	    TERMINATE1(ER_ULI, EX_UINP, save);	/* Report unable to access file error */
	}else{
	    /* Setup the buffer pointers */
	    pFCBCur->ptmpbuf = pFCBCur->buf;  /* Init ptr to start of buffer */
	    pFCBCur->ctmpbuf = cb;
	}
	return( fEOF );
}




/***	incomment - Checks a line ending in \ to determine if the \ is in a
 *		    comment and is therefore not a comment line.
 *
 *	Entry	Assumes lbuf contains partial logical line ending in a \.
 *		pchEnd - points within lbuf to the terminating LF.
 *	Methode Checks that line is not in a COMMENT directive's scope.
 *		Then checks if the line contains a semicolon. If not, \
 *		IS continuation. If a semicolon is found, line must be
 *		scanned carefully to determine if the semicolon is a
 *		comment delimeter or is in a string or is a character
 *		constant If it is not a comment delimeter, \ IS continuation.
 *		Otherwise, \ is part of comment, and is NOT a continuation.
 *	Exit	Returns true if the \ is in a comment
 *		Returns false if the \ is not in a comment, and is therefore
 *		a continuation character.
 *
 *	Calls	memchr
 *
 *	Created: 9/90 - Jeff Spencer, translated from asm code in asmhelp.asm
 */

SHORT PASCAL CODESIZE
incomment(
	char * pchTmp	   /* Points to terminating LF in lbuf */
){
    SHORT		fContSearch;
    unsigned char *	pchSearch;
    unsigned char *	pchSemi;
    unsigned char	chClose;
    static unsigned char szComment[] = "COMMENT";



    pchTmp--;	    /* Point to '\' character */
    if( handler == HCOMMENT ){	    /* If within comment directive */
	return( TRUE );
    }

    fContSearch = TRUE;
    pchSearch = lbuf;

    do{
	if( pchSemi = memchr( pchSearch, ';', (size_t)(pchTmp - pchSearch) )){	/* Check for a semicolon */
	    do{
		chClose = '\0';
		switch( *pchSearch++ ){
		  case ';':
		    /* Semicolon is not in quotes, return in comment */
		    return( TRUE );
		  case '\"':
		    chClose = '\"';
		    break;
		  case '\'':
		    chClose = '\'';
		    break;
		  case '<':
		    chClose = '>';
		    break;
		}
		/* Below the word quote is used to mean the chClose character */
		if( chClose ){
		    if( !(pchSearch = memchr( pchSearch, chClose, (size_t)(pchTmp - pchSearch) ) ) ){
			fContSearch = FALSE; /* No matching quote, not a comment */
		    }else{
			if( pchSearch < pchSemi){
			    /* Semicolon is in quotes */
			    pchSearch++; /* Move past quote just found
			    break;  // Look for another semicolon */
			}else{
			    /* Semicolon is past this set of quotes */
			    /* Continue, Scanning */
			}
		    }
		}
	    }while( fContSearch && pchSearch < pchTmp );
	}else{
	    /* No Semicolon in the line, or it's in quotes  */
	    fContSearch = FALSE;
	}
    }while( fContSearch );

    /* At this point we know that the \ is not in a semicolon	**
    ** delimited comment. However, we still have to make sure	**
    ** that the comment keyword doesn't appear at the begining  **
    ** of the line.						*/

    /* Skip leading white space */
    pchSearch = lbuf;
    while( *pchSearch == ' ' || *pchSearch == '\t' ){
	pchSearch++;
    }
    for( pchTmp = szComment; *pchTmp; ){
	if( *pchSearch++ != _asmTokenMap_[*pchTmp++] ){
	    return( FALSE );	    /* First word isn't "comment" */
	}
    }
    return( TRUE ); /* comment keyword at start of line, return in comment */
}

/****	closeFile
 *
 *	closeFile ()
 *
 *	Entry	Assumes valid pFCBCur->fh or FH_CLOSED
 *	Returns
 *	Calls	close()
 *	Note	Closes current file - i.e.  pFCBCur
 *		and marks all fields in pFCBCur appropriately
 */

void closefile(void)
{
    register FCB *pFCBOld;

    #ifdef BCBOPT
    BCB * pBCBT;

    if ((pBCBT = pFCBCur->pBCBCur) && pBCBT->pbuf)
	pBCBT->filepos = 0;			/* EOF */
    #endif

    if( pFCBCur->fh != FH_CLOSED ){   /* Check to see if the file is already closed */
         _close(pFCBCur->fh);
    }
    pFCBOld = pFCBCur;
    pFCBCur = pFCBCur->pFCBParent;  /* Remove from bidirectional linked list */
    pFCBCur->pFCBChild = NULL;

    _ffree( pFCBOld->buf);  /* Free FCB buffer */
    _ffree( (UCHAR *)pFCBOld );      /* Free FCB */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmindex.h ===
/* asmindex.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

/* indices of opcodes */

#define I_AAA           0
#define I_AAD           1
#define I_AAM           2
#define I_AAS           3
#define I_ADC           4
#define I_ADD           5
#define I_AND           6
#define I_CALL          7
#define I_CBW           8
#define I_CLC           9
#define I_CLD           10
#define I_CLI           11
#define I_CMC           12
#define I_CMP           13
#define I_CMPS          14
#define I_CMPSB         15
#define I_CMPSW         16
#define I_CWD           17
#define I_DAA           18
#define I_DAS           19
#define I_DEC           20
#define I_DIV           21
#define I_ESC           22
#define I_HLT           23
#define I_IDIV          24
#define I_IMUL          25
#define I_IN            26
#define I_INC           27
#define I_INT           28
#define I_INTO          29
#define I_IRET          30
#define I_JA            31
#define I_JAE           32
#define I_JB            33
#define I_JBE           34
#define I_JC            35
#define I_JCXZ          36
#define I_JE            37
#define I_JG            38
#define I_JGE           39
#define I_JL            40
#define I_JLE           41
#define I_JMP           42
#define I_JNA           43
#define I_JNAE          44
#define I_JNB           45
#define I_JNBE          46
#define I_JNC           47
#define I_JNE           48
#define I_JNG           49
#define I_JNGE          50
#define I_JNL           51
#define I_JNLE          52
#define I_JNO           53
#define I_JNP           54
#define I_JNS           55
#define I_JNZ           56
#define I_JO            57
#define I_JP            58
#define I_JPE           59
#define I_JPO           60
#define I_JS            61
#define I_JZ            62
#define I_LAHF          63
#define I_LEA           64
#define I_LES           65
#define I_LDS           66
#define I_LOCK          67
#define I_LODS          68
#define I_LODSB         69
#define I_LODSW         70
#define I_LOOP          71
#define I_LOOPE         72
#define I_LOOPNE        73
#define I_LOOPNZ        74
#define I_LOOPZ         75
#define I_MOV           76
#define I_MOVS          77
#define I_MOVSB         78
#define I_MOVSW         79
#define I_MUL           80
#define I_NEG           81
#define I_NOP           82
#define I_NOT           83
#define I_OR            84
#define I_OUT           85
#define I_POP           86
#define I_POPF          87
#define I_PUSH          88
#define I_PUSHF         89
#define I_RCL           90
#define I_RCR           91
#define I_REP           92
#define I_REPE          93
#define I_REPNE         94
#define I_REPNZ         95
#define I_REPZ          96
#define I_RET           97
#define I_ROL           98
#define I_ROR           99
#define I_SAHF          100
#define I_SAL           101
#define I_SAR           102
#define I_SBB           103
#define I_SCAS          104
#define I_SCASB         105
#define I_SCASW         106
#define I_SHL           107
#define I_SHR           108
#define I_STC           109
#define I_STD           110
#define I_STI           111
#define I_STOS          112
#define I_STOSB         113
#define I_STOSW         114
#define I_SUB           115
#define I_TEST          116
#define I_WAIT          117
#define I_XCHG          118
#define I_XLAT          119
#define I_XLATB         120
#define I_XOR           121
#define I_ARPL          122
#define I_BOUND         123
#define I_CLTS          124
#define I_ENTER         125
#define I_INS           126
#define I_INSB          127
#define I_INSW          128
#define I_LAR           129
#define I_LEAVE         130
#define I_LGDT          131
#define I_LIDT          132
#define I_LLDT          133
#define I_LMSW          134
#define I_LSL           135
#define I_LTR           136
#define I_OUTS          137
#define I_OUTSB         138
#define I_OUTSW         139
#define I_POPA          140
#define I_PUSHA         141
#define I_SGDT          142
#define I_SIDT          143
#define I_SLDT          144
#define I_SMSW          145
#define I_STR           146
#define I_VERR          147
#define I_VERW          148
#define I_F2XM1         149
#define I_FABS          150
#define I_FADD          151
#define I_FADDP         152
#define I_FBLD          153
#define I_FBSTP         154
#define I_FCHS          155
#define I_FCLEX         156
#define I_FCOM          157
#define I_FCOMP         158
#define I_FCOMPP        159
#define I_FDECSTP       160
#define I_FDISI         161
#define I_FDIV          162
#define I_FDIVP         163
#define I_FDIVR         164
#define I_FDIVRP        165
#define I_FENI          166
#define I_FFREE         167
#define I_FIADD         168
#define I_FICOM         169
#define I_FICOMP        170
#define I_FIDIV         171
#define I_FIDIVR        172
#define I_FILD          173
#define I_FIMUL         174
#define I_FINCSTP       175
#define I_FINIT         176
#define I_FIST          177
#define I_FISTP         178
#define I_FISUB         179
#define I_FISUBR        180
#define I_FLD           181
#define I_FLD1          182
#define I_FLDCW         183
#define I_FLDENV        184
#define I_FLDL2E        185
#define I_FLDL2T        186
#define I_FLDLG2        187
#define I_FLDLN2        188
#define I_FLDPI         189
#define I_FLDZ          190
#define I_FMUL          191
#define I_FMULP         192
#define I_FNCLEX        193
#define I_FNDISI        194
#define I_FNENI         195
#define I_FNINIT        196
#define I_FNOP          197
#define I_FNSAVE        198
#define I_FNSTCW        199
#define I_FNSTENV       200
#define I_FNSTSW        201
#define I_FPATAN        202
#define I_FPREM         203
#define I_FPTAN         204
#define I_FRNDINT       205
#define I_FRSTOR        206
#define I_FSAVE         207
#define I_FSCALE        208
#define I_FSQRT         209
#define I_FST           210
#define I_FSTCW         211
#define I_FSTENV        212
#define I_FSTP          213
#define I_FSTSW         214
#define I_FSETPM        215
#define I_FSUB          216
#define I_FSUBP         217
#define I_FSUBR         218
#define I_FSUBRP        219
#define I_FTST          220
#define I_FWAIT         221
#define I_FXAM          222
#define I_FXCH          223
#define I_FXTRACT       224
#define I_FYL2X         225
#define I_FYL2XP1       226
#define I_FNRSTOR       227

#ifdef V386

#define I_MOVSX         228
#define I_MOVZX         229
#define I_CWDE          230
#define I_CDQ           231
#define I_LFS           232
#define I_LGS           233
#define I_LSS           234
#define I_SHLD          235
#define I_SHRD          236
#define I_CMPSD         237
#define I_INSD          238
#define I_LODSD         239
#define I_MOVSD         240
#define I_OUTSD         241
#define I_SCASD         242
#define I_STOSD         243
#define I_BSF           244
#define I_BSR           245
#define I_BT            246
#define I_BTC           247
#define I_BTR           248
#define I_BTS           249
#define I_IBTS          250
#define I_XBTS          251
#define I_JECXZ         252
#define I_SETO          253
#define I_SETNO         254
#define I_SETB          255
#define I_SETNAE        256
#define I_SETNB         257
#define I_SETAE         258
#define I_SETE          259
#define I_SETZ          260
#define I_SETNE         261
#define I_SETNZ         262
#define I_SETBE         263
#define I_SETNA         264
#define I_SETNBE        265
#define I_SETA          266
#define I_SETS          267
#define I_SETNS         268
#define I_SETP          269
#define I_SETPE         270
#define I_SETNP         271
#define I_SETPO         272
#define I_SETL          273
#define I_SETNGE        274
#define I_SETC          275
#define I_SETNC         276
#define I_SETLE         277
#define I_SETNG         278
#define I_SETNL         279
#define I_SETGE         280
#define I_SETNLE        281
#define I_SETG          282
#define I_PUSHAD        283
#define I_POPAD         284
#define I_POPFD         285
#define I_PUSHFD        286
#define I_IRETD         287
#define I_FUCOM         288
#define I_FUCOMP        289
#define I_FUCOMPP       290
#define I_FPREM1        291
#define I_FCOS          292
#define I_FSIN          293
#define I_FSINCOS       294
#define I_RETN          295
#define I_RETF          296

#else

#define I_RETN          228
#define I_RETF          229

#endif

/* indices for size table */

#define I_BYTE          0
#define I_DWORD         1
#define I_FAR           2
#define I_NEAR          3
#define I_QWORD         4
#define I_TBYTE         5
#define I_WORD          6
#define I_FWORD         7
#define I_PROC          8


/* indices for first tokens */

#define I_TASSUME       0
#define I_TCOMMENT      1
#define I_TDB           2
#define I_TDD           3
#define I_TDQ           4
#define I_TDT           5
#define I_TDW           6
#define I_TELSE         7
#define I_TEND          8
#define I_TENDIF        9
#define I_TENDM         10
#define I_TERR          11
#define I_TERR1         12
#define I_TERR2         13
#define I_TERRB         14
#define I_TERRDEF       15
#define I_TERRDIF       16
#define I_TERRE         17
#define I_TERRNZ        18
#define I_TERRIDN       19
#define I_TERRNB        20
#define I_TERRNDEF      21
#define I_TEVEN         22
#define I_TEXITM        23
#define I_TEXTRN        24
#define I_TIF           25
#define I_TIF1          26
#define I_TIF2          27
#define I_TIFB          28
#define I_TIFDEF        29
#define I_TIFDIF        30
#define I_TIFE          31
#define I_TIFIDN        32
#define I_TIFNB         33
#define I_TIFNDEF       34
#define I_TINCLUDE      35
#define I_TIRP          36
#define I_TIRPC         37
#define I_TLOCAL        38
#define I_TNAME         39
#define I_TORG          40
#define I_TPAGE         41
#define I_TPUBLIC       42
#define I_TPURGE        43
#define I_TREPT         44
#define I_TSUBTTL       45
#define I_TTITLE        46
#define I_TCREF         47
#define I_TLALL         48
#define I_TLFCOND       49
#define I_TLIST         50
#define I_TRADIX        51
#define I_TSALL         52
#define I_TSFCOND       53
#define I_TTFCOND       54
#define I_TXALL         55
#define I_TXCREF        56
#define I_TXLIST        57
#define I_TOUT          58
#define I_TALIGN        59
#define I_T8086         60
#define I_T8087         61
#define I_T287          62
#define I_T186          63
#define I_T286C         64
#define I_T286P         65
#define I_TINCLIB       66
#define I_TMSTACK       67
#define I_TDOSSEG       68
#define I_TMODEL        69
#define I_TCODE         70
#define I_TDATA         71
#define I_TDATAQ        72
#define I_TCONST        73
#define I_TFARDATA      74
#define I_TFARDATAQ     75
#define I_TSEQ          76
#define I_TALPHA        77
#define I_TCOMM         78
#define I_TIFDIFI       79
#define I_TIFIDNI       80
#define I_TERRDIFI      81
#define I_TERRIDNI      82
#define I_TELSEIF       83
#define I_TELSEIF1      84
#define I_TELSEIF2      85
#define I_TELSEIFB      86
#define I_TELSEIFDEF    87
#define I_TELSEIFDIF    88
#define I_TELSEIFE      89
#define I_TELSEIFIDN    90
#define I_TELSEIFNB     91
#define I_TELSEIFNDEF   92
#define I_TELSEIFDIFI   93
#define I_TELSEIFIDNI   94
#define I_TFPO          99

#ifdef V386
#define I_T386C         95
#define I_T386P         96
#define I_T387          97
#define I_TDF           98
#endif

/* indices for second tokens */

#define I2_TDB          0
#define I2_TDD          1
#define I2_TDQ          2
#define I2_TDT          3
#define I2_TDW          4
#define I2_TENDP        5
#define I2_TENDS        6
#define I2_TEQU         7
#define I2_TSUBSTR      8
#define I2_TCATSTR      9
#define I2_TSIZESTR     10
#define I2_TINSTR       11
#define I2_TGROUP       12
#define I2_TLABEL       13
#define I2_TMACRO       14
#define I2_TPROC        15
#define I2_TRECORD      16
#define I2_TSEGMENT     17
#define I2_TSTRUC       18

#ifdef V386
#define I2_TDF          19
#endif

/* indices for segment attributes */

#define IS_AT           0
#define IS_BYTE         1
#define IS_COMMON       2
#define IS_MEMORY       3
#define IS_PAGE         4
#define IS_PARA         5
#define IS_PUBLIC       6
#define IS_STACK        7
#define IS_WORD         8
#define IS_DWORD        9

#ifdef V386
#define IS_USE32        10
#define IS_USE16        11
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmlst.c ===
/* asmlst.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmmsg.h"

#define setpassed(sym)	(sym)->attr |= (M_PASSED)

VOID PASCAL CODESIZE listPuts(char *);

#ifdef BCBOPT
extern UCHAR fNoCompact;
#endif

char fBigNum;

/* size names */


static char byte[] = "BYTE";
static char word[] = "WORD";
static char dword[] = "DWORD";
static char none[] = "NONE";
char hexchar[] = "0123456789ABCDEF";

char *siznm[] = {
		 0,
		 byte,
		 word,
		 0,
		 dword,
		 0,
		 "FWORD",
		 0,
		 "QWORD",
		 0,
		 "TBYTE",
		 "NEAR",
		 "FAR",
};

char *alignName[] = {
	"AT",
	byte,
	word,
	"PARA",
	"PAGE",
	dword
};

char *combineName[] = {
	none,
	"MEMORY",		   /* Memory is mapped to PUBLIC in fnspar */
	"PUBLIC",
	0,
	0,
	"STACK",
	"COMMON",
	none
};

char headSegment[] = "Segments and Groups:";

static char *head1[] = {
			headSegment,
			"Symbols:            ",
			headSegment
		       };

char headSeg[] =  "\tSize\tLength\t Align\tCombine Class";

static char *head2[] = {
			&headSeg[5],
			"\tType\t Value\t Attr",
			headSeg
		       };

/***	offsetAscii - display dword in hex
 *
 *	offsetAscii(v);
 *
 *	Entry	v = dword to be displayed
 *	Exit	objectascii = converted value of v zero terminated
 *	Returns none
 *	Calls
 */


VOID PASCAL
offsetAscii (
	OFFSET	v
){
	register USHORT t;
	register char *p = objectascii;

#ifdef V386

	if (highWord(v)) {

	    t = highWord(v);
	    p[3] = hexchar[t & 15];
	    t >>= 4;
	    p[2] = hexchar[t & 15];
	    t >>= 4;
	    p[1] = hexchar[t & 15];
	    t >>= 4;
	    p[0] = hexchar[t & 15];
	    p += 4;

	}
#endif
	p[4] = 0;

	t = (USHORT)v;
	p[3] = hexchar[t & 15];
	t >>= 4;
	p[2] = hexchar[t & 15];
	t >>= 4;
	p[1] = hexchar[t & 15];
	p[0] = hexchar[(t >> 4) & 15];
}




/***	dispsym - display symbol
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
dispsym (
	USHORT	indent,
	SYMBOL FARSYM	  *sym
){
register char *p = listbuffer;

	strcpy (p, " . . . . . . . . . . . . . . . .  \t");
	while (indent--)
		*p++ = ' ';
	if (caseflag == CASEX && (sym->attr & (M_GLOBAL | M_XTERN)))
		strcpy (p, sym->lcnamp->id);
	else
		STRNFCPY (p, sym->nampnt->id);

	p[STRFLEN (sym->nampnt->id)] = ' ';
	listPuts (listbuffer);
}




/***	dispword - display word value in current radix
 *
 *	dispword (v);
 *
 *	Entry	v = value to display
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
dispword (
	OFFSET	v
){
	/* Convert value to text */
	offsetAscii (v);
	if (symptr->symkind == EQU && symptr->symu.equ.equrec.expr.esign)
		listPuts ("-");

	listPuts(objectascii);
	fBigNum = objectascii[4];	 /* remember if you put a 8 digit # */
}




/***	chkheading - display heading if needed
 *
 *	chkheading (code);
 *
 *	Entry	code = index to heading to be printed
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
chkheading (
	USHORT	code
){
	if (!listed && lsting) {
		if (pagelength - pageline < 8)
			pageheader ();
		else
			skipline ();
		listPuts (head1[code]);
		skipline ();
		skipline ();
		listPuts("                N a m e         ");
		listPuts(head2[code]);
		skipline ();
		skipline ();
		listed = TRUE;
	}
}




/***	disptab - output tab character to listing
 *
 *	disptab ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
disptab ()
{
	putc ((fBigNum)? ' ': '\t', lst.fil);
	fBigNum = FALSE;
}




/***	skipline - output blank line
 *
 *	skipline ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
skipline ()
{
	fputs(NLINE, lst.fil);
	bumpline ();
}




/***	bumpline - bump line count
 *
 *	bumpline ();
 *
 *	Entry	pageline = current line number
 *		pagelength = number of lines per page
 *	Exit	pageline incremented
 *		new page started if pageline > pagelength
 *	Returns none
 *	Calls	pageheader
 */


VOID PASCAL
bumpline ()
{
	pageline++;
	if (pagelength <= pageline)
		pageheader ();
}




/***	newpage - start newpage
 *
 *	newpage ();
 *
 *	Entry	none
 *	Exit	pagemajor incremented
 *		pageminor = 0
 *		pageline set to pagelength - 1
 *	Returns none
 *	Calls	none
 */


VOID PASCAL
newpage ()
{
	pagemajor++;
	pageminor = 0;
	pageline = pagelength - 1;
}




/***	pageheader - output page header
 *
 *	pageheader ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL
pageheader ()
{
	if (lsting) {
		pageminor++;
		pageline = 4;
#if defined MSDOS && !defined FLATMODEL
		atime[20] = '\0';   /* get rid of '\n' */
#else
		atime[24] = '\0';   /* get rid of '\n' */
#endif
		fprintf (lst.fil, "\f\b%s%s" NLINE "%s", titlefn, atime + 4, titlebuf);
		if (pagemajor == 0)
			listPuts("Symbols");
		else {
			fprintf (lst.fil, "Page %5hd", pagemajor);
		}
		if (pageminor)
			fprintf (lst.fil, "-%hd", pageminor);

		fprintf (lst.fil, NLINE "%s" NLINE NLINE, subttlbuf);
	}
}




/***	testlist - test for listing of line
 *
 *	testlist ()
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


UCHAR PASCAL CODESIZE
testlist ()
{
	if (fPass1Err)
	    /* list pass 1 errors regardless of listing status */
	    return (TRUE);

	if (pass2 || debug) {

	    if (errorcode)
		/* list error in pass 2 regardless of listing status */
		return (TRUE);

	    if (fSkipList) {
		fSkipList = FALSE;
		return (FALSE);
	    }

	    if (loption)
		return (TRUE);

	    /* list line in pass 1 or pass 2 if listing enabled */

	    if (listflag &&
	       (generate || condflag) &&
		(!macrolevel ||
		  expandflag == LIST ||
		 !(expandflag == SUPPRESS ||
		   expandflag == LISTGEN &&
		    (listbuffer[1] == '=' || listbuffer[1] == ' ') &&
		    handler != HSTRUC)) )

		return (TRUE);

	 }
	 return (FALSE);
}


/***	listline - list line on device for user
 *
 *	listline ();
 *
 *	Entry	listbuffer = object part of line
 *		linebuffer = source line
 *		crefcount = cross reference line count
 *	Exit	crefcount incremented
 *	Returns none
 *	Calls
 */


VOID PASCAL
listline ()
{
	register char *p;
	char *q;
	char *r;
	register SHORT	 i;
	register SHORT	 j;
	register SHORT	 k;

#ifdef BCBOPT
	if (errorcode)
	    goodlbufp = FALSE;
#endif

	crefline ();

	if (testlist ()) {
	    if (listconsole || lsting) {

		    p = listbuffer + LISTMAX - 3;

#ifdef	FEATURE
#ifdef	BCBOPT
		    if (fNoCompact)
#endif
			*p++ = '\\';

		    else {
			if (pFCBCur->pFCBParent)
			    *p++ = 'C';
			if (macrolevel)
			    *p = (macrolevel > 9)? '+': '0' + macrolevel;
		    }
#else

		    if (pFCBCur->pFCBParent)
			p[0] = 'C';

#ifdef BCBOPT
		    if (fNoCompact && *linebuffer)
#else
		    if (*linebuffer)
#endif
			p[1] = '\\';
		    else if (macrolevel)
			p[1] = (macrolevel > 9)? '+': '0' + macrolevel;
#endif

		    listbuffer [LISTMAX] = 0;
	    }
	    if (lsting) {

		    bumpline ();
		    k = LISTMAX;

		    /** Put out line # * */
		    if (pass2 && crefing == CREF_SINGLE) {
			    fprintf (lst.fil, "%8hd", crefcount+crefinc);
			    k += 8;
		    }

		    p = listbuffer;
		    while (!memcmp(p,"        ",8)) { /* leading tabs */
			    putc('\t',lst.fil);
			    p += 8;
			    }


		    q = r = p + strlen(p) - 1; /* last char of p */
		    if (q >= p && *q == ' ') {

			    /* coalesce end spaces to tabs */
			    while (q != p && *(q - 1) == ' ')
				    /* gather spaces */
				    q--;

			    /* now q points at the first trailing space and
			     * r points at the last trailing space */

			    *q = '\0';
			    listPuts(p);
			    *q = ' ';
			    i = (short)((q - p) & 7); /* residual = strlen MOD 8 */
			    j = 8 - i; /* filler to next tab stop */
			    if (j != 8 && j <= (r - q + 1)) {
				    putc('\t',lst.fil);
				    q += j;
				    }
			    while (r >= q + 7) {
				    putc('\t',lst.fil);
				    q += 8;
				    }
			    while (r >= q++)
				    putc(' ',lst.fil);
			    }
		    else
			    listPuts(p);

		    p = linebuffer;
		    i = k; /* number of columns already put out */

		    while (*p) {
			while (*p && i < pagewidth) {
			    if (*p == '\t') {
				    if ((i = (((i+8)>>3)<<3))
						    >= pagewidth)
					    /* won't fit */
					    break;
				    }
			    else
				    i++;

			    putc(*p, lst.fil );
			    p++;
			    }

			if (*p) {
			    skipline ();
			    listPuts ( pass2 && crefing == CREF_SINGLE ?
				     "\t\t\t\t\t" : "\t\t\t\t");
			    i = k;
			}
		    }
		    fputs(NLINE, lst.fil);
	    }
	    crefinc++;

	    if (errorcode) {
		    if (listconsole)
			    /* display line */
			    fprintf (ERRFILE,"%s%s\n", listbuffer, linebuffer);
		    errordisplay ();
	    }

	}
	if (fNeedList)
	    memset(listbuffer, ' ', LISTMAX);

	errorcode = 0;
	fPass1Err = 0;
}


/***	storetitle - copy text of line to title buffer
 *
 *	storetitle (buf)
 *
 *	Entry	buf = pointer to buffer to hold title
 *	Exit	up to TITLEWIDTH - 1 characters move to *buf* and *buf* blank
 *		filled and zero terminated
 *	Returns none
 *	Calls	none
 */


VOID PASCAL
storetitle (
	register char	*buf
){
	register SHORT count = 0;

	for (; (count < TITLEWIDTH - 1); count++) {
		if (PEEKC () == 0)
			break;
		else
			*buf++ = NEXTC ();
	}
	/* skip to end of title */
	while (PEEKC ())
		NEXTC ();
	/* blank fill buffer */
	for (; count < TITLEWIDTH - 1; count++)
		*buf++ = ' ';
	*buf = 0;
}




/***	displength - display value as LENGTH = value
 *
 *	displength (v);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
displength (
	OFFSET	v
){
	offsetAscii (v);
	listPuts("\tLength = ");
	listPuts(objectascii);
}




/***	dispdatasize - display data size
 *
 *	dispdatasize (sym);
 *
 *	Entry	*sym = symbol
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL
dispdatasize (
	SYMBOL FARSYM *sym
){
	register USHORT idx;


	idx = sym->symtype;

	if (idx == CLABEL && sym->symu.clabel.type > 514)

	    dispword((OFFSET) idx);

	else{

	    if (idx == CSFAR)
		idx = 12;

	    else if (idx == CSNEAR)
		idx = 11;

	    else if (idx > 10 || siznm[idx] == NULL){
		return;
	    }

	    listPuts(siznm[idx]);
	}
}




/***	listopen - list blocks open at end of pass
 *
 *	listopen ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		Open segments:	<list>
 *		Open procedures: <list>
 *		Open conditionals: <n>
 */


VOID PASCAL
listopen ()
{
	SYMBOL FARSYM *sym;

	if (pcsegment) {
		if (!listquiet)
			fprintf (ERRFILE,"%s:", __NMSG_TEXT(ER_SEG));
		if (lsting) {
			fprintf (lst.fil, "%s:", __NMSG_TEXT(ER_SEG));
			bumpline ();
			skipline ();
		}
		sym = pcsegment;
		while (sym) {
			/*     Count as an error */
			if (pass2)
				errornum++;
			if (lsting) {
				dispsym (0, sym);
				skipline ();
			}
			if (!listquiet) {
				STRNFCPY (save, sym->nampnt->id);
				fprintf (ERRFILE," %s", save);
			}
			/* Point to previous seg */
			sym = sym->symu.segmnt.lastseg;
		}
		if (!listquiet)
			fprintf (ERRFILE,"\n");
	}
	if (iProcStack > 0) {
		if (!listquiet)
			fprintf (ERRFILE,"%s:", __NMSG_TEXT(ER_PRO));
		if (lsting) {
			fprintf (lst.fil, "%s:", __NMSG_TEXT(ER_PRO));
			bumpline ();
			skipline ();
		}
		while (iProcStack > 0) {
			sym = procStack[iProcStack--];

			/*	Count as an error */
			if (pass2)
				errornum++;
			if (lsting) {
				dispsym (0, sym);
				skipline ();
			}
			if (!listquiet) {
				STRNFCPY (save, sym->nampnt->id);
				fprintf (ERRFILE," %s", save);
			}
		}
		if (!listquiet)
			fprintf (ERRFILE,"\n");
	}
	if (condlevel) {
		/*	Count as an error */
		if (pass2)
			errornum++;
		if (!listquiet)
			fprintf (ERRFILE,"%s%hd\n", __NMSG_TEXT(ER_CON), condlevel);
		if (lsting) {
			fprintf (lst.fil, "%s%hd" NLINE, __NMSG_TEXT(ER_CON), condlevel);
			bumpline ();
		}
	}
}




/***	symbollist - list symbol
 *
 *	symbollist (sym)
 *
 *	Entry	*sym = symbol
 *	Exit	count = number of symbols listed
 *	Returns
 *	Calls
 */


VOID PASCAL
symbollist ()
{
    SYMBOL FARSYM *sym;
    SHORT i;

    listed = FALSE;

    for (i = 0; i < MAXCHR; i++) {
	count = 0;

	for(sym = symroot[i]; sym; sym = sym->alpha)

	    if (!((M_NOCREF|M_PASSED) & sym->attr)) {

		symptr = sym;
		count++;
		chkheading (1);
		setpassed (sym);
		dispsym (0, sym);
		dispstandard (sym);

		if (sym->symkind == PROC)
		    displength ((OFFSET) sym->symu.plabel.proclen);

		else if (sym->length != 1 &&
			(sym->symkind == DVAR || sym->symkind == CLABEL))

		    displength ((OFFSET) sym->length);

		skipline ();
	    }

	if (count)
	   skipline ();
    }
}





/***	dispstandard - display standard
 *
 *	dispstandard ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		PROC:	N/F PROC	offset	Segment
 *		CLABEL	L  NEAR|FAR	offset	Segment
 *		DVAR	V  SIZE 	offset	Segment
 *		REGISTR REG		name
 */


VOID PASCAL CODESIZE
dispstandard (
	SYMBOL FARSYM *sym
){
	NAME FAR *tp;
	register SHORT width;
	SHORT cbTM;

	switch (sym->symkind) {
		case PROC:
			if (sym->symtype == CSNEAR)
				listPuts("N PROC");
			else
				listPuts("F PROC");
			break;
		case CLABEL:
			if (sym->symtype == CSNEAR)
				listPuts("L NEAR");
			else if (sym->symtype == CSFAR)
				listPuts("L FAR ");
			else {
				fprintf (lst.fil, "L ");
				dispdatasize (sym);
			}
			break;
		case DVAR:
			/* Data associated label */
			listPuts("V ");
			/**Display keyword or size * */
			dispdatasize (sym);
			break;
		case REGISTER:
			listPuts("REG  ");
			break;
		case EQU:
			if (sym->symu.equ.equtyp == EXPR)
				if (sym->symtype == 0)
					listPuts("NUMBER");
				else
					dispdatasize (sym);

			else if (sym->symu.equ.equtyp == ALIAS) {
				if (sym->symu.equ.equrec.alias.equptr)
					tp = sym->symu.equ.equrec.alias.equptr->nampnt;
				else
					tp = NULL;
				listPuts("ALIAS\t ");
				if (tp) {
					STRNFCPY (save, tp->id);
					listPuts(save);
				}
			} else {
				listPuts("TEXT  ");
				cbTM = (SHORT) strlen(sym->symu.equ.equrec.txtmacro.equtext);
				width = pagewidth - 46;
				while (cbTM > width) {
				    memcpy(save, sym->symu.equ.equrec.txtmacro.equtext,
					width);
				    save[width] = 0;
				    listPuts(save);
				    skipline ();
				    listPuts("\t\t\t\t\t      ");
				    sym->symu.equ.equrec.txtmacro.equtext += width;
				    cbTM -= width;
				}
				listPuts(sym->symu.equ.equrec.txtmacro.equtext);
			}
			break;
	}
	disptab ();
	if ((sym->symkind != EQU) || (sym->symu.equ.equtyp == EXPR))
		if (sym->symkind != REGISTER)
			dispword (((sym->attr & M_XTERN) && sym->offset)?
				    (OFFSET) sym->length * sym->symtype:
				    sym->offset);
		else {
			STRNFCPY (save, sym->nampnt->id);
			listPuts(save);
		}
	disptab ();
	if (sym->symsegptr) {
			STRNFCPY (save, sym->symsegptr->nampnt->id);
			listPuts(save);
		}

	if (M_XTERN & sym->attr)
		listPuts((sym->symu.ext.commFlag)? "\tCommunal": "\tExternal");

	if (M_GLOBAL & sym->attr)
		listPuts("\tGlobal");
}




/***	macrolist - list macro names and lengths
 *
 *	macrolist (sym);
 *
 *	Entry	*sym = macro symbol entry
 *	Exit
 *	Returns
 *	Calls
 */


SHORT PASCAL
macrolist (
	SYMBOL FARSYM *sym
){
	SHORT i;
	TEXTSTR FAR *p;

	if (!(M_NOCREF & sym->attr)) {
		if (!listed) {
			listed = TRUE;
			/* # on line is 1 */
			skipline ();
			listPuts("Macros:");
			/** Display header * */
			skipline ();
			skipline ();
			listPuts("\t\tN a m e\t\t\tLines");
			skipline ();
			skipline ();
		}
		/* Display name of macro */
		dispsym (0, sym);
		for (i = 0, p = sym->symu.rsmsym.rsmtype.rsmmac.macrotext; p; p = p->strnext, i++)
			;
		fprintf (lst.fil, "%4hd", i);
		skipline ();
		setpassed (sym);
	}
    return 0;
}




/***	struclist - display structure and record names
 *
 *	struclist (sym);
 *
 *	Entry	*sym = symbol
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		<structure name>  <length> <# fields>
 *		  <field name>	  <offset>
 *			       Or
 *		<Record name>	  <width>  <# fields>
 *		<Field name>	<offset> <width> <mask> <init>
 */


SHORT PASCAL
struclist (
	SYMBOL FARSYM *sym
){
	char f32bit;

	if (!(M_NOCREF & sym->attr)) {
	    if (!listed) {
		    listed = TRUE;
		    if (pagelength - pageline < 8)
			    pageheader ();
		    else
			    skipline ();
		    listPuts("Structures and Records:");
		    skipline ();
		    skipline ();
		    listPuts("                N a m e                 Width   # fields");
		    skipline ();
		    listPuts("                                        Shift   Width   Mask    Initial");
		    skipline ();
		    skipline ();
	    }
	    setpassed (sym);
	    /* Display name */
	    dispsym (0, sym);
	    if (sym->symkind == REC) {
		    /* # bits in record */
		    dispword ((OFFSET) sym->length);
		    disptab ();
		    /* # of fields */
		    dispword ((OFFSET) sym->symu.rsmsym.rsmtype.rsmrec.recfldnum);
		    }
	    else {
		    /* Length of structure */
		    dispword ((OFFSET) sym->symtype);
		    disptab ();
		    /* # of fields */
		    dispword ((OFFSET) sym->symu.rsmsym.rsmtype.rsmstruc.strucfldnum);
	    }
	    skipline ();
	    if (sym->symkind == REC) {
#ifdef V386
		    f32bit = (symptr->length > 16);
#endif
		    /* Point to 1st rec */
		    symptr = symptr->symu.rsmsym.rsmtype.rsmrec.reclist;
		    while (symptr) {

			    dispsym (2, symptr);

			    /* Shift count */
			    dispword (symptr->offset);
			    disptab ();

			    /* Width */
			    dispword ((OFFSET) symptr->symu.rec.recwid);
			    disptab ();

			    /* Mask */
#ifdef V386
			    if (f32bit && symptr->symu.rec.recmsk <= 0xffff)
				dispword((OFFSET) 0);
#endif
			    dispword (symptr->symu.rec.recmsk);
			    disptab ();

			    /* Initial value */
#ifdef V386
			    if (f32bit && symptr->symu.rec.recinit <= 0xffff)
				dispword((OFFSET) 0);
#endif
			    dispword (symptr->symu.rec.recinit);

			    skipline ();
			    setpassed (sym);
			    symptr = symptr->symu.rec.recnxt;
		    }
	    }
	    else {
		    /* Point to 1st field */
		    symptr = symptr->symu.rsmsym.rsmtype.rsmstruc.struclist;
		    while (symptr) {
			    dispsym (2, symptr);
			    /* offset from start */
			    dispword (symptr->offset);
			    skipline ();
			    setpassed (symptr);
			    symptr = symptr->symu.struk.strucnxt;
		    }
	    }
	}
    return 0;
}


/* output a string to the listing file */

VOID PASCAL CODESIZE
listPuts(
	char *pString
){
    fputs(pString, lst.fil);
}



/***	segdisplay - display segment name, size, align, combine and class
 *
 *	segdisplay ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
segdisplay (
	USHORT	indent,
	SYMBOL FARSYM	  *sym
){

	dispsym (indent, sym);

#ifdef V386

	if (f386already){
	    listPuts((sym->symu.segmnt.use32 == 4)? "32": "16");
	    listPuts(" Bit\t");
	}
#endif
	/* Length of segment */
	dispword (sym->symu.segmnt.seglen);
	disptab ();
	listPuts (alignName[sym->symu.segmnt.align]);
	disptab ();

	if (sym->symu.segmnt.align == 0 && sym->symu.segmnt.combine == 0)

	    dispword ((OFFSET) sym->symu.segmnt.locate);
	else
	    listPuts (combineName[sym->symu.segmnt.combine]);

	disptab ();
	if (sym->symu.segmnt.classptr) {
		/* Have class name */
		setpassed (sym->symu.segmnt.classptr);

#ifdef XENIX286
		fputc('\'', lst.fil);
		farPuts(lst.fil, sym->symu.segmnt.classptr->nampnt->id);
		fputc('\'', lst.fil);
#else
# ifdef FLATMODEL
		fprintf (lst.fil, "\'%s\'",
# else
		fprintf (lst.fil, "\'%Fs\'",
# endif
			 sym->symu.segmnt.classptr->nampnt->id);
#endif
	}
	setpassed (sym);
	skipline ();
}





/***	seglist - list segment
 *
 *	seglist (sym);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		<Group name>  <# segments>
 *		<segment>   <size>  <align> <combine>	    <class>
 *				   Or
 *		<segment>     <size>  <align> <combine>       <class>
 */


VOID PASCAL
seglist ()
{
    SYMBOL FARSYM *sym;
    SHORT i;

    listed = FALSE;

    for (i = 0; i < MAXCHR; i++) {

	for(sym = symroot[i]; sym; sym = sym->alpha)


	if (1 << sym->symkind & (M_SEGMENT | M_GROUP) &&
	    !((M_NOCREF|M_PASSED) & sym->attr)) {
#ifdef V386
		chkheading ((USHORT) ((f386already)? 2: 0) );
#else
		chkheading (0);
#endif
		symptr = sym;
		setpassed (sym);
		if (sym->symkind == SEGMENT) {
			if (!sym->symu.segmnt.grouptr)
				/*Display segment */
				segdisplay (0, sym);
		}
		else {
			/* Display group name */
			dispsym (0, sym);
			listPuts ("GROUP" NLINE);
			bumpline ();
			bumpline ();
			/* Point to 1st seg */
			symptr = sym->symu.grupe.segptr;
			while (symptr) {
				segdisplay (2, symptr);
				symptr = symptr->symu.segmnt.nxtseg;
			}
		}
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmkeys.h ===
#include "asmindex.h"
/***
 *      [0]
 *      [1]
 *              DB,     I_TDB
 *      [2]
 *              EXTRN,  I_TEXTRN
 *      [3]
 *              DD,     I_TDD
 *      [4]
 *      [5]
 *              DF,     I_TDF
 *              .ALPHA, I_TALPHA
 *      [6]
 *      [7]
 *              .286C,  I_T286C
 *      [8]
 *              .386C,  I_T386C
 *      [9]
 *      [10]
 *              IF,     I_TIF
 *      [11]
 *      [12]
 *      [13]
 *              .SEQ,   I_TSEQ
 *              .FARDATA,       I_TFARDATA
 *              .ERR,   I_TERR
 *      [14]
 *      [15]
 *      [16]
 *              .MODEL, I_TMODEL
 *              DQ,     I_TDQ
 *      [17]
 *      [18]
 *      [19]
 *              PAGE,   I_TPAGE
 *              %OUT,   I_TOUT
 *              DT,     I_TDT
 *      [20]
 *              .286P,  I_T286P
 *      [21]
 *              .STACK, I_TMSTACK
 *              IFNB,   I_TIFNB
 *              .386P,  I_T386P
 *      [22]
 *              DW,     I_TDW
 *      [23]
 *              .XCREF, I_TXCREF
 *              .RADIX, I_TRADIX
 *              NAME,   I_TNAME
 *      [24]
 *              .ERRNB, I_TERRNB
 *      [25]
 *      [26]
 *              ENDM,   I_TENDM
 *      [27]
 *      [28]
 *              IFDIFI, I_TIFDIFI
 *      [29]
 *              IFNDEF, I_TIFNDEF
 *      [30]
 *      [31]
 *              .ERRDIFI,       I_TERRDIFI
 *              ELSE,   I_TELSE
 *      [32]
 *              .ERRNDEF,       I_TERRNDEF
 *      [33]
 *      [34]
 *              COMM,   I_TCOMM
 *      [35]
 *      [36]
 *              IRPC,   I_TIRPC
 *              IFIDNI, I_TIFIDNI
 *              EVEN,   I_TEVEN
 *      [37]
 *      [38]
 *              .CONST, I_TCONST
 *      [39]
 *              .ERRIDNI,       I_TERRIDNI
 *      [40]
 *      [41]
 *              ELSEIF, I_TELSEIF
 *      [42]
 *      [43]
 *      [44]
 *      [45]
 *      [46]
 *      [47]
 *      [48]
 *              PUBLIC, I_TPUBLIC
 *              .ERRNZ, I_TERRNZ
 *      [49]
 *              REPT,   I_TREPT
 *      [50]
 *      [51]
 *              .XLIST, I_TXLIST
 *      [52]
 *              ELSEIFNB,       I_TELSEIFNB
 *      [53]
 *      [54]
 *              DOSSEG, I_TDOSSEG
 *      [55]
 *      [56]
 *      [57]
 *      [58]
 *      [59]
 *              IF1,    I_TIF1
 *              ELSEIFDIFI,     I_TELSEIFDIFI
 *      [60]
 *              IF2,    I_TIF2
 *              ELSEIFNDEF,     I_TELSEIFNDEF
 *      [61]
 *      [62]
 *              .ERR1,  I_TERR1
 *              .DATA,  I_TDATA
 *      [63]
 *              .ERR2,  I_TERR2
 *              .CODE,  I_TCODE
 *              ASSUME, I_TASSUME
 *      [64]
 *      [65]
 *      [66]
 *              INCLUDELIB,     I_TINCLIB
 *      [67]
 *              ELSEIFIDNI,     I_TELSEIFIDNI
 *      [68]
 *              .CREF,  I_TCREF
 *      [69]
 *      [70]
 *      [71]
 *      [72]
 *              .186,   I_T186
 *      [73]
 *              .LALL,  I_TLALL
 *              .286,   I_T286C
 *      [74]
 *              .287,   I_T287
 *              .386,   I_T386C
 *      [75]
 *              .387,   I_T387
 *      [76]
 *              IFB,    I_TIFB
 *              .FARDATA?,      I_TFARDATAQ
 *      [77]
 *      [78]
 *      [79]
 *              SUBTTL, I_TSUBTTL
 *              IFE,    I_TIFE
 *              .ERRB,  I_TERRB
 *      [80]
 *              .SALL,  I_TSALL
 *      [81]
 *      [82]
 *              .ERRE,  I_TERRE
 *              END,    I_TEND
 *      [83]
 *      [84]
 *              IFDEF,  I_TIFDEF
 *      [85]
 *              .XALL,  I_TXALL
 *              .LFCOND,        I_TLFCOND
 *      [86]
 *      [87]
 *              .ERRDEF,        I_TERRDEF
 *      [88]
 *              IFDIF,  I_TIFDIF
 *      [89]
 *      [90]
 *              ELSEIF1,        I_TELSEIF1
 *      [91]
 *              .ERRDIF,        I_TERRDIF
 *              ELSEIF2,        I_TELSEIF2
 *      [92]
 *              .SFCOND,        I_TSFCOND
 *              ENDIF,  I_TENDIF
 *      [93]
 *              .TFCOND,        I_TTFCOND
 *      [94]
 *      [95]
 *      [96]
 *              .LIST,  I_TLIST
 *              IFIDN,  I_TIFIDN
 *      [97]
 *              ALIGN,  I_TALIGN
 *              LOCAL,  I_TLOCAL
 *      [98]
 *      [99]
 *              ORG,    I_TORG
 *              .ERRIDN,        I_TERRIDN
 *      [100]
 *      [101]
 *      [102]
 *              IRP,    I_TIRP
 *      [103]
 *      [104]
 *      [105]
 *      [106]
 *      [107]
 *              ELSEIFB,        I_TELSEIFB
 *      [108]
 *      [109]
 *      [110]
 *              ELSEIFE,        I_TELSEIFE
 *      [111]
 *      [112]
 *      [113]
 *      [114]
 *      [115]
 *              ELSEIFDEF,      I_TELSEIFDEF
 *      [116]
 *      [117]
 *              INCLUDE,        I_TINCLUDE
 *      [118]
 *      [119]
 *              ELSEIFDIF,      I_TELSEIFDIF
 *      [120]
 *              TITLE,  I_TTITLE
 *      [121]
 *              PURGE,  I_TPURGE
 *      [122]
 *      [123]
 *      [124]
 *      [125]
 *              EXITM,  I_TEXITM
 *              .DATA?, I_TDATAQ
 *      [126]
 *      [127]
 *              ELSEIFIDN,      I_TELSEIFIDN
 *              .8086,  I_T8086
 *      [128]
 *              .8087,  I_T8087
 *      [129]
 *      [130]
 *      [131]
 *      [132]
 *              COMMENT,        I_TCOMMENT
 */
static KEYSYM   t_ps120 = {0,"DB",134,I_TDB};
static KEYSYM   t_ps157 = {0,"EXTRN",401,I_TEXTRN};
static KEYSYM   t_ps121 = {0,"DD",136,I_TDD};
static KEYSYM   t_ps111 = {0,".ALPHA",404,I_TALPHA};
static KEYSYM   t_ps199 = {&t_ps111,"DF",138,I_TDF};
static KEYSYM   t_ps13  = {0,".286C",273,I_T286C};
static KEYSYM   t_ps16  = {0,".386C",274,I_T386C};
static KEYSYM   t_ps160 = {0,"IF",143,I_TIF};
static KEYSYM   t_ps142 = {0,".ERR",279,I_TERR};
static KEYSYM   t_ps158 = {&t_ps142,".FARDATA",545,I_TFARDATA};
static KEYSYM   t_ps190 = {&t_ps158,".SEQ",279,I_TSEQ};
static KEYSYM   t_ps123 = {0,"DQ",149,I_TDQ};
static KEYSYM   t_ps180 = {&t_ps123,".MODEL",415,I_TMODEL};
static KEYSYM   t_ps124 = {0,"DT",152,I_TDT};
static KEYSYM   t_ps183 = {&t_ps124,"%OUT",285,I_TOUT};
static KEYSYM   t_ps184 = {&t_ps183,"PAGE",285,I_TPAGE};
static KEYSYM   t_ps14  = {0,".286P",286,I_T286P};
static KEYSYM   t_ps17  = {0,".386P",287,I_T386P};
static KEYSYM   t_ps170 = {&t_ps17,"IFNB",287,I_TIFNB};
static KEYSYM   t_ps192 = {&t_ps170,".STACK",420,I_TMSTACK};
static KEYSYM   t_ps125 = {0,"DW",155,I_TDW};
static KEYSYM   t_ps181 = {0,"NAME",289,I_TNAME};
static KEYSYM   t_ps187 = {&t_ps181,".RADIX",422,I_TRADIX};
static KEYSYM   t_ps197 = {&t_ps187,".XCREF",422,I_TXCREF};
static KEYSYM   t_ps152 = {0,".ERRNB",423,I_TERRNB};
static KEYSYM   t_ps141 = {0,"ENDM",292,I_TENDM};
static KEYSYM   t_ps166 = {0,"IFDIFI",427,I_TIFDIFI};
static KEYSYM   t_ps171 = {0,"IFNDEF",428,I_TIFNDEF};
static KEYSYM   t_ps126 = {0,"ELSE",297,I_TELSE};
static KEYSYM   t_ps148 = {&t_ps126,".ERRDIFI",563,I_TERRDIFI};
static KEYSYM   t_ps153 = {0,".ERRNDEF",564,I_TERRNDEF};
static KEYSYM   t_ps114 = {0,"COMM",300,I_TCOMM};
static KEYSYM   t_ps155 = {0,"EVEN",302,I_TEVEN};
static KEYSYM   t_ps169 = {&t_ps155,"IFIDNI",435,I_TIFIDNI};
static KEYSYM   t_ps175 = {&t_ps169,"IRPC",302,I_TIRPC};
static KEYSYM   t_ps116 = {0,".CONST",437,I_TCONST};
static KEYSYM   t_ps151 = {0,".ERRIDNI",571,I_TERRIDNI};
static KEYSYM   t_ps127 = {0,"ELSEIF",440,I_TELSEIF};
static KEYSYM   t_ps154 = {0,".ERRNZ",447,I_TERRNZ};
static KEYSYM   t_ps185 = {&t_ps154,"PUBLIC",447,I_TPUBLIC};
static KEYSYM   t_ps188 = {0,"REPT",315,I_TREPT};
static KEYSYM   t_ps198 = {0,".XLIST",450,I_TXLIST};
static KEYSYM   t_ps137 = {0,"ELSEIFNB",584,I_TELSEIFNB};
static KEYSYM   t_ps122 = {0,"DOSSEG",453,I_TDOSSEG};
static KEYSYM   t_ps133 = {0,"ELSEIFDIFI",724,I_TELSEIFDIFI};
static KEYSYM   t_ps161 = {&t_ps133,"IF1",192,I_TIF1};
static KEYSYM   t_ps138 = {0,"ELSEIFNDEF",725,I_TELSEIFNDEF};
static KEYSYM   t_ps162 = {&t_ps138,"IF2",193,I_TIF2};
static KEYSYM   t_ps118 = {0,".DATA",328,I_TDATA};
static KEYSYM   t_ps143 = {&t_ps118,".ERR1",328,I_TERR1};
static KEYSYM   t_ps112 = {0,"ASSUME",462,I_TASSUME};
static KEYSYM   t_ps115 = {&t_ps112,".CODE",329,I_TCODE};
static KEYSYM   t_ps144 = {&t_ps115,".ERR2",329,I_TERR2};
static KEYSYM   t_ps173 = {0,"INCLUDELIB",731,I_TINCLIB};
static KEYSYM   t_ps136 = {0,"ELSEIFIDNI",732,I_TELSEIFIDNI};
static KEYSYM   t_ps117 = {0,".CREF",334,I_TCREF};
static KEYSYM   t_ps11  = {0,".186",205,I_T186};
static KEYSYM   t_ps12  = {0,".286",206,I_T286C};
static KEYSYM   t_ps176 = {&t_ps12,".LALL",339,I_TLALL};
static KEYSYM   t_ps15  = {0,".386",207,I_T386C};
static KEYSYM   t_ps19  = {&t_ps15,".287",207,I_T287};
static KEYSYM   t_ps110 = {0,".387",208,I_T387};
static KEYSYM   t_ps159 = {0,".FARDATA?",608,I_TFARDATAQ};
static KEYSYM   t_ps163 = {&t_ps159,"IFB",209,I_TIFB};
static KEYSYM   t_ps145 = {0,".ERRB",345,I_TERRB};
static KEYSYM   t_ps167 = {&t_ps145,"IFE",212,I_TIFE};
static KEYSYM   t_ps193 = {&t_ps167,"SUBTTL",478,I_TSUBTTL};
static KEYSYM   t_ps189 = {0,".SALL",346,I_TSALL};
static KEYSYM   t_ps139 = {0,"END",215,I_TEND};
static KEYSYM   t_ps149 = {&t_ps139,".ERRE",348,I_TERRE};
static KEYSYM   t_ps164 = {0,"IFDEF",350,I_TIFDEF};
static KEYSYM   t_ps177 = {0,".LFCOND",484,I_TLFCOND};
static KEYSYM   t_ps196 = {&t_ps177,".XALL",351,I_TXALL};
static KEYSYM   t_ps146 = {0,".ERRDEF",486,I_TERRDEF};
static KEYSYM   t_ps165 = {0,"IFDIF",354,I_TIFDIF};
static KEYSYM   t_ps128 = {0,"ELSEIF1",489,I_TELSEIF1};
static KEYSYM   t_ps129 = {0,"ELSEIF2",490,I_TELSEIF2};
static KEYSYM   t_ps147 = {&t_ps129,".ERRDIF",490,I_TERRDIF};
static KEYSYM   t_ps140 = {0,"ENDIF",358,I_TENDIF};
static KEYSYM   t_ps191 = {&t_ps140,".SFCOND",491,I_TSFCOND};
static KEYSYM   t_ps195 = {0,".TFCOND",492,I_TTFCOND};
static KEYSYM   t_ps168 = {0,"IFIDN",362,I_TIFIDN};
static KEYSYM   t_ps178 = {&t_ps168,".LIST",362,I_TLIST};
static KEYSYM   t_ps179 = {0,"LOCAL",363,I_TLOCAL};
static KEYSYM   t_ps1100        = {&t_ps179,"ALIGN",363,I_TALIGN};
static KEYSYM   t_ps150 = {0,".ERRIDN",498,I_TERRIDN};
static KEYSYM   t_ps182 = {&t_ps150,"ORG",232,I_TORG};
static KEYSYM   t_ps174 = {0,"IRP",235,I_TIRP};
static KEYSYM   t_ps130 = {0,"ELSEIFB",506,I_TELSEIFB};
static KEYSYM   t_ps134 = {0,"ELSEIFE",509,I_TELSEIFE};
static KEYSYM   t_ps131 = {0,"ELSEIFDEF",647,I_TELSEIFDEF};
static KEYSYM   t_ps172 = {0,"INCLUDE",516,I_TINCLUDE};
static KEYSYM   t_ps132 = {0,"ELSEIFDIF",651,I_TELSEIFDIF};
static KEYSYM   t_ps194 = {0,"TITLE",386,I_TTITLE};
static KEYSYM   t_ps186 = {0,"PURGE",387,I_TPURGE};
static KEYSYM   t_ps119 = {0,".DATA?",391,I_TDATAQ};
static KEYSYM   t_ps156 = {&t_ps119,"EXITM",391,I_TEXITM};
static KEYSYM   t_ps10  = {0,".8086",260,I_T8086};
static KEYSYM   t_ps135 = {&t_ps10,"ELSEIFIDN",659,I_TELSEIFIDN};
static KEYSYM   t_ps18  = {0,".8087",261,I_T8087};
static KEYSYM   t_ps113 = {0,"COMMENT",531,I_TCOMMENT};
static KEYSYM   t_ps200 = {0,".FPO",275,I_TFPO};

static KEYSYM FARSYM *t_ps1_words[133] = {
        0,
        &t_ps120,
        &t_ps157,
        &t_ps121,
        0,
        &t_ps199,
        0,
        &t_ps13,
        &t_ps16,
        &t_ps200,
        &t_ps160,
        0,
        0,
        &t_ps190,
        0,
        0,
        &t_ps180,
        0,
        0,
        &t_ps184,
        &t_ps14,
        &t_ps192,
        &t_ps125,
        &t_ps197,
        &t_ps152,
        0,
        &t_ps141,
        0,
        &t_ps166,
        &t_ps171,
        0,
        &t_ps148,
        &t_ps153,
        0,
        &t_ps114,
        0,
        &t_ps175,
        0,
        &t_ps116,
        &t_ps151,
        0,
        &t_ps127,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_ps185,
        &t_ps188,
        0,
        &t_ps198,
        &t_ps137,
        0,
        &t_ps122,
        0,
        0,
        0,
        0,
        &t_ps161,
        &t_ps162,
        0,
        &t_ps143,
        &t_ps144,
        0,
        0,
        &t_ps173,
        &t_ps136,
        &t_ps117,
        0,
        0,
        0,
        &t_ps11,
        &t_ps176,
        &t_ps19,
        &t_ps110,
        &t_ps163,
        0,
        0,
        &t_ps193,
        &t_ps189,
        0,
        &t_ps149,
        0,
        &t_ps164,
        &t_ps196,
        0,
        &t_ps146,
        &t_ps165,
        0,
        &t_ps128,
        &t_ps147,
        &t_ps191,
        &t_ps195,
        0,
        0,
        &t_ps178,
        &t_ps1100,
        0,
        &t_ps182,
        0,
        0,
        &t_ps174,
        0,
        0,
        0,
        0,
        &t_ps130,
        0,
        0,
        &t_ps134,
        0,
        0,
        0,
        0,
        &t_ps131,
        0,
        &t_ps172,
        0,
        &t_ps132,
        &t_ps194,
        &t_ps186,
        0,
        0,
        0,
        &t_ps156,
        0,
        &t_ps135,
        &t_ps18,
        0,
        0,
        0,
        &t_ps113
        };

KEYWORDS t_ps1_table = {t_ps1_words,133};


/***
 *      [0]
 *              CATSTR, I2_TCATSTR
 *              DW,     I2_TDW
 *      [1]
 *      [2]
 *      [3]
 *      [4]
 *              SEGMENT,        I2_TSEGMENT
 *      [5]
 *      [6]
 *              SIZESTR,        I2_TSIZESTR
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *              DB,     I2_TDB
 *      [11]
 *              LABEL,  I2_TLABEL
 *      [12]
 *              DD,     I2_TDD
 *      [13]
 *              RECORD, I2_TRECORD
 *      [14]
 *              DF,     I2_TDF
 *      [15]
 *      [16]
 *              ENDP,   I2_TENDP
 *      [17]
 *      [18]
 *              SUBSTR, I2_TSUBSTR
 *              EQU,    I2_TEQU
 *      [19]
 *              ENDS,   I2_TENDS
 *      [20]
 *      [21]
 *      [22]
 *      [23]
 *      [24]
 *      [25]
 *              GROUP,  I2_TGROUP
 *              DQ,     I2_TDQ
 *      [26]
 *      [27]
 *      [28]
 *              INSTR,  I2_TINSTR
 *              DT,     I2_TDT
 *      [29]
 *              STRUC,  I2_TSTRUC
 *              PROC,   I2_TPROC
 *              MACRO,  I2_TMACRO
 *      [30]
 */
static KEYSYM   t_ps2105        = {0,"DW",155,I2_TDW};
static KEYSYM   t_ps2110        = {&t_ps2105,"CATSTR",465,I2_TCATSTR};
static KEYSYM   t_ps2118        = {0,"SEGMENT",531,I2_TSEGMENT};
static KEYSYM   t_ps2111        = {0,"SIZESTR",564,I2_TSIZESTR};
static KEYSYM   t_ps2101        = {0,"DB",134,I2_TDB};
static KEYSYM   t_ps2114        = {0,"LABEL",352,I2_TLABEL};
static KEYSYM   t_ps2102        = {0,"DD",136,I2_TDD};
static KEYSYM   t_ps2117        = {0,"RECORD",447,I2_TRECORD};
static KEYSYM   t_ps2120        = {0,"DF",138,I2_TDF};
static KEYSYM   t_ps2106        = {0,"ENDP",295,I2_TENDP};
static KEYSYM   t_ps2108        = {0,"EQU",235,I2_TEQU};
static KEYSYM   t_ps2109        = {&t_ps2108,"SUBSTR",483,I2_TSUBSTR};
static KEYSYM   t_ps2107        = {0,"ENDS",298,I2_TENDS};
static KEYSYM   t_ps2103        = {0,"DQ",149,I2_TDQ};
static KEYSYM   t_ps2113        = {&t_ps2103,"GROUP",397,I2_TGROUP};
static KEYSYM   t_ps2104        = {0,"DT",152,I2_TDT};
static KEYSYM   t_ps2112        = {&t_ps2104,"INSTR",400,I2_TINSTR};
static KEYSYM   t_ps2115        = {0,"MACRO",370,I2_TMACRO};
static KEYSYM   t_ps2116        = {&t_ps2115,"PROC",308,I2_TPROC};
static KEYSYM   t_ps2119        = {&t_ps2116,"STRUC",401,I2_TSTRUC};

static KEYSYM FARSYM *t_ps2_words[31] = {
        &t_ps2110,
        0,
        0,
        0,
        &t_ps2118,
        0,
        &t_ps2111,
        0,
        0,
        0,
        &t_ps2101,
        &t_ps2114,
        &t_ps2102,
        &t_ps2117,
        &t_ps2120,
        0,
        &t_ps2106,
        0,
        &t_ps2109,
        &t_ps2107,
        0,
        0,
        0,
        0,
        0,
        &t_ps2113,
        0,
        0,
        &t_ps2112,
        &t_ps2119,
        0
        };

KEYWORDS t_ps2_table = {t_ps2_words,31};


/***
 *      [0]
 *      [1]
 *              TBYTE,  I_TBYTE
 *      [2]
 *              PROC,   I_PROC
 *              BYTE,   I_BYTE
 *      [3]
 *      [4]
 *      [5]
 *              NEAR,   I_NEAR
 *      [6]
 *              QWORD,  I_QWORD
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *              WORD,   I_WORD
 *              DWORD,  I_DWORD
 *      [11]
 *      [12]
 *              FWORD,  I_FWORD
 *      [13]
 *              FAR,    I_FAR
 *      [14]
 *      [15]
 *      [16]
 */
static KEYSYM   t_siz126        = {0,"TBYTE",392,I_TBYTE};
static KEYSYM   t_siz121        = {0,"BYTE",308,I_BYTE};
static KEYSYM   t_siz129        = {&t_siz121,"PROC",308,I_PROC};
static KEYSYM   t_siz124        = {0,"NEAR",294,I_NEAR};
static KEYSYM   t_siz125        = {0,"QWORD",397,I_QWORD};
static KEYSYM   t_siz122        = {0,"DWORD",384,I_DWORD};
static KEYSYM   t_siz127        = {&t_siz122,"WORD",316,I_WORD};
static KEYSYM   t_siz128        = {0,"FWORD",386,I_FWORD};
static KEYSYM   t_siz123        = {0,"FAR",217,I_FAR};

static KEYSYM FARSYM *t_siz_words[17] = {
        0,
        &t_siz126,
        &t_siz129,
        0,
        0,
        &t_siz124,
        &t_siz125,
        0,
        0,
        0,
        &t_siz127,
        0,
        &t_siz128,
        &t_siz123,
        0,
        0,
        0
        };

KEYWORDS t_siz_table = {t_siz_words,17};


/***
 *      [0]
 *              USE16,  IS_USE16
 *              STACK,  IS_STACK
 *      [1]
 *      [2]
 *              BYTE,   IS_BYTE
 *      [3]
 *              PARA,   IS_PARA
 *      [4]
 *      [5]
 *              PUBLIC, IS_PUBLIC
 *      [6]
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *              DWORD,  IS_DWORD
 *              WORD,   IS_WORD
 *      [11]
 *      [12]
 *      [13]
 *              PAGE,   IS_PAGE
 *              AT,     IS_AT
 *      [14]
 *              MEMORY, IS_MEMORY
 *      [15]
 *              USE32,  IS_USE32
 *              COMMON, IS_COMMON
 *      [16]
 */
static KEYSYM   t_seg137        = {0,"STACK",374,IS_STACK};
static KEYSYM   t_seg140        = {&t_seg137,"USE16",340,IS_USE16};
static KEYSYM   t_seg131        = {0,"BYTE",308,IS_BYTE};
static KEYSYM   t_seg135        = {0,"PARA",292,IS_PARA};
static KEYSYM   t_seg136        = {0,"PUBLIC",447,IS_PUBLIC};
static KEYSYM   t_seg138        = {0,"WORD",316,IS_WORD};
static KEYSYM   t_seg141        = {&t_seg138,"DWORD",384,IS_DWORD};
static KEYSYM   t_seg130        = {0,"AT",149,IS_AT};
static KEYSYM   t_seg134        = {&t_seg130,"PAGE",285,IS_PAGE};
static KEYSYM   t_seg133        = {0,"MEMORY",473,IS_MEMORY};
static KEYSYM   t_seg132        = {0,"COMMON",457,IS_COMMON};
static KEYSYM   t_seg139        = {&t_seg132,"USE32",338,IS_USE32};

static KEYSYM FARSYM *t_seg_words[17] = {
        &t_seg140,
        0,
        &t_seg131,
        &t_seg135,
        0,
        &t_seg136,
        0,
        0,
        0,
        0,
        &t_seg141,
        0,
        0,
        &t_seg134,
        &t_seg133,
        &t_seg139,
        0
        };

KEYWORDS t_seg_table = {t_seg_words,17};


/***
 *      [0]
 *      [1]
 *      [2]
 *              SHR,    OPSHR
 *      [3]
 *      [4]
 *              LE,     OPLE
 *      [5]
 *      [6]
 *              NOT,    OPNOT
 *              NE,     OPNE
 *              HIGH,   OPHIGH
 *      [7]
 *              LOW,    OPLOW
 *      [8]
 *              WIDTH,  OPWIDTH
 *      [9]
 *              EQ,     OPEQ
 *      [10]
 *      [11]
 *              PTR,    OPPTR
 *      [12]
 *      [13]
 *      [14]
 *              XOR,    OPXOR
 *              GT,     OPGT
 *      [15]
 *      [16]
 *      [17]
 *      [18]
 *              NOTHING,        OPNOTHING
 *              MASK,   OPMASK
 *      [19]
 *              LT,     OPLT
 *      [20]
 *              OR,     OPOR
 *      [21]
 *      [22]
 *      [23]
 *              AND,    OPAND
 *      [24]
 *              SHORT,  OPSHORT
 *      [25]
 *      [26]
 *      [27]
 *              LENGTH, OPLENGTH
 *      [28]
 *      [29]
 *      [30]
 *              THIS,   OPTHIS
 *      [31]
 *      [32]
 *              OFFSET, OPOFFSET
 *      [33]
 *              SIZE,   OPSIZE
 *      [34]
 *      [35]
 *              SEG,    OPSEG
 *      [36]
 *              MOD,    OPMOD
 *      [37]
 *      [38]
 *      [39]
 *              .TYPE,  OPSTYPE
 *      [40]
 *              TYPE,   OPTYPE
 *      [41]
 *      [42]
 *      [43]
 *              SHL,    OPSHL
 *      [44]
 *      [45]
 *              DUP,    OPDUP
 *      [46]
 *              GE,     OPGE
 */
static KEYSYM   t_op163 = {0,"SHR",237,OPSHR};
static KEYSYM   t_op148 = {0,"LE",145,OPLE};
static KEYSYM   t_op147 = {0,"HIGH",288,OPHIGH};
static KEYSYM   t_op154 = {&t_op147,"NE",147,OPNE};
static KEYSYM   t_op155 = {&t_op154,"NOT",241,OPNOT};
static KEYSYM   t_op150 = {0,"LOW",242,OPLOW};
static KEYSYM   t_op168 = {0,"WIDTH",384,OPWIDTH};
static KEYSYM   t_op144 = {0,"EQ",150,OPEQ};
static KEYSYM   t_op159 = {0,"PTR",246,OPPTR};
static KEYSYM   t_op146 = {0,"GT",155,OPGT};
static KEYSYM   t_op169 = {&t_op146,"XOR",249,OPXOR};
static KEYSYM   t_op152 = {0,"MASK",300,OPMASK};
static KEYSYM   t_op156 = {&t_op152,"NOTHING",535,OPNOTHING};
static KEYSYM   t_op151 = {0,"LT",160,OPLT};
static KEYSYM   t_op158 = {0,"OR",161,OPOR};
static KEYSYM   t_op142 = {0,"AND",211,OPAND};
static KEYSYM   t_op162 = {0,"SHORT",400,OPSHORT};
static KEYSYM   t_op149 = {0,"LENGTH",450,OPLENGTH};
static KEYSYM   t_op165 = {0,"THIS",312,OPTHIS};
static KEYSYM   t_op157 = {0,"OFFSET",455,OPOFFSET};
static KEYSYM   t_op164 = {0,"SIZE",315,OPSIZE};
static KEYSYM   t_op160 = {0,"SEG",223,OPSEG};
static KEYSYM   t_op153 = {0,"MOD",224,OPMOD};
static KEYSYM   t_op167 = {0,".TYPE",368,OPSTYPE};
static KEYSYM   t_op166 = {0,"TYPE",322,OPTYPE};
static KEYSYM   t_op161 = {0,"SHL",231,OPSHL};
static KEYSYM   t_op143 = {0,"DUP",233,OPDUP};
static KEYSYM   t_op145 = {0,"GE",140,OPGE};

static KEYSYM FARSYM *t_op_words[47] = {
        0,
        0,
        &t_op163,
        0,
        &t_op148,
        0,
        &t_op155,
        &t_op150,
        &t_op168,
        &t_op144,
        0,
        &t_op159,
        0,
        0,
        &t_op169,
        0,
        0,
        0,
        &t_op156,
        &t_op151,
        &t_op158,
        0,
        0,
        &t_op142,
        &t_op162,
        0,
        0,
        &t_op149,
        0,
        0,
        &t_op165,
        0,
        &t_op157,
        &t_op164,
        0,
        &t_op160,
        &t_op153,
        0,
        0,
        &t_op167,
        &t_op166,
        0,
        0,
        &t_op161,
        0,
        &t_op143,
        &t_op145
        };

KEYWORDS t_op_table = {t_op_words,47};


/***
 *      [0]
 *      [1]
 *      [2]
 *      [3]
 *      [4]
 *      [5]
 *      [6]
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *      [11]
 *      [12]
 *      [13]
 *      [14]
 *      [15]
 *      [16]
 *      [17]
 *      [18]
 *      [19]
 *      [20]
 *      [21]
 *      [22]
 *      [23]
 *      [24]
 *      [25]
 *      [26]
 *      [27]
 *      [28]
 *      [29]
 *      [30]
 *      [31]
 *      [32]
 *      [33]
 *      [34]
 *      [35]
 *      [36]
 *      [37]
 *      [38]
 *      [39]
 *      [40]
 *      [41]
 *      [42]
 *      [43]
 *      [44]
 *      [45]
 *      [46]
 *      [47]
 *      [48]
 *      [49]
 *      [50]
 *      [51]
 *      [52]
 *      [53]
 *      [54]
 *      [55]
 *      [56]
 *      [57]
 *      [58]
 *      [59]
 *      [60]
 *      [61]
 *      [62]
 *      [63]
 *      [64]
 *      [65]
 *      [66]
 *      [67]
 *      [68]
 *      [69]
 *      [70]
 *      [71]
 *      [72]
 *      [73]
 *      [74]
 *      [75]
 *      [76]
 *      [77]
 *      [78]
 *      [79]
 *      [80]
 *      [81]
 *      [82]
 *      [83]
 *      [84]
 *      [85]
 *      [86]
 *      [87]
 *      [88]
 *      [89]
 *      [90]
 *      [91]
 *      [92]
 *      [93]
 *      [94]
 *      [95]
 *      [96]
 *      [97]
 *      [98]
 *      [99]
 *      [100]
 *      [101]
 *      [102]
 *      [103]
 *      [104]
 *      [105]
 *      [106]
 *      [107]
 *      [108]
 *      [109]
 *      [110]
 *      [111]
 *      [112]
 *      [113]
 *      [114]
 *      [115]
 *      [116]
 *      [117]
 *      [118]
 *      [119]
 *      [120]
 *      [121]
 *      [122]
 *      [123]
 *      [124]
 *      [125]
 *      [126]
 *      [127]
 *      [128]
 *      [129]
 *      [130]
 *      [131]
 *      [132]
 *      [133]
 *      [134]
 *      [135]
 *      [136]
 *      [137]
 *      [138]
 *      [139]
 *              JA,     I_JA
 *      [140]
 *              JB,     I_JB
 *      [141]
 *              JC,     I_JC
 *      [142]
 *      [143]
 *              JE,     I_JE
 *      [144]
 *      [145]
 *              JG,     I_JG
 *      [146]
 *      [147]
 *      [148]
 *      [149]
 *      [150]
 *              JL,     I_JL
 *              BT,     I_BT
 *      [151]
 *              IN,     I_IN
 *      [152]
 *      [153]
 *              JO,     I_JO
 *      [154]
 *              JP,     I_JP
 *      [155]
 *      [156]
 *      [157]
 *              JS,     I_JS
 *      [158]
 *      [159]
 *      [160]
 *      [161]
 *              OR,     I_OR
 *      [162]
 *      [163]
 *      [164]
 *              JZ,     I_JZ
 *      [165]
 *      [166]
 *      [167]
 *      [168]
 *      [169]
 *      [170]
 *      [171]
 *      [172]
 *      [173]
 *      [174]
 *      [175]
 *      [176]
 *      [177]
 *      [178]
 *      [179]
 *      [180]
 *      [181]
 *      [182]
 *      [183]
 *      [184]
 *      [185]
 *      [186]
 *      [187]
 *      [188]
 *      [189]
 *      [190]
 *      [191]
 *      [192]
 *      [193]
 *      [194]
 *      [195]
 *              AAA,    I_AAA
 *      [196]
 *      [197]
 *      [198]
 *              DAA,    I_DAA
 *              AAD,    I_AAD
 *      [199]
 *      [200]
 *              ADC,    I_ADC
 *      [201]
 *              ADD,    I_ADD
 *      [202]
 *      [203]
 *      [204]
 *              DEC,    I_DEC
 *      [205]
 *      [206]
 *      [207]
 *              AAM,    I_AAM
 *      [208]
 *              JAE,    I_JAE
 *      [209]
 *              JBE,    I_JBE
 *      [210]
 *              LEA,    I_LEA
 *              CLC,    I_CLC
 *      [211]
 *              CMC,    I_CMC
 *              CLD,    I_CLD
 *              AND,    I_AND
 *      [212]
 *      [213]
 *              AAS,    I_AAS
 *      [214]
 *              JGE,    I_JGE
 *              FLD,    I_FLD
 *      [215]
 *              SBB,    I_SBB
 *      [216]
 *              DAS,    I_DAS
 *              CLI,    I_CLI
 *              CDQ,    I_CDQ
 *      [217]
 *              JNA,    I_JNA
 *              BTC,    I_BTC
 *      [218]
 *              NEG,    I_NEG
 *              JNB,    I_JNB
 *              INC,    I_INC
 *      [219]
 *              JNC,    I_JNC
 *              JLE,    I_JLE
 *              ESC,    I_ESC
 *              BSF,    I_BSF
 *      [220]
 *              CBW,    I_CBW
 *      [221]
 *              JNE,    I_JNE
 *      [222]
 *              CWD,    I_CWD
 *      [223]
 *              LAR,    I_LAR
 *              JPE,    I_JPE
 *              JNG,    I_JNG
 *      [224]
 *              SAL,    I_SAL
 *              CMP,    I_CMP
 *      [225]
 *              RCL,    I_RCL
 *      [226]
 *      [227]
 *              LDS,    I_LDS
 *              DIV,    I_DIV
 *      [228]
 *              LES,    I_LES
 *              JNL,    I_JNL
 *      [229]
 *              LFS,    I_LFS
 *      [230]
 *              SAR,    I_SAR
 *              LGS,    I_LGS
 *      [231]
 *              SHL,    I_SHL
 *              REP,    I_REP
 *              RCR,    I_RCR
 *              JNO,    I_JNO
 *              JMP,    I_JMP
 *              BSR,    I_BSR
 *      [232]
 *              JNP,    I_JNP
 *              HLT,    I_HLT
 *              BTR,    I_BTR
 *      [233]
 *              JPO,    I_JPO
 *              BTS,    I_BTS
 *      [234]
 *              SUB,    I_SUB
 *              STC,    I_STC
 *              INS,    I_INS
 *      [235]
 *              STD,    I_STD
 *              RET,    I_RET
 *              LSL,    I_LSL
 *              JNS,    I_JNS
 *              INT,    I_INT
 *      [236]
 *      [237]
 *              SHR,    I_SHR
 *              ROL,    I_ROL
 *              NOP,    I_NOP
 *              FST,    I_FST
 *      [238]
 *              MUL,    I_MUL
 *      [239]
 *              POP,    I_POP
 *      [240]
 *              STI,    I_STI
 *      [241]
 *              NOT,    I_NOT
 *      [242]
 *              MOV,    I_MOV
 *              LTR,    I_LTR
 *              LSS,    I_LSS
 *              JNZ,    I_JNZ
 *      [243]
 *              ROR,    I_ROR
 *      [244]
 *      [245]
 *      [246]
 *      [247]
 *      [248]
 *              OUT,    I_OUT
 *      [249]
 *              XOR,    I_XOR
 *              STR,    I_STR
 *      [250]
 *      [251]
 *      [252]
 *      [253]
 *      [254]
 *      [255]
 *      [256]
 *      [257]
 *      [258]
 *      [259]
 *      [260]
 *      [261]
 *      [262]
 *      [263]
 *              FLD1,   I_FLD1
 *      [264]
 *      [265]
 *      [266]
 *      [267]
 *      [268]
 *      [269]
 *      [270]
 *      [271]
 *              FADD,   I_FADD
 *      [272]
 *      [273]
 *      [274]
 *      [275]
 *      [276]
 *      [277]
 *      [278]
 *      [279]
 *      [280]
 *              FBLD,   I_FBLD
 *      [281]
 *      [282]
 *      [283]
 *              LAHF,   I_LAHF
 *      [284]
 *              FABS,   I_FABS
 *              CALL,   I_CALL
 *      [285]
 *      [286]
 *              JNAE,   I_JNAE
 *      [287]
 *              JNBE,   I_JNBE
 *              FILD,   I_FILD
 *      [288]
 *      [289]
 *      [290]
 *              SAHF,   I_SAHF
 *              FENI,   I_FENI
 *      [291]
 *              CWDE,   I_CWDE
 *      [292]
 *              JNGE,   I_JNGE
 *              FCHS,   I_FCHS
 *      [293]
 *              FCOM,   I_FCOM
 *      [294]
 *      [295]
 *      [296]
 *      [297]
 *              LOCK,   I_LOCK
 *              JNLE,   I_JNLE
 *              FXCH,   I_FXCH
 *              FDIV,   I_FDIV
 *      [298]
 *              XCHG,   I_XCHG
 *              SCAS,   I_SCAS
 *      [299]
 *              SHLD,   I_SHLD
 *              LGDT,   I_LGDT
 *              FCOS,   I_FCOS
 *      [300]
 *              REPE,   I_REPE
 *              INSB,   I_INSB
 *              IDIV,   I_IDIV
 *              FXAM,   I_FXAM
 *      [301]
 *              SETA,   I_SETA
 *              LIDT,   I_LIDT
 *      [302]
 *              SETB,   I_SETB
 *              INSD,   I_INSD
 *      [303]
 *              SETC,   I_SETC
 *              ARPL,   I_ARPL
 *      [304]
 *              POPA,   I_POPA
 *              LLDT,   I_LLDT
 *              FSUB,   I_FSUB
 *              FSIN,   I_FSIN
 *              FLDZ,   I_FLDZ
 *      [305]
 *              RETF,   I_RETF
 *              SHRD,   I_SHRD
 *              SETE,   I_SETE
 *      [306]
 *              SGDT,   I_SGDT
 *              LODS,   I_LODS
 *              IBTS,   I_IBTS
 *      [307]
 *              SETG,   I_SETG
 *              FNOP,   I_FNOP
 *              CMPS,   I_CMPS
 *      [308]
 *              SIDT,   I_SIDT
 *              IRET,   I_IRET
 *              FMUL,   I_FMUL
 *      [309]
 *              WAIT,   I_WAIT
 *              POPF,   I_POPF
 *      [310]
 *              FIST,   I_FIST
 *              CLTS,   I_CLTS
 *      [311]
 *              SLDT,   I_SLDT
 *              IMUL,   I_IMUL
 *      [312]
 *              SETL,   I_SETL
 *      [313]
 *              RETN,   I_RETN
 *              XLAT,   I_XLAT
 *      [314]
 *              LOOP,   I_LOOP
 *              INTO,   I_INTO
 *      [315]
 *              SETO,   I_SETO
 *      [316]
 *              SETP,   I_SETP
 *      [317]
 *              FSTP,   I_FSTP
 *      [318]
 *      [319]
 *              VERR,   I_VERR
 *              SETS,   I_SETS
 *              JCXZ,   I_JCXZ
 *      [320]
 *              TEST,   I_TEST
 *              PUSH,   I_PUSH
 *      [321]
 *              XBTS,   I_XBTS
 *              REPZ,   I_REPZ
 *              INSW,   I_INSW
 *              FTST,   I_FTST
 *      [322]
 *      [323]
 *              LMSW,   I_LMSW
 *      [324]
 *              VERW,   I_VERW
 *      [325]
 *              MOVS,   I_MOVS
 *      [326]
 *              SETZ,   I_SETZ
 *      [327]
 *      [328]
 *      [329]
 *              STOS,   I_STOS
 *      [330]
 *              SMSW,   I_SMSW
 *      [331]
 *              OUTS,   I_OUTS
 *      [332]
 *      [333]
 *      [334]
 *              F2XM1,  I_F2XM1
 *      [335]
 *      [336]
 *      [337]
 *      [338]
 *      [339]
 *      [340]
 *      [341]
 *      [342]
 *      [343]
 *      [344]
 *              FIADD,  I_FIADD
 *      [345]
 *      [346]
 *      [347]
 *      [348]
 *      [349]
 *      [350]
 *      [351]
 *              FADDP,  I_FADDP
 *      [352]
 *      [353]
 *      [354]
 *      [355]
 *      [356]
 *      [357]
 *      [358]
 *      [359]
 *      [360]
 *              FFREE,  I_FFREE
 *      [361]
 *      [362]
 *      [363]
 *      [364]
 *              SCASB,  I_SCASB
 *      [365]
 *              LEAVE,  I_LEAVE
 *      [366]
 *              SCASD,  I_SCASD
 *              FICOM,  I_FICOM
 *      [367]
 *              FLDPI,  I_FLDPI
 *              FDISI,  I_FDISI
 *      [368]
 *              FNENI,  I_FNENI
 *              FLDCW,  I_FLDCW
 *      [369]
 *      [370]
 *              SETAE,  I_SETAE
 *              FIDIV,  I_FIDIV
 *              FCLEX,  I_FCLEX
 *      [371]
 *              SETBE,  I_SETBE
 *      [372]
 *              POPAD,  I_POPAD
 *              LODSB,  I_LODSB
 *      [373]
 *              FYL2X,  I_FYL2X
 *              FSAVE,  I_FSAVE
 *              FCOMP,  I_FCOMP
 *              CMPSB,  I_CMPSB
 *      [374]
 *              LODSD,  I_LODSD
 *      [375]
 *              CMPSD,  I_CMPSD
 *      [376]
 *              SETGE,  I_SETGE
 *              IRETD,  I_IRETD
 *              BOUND,  I_BOUND
 *      [377]
 *              POPFD,  I_POPFD
 *              FPTAN,  I_FPTAN
 *              FISUB,  I_FISUB
 *              FDIVP,  I_FDIVP
 *      [378]
 *              REPNE,  I_REPNE
 *              FUCOM,  I_FUCOM
 *              FPREM,  I_FPREM
 *              FINIT,  I_FINIT
 *      [379]
 *              XLATB,  I_XLATB
 *              SETNA,  I_SETNA
 *              FWAIT,  I_FWAIT
 *              FDIVR,  I_FDIVR
 *      [380]
 *              SETNB,  I_SETNB
 *      [381]
 *              SETNC,  I_SETNC
 *              SETLE,  I_SETLE
 *              FIMUL,  I_FIMUL
 *      [382]
 *              ENTER,  I_ENTER
 *      [383]
 *              SETNE,  I_SETNE
 *              LOOPE,  I_LOOPE
 *              FBSTP,  I_FBSTP
 *      [384]
 *              FSUBP,  I_FSUBP
 *      [385]
 *              SETPE,  I_SETPE
 *              SETNG,  I_SETNG
 *              SCASW,  I_SCASW
 *              PUSHA,  I_PUSHA
 *      [386]
 *              FSUBR,  I_FSUBR
 *      [387]
 *      [388]
 *              JECXZ,  I_JECXZ
 *              FMULP,  I_FMULP
 *      [389]
 *      [390]
 *              SETNL,  I_SETNL
 *              PUSHF,  I_PUSHF
 *              FISTP,  I_FISTP
 *      [391]
 *              MOVSB,  I_MOVSB
 *              FSTCW,  I_FSTCW
 *      [392]
 *      [393]
 *              SETNO,  I_SETNO
 *              MOVSD,  I_MOVSD
 *              LODSW,  I_LODSW
 *      [394]
 *              SETNP,  I_SETNP
 *              CMPSW,  I_CMPSW
 *      [395]
 *              STOSB,  I_STOSB
 *              SETPO,  I_SETPO
 *      [396]
 *      [397]
 *              STOSD,  I_STOSD
 *              SETNS,  I_SETNS
 *              OUTSB,  I_OUTSB
 *      [398]
 *      [399]
 *              REPNZ,  I_REPNZ
 *              OUTSD,  I_OUTSD
 *      [400]
 *              FSQRT,  I_FSQRT
 *      [401]
 *      [402]
 *      [403]
 *      [404]
 *              SETNZ,  I_SETNZ
 *              LOOPZ,  I_LOOPZ
 *      [405]
 *      [406]
 *      [407]
 *              FSTSW,  I_FSTSW
 *      [408]
 *      [409]
 *              FLDL2E, I_FLDL2E
 *      [410]
 *      [411]
 *              FLDLG2, I_FLDLG2
 *      [412]
 *              MOVSW,  I_MOVSW
 *      [413]
 *              MOVSX,  I_MOVSX
 *      [414]
 *      [415]
 *      [416]
 *              STOSW,  I_STOSW
 *      [417]
 *      [418]
 *              OUTSW,  I_OUTSW
 *              FLDLN2, I_FLDLN2
 *      [419]
 *      [420]
 *              MOVZX,  I_MOVZX
 *      [421]
 *      [422]
 *      [423]
 *      [424]
 *              FLDL2T, I_FLDL2T
 *      [425]
 *      [426]
 *      [427]
 *              FPREM1, I_FPREM1
 *      [428]
 *      [429]
 *      [430]
 *              FSCALE, I_FSCALE
 *      [431]
 *      [432]
 *      [433]
 *      [434]
 *      [435]
 *      [436]
 *      [437]
 *      [438]
 *      [439]
 *      [440]
 *      [441]
 *      [442]
 *              FPATAN, I_FPATAN
 *      [443]
 *      [444]
 *      [445]
 *              FNDISI, I_FNDISI
 *      [446]
 *              FICOMP, I_FICOMP
 *      [447]
 *              FLDENV, I_FLDENV
 *      [448]
 *              SETNAE, I_SETNAE
 *              FNCLEX, I_FNCLEX
 *      [449]
 *              SETNBE, I_SETNBE
 *      [450]
 *      [451]
 *              FNSAVE, I_FNSAVE
 *      [452]
 *              FIDIVR, I_FIDIVR
 *      [453]
 *              PUSHAD, I_PUSHAD
 *              FCOMPP, I_FCOMPP
 *      [454]
 *              SETNGE, I_SETNGE
 *      [455]
 *      [456]
 *              FNINIT, I_FNINIT
 *      [457]
 *      [458]
 *              PUSHFD, I_PUSHFD
 *              FUCOMP, I_FUCOMP
 *      [459]
 *              SETNLE, I_SETNLE
 *              FISUBR, I_FISUBR
 *              FDIVRP, I_FDIVRP
 *      [460]
 *      [461]
 *              LOOPNE, I_LOOPNE
 *      [462]
 *      [463]
 *              FSETPM, I_FSETPM
 *      [464]
 *      [465]
 *      [466]
 *              FSUBRP, I_FSUBRP
 *      [467]
 *      [468]
 *      [469]
 *              FNSTCW, I_FNSTCW
 *      [470]
 *              FSTENV, I_FSTENV
 *      [471]
 *      [472]
 *      [473]
 *      [474]
 *      [475]
 *      [476]
 *      [477]
 *      [478]
 *      [479]
 *      [480]
 *              FRSTOR, I_FRSTOR
 *      [481]
 *      [482]
 *              LOOPNZ, I_LOOPNZ
 *      [483]
 *      [484]
 *      [485]
 *              FNSTSW, I_FNSTSW
 *      [486]
 *      [487]
 *      [488]
 *      [489]
 *      [490]
 *      [491]
 *      [492]
 *      [493]
 *      [494]
 *      [495]
 *      [496]
 *      [497]
 *      [498]
 *      [499]
 *      [500]
 *      [501]
 *      [502]
 *              FYL2XP1,        I_FYL2XP1
 *      [503]
 *      [504]
 *      [505]
 *      [506]
 *      [507]
 *      [508]
 *      [509]
 *      [510]
 *      [511]
 *      [512]
 *      [513]
 *      [514]
 *      [515]
 *      [516]
 *      [517]
 *      [518]
 *      [519]
 *      [520]
 *      [521]
 *              FDECSTP,        I_FDECSTP
 *      [522]
 *      [523]
 *      [524]
 *      [525]
 *      [526]
 *      [527]
 *      [528]
 *      [529]
 *      [530]
 *      [531]
 *      [532]
 *      [533]
 *              FSINCOS,        I_FSINCOS
 *              FRNDINT,        I_FRNDINT
 *      [534]
 *      [535]
 *              FINCSTP,        I_FINCSTP
 *      [536]
 *      [537]
 *      [538]
 *              FUCOMPP,        I_FUCOMPP
 *      [539]
 *      [540]
 *              FXTRACT,        I_FXTRACT
 *      [541]
 *      [542]
 *      [543]
 *      [544]
 *      [545]
 *      [546]
 *      [547]
 *      [548]
 *              FNSTENV,        I_FNSTENV
 *      [549]
 *      [550]
 *      [551]
 *      [552]
 *      [553]
 *      [554]
 *      [555]
 *      [556]
 *      [557]
 *      [558]
 *              FNRSTOR,        I_FNRSTOR
 *      [559]
 *      [560]
 *      [561]
 *      [562]
 *      [563]
 *      [564]
 *      [565]
 *      [566]
 */
static KEYSYM   t_oc306 = {0,"JA",139,I_JA};
static KEYSYM   t_oc308 = {0,"JB",140,I_JB};
static KEYSYM   t_oc310 = {0,"JC",141,I_JC};
static KEYSYM   t_oc312 = {0,"JE",143,I_JE};
static KEYSYM   t_oc314 = {0,"JG",145,I_JG};
static KEYSYM   t_oc180 = {0,"BT",150,I_BT};
static KEYSYM   t_oc316 = {&t_oc180,"JL",150,I_JL};
static KEYSYM   t_oc296 = {0,"IN",151,I_IN};
static KEYSYM   t_oc333 = {0,"JO",153,I_JO};
static KEYSYM   t_oc334 = {0,"JP",154,I_JP};
static KEYSYM   t_oc337 = {0,"JS",157,I_JS};
static KEYSYM   t_oc375 = {0,"OR",161,I_OR};
static KEYSYM   t_oc338 = {0,"JZ",164,I_JZ};
static KEYSYM   t_oc170 = {0,"AAA",195,I_AAA};
static KEYSYM   t_oc171 = {0,"AAD",198,I_AAD};
static KEYSYM   t_oc200 = {&t_oc171,"DAA",198,I_DAA};
static KEYSYM   t_oc174 = {0,"ADC",200,I_ADC};
static KEYSYM   t_oc175 = {0,"ADD",201,I_ADD};
static KEYSYM   t_oc202 = {0,"DEC",204,I_DEC};
static KEYSYM   t_oc172 = {0,"AAM",207,I_AAM};
static KEYSYM   t_oc307 = {0,"JAE",208,I_JAE};
static KEYSYM   t_oc309 = {0,"JBE",209,I_JBE};
static KEYSYM   t_oc188 = {0,"CLC",210,I_CLC};
static KEYSYM   t_oc342 = {&t_oc188,"LEA",210,I_LEA};
static KEYSYM   t_oc176 = {0,"AND",211,I_AND};
static KEYSYM   t_oc189 = {&t_oc176,"CLD",211,I_CLD};
static KEYSYM   t_oc192 = {&t_oc189,"CMC",211,I_CMC};
static KEYSYM   t_oc173 = {0,"AAS",213,I_AAS};
static KEYSYM   t_oc239 = {0,"FLD",214,I_FLD};
static KEYSYM   t_oc315 = {&t_oc239,"JGE",214,I_JGE};
static KEYSYM   t_oc404 = {0,"SBB",215,I_SBB};
static KEYSYM   t_oc187 = {0,"CDQ",216,I_CDQ};
static KEYSYM   t_oc190 = {&t_oc187,"CLI",216,I_CLI};
static KEYSYM   t_oc201 = {&t_oc190,"DAS",216,I_DAS};
static KEYSYM   t_oc181 = {0,"BTC",217,I_BTC};
static KEYSYM   t_oc319 = {&t_oc181,"JNA",217,I_JNA};
static KEYSYM   t_oc297 = {0,"INC",218,I_INC};
static KEYSYM   t_oc321 = {&t_oc297,"JNB",218,I_JNB};
static KEYSYM   t_oc372 = {&t_oc321,"NEG",218,I_NEG};
static KEYSYM   t_oc178 = {0,"BSF",219,I_BSF};
static KEYSYM   t_oc205 = {&t_oc178,"ESC",219,I_ESC};
static KEYSYM   t_oc317 = {&t_oc205,"JLE",219,I_JLE};
static KEYSYM   t_oc323 = {&t_oc317,"JNC",219,I_JNC};
static KEYSYM   t_oc186 = {0,"CBW",220,I_CBW};
static KEYSYM   t_oc324 = {0,"JNE",221,I_JNE};
static KEYSYM   t_oc198 = {0,"CWD",222,I_CWD};
static KEYSYM   t_oc325 = {0,"JNG",223,I_JNG};
static KEYSYM   t_oc335 = {&t_oc325,"JPE",223,I_JPE};
static KEYSYM   t_oc340 = {&t_oc335,"LAR",223,I_LAR};
static KEYSYM   t_oc193 = {0,"CMP",224,I_CMP};
static KEYSYM   t_oc402 = {&t_oc193,"SAL",224,I_SAL};
static KEYSYM   t_oc391 = {0,"RCL",225,I_RCL};
static KEYSYM   t_oc203 = {0,"DIV",227,I_DIV};
static KEYSYM   t_oc341 = {&t_oc203,"LDS",227,I_LDS};
static KEYSYM   t_oc327 = {0,"JNL",228,I_JNL};
static KEYSYM   t_oc344 = {&t_oc327,"LES",228,I_LES};
static KEYSYM   t_oc345 = {0,"LFS",229,I_LFS};
static KEYSYM   t_oc346 = {0,"LGS",230,I_LGS};
static KEYSYM   t_oc403 = {&t_oc346,"SAR",230,I_SAR};
static KEYSYM   t_oc179 = {0,"BSR",231,I_BSR};
static KEYSYM   t_oc318 = {&t_oc179,"JMP",231,I_JMP};
static KEYSYM   t_oc329 = {&t_oc318,"JNO",231,I_JNO};
static KEYSYM   t_oc392 = {&t_oc329,"RCR",231,I_RCR};
static KEYSYM   t_oc393 = {&t_oc392,"REP",231,I_REP};
static KEYSYM   t_oc440 = {&t_oc393,"SHL",231,I_SHL};
static KEYSYM   t_oc182 = {0,"BTR",232,I_BTR};
static KEYSYM   t_oc292 = {&t_oc182,"HLT",232,I_HLT};
static KEYSYM   t_oc330 = {&t_oc292,"JNP",232,I_JNP};
static KEYSYM   t_oc183 = {0,"BTS",233,I_BTS};
static KEYSYM   t_oc336 = {&t_oc183,"JPO",233,I_JPO};
static KEYSYM   t_oc298 = {0,"INS",234,I_INS};
static KEYSYM   t_oc448 = {&t_oc298,"STC",234,I_STC};
static KEYSYM   t_oc455 = {&t_oc448,"SUB",234,I_SUB};
static KEYSYM   t_oc302 = {0,"INT",235,I_INT};
static KEYSYM   t_oc331 = {&t_oc302,"JNS",235,I_JNS};
static KEYSYM   t_oc361 = {&t_oc331,"LSL",235,I_LSL};
static KEYSYM   t_oc398 = {&t_oc361,"RET",235,I_RET};
static KEYSYM   t_oc449 = {&t_oc398,"STD",235,I_STD};
static KEYSYM   t_oc273 = {0,"FST",237,I_FST};
static KEYSYM   t_oc373 = {&t_oc273,"NOP",237,I_NOP};
static KEYSYM   t_oc399 = {&t_oc373,"ROL",237,I_ROL};
static KEYSYM   t_oc442 = {&t_oc399,"SHR",237,I_SHR};
static KEYSYM   t_oc371 = {0,"MUL",238,I_MUL};
static KEYSYM   t_oc381 = {0,"POP",239,I_POP};
static KEYSYM   t_oc450 = {0,"STI",240,I_STI};
static KEYSYM   t_oc374 = {0,"NOT",241,I_NOT};
static KEYSYM   t_oc332 = {0,"JNZ",242,I_JNZ};
static KEYSYM   t_oc362 = {&t_oc332,"LSS",242,I_LSS};
static KEYSYM   t_oc363 = {&t_oc362,"LTR",242,I_LTR};
static KEYSYM   t_oc364 = {&t_oc363,"MOV",242,I_MOV};
static KEYSYM   t_oc400 = {0,"ROR",243,I_ROR};
static KEYSYM   t_oc376 = {0,"OUT",248,I_OUT};
static KEYSYM   t_oc447 = {0,"STR",249,I_STR};
static KEYSYM   t_oc464 = {&t_oc447,"XOR",249,I_XOR};
static KEYSYM   t_oc240 = {0,"FLD1",263,I_FLD1};
static KEYSYM   t_oc208 = {0,"FADD",271,I_FADD};
static KEYSYM   t_oc210 = {0,"FBLD",280,I_FBLD};
static KEYSYM   t_oc339 = {0,"LAHF",283,I_LAHF};
static KEYSYM   t_oc185 = {0,"CALL",284,I_CALL};
static KEYSYM   t_oc207 = {&t_oc185,"FABS",284,I_FABS};
static KEYSYM   t_oc320 = {0,"JNAE",286,I_JNAE};
static KEYSYM   t_oc231 = {0,"FILD",287,I_FILD};
static KEYSYM   t_oc322 = {&t_oc231,"JNBE",287,I_JNBE};
static KEYSYM   t_oc224 = {0,"FENI",290,I_FENI};
static KEYSYM   t_oc401 = {&t_oc224,"SAHF",290,I_SAHF};
static KEYSYM   t_oc199 = {0,"CWDE",291,I_CWDE};
static KEYSYM   t_oc212 = {0,"FCHS",292,I_FCHS};
static KEYSYM   t_oc326 = {&t_oc212,"JNGE",292,I_JNGE};
static KEYSYM   t_oc214 = {0,"FCOM",293,I_FCOM};
static KEYSYM   t_oc220 = {0,"FDIV",297,I_FDIV};
static KEYSYM   t_oc288 = {&t_oc220,"FXCH",297,I_FXCH};
static KEYSYM   t_oc328 = {&t_oc288,"JNLE",297,I_JNLE};
static KEYSYM   t_oc351 = {&t_oc328,"LOCK",297,I_LOCK};
static KEYSYM   t_oc405 = {0,"SCAS",298,I_SCAS};
static KEYSYM   t_oc461 = {&t_oc405,"XCHG",298,I_XCHG};
static KEYSYM   t_oc217 = {0,"FCOS",299,I_FCOS};
static KEYSYM   t_oc347 = {&t_oc217,"LGDT",299,I_LGDT};
static KEYSYM   t_oc441 = {&t_oc347,"SHLD",299,I_SHLD};
static KEYSYM   t_oc287 = {0,"FXAM",300,I_FXAM};
static KEYSYM   t_oc294 = {&t_oc287,"IDIV",300,I_IDIV};
static KEYSYM   t_oc299 = {&t_oc294,"INSB",300,I_INSB};
static KEYSYM   t_oc394 = {&t_oc299,"REPE",300,I_REPE};
static KEYSYM   t_oc348 = {0,"LIDT",301,I_LIDT};
static KEYSYM   t_oc409 = {&t_oc348,"SETA",301,I_SETA};
static KEYSYM   t_oc300 = {0,"INSD",302,I_INSD};
static KEYSYM   t_oc411 = {&t_oc300,"SETB",302,I_SETB};
static KEYSYM   t_oc177 = {0,"ARPL",303,I_ARPL};
static KEYSYM   t_oc413 = {&t_oc177,"SETC",303,I_SETC};
static KEYSYM   t_oc248 = {0,"FLDZ",304,I_FLDZ};
static KEYSYM   t_oc270 = {&t_oc248,"FSIN",304,I_FSIN};
static KEYSYM   t_oc278 = {&t_oc270,"FSUB",304,I_FSUB};
static KEYSYM   t_oc349 = {&t_oc278,"LLDT",304,I_LLDT};
static KEYSYM   t_oc382 = {&t_oc349,"POPA",304,I_POPA};
static KEYSYM   t_oc414 = {0,"SETE",305,I_SETE};
static KEYSYM   t_oc443 = {&t_oc414,"SHRD",305,I_SHRD};
static KEYSYM   t_oc466 = {&t_oc443,"RETF",305,I_RETF};
static KEYSYM   t_oc293 = {0,"IBTS",306,I_IBTS};
static KEYSYM   t_oc352 = {&t_oc293,"LODS",306,I_LODS};
static KEYSYM   t_oc439 = {&t_oc352,"SGDT",306,I_SGDT};
static KEYSYM   t_oc194 = {0,"CMPS",307,I_CMPS};
static KEYSYM   t_oc255 = {&t_oc194,"FNOP",307,I_FNOP};
static KEYSYM   t_oc415 = {&t_oc255,"SETG",307,I_SETG};
static KEYSYM   t_oc249 = {0,"FMUL",308,I_FMUL};
static KEYSYM   t_oc304 = {&t_oc249,"IRET",308,I_IRET};
static KEYSYM   t_oc444 = {&t_oc304,"SIDT",308,I_SIDT};
static KEYSYM   t_oc384 = {0,"POPF",309,I_POPF};
static KEYSYM   t_oc459 = {&t_oc384,"WAIT",309,I_WAIT};
static KEYSYM   t_oc191 = {0,"CLTS",310,I_CLTS};
static KEYSYM   t_oc235 = {&t_oc191,"FIST",310,I_FIST};
static KEYSYM   t_oc295 = {0,"IMUL",311,I_IMUL};
static KEYSYM   t_oc445 = {&t_oc295,"SLDT",311,I_SLDT};
static KEYSYM   t_oc417 = {0,"SETL",312,I_SETL};
static KEYSYM   t_oc462 = {0,"XLAT",313,I_XLAT};
static KEYSYM   t_oc465 = {&t_oc462,"RETN",313,I_RETN};
static KEYSYM   t_oc303 = {0,"INTO",314,I_INTO};
static KEYSYM   t_oc356 = {&t_oc303,"LOOP",314,I_LOOP};
static KEYSYM   t_oc433 = {0,"SETO",315,I_SETO};
static KEYSYM   t_oc434 = {0,"SETP",316,I_SETP};
static KEYSYM   t_oc276 = {0,"FSTP",317,I_FSTP};
static KEYSYM   t_oc311 = {0,"JCXZ",319,I_JCXZ};
static KEYSYM   t_oc437 = {&t_oc311,"SETS",319,I_SETS};
static KEYSYM   t_oc457 = {&t_oc437,"VERR",319,I_VERR};
static KEYSYM   t_oc386 = {0,"PUSH",320,I_PUSH};
static KEYSYM   t_oc456 = {&t_oc386,"TEST",320,I_TEST};
static KEYSYM   t_oc282 = {0,"FTST",321,I_FTST};
static KEYSYM   t_oc301 = {&t_oc282,"INSW",321,I_INSW};
static KEYSYM   t_oc397 = {&t_oc301,"REPZ",321,I_REPZ};
static KEYSYM   t_oc460 = {&t_oc397,"XBTS",321,I_XBTS};
static KEYSYM   t_oc350 = {0,"LMSW",323,I_LMSW};
static KEYSYM   t_oc458 = {0,"VERW",324,I_VERW};
static KEYSYM   t_oc365 = {0,"MOVS",325,I_MOVS};
static KEYSYM   t_oc438 = {0,"SETZ",326,I_SETZ};
static KEYSYM   t_oc451 = {0,"STOS",329,I_STOS};
static KEYSYM   t_oc446 = {0,"SMSW",330,I_SMSW};
static KEYSYM   t_oc377 = {0,"OUTS",331,I_OUTS};
static KEYSYM   t_oc206 = {0,"F2XM1",334,I_F2XM1};
static KEYSYM   t_oc226 = {0,"FIADD",344,I_FIADD};
static KEYSYM   t_oc209 = {0,"FADDP",351,I_FADDP};
static KEYSYM   t_oc225 = {0,"FFREE",360,I_FFREE};
static KEYSYM   t_oc406 = {0,"SCASB",364,I_SCASB};
static KEYSYM   t_oc343 = {0,"LEAVE",365,I_LEAVE};
static KEYSYM   t_oc227 = {0,"FICOM",366,I_FICOM};
static KEYSYM   t_oc407 = {&t_oc227,"SCASD",366,I_SCASD};
static KEYSYM   t_oc219 = {0,"FDISI",367,I_FDISI};
static KEYSYM   t_oc247 = {&t_oc219,"FLDPI",367,I_FLDPI};
static KEYSYM   t_oc241 = {0,"FLDCW",368,I_FLDCW};
static KEYSYM   t_oc253 = {&t_oc241,"FNENI",368,I_FNENI};
static KEYSYM   t_oc213 = {0,"FCLEX",370,I_FCLEX};
static KEYSYM   t_oc229 = {&t_oc213,"FIDIV",370,I_FIDIV};
static KEYSYM   t_oc410 = {&t_oc229,"SETAE",370,I_SETAE};
static KEYSYM   t_oc412 = {0,"SETBE",371,I_SETBE};
static KEYSYM   t_oc353 = {0,"LODSB",372,I_LODSB};
static KEYSYM   t_oc383 = {&t_oc353,"POPAD",372,I_POPAD};
static KEYSYM   t_oc195 = {0,"CMPSB",373,I_CMPSB};
static KEYSYM   t_oc215 = {&t_oc195,"FCOMP",373,I_FCOMP};
static KEYSYM   t_oc267 = {&t_oc215,"FSAVE",373,I_FSAVE};
static KEYSYM   t_oc290 = {&t_oc267,"FYL2X",373,I_FYL2X};
static KEYSYM   t_oc354 = {0,"LODSD",374,I_LODSD};
static KEYSYM   t_oc196 = {0,"CMPSD",375,I_CMPSD};
static KEYSYM   t_oc184 = {0,"BOUND",376,I_BOUND};
static KEYSYM   t_oc305 = {&t_oc184,"IRETD",376,I_IRETD};
static KEYSYM   t_oc416 = {&t_oc305,"SETGE",376,I_SETGE};
static KEYSYM   t_oc221 = {0,"FDIVP",377,I_FDIVP};
static KEYSYM   t_oc237 = {&t_oc221,"FISUB",377,I_FISUB};
static KEYSYM   t_oc264 = {&t_oc237,"FPTAN",377,I_FPTAN};
static KEYSYM   t_oc385 = {&t_oc264,"POPFD",377,I_POPFD};
static KEYSYM   t_oc234 = {0,"FINIT",378,I_FINIT};
static KEYSYM   t_oc262 = {&t_oc234,"FPREM",378,I_FPREM};
static KEYSYM   t_oc283 = {&t_oc262,"FUCOM",378,I_FUCOM};
static KEYSYM   t_oc395 = {&t_oc283,"REPNE",378,I_REPNE};
static KEYSYM   t_oc222 = {0,"FDIVR",379,I_FDIVR};
static KEYSYM   t_oc286 = {&t_oc222,"FWAIT",379,I_FWAIT};
static KEYSYM   t_oc419 = {&t_oc286,"SETNA",379,I_SETNA};
static KEYSYM   t_oc463 = {&t_oc419,"XLATB",379,I_XLATB};
static KEYSYM   t_oc421 = {0,"SETNB",380,I_SETNB};
static KEYSYM   t_oc232 = {0,"FIMUL",381,I_FIMUL};
static KEYSYM   t_oc418 = {&t_oc232,"SETLE",381,I_SETLE};
static KEYSYM   t_oc423 = {&t_oc418,"SETNC",381,I_SETNC};
static KEYSYM   t_oc204 = {0,"ENTER",382,I_ENTER};
static KEYSYM   t_oc211 = {0,"FBSTP",383,I_FBSTP};
static KEYSYM   t_oc357 = {&t_oc211,"LOOPE",383,I_LOOPE};
static KEYSYM   t_oc424 = {&t_oc357,"SETNE",383,I_SETNE};
static KEYSYM   t_oc279 = {0,"FSUBP",384,I_FSUBP};
static KEYSYM   t_oc387 = {0,"PUSHA",385,I_PUSHA};
static KEYSYM   t_oc408 = {&t_oc387,"SCASW",385,I_SCASW};
static KEYSYM   t_oc425 = {&t_oc408,"SETNG",385,I_SETNG};
static KEYSYM   t_oc435 = {&t_oc425,"SETPE",385,I_SETPE};
static KEYSYM   t_oc280 = {0,"FSUBR",386,I_FSUBR};
static KEYSYM   t_oc250 = {0,"FMULP",388,I_FMULP};
static KEYSYM   t_oc313 = {&t_oc250,"JECXZ",388,I_JECXZ};
static KEYSYM   t_oc236 = {0,"FISTP",390,I_FISTP};
static KEYSYM   t_oc389 = {&t_oc236,"PUSHF",390,I_PUSHF};
static KEYSYM   t_oc427 = {&t_oc389,"SETNL",390,I_SETNL};
static KEYSYM   t_oc274 = {0,"FSTCW",391,I_FSTCW};
static KEYSYM   t_oc366 = {&t_oc274,"MOVSB",391,I_MOVSB};
static KEYSYM   t_oc355 = {0,"LODSW",393,I_LODSW};
static KEYSYM   t_oc367 = {&t_oc355,"MOVSD",393,I_MOVSD};
static KEYSYM   t_oc429 = {&t_oc367,"SETNO",393,I_SETNO};
static KEYSYM   t_oc197 = {0,"CMPSW",394,I_CMPSW};
static KEYSYM   t_oc430 = {&t_oc197,"SETNP",394,I_SETNP};
static KEYSYM   t_oc436 = {0,"SETPO",395,I_SETPO};
static KEYSYM   t_oc452 = {&t_oc436,"STOSB",395,I_STOSB};
static KEYSYM   t_oc378 = {0,"OUTSB",397,I_OUTSB};
static KEYSYM   t_oc431 = {&t_oc378,"SETNS",397,I_SETNS};
static KEYSYM   t_oc453 = {&t_oc431,"STOSD",397,I_STOSD};
static KEYSYM   t_oc379 = {0,"OUTSD",399,I_OUTSD};
static KEYSYM   t_oc396 = {&t_oc379,"REPNZ",399,I_REPNZ};
static KEYSYM   t_oc272 = {0,"FSQRT",400,I_FSQRT};
static KEYSYM   t_oc360 = {0,"LOOPZ",404,I_LOOPZ};
static KEYSYM   t_oc432 = {&t_oc360,"SETNZ",404,I_SETNZ};
static KEYSYM   t_oc277 = {0,"FSTSW",407,I_FSTSW};
static KEYSYM   t_oc243 = {0,"FLDL2E",409,I_FLDL2E};
static KEYSYM   t_oc245 = {0,"FLDLG2",411,I_FLDLG2};
static KEYSYM   t_oc368 = {0,"MOVSW",412,I_MOVSW};
static KEYSYM   t_oc369 = {0,"MOVSX",413,I_MOVSX};
static KEYSYM   t_oc454 = {0,"STOSW",416,I_STOSW};
static KEYSYM   t_oc246 = {0,"FLDLN2",418,I_FLDLN2};
static KEYSYM   t_oc380 = {&t_oc246,"OUTSW",418,I_OUTSW};
static KEYSYM   t_oc370 = {0,"MOVZX",420,I_MOVZX};
static KEYSYM   t_oc244 = {0,"FLDL2T",424,I_FLDL2T};
static KEYSYM   t_oc263 = {0,"FPREM1",427,I_FPREM1};
static KEYSYM   t_oc268 = {0,"FSCALE",430,I_FSCALE};
static KEYSYM   t_oc261 = {0,"FPATAN",442,I_FPATAN};
static KEYSYM   t_oc252 = {0,"FNDISI",445,I_FNDISI};
static KEYSYM   t_oc228 = {0,"FICOMP",446,I_FICOMP};
static KEYSYM   t_oc242 = {0,"FLDENV",447,I_FLDENV};
static KEYSYM   t_oc251 = {0,"FNCLEX",448,I_FNCLEX};
static KEYSYM   t_oc420 = {&t_oc251,"SETNAE",448,I_SETNAE};
static KEYSYM   t_oc422 = {0,"SETNBE",449,I_SETNBE};
static KEYSYM   t_oc257 = {0,"FNSAVE",451,I_FNSAVE};
static KEYSYM   t_oc230 = {0,"FIDIVR",452,I_FIDIVR};
static KEYSYM   t_oc216 = {0,"FCOMPP",453,I_FCOMPP};
static KEYSYM   t_oc388 = {&t_oc216,"PUSHAD",453,I_PUSHAD};
static KEYSYM   t_oc426 = {0,"SETNGE",454,I_SETNGE};
static KEYSYM   t_oc254 = {0,"FNINIT",456,I_FNINIT};
static KEYSYM   t_oc284 = {0,"FUCOMP",458,I_FUCOMP};
static KEYSYM   t_oc390 = {&t_oc284,"PUSHFD",458,I_PUSHFD};
static KEYSYM   t_oc223 = {0,"FDIVRP",459,I_FDIVRP};
static KEYSYM   t_oc238 = {&t_oc223,"FISUBR",459,I_FISUBR};
static KEYSYM   t_oc428 = {&t_oc238,"SETNLE",459,I_SETNLE};
static KEYSYM   t_oc358 = {0,"LOOPNE",461,I_LOOPNE};
static KEYSYM   t_oc269 = {0,"FSETPM",463,I_FSETPM};
static KEYSYM   t_oc281 = {0,"FSUBRP",466,I_FSUBRP};
static KEYSYM   t_oc258 = {0,"FNSTCW",469,I_FNSTCW};
static KEYSYM   t_oc275 = {0,"FSTENV",470,I_FSTENV};
static KEYSYM   t_oc266 = {0,"FRSTOR",480,I_FRSTOR};
static KEYSYM   t_oc359 = {0,"LOOPNZ",482,I_LOOPNZ};
static KEYSYM   t_oc260 = {0,"FNSTSW",485,I_FNSTSW};
static KEYSYM   t_oc291 = {0,"FYL2XP1",502,I_FYL2XP1};
static KEYSYM   t_oc218 = {0,"FDECSTP",521,I_FDECSTP};
static KEYSYM   t_oc265 = {0,"FRNDINT",533,I_FRNDINT};
static KEYSYM   t_oc271 = {&t_oc265,"FSINCOS",533,I_FSINCOS};
static KEYSYM   t_oc233 = {0,"FINCSTP",535,I_FINCSTP};
static KEYSYM   t_oc285 = {0,"FUCOMPP",538,I_FUCOMPP};
static KEYSYM   t_oc289 = {0,"FXTRACT",540,I_FXTRACT};
static KEYSYM   t_oc259 = {0,"FNSTENV",548,I_FNSTENV};
static KEYSYM   t_oc256 = {0,"FNRSTOR",558,I_FNRSTOR};

static KEYSYM FARSYM *t_oc_words[567] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc306,
        &t_oc308,
        &t_oc310,
        0,
        &t_oc312,
        0,
        &t_oc314,
        0,
        0,
        0,
        0,
        &t_oc316,
        &t_oc296,
        0,
        &t_oc333,
        &t_oc334,
        0,
        0,
        &t_oc337,
        0,
        0,
        0,
        &t_oc375,
        0,
        0,
        &t_oc338,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc170,
        0,
        0,
        &t_oc200,
        0,
        &t_oc174,
        &t_oc175,
        0,
        0,
        &t_oc202,
        0,
        0,
        &t_oc172,
        &t_oc307,
        &t_oc309,
        &t_oc342,
        &t_oc192,
        0,
        &t_oc173,
        &t_oc315,
        &t_oc404,
        &t_oc201,
        &t_oc319,
        &t_oc372,
        &t_oc323,
        &t_oc186,
        &t_oc324,
        &t_oc198,
        &t_oc340,
        &t_oc402,
        &t_oc391,
        0,
        &t_oc341,
        &t_oc344,
        &t_oc345,
        &t_oc403,
        &t_oc440,
        &t_oc330,
        &t_oc336,
        &t_oc455,
        &t_oc449,
        0,
        &t_oc442,
        &t_oc371,
        &t_oc381,
        &t_oc450,
        &t_oc374,
        &t_oc364,
        &t_oc400,
        0,
        0,
        0,
        0,
        &t_oc376,
        &t_oc464,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc240,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc208,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc210,
        0,
        0,
        &t_oc339,
        &t_oc207,
        0,
        &t_oc320,
        &t_oc322,
        0,
        0,
        &t_oc401,
        &t_oc199,
        &t_oc326,
        &t_oc214,
        0,
        0,
        0,
        &t_oc351,
        &t_oc461,
        &t_oc441,
        &t_oc394,
        &t_oc409,
        &t_oc411,
        &t_oc413,
        &t_oc382,
        &t_oc466,
        &t_oc439,
        &t_oc415,
        &t_oc444,
        &t_oc459,
        &t_oc235,
        &t_oc445,
        &t_oc417,
        &t_oc465,
        &t_oc356,
        &t_oc433,
        &t_oc434,
        &t_oc276,
        0,
        &t_oc457,
        &t_oc456,
        &t_oc460,
        0,
        &t_oc350,
        &t_oc458,
        &t_oc365,
        &t_oc438,
        0,
        0,
        &t_oc451,
        &t_oc446,
        &t_oc377,
        0,
        0,
        &t_oc206,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc226,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc209,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc225,
        0,
        0,
        0,
        &t_oc406,
        &t_oc343,
        &t_oc407,
        &t_oc247,
        &t_oc253,
        0,
        &t_oc410,
        &t_oc412,
        &t_oc383,
        &t_oc290,
        &t_oc354,
        &t_oc196,
        &t_oc416,
        &t_oc385,
        &t_oc395,
        &t_oc463,
        &t_oc421,
        &t_oc423,
        &t_oc204,
        &t_oc424,
        &t_oc279,
        &t_oc435,
        &t_oc280,
        0,
        &t_oc313,
        0,
        &t_oc427,
        &t_oc366,
        0,
        &t_oc429,
        &t_oc430,
        &t_oc452,
        0,
        &t_oc453,
        0,
        &t_oc396,
        &t_oc272,
        0,
        0,
        0,
        &t_oc432,
        0,
        0,
        &t_oc277,
        0,
        &t_oc243,
        0,
        &t_oc245,
        &t_oc368,
        &t_oc369,
        0,
        0,
        &t_oc454,
        0,
        &t_oc380,
        0,
        &t_oc370,
        0,
        0,
        0,
        &t_oc244,
        0,
        0,
        &t_oc263,
        0,
        0,
        &t_oc268,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc261,
        0,
        0,
        &t_oc252,
        &t_oc228,
        &t_oc242,
        &t_oc420,
        &t_oc422,
        0,
        &t_oc257,
        &t_oc230,
        &t_oc388,
        &t_oc426,
        0,
        &t_oc254,
        0,
        &t_oc390,
        &t_oc428,
        0,
        &t_oc358,
        0,
        &t_oc269,
        0,
        0,
        &t_oc281,
        0,
        0,
        &t_oc258,
        &t_oc275,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc266,
        0,
        &t_oc359,
        0,
        0,
        &t_oc260,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc291,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc218,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc271,
        0,
        &t_oc233,
        0,
        0,
        &t_oc285,
        0,
        &t_oc289,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc259,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc256,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
        };

KEYWORDS t_oc_table = {t_oc_words,567};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asminptb.c ===
/* asminptb.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#define ASMINP		/* prevent external declaration of _asmctype_ */

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"

#define ID   (_AT | _A1 | _AF)
#define IDO  (_AT | _A1)
#define DIG  (_AT | _AF)
#define TERM (_AL | _AZ)
#define SIGN (_AS | _AF | _AO)
#define DOT  (_A1 | _AF | _AO)
#define BAD  0
#define BRK  0

/*  00	 01   02   03	04   05   06   07   08	 09   0a   0b	0c   0d   0e   0f	  */

UCHAR _asmctype_[256] = {

  TERM, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, _AB, _AL, BAD, BAD, _AL, BAD, BAD,  /* 0x */
   BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD,  /* 1x */
   _AB, BAD, BAD, BAD, IDO, IDO, BAD, BAD, _AO, _AO, _AO,SIGN, BAD,SIGN, DOT, _AO,  /* 2x */
   DIG, DIG, DIG, DIG, DIG, DIG, DIG, DIG, DIG, DIG, _AO, _AZ, BAD, BAD, BAD, IDO,  /* 3x */
   IDO,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  /* 4x */
    ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID, _AO, BAD, _AO, BAD, IDO,  /* 5x */
   BAD,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  /* 6x */
    ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID, BAD, BAD, BAD, BAD, BAD   /* 7x */
};

/*  00	  01   02   03	 04   05   06	07   08   09   0a   0b	 0c   0d   0e	0f	   */

char _asmcupper_[] = {

   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,  /* 0x */
   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,  /* 1x */

    ' ', '!', '"', '#', '$', '%', '&','\'', '(', ')', '*', '+', ',', '-', '.', '/',  /* 2x */
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',  /* 3x */
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 4x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[','\\', ']', '^', '_',  /* 5x */
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 6x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~',0x7F   /* 7x */
};

/*  00	  01   02   03	 04   05   06	07   08   09   0a   0b	 0c   0d   0e	0f	   */

char _asmTokenMap_[] = {

    BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK,  /* 0x */
    BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK,  /* 1x */

    BRK, BRK, BRK, BRK, '$', '%', BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK,  /* 2x */
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', BRK, BRK, BRK, BRK, BRK, '?',  /* 3x */
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 4x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', BRK, BRK, BRK, BRK, '_',  /* 5x */
    BRK, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 6x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', BRK, BRK, BRK, BRK, BRK   /* 7x */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmmsg.h ===
#define ER_FAT  258
#define ER_STR  261
#define ER_UNK  263
#define ER_EO2  265
#define ER_SEG  266
#define ER_PRO  267
#define ER_CON  268
#define ER_COP  269
#define ER_UOC  270
#define ER_WEO  271
#define ER_WEL  272
#define ER_WEC  273
#define ER_UOI  274
#define ER_ULI  275
#define ER_UOL  276
#define ER_UOO  277
#define ER_EM1  278
#define ER_EM2  279
#define ER_SOU  280
#define ER_SY2  281
#define ER_BYT  282
#define ER_MEM  283
#define ER_EXT  284
#define ER_INV  285
#define ER_PAT  287
#define ER_UNC  288
#define ER_UNS  289
#define ER_SIN  290
#define ER_HEP  291
#define ER_EXS  292
#define ER_WAN  293
#define ER_BNE  257
#define ER_ECL  258
#define ER_RAD  259
#define ER_UST  260
#define ER_RSY  261
#define ER_SMD  262
#define ER_PHE  263
#define ER_ELS  264
#define ER_NCB  265
#define ER_SND  266
#define ER_SYN  267
#define ER_TIL  268
#define ER_NGR  269
#define ER_PS1  270
#define ER_TUL  271
#define ER_SDK  272
#define ER_RES  273
#define ER_IFR  274
#define ER_MBR  275
#define ER_WRT  276
#define ER_MSG  277
#define ER_MSY  279
#define ER_ALD  280
#define ER_SPC  281
#define ER_NPA  282
#define ER_RMD  283
#define ER_OPN  284
#define ER_OPR  285
#define ER_DV0  286
#define ER_SCN  287
#define ER_OMM  288
#define ER_IUE  289
#define ER_RRF  291
#define ER_OHS  292
#define ER_NOP  293
#define ER_LOS  295
#define ER_OOC  296
#define ER_OSA  297
#define ER_CXP  299
#define ER_OSG  300
#define ER_ASD  301
#define ER_ASC  302
#define ER_DBR  303
#define ER_DIR  304
#define ER_IBR  305
#define ER_IUR  306
#define ER_VOR  307
#define ER_NIP  308
#define ER_IOT  309
#define ER_JOR  310
#define ER_IRV  312
#define ER_NIM  313
#define ER_IIS  314
#define ER_BRI  315
#define ER_CSI  316
#define ER_AXL  317
#define ER_ISR  318
#define ER_NCS  319
#define ER_OCI  320
#define ER_JCD  321
#define ER_NSO  322
#define ER_OAP  323
#define ER_OES  324
#define ER_CRS  325
#define ER_MSB  326
#define ER_NEB  327
#define ER_FOF  328
#define ER_IDV  329
#define ER_SAE  330
#define ER_DTL  331
#define ER_UID  332
#define ER_MVD  333
#define ER_OIL  334
#define ER_DIS  335
#define ER_ODI  336
#define ER_FCO  337
#define ER_CEA  340
#define ER_7OE  341
#define ER_EOF  342
#define ER_ENS  343
#define ER_EP1  344
#define ER_EP2  345
#define ER_ERR  346
#define ER_ERE  347
#define ER_ERZ  348
#define ER_END  349
#define ER_ESD  350
#define ER_EBL  351
#define ER_ENB  352
#define ER_EID  353
#define ER_EDF  354
#define ER_OWL  355
#define ER_LTL  356
#define ER_IMP  357
#define ER_MDZ  358
#define ER_286  359
#define ER_CPU  360
#define ER_ONW  361
#define ER_ANW  362
#define ER_JSH  363
#define ER_AP2  364
#define ER_EXP  365
#define ER_LNL  366
#define ER_NDN  367
#define ER_EMS  368
#define ER_MOP  369
#define ER_PAR  370
#define ER_NMC  371
#define ER_UEL  372
#define ER_INC  373
#define ER_FPO1 374
#define ER_FPO2 375
#define ER_H01  401
#define ER_H02  402
#define ER_H03  403
#define ER_H04  404
#define ER_H05  405
#define ER_H06  406
#define ER_H07  407
#define ER_H08  408
#define ER_H09  409
#define ER_H10  410
#define ER_H11  411
#define ER_H12  412
#define ER_H13  413
#define ER_H14  414
#define ER_H15  415
#define ER_H16  416
#define ER_H17  417
#define ER_H18  418
#define ER_HDUSE        430
#define ER_HXUSE        431
#define ER_HXHELP       432

#define ER_ENDOFLIST    0xFFFF

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmirp.c ===
/* asmirp.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include <fcntl.h>

#define DMYBASE         0x80

#define nextCH()   {*pText=cbText; pText = pTextCur++; cbText = 0;}
#define storeCH(c) {if (cbText>0x7f) nextCH() *pTextCur++=c; cbText++;}

char * PASCAL CODESIZE growParm( char * );

/***    irpxdir - process <irp> and <irpc> directives
 *
 *      irpxdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Format is
 *              IRPC    <dummy>, text | <text>
 *              IRP     <dummy>,<param list>
 */

VOID    PASCAL CODESIZE
irpxdir ()
{
        register short cc;      /* CHAR */
        USHORT  bracklevel;
        char    littext;
        register char    *pT;
        char    *pParmName;


        createMC (1);               /* Make IRPC param block */
        scandummy ();               /* Scan our only dummy param */

        if (NEXTC () != ','){
                error (E_EXP,"comma");
                return;
        }

        pMCur->cbParms = strlen(lbufp) << 1;
        pT = nalloc(pMCur->cbParms, "irpxdir: actuals");

        *pT = NULL;
        pMCur->rgPV[0].pActual = pMCur->pParmAct = pT;

        pParmName = pMCur->pParmNames;
        pMCur->pParmNames = pT;

        bracklevel = 0;

        if (littext = (skipblanks () == '<')) {

            SKIPC ();
            bracklevel = 1;
        }

        if (optyp == TIRP) {

            if (!littext)
                 error (E_EXP,"<");     /* Must have < */


            if (skipblanks () != '>') {

                BACKC ();
                do {
                    SKIPC ();
                    scanparam (TRUE);
                } while (skipblanks () == ',');

            }
            if (NEXTC () != '>')
                    error (E_EXP,">");
        }
        else {
            while (cc = NEXTC ()) {

                if (littext) {
                    /* Only stop on > */

                    if (cc == '<'){
                       bracklevel++;
                       continue;
                    }
                    else if (cc == '>'){

                        if (--bracklevel == 0)
                            break;

                        continue;
                    }
                }
                else if (ISBLANK (cc) || ISTERM (cc)) {

                        BACKC ();
                        break;
                }
                *pT++ = 1;  /* arg of length 1 */
                *pT++ = (char)cc; /* and the arg */

                pMCur->count++;
            }
            *pT = NULL;
        }
        if (PEEKC () == '>' && littext)
                SKIPC ();

        swaphandler = TRUE;
        handler = HIRPX;
        blocklevel = 1;
        pMCur->count--;                 /* don't count arg in repeat count */
        pMCur->pParmNames = pParmName;
        pMCur->iLocal++;
        pMCur->svlastcondon = (char)lastcondon;
        pMCur->svcondlevel = (char)condlevel;
        pMCur->svelseflag = elseflag;
}

/***    reptdir - process repeat directive
 *
 *      reptdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
reptdir ()
{
        char sign;

        createMC (1);
        pMCur->count = (USHORT)exprsmag (&sign);

        if (sign)
                errorc (E_VOR);
        if (errorcode)
                pMCur->count = 0;

        swaphandler = TRUE;
        handler = HIRPX;
        blocklevel = 1;
        pMCur->svcondlevel = (char)condlevel;
        pMCur->svlastcondon = (char)lastcondon;
        pMCur->svelseflag = elseflag;
}



/***    irpxbuild - build text for IRP/IRPC block
 *
 *      irpxbuild ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
irpxbuild ()
{
        if (checkendm ()) {
            if (pMCur->flags == TMACRO) {
                /* Delete old text */
                listfree (macroptr->symu.rsmsym.rsmtype.rsmmac.macrotext);
                macroptr->symu.rsmsym.rsmtype.rsmmac.macrotext = pMCur->pTSHead;

                pMCur->pParmAct = pMCur->pParmNames;
                deleteMC (pMCur);
            }
            else {

#ifdef BCBOPT
                    if (fNotStored)
                        storelinepb ();
#endif

                    pMCur->pTSCur = pMCur->pTSHead;

                    if (!pMCur->pTSCur)     /* empty macros go 0 times */
                        pMCur->count = 0;

                    macrolevel++;
                    handler = HPARSE;
                    /* Expand that body */
                    lineprocess (RMACRO, pMCur);
            }
            handler = HPARSE;
            swaphandler = TRUE;
        }
        else {
                irpcopy ();
                listline ();
        }
}


/***    irpcopy - copy line of text into irp/irpc/macro
 *
 *      irpcopy ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

char *pText, *pTextEnd;
UCHAR cbText;
char inpasschar = FALSE;

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif

VOID PASCAL CODESIZE
irpcopy ()
{
        register char *pTextCur;
        register UCHAR cc;
        TEXTSTR FAR   *bodyline;
        char     hold[LINEMAX];
        USHORT   siz;

        pText = pTextCur = hold;
        pTextEnd = pTextCur + LINEMAX - 2;
        pTextCur++;
        cbText = 0;
        lbufp = lbuf;

        if (!lsting)                     /* burn blanks if not listing */
            skipblanks();

        while ((cc = PEEKC ()) && pTextCur < pTextEnd) {

            ampersand = FALSE;
            if (cc == '\'' || cc == '"') {

                delim = cc;
                inpasschar = TRUE;       /* '...' being parsed */
                do {

                    if (cc == '&' || LEGAL1ST(cc)) { /* Could have &dummy or dummy& */
                        pTextCur = passatom (pTextCur);
                    }
                    else {
                        NEXTC();
                        ampersand = FALSE;
                        storeCH(cc);

                        if (pTextCur >= pTextEnd)
                            break;
                    }

                } while ((cc = PEEKC ()) && (cc != delim));

                inpasschar = FALSE;

                if (!cc)
                    break;
            }
            if (!LEGAL1ST (cc)) {
                SKIPC();

                if (cc != '&' || PEEKC() == '&')
                    storeCH(cc);

                if (cc == ';'){     /* don't translate comment */

                    if (PEEKC() != ';' && lsting) /* don't store ;; comment */

                        while (cc = NEXTC ())
                            storeCH(cc);
                    break;
                }
            }
            else
                pTextCur = passatom (pTextCur);
        }

        /* trim trailing spaces */

        while (cbText && ISBLANK (pTextCur[-1])){
            cbText--;
            pTextCur--;
        }
        /* check to see if we ended up with a blank line */

        if (cbText == 0 && pText == hold)
            return;

        storeCH(' ');       /* space and NULL terminated */
        storeCH(NULL);
        *pText = cbText;
        *pTextCur++ = NULL;

        siz =  (USHORT)(pTextCur - hold);
        bodyline = (TEXTSTR FAR *)talloc ((USHORT)(sizeof(TEXTSTR)+siz));

        bodyline->size = (char) (sizeof(TEXTSTR)+siz);
        bodyline->strnext = (TEXTSTR FAR *)NULL;
        fMemcpy (bodyline->text, hold, siz);

        if (pMCur->pTSCur)
            pMCur->pTSCur->strnext = bodyline;
        else
            pMCur->pTSHead = bodyline;

        pMCur->pTSCur = bodyline;
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif


/***    passatom - pass next atom to line
 *
 *      ptr = passatom (ptr, lim);
 *
 *      Entry   ptr = pointer to line buffer
 *              lim = limit address of buffer
 *      Exit
 *      Returns
 *      Calls
 */

char *  PASCAL CODESIZE
passatom (
        register char *pTextCur
){
        register UCHAR  *pT, *svline;
        unsigned short  number;
        UCHAR           cbName;
        UCHAR           cando = FALSE;
        UCHAR           preconcat = FALSE;  /* expanding SYM in "text&SYM" */
        UCHAR           postconcat = FALSE; /* expanding SYM in "SYM&text" */


        if (preconcat = (PEEKC () == '&'))
            SKIPC ();

        svline = lbufp;
        getatomend ();
        cbName = (UCHAR)(lbufp - svline);

        if (pTextCur + cbName > pTextEnd){
            errorc (E_LNL);
            return(pTextCur);
        }

        if (inpasschar ) {

            if (ampersand) {
                ampersand = FALSE;
                cando = !preconcat;
            }

            if (PEEKC () == '&' && cbName) {
                SKIPC ();
                postconcat = TRUE;
            }
            else if (!preconcat && !cando)
                goto noSubsitute;
        }

        for (pT = pMCur->pParmNames, number = DMYBASE;
           *pT; pT += *pT+1, number++){

          if (cbName == *pT &&
              memcmp(naim.pszName, pT+1, *pT) == 0) {

              if (cbText)
                  nextCH();

              pTextCur[-1] = (char)number;      /* store dummy parameter index */
              pText = pTextCur++;

              if (postconcat && (preconcat || cando))
                  ampersand = TRUE;

              return (pTextCur);
          }
        }

noSubsitute:

        if (preconcat){
            storeCH('&');
        }
        if (postconcat)
            BACKC ();

        if (cbName + cbText >= 0x7f)
            nextCH();

        memcpy(pTextCur, svline, cbName);

        cbText += cbName;
        pTextCur += cbName;

        return (pTextCur);
}


/***    scandummy - add next atom to dummy list
 *
 *      scandummy ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

VOID PASCAL CODESIZE
scandummy ()
{
        register MC *pMC = pMCur;
        SHORT siz, offset;

        /* Scan dummy name */

        getatom ();
        if (*naim.pszName == 0) {
            if (!ISTERM (PEEKC ()))
                errorc (E_ECL);

           return;
        }

        pMC->count++;
        siz = naim.ucCount;
        if (pMC->cbParms < siz+2){

            /* relloc the string on overflow */

            pMC->cbParms = 32;
            offset = (short)(pMC->pParmAct - pMC->pParmNames);
            if (!(pMC->pParmNames = realloc(pMC->pParmNames, (USHORT)( offset + 32))))
                memerror("scandummy");
            pMC->pParmAct = pMC->pParmNames + offset;
        }
        *pMC->pParmAct++ = (char)siz;
        memcpy(pMC->pParmAct, naim.pszName, siz+1);
        pMC->pParmAct += siz;
        pMC->cbParms -= siz+1;
}

/***    growParm - grow the size of parmeter block
 *
 *      Entry pTextCur: current text location
 *            pText: start of currect arg
 *            pTextEnd: end of string
 *      Returns relloced pMCparm names
 */

char * PASCAL CODESIZE
growParm (
        char *pTextCur
){
        register MC *pMC = pMCur;
        long delta, i;
        char *pTNew;

        /* relloc the string on overflow */

        if (!(pTNew = realloc(pMC->pParmAct, (USHORT)( pTextEnd - pMC->pParmAct + 32))))
            memerror("growparm");
        delta = (long)(pTNew - pMC->pParmAct);

        /* Adjust all the pointers */

        pMC->cbParms += 32;
        for (i = 0; i <pMC->count; i++)
            pMC->rgPV[i].pActual += delta;

        pMC->pParmAct += delta;
        pTextEnd += delta + 32;
        pTextCur += delta;
        pText += delta;

        return (pTextCur);
}


/***    scanparam - scan a parameter for IRP and MACRO calls
 *
 *      scanparm (irpp);
 *
 *      Entry   irpp = TRUE if parameters to be comma terminated
 *              irpp = FALSE if parameters to be blank or comma terminated
 *      Exit
 *      Returns none
 *      Calls
 */

VOID    PASCAL CODESIZE
scanparam (
        UCHAR irpp
){
        register char *pTextCur;
        register UCHAR cc;
        USHORT  bracklevel;

        pText = pTextCur = pMCur->pParmNames;
        pTextEnd = pTextCur + pMCur->cbParms;
        pTextCur++;

        bracklevel = 0;
        if (ISBLANK (PEEKC ()))
                skipblanks ();

        while(1) {

            if (pTextCur+1 >= pTextEnd)
                pTextCur = growParm(pTextCur);

            switch (cc = NEXTC ()) {

              case ';':
                    if (bracklevel)
                        break;

              case NULL:
                    BACKC ();
                    goto done;

              case '%': /* convert %expr to character string */

                    pTextCur = scanvalue (pTextCur);
                    break;

              case  '\'':
              case  '"':

                    *pTextCur++ = delim = cc;   /* store opening quote */

                    while(1) {
                        if (pTextCur >= pTextEnd)
                            pTextCur = growParm(pTextCur);

                        /* store next character of string */

                        if (!(cc = NEXTC())){
                            BACKC();
                            goto done;
                        }

                        *pTextCur++ = cc;

                        /* check for double quote character */

                        if (cc == delim) {
                            if (PEEKC () == delim) {
                                *pTextCur++ = cc;
                                SKIPC ();
                            }
                            else
                                break;
                        }
                    }
                    break;

               case '<':    /* Have start of < xxx > */

                    if (bracklevel)
                        *pTextCur++ = cc;

                    bracklevel++;
                    break;

               case '>':    /* Have end  of < xxx > */

                    if (bracklevel > 1)
                        *pTextCur++ = cc;

                    else{
                        if (bracklevel == 0)
                            BACKC();

                        goto done;
                    }

                    bracklevel--;
                    break;

               case '!':        /* Next char is literal */

                    *pTextCur++ = NEXTC ();
                    break;

               case ' ':
               case '\t':
               case ',':
                    if (bracklevel == 0 &&
                       (cc == ',' || !irpp)) {

                        BACKC ();
                        goto done;
                    }

               default:

                    *pTextCur++ = cc;
            }
        }
done:
    cbText = (UCHAR)(pTextCur - pText - 1);          /* set byte prefix count */
    if (cbText > 0xfe)
        errorc(E_LNL);

    *pText = cbText;
    pMCur->cbParms -= cbText + 1;

    if (!irpp)
        pMCur->rgPV[pMCur->count].pActual = pText;      /* point to arg */

    pMCur->pParmNames = pTextCur;           /* set pointer to parm pool */
    pMCur->count++;

}



/***    scanvalue - evaluate expression and and store converted value
 *
 *      p = scanvalue (p, lim);
 *
 *      Entry   p = pointer to location to store converted value
 *              lim = limit address of buffer
 *      Exit
 *      Returns pointer to next character to store into
 *      Calls   exprconst, radixconvert, error
 */

char *  PASCAL CODESIZE
scanvalue (
        char *pTextCur
){
        OFFSET value;
        register char *lastlbuf;
        SHORT errorIn;

        /* look for a text macro name thats not a constant */

        lastlbuf = lbufp;
        getatom();
        if (PEEKC() == ',' || ISTERM(PEEKC())) {

            /* try a text macro subsitution */

            if (symsrch () &&
                symptr->symkind == EQU &&
                symptr->symu.equ.equtyp == TEXTMACRO) {

                lastlbuf = symptr->symu.equ.equrec.txtmacro.equtext;

                while(*lastlbuf){

                    if (pTextCur >= pTextEnd)
                        pTextCur = growParm(pTextCur);

                    *pTextCur++ = *lastlbuf++;
                }

                return(pTextCur);
            }
        }
        lbufp = lastlbuf;

        return(radixconvert (exprconst(), pTextCur));
}

/***    radixconvert - convert expression to value in current radix
 *
 *      ptr = radixconvert (value, ptr, lim);
 *
 *      Entry   value = value to convert
 *              ptr = location to store converted string
 *              lim = limit address of buffer
 *      Exit
 *      Returns pointer to next character in store buffer
 *      Calls   error, radixconvert
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif


char *  PASCAL CODESIZE
radixconvert (
        OFFSET  valu,
        register char *p
){
        if (valu / radix) {
                p = radixconvert (valu / radix, p);
                valu = valu % radix;
        }
        else /* leading digit */
                if (valu > 9) /* do leading '0' for hex */
                        *p++ = '0';

        if (p >= pTextEnd)
            p = growParm(p);

        *p++ = (char)(valu + ((valu > 9)? 'A' - 10 : '0'));

        return (p);
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif


/***    macroexpand - expand IRP/IRPC/IRPT/MACRO
 *
 *      buffer = irpxexpand ();
 *
 *      Entry   pMC = pointer to macro call block
 *      Exit    lbuf = next line of expansion
 *      Returns pointer to expanded line
 *              NULL if end of all expansions
 *      Calls
 */

VOID PASCAL CODESIZE
macroexpand (
        register MC *pMC
){
        char FAR *lc;
        register USHORT  cc;
        register UCHAR  *lbp, *pParm;
        register USHORT cbLeft;

        if (pMC->count == 0) {      /* Have reached end of expand */
done:
            if (pMC->flags != TMACRO)
                listfree (pMC->pTSHead);

            deleteMC (pMC);         /* Delete all params */
            macrolevel--;
            popcontext = TRUE;
            exitbody = FALSE;
            return;
        }

        while(1){

            if (!pMC->pTSCur) {

                /* End of this repeat */
                /* Move back to body start */

                pMC->pTSCur = pMC->pTSHead;
                if (--pMC->count == 0)
                    goto done;

                if (pMC->flags <= TIRPC)
                    pMC->rgPV[0].pActual += *pMC->rgPV[0].pActual + 1;
            }

            lineExpand(pMC, pMC->pTSCur->text);

            pMC->pTSCur = pMC->pTSCur->strnext;

            if (exitbody) {         /* unroll nested if/else/endif */
                lastcondon = pMC->svlastcondon;
                condlevel = pMC->svcondlevel;
                elseflag = pMC->svelseflag;
                goto done;
            }
            break;
        }
}



#ifndef M8086OPT

VOID CODESIZE
lineExpand (
        MC *pMC,
        char FAR *lc            /* Macro Line */
){
        register USHORT  cc;
        register UCHAR  *lbp, *pParm;
        register USHORT cbLeft;
        UCHAR fLenError;

 #ifdef BCBOPT
        fNoCompact = FALSE;
 #endif
        lbufp = lbp = lbuf;
        cbLeft = LBUFMAX - 1;
        fLenError = FALSE;
        while( cc = *lc++) {

            if (cc & 0x80) {

                cc &= 0x7F;

                if (cc >= pMC->iLocal) {
                    pParm = pMC->rgPV[cc].localName;

                    // Error if not enough room for 6 more bytes
                    if( 6 > cbLeft ){
                        fLenError = TRUE;
                        break;
                    }
                    cbLeft -= 6;

                    *lbp++ = '?';       /* Store "??" */
                    *lbp++ = '?';

                    if (pParm[0] == NULL) {     /* must recreat the name */
                        offsetAscii ((OFFSET) (pMC->localBase +
                                      cc - pMC->iLocal));

                        *lbp++ = objectascii[0];
                        *lbp++ = objectascii[1];
                        *lbp++ = objectascii[2];
                        *lbp++ = objectascii[3];
                    }else{
                        /* Copy 4 bytes from pParm */
                        *lbp++ = pParm[0];
                        *lbp++ = pParm[1];
                        *lbp++ = pParm[2];
                        *lbp++ = pParm[3];
                    }
                }
                else {
                    pParm = pMC->rgPV[cc].pActual;
                    cc = *pParm;
                    if( cc > cbLeft ){
                        fLenError = TRUE;
                        break;
                    }
                    cbLeft -= cc;
                    memcpy(lbp, pParm+1, cc);
                    lbp += cc;
                }
            }
            else {
                if( cc > cbLeft ){      /* if line too long */
                    fLenError = TRUE;
                    break;
                }
                cbLeft -= cc;
                fMemcpy(lbp, lc, cc);
                lc += cc;
                lbp += cc;
            }
        }
        if( fLenError ){
            *lbp++ = '\0';      /* Terminate the line */
            errorc( E_LTL & E_ERRMASK );
        }
        linebp = lbp - 1;
        linelength = (unsigned char)(linebp - lbufp);
        if( fNeedList ){
            strcpy( linebuffer, lbuf );
        }

        /* At exit (linebp - lbuf) == strlen( lbuf ) */
}

#endif


/***    test4TM  -  tests if symbol is a text macro, and whether it is
 *                  preceded or followed by '&'
 *
 *      flag =  test4TM ();
 *
 *      Entry   lbufp points to beginning of symbol in lbuf
 *      Exit    lbufp is advanced by getatom
 *      Returns TRUE if symbol is text macro, else FALSE
 *      Calls   getatom, symsrch
 */

UCHAR PASCAL CODESIZE
test4TM()
{
    UCHAR ret = FALSE;

     if (!getatom ())
        return (ret);

     xcreflag--;

     if (symsrch() && (symptr->symkind == EQU)
       && (symptr->symu.equ.equtyp == TEXTMACRO)) {

         xcreflag++;        /* cref reference to text macro symbol now */
         crefnew (REF);     /* as it will be overwritten by expandTM */
         crefout ();

         /* '&' will be overwritten by equtext in lbuf */

         if (*(begatom - 1) == '&')
             begatom--;

         if (*endatom == '&')
             endatom++;

         ret = TRUE;

     } else
         xcreflag++;

    return (ret);
}



/***    substituteTMs - substitute equtext for each text macro symbol on line
 *
 *      substituteTMs ();
 *
 *      Entry   lbufp points to first non-blank character after '%' in lbuf
 *      Exit    lbufp points to beginning of lbuf
 *      Calls   test4TM, expandTM, getatom, skipblanks
 */

VOID PASCAL CODESIZE
substituteTMs()
{
    char  cc;
    char  delim;
    UCHAR inquote;

    while ((cc = PEEKC ()) && cc != ';') {

        inquote = FALSE;

        if (cc == '\'' || cc == '"') {

            delim = cc;
            cc = *(++lbufp);
            inquote = TRUE;
        }

        do {

            if (inquote && cc == '&')
                SKIPC ();

            if ((!inquote || cc == '&') && LEGAL1ST(PEEKC ())) {
                if (test4TM())
                    expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
                continue;
            }

            if (!(getatom())) {
                SKIPC ();
                skipblanks();
            }

        } while (inquote && (cc = PEEKC ()) && (cc != delim));

        if (inquote && (cc == delim))
            SKIPC ();
    }

    lbufp = lbuf;
}


#ifndef M8086OPT
/***    expandTM - expand text macro in naim in lbuf/lbufp
 *
 *      expandTM ( pReplace );
 *
 *      Entry   pReplace = replacement string
 *              naim    = text macro
 *              begatom = first character in lbuf to replace
 *              endatom = first character in lbuf after string to replace
 *              linebp  = points to null terminator in lbuf
 *      Exit    lbuf    = new line to be parsed
 *              lbufp   = first character of new atom (replace string)
 *              linebp  = points to new position of null terminator in lbuf
 *      Returns
 *      Calls
 *      Note    Shifts characters from lbufp to make substitution of TM.
 *              Inserts replacement string at begatom. This function could
 *              be tweaked considerably for speed at the expense of readability.
 */


VOID        CODESIZE
expandTM (
        register char *pReplace
){
        USHORT cbReplace;   /* Length of the replacement string */
        USHORT cbNaim;      /* Length of the atom to replace */
        USHORT cbLineEnd;   /* Length of the line past the atom being replaced */

        cbReplace = (USHORT) strlen( pReplace );
        cbNaim = (USHORT)(endatom - begatom);     /* Get length of the current atom */
        cbLineEnd = (USHORT)(linebp - endatom + 1);   /* Get length of end of line */

        if ( (begatom - lbuf) + cbReplace + cbLineEnd > LBUFMAX) {
            errorc (E_LTL & E_ERRMASK);
            *begatom = '\0';                /* Truncate line */
        }else{
            if( cbReplace != cbNaim ){
                /* Shift end of line */
                memmove( begatom + cbReplace, endatom, cbLineEnd );
            }
            memcpy ( begatom, pReplace, cbReplace );
        }
        lbufp = begatom;
        linebp = begatom + cbReplace + cbLineEnd - 1;
}

#endif /* M8086OPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmmac.c ===
/* asmmac.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"


/***	macrodefine - define a macro
 *
 *	macrodefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
macrodefine ()
{
	checkRes();
	if (!symFet ()) {

		/* Need to make it */
		symcreate (M_DEFINED | M_BACKREF, MACRO);

	}
	if (symptr->symkind != MACRO)
		errorn (E_SDK);
	else {
		crefdef ();
		/* Save ptr to macro entry */
		macroptr = symptr;
		/* Make param record */
		createMC (0);
		BACKC ();
		do {
			SKIPC ();
			scandummy ();

		} while (PEEKC () == ',');

		macroptr->symu.rsmsym.rsmtype.rsmmac.parmcnt = (unsigned char)pMCur->count;
		pMCur->count = 0;
		localflag = TRUE;   /* LOCAL is legal */

		swaphandler = TRUE;
		handler = HMACRO;
		blocklevel = 1;
	}
}


/***	macrobuild - build body of macro
 *
 *	macrobuild ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
macrobuild ()
{

#ifdef BCBOPT
	if (fNotStored)
	    storelinepb ();
#endif

	if (localflag) {	/* Still legal, check */
	    getatom ();
	    if (fndir () && optyp == TLOCAL) {

		/* Have LOCAL symlist */
		BACKC ();
		do {
			SKIPC ();
			scandummy ();

		} while (PEEKC () == ',');

		listline ();
		return;
	    }
	    lbufp = lbuf;
	    macroptr->symu.rsmsym.rsmtype.rsmmac.lclcnt = (unsigned char)pMCur->count;

	    swaphandler = TRUE;
	    handler = HIRPX;

	}
	irpxbuild ();
}


/***	macrocall - process macro call
 *
 *	macrocall ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif

VOID	PASCAL CODESIZE
macrocall ()
{
	register USHORT cc;
	SHORT cbParms;
	SYMBOL FARSYM	*macro;
	static char nullParm[1] = {0};

#ifdef BCBOPT
	if (fNotStored)
	    storelinepb ();
#endif

	macro = symptr;  /* Ptr to macro entry */
	crefnew (REF);

	/* Create param area */
	optyp = TMACRO;
	cbParms = macro->symu.rsmsym.rsmtype.rsmmac.parmcnt;
	createMC ((USHORT)(cbParms + macro->symu.rsmsym.rsmtype.rsmmac.lclcnt));

	while (--cbParms >= 0) {

		/* extract ' ' or ',' terminated parameter */
		scanparam (FALSE);
		/* check for proper termination parameter termination */
		if (((cc = PEEKC ()) != ',') && !ISBLANK (cc) && !ISTERM (cc)) {
			errorcSYN ();
			NEXTC ();
		}

		if (ISTERM (cc = skipblanks ()))
			break;

		if (cc == ',')
			SKIPC ();
	}

	pMCur->pTSCur = pMCur->pTSHead = macro->symu.rsmsym.rsmtype.rsmmac.macrotext; ;

	for (cc = pMCur->count;
	     cc < macro->symu.rsmsym.rsmtype.rsmmac.parmcnt; cc++)

	    pMCur->rgPV[cc].pActual = nullParm;

	pMCur->count = 1;
	pMCur->localBase = localbase;
	pMCur->iLocal = macro->symu.rsmsym.rsmtype.rsmmac.parmcnt;
	localbase += macro->symu.rsmsym.rsmtype.rsmmac.lclcnt;
	listline ();
	/* Start of macro text */
	macrolevel++;
	macro->symu.rsmsym.rsmtype.rsmmac.active++;
	pMCur->svcondlevel = (char)condlevel;
	pMCur->svlastcondon = (char)lastcondon;
	pMCur->svelseflag = elseflag;

	lineprocess (RMACRO, pMCur);

	if (!(--macro->symu.rsmsym.rsmtype.rsmmac.active))
		if (macro->symu.rsmsym.rsmtype.rsmmac.delete)
			deletemacro (macro);
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif


/***	checkendm - check for ENDM on current line
 *
 *	checkendm ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


UCHAR PASCAL CODESIZE
checkendm ()
{
	char flag;

	getatomend ();
	if (PEEKC () == '&') { /* skip constructed name */
		while (PEEKC () == '&') {
			SKIPC ();
			getatomend ();
		}
		*naim.pszName = '\0';
	}
	if (PEEKC () == ':' || (naim.pszName[0] == '%' && naim.pszName[1] == 0)) {
		SKIPC ();
		/* Skip over label */
		getatomend ();
	}
	if (flag = (char)fndir ()) {
	}
	else if (ISBLANK (PEEKC ())) {
		/* Check for naim MACRO */
		getatomend ();
		flag = (char)fndir2 ();
	}
	if (flag) {
		if (opkind & BLKBEG)
		    blocklevel++;
		else if (optyp == TENDM)
		    blocklevel--;

		if (!blocklevel) {
		    listline ();
		    return (TRUE);
		}
	}
	return (FALSE);
}


/***	createMC - create parameter descriptor
 */

VOID PASCAL CODESIZE
createMC (
	USHORT cParms
){
	register MC *pMC;
	SHORT cb;

	/* Create it */
	cb = sizeof(MC) - sizeof(PV) + sizeof(PV) * cParms;

	pMCur = pMC = (MC *) nalloc (cb, "creatMC");

	memset(pMC, 0, cb);
	pMC->flags = optyp;
	pMC->cbParms = (USHORT)(linebp - lbufp + 10);

	pMC->pParmNames = nalloc(pMC->cbParms, "macrodefine");

	pMC->pParmAct = pMC->pParmNames;
	*pMC->pParmAct = NULL;

}



/***	deleteMC - delete dummy and parameter lists
 *
 *
 *	Entry	pMC = parameter descriptor
 *	Exit	descriptor, dummy parameters and local parameters released
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
deleteMC (
	register MC *pMC
){
    if (pMC->flags <= TIRPC)
	free(pMC->pParmNames);

    free(pMC->pParmAct);
    free((char *) pMC);

}


VOID PASCAL CODESIZE
listfree (
	TEXTSTR FAR *ptr
){
	TEXTSTR FAR *ptrnxt;

	while (ptr) {
		ptrnxt = ptr->strnext;
		tfree ((char FAR *)ptr, (USHORT)ptr->size);
		ptr = ptrnxt;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmmsg.asm ===
;This was originally created from asmmsg.txt by mkmsg
;Only used by the OS2 1.2 version of MASM 5.NT

HDR segment byte public 'MSG'
HDR ends
MSG segment byte public 'MSG'
MSG ends
PAD segment byte public 'MSG'
PAD ends
EPAD segment byte common 'MSG'
EPAD ends
DGROUP group HDR,MSG,PAD,EPAD

MSG segment
	dw	258
	db	"Internal error",10,0
	dw	261
	db	"%s(%hd): %s A%c%03hd: %s%s",0
	dw	263
	db	"Internal unknown error",10,0
	dw	265
	db	"End of file encountered on input file",10,0
	dw	266
	db	"Open segments",0
	dw	267
	db	"Open procedures",0
	dw	268
	db	"Number of open conditionals:",0
	dw	269
	db	"%s",10,"Copyright (C) Microsoft Corp 1981, 1989.  All rights reserved.",10,10,0
	dw	270
	db	"Unable to open cref file: %s",10,0
	dw	271
	db	"Write error on object file",10,0
	dw	272
	db	"Write error on listing file",10,0
	dw	273
	db	"Write error on cross-reference file",10,0
	dw	274
	db	"Unable to open input file: %s",10,0
	dw	275
	db	"Unable to access input file: %s",10,0
	dw	276
	db	"Unable to open listing file: %s",10,0
	dw	277
	db	"Unable to open object file: %s",10,0
	dw	278
	db	" Warning Errors",0
	dw	279
	db	" Severe  Errors",0
	dw	280
	db	10,"%7ld Source  Lines",10,"%7ld Total   Lines",10,0
	dw	281
	db	"%7hd Symbols",10,0
	dw	282
	db	"Bytes symbol space free",10,0
	dw	283
	db	"%s(%hd): Out of memory",10,0
	dw	284
	db	"Extra file name ignored",10,0
	dw	285
	db	"Line invalid, start again",10,0
	dw	287
	db	"Path expected after I option",10,0
	dw	288
	db	"Unknown case option: %c. Use /help for list",10,0
	dw	289
	db	"Unknown option: %c. Use /help for list of options",10,0
	dw	290
	db	"Read error on standard input",10,0
	dw	291
	db	"Out of memory",10,0
	dw	292
	db	"Expected source file",10,0
	dw	293
	db	"Warning level (0-2) expected after W option",10,0
MSG ends

FAR_HDR segment byte public 'FAR_MSG'
FAR_HDR ends
FAR_MSG segment byte public 'FAR_MSG'
FAR_MSG ends
FAR_PAD segment byte public 'FAR_MSG'
FAR_PAD ends
FAR_EPAD segment byte common 'FAR_MSG'
FAR_EPAD ends
FMGROUP group FAR_HDR,FAR_MSG,FAR_PAD,FAR_EPAD

FAR_MSG segment
	dw	257
	db	"Block nesting error",0
	dw	258
	db	"Extra characters on line",0
	dw	259
	db	"Internal error - Register already defined",0
	dw	260
	db	"Unknown type specifier",0
	dw	261
	db	"Redefinition of symbol",0
	dw	262
	db	"Symbol is multidefined",0
	dw	263
	db	"Phase error between passes",0
	dw	264
	db	"Already had ELSE clause",0
	dw	265
	db	"Must be in conditional block",0
	dw	266
	db	"Symbol not defined",0
	dw	267
	db	"Syntax error",0
	dw	268
	db	"Type illegal in context",0
	dw	269
	db	"Group name must be unique",0
	dw	270
	db	"Must be declared during Pass 1",0
	dw	271
	db	"Illegal public declaration",0
	dw	272
	db	"Symbol already different kind",0
	dw	273
	db	"Reserved word used as symbol",0
	dw	274
	db	"Forward reference illegal",0
	dw	275
	db	"Operand must be register",0
	dw	276
	db	"Wrong type of register",0
	dw	277
	db	"Operand must be segment or group",0
	dw	279
	db	"Operand must be type specifier",0
	dw	280
	db	"Symbol already defined locally",0
	dw	281
	db	"Segment parameters are changed",0
	dw	282
	db	"Improper align/combine type",0
	dw	283
	db	"Reference to multidefined symbol",0
	dw	284
	db	"Operand expected",0
	dw	285
	db	"Operator expected",0
	dw	286
	db	"Division by 0 or overflow",0
	dw	287
	db	"Negative shift count",0
	dw	288
	db	"Operand types must match",0
	dw	289
	db	"Illegal use of external",0
	dw	291
	db	"Operand must be record or field name",0
	dw	292
	db	"Operand must have size",0
	dw	293
	db	"Extra NOP inserted",0
	dw	295
	db	"Left operand must have segment",0
	dw	296
	db	"One operand must be constant",0
	dw	297
	db	"Operands must be in same segment, or one constant",0
	dw	299
	db	"Constant expected",0
	dw	300
	db	"Operand must have segment",0
	dw	301
	db	"Must be associated with data",0
	dw	302
	db	"Must be associated with code",0
	dw	303
	db	"Multiple base registers",0
	dw	304
	db	"Multiple index registers",0
	dw	305
	db	"Must be index or base register",0
	dw	306
	db	"Illegal use of register",0
	dw	307
	db	"Value out of range",0
	dw	308
	db	"Operand not in current CS ASSUME segment",0
	dw	309
	db	"Improper operand type",0
	dw	310
	db	"Jump out of range by %ld byte(s)",0
	dw	312
	db	"Illegal register value",0
	dw	313
	db	"Immediate mode illegal",0
	dw	314
	db	"Illegal size for operand",0
	dw	315
	db	"Byte register illegal",0
	dw	316
	db	"Illegal use of CS register",0
	dw	317
	db	"Must be accumulator register",0
	dw	318
	db	"Improper use of segment register",0
	dw	319
	db	"Missing or unreachable CS",0
	dw	320
	db	"Operand combination illegal",0
	dw	321
	db	"Near JMP/CALL to different CS",0
	dw	322
	db	"Label cannot have segment override",0
	dw	323
	db	"Must have instruction after prefix",0
	dw	324
	db	"Cannot override ES for destination",0
	dw	325
	db	"Cannot address with segment register",0
	dw	326
	db	"Must be in segment block",0
	dw	327
	db	"Illegal combination with segment alignment",0
	dw	328
	db	"Forward needs override or FAR",0
	dw	329
	db	"Illegal value for DUP count",0
	dw	330
	db	"Symbol is already external",0
	dw	331
	db	"DUP nesting too deep",0
	dw	332
	db	"Illegal use of undefined operand (?)",0
	dw	333
	db	"Too many values for struc or record initialization",0
	dw	334
	db	"Angle brackets required around initialized list",0
	dw	335
	db	"Directive illegal in structure",0
	dw	336
	db	"Override with DUP illegal",0
	dw	337
	db	"Field cannot be overridden",0
	dw	340
	db	"Circular chain of EQU aliases",0
	dw	341
	db	"Cannot emulate coprocessor opcode",0
	dw	342
	db	"End of file, no END directive",0
	dw	343
	db	"Data emitted with no segment",0
	dw	344
	db	"Forced error - pass1",0
	dw	345
	db	"Forced error - pass2",0
	dw	346
	db	"Forced error",0
	dw	347
	db	"Forced error - expression equals 0",0
	dw	348
	db	"Forced error - expression not equal 0",0
	dw	349
	db	"Forced error - symbol not defined",0
	dw	350
	db	"Forced error - symbol defined",0
	dw	351
	db	"Forced error - string blank",0
	dw	352
	db	"Forced error - string not blank",0
	dw	353
	db	"Forced error - strings identical",0
	dw	354
	db	"Forced error - strings different",0
	dw	355
	db	"Wrong length for override value ",0
	dw	356
	db	"Line too long expanding symbol",0
	dw	357
	db	"Impure memory reference",0
	dw	358
	db	"Missing data; zero assumed",0
	dw	359
	db	"Segment near (or at) 64K limit",0
	dw	360
	db	"Cannot change processor in segment",0
	dw	361
	db	"Operand size does not match segment word size",0
	dw	362
	db	"Address size does not match segment word size",0
	dw	363
	db	"Jump within short distance",0
	dw	364
	db	"Align must be power of 2",0
	dw	365
	db	"Expected",0
	dw	366
	db	"Line too long",0
	dw	367
	db	"Non-digit in number",0
	dw	368
	db	"Empty string",0
	dw	369
	db	"Missing operand",0
	dw	370
	db	"Open parenthesis or bracket",0
	dw	371
	db	"Not in macro expansion",0
	dw	372
	db	"Unexpected end of line",0
	dw	373
	db	"Include file not found",0
	dw	401
	db	"a",9,9,"Alphabetize segments",0
	dw	402
	db	"c",9,9,"Generate cross-reference",0
	dw	403
	db	"d",9,9,"Generate pass 1 listing",0
	dw	404
	db	"D<sym>[=<val>] Define symbol",0
	dw	405
	db	"e",9,9,"Emulate floating point instructions and IEEE format",0
	dw	406
	db	"I<path>",9,"Search directory for include files",0
	dw	407
	db	"l[a]",9,9,"Generate listing, a-list all",0
	dw	408
	db	"M{lxu}",9,9,"Preserve case of labels: l-All, x-Globals, u-Uppercase Globals",0
	dw	409
	db	"n",9,9,"Suppress symbol tables in listing",0
	dw	410
	db	"p",9,9,"Check for pure code",0
	dw	411
	db	"s",9,9,"Order segments sequentially",0
	dw	412
	db	"t",9,9,"Suppress messages for successful assembly",0
	dw	413
	db	"v",9,9,"Display extra source statistics",0
	dw	414
	db	"w{012}",9,9,"Set warning level: 0-None, 1-Serious, 2-Advisory",0
	dw	415
	db	"X",9,9,"List false conditionals",0
	dw	416
	db	"z",9,9,"Display source line for each error message",0
	dw	417
	db	"Zi",9,9,"Generate symbolic information for CodeView",0
	dw	418
	db	"Zd",9,9,"Generate line-number information",0
	dw	430
	db	"Usage: masm /options source(.asm),[out(.obj)],[list(.lst)],[cref(.crf)][;]",0
	dw	431
	db	"Usage: masm -Switches sourceFile -o objFile",0
	dw	432
	db	"Run with -help for usage",0
FAR_MSG ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmopc.c ===
/* asmopc.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmopcod.h"

static SHORT CODESIZE nolong(struct psop *);
VOID CODESIZE pmovx(struct parsrec *);
VOID CODESIZE psetcc(struct parsrec *);
VOID CODESIZE pbit(struct parsrec *);
VOID CODESIZE pbitscan(struct parsrec *);
CODESIZE checkwreg(struct psop *);
VOID PASCAL CODESIZE pclts (void);

#define M_ESCAPE  (M_PRELJMP | M_PCALL | M_PJUMP | M_PRETURN | M_PINT | M_PARITH | \
		   M_PINOUT | M_PLOAD | M_PSTR | M_PESC | M_PBOUND | M_PARSL)

#define M_ERRIMMED (M_PSHIFT | M_PARITH | M_PINCDEC | M_PCALL | M_PJUMP |    \
		    M_PMOV | M_PSTR | M_PRELJMP | M_PGENARG | M_PXCHG |      \
		    M_PBOUND | M_PCLTS | M_PDESCRTBL | M_PDTTRSW | M_PARSL | \
		    M_PARPL | M_PVER)


/* EMITcall decides what type of calljump is present and outputs
      the appropriate code. Coding of last 4 args to EMITcall:

        DIRto:	Direct to different segment(inter)
        DIRin:	DIRect in same segment(intra)
        INDto:	Indirect to different segment(inter)
        INDin:	Indirect in same segment(intra)

*/



/***	emitcall - emit call
 *
 *	emitcall (dirin, dirto, indin, indto, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
emitcall (
         UCHAR       dirin,
         UCHAR       dirto,
         UCHAR       indin,
         UCHAR       indto,
         struct parsrec  *p
         )
{
    register struct psop *pso;  /* parse stack operand structure */
    char fNop = FALSE;

    pso = &(p->dsc1->dsckind.opnd);
    if (!isdirect(pso)) {

        /* Have indexing? */
        if (pso->dsize == 0) {
            /* make [BX] be word */
            pso->dsize = wordsize;
            pso->dtype |= xltsymtoresult[DVAR];
        } else if (pso->dsize >= CSFAR) {
            errorc (E_ASD);
            pso->dsize = wordsize;
            /* Data only, force word */
        }
    }

    if ((M_DATA & pso->dtype) && pso->dflag == UNDEFINED)
        pso->dflag = KNOWN;

    if (pso->dsize == CSNEAR ||
        (pso->dflag == UNDEFINED && !(M_PTRSIZE & pso->dtype))) {

#ifndef FEATURE
        if (regsegment[CSSEG] == pFlatGroup)
            pso->dcontext = pFlatGroup;
#endif
        if (regsegment[CSSEG] != pso->dcontext &&
            pso->dflag != XTERNAL)
            errorc (E_JCD);  /* Can't go near to dif assume */

        pso->dsize = wordsize;
        pso->dtype |= M_SHRT;
        emitopcode (dirin);
    } else if (pso->dsize == CSFAR) {

        if (M_FORTYPE & pso->dtype) /* Forward far */
            errorc (E_FOF); /* Couldn't guess */

        pso->fixtype = FPOINTER;
        pso->dsize = wordsize;

        if (pso->dsegment) {

            /* target has different segment size */

            pso->dsize = pso->dsegment->symu.segmnt.use32;

            if (pso->dsize != wordsize) {

                if (!(M_BACKREF & pso->dsegment->attr))
                    errorc (E_FOF); /* Forward mixed type */

                emitsize(0x66);

                if (wordsize == 4) {    /* set modes so you get the */
                    pso->mode = 0;      /* correct OFFSET size */
                    pso->rm = 6;
                    fNop++;         /* 16:32 -> 0x66 16:16 */
                } else {
                    pso->fixtype = F32POINTER;
                    pso->mode = 8;
                    pso->rm = 5;
                }
            }
        }
        pso->dsize += 2;
        emitopcode (dirto);

    } else {

#ifdef V386
        emit67(pso, NULL);
#endif

        if ((pso->dsize == wordsize) || (pso->dsize == wordsize+2)) {

            /* Indirect */
#ifdef V386
            /* if mode is through register, then it must be a near
             * call, so we can tell if its a foreign mode call */

            if (pso->dsize != wordsize && pso->mode == 3)
                emitsize(0x66);
#endif
            emitescape (p->dsc1, p->defseg);
            emitopcode (255);        /*  must use defseg([BP]) */

            if (pso->dsize == wordsize || pso->mode == 3)
                /* Near indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indin>>3), pso->rm);
            else
                /* Far indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indto>>3), pso->rm);
        }

#ifdef V386
        else if (pso->dsize == 2 || pso->dsize == 6) {

            /* indirect foreign mode call */
            /* in 16 bit mode normal near and far get done by the
             * above, and only 32 bit mode far gets here.  for 32
             * bit normal only 16 bit near.  the latter seems a bit
             * useless....*/

            emitsize(0x66);
            emitescape (p->dsc1, p->defseg);
            emitopcode (255);       /*  must use defseg([BP]) */

            if (pso->dsize == 2)
                /* Near indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indin>>3), pso->rm);
            else
                /* Far indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indto>>3), pso->rm);
        }
#endif
        else
            /* Bad size */
            errorc (E_IIS);
    }

    emitrest (p->dsc1);

    if (fNop)
        emitnop();
}




/***	movesegreg - emit move to/from segment register
 *
 *	movesegreg (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
movesegreg (
           char    first,
           struct parsrec  *p
           )
{
    register struct psop *pso1;  /* parse stack operand structure */
    register struct psop *pso2;  /* parse stack operand structure */
    DSCREC         *t;

    if (!first) {
        if (p->dsc1->dsckind.opnd.mode != 3 && impure)
            /* MOV cs:mem,segreg */
            errorc (E_IMP);
        t = p->dsc1;
        p->dsc1 = p->dsc2;
        p->dsc2 = t;
    }
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if ((pso2->dsize | wordsize) == 6)
        emitsize(0x66);

    emitopcode ((UCHAR)(first? 142: 140));
    errorimmed (p->dsc2);

#ifdef V386
    rangecheck (&pso1->rm, (UCHAR)((cputype&P386)?5:3));
#else
    rangecheck (&pso1->rm, (UCHAR)3);
#endif
    if ((pso2->mode == 3)
        && (pso2->dsegment->symu.regsym.regtype == SEGREG))
        errorc (E_WRT);    /* MOV segreg,segreg not allowed */

    if (pso2->sized && !pso2->w)
        errorc (E_IIS);

    if (first && (pso1->rm == CSSEG))
        /* CS illegal */
        errorc (E_CSI);


    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}

#ifdef V386

/***	movecreg - emit move to/from control/debug/test register
 *
 *	movecreg (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID
PASCAL
CODESIZE
movecreg (
         char    first,
         struct parsrec  *p
         )
{
    register struct psop *pso1;  /* parse stack operand structure */
    register struct psop *pso2;  /* parse stack operand structure */
    UCHAR opbase;

    if ((cputype&(P386|PROT)) != (P386|PROT)) {
        errorc(E_WRT);
        return;
    }
    emitopcode (0x0F);

    pso1 = &(p->dsc1->dsckind.opnd);
    opbase = 0x22;

    if (first)

        pso2 = &(p->dsc2->dsckind.opnd);
    else {
        opbase = 0x20;
        pso2 = pso1;
        pso1 = &(p->dsc2->dsckind.opnd);
    }

    if ((pso2->dsegment->symkind != REGISTER)
        || (pso2->dsegment->symu.regsym.regtype != DWRDREG))
        errorc (E_OCI);

    if ((pso1->rm&030) == 020) /* test register */
        opbase += 2;

    emitopcode((UCHAR)(opbase + (pso1->rm >> 3)));
    emitmodrm((USHORT)3, (USHORT)(pso1->rm & 7), (USHORT)(pso2->rm & 7));

    if (pso2->mode != 3)     /* only allowed to from register */
        errorc(E_MBR);
}

#endif


/***	emitmove - emit code for MOV reg and MOV accum
 *
 *	emitmove (opcode, first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
emitmove (
         UCHAR       opc,
         char    first,
         struct parsrec  *p
         )
{
    DSCREC         *t;
    char    accummove;
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */


    accummove = (opc == 160);
    if (!first) {
        t = p->dsc1;
        p->dsc1 = p->dsc2;
        p->dsc2 = t;
    }
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    emit66 (pso1, pso2);

    if ((pso1->dsize != pso2->dsize) && pso2->sized)
        errorc (E_OMM);

    emitopcode ((UCHAR)(opc + ((accummove != first)? 2: 0) + pso1->w));
    errorimmed (p->dsc2);
    if (!accummove)
        emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}




/***	moveaccum - move to/from accumulator and direct address
 *
 *	moveaccum (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
moveaccum (
          char    first,
          struct parsrec  *p
          )
{
    if (!first && p->dsc1->dsckind.opnd.mode != 3 && impure)
        errorc (E_IMP);
    emitmove (160, first, p);
}




/***	movereg - emit general move between register and memory
 *
 *	movereg (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
movereg (
        char    first,
        struct parsrec  *p
        )
{
    register struct psop *pso2; /* parse stack operand structure */
    char    flag;

    flag = FALSE;
    pso2 = &(p->dsc2->dsckind.opnd);
    /* Is not special */
    if (pso2->mode == 3)
        /* 2nd is reg */
        switch (pso2->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* Catch 2nd is SEGREG */
                movesegreg (FALSE, p);
                return;
#ifdef V386
            case CREG:
                /* Catch 2nd is SEGREG */
                movecreg (FALSE, p);
                return;
#endif
        }
    if (p->dsc1->dsckind.opnd.mode != 3 && impure)
        errorc (E_IMP);
    emitmove (136, first, p);
}




/***	segdefault - return default segment for operand
 *
 *	seg = segdefault (op);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


USHORT
PASCAL
CODESIZE
segdefault (
           register char goo
           )
{
    register USHORT  defseg;
    register char op;

    defseg = NOSEG;
    if (1 << goo & xoptoseg[opctype])
        defseg = DSSEG;

    if (opctype == PSTR) {
        op = (opcbase == O_CMPS || opcbase == O_LODS || opcbase == O_OUTS);
        defseg = ((goo == FIRSTDS) != op)?  ESSEG: DSSEG;
    }
    return (defseg);
}



/***	errorover -
 *
 *	errorover (seg);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
errorover (
          char    seg
          )
{
    if (seg != ESSEG && seg != NOSEG)
        errorc (E_OES);
}

/***	checksize - check for memory s byte and immed is word
 *
 *	checksize (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


SHORT
PASCAL
CODESIZE
checksize (
          struct parsrec  *p
          )
{
    OFFSET  off;
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if (pso1->sized) {

        /* Only set dsc2->w if dsc2 has no size. Set
         * dsc1->w to dsc2->w, not TRUE(WORD). [BX],WRD PTR 5 */

        if (!pso2->sized)
            pso2->w = pso1->w;
    } else
        pso1->w = pso2->w;

    if (pso2->fixtype == FCONSTANT) {  /* check for constant overflow */

        off = (pso2->doffset > 0x7fffffff)? -(long)pso2->doffset: pso2->doffset;

        if ((pso1->dsize == 1 && off > 0xff && off < 0xff00) ||
            (pso1->dsize == 2 && off > 0xffff))
            errorc (E_VOR);
    }
    /* check fixup'ed constants with implied sizes */

    if ((pso1->sized && pso1->dsize != 2) &&
        (pso2->dtype & (M_SEGMENT) ||
         pso2->fixtype == FGROUPSEG || pso2->fixtype == FBASESEG))

        errorc (E_OMM);

    if (!(pso1->sized || pso2->sized))
        errorc (E_OHS);

    /*  Also need to set <w> field if operand 1 sized */
    if (pso1->sized) {/* Force size */
        pso2->dsize = pso1->dsize;
        pso2->w = pso1->w;
    }
    if (pso2->dsize == 1 && pso2->dflag == XTERNAL
        && pso2->fixtype != FHIGH)
        /*    makes sure linker puts out correct stuff */
        pso2->fixtype = FLOW;

    return(0);
}




/***	opcode - process opcode and emit code
 *
 *	opcode ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


SHORT
PASCAL
CODESIZE
opcode ()
{
    struct parsrec  a;
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    long        opctypemask;    /* 1L << opctype */
    char        leaflag;

    a.dsc1 = a.dsc2 = NULL;
    pso1 = pso2 = NULL;
    impure = FALSE;

    if (xoptoargs[opctype] != NONE) {
        /* Evaulate 1st arg */
        a.dirscan = lbufp;
        /* In case JMP should be SHORT */
        a.defseg = (unsigned char)segdefault (FIRSTDS);
        a.dsc1 = expreval (&a.defseg);

        if (noexp && (xoptoargs[opctype] == ONE
                      || xoptoargs[opctype] == TWO))
            errorc(E_MDZ);

        if ((pso1 = &(a.dsc1->dsckind.opnd))
            && pso1->dtype & M_STRUCTEMPLATE)
            errorc(E_IOT);

        /*  Give error so sizes >wordsize and not CODE don't get thru */
        if (!((opctypemask = 1L << opctype) & (M_PLOAD | M_PCALL | M_PJUMP | M_PDESCRTBL))
            && ((pso1->dsize > wordszdefault) &&
                (pso1->dsize < CSFAR)))
            if (pso1->mode != 4) {
                errorc (E_IIS);
                /* No error if cst */
                /* Don't allow CSFAR or CSNEAR if not CODE opcode */
                pso1->dsize = wordszdefault;
            }

        if (!(opctypemask & (M_PRELJMP | M_PCALL | M_PJUMP)))
            if (pso1->dsize >= CSFAR)
                errorc (E_IIS);

        if (!(opctypemask & M_ESCAPE))
            emitescape (a.dsc1, a.defseg);

        if (opctypemask & M_ERRIMMED)
            /* 1st operand not immediate */
            errorimmed (a.dsc1);

        if (!(opctypemask & (M_PMOV | M_PSTACK)))
            /* Give error if segment reg used */
            errorsegreg (a.dsc1);

        if (opctypemask & (M_PRETURN | M_PINT | M_PESC | M_PENTER))
            forceimmed (a.dsc1);

        if ((xoptoargs[opctype] == TWO) || ((opctype == PSTR) &&
                                            ((opcbase == O_MOVS) || (opcbase == O_CMPS) ||
                                             (opcbase == O_INS) || (opcbase == O_OUTS)))) {

            /* Two args or 2 arg string oper */

            if (NEXTC () != ',')
                error (E_EXP,"comma");

            leaflag = (opcbase == O_LEA)? TRUE: FALSE;
            a.defseg = (unsigned char)segdefault (SECONDDS);
            a.dsc2 = expreval (&a.defseg);

            if (noexp)
                errorc(E_MDZ);

            if ((pso2 = &(a.dsc2->dsckind.opnd))
                && pso2->dtype & M_STRUCTEMPLATE)
                errorc(E_IOT);

            /* IF LEA(215), then never segment prefix */
            if ((opcbase != O_LEA) && (opctype != PSTR))
                emitescape (a.dsc2, a.defseg);

            if (opctypemask & (M_PLOAD | M_PXCHG | M_PESC |
                               M_PSTR | M_PBOUND | M_PARSL | M_PARPL))
                errorimmed (a.dsc2);

            if (opctype != PMOV)
                /* Give error if SEGREG and not a MOV opcode */
                errorsegreg (a.dsc2);

            if (!(opctypemask & (M_PLOAD | M_PBOUND)) &&
                (pso2->dsize > 2 &&
#ifdef V386
                 ( !(cputype & P386) || pso2->dsize != 4) &&
#endif
                 pso2->dsize < CSFAR))

                /* Give error so sizes > 2 and not CODE don't
                 * get thru */

                if (pso2->mode != 4)
                    errorc (E_IIS);

            if (pso2->dsize >= CSFAR && !leaflag)
                /*    Don't allow CSFAR or CSNEAR if not
                      code opcode. But allow LEA since
                      it is untyped anyway. */
                errorc (E_IIS);
        }
    }

#ifdef V386
    /* for most instructions, the 386 0x66 prefix is appropriate.
     * for some classes, we either never allow it, or do some
     * special handling specific to the instruction. */

    if (cputype & P386) {
        switch (opctype) {

            default:

                emit67(pso1, pso2);
                emit66(pso1, pso2);
                break;

            case PMOV:
            case PMOVX:
            case PLOAD:
            case PSHIFT:
            case PSTACK:
            case PSTR:
            case PARPL:
            case PDTTRSW:
            case PDESCRTBL:
                emit67(pso1, pso2);
                break;

            case PCALL:
            case PJUMP:
            case PRELJMP:
            case PENTER:
            case PNOARGS:
            case PESC:
            case PRETURN:
            case PINT:
            case PINOUT:
            case PARITH:
                break;
        }
    }
#endif
    switch (opctype) {
        case PNOARGS:
            pnoargs ();
            break;
        case PJUMP:
        case PRELJMP:
            preljmp (&a);
            break;
        case PSHIFT:
            pshift (&a);
            break;
        case PSTACK:
            pstack (&a);
            break;
        case PARITH:
            parith (&a);
            break;
        case PBOUND:
            pbound (&a);
            break;
        case PENTER:
            penter (&a);
            break;
        case PCLTS:
            pclts ();
            break;
        case PDESCRTBL:
            pdescrtbl (&a);
            break;
        case PDTTRSW:
            pdttrsw (&a);
            break;
        case PVER:
            pver (&a);
            break;
        case PARSL:
            parsl (&a);
            break;
        case PARPL:
            parpl (&a);
            break;
        case PRETURN:
            preturn (&a);
            break;
        case PINCDEC:
            pincdec (&a);
            break;
        case PINT:
            pint (&a);
            break;
        case PINOUT:
            pinout (&a);
            break;
        case PLOAD:
            pload (&a);
            break;
        case PCALL:
            emitcall (232, 154, 16, 24, &a);
            break;
        case PMOV:
            pmov (&a);
            break;
        case PGENARG:
            pgenarg (&a);
            break;
        case PXCHG:
            pxchg (&a);
            break;
        case PESC:
            pesc (&a);
            break;
        case PREPEAT:
            prepeat (&a);
            break;
        case PSTR:
            pstr (&a);
            break;
        case PXLAT:
            pxlat (&a);
            break;
#ifdef V386
        case PMOVX:
            pmovx (&a);
            break;
        case PSETCC:
            psetcc (&a);
            break;
        case PBIT:
            pbit (&a);
            break;
        case PBITSCAN:
            pbitscan (&a);
            break;
#endif
    }
    if (a.dsc1)
        dfree ((char *)a.dsc1 );
    if (a.dsc2)
        dfree ((char *)a.dsc2 );

    if (pcsegment) {

        pcsegment->symu.segmnt.hascode = 1;
    }
    return (0);
}




/***	pnoargs - no arguments
 *
 *	pnoargs ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


#ifdef V386

UCHAR stackOps[] = {O_PUSHA, O_PUSHAD,
    O_POPA,  O_POPAD,
    O_PUSHF, O_PUSHFD,
    O_POPF,  O_POPFD,
    O_IRET,  O_IRETD,
    NULL
};

#endif

VOID
PASCAL
CODESIZE
pnoargs ()
{
    /* some no argument instructions have an implied arg which determines
     * whether to do the 386 66 prefix.  that this is the case is encoded
     * in the modrm in the op code table.  -Hans  */

#ifdef V386
    if (modrm != 0 && modrm <= 4 && modrm != wordsize) {

        emitsize(0x66);

        if (strchr(stackOps, (UCHAR) opcbase))
            errorc (E_ONW);
    }
#endif
    emitopcode (opcbase);
    if (opcbase == O_AAM || opcbase == O_AAD)
        /* emit modrm byte for AAD/AAM* */
        emitopcode (modrm);
}


/***	preljmp - Relative jump -128..+127
 *
 *	preljmp (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
preljmp (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */
    register SHORT cPadNop;
    SHORT rangeisshort;

#ifdef V386
    SHORT maybelong;
#else
    #define maybelong 0
#endif

    pso1 = &(p->dsc1->dsckind.opnd);

#ifdef V386
    maybelong = (cputype & P386) && !nolong(pso1) && pso1->dsize != CSFAR;
#endif
    rangeisshort = shortrange(p);
    cPadNop = 0;

    if (opcbase == O_JMP) {

        if (pso1->dtype & M_SHRT ||
            rangeisshort && pso1->dflag != XTERNAL) {

            opcbase += 2;
            if (rangeisshort == 2 &&
                !(pso1->dtype & M_SHRT)) {

                cPadNop = wordsize;
                errorc(E_JSH);

                if (M_PTRSIZE & pso1->dtype && pso1->dsize == CSFAR)
                    cPadNop += 2;
            }
        } else {   /* Is normal jump */
            emitcall (opcbase, 234, 32, 40, p);
            return;
        }
    }

    if (!(M_CODE & pso1->dtype))
        errorc (E_ASC);

    /* an extrn may have no segment with it but still be near */

    if (pso1->dsegment != pcsegment && !(maybelong && !pso1->dsegment))
        errorc (E_NIP);

    if (pso1->dtype & (M_HIGH | M_LOW))
        errorc (E_IOT);

    if (M_SHRT & pso1->dtype) {
        if (pass2 && !rangeisshort)
            errorc (E_JOR);
    } else if (!rangeisshort && !maybelong)
        error (E_JOR, (char *)NULL);    /* common pass1 error */

#ifdef V386
    if (maybelong && !(M_SHRT & pso1->dtype) &&
        (!rangeisshort || pso1->dflag == XTERNAL)) {

        /* 386 long conditional branches */
        emitopcode(0x0f);
        emitopcode((UCHAR)(0x80 | (opcbase&0xf)));

        pso1->dtype |= M_SHRT;
        emitrest(p->dsc1);
        return;
    }
#endif
    emitopcode (opcbase);

    if (pso1->dflag == XTERNAL) {       /* EXTERNAL jump */
        pso1->dsize = 1;
        pso1->fixtype = FLOW;       /* SHORT to EXTERNAL */
        pso1->dtype |= M_SHRT;     /* One byte result */

        emitOP (pso1);
    } else
        emitopcode ((UCHAR)pso1->doffset);

    while (--cPadNop > 0)
        emitnop();
}

#ifdef V386

/* most 386 conditional jumps can take a long or short form.  these can
 * only take a short form */

static
SHORT
CODESIZE
nolong(
      register struct psop *pso1
      )
{
    switch (opcbase) {
        case O_JCXZ:
        case O_LOOP:
        case O_LOOPZ:
        case O_LOOPNZ:
    #ifdef V386

            pso1->dtype |=  M_SHRT;
            pso1->dtype &=  ~M_PTRSIZE;

            /* allow `loop word ptr label' for cx|ecx overide */

            if (modrm && modrm != wordsize ||
                pso1->sized && pso1->dsize != wordsize &&
                (pso1->dsize == 4 || pso1->dsize == 2)) {

                pso1->dtype = (USHORT)((pso1->dtype & ~M_DATA) | M_CODE);
                emitsize(0x67);
            }
    #endif
            return(1);

        default:
            return(0);
    }
}

#endif

/***	shortrange - check range of short jump
 *
 *	flag = shortrange (p);
 *
 *	Entry
 *	Exit
 *	Returns 1 for short jump, not shortened
 *		2 for forward label shortened
 *		0 for not short jmp
 *	Calls
 */


SHORT
PASCAL
CODESIZE
shortrange (
           struct parsrec  *p
           )
{
    register struct psop *pso1; /* parse stack operand structure */
    register OFFSET disp;

    pso1 = &(p->dsc1->dsckind.opnd);

    if (pso1->dtype & M_PTRSIZE
#ifdef V386
        && !((cputype & P386) && (pso1->dsize == CSNEAR))
#endif
       )
        if (opcbase == O_JMP) {
            if (!isdirect(pso1))
                return (0);
        } else
            errorc (E_IIS|E_WARN1);

    if (pso1->dflag == XTERNAL && pso1->dsize == CSNEAR)
        return (1);

    if (pso1->dsegment == pcsegment && M_CODE&pso1->dtype &&
        pso1->dflag != UNDEFINED) {

        if (pso1->dflag == XTERNAL)
            return (1);

        if (pcoffset + 2 < pso1->doffset) {

            /* Forward */
            disp = (pso1->doffset - pcoffset) - 2;
            CondJmpDist = disp - 127;

            /* Get displace, only jump shorten for explicid
             * forward jumps */

            if (disp < 128)

                if (pso1->dflag == KNOWN ||
                    opcbase == O_JMP || !(cputype&P386) ||
                    (cputype&P386 && pso1->dtype & M_SHRT)) {

                    pso1->doffset = disp;

                    if (pso1->dflag == KNOWN)
                        return(1);
                    else
                        return (2);
                } else
                    errorc(E_JSH);
        } else {

            /* Backwards jump */

            disp = (pcoffset + 2) - pso1->doffset;
            CondJmpDist = disp - 128;
            if (disp < 129) {
                pso1->doffset = 256 - disp;
                return (1);
            }
        }
    }

    return (FALSE);
}



/***	pshift - shift opcodes
 *
 *	pshift (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pshift (
       struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    DSCREC  *op3;

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    if (impure)
        errorc (E_IMP);
#ifdef V386

    /* Shift/rotate opcodes */

    if (pso1->dsize >= 2 && pso1->dsize != wordsize)
        emitsize(0x66);

    /* parse 3rd operand for SHLD and SHRD */
    /* note that we wont have even gotten here if not 386 */

    if (opcbase == O_SHRD || opcbase == O_SHLD) {

        if (pso1->dsize != pso2->dsize)
            errorc (E_OMM);

        pso2->dsegment = NULL;      /* for checksize */
        checksize (p);
        emitopcode(0x0f);
        checkwreg(pso2);
        if (NEXTC() == ',') {
            op3 = expreval (&nilseg);
            if (op3->dsckind.opnd.mode == 3 && op3->dsckind.opnd.rm == 1 && !op3->dsckind.opnd.w)
                emitopcode((UCHAR)(opcbase | 1));
            else {
                forceimmed (op3);
                emitopcode(opcbase);
            }
            emitmodrm ((USHORT)pso1->mode, (USHORT)(pso2->rm & 7), pso1->rm);
            /* Emit any effective address */
            emitrest (p->dsc1);
            /* and the immediate if appropriate */
            if (op3->dsckind.opnd.mode == 4)
                emitrest (op3);
        } else error(E_EXP,"comma");
        return;
    }
#endif
    if (pso2->mode == 3 && pso2->rm == 1 && pso2->dsize == 1)
        /* Have CL now */
        emitopcode ((UCHAR)(0xD2 + pso1->w));
    /* * 1st byte * */
    else {
        /* Shift count is 1 */
        forceimmed (p->dsc2);
        if (pso2->doffset == 1)
            /* * 1st byte */
            emitopcode ((UCHAR)(0xD0 + pso1->w));
        else if (cputype == P86)
            errorc (E_IOT);
        else {
            if (pso2->doffset > 0xFF)
                errorc (E_VOR);
            emitopcode ((UCHAR)(0xC0 + pso1->w));
        }
    }
    /* Must have size or error */
    forcesize (p->dsc1);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    /* Emit any effective address */
    emitrest (p->dsc1);
    if ((cputype != P86) && (pso2->doffset != 1))
        emitrest (p->dsc2);
}

#ifdef V386

/***	pmovx - 386 movzx, movsx operators
 *
 */
VOID
CODESIZE
pmovx(
     struct parsrec *p
     )
{

    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    checkwreg(pso1);
    if (pso2->mode == 4)
        errorc(E_IOT);

    if (pso1->dsize != wordsize)
        emitsize(0x66);

    if (pso2->sized && pso2->dsize != 1 && (pso1->dsize>>1 != pso2->dsize))
        errorc(E_IIS);

    emitopcode(0x0f);
    emitopcode((UCHAR)(opcbase|pso2->w));
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}

/***	psetcc - 386 setle, seto, etc
 *
 */
VOID
CODESIZE
psetcc(
      struct parsrec *p
      )
{

    register struct psop *pso1; /* parse stack operand structure */
    pso1 = &(p->dsc1->dsckind.opnd);

    if (pso1->dsize != 1)
        errorc(E_IIS);

    emitopcode(0x0f);
    emitopcode(modrm);
    emitmodrm ((USHORT)pso1->mode, 0, pso1->rm);
    emitrest (p->dsc1);
}

/***	pbit -- 386 bit test and set, complement or reset
 *
 */
VOID
CODESIZE
pbit(
    register struct parsrec *p
    )
{

    register struct psop *pso1;
    struct psop *pso2;

    pso1 = &(p->dsc1->dsckind.opnd);

    emitopcode(0x0f);

    if (pso1->mode == 4)
        errorc(E_NIM);

    pso2 = &(p->dsc2->dsckind.opnd);

    if (pso2->mode == 4) {
        emitopcode(0xBA);
        emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
        emitrest (p->dsc1);
        emitrest (p->dsc2);
        forcesize (p->dsc1);
        byteimmcheck (pso2);
    } else if (pso2->mode == 3) {
        static UCHAR byte2[] = {0xA3, 0xAB, 0xB3, 0xBB};
        emitopcode(byte2[modrm&3]);
        emitmodrm ((USHORT)pso1->mode, pso2->rm, pso1->rm);
        checkmatch (p->dsc2, p->dsc1);
        emitrest (p->dsc1);
    } else
        errorc(E_IOT);
}

/***	pbitscan -- 386 bit scan forward, reverse
 *
 */
VOID
CODESIZE
pbitscan(
        register struct parsrec *p
        )
{

    register struct psop *pso2;
    pso2 = &(p->dsc2->dsckind.opnd);

    checkwreg (&p->dsc1->dsckind.opnd);

    if (pso2->mode == 4)
        errorc (E_NIM);

    checkmatch (p->dsc1, p->dsc2);

    emitopcode(0x0f);
    emitopcode(modrm);
    emitmodrm ((USHORT)pso2->mode, p->dsc1->dsckind.opnd.rm, pso2->rm);
    emitrest (p->dsc2);
}

#endif /* V386 */

/***	parith - arithmetic operators
 *
 *	parith (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
parith (
       register struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    DSCREC      *op1;

    pso1 = &(p->dsc1->dsckind.opnd);

    /* note that opcbase is the same for IMUL and IDIV--thus this was
     * trying to accept immediates. modrm has the right stuff, strangely */

    if (opcbase == O_IMUL && (modrm == R_IMUL) &&
        (PEEKC () == ',') && (cputype != P86)) {

        /* IMUL reg | ea,imm */
        SKIPC ();
        if (pso1->dsize != 2 && pso1->dsize != 4)
            errorc (E_BRI);
        p->defseg = (unsigned char)segdefault (SECONDDS);
        p->dsc2 = expreval (&p->defseg);
        pso2 = &(p->dsc2->dsckind.opnd);
        if (PEEKC () == ',') {
            SKIPC ();
            if (pso2->sized && ((pso2->dsize != 2 && pso2->dsize != 4)
                                || pso2->dsize != pso1->dsize))
                errorc (E_IIS);
            /* IMUL reg,ea,immed */
#ifdef V386
            emit67 (pso1, pso2);
            emit66 (pso1, pso2);
#endif
            op1 = p->dsc1;
            p->dsc1 = p->dsc2;
            pso1 = pso2;
            p->dsc2 = expreval (&nilseg);
            pso2 = &(p->dsc2->dsckind.opnd);
            forceimmed (p->dsc2);
            emitescape (p->dsc1, p->defseg);
            emitopcode ((UCHAR)(IMUL3 + 2 * pso2->s));
            emitmodrm ((USHORT)pso1->mode, op1->dsckind.opnd.rm, pso1->rm);
            emitrest (p->dsc1);
            pso2->w = !pso2->s; /* shorten to byte if necessary */
            if (!pso2->w)
                byteimmcheck(pso2);
            /* force size immediate size to match op 1 */
            pso2->dsize = op1->dsckind.opnd.dsize;
            emitrest (p->dsc2);
            dfree ((char *)op1 );
        }
#ifdef V386
        else if (pso2->mode != 4 && (cputype & P386)) {
            /* IMUL reg, reg/mem */
            if (pso1->dsize != pso2->dsize && pso2->sized)
                errorc (E_OMM);
            emit67 (pso1, pso2);
            emit66 (pso1, pso2);
            emitescape (p->dsc2, p->defseg);
            emitopcode(0x0f);
            emitopcode(0xaf);
            emitmodrm(pso2->mode, pso1->rm, pso2->rm);
            emitrest(p->dsc2);
        }

#endif /* V386 */
        else {
            /* IMUL reg,immed */
#ifdef V386		/* recompute immediate size based op 1 size not word size */

            if (!(pso2->dflag & (UNDEFINED|FORREF|XTERNAL))
                && pso2->fixtype == FCONSTANT
                && pso2->doffset & 0x8000)
                if (pso1->dsize == 2)
                    pso2->s = (char)((USHORT)(((USHORT) pso2->doffset & ~0x7F ) == (USHORT)(~0x7F)));
                else
                    pso2->s = (char)((OFFSET)((pso2->doffset & ~0x7F ) == (OFFSET)(~0x7F)));

            emit67 (pso1, pso2);
            emit66 (pso1, pso2);
#endif
            forceimmed (p->dsc2);
            checksize(p);
            emitopcode ((UCHAR)(IMUL3 + 2 * pso2->s));
            emitmodrm ((USHORT)pso1->mode, pso1->rm, pso1->rm);
            pso2->w = !pso2->s; /* shorten to byte if necessary */
            if (!pso2->w)
                byteimmcheck(pso2);
            pso2->dsize = pso1->dsize;
            emitrest (p->dsc2);
        }
    } else {
#ifdef V386
        emit67 (pso1, NULL);
        emit66 (pso1, NULL);
#endif
        forcesize (p->dsc1);
        emitescape (p->dsc1, p->defseg);
        if ((opcbase == O_NEG || opcbase == O_NOT) && impure)
            errorc (E_IMP);
        emitopcode ((UCHAR)(ARITHBASE + pso1->w));
        emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
        emitrest (p->dsc1);
    }
}




/***	pbound - bounds operators
 *
 *	pbound (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pbound (
       struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    checkwreg(pso1);
    if (pso2->dsize != pso1->dsize*2)
        errorc (E_IIS);

#ifdef V386_0

    if (wordsize != pso1->dsize)
        emitsize(0x66);
#endif
    emitopcode (opcbase);
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}




/***	penter - enter operators
 *
 *	penter (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
penter (
       register struct parsrec *p
       )
{

    emitopcode (opcbase);

    p->dsc1->dsckind.opnd.dsize = 2;
    emitOP (&p->dsc1->dsckind.opnd);

    p->dsc2->dsckind.opnd.dsize = 1;
    forceimmed (p->dsc2);
    emitOP (&p->dsc2->dsckind.opnd);
}




/***	pclts - 	   operators
 *
 *	pclts ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pclts ()
{
    emitopcode (opcbase);
    emitopcode (modrm);
}




/***	pdescrtbl - table operators
 *
 *	pdescrtbl (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pdescrtbl (
          struct parsrec *p
          )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    if (pso1->dsize != 6)
        errorc (E_IIS);
    emitopcode (opcbase);
    emitopcode (1);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    emitrest (p->dsc1);
}




/***	pdttrsw -	     operators
 *
 *	pdttrsw (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL CODESIZE

pdttrsw (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    if (!pso1->w || (pso1->sized && pso1->dsize != 2))
        errorc ((USHORT)(pso1->mode != 3? E_IIS: E_IIS & ~E_WARN1));
    emitopcode (opcbase);
    if ((modrm == R_LMSW) || (modrm == R_SMSW))
        emitopcode (1);
    else
        emitopcode (0);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    emitrest (p->dsc1);
}




/***	pver -		  operators
 *
 *	pver (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pver (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    if (!pso1->w || (pso1->sized && pso1->dsize != 2))
        errorc ((UCHAR)(pso1->mode != 3? E_IIS: E_IIS & ~E_WARN1));
    emitopcode (opcbase);
    emitopcode (0);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    emitrest (p->dsc1);
}




/***	parsl - 	   operators
 *
 *	parsl (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
parsl (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    checkmatch (p->dsc1, p->dsc2);
    checkwreg(pso1);

    emitopcode (opcbase);
    emitopcode (modrm);
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}




/***	parpl - 	   operators
 *
 *	parpl (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
parpl (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    if (pso2->dsize != 2)
        errorc (E_IIS);

    checkmatch (p->dsc2, p->dsc1);
    emitopcode (opcbase);
    emitmodrm ((USHORT)pso1->mode, pso2->rm, pso1->rm);
    emitrest (p->dsc1);
}




/***	pstack - push|pos stack
 *
 *	pstack (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pstack (
       struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);

#ifdef V386
    if (!(pso1->fixtype == FBASESEG || pso1->fixtype == FGROUPSEG) &&
        pso1->sized && (pso1->dsize|wordsize) == 6 &&
        !(pso1->mode == 3 && pso1->dsegment->symu.regsym.regtype == SEGREG)) {
        emitsize(0x66);
        errorc (E_ONW);
    }
#endif

    if (pso1->mode == 3) {          /* Using register */
        /* Forward is error */
        errorforward (p->dsc1);
        switch (pso1->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* CS | DS | ES | SS | FS | GS */
                rangecheck (&pso1->rm, (UCHAR)7);
                if (opcbase == O_POP && pso1->rm == CSSEG)
                    errorc (E_CSI);
#ifdef V386
                if (pso1->rm >= FSSEG) {
                    emitopcode(0x0f);
                    emitopcode ((UCHAR)(((pso1->rm << 3)+ 0x80) + (opcbase == O_POP)));
                } else
#endif
                    emitopcode ((UCHAR)(((pso1->rm << 3)+ 6) + (opcbase == O_POP)));
                break;
            case WRDREG:
            case INDREG:
#ifdef V386
            case DWRDREG:
#endif
                rangecheck (&pso1->rm, (UCHAR)7);
                emitopcode ((UCHAR)(opcbase + pso1->rm));
                /* Reg form */
                break;
            default:
                errorc(E_BRI);
        }
    } else if (pso1->mode == 4) {

#ifdef V386		/* detect immediate too big */
        if (wordsize == 2 && pso1->dsize != 4 && highWord(pso1->doffset))
            if (highWord(pso1->doffset) != 0xFFFF || !pso1->s)
                errorc(E_VOR);
#endif
        if (opcbase == O_POP || cputype == P86)
            errorimmed (p->dsc1);

        emitopcode ((UCHAR)(0x68 + 2 * pso1->s));
        pso1->w = !pso1->s; /* shorten to byte if necessary */
        if (!pso1->w)
            byteimmcheck(pso1);

        else if (!(M_PTRSIZE & pso1->dtype))
            pso1->dsize = wordsize; /* force size to wordsize */

        emitrest (p->dsc1);
    } else {

        if (pso1->sized && pso1->dsize &&
            !(pso1->dsize == 2 || pso1->dsize == 4))

            errorc(E_IIS);

        /* Have memory operand of some kind */

        if (opcbase == O_POP && impure)
            errorc (E_IMP);

        emitopcode ((UCHAR)((opcbase == O_PUSH)? O_PUSHM: O_POPM));
        emitmodrm ((USHORT)pso1->mode,
                   (USHORT)((opcbase == O_PUSH)? 6: 0),
                   pso1->rm);
        emitrest (p->dsc1);
    }
}


/***	buildFrame - builds stack frame
 *
 *	preturn (p);
 *
 *	Entry before first instruction is generated in proc
 */


VOID
PASCAL
CODESIZE
buildFrame()
{
    char szLocal[32];
    char szT[48];
    SHORT i;

    strcpy(save, lbuf);     /* save line for later .. */
    fSkipList++;

    fProcArgs = -fProcArgs;     /* mark already processed */

    if (fProcArgs < -ARGS_REG) {

        *radixconvert (cbProcLocals,  szLocal) = NULL;
        if (cputype & P86) {

            doLine("push bp");
            doLine("mov  bp,sp");

            if (fProcArgs == -ARGS_LOCALS)     /* locals present */
                doLine(strcat( strcpy(szT, "sub sp,"), szLocal));
        } else
            doLine(strcat( strcat( strcpy(szT, "enter "), szLocal), ",0"));
    }

    for (i = 0; i <= iRegSave; i++) {  /* push all the saved registers */

        doLine( strcat( strcpy(lbuf, "push "), regSave[i]) );
    }

    fSkipList--;
    lbufp = strcpy(lbuf, save);
    linebp = lbufp + strlen(lbufp);
    strcpy(linebuffer, save);
    parse();
}


/***	preturn - various forms of return
 *
 *	preturn (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */



VOID
PASCAL
CODESIZE
preturn (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */
    SHORT i;

    pso1 = &(p->dsc1->dsckind.opnd);

    /* Decide whether inter or intra segment */

    if (!modrm) {    /* determine distance, if not RETN or RETF */

        if (fProcArgs) {            /* tear down the stack frame */

            strcpy(save, linebuffer);
            fSkipList++;

            for (i = iRegSave; i >= 0; i--) {  /* pop all the saved registers */

                doLine( strcat( strcpy(lbuf, "pop "), regSave[i]) );
            }

            if (fProcArgs < -ARGS_REG)
                if (cputype & P86) {

                    if (fProcArgs == -ARGS_LOCALS)  /* locals present */
                        doLine("mov  sp,bp");

                    doLine("pop bp");
                } else
                    doLine("leave");

            if (!(pcproc->attr & M_CDECL))
                pso1->doffset = cbProcParms;

            strcpy(linebuffer, save);
            listindex = 1;
            fSkipList = FALSE;
        }

        opcbase = O_RET;

        if (pcproc && pcproc->symtype == CSFAR)
            opcbase = O_RET + 8;
    }

    /* Optimize, if constant is 0 and not forward, use SHORT */

    if (pso1->doffset == 0 && pso1->dflag != FORREF)
        emitopcode (opcbase);

    else {  /* Gen 2 byte version */
        emitopcode ((UCHAR)(opcbase - 1));  /* Pop form */
        /* Force word--always 2 bytes, even on 386 */
        pso1->dsize = 2;
        emitOP (pso1);          /* Immediate word */

    }
}




/***	pincdec - increment|decrement
 *
 *	pincdec (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pincdec (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    /* INC | DEC */
    if (!pso1->sized)
        errorc (E_OHS);
    if (pso1->mode == 3 && pso1->w)
        /* Is word reg */
        emitopcode ((UCHAR)(opcbase + pso1->rm));
    else {
        /* Use mod reg r/m form */
        if (impure)
            errorc (E_IMP);
        emitopcode ((UCHAR)(0xFE + pso1->w));
        emitmodrm ((USHORT)pso1->mode,
                   (USHORT)(opcbase == O_DEC), pso1->rm);
        emitrest (p->dsc1);
    }
}




/***	pint - interrupt
 *
 *	pint (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pint (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    /* INT */
    valuecheck (&pso1->doffset, 255);
    if (pso1->doffset == 3 && pso1->dflag != FORREF)
        /* Use SHORT form */
        emitopcode (opcbase);
    else {
        /* Use long form */
        emitopcode ((UCHAR)(opcbase + 1));
        emitopcode ((UCHAR)(pso1->doffset & 255));
    }
}




/***	pinout - input|output
 *
 *	pinout (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pinout (
       struct parsrec *p
       )
{
    register DSCREC *pso1;
    register DSCREC *pso2;

    pso1 = p->dsc1;
    pso2 = p->dsc2;

    if (opcbase == O_OUT) {
        pso2 = pso1;
        pso1 = p->dsc2;
    }

    /* IN  ax|al,	 DX|immed */
    /* OUT DX|immed, ax|al, */

#ifdef V386
    emit66(&pso1->dsckind.opnd, NULL);
#endif
    forceaccum (pso1);

    /* Must be accum */
    if (pso2->dsckind.opnd.mode == 3 && pso2->dsckind.opnd.rm == 2) {
        /* Have DX */
        emitopcode ((UCHAR)(opcbase + pso1->dsckind.opnd.w + 8));

        if (pso2->dsckind.opnd.dsize != 2)
            errorc(E_IRV);
    } else {
        /* Have port # */
        forceimmed (pso2);
        /* Must be constant */
        valuecheck (&pso2->dsckind.opnd.doffset, 255);
        emitopcode ((UCHAR)(opcbase + pso1->dsckind.opnd.w));
        emitopcode ((UCHAR)(pso2->dsckind.opnd.doffset));
    }
}




/***	pload - load
 *
 *	pload (p);	lea, les, les, etc
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pload (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    /* LDS | LEA | LES */

    if (pso1->mode != 3)
        /* Must be reg */
        errorc (E_MBR);

    else if (1 << pso1->dsegment->symu.regsym.regtype
             & (M_STKREG | M_SEGREG | M_BYTREG))
        errorc (E_WRT);

    if (pso2->mode == 3)
        errorc (E_IUR);

    if (opcbase != O_LEA) {
        if (pso2->dsize && pso2->dsize != 4 && pso2->dsize != 6)
            errorc (E_IIS);

        /* complain about mismatching source and destination */

        if (pso2->dsize && pso1->dsize &&
            pso1->dsize + 2 != pso2->dsize)
            errorc (E_IIS);
#ifdef V386
        else if (pso2->dsize && pso2->dsize != wordsize+2)
            emitsize(0x66);
        else if (pso1->dsize && pso1->dsize != wordsize)
            emitsize(0x66);
#endif
    }

#ifdef V386
    else
        if (pso1->dsize != wordsize)
        emitsize(0x66);

    switch (opcbase) {
        case O_LFS:
        case O_LGS:
        case O_LSS:
            emitopcode(0x0F);
            break;
    }
#endif
    emitopcode (opcbase);
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);

    /* If FAR, make offset so only 2 bytes out */

    if (pso2->fixtype == FPOINTER)
        pso2->fixtype = FOFFSET;

    emitrest (p->dsc2);
}




/***	pmov - move
 *
 *	pmov (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pmov (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    /* If 1st arg is memory or undef, force 2nd to be
     * immed for pass 1 and set <EXPLOFFSET> in pass 2 */

    if ((pso1->mode < 3) && (pso2->mode != 3)) {
        /* mem,immed */
        pso2->dtype |= M_EXPLOFFSET;
        /* Look like OFFSET val */
        if (!pass2)
            /* Force immed on pass1 */
            pso2->mode = 4;
    }
    /* See if this is immediate move */
    if (pso2->mode == 4) {
        emit66 (pso1, pso2);

        /* MOV arg,immed */
        if (pso1->mode == 3) {
            /* MOV reg,immed */
            if (1 << pso1->dsegment->symu.regsym.regtype
                & (M_SEGREG | M_STKREG | M_CREG ))
                /* Wrong type of register */
                errorc (E_NIM);
            emitopcode ((UCHAR)(176 + 8*pso1->w + pso1->rm));
            /* Make sure agree */
            checksize (p);
            emitrest (p->dsc2);
            /* Emit immed */
            if (pso1->rm &&
                pso2->dtype & M_FORTYPE &&
                !pso2->dsegment && !(M_EXPLOFFSET & pso2->dtype))
                /* Pass 1 assumed not immed */
                emitnop();
        } else {/* MOV mem,immed */
            checksize (p);
            if (!(pso1->sized || pso2->sized)) {
                pso1->sized = pso2->sized = TRUE;
                pso1->w = pso2->w = TRUE;
            }
            /* Make sure agree */
            if (impure)
                errorc (E_IMP);
            emitopcode    (   (   UCHAR)(   198    +    pso1->w));
            emitmodrm ((USHORT)pso1->mode, 0, pso1->rm);
            emitrest (p->dsc1);
            emitrest (p->dsc2);
        }

        if (!pso1->w)

            /*	1st operand is byte, 2nd is immed
             *	Check below on dsc1 should only be done
             *	on MOV since the PGENARG opcodes always shorten a known
             *	byte const */

            if ((pso1->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE ||
                (pso2->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE)
                emitnop();

    }
    /* See if either is segment register */
    else if (pso1->mode == 3) {
        /* 1st arg is reg */
        switch (pso1->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* MOV SEGREG,arg */
                movesegreg (TRUE, p);
                break;
#ifdef V386
            case CREG:
                /* mov CREG,reg */
                movecreg (TRUE, p);
                break;

            case DWRDREG:
#endif
            case BYTREG:
            case WRDREG:
                /* MOV ac,addr? */
                if ((pso1->rm == 0) && isdirect(pso2))
                    /* MOV ac,addr */
                    moveaccum (TRUE, p);
                else
                    /* MOV reg,arg */
                    movereg (TRUE, p);
                break;
            case INDREG:
                /* MOV indreg,arg */
                movereg (TRUE, p);
                break;
            default:
                errorc (E_WRT);
                break;
        }
    } else if (pso2->mode == 3) {
        /* 2nd arg is reg */
        switch (pso2->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* MOV arg,SEGREG */
                movesegreg (FALSE, p);
                break;
#ifdef V386
            case CREG:
                /* mov reg, CREG */
                movecreg(FALSE, p);
                break;
            case DWRDREG:
#endif
            case BYTREG:
            case WRDREG:
                /* MOV addr,ac? */
                if ((pso2->rm == 0) && isdirect(pso1))
                    /* MOV addr,ac */
                    moveaccum (FALSE, p);
                else
                    /* MOV arg,reg */
                    movereg (FALSE, p);
                break;
            case INDREG:
                /* MOV arg,indreg */
                movereg (FALSE, p);
                break;
            default:
                errorc (E_WRT);
                break;
        }
    } else
        errorc (E_IOT);
}




/***	pgenarg
 *
 *	pgenarg (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID
PASCAL
CODESIZE
pgenarg (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    char fAccumMode = 0;

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    /* ADC | ADD | AND | CMP | OR | SBB  SUB | XOR | TEST */
    if (pso1->mode != 3 && pso2->mode != 3) {
        /* Force to mem,immed */
        if (!pass2)
            /* Force immediate */
            pso2->mode = 4;
    }
    /* Not AX,immed */
    if (pso2->mode == 4) {

#ifdef V386	/* recompute immediate size based op 1 size not word size */

        if (!(pso2->dflag & (UNDEFINED|FORREF|XTERNAL))
            && pso2->fixtype == FCONSTANT
            && pso2->doffset & 0x8000)
            if (pso1->dsize == 2)
                pso2->s = (char)((USHORT)(((USHORT) pso2->doffset & ~0x7F ) == (USHORT)(~0x7F)));
            else
                pso2->s = (char)((OFFSET)((pso2->doffset & ~0x7F ) == (OFFSET)(~0x7F)));

#endif
        /* OP mem/reg,immed */
        if (pso1->mode == 3 && pso1->rm == 0
#ifdef V386
            && !(pso1->dsize == 4 && pso2->s &&
                 opcbase != O_TEST)      /* chose size extended */
#endif						    /* general purpose over ac*/
           ) {

            /* OP al|ax|eax,immed */
            checksize (p);
            /* Make sure agree */
            if (opcbase == O_TEST)
                /* * TEST is special * */
                emitopcode ((UCHAR)(0xA8 + pso1->w));
            else/* Other reg immed */
                /* Is AX,immed */
                emitopcode ((UCHAR)(opcbase + 4 + pso1->w));
            fAccumMode = 1;
        } else {/* OP mem/reg, immed */

            checksize (p);
            if (!(pso1->sized || pso2->sized)) {
                pso1->sized = pso2->sized = TRUE;
                pso1->w = pso2->w = TRUE;
            }
            /* Make sure agree */
            if (opcbase == O_TEST) {
                /* TEST is special */
                emitopcode ((UCHAR)(ARITHBASE + pso1->w));
                emitmodrm ((USHORT)pso1->mode, 0, pso1->rm);
            } else {
                if (opcbase != O_CMP && impure)
                    errorc (E_IMP);

                if (pso2->w) {
                    /* Try to shorten word */
                    emitopcode ((UCHAR)(0x80 + (pso2->s <<1) +pso1->w));
                    pso2->w = !pso2->s;
                    /* So only byte out */
                    if (!pso2->w) {
                        fAccumMode = wordsize - 1;
                        byteimmcheck(pso2);
                    }
                } else {
                    emitopcode (128);
                }
                emitmodrm ((USHORT)pso1->mode, (USHORT)(opcbase>>3), pso1->rm);
            }
            emitrest (p->dsc1);
        }
        if (pso2->w && !pso1->w)
            /* size mismatch */
            errorc (E_VOR);

        emitrest (p->dsc2);     /* Emit immed */

        if (!pso1->w)

            if (((pso2->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE ||
                 opcbase == O_TEST && pso1->mode != 3) &&

                ((pso1->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE ||
                 pso1->mode == 3))

                emitnop();

        if (fAccumMode &&
            M_FORTYPE & pso2->dtype &&
            !(M_EXPLOFFSET & pso2->dtype))

            while (--fAccumMode >= 0)
                emitnop();
    } else {  /* Not immediate */
        if (pso1->mode == 3) {
            /* OP reg,mem/reg */
            checkmatch (p->dsc1, p->dsc2);
            if (opcbase == O_TEST)
                opcbase = O_TEST - 2;

            emitopcode ((UCHAR)(opcbase + 2 + pso1->w));
            emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
            emitrest (p->dsc2);
        } else if (pso2->mode != 3)
            errorc (E_IOT);

        else { /* Have OP mem,reg */
            if (opcbase != O_CMP && opcbase != O_TEST && impure)
                errorc (E_IMP);

            checkmatch (p->dsc2, p->dsc1);
            emitopcode ((UCHAR)(opcbase + pso2->w));
            emitmodrm ((USHORT)pso1->mode, pso2->rm, pso1->rm);
            emitrest (p->dsc1);
        }
    }
}




/***	pxchg - exchange register and register/memory
 *
 *	pxchg (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pxchg (
      struct parsrec  *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    DSCREC *t;

    if (impure)
        errorc (E_IMP);

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if (pso1->mode != 3) {

        if (pso2->mode != 3) {
            errorc (E_OCI);     /* Illegal */
            return;
        }
        t = p->dsc1;
        p->dsc1 = p->dsc2;
        p->dsc2 = t;

        pso1 = &(p->dsc1->dsckind.opnd);
        pso2 = &(p->dsc2->dsckind.opnd);

    }

    /* First operand is register */

    if (1 << pso1->dsegment->symu.regsym.regtype & (M_STKREG | M_SEGREG))
        errorc (E_WRT);
    rangecheck (&pso1->rm, (UCHAR)7);

    if (pso1->dsize != pso2->dsize && pso2->sized)
        errorc (E_OMM);

    if (pso2->mode == 3) {
        /* XCHG reg, reg */

        if (1 << pso2->dsegment->symu.regsym.regtype & (M_STKREG | M_SEGREG))
            errorc (E_WRT);
        rangecheck (&pso2->rm, (UCHAR)7);

        /* Check for XCHG accum, reg */

        if (pso1->rm == 0 && pso1->w) {
            emitopcode ((UCHAR)(144 + pso2->rm));
            return;
        } else if (pso2->w && pso2->rm == 0) {
            emitopcode ((UCHAR)(144 + pso1->rm));
            return;
        }
    }
    emitopcode ((UCHAR)(134 + pso1->w));
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}






/***	pesc - escape operators
 *
 *	pesc (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pesc (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    /* ESC opcode,modrm */
    valuecheck (&pso1->doffset, 63);
    emitopcode ((UCHAR)(216 + pso1->doffset / 8));
    emitmodrm ((USHORT)pso2->mode, (USHORT)(pso1->doffset & 7), pso2->rm);
    emitrest (p->dsc2);
}



/***	prepeat - repeat operators
 *
 *	prepeat (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
prepeat (
        struct parsrec *p
        )
{

    /* REP | REPZ | REPE | REPNE | REPNZ */
    emitopcode (opcbase);
    listbuffer[listindex-1] = '/';
    listindex++;
    /* Flag is LOCK/REP */
    getatom ();
    if (!opcodesearch ())
        /* Must have another op */
        errorc (E_OAP);
    else
        /* Prefix for string instr */
        opcode ();
    p->dsc1 = NULL;
    p->dsc2 = NULL;
}




/***	pstr - string operators
 *
 *	pstr (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pstr (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    /* SCAS | STOS | MOVS | LODS | CMPS */
    if (!p->dsc2)
        p->dsc2 = p->dsc1;
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if (opcbase == O_OUTS) {
        if (pso1->mode != 3)
            errorc (E_MBR);
        else if (pso1->rm != 2)
            errorc (E_WRT);
        p->dsc1 = p->dsc2;
        pso1 = pso2;
    }
    if (opcbase == O_INS) {
        if (pso2->mode != 3)
            errorc (E_MBR);
        else if (pso2->rm != 2)
            errorc (E_WRT);
        p->dsc2 = p->dsc1;
        pso2 = pso1;
    }

    /* Had to wait til now, so OUTS, INS would be adjusted already */
    emit66 (pso1, pso2);

    if ((pso1->mode > 2 && pso1->mode < 5) ||
        (pso2->mode > 2 && pso2->mode < 5))
        errorc (E_IOT);

    if (!(pso1->sized || pso2->sized))
        /* Give error if don't have a size specified */
        errorc (E_OHS);

    if (pso1->w != pso2->w)
        errorc (E_OMM);

    if (opcbase == O_MOVS || opcbase == O_LODS || opcbase == O_OUTS) {
        emitescape (p->dsc2, DSSEG);
        /* 2nd can be override */
        if (p->dsc1 != p->dsc2)
            errorover (pso1->seg);
    } else {
        errorover (pso2->seg);
        /* No 2nd override */
        if (p->dsc1 != p->dsc2)
            emitescape (p->dsc1, DSSEG);
    }
    emitopcode ((UCHAR)(opcbase + pso1->w));
    if (p->dsc1 == p->dsc2) {
        p->dsc1 = NULL;
    }
}




/***	pxlat
 *
 *	pxlat (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pxlat (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    /* XLAT */
    if (pso1->mode <= 2 || pso1->mode >= 5)
        /* Good mode */
        if (pso1->w)
            /* Must be byte */
            errorc (E_IIS);
    emitopcode (opcbase);
}


/* isdirect -- given a psop representing a modrm, is it mem-direct? */

USHORT
CODESIZE
isdirect(
        register struct psop *pso   /* parse stack operand structure */
        )
{
    return ((pso->mode == 0 && pso->rm == 6) || /* for 8086 */
            (pso->mode == 5 && pso->rm == 5));  /* for 386 */
}

#ifdef V386

/* emit66 -- if dsize == 2 && wordsize == 4, or vice versa, we generate
 * a 66 prefix to locally change the operand mode.
 */

VOID
PASCAL
CODESIZE
emit66(
      register struct psop *pso1, /* parse stack operand structure */
      register struct psop *pso2  /* parse stack operand structure */
      )
{


    if (!pso1)
        return;

    if (!pso2) {

        if (pso1->sized && (pso1->dsize | wordsize) == 6)
            emitsize(0x66);
    } else {
        /* key off the first operand if size known AND second isn't a register */

        if (pso1->sized && pso2->mode != 3 ||

            /* bogusness--sized and dsize 0 means immed bigger than 127 */

            (pso2->sized &&
             (pso1->dsize == pso2->dsize || pso2->dsize == 0))) {
            if ((pso1->dsize | wordsize) == 6)
                emitsize(0x66);
        } else if (pso2->sized) {
            if ((pso2->dsize | wordsize) == 6)
                emitsize(0x66);
        }
    }
    /* otherwise we have inconsistent opcodes and we cant do a thing.
       so dont.  bogus!!! */
}

/* emit67-- checks for operand size not matching wordsize and emits the
 * appropriate override */

VOID
PASCAL
emit67(
      register struct psop *pso1, /* parse stack operand structure */
      register struct psop *pso2  /* parse stack operand structure */
      )
{

    if (!pso1)
        return;

    if ((1<<FIRSTDS) & xoptoseg[opctype]) {
        if (wordsize < 4 && pso1->mode > 4) {
            emitsize(0x67);
            return;
        } else if (wordsize > 2 && pso1->mode < 3) {
            emitsize(0x67);
            return;
        }
    }

    if (!pso2 || !(1<<SECONDDS & xoptoseg[opctype]))
        return;

    if (wordsize < 4 && pso2->mode > 4) {
        emitsize(0x67);
        return;
    } else if (wordsize > 2 && pso2->mode < 3) {
        emitsize(0x67);
        return;
    }
}

#endif /* V386 */

/* check for word register, or if 386, dword register */
CODESIZE
checkwreg(
         register struct psop *psop  /* parse stack operand structure */
         )
{

    if (psop->mode != 3)
        errorc (E_MBR);
    if (psop->dsize != 2

#ifdef V386
        && (!(cputype&P386) || psop->dsize != 4)
#endif
       )
        errorc (E_BRI);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmopcod.c ===
/* asmopcod.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"


#ifdef FIXCOMPILERBUG
// foobarfoofoo simply takes up space to get around a compiler bug
void
foobarfoofoo()
{
    int foo;

    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
}
#endif

/***	forcesize - check for no size in pass 2
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
forcesize (
	DSCREC *arg
){
	register struct psop *pso;	/* parse stack operand structure */

	pso = &(arg->dsckind.opnd);
	if (pass2)
		if (!pso->sized)
			errorc (E_OHS);
		else if (M_CODE & pso->dtype)
			/* Not data assoc */
			errorc (E_ASD);

	if (arg != fltdsc)	/* Large size ok for 8087 */

		if (pso->dsize > 2 && (
#ifdef V386
		    !(cputype&P386) ||
#endif
			pso->dsize != 4))
			/* Illegal item size */
			errorc (E_IIS);
}




/***	checkmatch - check memory and register
 *
 *	checkmatch ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Give error if Dmem has a size and does not match Dreg.
 *		Force to same size
 */


VOID	PASCAL CODESIZE
checkmatch (
	DSCREC *dreg,
	DSCREC *dmem
){
	register struct psop *psor;	/* parse stack operand structure */
	register struct psop *psom;	/* parse stack operand structure */

	psor = &(dreg->dsckind.opnd);
	psom = &(dmem->dsckind.opnd);
	if (psom->sized && (psom->w != psor->w

#ifdef V386
	    || (psom->dsize && psor->dsize != psom->dsize)
#endif
	))
	    errorc ((USHORT)(psom->mode == psor->mode? E_OMM & ~E_WARN1: E_OMM));

	psom->w = psor->w;
}




/***	emitopcode - emit opcode to linker and display on listing
 *
 *	emitopcode (val);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitopcode (
	UCHAR	v
){
	if (pass2 || debug) {
		if (pass2 && emittext)
			/* Output to linker */
			emitcbyte (v);
		/* Display on listing */
		opdisplay (v);
	}
	if (emittext)
		pcoffset++;
}




/***	emitmodrm - emit modrm byte 64*p1+8*p2+p3
 *
 *	emitmodrm (p1, p2, p3);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitmodrm (
	USHORT	p1,
	USHORT	p2,
	USHORT	p3
){

#ifdef V386
	if (p1>7)
	{
		/* 386 SIB opcodes have wired in RM of ESP */
		emitopcode ((UCHAR)(((p1-8) << 6) + (p2 << 3) + 4));
		listindex--;
		emitopcode ((UCHAR)p3);
	}
	else
#endif
		emitopcode ((UCHAR)(((p1 > 3 ? (p1-5) : p1) << 6) + (p2 << 3) + p3));
}




/***	emitescape - emit segment escapt byte
 *
 *	emitescape ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitescape (
	DSCREC	*dsc,
	UCHAR	sreg
){
	register struct psop *pso;     /* parse stack operand structure */

	pso = &(dsc->dsckind.opnd);
	if (pso->seg < NOSEG && pso->seg != sreg && pso->mode != 4) {
		if (checkpure && (cputype & (P286|P386)) && pso->seg == CSSEG)
			impure = TRUE;

		if (pso->seg < FSSEG)
			emitopcode((UCHAR)(0x26|(pso->seg<<3)));
#ifdef V386
		else if (cputype & P386)
			emitopcode((UCHAR)(0x60|pso->seg));
#endif
		else
			errorc (E_CRS);
		/* Flag is prefix */
		listbuffer[listindex-1] = ':';
		listindex++;
	}
	if (pso->seg > NOSEG)
		/* Unknown segreg */
		errorc (E_CRS);
}

#ifdef V386

VOID PASCAL CODESIZE
emitsize (
	USHORT value
){
	if (! (cputype & P386)) {

	    if (errorcode == (E_IIS&~E_WARN1))
		errorcode = 0;

	    errorc(E_IIS&~E_WARN1);
	}

	emitopcode((UCHAR)value);
	listbuffer[listindex-1] = '|';
	listindex++;
}

#endif





/***	byteimmcheck - check if value is -128 .. +127
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
byteimmcheck (
	register struct psop *pso
){
	register USHORT t;

	t = (USHORT)pso->doffset;
	if (pso->dsign)
		t = -t;

	if (t > (USHORT) 0x7F && t < (USHORT)~0x7F)
		errorc (E_VOR);
}


/***	emitOP - emit operand, value which may be in segment
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitOP (
	register struct psop *pso
){
	USHORT	i, fSegOnly;

	if (pso->dsign)
	   pso->doffset = -(long)pso->doffset;

	pso->dsign = FALSE;

	if (fNeedList) {

		fSegOnly = (pso->fixtype == FBASESEG || pso->fixtype == FGROUPSEG);

		if (pso->dflag == INDETER) {	/* Have ? */

		    for (i = 1; i <= 2 * pso->dsize; i++) {
			    listbuffer[listindex] = '?';
			    if (listindex < LSTMAX)
				    listindex++;
			    else
				    resetobjidx ();
		    }
		}
		else if (pso->dsize == 1) {

		    opdisplay ((UCHAR) pso->doffset);
		    listindex--;
		}
		else if (!fSegOnly) {

		    if (pso->dsize > 4 ||
			pso->dsize == 4 &&
			((pso->fixtype&7) == FOFFSET || pso->fixtype == FCONSTANT)) {

			/* list full 32 bits, even if top is 0 */

			if (!highWord(pso->doffset)){
			    offsetAscii((OFFSET) 0);
			    copyascii();
			}
			offsetAscii (pso->doffset);
		    }
		    else
			offsetAscii (pso->doffset & 0xffff);

		    copyascii ();
		}

		if ((pso->fixtype&7) == FPOINTER || fSegOnly) {

			if (pso->dsize != 2)
				listindex++;

			copytext ("--");
			copytext ("--");
		}
		if (pso->dflag == XTERNAL)
			copytext (" E");
		else if (pso->dsegment)
			copytext (" R");
		if (pso->dflag == UNDEFINED)
			copytext (" U");

		listindex++;

		if (fSegOnly && pso->dsize == 4){
		    copytext("00");
		    copytext("00");
		}

	}
	if (emittext) {
		if (pass2)
			if (pso->dflag != UNDEFINED)
			emitobject (pso);

		    else if (pso->dsize != 1)
			emitcword ((OFFSET) 0);  /* Just put out word */

		    else {
			if (((USHORT) (pso->doffset >> 8)) != (USHORT)0 &&
			    ((USHORT) (pso->doffset >> 8)) != (USHORT)-1)

				errorc (E_VOR);

			emitcbyte (0);
		    }

		pcoffset += pso->dsize;
	}
}




/***	emitrest - emit displacement or immediate values based on
 *	address passed in address mode
 *
 *	emitrest (opc);
 *
 *	Entry	*opc = parse stack entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitrest (
	DSCREC *opc
){
	register struct psop *pso;	/* parse stack operand structure */

	pso = &(opc->dsckind.opnd);

	if ((pso->mode != 3 && pso->mode != 4) && (pso->fixtype == FNONE))
		pso->fixtype = FCONSTANT;

	switch(pso->mode)
		/* There is something to output */
	{
	case 0:
		if(pso->rm != 6) break;
	case 2:
		pso->dsize = 2;
		goto bpcomm;

		/* 386 modes, 4 byte displacements */
	case 5:
	case 8:
		if ((pso->rm&7) != 5) break;
	case 7:
	case 10:
		pso->dsize = 4;
	bpcomm:
		/* we get empty dsize from some callers.  for this operand,
		 * we need to make it an offset.  but not for far calls and
		 * jumps */

		if ((pso->fixtype&7) == FPOINTER)
		    pso->dsize += 2;

		emitOP (pso);
		break;
	case 1:
	case 6:
	case 9:
		pso->dsize = 1;
		emitOP (pso);
		break;
	case 3:
		break;
	case 4:
		/* Immediate mode */
		if (!pso->w || pso->dsize == 0)
		    pso->dsize = (pso->w ? wordsize : 1);

		emitOP (pso);
	}
}




/***	errorforward - generate error if forward reference on pass 2
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
errorforward (
	DSCREC *arg
){
	if (pass2)
		if (arg->dsckind.opnd.dflag == FORREF)
			errorc (E_IFR);
}




/***	errorimmed - generate error if immediate operand
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
errorimmed (
	DSCREC *dsc
){
	if (dsc->dsckind.opnd.mode == 4) {
		errorc (E_NIM);
		dsc->dsckind.opnd.mode = 2;
	}
}




/***	rangecheck - check for register number within range
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
rangecheck (
	USHORT *v,
	UCHAR	limit
){
	if (*v > limit) {
		if (limit <= 7)
			errorc (E_IRV);
		else
			errorc (E_VOR);
		*v = limit;
	}
}

VOID PASCAL CODESIZE
valuecheck(
	OFFSET *v,
	USHORT limit
){
	if (*v > limit) {
		if (limit <= 7)
			errorc (E_IRV);
		else
			errorc (E_VOR);
		*v = limit;
	}
}




/***	forceaccum - generate error if not register AX or AL
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
forceaccum (
	DSCREC *dsc
){
	if (dsc->dsckind.opnd.mode != 3 || dsc->dsckind.opnd.rm)
			errorc (E_AXL);
}




/***	errorsegreg - generate error if operand is segment register
 *
 *	errorsegreg (arg);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
errorsegreg (
	DSCREC *arg
){
	if (1 << REGRESULT & arg->dsckind.opnd.dtype)
		if (arg->dsckind.opnd.dsegment->symu.regsym.regtype == SEGREG)
			errorc (E_ISR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmopcod.h ===
/* asmopcod.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#define IMUL3		0x69	/* 3 argument integer multiply */
#define ARITHBASE	0xF6	/* base opcode for arithmetic opcodes */

/* base opcode for all instructions */

#define O_AAA		0x37
#define O_AAD		0xD5
#define O_AAM		0xD4
#define O_AAS		0x3F
#define O_ADC		0x10       /* ?????? */
#define O_ADD		0x00       /* ?????? */
#define O_AND		0x20       /* ?????? */
#define O_ARPL		0x63
#define O_BOUND		0x62
#define O_CALL		0xE8
#define O_CALLGATE	0xFF
#define O_CBW		0x98
#define O_CLC		0xF8
#define O_CLD		0xFC
#define O_CLI		0xFA
#define O_CLTS		0x0F
#define O_CMC		0xF5
#define O_CMP		0x38       /* ?????? */
#define O_CMPS		0xA6
#define O_CMPSB		0xA6
#define O_CMPSW		0xA7
#define O_CWD		0x99
#define O_DAA		0x27
#define O_DAS		0x2F
#define O_DEC		0x48       /* ?????? */
#define O_DIV		0xF6
#define O_ENTER		0xC8
#define O_ESC		0x36       /* not opcode */
#define O_HLT		0xF4
#define O_IDIV		0xF6
#define O_IMUL		0xF6
#define O_IN		0xE4
#define O_INC		0x40
#define O_INS		0x6C
#define O_INSB		0x6C
#define O_INSW		0x6D
#define O_INT		0xCC
#define O_INTO		0xCE
#define O_IRET		0xCF
#define O_JA		0x77
#define O_JAE		0x73
#define O_JB		0x72
#define O_JBE		0x76
#define O_JC		0x72
#define O_JCXZ		0xE3
#define O_JE		0x74
#define O_JG		0x7F
#define O_JGE		0x7D
#define O_JL		0x7C
#define O_JLE		0x7E
#define O_JMP		0xE9
#define O_JNA		0x76
#define O_JNAE		0x72
#define O_JNB		0x73
#define O_JNBE		0x77
#define O_JNC		0x73
#define O_JNE		0x75
#define O_JNG		0x7E
#define O_JNGE		0x7C
#define O_JNL		0x7D
#define O_JNLE		0x7F
#define O_JNO		0x71
#define O_JNP		0x7B
#define O_JNS		0x79
#define O_JNZ		0x75
#define O_JO		0x70
#define O_JP		0x7A
#define O_JPE		0x7A
#define O_JPO		0x7B
#define O_JS		0x78
#define O_JZ		0x74
#define O_LAHF		0x9F
#define O_LAR		0x0F
#define O_LDS		0xC5
#define O_LEA		0x8D
#define O_LES		0xC4
#define O_LEAVE		0xC9
#define O_LGDT		0x0F
#define O_LIDT		0x0F
#define O_LLDT		0x0F
#define O_LMSW		0x0F
#define O_LOCK		0xF0
#define O_LODS		0xAC
#define O_LODSB		0xAC
#define O_LODSW		0xAD
#define O_LOOP		0xE2
#define O_LOOPE		0xE1
#define O_LOOPNE	0xE0
#define O_LOOPNZ	0xE0
#define O_LOOPZ		0xE1
#define O_LSL		0x0F
#define O_LTR		0x0F
#define O_MOV		0xA2
#define O_MOVBOFF	0xA0
#define O_MOVBREA	0x88
#define O_MOVFSEG	0x8C
#define O_MOVTSEG	0x8E
#define O_MOVS		0xA4
#define O_MOVSB		0xA4
#define O_MOVSW		0xA5
#define O_MUL		0xF6
#define O_NEG		0xF6
#define O_NOP		0x90
#define O_NOT		0xF6
#define O_OR		0x08
#define O_OUT		0xE6
#define O_OUTS		0x6E
#define O_OUTSB		0x6E
#define O_OUTSW		0x6F
#define O_POP		0x58
#define O_POPA		0x61
#define O_POPF		0x9D
#define O_POPM		0x8F
#define O_PUSH		0x50
#define O_PUSHA		0x60
#define O_PUSHF		0x9C
#define O_PUSHM		0xFF
#define O_RCL		0xD0
#define O_RCR		0xD0
#define O_REP		0xF3
#define O_REPE		0xF3
#define O_REPNE		0xF2
#define O_REPNZ		0xF2
#define O_REPZ		0xF3
#define O_RET		0xC3
#define O_ROL		0xD0
#define O_ROR		0xD0
#define O_SAHF		0x9E
#define O_SAL		0xD0
#define O_SAR		0xD0
#define O_SBB		0x18
#define O_SCAS		0xAE
#define O_SCASB		0xAE
#define O_SCASW		0xAF
#define O_SGDT		0x0F
#define O_SHL		0xD0
#define O_SHR		0xD0
#define O_SIDT		0x0F
#define O_SLDT		0x0F
#define O_SMSW		0x0F
#define O_STC		0xF9
#define O_STD		0xFD
#define O_STI		0xFB
#define O_STOS		0xAA
#define O_STOSB		0xAA
#define O_STOSW		0xAB
#define O_STR		0x0F
#define O_SUB		0x28
#define O_TEST		0x84
#define O_VERR		0x0F
#define O_VERW		0x0F
#define O_WAIT		0x9B
#define O_XCHG		0x90
#define O_XCHGBREA	0x86
#define O_XCHGWRAX	0x90
#define O_XLAT		0xD7
#define O_XLATB		0xD7
#define O_XOR		0x30

#ifdef V386
#define O_MOVSX		0x0FBE
#define O_MOVZX		0x0FB6
#define O_CWDE		0x98
#define O_CDQ		0x99
#define O_LFS		0xB4
#define O_LGS		0xB5
#define O_LSS		0xB2
#define O_SHLD		0xA4
#define O_SHRD		0xAC
#define O_CMPSD		0xA7
#define O_INSD		0x6D
#define O_LODSD		0xAD
#define O_MOVSD		0xA5
#define O_OUTSD		0x6F
#define O_SCASD		0xAF
#define O_STOSD		0xAB
#define O_BSF		0x0F
#define O_BSR		0x0F
#define O_BT		0x0F
#define O_BTC		0x0F
#define O_BTR		0x0F
#define O_BTS		0x0F
#define O_IBTS		0x0F
#define O_XBTS		0x0F
#define O_JECXZ		0xE3
#define O_SETO		0x0F
#define O_SETNO		0x0F
#define O_SETB		0x0F
#define O_SETNAE	0x0F
#define O_SETNB		0x0F
#define O_SETAE		0x0F
#define O_SETE		0x0F
#define O_SETZ		0x0F
#define O_SETNE		0x0F
#define O_SETNZ		0x0F
#define O_SETBE		0x0F
#define O_SETNA		0x0F
#define O_SETNBE	0x0F
#define O_SETA		0x0F
#define O_SETS		0x0F
#define O_SETNS		0x0F
#define O_SETP		0x0F
#define O_SETPE		0x0F
#define O_SETNP		0x0F
#define O_SETPO		0x0F
#define O_SETL		0x0F
#define O_SETNGE	0x0F
#define O_SETC		0x0F
#define O_SETNC		0x0F
#define O_SETLE		0x0F
#define O_SETNG		0x0F
#define O_SETNL		0x0F
#define O_SETGE		0x0F
#define O_SETNLE	0x0F
#define O_SETG		0x0F
#define O_PUSHAD	0x60
#define O_POPAD		0x61
#define O_POPFD		0x9D
#define O_PUSHFD	0x9C
#define O_IRETD		0xCF
#endif

#define O_RETN		0xC3
#define O_RETF		0xCB

/* modrm bits for 8086/186/286/386 instructions  */

#define R_AAD		0x0A
#define R_AAM		0x0A
#define R_CLTS		0x06
#define R_DIV		0x06
#define R_IDIV		0x07
#define R_IMUL		0x05
#define R_LAR		0x02
#define R_LGDT		0x02
#define R_LIDT		0x03
#define R_LLDT		0x02
#define R_LMSW		0x06
#define R_LSL		0x03
#define R_LTR		0x03
#define R_MUL		0x04
#define R_NEG		0x03
#define R_NOT		0x02
#define R_RCL		0x02
#define R_RCR		0x03
#define R_ROL		0x00
#define R_ROR		0x01
#define R_SAL		0x04
#define R_SAR		0x07
#define R_SGDT		0x00
#define R_SHL		0x04
#define R_SHR		0x05
#define R_SIDT		0x01
#define R_SLDT		0x00
#define R_SMSW		0x04
#define R_STR		0x01
#define R_VERR		0x04
#define R_VERW		0x05
#define R_BT		0x04
#define R_BTC		0x07
#define R_BTR		0x06
#define R_BTS		0x05
#define R_SETO		0x90
#define R_SETNO		0x91
#define R_SETB		0x92
#define R_SETNAE	0x92
#define R_SETNB		0x93
#define R_SETAE		0x93
#define R_SETE		0x94
#define R_SETZ		0x94
#define R_SETNE		0x95
#define R_SETNZ		0x95
#define R_SETBE		0x96
#define R_SETNA		0x96
#define R_SETNBE	0x97
#define R_SETA		0x97
#define R_SETS		0x98
#define R_SETNS		0x99
#define R_SETP		0x9A
#define R_SETPE		0x9A
#define R_SETNP		0x9B
#define R_SETPO		0x9B
#define R_SETL		0x9C
#define R_SETNGE	0x9C
#define R_SETC		0x92
#define R_SETNC		0x93
#define R_SETLE		0x9E
#define R_SETNG		0x9E
#define R_SETNL		0x9D
#define R_SETGE		0x9D
#define R_SETNLE	0x9F
#define R_SETG		0x9F


/* 8087/287 instructions */

#define O_F2XM1		0xD9
#define O_FABS		0xD9
#define O_FADD		0xD8
#define O_FADDP		0xDE
#define O_FBLD		0xDF
#define O_FBSTP		0xDF
#define O_FCHS		0xD9
#define O_FCLEX		0xDB
#define O_FCOM		0xD8
#define O_FCOMP		0xD8
#define O_FCOMPP	0xDE
#define O_FDECSTP	0xD9
#define O_FDISI		0xDB
#define O_FDIV		0xD8
#define O_FDIVP		0xDE
#define O_FDIVR		0xD8
#define O_FDIVRP	0xDE
#define O_FENI		0xDB
#define O_FFREE		0xDD
#define O_FIADD		0xDA
#define O_FICOM		0xDA
#define O_FICOMP	0xDA
#define O_FIDIV		0xDA
#define O_FIDIVR	0xDA
#define O_FILD		0xDB
#define O_FIMUL		0xDA
#define O_FINCSTP	0xD9
#define O_FINIT		0xDB
#define O_FIST		0xDB
#define O_FISTP		0xDB
#define O_FISUB		0xDA
#define O_FISUBR	0xDA
#define O_FLD		0xD9
#define O_FLD1		0xD9
#define O_FLDCW		0xD9
#define O_FLDENV	0xD9
#define O_FLDL2E	0xD9
#define O_FLDL2T	0xD9
#define O_FLDLG2	0xD9
#define O_FLDLN2	0xD9
#define O_FLDPI		0xD9
#define O_FLDZ		0xD9
#define O_FMUL		0xD8
#define O_FMULP		0xDE
#define O_FNCLEX	0xDB
#define O_FNDISI	0xDB
#define O_FNENI		0xDB
#define O_FNINIT	0xDB
#define O_FNOP		0xD9
#define O_FNSAVE	0xDD
#define O_FNSTCW	0xD9
#define O_FNSTENV	0xD9
#define O_FNSTSW	0xDD
#define O_FPATAN	0xD9
#define O_FPREM		0xD9
#define O_FPTAN		0xD9
#define O_FRNDINT	0xD9
#define O_FRSTOR	0xDD
#define O_FSAVE		0xDD
#define O_FSCALE	0xD9
#define O_FSETPM	0xDB
#define O_FSQRT		0xD9
#define O_FST		0xD9
#define O_FSTCW		0xD9
#define O_FSTENV	0xD9
#define O_FSTP		0xD9
#define O_FSTSW		0xDD
#define O_FSTSWAX	0xDF
#define O_FSUB		0xD8
#define O_FSUBP		0xDE
#define O_FSUBR		0xD8
#define O_FSUBRP	0xDE
#define O_FTST		0xD9
#define O_FWAIT		0xD8
#define O_FXAM		0xD9
#define O_FXCH		0xD9
#define O_FXTRACT	0xD9
#define O_FYL2X		0xD9
#define O_FYL2XP1	0xD9
#define O_FNRSTOR	0xDD

#ifdef V386

#define O_FSIN		0xD9
#define O_FSINCOS	0xD9
#define O_FCOS		0xD9
#define O_FPREM1	0xD9
#define O_FUCOM 	0xDD
#define O_FUCOMP	0xDD
#define O_FUCOMPP	0xDA

#endif
/* 8087/287 modrm bits */

#define R_F2XM1		0xF0
#define R_FABS		0xE1
#define R_FADD		0x00
#define R_FADDP		0x00
#define R_FBLD		0x04
#define R_FBSTP		0x06
#define R_FCHS		0xE0
#define R_FCLEX		0xE2
#define R_FCOM		0x02
#define R_FCOMP		0x03
#define R_FCOMPP	0xD9
#define R_FDECSTP	0xF6
#define R_FDISI		0xE1
#define R_FDIV		0x06
#define R_FDIVP		0x07
#define R_FDIVR		0x07
#define R_FDIVRP	0x06
#define R_FENI		0xE0
#define R_FFREE		0x00
#define R_FIADD		0x00
#define R_FICOM		0x02
#define R_FICOMP	0x03
#define R_FIDIV		0x06
#define R_FIDIVR	0x07
#define R_FILD		0x00
#define R_FIMUL		0x01
#define R_FINCSTP	0xF7
#define R_FINIT		0xE3
#define R_FIST		0x02
#define R_FISTP		0x03
#define R_FISUB		0x04
#define R_FISUBR	0x05
#define R_FLD		0x00
#define R_FLD1		0xE8
#define R_FLDCW		0x05
#define R_FLDENV	0x04
#define R_FLDL2E	0xEA
#define R_FLDL2T	0xE9
#define R_FLDLG2	0xEC
#define R_FLDLN2	0xED
#define R_FLDPI		0xEB
#define R_FLDZ		0xEE
#define R_FMUL		0x01
#define R_FMULP		0x01
#define R_FNCLEX	0xE2
#define R_FNDISI	0xE1
#define R_FNENI		0xE0
#define R_FNINIT	0xE3
#define R_FNOP		0xD0
#define R_FNSAVE	0x06
#define R_FNSTCW	0x07
#define R_FNSTENV	0x06
#define R_FNSTSW	0x07
#define R_FPATAN	0xF3
#define R_FPREM		0xF8
#define R_FPTAN		0xF2
#define R_FRNDINT	0xFC
#define R_FRSTOR	0x04
#define R_FSAVE		0x06
#define R_FSCALE	0xFD
#define R_FSETPM	0xE4
#define R_FSQRT		0xFA
#define R_FST		0x02
#define R_FSTCW		0x07
#define R_FSTENV	0x06
#define R_FSTP		0x03
#define R_FSTSW		0x07
#define R_FSTSWAX	0x04	/* sleazy trick to make fltmodrm work */
#define R_FSUB		0x04
#define R_FSUBP		0x05
#define R_FSUBR		0x05
#define R_FSUBRP	0x04
#define R_FTST		0xE4
#define R_FWAIT		0x9B
#define R_FXAM		0xE5
#define R_FXCH		0x01
#define R_FXTRACT	0xF4
#define R_FYL2X		0xF1
#define R_FYL2XP1	0xF9
#define R_FNRSTOR	0x04

#ifdef V386

#define R_FPREM1	0xF5
#define R_FSIN		0xFE
#define R_FCOS		0xFF
#define R_FSINCOS	0xFB
#define R_FUCOM 	0x04
#define R_FUCOMP	0x05
#define R_FUCOMPP	0xE9

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmrec.c ===
/* asmrec.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"


struct recpars {
	SYMBOL FARSYM    *recptr;
	SYMBOL FARSYM    *curfld;
	OFFSET	recval;
};

struct recdef {
	USHORT	fldcnt;
	USHORT	reclen;
	SYMBOL FARSYM    *recptr;
	SYMBOL FARSYM    *curfld;
	short	i;
};

VOID  PASCAL CODESIZE  recordspec PARMS((struct recdef *));
VOID  PASCAL CODESIZE  recfill PARMS((struct recpars *));


static OFFSET svpc = 0;
static struct duprec FARSYM *pDUPCur;

/***	checkvalue - insure value will fit in field
 *
 *	checkvalue (width, sign, magnitude)
 *
 *	Entry	width = width of field
 *		sign = sign of result
 *		magnitude= magnitude of result
 *	Exit	none
 *	Returns adjusted value
 *	Calls	none
 */


OFFSET PASCAL CODESIZE
checkvalue (
	register SHORT width,
	register char sign,
	register OFFSET mag
){
	register OFFSET mask;

	if (width == sizeof(OFFSET)*8)
		mask = OFFSETMAX;
	else
		mask = (1 << width) - 1;
	if (!sign) {
		if (width < sizeof(OFFSET)*8)
			if (mag > mask) {
				errorc (E_VOR);
				mag = mask;
			}
	}
	else {
		mag = OFFSETMAX - mag;
		mag++;
		if (width < sizeof(OFFSET)*8)
			if ((mag ^ OFFSETMAX) & ~mask) {
				errorc (E_VOR);
				mag = mask;
			}
	}
	return (mag & mask);
}




/***	recordspec - parse record field specification fld:wid[=val]
 *
 *	recordspec (p);
 *
 *	Entry	p = pointer to record definition structure
 *	Exit
 *	Returns
 *	Calls
 */


VOID	 PASCAL CODESIZE
recordspec (
	register struct recdef	  *p
){
	register SYMBOL FARSYM	*fldptr;
	register USHORT  width;
	register struct symbrecf FARSYM *s;
	char	sign;
	OFFSET	mag;

	getatom ();
	if (*naim.pszName) {

	    if (!symFet ())
		    symcreate (M_DEFINED | M_BACKREF, RECFIELD);
	    else {
		    if (symptr->symu.rec.recptr != p->recptr ||
			M_BACKREF & symptr->attr)

			errorn (E_SMD);

		    symptr->attr |= M_BACKREF;
	    }
	    crefdef ();
	    s = &(symptr->symu.rec);
	    if (symptr->symkind != RECFIELD)
		    /* Not field */
		    errorn (E_SDK);
	    else {
		    /* Ptr to field */
		    fldptr = symptr;

		    if (!p->curfld)
			p->recptr->symu.rsmsym.rsmtype.rsmrec.reclist = fldptr;
		    else
			p->curfld->symu.rec.recnxt = fldptr;

		    /* New last field */
		    p->curfld = fldptr;
		    s->recptr = p->recptr;
		    s->recnxt = NULL;
		    p->fldcnt++;
		    if (NEXTC () != ':')
			    error (E_EXP,"colon");

		    /* Get field width */
		    width = (USHORT)exprconst ();

		    if (skipblanks () == '=') {
			    SKIPC ();
			    mag = exprsmag (&sign);
		    }
		    else {
			    sign = FALSE;
			    mag = 0;
		    }

		    if (width == 0 ||
			p->reclen + width > wordsize*8) {
			    STRNFCPY (save, p->curfld->nampnt->id);
			    /*Overflow */
			    error (E_VOR, save);
			    width = 0;
		    }

		    s->recinit = checkvalue (width, sign, mag);
		    s->recmsk = (OFFSET)((1L << width) - 1);
		    s->recwid = (char)width;
		    p->reclen += width;
	    }
	}
}




/***	recorddefine - parse record definition
 *
 *	recorddefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
recorddefine ()
{
	struct recdef	  a;
	struct symbrecf FARSYM *s;
	register SHORT cbRec;

	a.reclen = 0;
	a.fldcnt = 0;
	checkRes();
	if (!symFet ()) {
		/* Make record */
		symcreate (M_DEFINED | M_BACKREF, REC);
	}
	else
		symptr->attr |= M_BACKREF;

	/* This is def */
	crefdef ();
	if (symptr->symkind != REC)
		/* Wasn't record */
		errorn (E_SDK);
	else {
		/* Leftmost bit of record */
		a.reclen = 0;
		/*No record filed yet */
		a.curfld = NULL;
		/* In case error */
		symptr->symu.rsmsym.rsmtype.rsmrec.reclist = NULL;
		/* Pointer to record name */
		a.recptr = symptr;
		/* Parse record field list */
		BACKC ();
		do {
			SKIPC ();
			recordspec (&a);

		} while (skipblanks() == ',');

		/* Length of record in bits */
		cbRec = a.reclen;

		a.recptr->length = cbRec;
		a.recptr->offset = (OFFSET)((1L << cbRec) - 1);
		a.recptr->symtype = (cbRec > 16 )? 4: ((cbRec > 8)? 2: 1);
		/* # of fields in record */
		a.recptr->symu.rsmsym.rsmtype.rsmrec.recfldnum = (char)a.fldcnt;
		/* 1st field */
		a.curfld = a.recptr->symu.rsmsym.rsmtype.rsmrec.reclist;
	}

	/* For all the fields adjust the shift (stored in offset),
	 * initial value and mask so the last field is right justified */

	while (a.curfld) {

		s = &(a.curfld->symu.rec);

		/* Start of field */
		cbRec = (cbRec > s->recwid)? cbRec - s->recwid: 0;

		/* Shift count */
		a.curfld->offset = cbRec;
		s->recinit <<= cbRec;
		s->recmsk  <<= cbRec;

		a.curfld = s->recnxt;	/* Next field */
	}
}




/***	recfill - get initial value for field in list
 *
 *	recfill (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
recfill (
	register struct recpars	*p
){
	register char cc;
	struct symbrecf FARSYM *s;
	char	sign;
	OFFSET	mag, t;

	if (!p->curfld) {
		/* More fields than exist */
		errorc (E_MVD);
	}
	else {
		s = &(p->curfld->symu.rec);

		if ((cc = skipblanks ()) == ',' || cc == '>') {
			/* Use default value */
			t = s->recinit;
		}
		else {
			/* Have an override */
			mag = exprsmag (&sign);
			t = checkvalue (s->recwid, sign, mag);
			/* Scale value */
			t <<= p->curfld->offset;
		}
		/* Add in new field */

		if (s->recwid)
			p->recval = (p->recval & ~(s->recmsk)) | t;

		p->curfld = s->recnxt;
	}
}




/***	recordparse - parse record specification
 *
 *	recordparse ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


OFFSET	PASCAL CODESIZE
recordparse ()
{
	struct recpars	 a;
	struct symbrecf FARSYM *s;


	a.recptr = symptr;		/* Current record */

	if (PEEKC () != '<')
		error (E_EXP,"<");	/* Must have < */
	else
		SKIPC ();

	/* No value yet */
	a.recval = 0;
	/* 1st field in record */
	a.curfld = a.recptr->symu.rsmsym.rsmtype.rsmrec.reclist;

	BACKC ();
	do {			    /* Fill in values */
		SKIPC ();
		recfill (&a);

	} while (skipblanks () == ',');

	while (a.curfld) {
		/* Fill in remaining defaults */
		s = &(a.curfld->symu.rec);
		if (s->recwid)
			a.recval = (a.recval & ~(s->recmsk)) | s->recinit;
		a.curfld = s->recnxt;
	}
	if (NEXTC () != '>')	    /* Must have > */
		error (E_EXP,">");

	return (a.recval);	    /* Value of record */
}




/***	recordinit - parse record allocation
 *
 *	recordinit ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
recordinit ()
{
	initflag = TRUE;
	strucflag = FALSE;	/* This is RECORD init */
	recptr = symptr;

	optyp = TDB;

	if (symptr->symtype == 2)
		optyp = TDW;
#ifdef V386
	else if (symptr->symtype == 4)
		optyp = TDD;
#endif

	datadefine ();
	initflag = FALSE;
}




/***	nodecreate - create one DUP record
 *
 *	nodecreate ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
nodecreate ()
{
	register struct duprec FARSYM *node;

	node = (struct duprec FARSYM *)falloc (sizeof (*node), "nodecreate");
	node->rptcnt = 1;
	node->itemcnt = 0;
        node->duptype.dupnext.dup = NULL;
	node->itemlst = NULL;
	node->dupkind = NEST;
	return (node);
}




/***	strucdefine - define structure
 *
 *	strucdefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
strucdefine ()
{
	checkRes();
	if (!symFet()) {

		/* Make STRUC */
		symcreate (M_DEFINED | M_BACKREF, STRUC);
	}
	else
		symptr->attr |= M_BACKREF;

	/* This is definition */
	crefdef ();
	if (symptr->symkind != STRUC)
	    errorn (E_SDK);

	else {
	    symptr->attr |= M_BACKREF;
	    recptr = symptr;		/* Pointer to STRUC name */
	    recptr->symu.rsmsym.rsmtype.rsmstruc.strucfldnum = 0;

	    if (! pass2) {
		recptr->symu.rsmsym.rsmtype.rsmstruc.type = typeIndex;
		typeIndex += 3;

		if (pStrucCur)
		    pStrucCur->alpha = recptr;
		else
		    pStrucFirst = recptr;

		pStrucCur = recptr;
	    }

	    /* No labeled fields yet */
	    recptr->symu.rsmsym.rsmtype.rsmstruc.struclist = NULL;

	    /* Delete old STRUC */
	    scandup (recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody, oblitdup);
	    recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody = nodecreate ();

	    struclabel = NULL;	    /* No named fields */
	    strucprev = NULL;	    /* No body yet */
	    count = 0;		    /* No fields yet */
	    strucflag = TRUE;	    /* We are STRUC not RECORD */

	    svpc = pcoffset;	    /* Save normal PC */
	    pcoffset = 0;	    /* Relative to STRUC begin */

	    swaphandler = TRUE;     /* Switch to STRUC builder */
	    handler = HSTRUC;
	}
}




/***	strucbuild - build the struc block
 *
 *	strucbuild ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
strucbuild ()
{
	labelflag = FALSE;
	optyp = 0;
	getatom ();

#ifndef FEATURE

	if (naim.pszName[0] == '%' && naim.pszName[1] == 0) {  /* expand all text macros */
	    *begatom = ' ';
	    substituteTMs();
	    getatom();
	}

#endif

	/* First, look for IF, ELSE & ENDIF stuff */

	if (fndir () && (opkind & CONDBEG)) {
		firstDirect();
	}
	else if (generate && *naim.pszName) {

	    /* next, classify the current token, which is either
	     * and ENDS, data label or data name */

	    if (optyp == 0 || !fndir2 ()){

		/* first token was a label */

		switchname ();
		getatom ();
		optyp = 0;

		if (!fndir2 ())
		    errorc(E_DIS);

		labelflag = TRUE;   /* Do have label */
		switchname ();
	    }

	    if (optyp == TENDS) {

		if (!symFet () || symptr != recptr)
		    errorc(E_BNE);

		/* Have end of STRUC */

		handler = HPARSE;
		swaphandler = TRUE;
		strucflag = FALSE;
		recptr->symu.rsmsym.rsmtype.rsmstruc.strucfldnum =
			/* # of fields */
			recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->itemcnt;

		if (pcoffset & 0xFFFF0000)
		    errorc (E_DVZ);
		recptr->symtype = (USHORT)pcoffset;	/* Size of STRUC */
		recptr->length = 1;

		pcdisplay ();
		/* Restore PC */
		pcoffset = svpc;
	    }
	    else if (! (optyp >= TDB && optyp <= TDW))
		errorc (E_DIS);

	    else {	/* Have another line of body */

		if (!strucprev) {
		    /* Make first node */
		    strucprev = nodecreate ();
		    recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->
                            duptype.dupnext.dup = strucprev;
		}
		else {
			strucprev->itemlst = nodecreate ();
			strucprev = strucprev->itemlst;
		}
		recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->itemcnt++;
		/* Add new data line to STRUC */
		datadefine ();
		strucprev->decltype = optyp;
	    }
	}
	if (generate) {
	    if (!ISTERM (skipblanks()))
	       errorc (E_ECL);
	}
	listline ();
}

struct srec {
	struct duprec FARSYM  *curfld;
	USHORT	curlen;
};




/***	createduprec - create short data record with null data
 *
 *	createduprec ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
createduprec ()
{
	register struct duprec FARSYM *newrec;

	newrec = (struct duprec FARSYM	*)falloc (sizeof (*newrec), "createduprec");
	newrec->rptcnt = 1;
	/* Not a DUP */
	newrec->itemcnt = 0;
	newrec->itemlst = NULL;
	newrec->dupkind = ITEM;
	/* this also clears ddata and dup in other variants of struc */
	newrec->duptype.duplong.ldata = NULL;
	newrec->duptype.duplong.llen = 1;
	return (newrec);
}




/***	strucerror - generate structure error message
 *
 *	strucerror ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec  FARSYM * PASCAL CODESIZE
strucerror (
	SHORT	code,
	struct duprec	FARSYM *node
){
	errorc (code);
	/* Get rid of bad Oitem */
	oblitdup (node);
	/* Make up a dummy */
	return (createduprec ());
}




/***	strucfill - fill in structure values
 *
 *	strucfill ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	 PASCAL CODESIZE
strucfill ()
{
    register struct duprec  FARSYM *pOver;
    register struct duprec  FARSYM *pInit;
    register char *cp;
    char    svop;
    short   i, cbCur;
    struct datarec drT;


    if (!pDUPCur) {
	errorc (E_MVD);
	return;
    }

    if (skipblanks() == ',' || PEEKC() == '>') {
	/* use default values */
	pOver = createduprec ();
    }
    else {
	/* Save operation type */
	svop = optyp;
	/* Original directive type */
	optyp = pDUPCur->decltype;

	pOver = datascan (&drT);    /* Get item */

	optyp = svop;
        pInit = pDUPCur->duptype.dupnext.dup;
	cbCur = pInit->duptype.duplong.llen;

	if (pOver->dupkind == NEST)
	    /* Bad override val */
	    pOver = strucerror (E_ODI, pOver);

	else if (pDUPCur->itemcnt != 1 || pInit->itemcnt)
	    /* Can't override field */
	    pOver = strucerror (E_FCO, pOver);

	else if (pOver->dupkind != pInit->dupkind) {

	    if (pInit->dupkind == ITEM)
		cbCur = pInit->duptype.dupitem.ddata->dsckind.opnd.dsize;
	}

	if (pOver->dupkind == LONG) {
	    /* If too long, truncate */

	    if ((i = pOver->duptype.duplong.llen) < cbCur) {

		/* Space fill short (after reallocating more space) */

		if (!(pOver->duptype.duplong.ldata =
		  realloc (pOver->duptype.duplong.ldata, cbCur)))
		    memerror("strucfil");

		cp = pOver->duptype.duplong.ldata + i;

		for (; i < cbCur; i++)
		    *cp++ = ' ';
	    }
	    else if (pOver->duptype.duplong.llen > cbCur)
		errorc (E_OWL);

	    pOver->duptype.duplong.llen = (unsigned char)cbCur;
	}
	if ((pOver->dupkind == pInit->dupkind) &&
	    (pOver->dupkind == ITEM) && !errorcode)

	    pOver->duptype.dupitem.ddata->dsckind.opnd.dsize =
	      pInit->duptype.dupitem.ddata->dsckind.opnd.dsize;
    }
    pDUPCur = pDUPCur->itemlst;

    if (strucoveride)
	strclastover->itemlst = pOver;
    else
	strucoveride = pOver;

    strclastover = pOver;
}





/***	strucparse - parse structure specification
 *
 *	strucparse ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
strucparse ()
{
	/* No items yet */
	strucoveride = NULL;
	recptr = symptr;

	if (skipblanks () != '<')
		error (E_EXP,"<");

	/* 1st default field */
        pDUPCur = recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->duptype.dupnext.dup;
	initflag = FALSE;
	strucflag = FALSE;
				      /* Build list of overrides */
	do {
		SKIPC ();
		strucfill ();

	} while (skipblanks () == ',');

	initflag = TRUE;
	strucflag = TRUE;
	while (pDUPCur) {/* Fill rest with overrides */
	       /* Make dummy entry */
		strclastover->itemlst = createduprec ();
		strclastover = strclastover->itemlst;
		/* Advance to next field */
		pDUPCur = pDUPCur->itemlst;
	}
	if (PEEKC () != '>')
		error (E_EXP,">");
	else
		SKIPC ();
	return (recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody);
}




/***	strucinit - initialize structure
 *
 *	strucinit ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
strucinit ()
{
	initflag = TRUE;
	strucflag = TRUE;
	recptr = symptr;
	optyp = TMACRO;
	datadsize[TMACRO - TDB] = recptr->symtype;
	datadefine ();
	initflag = FALSE;
	strucflag = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmmsg2.h ===
/* messages for masm macro assembler */
/* Originally these messages were contained in a file called asmmsg.asm */
/* that was produced by the mkmsg build tool. However, because this is */
/* dead end code (will be replaced by MASM 6.0) and NT required the */
/* elimination of all assembly language it was hand converted to C and */
/* the build tool removed from the loop. (Jeff Spencer 10/30/90) */

struct Message MSG_tbl[] = {
        258,    "Internal error\n",
        261,    "%s(%hd): %s A%c%03hd: %s%s",
        263,    "Internal unknown error\n",
        265,    "End of file encountered on input file\n",
        266,    "Open segments",
        267,    "Open procedures",
        268,    "Number of open conditionals:",
        269,    "%s\nCopyright (C) Microsoft Corp 1981, 1989.  All rights reserved.\n\n",
        270,    "Unable to open cref file: %s\n",
        271,    "Write error on object file\n",
        272,    "Write error on listing file\n",
        273,    "Write error on cross-reference file\n",
        274,    "Unable to open input file: %s\n",
        275,    "Unable to access input file: %s\n",
        276,    "Unable to open listing file: %s\n",
        277,    "Unable to open object file: %s\n",
        278,    " Warning Errors",
        279,    " Severe  Errors",
        280,    "\n%7ld Source  Lines\n%7ld Total   Lines\n",
        281,    "%7hd Symbols\n",
        282,    "Bytes symbol space free\n",
        283,    "%s(%hd): Out of memory\n",
        284,    "Extra file name ignored\n",
        285,    "Line invalid, start again\n",
        287,    "Path expected after I option\n",
        288,    "Unknown case option: %c. Use /help for list\n",
        289,    "Unknown option: %c. Use /help for list of options\n",
        290,    "Read error on standard input\n",
        291,    "Out of memory\n",
        292,    "Expected source file\n",
        293,    "Warning level (0-2) expected after W option\n",
        0xFFFF, ""
};


struct Message FAR_MSG_tbl[] = {
        257,    "Block nesting error",
        258,    "Extra characters on line",
        259,    "Internal error - Register already defined",
        260,    "Unknown type specifier",
        261,    "Redefinition of symbol",
        262,    "Symbol is multidefined",
        263,    "Phase error between passes",
        264,    "Already had ELSE clause",
        265,    "Must be in conditional block",
        266,    "Symbol not defined",
        267,    "Syntax error",
        268,    "Type illegal in context",
        269,    "Group name must be unique",
        270,    "Must be declared during Pass 1",
        271,    "Illegal public declaration",
        272,    "Symbol already different kind",
        273,    "Reserved word used as symbol",
        274,    "Forward reference illegal",
        275,    "Operand must be register",
        276,    "Wrong type of register",
        277,    "Operand must be segment or group",
        279,    "Operand must be type specifier",
        280,    "Symbol already defined locally",
        281,    "Segment parameters are changed",
        282,    "Improper align/combine type",
        283,    "Reference to multidefined symbol",
        284,    "Operand expected",
        285,    "Operator expected",
        286,    "Division by 0 or overflow",
        287,    "Negative shift count",
        288,    "Operand types must match",
        289,    "Illegal use of external",
        291,    "Operand must be record or field name",
        292,    "Operand must have size",
        293,    "Extra NOP inserted",
        295,    "Left operand must have segment",
        296,    "One operand must be constant",
        297,    "Operands must be in same segment, or one constant",
        299,    "Constant expected",
        300,    "Operand must have segment",
        301,    "Must be associated with data",
        302,    "Must be associated with code",
        303,    "Multiple base registers",
        304,    "Multiple index registers",
        305,    "Must be index or base register",
        306,    "Illegal use of register",
        307,    "Value out of range",
        308,    "Operand not in current CS ASSUME segment",
        309,    "Improper operand type",
        310,    "Jump out of range by %ld byte(s)",
        312,    "Illegal register value",
        313,    "Immediate mode illegal",
        314,    "Illegal size for operand",
        315,    "Byte register illegal",
        316,    "Illegal use of CS register",
        317,    "Must be accumulator register",
        318,    "Improper use of segment register",
        319,    "Missing or unreachable CS",
        320,    "Operand combination illegal",
        321,    "Near JMP/CALL to different CS",
        322,    "Label cannot have segment override",
        323,    "Must have instruction after prefix",
        324,    "Cannot override ES for destination",
        325,    "Cannot address with segment register",
        326,    "Must be in segment block",
        327,    "Illegal combination with segment alignment",
        328,    "Forward needs override or FAR",
        329,    "Illegal value for DUP count",
        330,    "Symbol is already external",
        331,    "DUP nesting too deep",
        332,    "Illegal use of undefined operand (?)",
        333,    "Too many values for struc or record initialization",
        334,    "Angle brackets required around initialized list",
        335,    "Directive illegal in structure",
        336,    "Override with DUP illegal",
        337,    "Field cannot be overridden",
        340,    "Circular chain of EQU aliases",
        341,    "Cannot emulate coprocessor opcode",
        342,    "End of file, no END directive",
        343,    "Data emitted with no segment",
        344,    "Forced error - pass1",
        345,    "Forced error - pass2",
        346,    "Forced error",
        347,    "Forced error - expression equals 0",
        348,    "Forced error - expression not equal 0",
        349,    "Forced error - symbol not defined",
        350,    "Forced error - symbol defined",
        351,    "Forced error - string blank",
        352,    "Forced error - string not blank",
        353,    "Forced error - strings identical",
        354,    "Forced error - strings different",
        355,    "Wrong length for override value ",
        356,    "Line too long expanding symbol",
        357,    "Impure memory reference",
        358,    "Missing data; zero assumed",
        359,    "Segment near (or at) 64K limit",
        360,    "Cannot change processor in segment",
        361,    "Operand size does not match segment word size",
        362,    "Address size does not match segment word size",
        363,    "Jump within short distance",
        364,    "Align must be power of 2",
        365,    "Expected",
        366,    "Line too long",
        367,    "Non-digit in number",
        368,    "Empty string",
        369,    "Missing operand",
        370,    "Open parenthesis or bracket",
        371,    "Not in macro expansion",
        372,    "Unexpected end of line",
        373,    "Include file not found",
        374,    "missing parameters from an FPO directive",
        375,    "FPO directive declared outside the scope of a procedure, ignored",

/* help strings; leave some room for future error messages */
        401,    "a\t\tAlphabetize segments",
        402,    "c\t\tGenerate cross-reference",
        403,    "d\t\tGenerate pass 1 listing",
        404,    "D<sym>[=<val>] Define symbol",
        405,    "e\t\tEmulate floating point instructions and IEEE format",
        406,    "I<path>\tSearch directory for include files",
        407,    "l[a]\t\tGenerate listing, a-list all",
        408,    "M{lxu}\t\tPreserve case of labels: l-All, x-Globals, u-Uppercase Globals",
        409,    "n\t\tSuppress symbol tables in listing",
        410,    "p\t\tCheck for pure code",
        411,    "s\t\tOrder segments sequentially",
        412,    "t\t\tSuppress messages for successful assembly",
        413,    "v\t\tDisplay extra source statistics",
        414,    "w{012}\t\tSet warning level: 0-None, 1-Serious, 2-Advisory",
        415,    "X\t\tList false conditionals",
        416,    "z\t\tDisplay source line for each error message",
        417,    "Zi\t\tGenerate symbolic information for CodeView",
        418,    "Zd\t\tGenerate line-number information",

        430,    "Usage: masm /options source(.asm),[out(.obj)],[list(.lst)],[cref(.crf)][;]",
        431,    "Usage: masm -Switches sourceFile -o objFile",
        432,    "Run with -help for usage",
        0xFFFF, ""
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmsym.c ===
/* asmsym.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmtab.h"
#include "dos.h"
#include <ctype.h>

#define TSYMSIZE 451
#define FS_ALLOC 2000		       /* far symbol allocation size */

#define CB_CODELABEL 2
#define CB_PROCLABEL 12
#define CB_DATALABEL 5

SYMBOL FARSYM * FARSYM tsym[TSYMSIZE];
static char FARSYM *symaddr;
static SHORT symfree;
static DSCREC descT;

extern USHORT	 LedataOp;
extern OFFSET  ecuroffset;
extern SYMBOL FARSYM *pStrucFirst;

VOID PASCAL CODESIZE putWord(USHORT);
SHORT PASCAL CODESIZE cbNumericLeaf(long);
VOID PASCAL CODESIZE putNumericLeaf(long);

SHORT PASCAL	     dmpSymbols PARMS((SYMBOL FARSYM *));
SHORT PASCAL	     dumpTypes PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE putSymbol PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE putFixup PARMS((void));



/***	iskey - look for string in keyword table
 *
 *	iskey (str, table);
 *
 *	Entry	str = string to search for
 *		table = keyword table to search
 *	Exit
 *	Returns value defined in keyword table if string found
 *		NOTFOUND if string not found
 *	Calls
 */

#ifndef M8086OPT		    /* native coded */

USHORT CODESIZE
iskey (
	KEYWORDS FARSYM *table
){
	register KEYSYM FARSYM *p;
	register char *uc;
	register char *lc;
	register SHORT nhash;
	char mapstr[SYMMAX + 1];

	if (caseflag == CASEL) {
		nhash = 0;
		for (uc = mapstr, lc = naim.pszName; *lc; ) {
			nhash += *uc++ = MAP (*lc++);
		}
		*uc = 0;
		uc = mapstr;
	}
	else {
		nhash = naim.usHash;
		uc = naim.pszName;
	}
	for (p = (table->kt_table)[nhash % table->kt_size]; p; p = p->k_next)
		if ((nhash == p->k_hash) && (!STRFFCMP( p->k_name,uc)))
			return (p->k_token);
	return (NOTFOUND);
}

#endif	/* not M8086OPT */


/***	symsrch - search for symbol
 *
 *	flag = symsrch ();
 *
 *	Entry	naim = symbol to search for
 *
 *	Exit	*symptr = symbol if found
 *		*symptr = NULL if symbol not found
 *	Returns TRUE if symbol found
 *		FALSE if symbol not found
 */

#ifndef M8086OPT

char	CODESIZE
symsrch ()
{
	register SYMBOL FARSYM	    *p;

	if (naim.ucCount && (p = tsym[naim.usHash % TSYMSIZE])){
		do	{
			if (( naim.usHash == p->nampnt->hashval)
			    && !STRNFCMP (naim.pszName, p->nampnt->id)) {
				if( iProcCur ){  /* Check for nested names */
				    if( p->symkind == CLABEL ){
					if( p->symu.clabel.iProc && p->symu.clabel.iProc != iProcCur ){
					    continue;
					}
				    }else if( p->symkind == EQU ){
					if( p->symu.equ.iProc && p->symu.equ.iProc != iProcCur ){
					    continue;
					}
				    }
				}
				symptr = p;
				if( crefing == CREF_SINGLE ){
				    crefnew (REF);
				    crefout ();
				}
				return (TRUE);
			}
		} while (p = p->next);
	}
	return (FALSE);
}

#endif /* M8086OPT */

/***	symsearch - search for symbol
 *
 *	flag = symsearch (sym);
 *
 *	Entry	*sym = symbol to search for
 *	Exit	*symptr = symbol if found
 *		*symptr = NULL if symbol not found
 *	Returns TRUE if symbol found
 *		FALSE if symbol not found
 */


char	PASCAL CODESIZE
symsearch ()
{
	char rg[4], *naimSav;
	register SHORT i;
	register char ret;
	FASTNAME save;

	ret = FALSE;
	if (*naim.pszName)
	    if (!(ret = symsrch ()))
		if (caseflag == CASEL && (i = naim.ucCount) <= 3) {

			// Save the name
			memcpy( &save, &naim, sizeof( FASTNAME ) );

			// Rebuild it in upper case
			naim.pszName = rg;
			*naim.pszName = '\0';
			naim.usHash = 0;
			for( ; i >= 0; i--){
			    naim.usHash += naim.pszName[i] = MAP (save.pszName[i]);
			}

			// Search for the upper cased name
			ret = symsrch ();

			// Restore the name
			memcpy( &naim, &save, sizeof( FASTNAME ) );
		}
	return (ret);
}



/***	syFet - symbol Fetch with text macro subsitution
 *
 *	flag =	syFet();
 *
 *	Entry	naim.pszName - atom to fetch
 *	Exit	*symptr = symbol if found
 *		*symptr = NULL if symbol not found
 *	Returns TRUE if symbol found
 *		FALSE if symbol not found
 */


char	PASCAL CODESIZE
symFet ()
{
	register char ret;
	char *lbufSav;

	ret = symsrch();

	if (ret &&
	    symptr->symkind == EQU &&
	    symptr->symu.equ.equtyp == TEXTMACRO){

	    /* look up the name indirect */

	    lbufSav = lbufp;
	    lbufp = symptr->symu.equ.equrec.txtmacro.equtext;
	    getatom();

	    lbufp = lbufSav;

	    ret = symsrch();
	}
	return(ret);
}

char PASCAL CODESIZE
symFetNoXref()
{
    SHORT ret;

    xcreflag--;
    ret = symFet();
    xcreflag++;
    return((char)ret);
}



/***	createname - create idtext structure for name
 *
 *	ptr = createname (sym);
 *
 *	Entry	*sym = name to create entry for
 *	Exit	none
 *	Returns address of idtext structure
 *	Calls	malloc, strcpy
 */

NAME FAR * PASCAL CODESIZE
createname (
	register char *sym
){
	register NAME FAR *ptr;
	register UINT i;
	register UINT len;

	len = strlen (sym );
	i = len + sizeof( NAME ) - sizeof( ptr->id );
	ptr = (NAME FAR *)falloc ((USHORT)i, "createname");
	ptr->hashval = 0;
	fMemcpy (ptr->id, sym, len + 1 );
	return (ptr);
}


#ifdef M8086

/***	creatlname - create idtext structure for name
 *
 *	ptr = creatlname (sym);
 *
 *	Entry	*sym = name to create entry for
 *	Exit	none
 *	Returns address of idtext structure
 *	Calls	malloc, strcpy
 */

NAME *	PASCAL CODESIZE
creatlname (
	register char *sym
){
	NAME *ptr;
	register UINT i;

	i = naim.ucCount + sizeof( NAME ) - sizeof( ptr->id );
	ptr = (NAME *)nalloc ( (USHORT)i, "creatlname");

	memcpy (ptr->id, sym, naim.ucCount + 1 );
	return (ptr);
}
#endif


/***	symcreate - create new symbol node
 *
 *	symcreate (symbol, sattr, skind);
 *
 *	Entry	symbol = symbol name
 *		sattr = symbol attribute
 *		skind = symbol kind
 *	Exit	symptr = pointer to symbol
 *		symbolcnt incremented
 *	Returns none
 *	Calls	createname
 */

/* Map of Symbol types to additional allocation needed past common header */

UCHAR mpcbSY [] = {

    sizeof (struct symbseg),	    /* SEGMENT */
    sizeof (struct symbgrp),	    /* GROUP */
    sizeof (struct symbclabel),     /* CLABEL */
    sizeof (struct symbproc),	    /* PROC */
    sizeof (struct symbrsm),	    /* REC */
    sizeof (struct symbrsm),	    /* STRUC */
    sizeof (struct symbequ),	    /* EQU */
    sizeof (struct symbext),	    /* DVAR */
    sizeof (struct symbext),	    /* CLASS*/
    sizeof (struct symbrecf),	    /* RECFIELD */
    sizeof (struct symbstrucf),     /* STRUCFIELD */
    sizeof (struct symbrsm),	    /* MACRO */
    sizeof (struct symbreg)	    /* REGISTER */
};

VOID	PASCAL CODESIZE
symcreate (
	UCHAR	sattr,
	char	skind
){
	register USHORT cb;
	register SYMBOL FARSYM *p;
	register USHORT cbName, pT;
	register USHORT cbStruct;

       /* Create new symbol entry */

       cbName = naim.ucCount + sizeof (char) + sizeof (USHORT);
       cbStruct = (SHORT)(&(((SYMBOL FARSYM *)0)->symu)) + mpcbSY[skind];
       // Make sure NAME struct starts on double word boundry (required for MIPS)
       cbStruct = (cbStruct + 3) & ~3;
       cb = cbStruct + cbName;
       // Do suballocations on double word boundries, so promote length to a
       // multiple of 4.
       cb = (cb + 3) & ~3;

       if (!symaddr || (cb > symfree)) {
#ifdef FS
		symaddr = falloc (FS_ALLOC, "symcreate-EXPR");
#else
		symaddr = nalloc (FS_ALLOC, "symcreate-EXPR");
#endif
		symfree = FS_ALLOC;

#if !defined FLATMODEL
		/* Uses knowledge of fMemcpy to initialize memory by */
		/* Repeatedly copying zero to the next word in the buf */
		*((SHORT FARSYM *)symaddr) = NULL;
		fMemcpy(((char FAR *)symaddr)+2, symaddr, FS_ALLOC-2);
#else
		/* Since in small model memset is available use it */
		memset( symaddr, 0, FS_ALLOC );
#endif

	}

	p = (SYMBOL FARSYM *)symaddr;
	symaddr += cb;
	symfree -= cb;
	symbolcnt++;

	/* clear out default values and fill in givens */

	p->attr = sattr;
	p->symkind = skind;

	if (skind == EQU)
	    p->symu.equ.equtyp = equsel;

	/* Now create record for name of symbol and link in */
	p->nampnt = (NAME FAR *)((char FAR *)p + cbStruct); // Name follows fixed structures and padding
	fMemcpy (p->nampnt->id, naim.pszName, (USHORT)(naim.ucCount + 1));
	p->nampnt->hashval = naim.usHash;
	cb = naim.usHash % TSYMSIZE;

	p->next = tsym[cb];
	tsym[cb] = symptr = p;
}



/***	muldef - set multidefined bit and output error
 *
 *	muldef ();
 *
 *	Entry	*symptr = symbol which is multiply defined
 *	Exit	MULTDEFINED set in symptr->attr
 *	Returns none
 *	Calls	error
 *
 *	Two bits keep track of multiple definitions:
 *	    MULTDEFINED: is remembered between pass one & two
 *	    BACKREF:	 set by defining function, unset by uses that are
 *			 forward references.  Reset at end of pass 1.
 *
 *	When a symbol is defined, it should:
 *	    - check that BACKREF is off, if not call muldef which
 *	      sets MULTIDEFINED, causes an error in pass 1 & 2
 *	      This causes error on 2nd and on defines
 *
 *	    - if not BACKREF then check for MULTDEFINED,
 *	      error message in pass 2 only.
 *	      This in effect prints an error for the first definer only
 *
 *	    - set BACKREF to indicate symbol defined
 */


VOID	PASCAL CODESIZE
muldef ()
{
	symptr->attr |= (M_MULTDEFINED);
	errorc (E_RSY);
}




/***	labelcreate - create label
 *
 *	labelcreate (labelsize, labelkind);
 *
 *	Entry	labelsize = size of label
 *		labelkind = kind of label
 *	Exit
 *	Returns
 *	Calls
 *	Note	This routine makes symbol table entry and checks for
 *		  *  Multiple definitions
 *		  *  Phase error (value different between passes)
 */


VOID	PASCAL CODESIZE
labelcreate (
	USHORT	labelsize,
	char	labelkind
){
	char	newsym;
	register SYMBOL FARSYM *p, FARSYM *pCS;

	newsym = TRUE;

	checkRes();
	xcreflag--;

	if (! ((labelkind == EQU)? symsrch (): symFet())){
		symcreate (M_DEFINED, labelkind);
	}
	else if (M_DEFINED & symptr->attr)
		newsym = FALSE;

	xcreflag++;
	p = symptr;
	equdef = !newsym;

	if (newsym) {
	    p->offset = pcoffset;
	    p->symsegptr = pcsegment;
	}

	if ((p->attr&~M_CDECL) == M_GLOBAL)	/* forward referenced global */

	    if (1 << labelkind & (M_PROC | M_DVAR | M_CLABEL | M_EQU)){
		p->symkind = labelkind;

	       if (labelkind == EQU)
		   p->symu.equ.equtyp = equsel;
	    }
	    else
		errorn (E_SDK);

	p->attr |= M_DEFINED;
	p->symtype = labelsize;
	p->length = 1;

	/* Check to see if there would be any error in label */

	if ((p->symkind != labelkind) || (M_XTERN & p->attr))
		errorn (E_SDK);

	else if ((M_BACKREF & p->attr) && (p->symkind != EQU))
		muldef ();

	else if (M_MULTDEFINED & p->attr)
		errorn (E_SMD);

	else if (M_DEFINED & p->attr)
		if (!(1 << labelkind & (M_EQU | M_STRUCFIELD)) &&
		    (p->offset != pcoffset)) {
			errorc (E_PHE);
			if (errorcode == E_PHE)
				pcoffset = p->offset;
		}
		else {
			p->attr |=  M_DEFINED | M_BACKREF;
			if ((labelkind != EQU) && emittext)
				pcdisplay ();
		}

	if ((labelkind == p->symkind) &&
	    !((1 << labelkind) & (M_EQU | M_STRUCFIELD))) {

	    if (isCodeLabel(p)) {

		pCS = regsegment[CSSEG];

#ifndef FEATURE
		/* ASSUME CS:FLAT gets assume of current segment */

		if (pCS == pFlatGroup)
		    pCS = pcsegment;
#endif
	    }
	    else
		pCS = regsegment[DSSEG];

	    /* CS context for label */
	    if (!newsym && pCS != p->symu.clabel.csassume)
		errorc(E_SPC);

	    p->symu.clabel.csassume = pCS;

	    if (labelsize == CSNEAR)

	      /* This is code label */
	      if (!pCS)
		      /* No CS assume, can't define */
		      errorc (E_NCS);
	      else
	      if ((pcsegment != pCS) &&
		  ((pCS->symkind != GROUP) ||
		   (pcsegment->symu.segmnt.grouptr != pCS)))

		      /* Not same segment or CS not seg's grp */
			      errorc (E_NCS);
	}
	crefdef ();
}




/***	switchname - switch atom and length between svname and name
 *
 *	switchname ();
 *
 *	Entry	none
 *	Exit	svname and name switched
 *		naim.usHash and svname.usHash switched
 *		svlcname and lcname switched
 *	Returns none
 *	Calls	none
 */

#ifndef M8086OPT
VOID CODESIZE
switchname ()
{
	FASTNAME tmpName;

	register char *pNameTmp;

	/* Swap naim and svname (str ptrs, hash values and lengths) */
	memcpy( &tmpName, &naim, sizeof( FASTNAME ) );
	memcpy( &naim, &svname, sizeof( FASTNAME ) );
	memcpy( &svname, &tmpName, sizeof( FASTNAME ) );
}
#endif

#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, scansymbols)
#endif

/***	scansymbols - scan symbol in alpha order and execute function
 *
 *	scansymbols (item);
 *
 *	Entry	item = pointer to function to execute
 *	Exit
 *	Returns
 *	Calls
 */

VOID	PASCAL
scansymbols (
	SHORT	(PASCAL *item) (SYMBOL FARSYM *)
){
	register USHORT  i;

	for (i = 0; i < TSYMSIZE; i++)
		scanorder (tsym[i], item);
}


#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, sortalpha)
#endif

/***	sortalpha - sort symbol into alpha ordered list
 *
 *	sortalpha (p);
 *
 *	Entry	*p = symbol entry
 *	Exit	symbol sorted into proper alpha list
 *	Returns none
 *	Calls	none
 */


SHORT	PASCAL
sortalpha (
	register SYMBOL FARSYM *p
){
	register SYMBOL FARSYM  *tseg;
	register SYMBOL FARSYM * FARSYM *lseg;
	char i;
	char c;

	if (p->symkind == MACRO) {
		tseg = macroroot;
		lseg = &macroroot;
	}
	else if ((p->symkind == STRUC) || (p->symkind == REC)) {
		tseg = strucroot;
		lseg = &strucroot;
	}
	else {
		c = MAP (*(p->nampnt->id));
		i = (isalpha (c))? c - 'A': 'Z' - 'A' + 1;
		tseg = symroot[i];
		lseg = &symroot[i];
	}


	/* Add symbol to list */
	for (; tseg; lseg = &(tseg->alpha), tseg = tseg->alpha) {
	    if (STRFFCMP (p->nampnt->id, tseg->nampnt->id) < 0)
		break;
	}

	*lseg = p;
	p->alpha = tseg;
    return 0;
}


/***	typeFet - Fetch the type of the symbol
 *
 *	Entry	symtype - the size of the symbol
 *	Exit	prefined symbol type
 */

UCHAR mpSizeType[] = {

    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz1),	    /* db */
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz2),	    /* dw */
    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz4),	    /* dd */
    0,
    makeType(BT_UNSIGNED, BT_FARP, BT_sz4),	    /* df */
    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz2),	    /* dq */
    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz4)	    /* dt */
};

UCHAR mpRealType[] = {

    0, 0, 0, 0,
    makeType(BT_REAL, BT_DIRECT, BT_sz1),	    /* dd */
    0, 0, 0,
    makeType(BT_REAL, BT_DIRECT, BT_sz2),	    /* dq */
    0,
    makeType(BT_REAL, BT_DIRECT, BT_sz4)	    /* dt */
};

SHORT PASCAL CODESIZE
typeFet (
	USHORT symtype
){
    if (symtype <= 10)

	return(mpSizeType[symtype]);

    else if (symtype == CSNEAR)
	return(512);

    else if (symtype == CSFAR)
	return(513);

    else
	return(0);
}


char symDefine[] = "$$SYMBOLS segment 'DEBSYM'";
char typeDefine[] = "$$TYPES segment 'DEBTYP'";
char fProcs;

/***	dumpCodeview - dump out codeview symbolic info to the obj file
 *
 *	Entry	end of pass one and two
 *	Exit	pass one just computes the segment sizes
 *		and pass two writes the symbols
 */


static SYMBOL FAR *plastSeg;	    // indicates segIndex of last ChangeSegment

VOID PASCAL
dumpCodeview ()
{
    char svlistflag;
    char svloption;

    if (codeview != CVSYMBOLS || !emittext)
	return;

    plastSeg = NULL;
    svlistflag = listflag;
    svloption = loption;
    listflag = FALSE;
    loption = FALSE;
    fProcs = FALSE;

    wordszdefault = 2;	    /* this will vary when CV can do 32 bit segments */

    doLine(symDefine);
    pcsegment->attr |= M_NOCREF; pcsegment->symu.segmnt.classptr->attr |= M_NOCREF;

    scansymbols(dmpSymbols);

    fProcs++;
    scanSorted(pProcFirst, dmpSymbols);
    endCurSeg();

    doLine(typeDefine);
    pcsegment->attr |= M_NOCREF; pcsegment->symu.segmnt.classptr->attr |= M_NOCREF;

    /* First output two types, one for near & far code labels
     * Format
     *	    [1][cb][0x72][0x80][0x74|0x73 (near/far)] */

    if (pass2) {

	putWord(3 << 8 | 1);
	putWord(0x72 << 8);
	putWord(0x74 << 8 | 0x80);

	putWord(3 << 8 | 1);
	putWord(0x72 << 8);
	putWord(0x73 << 8 | 0x80);
    }
    else
	pcoffset = 12;

    scanSorted(pStrucFirst, dumpTypes);

    endCurSeg();

    listflag = svlistflag;
    loption = svloption;
}



/*** dmpSymbols - create the codeview symbol segment
 *
 *	Entry
 *	Exit
 */


static fInProc;

SHORT PASCAL
dmpSymbols(
	SYMBOL FARSYM *pSY
){
    SHORT cbName, cbRecord;
    char fProcParms;
    UCHAR f386; 		    // will be 0 or 0x80 for OR'ing into rectype

    fProcParms = 0xB;

    if (pSY->symkind == PROC) {
	if ( pSY->symu.plabel.pArgs){

	    if (!fProcs)
		return 0;

	    fProcParms = 1;
	}
	else if (pSY->attr & (M_GLOBAL | M_XTERN))
	    return 0;
    }
    else if (pSY->symkind == CLABEL) {

	if (!fInProc && (pSY->symu.clabel.iProc ||
			 pSY->attr & (M_GLOBAL | M_XTERN)))

	    return 0;

    }
    else
	return 0;

    f386 = (pSY->symsegptr->symu.segmnt.use32 == 4? 0x80 : 0);

    cbName = STRFLEN(pSY->nampnt->id) + 1 + (pSY->attr & M_CDECL);
    cbRecord = cbName + (f386? 4: 2) +
	       ((isCodeLabel(pSY))?
		((fProcParms == 1)? CB_PROCLABEL: CB_CODELABEL):
		CB_DATALABEL);

    if (isCodeLabel(pSY)
      && (plastSeg != pSY->symsegptr)) {

	plastSeg = pSY->symsegptr;

	putWord(0x11 << 8 | 5);

	descT.dsckind.opnd.doffset = 0;
	descT.dsckind.opnd.dtype = FORTYPE;
	descT.dsckind.opnd.dsegment = pSY->symsegptr;
	descT.dsckind.opnd.dsize = 2;
	descT.dsckind.opnd.fixtype = FBASESEG;
	descT.dsckind.opnd.dcontext = pSY->symsegptr;
	putFixup();

	putWord(0);	// 2 bytes reserved
    }

    descT.dsckind.opnd.doffset = pSY->offset;
    descT.dsckind.opnd.dtype = FORTYPE;
    descT.dsckind.opnd.dsegment = pSY->symsegptr;
    descT.dsckind.opnd.dsize = f386? 4: 2;

    emitopcode((UCHAR)cbRecord);

    if (isCodeLabel(pSY)) {

	/* do the actual outputting for code labels
	 * FORMAT:
	 *
	 *   [cb][0xB][offset][0/4][name]
	 *
	 *  For Proc labels with parms
	 *
	 *   [cb][0x1][offset][typeIndex][cbProc][startRelOff][endRelOff]
	 *	 [0][0/4][name]
	 */

       emitopcode((UCHAR)(fProcParms | f386));	   /* contains 0xb or 1 */

      /* reserve two bytes and then a fixup to get
       * the code labe offset */

       descT.dsckind.opnd.fixtype = f386? F32OFFSET: FOFFSET;
       descT.dsckind.opnd.dcontext = pSY->symu.clabel.csassume;

       putFixup();

       if (fProcParms == 1) {
				/* type index */
	   putWord(0);
	   putWord(pSY->symu.plabel.proclen);

	   /* starting & ending offset of proc */

	   putWord(0);
	   putWord(pSY->symu.plabel.proclen);

	   putWord(0);		 /* reservered to 0 */

       }
       emitopcode((UCHAR)((pSY->symtype == CSNEAR)? 0: 4));

    }
    else {

	/* do the actual outputting for data labels
	 * FORMAT:
	 *	   [cb][0x5][offset:seg][typeIndex][name]   */

	emitopcode((UCHAR)(0x5|f386));

	/* reserve four bytes and then a fixup to get
	 * the data far address */

	descT.dsckind.opnd.fixtype = f386? F32POINTER: FPOINTER;
	descT.dsckind.opnd.dsize += 2;
	descT.dsckind.opnd.dcontext = NULL;

	putFixup();

	putWord(pSY->symu.clabel.type);
    }

    putSymbol(pSY);

    if (fProcParms == 1) {

	/* Go through the chain of text macro parmeters and output
	 * the BP relative local symbols.
	 *
	 * Format:
	 *	  [cb][4][offset][typeIndex][name]
	 *	  ...
	 *	  [1][2]  - end block
	 */

	for (pSY = pSY->symu.plabel.pArgs; pSY; pSY = pSY->alpha){

	    if (pSY->symkind == CLABEL) {

		/* a locally nest label in a procedure */

		fInProc++;
		dmpSymbols(pSY);
		fInProc--;
	    }
	    else {

		cbName = STRFLEN(pSY->nampnt->id) + 1;

		emitopcode((UCHAR)((f386? 7:5) + cbName));   /* cbRecord */
		emitopcode((UCHAR)(4 | f386));		     /* recType */

		if (f386) {
		    putWord((USHORT) pSY->offset);
		    putWord(*((USHORT FAR *)&(pSY->offset)+1));
		} else
		    putWord((USHORT) pSY->offset);

		putWord(pSY->symu.equ.equrec.txtmacro.type);
		putSymbol(pSY);
	    }
	}

	putWord(2 << 8 | 1);		/* end block record */
    }

    return 0;
}


/***	dumpTypes - creats a type definition in the codeview type segment
 *
 *	Entry	Symbol table pointer to structure or record
 *	Exit
 */

SHORT PASCAL
dumpTypes(
	SYMBOL FARSYM *pSY
){
    SHORT cType, cbType, cbNlist, cbName;
    SYMBOL FARSYM *pSYField;

    /* Scan through the struct field to compute tlist size */

    pSYField = pSY->symu.rsmsym.rsmtype.rsmstruc.struclist;
    cbNlist = 1;
    cType = 0;

    if (pSY->symkind == STRUC) {

	while (pSYField) {

	    cbNlist += STRFLEN(pSYField->nampnt->id) + 2 +
		       cbNumericLeaf(pSYField->offset);
	    pSYField = pSYField->symu.struk.strucnxt;
	    cType++;
	}

	cbName = (SHORT) STRFLEN(pSY->nampnt->id);

	cbType = 10 +
		 cbNumericLeaf(((long) pSY->symtype) * 8) +
		 cbNumericLeaf((long) cType) +
		 cbName;

    }
    else
	cbType = -3;

    /* A type has the following format
     *
     *	    [1][cbType][0x79][cbTypeInBits][cFields][tListIndex][nListIndex]
     *	       [0x82][structureName][0x68]
     *
     *	       tList
     *	       nList
     */

    if (pass2) {

	emitopcode(1);

	if (pSY->symkind == STRUC) {

	    putWord(cbType);
	    emitopcode(0x79);

	    putNumericLeaf(((long) pSY->symtype) * 8);
	    putNumericLeaf((long) pSY->symu.rsmsym.rsmtype.rsmstruc.strucfldnum);

	    emitopcode(0x83);	    /* tList Index */
	    putWord((USHORT)(pSY->symu.rsmsym.rsmtype.rsmstruc.type+1));

	    emitopcode(0x83);	    /* nList Index */
	    putWord((USHORT)(pSY->symu.rsmsym.rsmtype.rsmstruc.type+2));

	    emitopcode(0x82);
	    putSymbol(pSY);

	    emitopcode(0x68);	    /* packed structure */

	    /* next comes the tList (type index array), it has the following format
	     *
	     *	[1][cb][0x7f] ([0x83][basicTypeIndex])..repeated..
	     */

	    emitopcode(1);
	    putWord((USHORT)(cType * (USHORT)3 + (USHORT)1));
	    emitopcode(0x7f);

	    pSYField = pSY->symu.rsmsym.rsmtype.rsmstruc.struclist;

	    while(pSYField){

		emitopcode(0x83);
		putWord(pSYField->symu.struk.type);

		pSYField = pSYField->symu.struk.strucnxt;
	    }

	    /* next comes the nList (field names), it has the following format
	     *
	     *	[1][cb][0x7f] ([0x82][cbName][fieldName][offset])..repeated..
	     */

	    emitopcode(1);
	    putWord(cbNlist);
	    emitopcode(0x7f);

	    pSYField = pSY->symu.rsmsym.rsmtype.rsmstruc.struclist;

	    while(pSYField){

		emitopcode(0x82);

		putSymbol(pSYField);
		putNumericLeaf(pSYField->offset);

		pSYField = pSYField->symu.struk.strucnxt;
	    }
	}
	else {

	    /* a pointer to type has the following format
	     *
	     * [1][5][0x7f] [near/far][0x83][typeIndex]
	     */

	    putWord(5);
	    emitopcode(0x7A);
	    emitopcode((UCHAR)((pSY->attr)? 0x73: 0x74));

	    emitopcode(0x83);
	    putWord(pSY->symtype);
	}
    }
    else
	pcoffset += cbType +
		    cType * 3 +
		    cbNlist + 10;

    return 0;
}

/*** cbNumericLeaf - compute the size for a numeric leaf
 *
 *	Entry long value to output
 *	Exit  size of leaf
 */

SHORT PASCAL CODESIZE
cbNumericLeaf(
	long aLong
){
    if (aLong & 0xFFFF0000)
	return(5);

    else if (aLong & 0xFF80)
	return(3);

    else
	return(1);
}


/*** putNumericLeaf - output variable size numeric codeview leaf
 *
 *	Entry long value to output
 *	Exit  numeric leaf on OMF
 */

VOID PASCAL CODESIZE
putNumericLeaf(
	long aLong
){
    if (aLong & 0xFFFF0000){

	emitopcode(0x86);
	putWord((USHORT)aLong);
	putWord(*((USHORT *)&aLong+1));
    }
    else if (aLong & 0xFF80){

	emitopcode(0x85);
	putWord((USHORT)aLong);
    }

    else
	emitopcode((UCHAR)aLong);
}



/*** doLine - feed a text line to parse for processing
 *
 *	Entry pointer to text string
 *	Exit  processed line
 */

VOID PASCAL CODESIZE
doLine(
	char *pText
){

    USHORT cvSave;

    fCrefline = FALSE;

#ifdef BCBOPT
    if (fNotStored)
	storelinepb ();
#endif

    if (fNeedList) {

	listline();		/* list out current line */

	strcpy(linebuffer, pText);
	fSkipList++;
    }

    lbufp = strcpy(lbuf, pText);
    linebp = lbufp + strlen(lbufp);
    cvSave = codeview;
    codeview = 0;

    if (loption || expandflag == LIST)
	fSkipList = FALSE;

    parse();

    codeview = cvSave;
    fSkipList++;
    fCrefline++;
}

/*** putWord - output a 2 byte word to the current segment
 *
 *	Entry word to output
 *	Exit  increment pcoffset
 */

VOID PASCAL CODESIZE
putWord(
	USHORT aWord
){
    if (pass2)
	emitcword((OFFSET) aWord);

    pcoffset += 2;
}


/*** putSymbol - put out the name of a symbol
 *
 *	Entry word to output
 *	Exit  increment pcoffset
 */

VOID PASCAL CODESIZE
putSymbol(
	SYMBOL FARSYM *pSY
){
    SHORT cbName;

    cbName = STRFLEN(pSY->nampnt->id) + 1 + (pSY->attr & M_CDECL);

    if (pass2){

	if (emitcleanq ((UCHAR)cbName))
	    emitdumpdata ((UCHAR)LedataOp);

	emitSymbol(pSY);
    }

    pcoffset += cbName;
    ecuroffset = pcoffset;
}

/*** putFixup - put out a fixup
 *
 *	Entry golbal descT
 *	Exit  increment pcoffset
 */

VOID PASCAL CODESIZE
putFixup()
{
extern UCHAR  fNoMap;

    fNoMap++;

    if (pass2)
	   emitobject(&descT.dsckind.opnd);

    fNoMap--;
    pcoffset += descT.dsckind.opnd.dsize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmpars.c ===
/* asmpars.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"

extern void closefile(void);

static  char parsedflag;
char    fNeedList;
static  char iod[] = "instruction, directive, or label";
char    cputext[22] = "@Cpu=";
char    tempText[32];
USHORT  coprocproc;

/* an array of pointers to the function parsers */

VOID (PASCAL CODESIZE * rgpHandler[])(void) = {

    parse,
    macrobuild,
    irpxbuild,
    commentbuild,
    strucbuild
};

/***    dopass - initialize and execute pass
 *
 *      dopass ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL
dopass ()
{

        /* Common pass initialize */

        cputype = DEF_CPU;
        X87type = DEF_X87;
        radix = 10;

#ifdef  XENIX287
        definesym("@Cpu=0507h");
#else
        definesym("@Cpu=0101h");
#endif
        definesym("@Version=510");

        pagewidth = DEF_LISTWIDTH;
        condflag = origcond;
        crefinc = 0;
        fSkipList = 0;
        errorlineno = 1;
        fCrefline = 1;
        fCheckRes = (pass2 && warnlevel >= 1);
        fNeedList = listconsole || (lsting && (pass2 | debug));

        subttlbuf[0] = NULL;
        modulename = NULL;
        pcsegment = NULL;
        pcproc = NULL;
        startaddr = NULL;
        localbase = 0;
        macrolevel = 0;
        linessrc = 0;
        linestot = 0;
        condlevel = 0;
        lastcondon = 0;
        pcoffset = 0;
        pageminor = 0;
        errorcode = 0;
        fPass1Err = 0;
        iProc = 0;
        iProcCur = 0;

        radixescape = FALSE;
        titleflag = FALSE;
        elseflag = FALSE;
        initflag = FALSE;
        strucflag = FALSE;
        fPutFirstOp = FALSE;
        fArth32 = FALSE;

        listflag = TRUE;
        generate = TRUE;
        xcreflag = TRUE;

        pagemajor = 1;
        crefcount = 1;
        expandflag = LISTGEN;
        pagelength = NUMLIN;
        pageline = NUMLIN - 1;

        memset(listbuffer, ' ', LISTMAX);
        memset(regsegment, 0, sizeof(regsegment));/* No segments assumed*/

        strcpy(tempText, "@F=@0");

        if (tempLabel){
            definesym(tempText);
            tempText[1] = 'B';
            tempText[4] = '@';
            definesym(tempText);
            tempText[4] = '0';
        }

        tempLabel = 0;


        /* Dispatch to do pass */

        handler = HPARSE;
        if (! setjmp(forceContext))
            lineprocess (RREADSOURCE, NULL);

        while (pFCBCur->pFCBParent)
            closefile ();
}




/***    lineprocess - processs next line
 *
 *      lineprocess (tread);
 *
 *      Entry   tread = reader routine
 *      Exit
 *      Returns
 *      Calls
 *      Note    Uses handler to decide which parsing routine to use
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif

VOID CODESIZE
lineprocess (
        char tread,
        MC *pMC
){
        VOID (PASCAL CODESIZE * pHandler)(void);

        lastreader = tread;
        pHandler = rgpHandler[handler];

        do {
            /* dispatch to reader to put line into lbuf */

            /* Clear opcode area if listing */

            if (crefinc) {
                crefcount += crefinc - 1;
                crefline ();
                crefcount++;
                crefinc = 0;
            }

            if (tread == RREADSOURCE)

                readfile ();
            else
                macroexpand (pMC);

            if (popcontext)
                break;

            linestot++;

            (*pHandler)();

            if (swaphandler) {

                swaphandler = FALSE;
                pHandler = rgpHandler[handler];
            }

        } while (1);

        popcontext = FALSE;
        if (macrolevel == 0)
            fPutFirstOp = FALSE;
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif



/***    parse - parse line and dispatch
 *
 *      parse ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
parse ()
{
        static SHORT ret, i;
        static char *nextAtom;

startscan:
        opcref = REF_OTHER << 4 | REF_OTHER;
        listindex = 1;
        optyp = -1;                         /* Haven't looked up first token */

        /* Scan 1st atom on line and check delimiter */

        if (!getatom () && ISTERM(PEEKC())) {  /* quick out for comment line */
                listline ();
                return;
        }

        if (naim.pszName[0] == '%' && naim.pszName[1] == 0) {  /* expand all text macros */
            *begatom = ' ';
            substituteTMs();
            getatom();
        }

        parsedflag = labelflag = FALSE;     /* Have not recognized line yet */

        if (generate)
            switch (PEEKC ()) {
                case ':':
                    /* Form: <name>: xxxxx */
                    /*       name          */

                     nextAtom = lbufp;

                     if (*naim.pszName == 0)

                        errorcSYN ();
                     else {

                        /* create a temporary label of the form @@: */

                        if (fProcArgs > 0)    {/* build stack frame for procs */
                            buildFrame();
                            return;
                        }

                        if (naim.ucCount == 2 && *(SHORT *)naim.pszName == ('@'<<8 | '@')) {

                            tempText[1] = 'B';
                            definesym(tempText);
                            symptr->attr |= M_NOCREF;

                            lbufp = &tempText[3];
                            getatom();
                            labelcreate (CSNEAR, CLABEL);
                            symptr->symu.clabel.iProc = iProcCur;

                            pTextEnd = (char *)-1;
                            *xxradixconvert((long)++tempLabel, &tempText[4]) = NULL;

                            tempText[1] = 'F';
                            definesym(tempText);
                            symptr->attr |= M_NOCREF;
                        }
                        else {

                             /* define NEAR label */
                            labelcreate (CSNEAR, CLABEL);

                            if (lbufp[1] == ':')

                                nextAtom++;

                            else if (!errorcode) { /* don't add if redef */

                                symptr->symu.clabel.iProc = iProcCur;
                                symptr->alpha = NULL;

                                /* addLocal needs takes a null-terminated list */
                                    addLocal(symptr);
                            }
                        }
                    }

                    /* get next token on line after label */

                    lbufp = nextAtom+1;

                    if (!getatom ())
                        goto Done;

                    break;

                case '=':
                    SKIPC ();
                    assignvalue ();
                    goto Done;

                default:
                    /* Form: <name>  xxxxx
                     * Could have <name> <DIR2 directive> so
                     * check 2nd atom */

                    secondDirect ();
                    break;
            }

        /* If PARSEDflag is off, then statement has not been recognized so
           see if atom is a macro name, directive or opcode */

        if (!parsedflag){

            /* look up Macros & struc only when in true part of condition */

            if (generate) {

                xcreflag--;
                ret = symsrch();
                xcreflag++;

                if (ret)

                    switch (symptr->symkind) {

                      case EQU:
                        if (symptr->symu.equ.equtyp == TEXTMACRO) {

#ifdef BCBOPT
                          goodlbufp = FALSE;
#endif

                          /* cref reference to text macro symbol now */
                          /* as it will be overwritten by expandTM */
                          crefnew (REF);
                          crefout ();

                          /* replaces text macro with text */

                          expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
                          goto startscan;
                        }
                        break;

                      case MACRO:
                        macrocall ();
                        return;

                      case STRUC:
                        strucinit ();
                        goto Done;

                      case REC:
                        recordinit ();
                        goto Done;

                    }
            }

            if (! firstDirect() && generate) {

                if (fProcArgs > 0){         /* build stack frame for procs */
                    buildFrame();
                    return;
                }

                emitline();

                if (opcodesearch ())
                     if (opctype < OPCODPARSERS)
                             opcode ();

                     else if (X87type & cpu) {
                             fltopcode ();
                     }
                     else
                             error(E_EXP,iod);

                else if (*naim.pszName != '\0')
                        error (E_EXP,iod);

            }
        }

       /* When we get here, the statement has been parsed and all that is
        * left to do is make sure that the line ends with ; or <cr>. If
        * we are currently under a FALSE conditional, don't bother to check
        * for proper line end since won't have scanned it. */
Done:
        if (generate) {
           if (!ISTERM (skipblanks()))
               errorc (E_ECL);   /* Questionable syntax(bad line end)*/
#ifdef BCBOPT
        } else {
            goodlbufp = FALSE;
#endif
        }
        listline ();
}




/***    secondDirect - parse those instructions which require a label
 *
 *      secondDirect
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID     PASCAL CODESIZE
secondDirect ()
{
   static char *oldlbufp;
   static char *saveBegatom;
   static char *saveEndatom;

   optyp = 0;
   fndir ();                   /* sets to non zero if found */

   if (generate && optyp == (char)0) {

        saveBegatom = begatom;
        saveEndatom = endatom;
        oldlbufp = lbufp;

        switchname ();
        getatom ();
        if (fndir2 ()) {
                /* Have recognized */
                parsedflag = TRUE;
                /* Switch back to 1st atom and dispatch */
                switchname ();
                labelflag = TRUE;

                switch (optyp) {
                        case TCATSTR:
                                catstring ();
                                break;
                        case TENDP:
                                procend ();
                                break;
                        case TENDS:
                                /* End segment */
                                ptends ();
                                break;
                        case TEQU:
                                equdefine ();
                                break;
                        case TGROUP:
                                groupdefine ();
                                break;
                        case TINSTR:
                                instring ();
                                break;
                        case TLABEL:
                                /* <name> LABEL <type> Type is one of
                                   NEAR, FAR | BYTE, WORD, DWORD, QWORD, TBYTE Also can be
                                   record or structure name in which
                                   case set type = length */

                                switchname ();
                                getatom ();
                                if (fnsize ())
                                    if (varsize) {
                                        switchname ();
                                        /* Label in name */
                                        labelcreate (varsize, CLABEL);
                                        symptr->symu.clabel.type = typeFet(varsize);
                                    }
                                    else
                                        errorc (E_TIL);
                                else if (!symFet () ||
                                         !(symptr->symkind == STRUC ||
                                           symptr->symkind == REC))
                                        errorc (E_UST);
                                else {
                                        switchname ();
                                        labelcreate (symptr->symtype, CLABEL);
                                        symptr->symu.clabel.type = typeFet(varsize);
                                }
                                break;
                        case TMACRO:
                                macrodefine ();
                                break;
                        case TPROC:
                                procdefine ();
                                break;
                        case TRECORD:
                                recorddefine ();
                                break;
                        case TSEGMENT:
                                segdefine ();
                                break;
                        case TSIZESTR:
                                sizestring ();
                                break;
                        case TSTRUC:
                                strucdefine ();
                                break;
                        case TSUBSTR:
                                substring ();
                                break;
                        case TDB:
                        case TDD:
                        case TDQ:
                        case TDT:
                        case TDW:
                        case TDF:
                                datadefine ();
                                break;
                }
                labelflag = FALSE;
        }
        else {
                /* Is not a legal 2nd atom directive, but could be
                   <strucname> or <recordname> */

                if (symFetNoXref () &&
                   (symptr->symkind == STRUC ||
                    symptr->symkind == REC)) {

                        switchname ();  /* Get 1st token back */

                        parsedflag = TRUE;
                        labelflag = TRUE;

                        /* Atom is a skeleton name for
                         * RECORD or STRUC so have form:
                         * <name> <skel> */

                        if (symptr->symkind == STRUC)
                                strucinit ();
                        else
                                recordinit ();
                }
                else {
                        begatom = saveBegatom;
                        endatom = saveEndatom;
                        lbufp = oldlbufp;

                        switchname ();
                        /* must be directive or opcode in 1st atom, so get
                           back to that state be rescanning */
                }
        }
    }
}

/***    firstDirect - parse a first token directive
 *
 *
 *      Entry   optyp maybe set, via pars2
 *              0 - not a token
 *             -1 - haven't looked up token yet
 *          other - valid token # of dir
 *
 *      Returns TRUE if it processed a directive
 */



SHORT PASCAL CODESIZE
firstDirect ()
{

        if (optyp == (char)0 || (optyp == ((char)-1) && !fndir ()))
            return(FALSE);

        if (generate ||
            (opkind & CONDBEG) ||
             optyp == TCOMMENT ||
             optyp == TFPO)       {

                switch (optyp) {
                  case TASSUME:
                          BACKC ();
                          do {
                              SKIPC ();
                              assumeitem ();
                          } while (PEEKC () == ',');
                          break;

                  case TCOMMENT:
                          comdir ();
                          break;
                  case TOUT:
                          outdir ();
                          break;
                  case TELSE:
                          elsedir ();
                          break;
                  case TEND:
                          enddir ();
                          break;
                  case TENDIF:
                          endifdir ();
                          break;
                  case TENDM:
                          /* Block nesting */
                          errorc (E_BNE);
                          break;
                  case TERR:
                  case TERR1:
                  case TERR2:
                  case TERRDIF:
                  case TERRIDN:
                  case TERRB:
                  case TERRDEF:
                  case TERRE:
                  case TERRNZ:
                  case TERRNB:
                  case TERRNDEF:
                          errdir ();
                          break;
                  case TEVEN:
                          evendir (2);
                          break;
                  case TALIGN:
                          evendir (0);
                          break;
                  case TEXITM:
                          exitmdir ();
                          break;
                  case TEXTRN:
                          BACKC ();
                          do {
                                  SKIPC ();
                                  externitem ();
                          } while (PEEKC() == ',');
                          break;
                  case TIF:
                  case TIF1:
                  case TIF2:
                  case TIFDIF:
                  case TIFIDN:
                  case TIFB:
                  case TIFDEF:
                  case TIFE:
                  case TIFNB:
                  case TIFNDEF:
                          conddir ();
                          break;
                  case TINCLUDE:
                          includedir ();
                          break;
                  case TIRP:
                  case TIRPC:
                          irpxdir ();
                          break;
                  case TLOCAL:
                          if (langType)
                            defineLocals();
                          break;
                  case TNAME:
                          namedir ();
                          break;
                  case TORG:
                          orgdir ();
                          break;
                  case TPAGE:
                          setpage ();
                          break;
                  case TPUBLIC:
                          BACKC ();
                          do {
                              SKIPC ();
                              publicitem ();
                          } while (PEEKC () == ',');
                          break;
                  case TPURGE:
                          BACKC ();
                          do {
                              SKIPC ();
                              purgemacro ();
                          } while (PEEKC () == ',');
                          break;
                  case TREPT:
                          reptdir ();
                          break;
                  case TCREF:
                          xcreflag = TRUE;
                          break;
                  case TLALL:
                          expandflag = LIST;
                          break;
                  case TLFCOND:
                          condflag = TRUE;
                          break;
                  case TLIST:
                          listflag = TRUE;
                          break;
                  case TRADIX:
                          radixdir ();
                          break;
                  case TSALL:
                          expandflag = SUPPRESS;
                          break;
                  case TSFCOND:
                          condflag = FALSE;
                          break;
                  case TSUBTTL:
                          storetitle (subttlbuf);
                          break;
                  case TTFCOND:
                          if (pass2) {
                                  condflag = (origcond? FALSE: TRUE);
                                  origcond = condflag;
                          }
                          break;
                  case TTITLE:
                          if (titleflag)
                                  errorc (E_RSY);
                          else
                                  storetitle (titlebuf);
                          titleflag = TRUE;
                          break;
                  case TXALL:
                          expandflag = LISTGEN;
                          break;
                  case TXCREF:
                          if (ISTERM (PEEKC ()))
                                  xcreflag = loption;
                          else {
                             BACKC ();
                             do {
                                 SKIPC ();
                                 xcrefitem ();
                             } while (PEEKC () == ',');
                          }
                          break;
                  case TXLIST:
                          listflag = FALSE;
                          break;
                  case TDB:
                  case TDD:
                  case TDQ:
                  case TDT:
                  case TDW:
                  case TDF:
                          datadefine ();
                          break;

                  case T8087:
                          X87type = PX87;
                          goto setatcpu;

                  case T287:
                          X87type = PX87|PX287;
                          goto setX;

                  case T387:
                          X87type = PX87|PX287|PX387;
                  setX:
                          if (X87type > cputype)
                            errorc(E_TIL);

                          goto setatcpu;

                  case T8086:

                          cputype = P86;
                          X87type = PX87;
                          goto setcpudef;

                  case T186:

                          cputype = P186;
                          X87type = PX87;
                          goto setcpudef;

                  case T286C:

                          cputype = P186|P286;
                          X87type = PX87|PX287;
                          goto setcpudef;

                  case T286P:

                          cputype = P186|P286|PROT;
                          X87type = PX87|PX287;
                          goto setcpudef;

#ifdef V386
                  case T386C:

                          init386(0);

                          cputype = P186|P286|P386;
                          goto set386;

                  case T386P:
                          init386(1);

                          cputype = P186|P286|P386|PROT;
                  set386:
                          X87type = PX87|PX287|PX387;
                          fltemulate = FALSE;
                          fArth32 |= TRUE;
#endif
                  setcpudef:
#ifdef V386
                          wordszdefault = (char)wordsize = (cputype&P386)? 4: 2;
                          defwordsize();

                          if (pcsegment)
                              if (pcsegment->symu.segmnt.use32 > wordsize)
                                  errorc(E_CPU);
                              else
                                  wordsize = pcsegment->symu.segmnt.use32;
#endif
                  setatcpu:
                          coprocproc = (X87type << 8) + (cputype | 1);
                          pTextEnd = (UCHAR *) -1;
                          *xxradixconvert((OFFSET)coprocproc, cputext + 5) = 0;
                          definesym(cputext);

                          break;

                  case TSEQ:
                          segalpha = FALSE;
                          break;
                  case TALPHA:
                          segalpha = TRUE;
                          break;

                  case TDOSSEG:
                          fDosSeg++;
                          break;

                  case TMODEL:
                          model();
                          break;

                  case TMSEG:
                          openSeg();
                          break;

                  case TMSTACK:
                          createStack();
                          break;

                  case TINCLIB:
                          includeLib();
                          break;

                  case TFPO:
                          fpoRecord();
                          break;

                  case TCOMM:
                          BACKC ();
                          do {
                                  SKIPC ();
                                  commDefine ();

                          } while (PEEKC() == ',');
                          break;
               }
           }
        return(TRUE);
}



/***    setpage - set page length and width
 *
 *      setpage ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
setpage ()
{
        register char cc;
        SHORT i;

        if (ISTERM (cc = PEEKC ())) {
                /* position to bottom of page if no operands */
                if (listflag)
                        pageline = pagelength - 1;
        }
        else if (cc == '+') {
                if (ISBLANK (NEXTC ()))
                        skipblanks ();
                if (listflag)
                        newpage ();
        }
        else {
                if (cc != ',') {
                        /* set page length */
                        if ((i = (SHORT)exprconst ()) > 9 && i < 256)
                                pagelength = i;
                        else
                                errorc (E_VOR);
                        if (pageminor + pagemajor == 1)
                                /* Adjust so page length right */
                                pageline = (pagelength - NUMLIN) + pageline;
                }
                if (PEEKC () == ',') {
                        SKIPC ();
                        /* set page width */
                        if ((i = (SHORT)exprconst ()) > LINEMAX || i < 60)
                                errorc (E_VOR);
                        else
                                pagewidth = i;
                }
        }
}




/***    ptends - process ends statement
 *
 *      ptends ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
ptends ()
{
        if (!symFet() || !pcsegment)
                errorc (E_BNE);

        /*  Make sure segname is correct */
        else if (pcsegment != symptr)
                errorc (E_BNE);
        else {
                if (symptr->symkind != SEGMENT)
                        errorc (E_BNE);
                else {
                        if (pcmax <= pcoffset)
                                symptr->symu.segmnt.seglen = pcoffset;
                        else
                                symptr->symu.segmnt.seglen = pcmax;
                        /* S a v e s e g me n t P C */
                        symptr->offset = pcoffset;

                        if (pcsegment->symu.segmnt.use32 == 2) {

                            if (pcoffset > 0x10000)
                                errorc(E_286 & ~E_WARN1);

                            if (pcsegment->symu.segmnt.hascode &&
                                pcsegment->symu.segmnt.seglen > 0xFFDC)
                                    errorc( E_286 );
                        }


                        pcdisplay (); /* must do before lose pcsegment */
                        pcsegment = symptr->symu.segmnt.lastseg;
#ifdef V386
                        if (pcsegment)
                                wordsize = pcsegment->symu.segmnt.use32;
                        else
                                wordsize = wordszdefault;
#endif
                        symptr->symu.segmnt.lastseg = NULL;
                        /* Replace later pcsegment <> NULL block with following
                           block.  pcmax must be reset on leaving seg. */
                        if (pcsegment) {
                                /*  Restore PC and max offset so far in
                                    segment */
                                pcoffset = (*pcsegment).offset;
                                pcmax = pcsegment->symu.segmnt.seglen;

                                strnfcpy(&segName[8], pcsegment->nampnt->id);
                        }
                        else {
                                /* If no seg, PC and max are 0 */
                                pcoffset = 0;
                                pcmax = 0;
                                segName[8] = NULL;
                        }
                }
                definesym(segName);
        }
        defwordsize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmtab.h ===
/* asmtab.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#define NOTFOUND	((USHORT)-1)
#define KEYWORDS	struct s_ktab
#define KEYSYM		struct s_key

struct segp {
	USHORT	index;
	char	type;
	};

struct opcentry {
	UCHAR	opcb;
	UCHAR	mr;
	char	opct;
	char	cpumask;
	};
/* masks and flags to extract operand reference types */

#define F_W	0x40	/* first operand is write  */

#define S_W	0x20	/* second operand is write */


struct pseudo {
	char	type;
	char	kind;
	};


KEYWORDS {
	KEYSYM	FARSYM * FARSYM *kt_table;    /* ptr to hash table  */
	int	kt_size;	/* size of hash table */
};


KEYSYM	{
	KEYSYM	FARSYM *k_next;        /* pointer to next ident */
	char	FARSYM *k_name;        /* pointer to name */
	USHORT	k_hash; 	/* actual hash value */
	USHORT	k_token;	/* token type.  note more than 255 opcodes */
};


USHORT CODESIZE        iskey PARMS((struct s_ktab FAR *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmtab.c ===
/* asmtab.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmopcod.h"
#include "asmctype.h"
#include "asmtab.h"	/* common between asmtab.c and asmtabtb.c */

extern struct pseudo FAR dir1tok[];
extern struct pseudo FAR dir2tok[];
extern struct opcentry FAR opctab[];

extern UCHAR opprec[];

extern KEYWORDS FAR t_siz_table;
extern KEYWORDS FAR t_op_table;
extern KEYWORDS FAR t_oc_table;
extern KEYWORDS FAR t_seg_table;
extern KEYWORDS FAR t_ps1_table;
extern KEYWORDS FAR t_ps2_table;


/***	fnsize - return size of operand
 *
 *	flag = fnsize ();
 *
 *	Entry	naim = token to search for
 *	Exit	varsize = size of symbol
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	none
 *	Note	8/1/88 - MCH - Modified to perform text macro substitution.
 *		This is a complete hack.  iskey() is hardcoded to lookup
 *		the string in naim, while symFet() sets symptr to the
 *		symbol following the text macro expansion.  Thus, lots of
 *		contortions are necessary to get these routines to mesh.
 */

/* size table */

USHORT dirsize[] = {
	/* I_BYTE */	1,
	/* I_DWORD */	4,
	/* I_FAR */	CSFAR,
	/* I_NEAR */	CSNEAR,
	/* I_QWORD */	8,
	/* I_TBYTE */	10,
	/* I_WORD */	2,
	/* I_FWORD */	6,
	/* I_PROC */	CSNEAR
};

SHORT	PASCAL CODESIZE
fnsize ()
{

#ifdef	FEATURE

	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_siz_table)) != NOTFOUND)) {
		varsize = dirsize[v];
		return (TRUE);
	}
	return (FALSE);

#else

	register USHORT v;
	SYMBOL FARSYM * pSYsave;
	char * savelbufp, * savebegatom, * saveendatom;
	char szname[SYMMAX+1];
	FASTNAME saveInfo;
	char	 szSave[SYMMAX+1];

	if (*naim.pszName) {
	    pSYsave = symptr;
	    savelbufp = lbufp;
	    savebegatom = begatom;
	    saveendatom = endatom;
	    memcpy (&saveInfo, &naim, sizeof( FASTNAME ) );
	    memcpy (szSave, naim.pszName, SYMMAX + 1);

	    if (symFet()) {
		STRNFCPY (szname, symptr->nampnt->id);
		lbufp = szname;
		getatom();
	    }

	    symptr = pSYsave;
	    lbufp = savelbufp;
	    begatom = savebegatom;
	    endatom = saveendatom;

	    if (*naim.pszName && ((v = iskey (&t_siz_table)) != NOTFOUND)) {
		    varsize = dirsize[v];
		    return (TRUE);
	    }

	    memcpy (naim.pszName, szSave, SYMMAX + 1);
	    memcpy (&naim, &saveInfo, sizeof( FASTNAME ) );
	}
	return (FALSE);

#endif

}


/***	fnPtr - find a type to a pointer or size and return a CV type
 *
 *	flag = fnPtr (ptrSize)
 *
 *	Entry	token = token to search for
 *	Exit	CV - type
 */


SHORT	PASCAL CODESIZE
fnPtr (
	SHORT sizePtr
){
	SYMBOL FARSYM  *pSYtype, FARSYM *pT, FARSYM *pSY;
	SHORT fFarPtr;

	fFarPtr = sizePtr > wordsize;

	if (fnsize() || *naim.pszName == 0)
	    return (typeFet(varsize) |
		    makeType(0, ((fFarPtr)? BT_FARP: BT_NEARP), 0));

	pT = symptr;

	if (symsrch()) {

	    pSY = symptr;		/* restore old symptr */
	    symptr = pT;

	    if (pSY->symkind == STRUC) {

		if (fFarPtr) {
		    if (pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrFar)
			return(pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrFar);
		}
		else if (pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrNear)
		    return(pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrNear);

		/* Neither derived type is allocated, so make an allocation */

		pSYtype = (SYMBOL FARSYM *)falloc((SHORT)( &(((SYMBOL FARSYM *)0)->symu) ), "fnPtr" );

		if (pStrucCur)
		    pStrucCur->alpha = pSYtype;
		else
		    pStrucFirst = pSYtype;

		pStrucCur = pSYtype;

		pSYtype->attr = (unsigned char)fFarPtr;
		pSYtype->symkind = 0;
		pSYtype->alpha = 0;
		pSYtype->symtype = pSY->symu.rsmsym.rsmtype.rsmstruc.type;

		if (fFarPtr)
		    pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrFar = typeIndex;

		else
		    pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrNear = typeIndex;


		return(typeIndex++);
	    }
	}
	return (FALSE);
}


/***	fnoper - search for operator
 *
 *	flag = fnoper (token, type, prec);
 *
 *	Entry	token = token to search for
 *	Exit	opertype = type of operator
 *		operprec = precedence of operator
 *	Returns TRUE if token is an operator
 *		FALSE if token is not an operator
 *	Calls	none
 */

SHORT	PASCAL CODESIZE
fnoper ()
{
	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_op_table)) != NOTFOUND)) {
		opertype = (char)v;
		operprec = opprec[v];
		return (TRUE);
	}
	return (FALSE);
}


/***	opcodesearch - search for opcode
 *
 *	flag = opcodesearch ();
 *
 *	Entry	*naim.pszName = token to search for
 *		cputype = cpu type (8086, 186, 286)
 *	Exit	opcbase = opcode base value
 *		opctype = type of opcode
 *		modrm = modrm value
 *	Returns TRUE if token is an opcode
 *		FALSE if token is not an opcode
 *	Calls	none
 */

char	PASCAL CODESIZE
opcodesearch ()
{
	register USHORT v;
	struct opcentry FAR *opc;
        UCHAR cputypeandprot;
        UCHAR opctabmask;
        int workaround;

	if (*naim.pszName && ((v = iskey (&t_oc_table)) != NOTFOUND)) {
            cputypeandprot = cputype & PROT;
            opctabmask = opctab[v].cpumask&PROT;
            workaround = cputypeandprot >= opctabmask ? 1 : 0;
	    if (((cpu = (opc = &(opctab[v]))->cpumask) & cputype) &&
		workaround) {
		    opcbase = opc->opcb;
		    modrm = opc->mr;
		    opctype = opc->opct;

		    if (crefing) {

			fSecondArg = FALSE;

			switch (opctype) {

			case PJUMP:
			case PRELJMP:
			case PCALL:
			    opcref = REF_XFER << 4 | REF_NONE;
			    break;

			default:
			    v = opc->cpumask;
			    opcref  = (char)((v&F_W)? REF_WRITE << 4: REF_READ << 4);
			    opcref |= (v&S_W)? REF_WRITE: REF_READ;
			}
		    }

		    return (TRUE);
	    }
        }
	return (FALSE);
}


/***	fnspar - return token index and type from table.
 *
 *	flag = fnspar ();
 *
 *	Entry	naim = token to search for
 *	Exit	segtyp = type of segment
 *		segidx = index of token in table
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	iskey
 *
 *	I spent several hours trying to debug through the silly
 *	redundant level of indirection, so I removed it for the
 *	index.  this changes all the token numbers by 1, so they
 *	are consistent.  see accompanying change in asmdir:segalign
 *				-Hans Apr 8 1986
 */

SHORT	PASCAL CODESIZE
fnspar ()
{
	register USHORT v;

	/* Must match IS_... in asmindex.h under "segment attributes.
	   These values are the segment types put in the segdef OMF */

	static char tokseg[] = {

	/* IS_AT */	0,
	/* IS_BYTE */	1,
	/* IS_COMMON */	6,
	/* IS_MEMORY */ 1,
	/* IS_PAGE */	4,
	/* IS_PARA */	3,
	/* IS_PUBLIC */	2,
	/* IS_STACK */	5,
	/* IS_WORD */	2,
	/* IS_DWORD */	5,

	/* IS_USE32 */	0,
	/* IS_USE16 */	0,
	};


	if (*naim.pszName && ((v = iskey (&t_seg_table)) != NOTFOUND)) {
		segtyp = tokseg[v];
		segidx = v;
		return (TRUE);
	}
	return (FALSE);
}


/***	fndir - return size of operand
 *
 *	flag = fndir ();
 *
 *	Entry	naim = token to search for
 *	Exit	opty = size of symbol
 *		opkind = kind of symbol
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	none
 */

SHORT	PASCAL CODESIZE
fndir ()
{
	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_ps1_table)) != NOTFOUND)) {
		optyp = dir1tok[v].type;
		opkind = dir1tok[v].kind;
		return (TRUE);
	}
	return (FALSE);
}


/***	fndir2 - return type of directive
 *
 *	flag = fndir2 ();
 *	Entry	naim = token to search for
 *	Exit	opty = size of symbol
 *		opkind = kind of symbol
 *
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	none
 */

SHORT	PASCAL CODESIZE
fndir2 ()
{
	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_ps2_table)) != NOTFOUND)) {
		optyp = dir2tok[v].type;
		opkind = dir2tok[v].kind;
		return (TRUE);
	}
	return (FALSE);
}

SHORT PASCAL CODESIZE
checkRes()
{
    USHORT v;

    xcreflag--;

    if (fCheckRes &&
	(((v = iskey (&t_oc_table)) != NOTFOUND &&
	  (opctab[v].cpumask & cputype)) ||

	 iskey (&t_ps1_table) != NOTFOUND ||
	 iskey (&t_ps2_table) != NOTFOUND ||
	 iskey (&t_op_table) != NOTFOUND ||
	 iskey (&t_siz_table) != NOTFOUND ||
/*	 iskey (&t_seg_table) != NOTFOUND || */
	 (symsearch() && symptr->symkind == REGISTER) ||
	 (naim.pszName[1] == 0 && (*naim.pszName == '$'||
	 *naim.pszName == '%' || *naim.pszName == '?')))){


	errorn(E_RES);
	xcreflag++;
	return(TRUE);
    }
    xcreflag++;
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmtabtb.c ===
/* asmtabtb.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmopcod.h"
#include "asmctype.h"
#include "asmindex.h"
#include "asmtab.h"	/* common between asmtab.c and asmtabtb.c */

#ifndef V386

#define P386 0
#endif

/* first token table */

struct pseudo FAR dir1tok[] = {
	/* I_TASSUME */		{ TASSUME,	NL	},
	/* I_TCOMMENT */	{ TCOMMENT,	NL	},
	/* I_TDB */		{ TDB,		NL	},
	/* I_TDD */		{ TDD,		NL	},
	/* I_TDQ */		{ TDQ,		NL	},
	/* I_TDT */		{ TDT,		NL	},
	/* I_TDW */		{ TDW,		NL	},
	/* I_TELSE */		{ TELSE,	CONDBEG	},
	/* I_TEND */		{ TEND,		NL	},
	/* I_TENDIF */		{ TENDIF,	CONDBEG },
	/* I_TENDM */		{ TENDM,	NL	},
	/* I_TERR */		{ TERR,		NL	},
	/* I_TERR1 */		{ TERR1,	NL	},
	/* I_TERR2 */		{ TERR2,	NL	},
	/* I_TERRB */		{ TERRB,	NL	},
	/* I_TERRDEF */		{ TERRDEF,	NL	},
	/* I_TERRDIF */		{ TERRDIF,	NL	},
	/* I_TERRE */		{ TERRE,	NL	},
	/* I_TERRNZ */		{ TERRNZ,	NL	},
	/* I_TERRIDN */		{ TERRIDN,	NL	},
	/* I_TERRNB */		{ TERRNB,	NL	},
	/* I_TERRNDEF */	{ TERRNDEF,	NL	},
	/* I_TEVEN */		{ TEVEN,	NL	},
	/* I_TEXITM */		{ TEXITM,	NL	},
	/* I_TEXTRN */		{ TEXTRN,	NL	},
	/* I_TIF */		{ TIF,		CONDBEG	},
	/* I_TIF1 */		{ TIF1,		CONDBEG	},
	/* I_TIF2 */		{ TIF2,		CONDBEG	},
	/* I_TIFB */		{ TIFB,		CONDBEG	},
	/* I_TIFDEF */		{ TIFDEF,	CONDBEG	},
	/* I_TIFDIF */		{ TIFDIF,	CONDBEG	},
	/* I_TIFE */		{ TIFE,		CONDBEG	},
	/* I_TIFIDN */		{ TIFIDN,	CONDBEG	},
	/* I_TIFNB */		{ TIFNB,	CONDBEG	},
	/* I_TIFNDEF */		{ TIFNDEF,	CONDBEG	},
	/* I_TINCLUDE */	{ TINCLUDE,	NL	},
	/* I_TIRP */		{ TIRP,		BLKBEG	},
	/* I_TIRPC */		{ TIRPC,	BLKBEG	},
	/* I_TLOCAL */		{ TLOCAL,	NL	},
	/* I_TNAME */		{ TNAME,	NL	},
	/* I_TORG */		{ TORG,		NL	},
	/* I_TPAGE */		{ TPAGE,	NL	},
	/* I_TPUBLIC */		{ TPUBLIC,	NL	},
	/* I_TPURGE */		{ TPURGE,	NL	},
	/* I_TREPT */		{ TREPT,	BLKBEG	},
	/* I_TSUBTTL */		{ TSUBTTL,	NL	},
	/* I_TTITLE */		{ TTITLE,	NL	},
	/* I_TCREF */		{ TCREF,	NL	},
	/* I_TLALL */		{ TLALL,	NL	},
	/* I_TLFCOND */		{ TLFCOND,	NL	},
	/* I_TLIST */		{ TLIST,	NL	},
	/* I_TRADIX */		{ TRADIX,	NL	},
	/* I_TSALL */		{ TSALL,	NL	},
	/* I_TSFCOND */		{ TSFCOND,	NL	},
	/* I_TTFCOND */		{ TTFCOND,	NL	},
	/* I_TXALL */		{ TXALL,	NL	},
	/* I_TXCREF */		{ TXCREF,	NL	},
	/* I_TXLIST */		{ TXLIST,	NL	},
	/* I_TOUT */		{ TOUT,		NL	},
	/* I_TALIGN */		{ TALIGN,	NL	},
	/* I_T8086 */		{ T8086,	NL	},
	/* I_T8087 */		{ T8087,	NL	},
	/* I_T287 */		{ T287,		NL	},
	/* I_T186 */		{ T186,		NL	},
	/* I_T286C */		{ T286C,	NL	},
	/* I_T286P */		{ T286P,	NL	},

	/* I_TINCLIB */ 	{ TINCLIB,	NL	},
	/* I_TMSTACK */ 	{ TMSTACK,	NL	},
	/* I_TDOSSEG */ 	{ TDOSSEG,	NL	},
	/* I_TMODEL  */ 	{ TMODEL,	NL	},
	/* I_TCODE    */	{ TMSEG,	0	},
	/* I_TDATA    */	{ TMSEG,	1	},
	/* I_TDATAQ   */	{ TMSEG,	2	},
	/* I_TCONST   */	{ TMSEG,	3	},
	/* I_TFARDATA */	{ TMSEG,	5	},
	/* I_TFARDATAQ*/	{ TMSEG,	6	},

	/* I_TSEQ	*/	{ TSEQ,		NL	},
	/* I_TALPHA	*/	{ TALPHA,	NL	},
	/* I_TCOMM  */		{ TCOMM,	NL	},
	/* I_TIFDIFI */ 	{ TIFDIF,	CONDBEG | IGNORECASE},
	/* I_TIFIDNI */ 	{ TIFIDN,	CONDBEG | IGNORECASE},
	/* I_TERRDIFI */	{ TERRDIF,	NL	| IGNORECASE},
	/* I_TERRIDNI */	{ TERRIDN,	NL	| IGNORECASE},
	/* I_TELSEIF */ 	{ TIF,		(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIF1 */	{ TIF1, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIF2 */	{ TIF2, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFB */	{ TIFB, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFDEF */	{ TIFDEF,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFDIF */	{ TIFDIF,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFE */	{ TIFE, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFIDN */	{ TIFIDN,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFNB */	{ TIFNB,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFNDEF */	{ TIFNDEF,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFDIFI */	{ TIFDIF,	(char)(CONDBEG | CONDCONT | IGNORECASE)},
	/* I_TELSEIFIDNI */	{ TIFIDN,	(char)(CONDBEG | CONDCONT | IGNORECASE)},

#ifdef V386
	/* I_T386C */		{ T386C,	NL	},
	/* I_T386P */		{ T386P,	NL	},
	/* I_T387 */		{ T387, 	NL	},
	/* I_TDF */		{ TDF,		NL	},
#endif

    /* I_TFPO */        { TFPO,     NL },
};


/* second token table */

struct pseudo FAR dir2tok[] = {
	/* I2_TDB */		{ TDB,		NL	},
	/* I2_TDD */		{ TDD,		NL	},
	/* I2_TDQ */		{ TDQ,		NL	},
	/* I2_TDT */		{ TDT,		NL	},
	/* I2_TDW */		{ TDW,		NL	},
	/* I2_TENDP */		{ TENDP,	NL	},
	/* I2_TENDS */		{ TENDS,	NL	},
	/* I2_TEQU */		{ TEQU,		NL	},
	/* I2_TSUBSTR */	{ TSUBSTR,	NL	},
	/* I2_TCATSTR */	{ TCATSTR,	NL	},
	/* I2_TSIZESTR */	{ TSIZESTR,	NL	},
	/* I2_TINSTR */ 	{ TINSTR,	NL	},
	/* I2_TGROUP */		{ TGROUP,	NL	},
	/* I2_TLABEL */		{ TLABEL,	NL	},
	/* I2_TMACRO */ 	{ TMACRO,	BLKBEG	},
	/* I2_TPROC */		{ TPROC,	NL	},
	/* I2_TRECORD */	{ TRECORD,	NL	},
	/* I2_TSEGMENT */	{ TSEGMENT,	NL	},
	/* I2_TSTRUC */		{ TSTRUC,	NL	},

#ifdef V386
	/* I2_TDF */		{ TDF,		NL	},
#endif
};


/* precedence tables */

UCHAR opprec[] = {
	11, 11, 11, 11, 9, 9, 9,
	1, 9, 8, 8, 4, 1,
	3, 5, 5, 5, 5, 5, 7, 5, 2, 9,
	7, 7, 2, 0, 0,
	11, 11, 11, 11, 11, 11, 10, 10, 7, 7, 6, 6
};


/* segment parameter names */


/* opcode table */

struct opcentry FAR opctab[] = {  /* order must match I_xxx in asmindex.h */
	{ O_AAA,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_AAD,     R_AAD,	PNOARGS,       P86|P186|P286|P386 },
	{ O_AAM,     R_AAM,	PNOARGS,       P86|P186|P286|P386 },
	{ O_AAS,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_ADC,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_ADD,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_AND,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_CALL,    0, 	PCALL,	       P86|P186|P286|P386 },
	{ O_CBW,     2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CLC,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CLD,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CLI,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CMC,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CMP,     0, 	PGENARG,       P86|P186|P286|P386 },
	{ O_CMPS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_CMPSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CMPSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CWD,     2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_DAA,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_DAS,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_DEC,     0, 	PINCDEC,   F_W|P86|P186|P286|P386 },
	{ O_DIV,     R_DIV,	PARITH,        P86|P186|P286|P386 },
	{ O_ESC,     0, 	PESC,	       P86|P186|P286|P386 },
	{ O_HLT,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_IDIV,    R_IDIV,	PARITH,        P86|P186|P286|P386 },
	{ O_IMUL,    R_IMUL,	PARITH,        P86|P186|P286|P386 },
	{ O_IN,      0, 	PINOUT,        P86|P186|P286|P386 },
	{ O_INC,     0, 	PINCDEC,   F_W|P86|P186|P286|P386 },
	{ O_INT,     0, 	PINT,	       P86|P186|P286|P386 },
	{ O_INTO,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_IRET,    2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_JA,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JAE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JB,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JBE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JC,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JCXZ,    2, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JE,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JG,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JGE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JL,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JLE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JMP,     0, 	PJUMP,	       P86|P186|P286|P386 },
	{ O_JNA,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNAE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNB,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNBE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNC,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNG,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNGE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNL,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNLE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNO,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNP,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNS,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNZ,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JO,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JP,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JPE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JPO,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JS,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JZ,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LAHF,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_LEA,     0, 	PLOAD,	       P86|P186|P286|P386 },
	{ O_LES,     0, 	PLOAD,	       P86|P186|P286|P386 },
	{ O_LDS,     0, 	PLOAD,	       P86|P186|P286|P386 },
	{ O_LOCK,    0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_LODS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_LODSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_LODSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_LOOP,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPE,   0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPNE,  0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPNZ,  0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPZ,   0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_MOV,     0, 	PMOV,	   F_W|P86|P186|P286|P386 },
	{ O_MOVS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_MOVSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_MOVSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_MUL,     R_MUL,	PARITH,        P86|P186|P286|P386 },
	{ O_NEG,     R_NEG,	PARITH,    F_W|P86|P186|P286|P386 },
	{ O_NOP,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_NOT,     R_NOT,	PARITH,    F_W|P86|P186|P286|P386 },
	{ O_OR,      0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_OUT,     0, 	PINOUT,        P86|P186|P286|P386 },
	{ O_POP,     0, 	PSTACK,    F_W|P86|P186|P286|P386 },
	{ O_POPF,    2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_PUSH,    0, 	PSTACK,        P86|P186|P286|P386 },
	{ O_PUSHF,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_RCL,     R_RCL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_RCR,     R_RCR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_REP,     0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPE,    0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPNE,   0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPNZ,   0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPZ,    0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_RET,     0, 	PRETURN,       P86|P186|P286|P386 },
	{ O_ROL,     R_ROL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_ROR,     R_ROR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SAHF,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SAL,     R_SAL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SAR,     R_SAR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SBB,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_SCAS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_SCASB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SCASW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SHL,     R_SHL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SHR,     R_SHR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_STC,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STD,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STI,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STOS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_STOSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STOSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SUB,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_TEST,    0, 	PGENARG,       P86|P186|P286|P386 },
	{ O_WAIT,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_XCHG,    0, 	PXCHG, F_W|S_W|P86|P186|P286|P386 },
	{ O_XLAT,    0, 	PXLAT,	       P86|P186|P286|P386 },
	{ O_XLATB,   0, 	PXLAT,	       P86|P186|P286|P386 },
	{ O_XOR,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_ARPL,    0, 	PARPL,	   (char)(F_W| 	P286|P386|PROT) },
	{ O_BOUND,   0, 	PBOUND, 	   P186|P286|P386 },
	{ O_CLTS,    R_CLTS,	PCLTS,			(char)(P286|P386|PROT) },
	{ O_ENTER,   0, 	PENTER, 	   P186|P286|P386 },
	{ O_INS,     0, 	PSTR,		   P186|P286|P386 },
	{ O_INSB,    0, 	PNOARGS,	   P186|P286|P386 },
	{ O_INSW,    2, 	PNOARGS,	   P186|P286|P386 },
	{ O_LAR,     R_LAR,	PARSL,			(char)(P286|P386|PROT) },
	{ O_LEAVE,   0, 	PNOARGS,	   P186|P286|P386 },
	{ O_LGDT,    R_LGDT,	PDESCRTBL,		(char)(P286|P386|PROT) },
	{ O_LIDT,    R_LIDT,	PDESCRTBL,		(char)(P286|P386|PROT) },
	{ O_LLDT,    R_LLDT,	PDTTRSW,		(char)(P286|P386|PROT) },
	{ O_LMSW,    R_LMSW,	PDTTRSW,		(char)(P286|P386|PROT) },
	{ O_LSL,     R_LSL,	PARSL,			(char)(P286|P386|PROT) },
	{ O_LTR,     R_LTR,	PDTTRSW,		(char)(P286|P386|PROT) },
	{ O_OUTS,    0, 	PSTR,		   P186|P286|P386 },
	{ O_OUTSB,   0, 	PNOARGS,	   P186|P286|P386 },
	{ O_OUTSW,   2, 	PNOARGS,	   P186|P286|P386 },
	{ O_POPA,    2, 	PNOARGS,   F_W|    P186|P286|P386 },
	{ O_PUSHA,   2, 	PNOARGS,	   P186|P286|P386 },
	{ O_SGDT,    R_SGDT,	PDESCRTBL, (char)(F_W| 	P286|P386|PROT) },
	{ O_SIDT,    R_SIDT,	PDESCRTBL, (char)(F_W| 	P286|P386|PROT) },
	{ O_SLDT,    R_SLDT,	PDTTRSW,   (char)(F_W| 	P286|P386|PROT) },
	{ O_SMSW,    R_SMSW,	PDTTRSW,   (char)(F_W| 	P286|P386|PROT) },
	{ O_STR,     R_STR,	PDTTRSW,   (char)(F_W| 	P286|P386|PROT) },
	{ O_VERR,    R_VERR,	PVER,			(char)(P286|P386|PROT) },
	{ O_VERW,    R_VERW,	PVER,			(char)(P286|P386|PROT) },

	{ O_F2XM1,   R_F2XM1,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FABS,    R_FABS,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FADD,    R_FADD,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FADDP,   R_FADDP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FBLD,    R_FBLD,	FBCDMEM,       P86|P186|P286|P386 },
	{ O_FBSTP,   R_FBSTP,	FBCDMEM,   F_W|P86|P186|P286|P386 },
	{ O_FCHS,    R_FCHS,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FCLEX,   R_FCLEX,	FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FCOM,    R_FCOM,	FMEMSTK,       P86|P186|P286|P386 },
	{ O_FCOMP,   R_FCOMP,	FMEMSTK,       P86|P186|P286|P386 },
	{ O_FCOMPP,  R_FCOMPP,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FDECSTP, R_FDECSTP, FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FDISI,   R_FDISI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FDIV,    R_FDIV,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FDIVP,   R_FDIVP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FDIVR,   R_FDIVR,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FDIVRP,  R_FDIVRP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FENI,    R_FENI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FFREE,   R_FFREE,	FSTK,	       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FIADD,   R_FIADD,	FMEM42,        P86|P186|P286|P386 },
	{ O_FICOM,   R_FICOM,	FMEM42,        P86|P186|P286|P386 },
	{ O_FICOMP,  R_FICOMP,	FMEM42,        P86|P186|P286|P386 },
	{ O_FIDIV,   R_FIDIV,	FMEM42,        P86|P186|P286|P386 },
	{ O_FIDIVR,  R_FIDIVR,	FMEM42,        P86|P186|P286|P386 },
	{ O_FILD,    R_FILD,	FMEM842,       P86|P186|P286|P386 },
	{ O_FIMUL,   R_FIMUL,	FMEM42,        P86|P186|P286|P386 },
	{ O_FINCSTP, R_FINCSTP, FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FINIT,   R_FINIT,	FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FIST,    R_FIST,	FMEM42,    F_W|P86|P186|P286|P386 },
	{ O_FISTP,   R_FISTP,	FMEM842,   F_W|P86|P186|P286|P386 },
	{ O_FISUB,   R_FISUB,	FMEM42,        P86|P186|P286|P386 },
	{ O_FISUBR,  R_FISUBR,	FMEM42,        P86|P186|P286|P386 },
	{ O_FLD,     R_FLD,	FMEM4810,      P86|P186|P286|P386 },
	{ O_FLD1,    R_FLD1,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDCW,   R_FLDCW,	FMEM2,	       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FLDENV,  R_FLDENV,	FMEM14,        FORCEWAIT|P86|P186|P286|P386 },
	{ O_FLDL2E,  R_FLDL2E,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDL2T,  R_FLDL2T,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDLG2,  R_FLDLG2,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDLN2,  R_FLDLN2,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDPI,   R_FLDPI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDZ,    R_FLDZ,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FMUL,    R_FMUL,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FMULP,   R_FMULP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FNCLEX,  R_FNCLEX,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNDISI,  R_FNDISI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNENI,   R_FNENI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNINIT,  R_FNINIT,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNOP,    R_FNOP,	FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FNSAVE,  R_FNSAVE,	FMEM94,    F_W|P86|P186|P286|P386 },
	{ O_FNSTCW,  R_FNSTCW,	FMEM2,	   F_W|P86|P186|P286|P386 },
	{ O_FNSTENV, R_FNSTENV, FMEM14,    F_W|P86|P186|P286|P386 },
	{ O_FNSTSW,  R_FNSTSW,	FMEM2,	   F_W|P86|P186|P286|P386 },
	{ O_FPATAN,  R_FPATAN,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FPREM,   R_FPREM,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FPTAN,   R_FPTAN,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FRNDINT, R_FRNDINT, FNOARGS,       P86|P186|P286|P386 },
	{ O_FRSTOR,  R_FRSTOR,	FMEM94,        FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSAVE,   R_FSAVE,	FMEM94,    F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSCALE,  R_FSCALE,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FSQRT,   R_FSQRT,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FST,     R_FST,	FMEMSTK,   F_W|P86|P186|P286|P386 },
	{ O_FSTCW,   R_FSTCW,	FMEM2,	   F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSTENV,  R_FSTENV,	FMEM14,    F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSTP,    R_FSTP,	FMEM4810,  F_W|P86|P186|P286|P386 },
	{ O_FSTSW,   R_FSTSW,	FMEM2,	   F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSETPM,  R_FSETPM,	FNOARGS,       (char)(FORCEWAIT|P286|P386|PROT) },
	{ O_FSUB,    R_FSUB,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FSUBP,   R_FSUBP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FSUBR,   R_FSUBR,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FSUBRP,  R_FSUBRP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FTST,    R_FTST,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FWAIT,   R_FWAIT,	FWAIT,	       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FXAM,    R_FXAM,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FXCH,    R_FXCH,	FSTK,	       P86|P186|P286|P386 },
	{ O_FXTRACT, R_FXTRACT, FNOARGS,       P86|P186|P286|P386 },
	{ O_FYL2X,   R_FYL2X,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FYL2XP1, R_FYL2XP1, FNOARGS,       P86|P186|P286|P386 },
	{ O_FNRSTOR, R_FNRSTOR, FMEM94,        P86|P186|P286|P386 },

#ifdef V386
	{ (char)O_MOVSX,   4, 	PMOVX,	       P386 },
	{ (char)O_MOVZX,   4, 	PMOVX,	       P386 },
	{ O_CWDE,    4, 	PNOARGS,       P386 },
	{ O_CDQ,     4, 	PNOARGS,       P386 },
	{ O_LFS,     0, 	PLOAD,	       P386 },
	{ O_LGS,     0, 	PLOAD,	       P386 },
	{ O_LSS,     0, 	PLOAD,	       P386 },
	{ O_SHLD,    0, 	PSHIFT,    F_W|P386 },
	{ O_SHRD,    0, 	PSHIFT,    F_W|P386 },
	{ O_CMPSD,   4, 	PNOARGS,       P386 },
	{ O_INSD,    4, 	PNOARGS,       P386 },
	{ O_LODSD,   4, 	PNOARGS,       P386 },
	{ O_MOVSD,   4, 	PNOARGS,       P386 },
	{ O_OUTSD,   4, 	PNOARGS,       P386 },
	{ O_SCASD,   4, 	PNOARGS,       P386 },
	{ O_STOSD,   4, 	PNOARGS,       P386 },
	{ O_BSF,     0xBC,	PBITSCAN,      P386 },
	{ O_BSR,     0xBD,	PBITSCAN,      P386 },
	{ O_BT,      R_BT,	PBIT,	       P386 },
	{ O_BTC,     R_BTC,	PBIT,	   F_W|P386 },
	{ O_BTR,     R_BTR,	PBIT,	   F_W|P386 },
	{ O_BTS,     R_BTS,	PBIT,	   F_W|P386 },
	{ O_IBTS,    0, 	PNOARGS,       P386 },
	{ O_XBTS,    0, 	PNOARGS,       P386 },
	{ O_JECXZ,   4, 	PRELJMP,       P386 },
	{ O_SETO,    R_SETO,	PSETCC,    F_W|P386 },
	{ O_SETNO,   R_SETNO,	PSETCC,    F_W|P386 },
	{ O_SETB,    R_SETB,	PSETCC,    F_W|P386 },
	{ O_SETNAE,  R_SETNAE,	PSETCC,    F_W|P386 },
	{ O_SETNB,   R_SETNB,	PSETCC,    F_W|P386 },
	{ O_SETAE,   R_SETAE,	PSETCC,    F_W|P386 },
	{ O_SETE,    R_SETE,	PSETCC,    F_W|P386 },
	{ O_SETZ,    R_SETZ,	PSETCC,    F_W|P386 },
	{ O_SETNE,   R_SETNE,	PSETCC,    F_W|P386 },
	{ O_SETNZ,   R_SETNZ,	PSETCC,    F_W|P386 },
	{ O_SETBE,   R_SETBE,	PSETCC,    F_W|P386 },
	{ O_SETNA,   R_SETNA,	PSETCC,    F_W|P386 },
	{ O_SETNBE,  R_SETNBE,	PSETCC,    F_W|P386 },
	{ O_SETA,    R_SETA,	PSETCC,    F_W|P386 },
	{ O_SETS,    R_SETS,	PSETCC,    F_W|P386 },
	{ O_SETNS,   R_SETNS,	PSETCC,    F_W|P386 },
	{ O_SETP,    R_SETP,	PSETCC,    F_W|P386 },
	{ O_SETPE,   R_SETPE,	PSETCC,    F_W|P386 },
	{ O_SETNP,   R_SETNP,	PSETCC,    F_W|P386 },
	{ O_SETPO,   R_SETPO,	PSETCC,    F_W|P386 },
	{ O_SETL,    R_SETL,	PSETCC,    F_W|P386 },
	{ O_SETNGE,  R_SETNGE,	PSETCC,    F_W|P386 },
	{ O_SETC,    R_SETC,	PSETCC,    F_W|P386 },
	{ O_SETNC,   R_SETNC,	PSETCC,    F_W|P386 },
	{ O_SETLE,   R_SETLE,	PSETCC,    F_W|P386 },
	{ O_SETNG,   R_SETNG,	PSETCC,    F_W|P386 },
	{ O_SETNL,   R_SETNL,	PSETCC,    F_W|P386 },
	{ O_SETGE,   R_SETGE,	PSETCC,    F_W|P386 },
	{ O_SETNLE,  R_SETNLE,	PSETCC,    F_W|P386 },
	{ O_SETG,    R_SETG,	PSETCC,    F_W|P386 },
	{ O_PUSHAD,  4, 	PNOARGS,       P386 },
	{ O_POPAD,   4, 	PNOARGS,       P386 },
	{ O_POPFD,   4, 	PNOARGS,       P386 },
	{ O_PUSHFD,  4, 	PNOARGS,       P386 },
	{ O_IRETD,   4, 	PNOARGS,       P386 },

	{ O_FUCOM,   R_FUCOM,	FSTK,	       P386 },
	{ O_FUCOMP,  R_FUCOMP,	FSTK,	       P386 },
	{ O_FUCOMPP, R_FUCOMPP, FNOARGS,       P386 },
	{ O_FPREM1,  R_FPREM1,	FNOARGS,       P386 },
	{ O_FCOS,    R_FCOS,	FNOARGS,       P386 },
	{ O_FSIN,    R_FSIN,	FNOARGS,       P386 },
	{ O_FSINCOS, R_FSINCOS, FNOARGS,       P386 },
#endif
	{ O_RETN,    1, 	PRETURN,       P86|P186|P286|P386 },
	{ O_RETF,    1, 	PRETURN,       P86|P186|P286|P386 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmtabt2.c ===
/* asmtabt2.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmtab.h"	/* common between asmtab.c and asmtabtb.c */

static int pad = 1;	/* to insure non 0 address */

#include "asmkeys.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\asmutl.c ===
/* asmutl.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmindex.h"
#include "asmmsg.h"

extern char *fname;
extern char hexchar[];

/* put a bunch of registers into the symbol table */
VOID initregs(
	struct mreg *makreg
){
	register struct mreg *index;
	register char *p;
	char * savelbufp;

	savelbufp = lbufp;

	for (index = makreg; *index->nm; index++)
	{
		lbufp = index->nm;
		getatom();

		if (symsearch())
			/* register already defined */
			errorn(E_RAD);

		symcreate( M_NOCREF | M_BACKREF | M_DEFINED, REGISTER);
		symptr->offset = index->val;
		symptr->symu.regsym.regtype = index->rt;
		symbolcnt--;
	}
	lbufp = savelbufp;
}



/***	scanorder - process symbol list in order
 *
 *	scanorder (root, fcn);
 *
 *	Entry	root = root of symbol list
 *		fcn = pointer to function to be executed
 *	Exit	none
 *	Returns none
 *	Calls
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma alloc_text (FA_TEXT, scanorder)
#endif

VOID	PASCAL
scanorder (
	SYMBOL FARSYM	  *root,
	SHORT	  (PASCAL *item) (SYMBOL FARSYM *)
){
	register SYMBOL FARSYM *p;

	for (p = root; p; p = p->next) {
		symptr = p;
		(*item) (p);
	}
}


/***	scanSorted - process symbol sorted order
 *
 *	Entry	root = root of symbol list
 *		fcn = pointer to function to be executed
 *	Exit	none
 *	Returns none
 *	Calls
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma alloc_text (FA_TEXT, scanSorted)
#endif

VOID	 PASCAL
scanSorted (
	SYMBOL FARSYM	  *root,
	SHORT	  (PASCAL *item) (SYMBOL FARSYM *)
){
	register SYMBOL FARSYM *p;

	for (p = root; p; p = p->alpha) {
		symptr = p;
		if (!(M_PASSED & p->attr))
			(*item) (p);
	}
}



/***	assignemitsylinknum - assign link number
 *
 *	assignlinknum (sym);
 *
 *	Entry	*sym = symbol
 *	Exit
 *	Returns
 *	Calls
 *	Note	Turn off BACKREF and PASSED bits in symbol attributes and
 *		if symbol is segment, group, public or external give it a
 *		link dictionary number
 */

SHORT	 PASCAL
assignlinknum (
	register SYMBOL FARSYM	*sym
){
	switch (sym->symkind) {

	  case MACRO:	     /* make symbol unknown at start of p2 */
	  case STRUC:
	  case REC:
		sym->attr &= ~M_BACKREF;
		return 0;

	  case SEGMENT:

	    sym->symu.segmnt.lnameIndex = lnameIndex++;
	    goto creatLname;

	  case CLASS:

	    sym->symu.ext.extIndex = lnameIndex++;
	    goto creatLname;

	  /* group indexs holds lname index temporary */

	  case GROUP:
	    sym->symu.grupe.groupIndex = lnameIndex++;

creatLname:
	    emitlname (sym);
	}

	if (sym->symkind == REGISTER)
		sym->attr &= ~(M_PASSED);
	else
		sym->attr &= ~(M_PASSED | M_BACKREF);
    return 0;
}


/***	scansegment - output segment names
 *
 *	scansegment (sym);
 *
 *	Entry	*sym = segment symbol chain
 *	Exit
 *	Returns
 *	Calls
 */

VOID	 PASCAL
scansegment (
	register SYMBOL FARSYM	*sym
){

	if (sym->symu.segmnt.align == (char)-1)
		/* PARA default */
		sym->symu.segmnt.align = 3;

	if (sym->symu.segmnt.combine == 7)
		/* Default no combine */
		sym->symu.segmnt.combine = 0;

	sym->symu.segmnt.lastseg = NULL;

	/* Output segment def */
	emitsegment (sym);

	/*     Clear Offset( current segment PC ) for pass 2 */
	sym->offset = 0;
	sym->symu.segmnt.seglen = 0;
}


/***	scangroup - output group names
 *
 *	scangroup (sym);
 *
 *	Entry	*sym = group chain
 *	Exit
 *	Returns
 *	Calls
 */

SHORT	PASCAL
scangroup (
	SYMBOL FARSYM	  *sym
){
	if (sym->symkind == GROUP)
		emitgroup (sym);
    return 0;
}


/***	scanextern - output external names
 *
 *	scanextern (sym);
 *
 *	Entry	*sym = chain of external names
 *	Exit
 *	Returns
 *	Calls
 */

SHORT	PASCAL
scanextern (
	SYMBOL FARSYM	  *sym
){
	if (M_XTERN & sym->attr)
		emitextern (sym);
    return 0;
}

/***	scanglobal - output global names
 *
 *	scanglobal (sym);
 *
 *	Entry	*sym = chain of external names
 *	Exit
 *	Returns
 *	Calls
 */

SHORT	PASCAL
scanglobal (
	SYMBOL FARSYM	  *sym
){
	if (M_GLOBAL & sym->attr)
		emitglobal (sym);
    return 0;
}



/***	dumpname - output module name
 *
 *	dumpname ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID	PASCAL
dumpname ()
{
	moduleflag = TRUE;

	/* put file name instead of the usual */

	emodule(createname(fname));

}


/***	showresults - display final assembly results
 *
 *	showresults (fil, verbose, mbytes);
 *
 *	Entry	fil = file to print statistics to
 *		verbose = TRUE if all statistics to be displayed
 *			  FALSE if only error messages to be displayed
 *		mbytes = number of free bytes in symbol space
 *	Exit	statistics written to file
 *	Returns none
 *	Calls	fprintf
 */

VOID	 PASCAL
showresults (
	FILE *fil,
	char verbose,
	char *pFreeBytes
){
	if (verbose) {
		fprintf (fil, __NMSG_TEXT(ER_SOU), linessrc, linestot);
		fprintf (fil, __NMSG_TEXT(ER_SY2), symbolcnt);
	}
	fprintf (fil, pFreeBytes);
	fprintf (fil, "%7hd%s\n%7hd%s\n",
		      warnnum, __NMSG_TEXT(ER_EM1),
		      errornum, __NMSG_TEXT(ER_EM2));

#ifdef BUF_STATS
	if (verbose) {

	    extern long DEBUGtl, DEBUGlb, DEBUGbp, DEBUGbl, DEBUGcs, DEBUGca;

	    fprintf (fil, "\nTotal lines:           %ld\n", DEBUGtl);
	    fprintf (fil, "Lines buffered:        %ld\n", DEBUGlb);
	    fprintf (fil, "Stored as blank:       %ld\n", DEBUGbl);
	    fprintf (fil, "Bad lbufp:             %ld\n", DEBUGbp);
	    fprintf (fil, "Total Characters:      %ld\n", DEBUGca);
	    fprintf (fil, "Characters buffered:   %ld\n", DEBUGcs);
	}
#endif

#ifdef EXPR_STATS
	if (verbose) {

	    extern long cExpr, cHardExpr;

	    fprintf(fil, "\nTotal Expressions(%ld), Simple(%ld): %hd%%\n",
		    cExpr, cExpr - cHardExpr, (SHORT)((cExpr - cHardExpr)*100 / (cExpr+1)));
	}
#endif
}

/***	resetobjidx - reset listindex to correct column
 *
 *	resetobjidx ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
resetobjidx ()
{

	listindex = LSTDATA;
	if (!emittext && duplevel)
	    listindex += 3 + ((duplevel <= 8)? duplevel: 8);

	if (highWord(pcoffset))       /* check for 32 bit listing */
	    listindex += 4;

#ifdef BCBOPT
	if (fNotStored)
	    storelinepb ();
#endif

	listline ();
	linebuffer[0] = 0;
}




/***	copyascii - copy ASCII into list buffer
 *
 *	copyascii ();
 *
 *	Entry	objectascii = data to be copied
 *		listindex = position for copy
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
copyascii ()
{
	register char *p2;
	register char *p1;

	if (listindex >= LSTMAX)
		resetobjidx ();

	if (!fNeedList)
		return;

	for (p1 = listbuffer + listindex, p2 = objectascii; *p2; )
		*p1++ = *p2++;
	listindex = (char)(p1 - listbuffer);
}



/***	copystring - copy ASCII into list buffer
 *
 *	copystring ();
 *
 *	Entry	objectascii = data to be copied
 *		listindex = position for copy
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
copystring (
	register char	 *strng
){
	register char *p1;

	if (!fNeedList || fSkipList)
		return;

	goto firstTime;
	while (*strng) {

	    *p1++ = *strng++;

	    if (*strng && ++listindex > LSTMAX + 2) {

		resetobjidx ();
firstTime:
		listindex = 3;
		p1 = listbuffer + 3;
	    }

	}
}


/***	copytext - copy two characters to text line
 *
 *	copytext (chrs)
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
copytext (
	char	*chrs
){
	if (listindex > LSTMAX+1)
		resetobjidx ();


	listbuffer[listindex++] = *chrs++;
	listbuffer[listindex++] = *chrs;
}



/***	pcdisplay - display program counter
 *
 *	pcdisplay();
 *
 *	Entry	pcoffset = value to display
 *	Exit	hex or octal value of pc interted in list buffer
 *	Returns none
 *	Calls	copyascii, wordascii
 */

VOID PASCAL CODESIZE
pcdisplay ()
{

	listindex = 1;
	if (!fNeedList)
		return;

	offsetAscii (pcoffset);

	copyascii ();
	listindex = LSTDATA;

	if (objectascii[4])	/* was a 32bit number */
		listindex += 4;
}



/***	opdisplay - display program counter and opcode
 *
 *	opdisplay(v);
 *
 *	Entry	v = opcode to display
 *	Exit	none
 *	Returns none
 *	Calls
 */


VOID PASCAL CODESIZE
opdisplay (
	UCHAR	v
){
	if (!fNeedList)
		return;

	if (listindex == 1)
		pcdisplay ();

	objectascii[1] = hexchar[v & 0xf];
	objectascii[0] = hexchar[v >> 4];
	objectascii[2] = 0;

	copyascii ();

	listindex++;
}


#ifndef M8086OPT

/***	inset - check for value in a set of values
 *
 *	flag = inset (val, set);
 *
 *	Entry	val = value to check
 *		set = array of values to check for
 *		      set[0] = number of entries in set
 *	Exit	none
 *	Returns TRUE if val is in set
 *		FALSE if val is not in set
 *	Calls
 */

char CODESIZE
inset (
	register char v,
	char *s
){
	register USHORT i;
	register char *p;

	for (i = *s, p = ++s; i; i--)
		if (v == *p++)
			return (TRUE);
	return (FALSE);
}

#endif /* M8086OPT */


/***	outofmem - issue an out of memory error message
 *
 *	outofmem (text);
 *
 *	Entry	*text = text to append to message
 *	Exit	doesn't
 *	Returns none
 *	Calls	endblk, parse
 *	Note	if not end of PROC, parse line as normal.  Otherwise,
 *		terminate block.
 */

VOID	PASCAL
outofmem ()
{
	closeOpenFiles();
	terminate((SHORT)((EX_MEME<<12) | ER_MEM), pFCBCur->fname, (char *)errorlineno, NULL );
}

SHORT PASCAL CODESIZE
tokenIS(
	char *pLiteral
){
    return(_stricmp(naim.pszName, pLiteral) == 0);
}

#ifdef M8086

/***	strnfcpy - copy string to near buffer
 *
 *	strnfcpy (dest, src);
 *
 *	Entry	dest = pointer to near buffer
 *		src = pointer to far source buffer
 *	Exit	source copied to destination
 *	Returns none
 *	Calls	none
 */

VOID	PASCAL
strnfcpy (
	register char	  *dest,
	register char FAR *src
){
	while(*src)
	    *dest++ = *src++;

	*dest = NULL;

}


/***	strflen - compute length of far buffer
 *
 *	strnflen (s1);
 *
 *	Entry	s1 = pointer to far buffer
 *	Exit	none
 *	Returns  number of characters in buffer
 *	Calls	none
 */

USHORT PASCAL
strflen (
	register char FAR *s1
){
	register USHORT i = 0;

	while (*s1++)
		i++;
	return(i);
}

#endif /* M8086 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\fmsghdr.asm ===
title	fmsghdr       - far message header and finder

;--------------------------------------------------------------------------
;
;	Microsoft C Compiler Runtime for MS-DOS
;
;	(C)Copyright Microsoft Corporation, 1986
;
;--------------------------------------------------------------------------
;
;	Revision History
;
;	04/17/86	Randy Nevin (adapted from Greg Whitten's version
;			of nmsghdr.asm)
;
;--------------------------------------------------------------------------


?DF=		1		; this is special for c startup
include version.inc
?PLM=		1		; pascal calling conventions
.xlist
include cmacros.inc
include msdos.inc
.list

createSeg	_TEXT,	code,	byte,	public, CODE,	<>

createSeg	_DATA,	data,	word,	public, DATA,	DGROUP

createSeg	FAR_HDR,fhdr,	byte,	public, FAR_MSG,FMGROUP
createSeg	FAR_MSG,fmsg,	byte,	public, FAR_MSG,FMGROUP
createSeg	FAR_PAD,fpad,	byte,	common, FAR_MSG,FMGROUP
createSeg	FAR_EPAD,fepad,	byte,	common, FAR_MSG,FMGROUP

defGrp	DGROUP			; define DGROUP
defGrp	FMGROUP			; define FMGROUP

codeOFFSET	equ	offset _TEXT:
fmsgOFFSET	equ	offset FMGROUP:


sBegin	fhdr
assumes ds,DGROUP

	db	'<<FMSG>>'
stfmsg	label	byte

sEnd

SBegin	fpad
assumes ds,DGROUP

	dw	-1			; message padding marker

sEnd

sBegin	fepad
assumes ds,DGROUP

	db	-1

sEnd


sBegin	code
assumes cs,code
assumes ds,DGROUP

;------------------------------------------------------------------------
;
;	char far * pascal __FMSG_TEXT ( messagenumber)
;
;	This routine returns a far pointer to the message associated with
;	messagenumber.	If the message does not exist, then a 0:0 is returned.

cProc	__FMSG_TEXT,<PUBLIC>,<ds,si,di>	; pascal calling

parmW	msgt

cBegin
	mov	ax,FMGROUP
	mov	ds,ax			; ds = FMGROUP (force it always)
	push	ds
	pop	es
	mov	dx,msgt 		; dx = message number
	mov	si,fmsgOFFSET stfmsg	; start of far messages

tloop:
	lodsw				; ax = current message number
	cmp	ax,dx
	je	found			;   found it - return address
	inc	ax
	xchg	ax,si
	jz	found			;   at end and not found - return 0
	xchg	di,ax
	xor	ax,ax
	mov	cx,-1
	repne	scasb			; skip until 00
	mov	si,di
	jmp	tloop			; try next entry

found:
	xchg	ax,si
	cwd				; zero out dx in case NULL
	or	ax,ax
	jz	notfound
	mov	dx,ds			; remember segment selector
notfound:
cEnd

sEnd

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\genkey.c ===
#include <stdio.h>
#include <math.h>
#include <string.h>

#define TRUE            (~0)
#define FALSE           0
#define TABLESIZE       1100

struct entry {
        struct entry    *t_link;
        char            *t_name;
        char            *t_lex;
        unsigned short  t_id;
        } *table[TABLESIZE];

FILE            *infile, *outfile;
unsigned short  nsym = 0;
unsigned short  hashstore = TRUE;
unsigned short  f386 = TRUE;

extern char             *_strdup();
extern char             *malloc();
extern unsigned short   hash();
extern unsigned short   atoi();
static                  tfree(); /* defined below */
static struct entry     *talloc(); /* defined below */

/* Local functions */
void s_entries ( struct entry *, char * );
void enter ( char *, char *, unsigned short );

__cdecl main( ac, av )
        int     ac;
        char    **av;
        {
        char            ent[30], name[30], lex[30], ts[30], tc[30];
        unsigned short  size, count;
        register unsigned short i;
        register struct entry   *p;
        struct entry    *q;
        char            *a;
        double          n, j, ssq, sum;

        ac--;
        av++;

        while (**av == '-') {
                ac--;
                a = *av++;

                while (*++a){

                        if (_stricmp(a, "dnoV386") == 0){
                            f386 = FALSE;
                            break;
                        }
                        else
                        if (*a == 'h')
                                hashstore = ~hashstore;
                        else    {
                                fprintf( stderr, "usage: genkey [-dnoV386] [-h] [infile] [outfile]\n" );
                                exit( 1 );
                                }
                }
        }

        if (ac < 1)
                infile = stdin;
        else    {
                ac--;

                if ((infile = fopen( *av++, "r" )) == NULL) {
                        fprintf( stderr, "Cannot open input file %s\n", *--av );
                        exit( 1 );
                        }
                }

        if (ac < 1)
                outfile = stdout;
        else if ((outfile = fopen( *av, "w" )) == NULL) {
                fprintf( stderr, "Cannot open output file %s\n", *av );
                exit( 1 );
                }

#ifdef DEBUG
        setbuf( outfile, NULL );
#endif

        /* copy first line of file */

        do      {
                i = getc( infile );
                putc( i, outfile );
                } while (i != '\n');

        while (fscanf( infile, " %s %s %s\n", tc, ts, name) == 3) {
                count = atoi( tc );
                size = atoi( ts );

#ifdef DEBUG
                printf( "DEBUG: name=%s, size=%u, count=%u\n", name, size, count );
#endif

                for (i = 0; i < TABLESIZE; table[i++] = NULL)
                        ;

                for (i = 0; i < count; i++)
                        if (fscanf( infile, " %s %s\n", ent, lex ) == 2) {

#ifdef DEBUG
                                printf( "DEBUG:  ent=%s, lex=%s\n", ent, lex );
#endif

                                enter( ent, lex, size );
                                }
                        else    {
                                fprintf( stderr, "Error in input file\n" );
                                exit( 1 );
                                }

#ifdef DEBUG
                printf( "DEBUG: finished input loop\n" );
#endif

                print_table( size );

#ifdef DEBUG
                printf( "DEBUG: finished print_table()\n" );
#endif

                print_struct( name, size );

#ifdef DEBUG
                printf("DEBUG: finished print_struct()\n" );
#endif

                n = sum = ssq = 0.0;

                for (i = 0; i < TABLESIZE; i++) {
                        j = 0.0;

                        if (p = table[i]) {
                                n += 1.0;

                                do      {
                                        q = p->t_link;
                                        tfree( p );
                                        j += 1.0;
                                        } while (p = q);

                                sum += j;
                                ssq += j * j;
                                }
                        }

#ifdef DEBUG
                printf( "DEBUG: finished statistics loop\n" );
#endif

                printf( "%6s: Size = %3u,  Buckets = %3u,  Avg = %.2f,  Std = %.2f\n",
                        name, (unsigned short)sum, (unsigned short)n, sum / n,
                        sqrt( (ssq - sum * sum / n) / (n - 1.0) )
                        );

#ifdef DEBUG
                printf( "DEBUG: finished this table; looking for more\n" );
#endif
                }

        exit( 0 );
        }


/****************************************************************/
/*                                                              */
/*      enter : make an ent into the symbol table.              */
/*                                                              */
/****************************************************************/

void enter ( ent, lex, size )
        char            *ent;
        char            *lex;
        unsigned short  size;
        {
        register unsigned short hashval;
        register struct entry   *p;
        int cb;
        int fIs386Only;

        cb = strlen(ent);
        fIs386Only = !strcmp(ent + strlen(ent) - 4, ".386");

        if (!f386 && fIs386Only)
            return;

        if (fIs386Only)
            *(ent + cb - 4) = '\0';

        p = talloc();
        p->t_id = nsym++;
        hashval = hash( ent ) % size;
        p->t_link = table[hashval];
        table[hashval] = p;

        if ((p->t_name = _strdup( ent )) == NULL
                 || (p->t_lex = _strdup( lex )) == NULL)
                memerror();
        }


/****************************************************************/
/*                                                              */
/*      print_table : output the table we have built.           */
/*                                                              */
/****************************************************************/

print_table ( size )
        unsigned short  size;
        {
        register unsigned short i;
        register struct entry   *p;

        fprintf( outfile, "/***\n" );

        for (i = 0; i < size; i++) {
                fprintf( outfile, " *\t[%u]\n", i );

                for (p = table[i]; p; p = p->t_link)
                        fprintf( outfile, " *\t\t%s,\t%s\n", p->t_name,
                                p->t_lex );
                }

        fprintf( outfile, " */\n" );
        }


/****************************************************************/
/*                                                              */
/*      print_struct : print the initialization structures.     */
/*                                                              */
/****************************************************************/

print_struct ( name, size )
        char            *name;
        unsigned short  size;
        {
        register unsigned short i;

        for (i = 0; i < size; i++)
                s_entries( table[i], name );

        s_symbols( name, size );
        s_header( name, size );
        }


/****************************************************************/
/*                                                              */
/*      s_entries : print the symbol names and defs.            */
/*                                                              */
/****************************************************************/

void s_entries ( p, name )
        register struct entry   *p;
        char                    *name;
        {
        struct reverse {
                struct  entry   *actual;
                struct  reverse *next;
                } *head = NULL;
        register struct reverse *q;

        if (!p)
                return;

        while (p) {

/*
**  all definitions must be reversed so that output will be that a
**  unit will be defined before it is used.
*/

                if ((q = (struct reverse *)malloc( sizeof(struct reverse) ))
                         == NULL)
                        memerror();

                q->actual = p;
                q->next = head;
                head = q;
                p = p->t_link;
                }

        for (q = head; q; q = q->next) {
                fprintf( outfile, "static KEYSYM\t%s%u\t= {", name,
                        q->actual->t_id );

                if (hashstore)
                        if (q->actual->t_link)
                                fprintf( outfile, "&%s%u,\"%s\",%u,%s", name,
                                        q->actual->t_link->t_id,
                                        q->actual->t_name,
                                        hash( q->actual->t_name ),
                                        q->actual->t_lex
                                        );
                        else
                                fprintf( outfile, "0,\"%s\",%u,%s",
                                        q->actual->t_name,
                                        hash( q->actual->t_name ),
                                        q->actual->t_lex
                                        );
                else if (q->actual->t_link)
                        fprintf( outfile, "&%s%u,\"%s\",%s", name,
                                q->actual->t_link->t_id, q->actual->t_name,
                                q->actual->t_lex
                                );
                else
                        fprintf( outfile, "0,\"%s\",%s", q->actual->t_name,
                                q->actual->t_lex
                                );

                fprintf( outfile, "};\n" );
                }

        for (q = head; q; head = q) {
                q = q->next;
                free( head );
                }
        }


/****************************************************************/
/*                                                              */
/*      s_symbols : output the structure defining the           */
/*   symbol table.                                              */
/*                                                              */
/****************************************************************/

s_symbols ( name, size )
        char            *name;
        unsigned short  size;
        {
        register unsigned short i;

        fprintf( outfile, "\nstatic KEYSYM FARSYM *%s_words[%u] = {\n", name,
                size );

        for (i = 0; i < size; i++)
                if (table[i])
                        fprintf( outfile, "\t&%s%u%c\n", name, table[i]->t_id,
                                ((i < (size - 1)) ? ',' : ' ') );
                else
                        fprintf( outfile, "\t0%c\n",
                                ((i < (size - 1)) ? ',' : ' ') );

        fprintf( outfile, "\t};\n" );
        }


/****************************************************************/
/*                                                              */
/*      s_header : output the header for the symbol table.      */
/*                                                              */
/****************************************************************/

s_header ( name, size )
        char            *name;
        unsigned short  size;
        {
        fprintf( outfile, "\nKEYWORDS %s_table = {%s_words,%u};\n\n\n",
                name, name, size );
        }


static struct entry *head = NULL;

/****************************************************************/
/*                                                              */
/*      talloc -- allocate space for a table entry              */
/*                                                              */
/****************************************************************/

 static struct entry *
talloc ()
        {
        register struct entry *p;

        if (p = head) {
                head = head->t_link;
                return( p );
                }

        if ((p = (struct entry *)malloc( sizeof(struct entry) )))
                return( p );

        memerror();
        }


/****************************************************************/
/*                                                              */
/*      tfree -- free space for a table entry                   */
/*                                                              */
/****************************************************************/

 static
tfree ( p )
        struct entry *p;
        {
        free( p->t_name );
        free( p->t_lex );
        p->t_link = head;
        head = p;
        }


/****************************************************************/
/*                                                              */
/*      memerr -- ran out of heap space; die                    */
/*                                                              */
/****************************************************************/

memerror ()
        {
        fprintf( stderr, "Out of heap space\n" );
        exit( 1 );
        }


#ifdef XENIX

int _stricmp ( first, last )
        register char *first;
        register char *last;
        {
        register f;
        register l;

        do      {
                if ((f = *first++) >= 'A' && f <= 'Z')
                        f += 'a' - 'A';

                if ((l = *last++) >= 'A' && l <= 'Z')
                        l += 'a' - 'A';
                } while (f && f == l);

        return( f - l );
        }

#endif /* XENIX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\hash.c ===
/*
**	hash : hashes the given string by adding all the chars in the string.
*/

 unsigned short
hash ( name )
	register char *name;
	{
	register unsigned short i = 0;
	register unsigned short c;

	while (c = *name++)
		i += c;

	return( i );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\makefile.inc ===
# This file is for documentation only, no private build tools are used
# anymore for NT. This allows the standard sources file to be used to
# build under any environment including a non-386 processor based one.
#
# Note: These exe's are dependent on slibce being available
# and link.exe being in the path
# Niether of these are part of the standard NT environment.

# makev.exe creates a string containing the current date and time
.\makev.exe: makev.c
	cl -I \nt\public\sdk\inc\cl386 -W3 makev.c -Fe.\makev.exe
	markexe windowcompat makev.exe

#genkey generates the hash tables for the keywords
hash.obj:	hash.c
		cl -c -I \nt\public\sdk\inc\cl386 -W3 hash.c

genkey.obj:	genkey.c
		cl -c -I \nt\public\sdk\inc\cl386 -W3 genkey.c

genkey.exe:	genkey.obj hash.obj
		cl -W3 genkey.obj hash.obj

asmkeys.h:	genkey.exe asmkeys.src
		genkey asmkeys.src $@


# Force an update of version.c and makev.exe if necessary
version: .\makev.exe
    .\makev Microsoft (R) Macro Assembler Version 5.NT.01 > version.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\makev.c ===
/* Creat a version string with the current data/time stamp
   suitable for compiling */

/* Modified 9/13/90 to produce a C source file rather than a MASM   *
 * source file. (Thereby making it target indepedent)               */

#include <stdio.h>
#include <time.h>

__cdecl main(argc, argv)
char **argv;
{
        long theTime;
        char *pszTime;

        time(&theTime);
        pszTime = (char *) ctime(&theTime);
        pszTime[24] = 0;
        pszTime += 4;

        printf("char version[] = \"@(#) ");

        while (--argc > 0)
            printf("%s ", *(++argv));

        printf("%s\";\n", pszTime);

        return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\masm386.c ===
/* asmmain.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#ifndef FLATMODEL
#include <signal.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>

#define ASMGLOBAL
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include <fcntl.h>
#include <time.h>

#ifdef MSDOS
# include <dos.h>
# include <share.h>
# include <io.h>
# if defined CPDOS && !defined OS2_2
#  include <doscalls.h>
# endif
#endif

//extern char *strrchr();
//extern char *strchr();

#include "asmmsg.h"

static VOID panic();     /* defined below */

long farAvail(void);

#if defined MSDOS  && !defined FLATMODEL
 UCHAR * PASCAL ctime();
#else
// extern long time();        /* Use C library functions */
// extern UCHAR *ctime();
// extern long _lseek();
#endif /* MSDOS */


#if defined M8086OPT
 extern char qlcname[];         /* defined in asmhelp.asm */
 extern char qname[];           /* defined in asmhelp.asm */
 extern char qsvlcname[];       /* defined in asmhelp.asm */
 extern char qsvname[];         /* defined in asmhelp.asm */
 UCHAR           *naim = qname;
 UCHAR           *svname = qsvname;
#else
 static UCHAR qname[SYMMAX + 1];
 static UCHAR qlcname[SYMMAX + 1];
 static UCHAR qsvname[SYMMAX + 1];
 static UCHAR qsvlcname[SYMMAX + 1];
 FASTNAME       naim =   {qname, qlcname, 0, 0};
 FASTNAME       svname = {qsvname, qsvlcname, 0, 0};
#endif


UCHAR           X87type;
char            *argv0;
char            *atime;
char            *begatom;
char            addplusflagCur;
char            ampersand;
char            baseName[25] = "@FileName=";
USHORT          blocklevel;
char            caseflag = DEF_CASE;
char            checkpure;              /* do checks for pure code? */
OFFSET          clausesize;
char            condflag;
USHORT          condlevel;              /* conditional level */
USHORT          count;
UCHAR           cputype = DEF_CPU;
SHORT           wordszdefault = 2;

#ifdef V386
SHORT           wordsize = 2;           /* preprocessor constant in other ver */
#endif

OFFSET          cbProcParms;
OFFSET          cbProcLocals;
USHORT          crefcount;
UCHAR           crefinc;
UCHAR           cpu;
char            crefopt = 0;
char            crefing = DEF_CREFING;
char            crefnum[CREFINF] = {
                        /* CREFEND */   4,      /* End of line */
                        /* REF     */   1,      /* Reference */
                        /* DEF     */   2       /* Define */
                };
UCHAR           creftype;
struct fileptr  crf;
SYMBOL FARSYM   *curgroup;

USHORT codeview;                        /* codeveiw obj level = 0 => CVNONE */

PFPOSTRUCT  pFpoHead = 0;
PFPOSTRUCT  pFpoTail = 0;
unsigned long numFpoRecords = 0;

#ifdef DEBUG
 FILE           *d_df;
 long           d_debug = 0;            /* debug selection */
 long           d_dlevel = 0;           /* debug level selection */
 long           d_indent = 0;           /* debug output indention count */
 long           d_sindent = 0;          /* indentation printing temporary */
#endif /* DEBUG */

/* note that TDW has to be last */
USHORT          datadsize[TMACRO - TDB + 1] = {
                        /* TDB */       1,
                        /* TDD */       4,
                        /* TDQ */       8,
                        /* TDT */       10,
                        /* TDF */       6,
                        /* TDW */       2,
                        /* TMACRO */    0
                };
char            debug = DEF_DEBUG;      /* true if debug set */
UCHAR           delim;
char            displayflag;
char            dumpsymbols = DEF_DUMPSYM; /* symbol table display if true */
char            dupflag;
USHORT          duplevel;               /* indent for dup listing */
char            elseflag;
char            emittext = TRUE;        /* emit linker text if true */
struct dscrec   emptydsc;
char            emulatethis;
char            *endatom;
char            endbody;
char            equdef;
char            equflag;
char            equsel;
SHORT           errorcode;
USHORT          errorlineno;
USHORT          errornum;           /* error count */
char            exitbody;
char            expandflag;
USHORT          externnum = 1;
SYMBOL FARSYM   *firstsegment;
UCHAR           fixvalues[] = {
                        /* FPOINTER */  3,
                        /* FOFFSET */   1,
                        /* FBASESEG */  2,
                        /* FGROUPSEG */ 1,
                        /* FCONSTANT */ 0,
                        /* FHIGH */     4,
                        /* FLOW */      0,
                        /* FNONE */     0,
                        /* F32POINTER*/ 11,
                        /* F32OFFSET */ 9,
                        /* DIR32NB */   14,
                };

char            fDosSeg;
char            fSimpleSeg;
char            fCheckRes;
UCHAR           fCrefline;
char            fSecondArg;
char            f386already;
char            fArth32;
char            fProcArgs;

struct dscrec   *fltdsc;
char            fltemulate = DEF_FLTEMULATE;
USHORT          fltfixmisc[9][2] = {    /* fixup characters */
                        'E', 0, 'C', 0, 'S', 0, 'A', 0, 'C', 0,
                        'S', 0, 'A', 0, 'D', 0, 'W', 0
                };
USHORT          fltselect[4][2] = {
                        /* [TDD][0] */  5,      /* Single precision non IEEE */
                        /* [TDD][1] */  3,      /* Single precision IEEE */
                        /* [TDQ][0] */  4,      /* Double precision non IEEE */
                        /* [TDQ][1] */  2,      /* Double precision IEEE */
                        /* [TDT][0] */  1,      /* No temp real - use double */
                        /* [TDT][1] */  1       /* 80 bit precision IEEE */
                };
char            *fname;
UCHAR           fKillPass1;
UCHAR           fPutFirstOp;
char            fSkipList;
USHORT          fPass1Err;
jmp_buf         forceContext;
char            generate;
USHORT          groupnum = 1;
char            impure;
USHORT          iProcCur;
USHORT          iProc;
char            inclcnt = 1;
char            inclFirst = 1;
char            *inclpath[INCLUDEMAX+1];
char            initflag;
struct dscrec   *itemptr;
SHORT           iRegSave;
char            labelflag;
USHORT          lastcondon;
SHORT           handler;
char            lastreader;
SYMBOL FARSYM   *lastsegptr;
SHORT           langType;
char            lbuf[LBUFMAX + 1];
char            *lbufp;
char            *linebp;
char            linebuffer[LBUFMAX + 1];
UCHAR           linelength;             /* length of line */
long            linessrc;
long            linestot;
char            listbuffer[LISTMAX + 10] = "                                ";
char            listconsole = DEF_LISTCON;
char            listed;
char            listflag;
char            listindex;
char            listquiet;
USHORT          lnameIndex = 2;
char            loption = 0;            /* listion option from command line */
USHORT          localbase;
char            localflag;
struct fileptr  lst;
char            lsting = DEF_LSTING;
USHORT          macrolevel;
SYMBOL FARSYM   *macroptr;
SYMBOL FARSYM   *macroroot;

/* reg initialization data */
struct mreg makreg[] = {
                { "CS", SEGREG, 1 },
                { "DS", SEGREG, 3 },
                { "ES", SEGREG, 0 },
                { "SS", SEGREG, 2 },
                { "AX", WRDREG, 0 },
                { "CX", WRDREG, 1 },
                { "DX", WRDREG, 2 },
                { "AL", BYTREG, 0 },
                { "BL", BYTREG, 3 },
                { "CL", BYTREG, 1 },
                { "DL", BYTREG, 2 },
                { "AH", BYTREG, 4 },
                { "BH", BYTREG, 7 },
                { "CH", BYTREG, 5 },
                { "DH", BYTREG, 6 },
                { "BX", INDREG, 3 },
                { "BP", INDREG, 5 },
                { "SI", INDREG, 6 },
                { "DI", INDREG, 7 },
                { "SP", WRDREG, 4 },
                { "ST", STKREG, 0 },
                        0
        };

#ifdef V386

struct mreg mak386regs[] = {
                        { "FS", SEGREG, 4 },
                        { "GS", SEGREG, 5 },
                        { "EAX", DWRDREG, 0 },
                        { "ECX", DWRDREG, 1 },
                        { "EDX", DWRDREG, 2 },
                        { "EBX", DWRDREG, 3 },
                        { "EBP", DWRDREG, 5 },
                        { "ESI", DWRDREG, 6 },
                        { "EDI", DWRDREG, 7 },
                        { "ESP", DWRDREG, 4 },
                        0
        };

struct mreg mak386prot[] = {
                        { "CR0", CREG, 0 },
                        { "CR2", CREG, 2 },
                        { "CR3", CREG, 3 },

                        { "DR0", CREG, 010 },
                        { "DR1", CREG, 011 },
                        { "DR2", CREG, 012 },
                        { "DR3", CREG, 013 },
                        { "DR6", CREG, 016 },
                        { "DR7", CREG, 017 },

                        { "TR6", CREG, 026 },
                        { "TR7", CREG, 027 },
                        0
                };
#endif /* V386 */

UCHAR           modrm;
char            moduleflag;
long            memEnd;
USHORT          memRequest = 0xFFFF;
NAME FAR        *modulename;

USHORT          nearMem;
USHORT          nestCur;
USHORT          nestMax;
USHORT          nearMem;
UCHAR           nilseg;
char            noexp;
char            objectascii[9];
char            objing = DEF_OBJING;
long            oEndPass1;
UCHAR           opcbase;
char            opctype;
USHORT          operprec;
char            opertype;
char            opkind;
char            optyp;
char            opcref;
char            origcond = DEF_ORIGCON;
USHORT          pagelength;
USHORT          pageline;
short           pagemajor;
short           pageminor;
USHORT          pagewidth;
char            pass2 = FALSE;          /* true if in pass 2 */
OFFSET          pcmax;
OFFSET          pcoffset;
SYMBOL FARSYM   *procStack[PROCMAX];
short           iProcStack = 0;
SYMBOL FARSYM   *pcproc;
SYMBOL FARSYM   *pcsegment;
SYMBOL FARSYM   *pProcCur;
SYMBOL FARSYM   *pProcFirst;
SYMBOL FARSYM   *pStrucCur;
SYMBOL FARSYM   *pStrucFirst;
TEXTSTR FAR     *pLib;
MC              *pMCur;
char            popcontext;
char            radix;                  /* assumed radix base */
char            radixescape;
SYMBOL FARSYM   *recptr;
SYMBOL FARSYM   *regsegment[6]; /* 386 has 6 segments.  -Hans */
struct dscrec   *resptr;
char            regSave[8][SYMMAX+1];
char            resvspace;
char            save[LBUFMAX];
char            segalpha = DEF_SEGA;    /* true if segment output in alpha order */
USHORT          segidx = 0;
USHORT          segmentnum = 1;
char            segtyp;
struct dscrec   *startaddr;
struct duprec   FARSYM *strclastover;
char            strucflag;
SYMBOL FARSYM   *struclabel;
struct duprec   FARSYM *strucoveride;
struct duprec   FARSYM *strucprev;
SYMBOL FARSYM   *strucroot;
char            subttlbuf[TITLEWIDTH + 1];
char            swaphandler;
short           symbolcnt;
SYMBOL FARSYM   *symptr;
SYMBOL FARSYM   *symroot[MAXCHR];
SYMBOL FARSYM   *pFlatGroup = (SYMBOL FARSYM *)-1;
char            titlebuf[TITLEWIDTH + 1];
char            titleflag;
char            titlefn[TITLEWIDTH + 1];
USHORT          tempLabel;
char            terse;
USHORT          typeIndex = 514;        /* structure/record types */
extern char     version[];

char            unaryset[] = { 15,
                        OPLENGTH, OPSIZE, OPWIDTH, OPMASK,
                        OPOFFSET, OPSEG, OPTYPE, OPSTYPE,
                        OPTHIS, OPHIGH, OPLOW, OPNOT,
                        OPSHORT, OPLPAR, OPLBRK
                };
OFFSET          val;
USHORT          varsize;
char            verbose = DEF_VERBOSE;
USHORT          warnnum;                /* warning count */
USHORT          warnlevel = 1;          /* warning level */
USHORT          warnCode;
char            xcreflag;

/* Array to convert symbol kind to bits in RESULT record */

USHORT          xltsymtoresult[13] = {
                        /* SEGMENT      */  1 << SEGRESULT,
                        /* GROUP        */  1 << SEGRESULT,
                        /* CLABEL       */  0,
                        /* PROC         */  1 << CODE,
                        /* REC          */  1 << RCONST,
                        /* STRUC        */  (1 << RCONST)|(1 << STRUCTEMPLATE),
                        /* EQU          */  1 << RCONST,
                        /* DVAR         */  1 << DATA,
                        /* CLASS        */  0,
                        /* RECFIELD     */  1 << RCONST,
                        /* STRUCFIELD   */  1 << RCONST,
                        /* MACRO        */  0,
                        /* REGISTER     */  1 << REGRESULT
                };
char xoptoargs[OPCODPARSERS] = {
                        /* PGENARG      */      TWO,
                        /* PCALL        */      ONE,
                        /* PJUMP        */      ONE,
                        /* PSTACK       */      ONE,
                        /* PRETURN      */      MAYBE,
                        /* PRELJMP      */      ONE,
                        /* PNOARGS      */      NONE,
                        /* PREPEAT      */      NONE,
                        /* PINCDEC      */      ONE,
                        /* PINOUT       */      TWO,
                        /* PARITH       */      ONE,
                        /* PESC         */      TWO,
                        /* PXCHG        */      TWO,
                        /* PLOAD        */      TWO,
                        /* PMOV         */      TWO,
                        /* PSHIFT       */      TWO,
                        /* PXLAT        */      MAYBE,
                        /* PSTR         */      VARIES,
                        /* PINT         */      ONE,
                        /* PENTER       */      TWO,
                        /* PBOUND       */      TWO,
                        /* PCLTS        */      NONE,
                        /* PDESCRTBL    */      ONE,
                        /* PDTTRSW      */      ONE,
                        /* PARSL        */      TWO,
                        /* PARPL        */      TWO,
                        /* PVER         */      ONE,
                        /* PMOVX        */      TWO,
                        /* PSETCC       */      ONE,
                        /* PBIT         */      TWO,
                        /* PBITSCAN     */      TWO,
                };

UCHAR xoptoseg[] = {
                        /* PGENARG      */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PCALL        */      1 << FIRSTDS,
                        /* PJUMP        */      1 << FIRSTDS,
                        /* PSTACK       */      1 << FIRSTDS,
                        /* PRETURN      */      0,
                        /* PRELJMP      */      0,
                        /* PNOARGS      */      0,
                        /* PREPEAT      */      0,
                        /* PINCDEC      */      1 << FIRSTDS,
                        /* PINOUT       */      0,
                        /* PARITH       */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PESC         */      1 << SECONDDS,
                        /* PXCHG        */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PLOAD        */      1 << SECONDDS,
                        /* PMOV         */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PSHIFT       */      1 << FIRSTDS,
                        /* PXLAT        */      1 << FIRSTDS,
                        /* PSTR         */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PINT         */      0,
                        /* PENTER       */      0,
                        /* PBOUND       */      1 << SECONDDS,
                        /* PCLTS        */      0,
                        /* PDESCRTBL    */      1 << FIRSTDS,
                        /* PDTTRSW      */      1 << FIRSTDS,
                        /* PARSL        */      1 << SECONDDS,
                        /* PARPL        */      1 << FIRSTDS,
                        /* PVER         */      1 << FIRSTDS,
                        /* PMOVX        */      1 << SECONDDS,
                        /* PSETCC       */      1 << FIRSTDS,
                        /* PBIT         */      1 << FIRSTDS,
                        /* PBITSCAN     */      1 << SECONDDS,
                        /* empty slots  */      0,0,0,0,0,0,

                        /* FNOARGS      */      0,
                        /* F2MEMSTK     */      1 << FIRSTDS,
                        /* FSTKS        */      0,
                        /* FMEMSTK      */      1 << FIRSTDS,
                        /* FSTK         */      0,
                        /* FMEM42       */      1 << FIRSTDS,
                        /* FMEM842      */      1 << FIRSTDS,
                        /* FMEM4810     */      1 << FIRSTDS,
                        /* FMEM2        */      1 << FIRSTDS,
                        /* FMEM14       */      1 << FIRSTDS,
                        /* FMEM94       */      1 << FIRSTDS,
                        /* FWAIT        */      0,
                        /* FBCDMEM      */      1 << FIRSTDS,
                };

char segName[8+31] = "@CurSeg=";


OFFSET  CondJmpDist;            /* conditional jump distance (for error) */

 struct objfile obj;
 SHORT  objerr = 0;
 USHORT         obufsiz = DEF_OBJBUFSIZ;

#ifdef BCBOPT
 BCB * pBCBAvail = NULL; /* List of deallocatable file buffers */
 FCB * pFCBInc = NULL;   /* Next include file */
 UCHAR fBuffering = TRUE; /* TRUE if storing lines for pass 2 */
 UCHAR fNotStored = FALSE;/* == TRUE when lbuf contains valid line to save */
#endif
 FCB * pFCBCur = NULL;   /* Current file being read */
 FCB * pFCBMain;         /* main file */
 char  srceof;           /* EOF flag for source reads */

#ifndef XENIX286
 static SHORT PASCAL nulname(char *);   /* defined below */
 static SHORT PASCAL conname(char *);   /* defined below */
 extern char *file[];
#endif /* XENIX286 */

#ifdef CPDOS
 extern unsigned _osmode;
#endif


/***    main - main routine for assembler
 *
 */


VOID main (ac, av)
int ac;
char **av;
        {
        char *p;
        SHORT i;

#ifdef MSDOS
# ifdef FLATMODEL
//#   pragma message("signals don't work")
# else
        signal( SIGINT, panic );
# endif
#else
        if (signal( SIGINT, SIG_IGN ) != SIG_IGN)
                /* don't panic() if we're in the background */
                signal( SIGINT, panic );
#endif /* MSDOS */

        initregs(makreg);
        makedefaultdsc();
        argv0 = av[0];

#ifdef MSGISOL0

        strcpy( titlefn, __NMSG_TEXT(ER_TIT) );
#else

#ifndef RELEASE
// version string nolonger has a date to trim off
//      version[strlen(version) - 20] = NULL;    /* Trim date off */
#endif

        strncpy(titlefn, &version[5], TITLEWIDTH-3);
        i = (SHORT) strlen(titlefn);
        memset(&titlefn[i], ' ', TITLEWIDTH-2 - i);
#endif


#ifndef XENIX286

        sprintf(&save[256], __NMSG_TEXT(ER_COP), &version[5]);

        UserInterface( ac, av, &save[256] );
        fname = file[0];
#else
        ac--;
        av++;

        while (**av == '-') {
                ac--;
                nextarg( *av++ );
                }

        if (ac-- < 1)
                usage( EX_NONE );

        fname = *av;
#endif /* XENIX286 */

        initproc();
        dopass();

        listopen();         /* List unterminated blocks */
        dumpCodeview();     /* output symbols in speical segments for codeview */


        if (crefing == CREF_SINGLE) {

            fprintf( crf.fil, "\7%c%c", pagelength, pagewidth );

            if (titleflag)
                    fprintf( crf.fil, "\6%s", titlebuf );

            fprintf( crf.fil, "\x8%s", pFCBCur->fname);
        }

        /* Output end of pass 1 linker information */
        creftype = CREFEND;

        if (!moduleflag)
                dumpname();

        /* Output end pass 1 symbol table to linker */

        /* Assign link #s and clear bit */
        scansymbols(assignlinknum);

        /* Output segment definitions */
        while (firstsegment) {
                scansegment( firstsegment );
                firstsegment = firstsegment->symu.segmnt.segordered;
        }

        scansymbols(scangroup);     /* Emit group defs */
        scansymbols(scanextern);    /* Emit extern defs */
        emitFpo();
        scansymbols(scanglobal);    /* Emit global defs */
        emitEndPass1();             /* Emit end of pass1 OMF record */

        /* do pass 2 */
        pass2 = TRUE;
        pFCBCur = pFCBMain;
#ifdef BCBOPT
        pFCBInc = pFCBMain;
        fNotStored = FALSE;
        pFCBCur->pBCBCur = pFCBCur->pBCBFirst;
        pFCBCur->pbufCur = pFCBCur->pBCBCur->pbuf;
        pFCBCur->pBCBCur->fInUse = 1;
#endif
        pFCBCur->ptmpbuf = pFCBCur->buf;
        pFCBCur->line = 0;
        pFCBCur->ctmpbuf = 0;
        if (_lseek(pFCBCur->fh, 0L, 0 ) == -1)
            TERMINATE1(ER_ULI, EX_UINP, fname);

        dopass();
        dumpCodeview();                     /* write codeview symbols */

        /* List unterminated blocks */

        listopen();

        if (lsting && dumpsymbols) {

            scansymbols(sortalpha);

            pagemajor = 0;
            pageminor = 0;
            pageline = pagelength - 1;

            /* Suppress SUBTTL listing */
            subttlbuf[0] = '\0';

            /* List out all macro names */
            listed = FALSE;
            scanSorted( macroroot, macrolist );

            /* List out records/structures */
            listed = FALSE;
            scanSorted( strucroot, struclist );

            /* List out segments and groups */
            seglist();

            /* List remaining symbols out */
            symbollist();

        }

        emitFpo();
        emitdone( startaddr );              /* Emit end of object file */

#if !defined(FLATMODEL)   /* In flat model don't display heap space available */
# if defined(CPDOS) || defined(XENIX286)

        sprintf(lbuf, "\n%7u %s\n", _freect( 0 ) << 1,
                __NMSG_TEXT(ER_BYT));
# else

        if (!terse || lsting + warnnum + errornum){

            nearMem = _freect(0) << 1;
            memEnd = farAvail();

            while(memRequest > 1024)
                if(_fmalloc(memRequest))
                    memEnd += memRequest;
                else
                    memRequest >>= 1;

            memEnd -= nearMem;
            if (memEnd < 0)
                memEnd = 0;

            sprintf(lbuf, "\n%7u + %ld %s\n", nearMem, memEnd,
                         __NMSG_TEXT(ER_BYT));
        }
# endif
#else

        lbuf[0] = '\0';    /* Null string for symbol space free */

#endif /* FLATMODEL */

#ifdef MSDOS
        _flushall();
#endif

        /* Put # errors in listing */
        if (lsting){

#ifdef MSDOS
            _setmode( _fileno(lst.fil), O_TEXT );
#endif
            if (pagelength - pageline < 12)
                pageheader ();

            showresults( lst.fil, TRUE, lbuf );
        }

        /* List # errors and warnings to console */
        if (!listquiet)
                if (!terse || warnnum || errornum)
                        showresults( stdout, verbose, lbuf );

        if (crefing)
                /* Flag end of cref info */
                fprintf( crf.fil, "\5" );


        if (objing) {
# if defined MSDOS && !defined FLATMODEL
                farwrite( obj.fh, obj.buf, obj.siz - obj.cnt );
# else
                if (_write( obj.fh, obj.buf, obj.siz - obj.cnt )
                        != obj.siz - obj.cnt)
                        objerr = -1;
# endif /* MSDOS */

                if (fKillPass1){        /* extrn happened on pass 2 */

                    /* over write linker comment record */

                    i = (SHORT)(0xd2<<8 | 0);
                    if (_lseek(obj.fh, oEndPass1, 0 ) == -1)
                        TERMINATE1(ER_ULI, EX_UINP, fname);
#if defined MSDOS && !defined FLATMODEL
                    farwrite( obj.fh, (UCHAR FAR *)&i, 2);
#else
                    _write( obj.fh, (UCHAR *)&i, 2);
#endif
                }

                _close( obj.fh );
                }

        if (objing && (objerr))
                fprintf(ERRFILE,__NMSG_TEXT(ER_WEO) );

        if (objing && (errornum || objerr))
                _unlink( obj.name );

        if (lsting && ferror(lst.fil))
                fprintf(ERRFILE,__NMSG_TEXT(ER_WEL) );

        if (crefing && ferror(crf.fil)) {
                fprintf(ERRFILE,__NMSG_TEXT(ER_WEC) );
                _unlink( crf.name );
        }

        if (errornum)
            exit( EX_ASME );
        else
            exit( EX_NONE );
}



VOID PASCAL CODESIZE
getincenv ()
{
#ifdef MSDOS
    char   *pchT;
    char    pathname[128];
    char   *getenv();
    char   *env = NULL;
#endif

    if (inclcnt < INCLUDEMAX - 1)
        inclpath[inclcnt++] = _strdup("");

#ifdef MSDOS

    if (!(env = getenv("INCLUDE")))
        return;

    while (*env==';')
        env++;

    while (*env && (inclcnt < INCLUDEMAX - 1)) {
        pchT = pathname;

        while(*env && *env!=';') {

            if (*env == ALTPSEP) {
                *pchT++ = PSEP;
                env++;
            } else
                *pchT++ = *env++;
        }

        if (*(pchT-1) != PSEP)
            *pchT++ = PSEP;
        *pchT = '\0';

        while (*env == ';')
            env++;

        inclpath[inclcnt++] = _strdup(pathname);
    }

#endif /* MSDOS */

}

VOID PASCAL
initproc ()
{
    register char *p;
    char c;
    struct mreg *index;
    time_t gmttime;
    long filelen;
    char * q;

#ifdef DEBUG
    if (d_debug)
        if (!(d_df = fopen("asm.trace", "w"))) {
            fprintf (ERRFILE, "Unable to open trace output file\n");
            d_debug = 0;
        }
#endif

    if (!(pFCBCur = (FCB *) malloc(sizeof(FCB) + strlen(fname) + 1)))
        memerror( "main file FCB" );

    pFCBMain = pFCBCur;

#ifdef BCBOPT
    pFCBInc = pFCBMain;
    pFCBCur->pFCBNext = NULL;
#endif
    pFCBCur->pFCBParent = NULL;
    pFCBCur->pFCBChild = NULL;
    strcpy(pFCBCur->fname, fname);

#ifdef XENIX286
    if ((pFCBCur->fh = _open(fname, TEXTREAD)) == -1)
#else
    if ((pFCBCur->fh = _sopen(fname, O_RDONLY | O_BINARY, SH_DENYWR)) == -1)
#endif
        TERMINATE1(ER_UOI, EX_UINP, fname);

    if ((filelen = _lseek(pFCBCur->fh, 0L, 2 )) == -1L)
        TERMINATE1(ER_ULI, EX_UINP, fname);

    /* go back to beginning */
    if (_lseek(pFCBCur->fh, 0L, 0 ) == -1)
        TERMINATE1(ER_ULI, EX_UINP, fname);

    pFCBCur->ctmpbuf = 0;
    pFCBCur->cbbuf = DEF_SRCBUFSIZ * 1024;

    if (filelen < DEF_SRCBUFSIZ * 1024)
        pFCBCur->cbbuf = (USHORT)filelen + 2;

/* Allocate line buffer for main file */
#ifdef XENIX286
    pFCBCur->ptmpbuf = pFCBCur->buf = malloc(pFCBCur->cbbuf);
#else
    pFCBCur->ptmpbuf = pFCBCur->buf = _fmalloc(pFCBCur->cbbuf);
#endif

    if (!pFCBCur->ptmpbuf)
        memerror ( "main file buf");

#ifdef BCBOPT
    pFCBCur->pBCBFirst = pBCBalloc(pFCBCur->cbbuf);
    pFCBCur->pBCBCur = pFCBCur->pBCBFirst;
#endif
    pFCBCur->line = 0;

    p = fname;

    if (q = strrchr( p, PSEP ))
        p = ++q;

    if (q = strrchr( p, ALTPSEP ))
        p = ++q;

    if (!LEGAL1ST(*p))
        baseName[10] = '_';

    strcat(baseName, p);

    /* put ..\sourceFile at the head of the include paths */

    if (fname[0] == '.' && fname[1] == '.') {

        *--p = NULL;
        inclpath[0] = (char *) _strdup(fname);
        *p = PSEP;
        inclFirst--;
    }

    if (p = strchr( baseName, '.' ))
            *p = '\0';

    /* map legal files names into legal idents */

    for (p = &baseName[11]; *p; p++)
        if (!TOKLEGAL(*p))
            *p = '_';

    getincenv();            /* get INCLUDE environment variable paths */

#ifdef XENIX286

    if (lsting) {

        if (!lst.name)
            lst.name = _strdup( strcat( strcpy( save, &baseName[10] ), LST_EXT ));
            if (!lst.name)
                memerror( "lst-name" );
#else
    if (file[2] && !nulname( file[2] )) {
        lsting = TRUE;

        lst.name = _strdup( file[2] );
        if (!lst.name)
            memerror( "lst-name" );

#endif /* XENIX286 */

#ifdef XENIX286
        if (*(lst.name) == '-') {
#else
        if (conname( lst.name )) {
#endif
            lst.fil = stdout;
            verbose = listconsole = FALSE;
            listquiet = TRUE;
        }
        else if (!(lst.fil = fopen( lst.name, "w" BINSTDIO)))
            TERMINATE1(ER_UOL, EX_ULST, lst.name);

        setvbuf(lst.fil, malloc(BUFSIZ*4), _IOFBF, BUFSIZ*4);
    }

#ifdef XENIX286
    if (objing) {
#else
    if (file[1] && !nulname( file[1] )) {
#endif


#ifdef XENIX286
        if (!obj.name)
            obj.name = _strdup( strcat( strcpy( save, &baseName[10] ), OBJ_EXT ));
            if (!obj.name)
                memerror( "obj-name" );
#else
        obj.name = _strdup( file[1] );
        if (!obj.name)
            memerror( "obj-name" );
#endif
        /* let the file be read or overwritten by anybody, like
         * other utilities.  -Hans */

        if ((obj.fh = _open( obj.name, BINOPEN, 0666)) == -1)
            TERMINATE1(ER_UOO, EX_UOBJ, obj.name );

        obj.cnt = obj.siz = obufsiz << 10;
#ifdef XENIX286
        if (!(obj.pos = obj.buf = malloc( obj.cnt)))
#else
        if (!(obj.pos = obj.buf = _fmalloc( obj.cnt)))
#endif
            memerror( "main-obj buffer" );
    }

#ifndef XENIX286
    else
        objing = FALSE;

    if (file[3] && !nulname( file[3] ))
        crefing = CREF_SINGLE;
#endif

    if (crefing) {
#ifdef XENIX286

        crf.name = _strdup( strcat( strcpy( save, &baseName[10] ), ".crf" ));
#else
        crf.name = _strdup( file[3] );
#endif

        if (!(crf.fil = fopen( crf.name, "w" BINSTDIO )))
                TERMINATE1(ER_UOC, EX_UCRF, crf.name );
    }


    lbufp = strcpy( lbuf, titlefn );
    storetitle( titlefn );

    memset(titlebuf, ' ', TITLEWIDTH);

    /* get date and time of assembly */
#if defined MSDOS && !defined FLATMODEL
    atime = ctime();        /* ctime() is defined below */
#else
    gmttime = time( NULL );
    atime = ctime( &gmttime );
#endif /* MSDOS */

    definesym(baseName);    /* define @FileName & @WordSize */
    defwordsize();
}




#ifdef V386

VOID init386(
        short prot
){
        if (!f386already)
        {
                initregs(mak386regs);
                f386already = 1;
        }
        if (prot && f386already<2)
        {
                initregs(mak386prot);
                f386already = 2;
        }
}

#endif

#ifdef XENIX286

/***    nextarg - scan next argument string and set parameters
 *
 *      nextarg (p);
 *
 *      Entry   p = pointer to argument string
 *      Exit    parameters set
 *      Returns none
 *      Calls   malloc
 */

VOID PASCAL
nextarg (
register char *p
){
    register char cc, *q;
    SHORT i;

    while (cc = *++p)
        switch (cc) {
            case 'a':
                    segalpha = TRUE;
                    break;
            case 'b':
                    p++;

                    while(isdigit(p[1])) p++;
                    break;
            case 'c':
                    crefing = CREF_SINGLE;
                    break;
            case 'C':
                    crefing = CREF_MULTI;
                    break;
            case 'd':
                    debug = TRUE;
                    break;
            case 'D':
                    p++;
                    for (q = p; *q && !isspace( *q ); q++);
                    cc = *q;
                    *q = '\0';
                    definesym(p);
                    if (errorcode)
                                if (errorcode){
                                    error_line (ERRFILE, "command line", 0);

                                    if (errornum)
                                        exit (EX_DSYM);
                                }
                    *q = cc;
                    p = q - 1;
                    break;

            case 'e':
                    fltemulate = TRUE;
                    X87type = PX287;
                    break;
            case 'h':
                    farPuts(stdout, __FMSG_TEXT(ER_HXUSE));
                    putchar('\n');
                    for (i = ER_H01; i <= ER_H18; i++){

                        putchar('-');
                        farPuts(stdout, __FMSG_TEXT(i));
                        putchar('\n');

                    }

                    exit( 0 ); /* let him start again */

            case 'I':
                    if (!*++p || isspace( *p ))
                        TERMINATE(ER_PAT, EX_ARGE);

                    if (inclcnt < INCLUDEMAX - 1)
                        inclpath[inclcnt++] = p;

                    p += strlen( p ) - 1;
                    break;

            case 'L':
                    loption++;

            case 'l':
                    lsting = TRUE;

                    if (p[1]) {  /* listing file name specified */

                        lst.name = _strdup( p+1 );
                        p += strlen( p ) - 1;
                        }

                    break;
            case 'M':
                    switch (*++p) {
                        case 'l':
                                caseflag = CASEL;
                                break;
                        case 'u':
                                caseflag = CASEU;
                                break;
                        case 'x':
                                caseflag = CASEX;
                                break;
                        default:
                                fprintf(ERRFILE,__NMSG_TEXT(ER_UNC), *p );
                                usage( EX_ARGE );
                    }

                    break;
            case 'n':
                    dumpsymbols = FALSE;
                    break;
            case 'o':
                    objing = FALSE;

                    if (p[1]) {  /* object file name specified */

                        objing = TRUE;
                        obj.name = _strdup( p+1 );
                        p += strlen( p ) - 1;
                        }

                    break;
            case 'p':
                    checkpure = TRUE;
                    break;
            case 'r':
                    fltemulate = FALSE;
                    break;
            case 's':
                    segalpha = FALSE;
                    break;
            case 't':
                    terse = TRUE;
                    break;

            case 'v':
                    terse = FALSE;
                    verbose = TRUE;
                    break;

            case 'w':
                    p++;
                    if (! isdigit(*p) || (warnlevel = atoi(p)) > 2)
                        TERMINATE(ER_WAN, EX_ARGE );

                    break;

            case 'X':
                    origcond = !origcond;
                    break;
            case 'x':
                    listconsole = FALSE;

                    if (p[1] == '-') {
                        listquiet = TRUE;  /* total quiet */
                        p++;
                    }
                    break;

            case 'z':
                    break;          /* accept just 'Z' */

            case 'Z':
                    if (p[1] == 'd'){
                        codeview = CVLINE;
                        p++;
                        break;
                    }
                    else if (p[1] == 'i'){
                        codeview = CVSYMBOLS;
                        p++;
                        break;
                    }

            default:
                    fprintf(stderr, "Argument error: %s\n", p );
                    usage( EX_ARGE );
        }
}


/***    usage - display usage line and exit
 *
 *      usage (exitcode);
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

VOID PASCAL
usage (
        SHORT exitcode
){
        farPuts(stderr, __FMSG_TEXT(ER_HXHELP));
        putchar('\n');
        exit (exitcode);
}

#endif /* XENIX286 */



#ifdef DEBUG

/***    hatoi - convert hex ASCII string to integer
 *
 *      hex = hatoi(p);
 *
 *      ENTRY   p = pointer to hex string in ASCII
 *      EXIT    none
 *      RETURNS integer equivalent of hex string
 *      CALLS   none
 */

SHORT     PASCAL
hatoi (
        char *p
){
    SHORT i;

    i = 0;
    while (isxdigit(*p))
        if (*p <= '9')
            i = 0x10*i + *p++ - '0';
        else
            i = 0x10*i + (*p++ & 0xF) + 9;
    return i;
}

#endif /* DEBUG */


#ifndef XENIX286

static SHORT PASCAL nulname ( p )
char *p;
        {
        char *q;
        SHORT result;

        if ((q = strrchr( p, PSEP )) || (q = strrchr( p, ':' )))
                q++;
        else
                q = p;

        if (p = strchr( q, '.' )) {
                if (!_stricmp( p + 1, "nul" ))
                        return( 1 );

                *p = '\0';
                }

        result = (SHORT)_stricmp( q, "nul" );

        if (p)
                *p = '.';

        return( !result );
        }


 static SHORT PASCAL
conname (
        char *p
){
        char *q;
        SHORT result;

        if (q = strrchr( p, PSEP ))
                q++;
        else
                q = p;

        if (p = strchr( q, '.' )) {
                if (!_stricmp( p + 1, "con" ))
                        return( 1 );

                *p = '\0';
                }

        result = (SHORT)_stricmp( q, "con" );

        if (p)
                *p = '.';

        return( !result );
        }

#endif /* XENIX286 */


static VOID panic () {

# ifdef FLATMODEL
//#   pragma message("signals don't work")
# else
        signal( SIGINT, SIG_IGN );
# endif


        closeOpenFiles();
        exit( EX_INT );
}

VOID PASCAL
closeOpenFiles()                 /* close and delete all output files on error */
{
        if (crf.fil) {
                fclose( crf.fil );
                _unlink( crf.name );
                }

        if (lst.fil) {
                fclose( lst.fil );
                _unlink( lst.name );
                }

        if (obj.fh) {
                _close( obj.fh );
                _unlink( obj.name );
                }
}

/***    terminate - exit masm with terminal message
 *
 *
 *      ENTRY   packed message number, exit code
 *              pointers with up to 1 arguments to a printf function
 *      EXIT    exits to DOS, no return
 */

VOID terminate(
    SHORT message,
    char *arg1,
    char *arg2,
    char *arg3
){
    fprintf(ERRFILE,__NMSG_TEXT((USHORT)(0xfff & message)), arg1, arg2, arg3);
    exit(message >> 12);
}

# if defined MSDOS && !defined FLATMODEL

/* get date in form:
**      <month>-<day>-<year> <hour>:<minute>:<second>\n
 */

static UCHAR seetime[25];

UCHAR * PASCAL
ctime ()
{
        USHORT year;
        UCHAR month;
        UCHAR day;
        UCHAR hour;
        UCHAR minute;
        UCHAR second;
        register char *p = &seetime[4];

#ifdef CPDOS
        {
        struct DateTime regs;

        DOSGETDATETIME( (struct DateTime far *)(&regs) );
        hour = regs.hour;
        minute = regs.minutes;
        second = regs.seconds;
        year = regs.year;
        month = regs.month;
        day = regs.day;
        }
#else
        {
        union REGS regs;

        regs.h.ah = 0x2c; /* get time */
        intdos( &regs, &regs );
        hour = regs.h.ch;
        minute = regs.h.cl;
        second = regs.h.dh;
        regs.h.ah = 0x2a; /* get date */
        intdos( &regs, &regs );
        year = (regs.h.ch << 8) | regs.h.cl;
        month = regs.h.dh;
        day = regs.h.dl;
        }
#endif
        _itoa( month, p++, 10 );
        if (month >= 10)
                p++;

        *p++ = '/';
        _itoa( day, p++, 10 );
        if (day >= 10)
                p++;

        *p++ = '/';
        _itoa( year % 100, p, 10 );
        p += 2;
        *p++ = ' ';

        if (hour < 10)
                *p++ = '0';

        _itoa( hour, p++, 10 );
        if (hour >= 10)
                p++;

        *p++ = ':';

        if (minute < 10)
                *p++ = '0';

        _itoa( minute, p++, 10 );
        if (minute >= 10)
                p++;

        *p++ = ':';

        if (second < 10)
                *p++ = '0';

        _itoa( second, p++, 10 );
        if (second >= 10)
                p++;

        *p = '\n';
        p[1] = NULL;

        return( seetime );
        }

# endif /* MSDOS && !flatmodel */


// Only needed if C library doesn't contain strchr and strrchr
#ifdef PRIVATESTRCHR

char * strchr ( string, ch )
        register char *string;
        register ch;
        {
        while (*string && *string != ch)
                string++;

        if (*string == ch)
                return( string );

        return( NULL );
        }


char * strrchr ( string, ch )
        register char *string;
        register ch;
        {
        register char *start = string;

        while (*string++)
                ;

        while (--string != start && *string != ch)
                ;

        if (*string == ch)
                return( string );

        return( NULL );
        }

#endif  /* PRIVATESTRCHR */


#ifdef XENIX286
#pragma loop_opt (on)

SHORT _stricmp ( first, last )
char *first;
char *last;
{
        return(memicmp(first, last, strlen(first)));
}

SHORT memicmp ( first, last,count)
register char *first;
register char *last;
SHORT count;
{
        char c1, c2;

        do {
                if ((c1 = *first++) >= 'A' && c1 <= 'Z')
                        c1 += 'a' - 'A';

                if ((c2 = *last++) >= 'A' && c2 <= 'Z')
                        c2 += 'a' - 'A';

                if (c1 != c2)
                    return (c1 - c2);

        } while (--count >= 0);

        return(0);
}

farPuts(pFile, psz)         /* print a far string */
FILE *pFile;
char FAR *psz;
{
    while(*psz)
        fputc(*psz++, pFile);
}


char *strstr(p1, p2)
char *p1;
char *p2;
{
        SHORT cb = strlen(p2);

        while (*p1) {
            if (memcmp(p1, p2, cb) == 0)
                return(p1);

            p1++;
        }
        return (0);
}
#endif /* XENIX286 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright Microsoft Corp. 1984, 1985, 1986
$
if1
ASMpass=1
outif MACRO name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
%out ! onmsg
endif
else
ifnb <offmsg>
%out ! offmsg
endif
endif
endm
??error macro msg
E r r o r ----- msg
endm
%out cMacros Version 2.03 - 3/06/86
%out Copyright (C) Microsoft Corp. 1984, 1985, 1986. All rights reserved.
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
??error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Windows far epilogs assume valid SP>
outif ?WIN,1,<Windows Support>
outif ?PLM,1,<PLM calling convention>
ifndef ?NODATA
?NODATA1=0
else
?NODATA1=1
%out ! NODATA module
endif
ifndef ?CHKSTK
?CHKSTK1=0
else
?CHKSTK1=1
%out ! Stack checking enabled
endif
ifndef ?CPDOS
?CPDOS1=0
else
?CPDOS1=1
%out ! CPDOS module
endif
else
ASMpass=2
endif
.XCREF
.XCREF ?N,?AX,?AH,?AL,?BX,?BH
.XCREF ?BL,?CX,?CH,?CL,?DX,?DH
.XCREF ?DL,?SI,?DI,?ES,?DS,?BP
.XCREF ?SP,?SS,?CS
.XCREF ?RSL,?CPD,?argl,?argc,?BA
.XCREF ?ACB,???,?PO
.XCREF ?PAS,?PC
.XCREF Uconcat,mPush,mPop
.XCREF ?RI,?pp,?pp1,?al1
.XCREF ?aD,?AP,?Atal,?dd,?dd1
.XCREF ?pg,?pg1,?aloc,?cs1,?cs2
.XCREF ?DF,?TF,?PLM,?WIN,?IA,?PU,?ADJ
.XCREF ?UF,?RP,?NX,?ND,?NODATA1,?CHKSTK1,?CPDOS1
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?RP = 0
?UF = 0
?ND = 0
?NX = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
.CREF
uconcat macro a,b,c,d,e,f
a&b c&d e&f
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if r AND ?&&x
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if r AND ?&&x
pop x
endif
endm
endm
save macro r
?RSL=0
?RI ?RSL,<r>
endm
?RI macro n,r
irp x,<r>
ifdef ?&&x
n=n OR ?&&x
endif
endm
endm
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<n>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<QWORD>,8,8
endm
parmT macro n
?pp <n>,<TBYTE>,10,10
endm
if sizeC
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sizeD
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?CPD
.xcref
irp x,<n>
.xcref ?T&&x
?T&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?PO+?adj)
?PO=?PO+l
else
?PO=?PO+l
?pp1 x,<t>,%?PO,%?adj
endif
endm
.cref
else
??error <Parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
ifndef ?NOPARMR
.XCREF
.XCREF ?pr
.CREF
parmR macro n,r,r2
?pr n,r,r2,%?RP,%(?IA+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR SEG_&n,r
parmR OFF_&n,r2
n equ dword ptr [bp-o-2]
.xcref ?T&n
?T&n=4
else
.xcref ?RP&i
?RP&i=0
ifdef ?&r
?RP&i=?&r
endif
if ??? OR (?CPD EQ 0) OR (?RP&i EQ 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ word ptr [bp-o]
?T&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x EQ ?&r
n equ byte ptr [bp-o]
?T&n=1
exitm
endif
endm
?IA=?IA+2
?RP=?RP+1
endif
.cref
endm
endif
localB macro n
?aLoc <n>,<BYTE ptr>,1,1,0
endm
localW macro n
?aLoc <n>,<WORD PTR>,2,2,1
endm
localD macro n
irp x,<n>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro n
?aLoc <n>,<QWORD PTR>,8,8,1
endm
localT macro n
?aLoc <n>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sizeD
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aLoc <n>,,%(a),0,1
endm
?aLoc macro n,t,l,s,a
if ?CPD
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) AND 0FFFEH)
endif
?aL1 x,<t>,%(???+?IA)
.xcref ?T&&x
?T&&x=s
endm
.cref
else
??error <Locals "&n" declared outside procedure def>
endif
endm
?aL1 macro n,t,o
n equ t [bp-o]
endm
ifndef ?NOGLOBAL
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
endif
ifndef ?NOSTATIC
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
ifndef ?NOEXTERN
.XCREF
.XCREF ?ex1
.CREF
externB macro n
?ex1 <n>,1,<BYTE>
endm
externW macro n
?ex1 <n>,2,<WORD>
endm
externD macro n
?ex1 <n>,4,<DWORD>
endm
externQ macro n
?ex1 <n>,8,<QWORD>
endm
externT macro n
?ex1 <n>,10,<TBYTE>
endm
externNP macro n
?ex1 <n>,2,<NEAR>
endm
externFP macro n
?ex1 <n>,4,<FAR>
endm
if sizeC
externP macro n
?ex1 <n>,4,<FAR>
endm
else
externP macro n
?ex1 <n>,2,<NEAR>
endm
endif
if sizeC
externCP macro n
?ex1 <n>,4,<DWORD>
endm
else
externCP macro n
?ex1 <n>,2,<WORD>
endm
endif
if sizeD
externDP macro n
?ex1 <n>,4,<DWORD>
endm
else
externDP macro n
?ex1 <n>,2,<WORD>
endm
endif
?ex1 macro n,s,d
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
endif
ifndef ?NOLABEL
.XCREF
?lblpu = 0
.XCREF ?lb1,?lblpu
.CREF
labelB macro n
?lb1 <n>,1,<BYTE>
endm
labelW macro n
?lb1 <n>,2,<WORD>
endm
labelD macro n
?lb1 <n>,4,<DWORD>
endm
labelQ macro n
?lb1 <n>,8,<QWORD>
endm
labelT macro n
?lb1 <n>,10,<TBYTE>
endm
labelNP macro n
?lb1 <n>,2,<NEAR>
endm
labelFP macro n
?lb1 <n>,4,<FAR>
endm
if sizeC
labelP macro n
?lb1 <n>,4,<FAR>
endm
else
labelP macro n
?lb1 <n>,2,<NEAR>
endm
endif
if sizeC
labelCP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelCP macro n
?lb1 <n>,2,<WORD>
endm
endif
if sizeD
labelDP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelDP macro n
?lb1 <n>,2,<WORD>
endm
endif
?lb1 macro n,s,d
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
defB macro n
?aD <n>,1
endm
defW macro n
?aD <n>,2
endm
defD macro n
?aD <n>,4
endm
defQ macro n
?aD <n>,8
endm
defT macro n
?aD <n>,10
endm
if sizeC
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sizeD
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?aD macro n,s
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
endm
endm
ifndef ?NOPTR
regPtr macro n,S,O
farPtr n,S,O
endm
farptr macro n,S,O
.xcref
.xcref ?T&n
.cref
n &macro
push S
push O
&endm
?T&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
.xcref
.xcref ?ALI&i
.cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl=?argl+2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?T&n AND 80h
n
?argl=?argl+2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ife ?PLM
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
?ACB=?argc
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB=?ACB-1
endm
ifb <sleaze>
call _&n
else
call n
endif
if ?argl
add sp,?argl
endif
mpop %?RSL
?RSL=0
?argc= 0
?argl= 0
endm
else
ccall macro n,a
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
?ACB=1
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB=?ACB+1
endm
call n
mpop %?RSL
?RSL=0
?argc=0
?argl=0
endm
endif
cProc macro n,c,a,f
if ?CPD
?UTPE
endif
?CPD=1
???=0
?argc=0
?BA=0
?PO=0
?PU=0
?IA=0
?adj=4
?PC=0
?RP=0
?UF=0
?PAS=0
ifnb <a>
?RI ?PAS,<a>
endif
?PC=sizeC
?ND=?NODATA1
?NX=0
irp x,<c>
ifidn <x>,<FAR>
?PC=1
endif
ifidn <x>,<NEAR>
?PC=0
endif
ifidn <x>,<PUBLIC>
?PU=1
endif
ifidn <x>,<SMALL>
?UF=1
endif
ifidn <x>,<DATA>
?ND=0
endif
ifidn <x>,<NODATA>
?ND=1
endif
ifidn <x>,<ATOMIC>
?NX=1
endif
endm
if ?PC
if ?WIN
ife ?NX
?IA=2
?PAS = ?PAS AND (NOT ?ds)
endif
endif
?adj=?adj+2
endif
?PAS = ?PAS AND (NOT (?sp+?cs+?ss))
if ?UF
?PAS = ?PAS AND (NOT (?bp+?si+?di))
endif
ife ?PLM
ife ?PC
n label near
else
n label far
endif
?pg <_&n>,%?PU,%?PC,%?PAS,%?IA
else
?pg <n>,%?PU,%?PC,%?PAS,%?IA
endif
endm
?pg macro n,p,c,a,w
.xcref
if ?UF
if ?RP
??error <parmR encountered in &n - user frame ignored>
?UF=0
endif
if ?ND
??error <NODATA encountered in &n - user frame ignored>
?UF=0
endif
endif
cBegin &macro g
.xcref
?pg1 <n>,c,a,%?PO,w,%?UF,%?ND,%?RP
?CPD=0
?argc=0
?BA=1
???=(???+1) AND 0FFFEH
if p
PUBLIC n
endif
ife c
n proc NEAR
else
n proc FAR
endif
ifidn <g>,<nogen>
if ???+?PO+a+?RP
%out <cBegin - possible invalid use of nogen>
endif
else
if ?UF
?MF c,%???,%?PO
mPush a
else
if w
ife ?ND
mov ax,ds
nop
endif
ife ?NX
ife ?CPDOS1
inc bp
endif
push bp
mov bp,sp
push ds
else
if ???+?PO+?RP
push bp
mov bp,sp
endif
endif
ife ?ND
mov ds,ax
endif
else
if ???+?PO+?RP
push bp
mov bp,sp
endif
endif
if ?RP
?UF=0
rept ?RP
uconcat mpush,,?RP,%?UF
?UF=?UF+1
endm
endif
if ???
if ?CHKSTK1
mov ax,???
ife ?PLM
call _chkstk
else
call chkstk
endif
else
sub sp,???
endif
endif
mPush a
endif
endif
.cref
purge cBegin
&endm
?UTPE &macro
??error <Unterminated Procedure Definition: "&n">
&endm
endm
?pg1 macro n,c,a,o,w,f,d,r
.xcref
cEnd &macro g
.xcref
?BA=0
ifidn <g>,<nogen>
if o+a+r
%out <cEnd - possible invalid use of nogen>
endif
else
if f
mPop a
db 0C3h
else
mPop a
if w
ife ?NX
ife ?TF
lea sp,-2[bp]
else
if ???+?RP
lea sp,-2[bp]
endif
endif
pop ds
pop bp
ife ?CPDOS1
dec bp
endif
else
ife ?TF
mov sp,bp
else
if ???+?RP
sp,bp
endif
endif
if ???+?PO+?RP
pop bp
endif
endif
else
if ???+?PO+?RP
mov sp,bp
pop bp
endif
endif
ife ?PLM
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addSeg grp,n
else
ln&OFFSET equ OFFSET n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addSeg macro grp,seg
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
grp&_add &macro s
grp&_in <seg>,s
&endm
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defGrp macro grp,ln
addSeg grp
ifnb <ln>
?cs3 <ln>,<grp>
ln&OFFSET equ OFFSET grp:
ln&BASE equ grp
endif
endm
?cs1 macro ln,n
ln&_sBegin &macro
?MF &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
sEnd &macro
n ends
purge ?MF
&endm
endm
?cs3 macro ln,n
ln&_assumes &macro s
assume s:&n
&endm
endm
sBegin macro ln
ln&_sBegin
endm
ife ?DF
createSeg _TEXT,code,byte,public,CODE
ife ?NODATA1
createSeg _DATA,data,word,public,DATA,DGROUP
defGrp DGROUP,DATA
endif
if ?CHKSTK1
externP <chkstk>
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *ERRNZ* x1 = x2
endm
errn$ macro l,x
errnz <OFFSET $ - OFFSET l x>
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\msghdr.c ===
/* msghdr.c -- Message code - replacement for nmsghdr.asm fmsghdr.asm
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** Note: This module is only used for FLATMODEL versions of masm
**	 __NMSG_TEXT is used whenever segments are allowed.
**
** Jeff Spencer 10/90
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmmsg.h"

/* Used by asmmsg2.h */
struct Message {
	USHORT	 usNum; 	/* Message number */
	UCHAR	 *pszMsg;	/* Message pointer */
	};

#include "asmmsg2.h"

UCHAR * GetMsgText( USHORT, USHORT );

/* Performs same function as internal C library function __NMSG_TEXT */
/* Only the C library function uses segments, and a different data */
/* format */
UCHAR NEAR * PASCAL
NMsgText(
	USHORT messagenum
){
    return( (UCHAR NEAR *)GetMsgText( messagenum, 0 ) );
}


/* Same functionality as internal C library function __FMSG_TEXT */
/* Only the C library function uses segments, and a different data */
/* format */
UCHAR FAR * PASCAL
FMsgText(
	USHORT messagenum
){
    return( (UCHAR FAR *)GetMsgText( messagenum, 1 ) );
}


UCHAR *
GetMsgText(
	USHORT messagenum,
	USHORT tablenum
){
    struct Message *pMsg;

    pMsg = ( tablenum ) ? FAR_MSG_tbl : MSG_tbl;
    while( pMsg->usNum != ER_ENDOFLIST ){
	if( pMsg->usNum == messagenum ){
	    return( pMsg->pszMsg );
	}
	pMsg++;
    }
    return( (UCHAR *)0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\msdos.inc ===
;-----------------------------------------------------------------------
;
;	MS-DOS definitions for C runtime


_NFILE		equ	20		; maximum # files per process

STACKSLOP	equ	150		; stack slop for interrupt overhead


;	__osfile flag values for DOS file handles

FOPEN		equ	01H		; file handle open
FEOFLAG     equ 02H		; end of file has been encountered
FDEV		equ	40H		; file handle refers to device
FTEXT		equ	80H		; file handle is in text mode
FAPPEND		equ	20H		; file handle opened O_APPEND
FRDONLY		equ 10H		; file handle associated with read only file


callos	MACRO	func
ifnb	<func>
	mov	ah,DOS_&func
endif
	int	DOS
	ENDM


DOS		equ	21H		; MS-DOS interrupt

DOS_exit	equ	00000H		; exit offset		(PSP:0000)
DOS_maxpara	equ	00002H		; maximum paragraph	(PSP:0002)
DOS_envp	equ	0002cH		; environment address	(PSP:002c)
DOS_cmdline	equ	00080H		; command line offset	(PSP:0080)

DOS_kill	equ	00H		; terminate
DOS_echoread	equ	01H		; read keyboard and echo
DOS_display	equ	02H		; display character
DOS_auxinput	equ	03H		; auxiliary input
DOS_auxoutput	equ	04H		; auxiliary output
DOS_print	equ	05H		; print character
DOS_conio	equ	06H		; direct console i/o
DOS_coninput	equ	07H		; direct console input
DOS_readkbd	equ	08H		; read keyboard
DOS_message	equ	09H		; display string
DOS_bufkbdin	equ	0aH		; buffered keyboard input
DOS_kbdstatus	equ	0bH		; check keyboard status
DOS_flshread	equ	0cH		; flush buffer and read keyboard
DOS_diskreset	equ	0dH		; disk reset
DOS_selectdisk	equ	0eH		; select default disk
DOS_fcbopen	equ	0fH		; open file with fcb
DOS_fcbclose	equ	10H		; close file with fcb
DOS_fcbfirst	equ	11H		; search for first entry with fcb
DOS_fcbnext	equ	12H		; search for next entry with fcb
DOS_fcbdelete	equ	13H		; delete file with fcb
DOS_fcbsread	equ	14H		; sequential read with fcb
DOS_fcbswrite	equ	15H		; sequential write with fcb
DOS_fcbcreate	equ	16H		; create file with fcb
DOS_fcbrename	equ	17H		; rename file with fcb
DOS_currentd	equ	19H		; current default disk
DOS_setDMA	equ	1aH		; set DMA
DOS_fcbrread	equ	21H		; random read with fcb
DOS_fcbrwrite	equ	22H		; random write with fcb
DOS_fcbsize	equ	23H		; file size with fcb
DOS_fcbsetrec	equ	24H		; set relative record with fcb
DOS_setvector	equ	25H		; set interrupt vector
DOS_fcbbread	equ	27H		; random block read with fcb
DOS_fcbbwrite	equ	28H		; random block write with fcb
DOS_fcbparse	equ	29H		; parse file name with fcb
DOS_getdate	equ	2aH		; get date
DOS_setdate	equ	2bH		; set date
DOS_gettime	equ	2cH		; get time
DOS_settime	equ	2dH		; set time
DOS_verify	equ	2eH		; set/reset verify flag
DOS_getDMA	equ	2fH		; get DMA
DOS_version	equ	30H		; get version number
DOS_keep	equ	31H		; keep process
DOS_cntlc	equ	33H		; Cntl-C check
DOS_getvector	equ	35H		; get interrupt vector
DOS_getdskspc	equ	36H		; get disk free space
DOS_country	equ	38H		; get country dependent info
DOS_mkdir	equ	39H		; make subdirectory
DOS_rmdir	equ	3aH		; remove subdirectory
DOS_chdir	equ	3bH		; change subdirectory
DOS_create	equ	3cH		; create pathname
DOS_open	equ	3dH		; open pathname
DOS_close	equ	3eH		; close file handle
DOS_read	equ	3fH		; read from file handle
DOS_write	equ	40H		; write from file handle
DOS_delete	equ	41H		; delete pathname
DOS_lseek	equ	42H		; move file pointer
DOS_filemode	equ	43H		; get/set attributes of pathname
DOS_ioctl	equ	44H		; ioctl for devices
DOS_dup		equ	45H		; duplicate file handle
DOS_forcedup	equ	46H		; force duplicate file handle
DOS_curdir	equ	47H		; get current directory
DOS_allocmem	equ	48H		; allocate memory block
DOS_freemem	equ	49H		; free memory block
DOS_setmem	equ	4aH		; set size of memory block
DOS_exec	equ	4bH		; load and execute program
DOS_terminate	equ	4cH		; terminate process with errorcode
DOS_wait	equ	4dH		; get child process return code
DOS_findfirst	equ	4eH		; find first file match
DOS_findnext	equ	4fH		; find next file match
DOS_getverify	equ	54H		; return current verify flag
DOS_rename	equ	56H		; rename pathname
DOS_filedate	equ	57H		; get/set file handle date/time
DOS_locking	equ	5CH		; file record locking/unlocking
DOS_sleep	equ	89H		; delay process execution


;	DOS error codes

doserr	MACRO	num,name,text
name	equ	num
	ENDM

doserr	1,	E_ifunc,	<invalid function code>
doserr	2,	E_nofile,	<file not found>
doserr	3,	E_nopath,	<path not found>
doserr	4,	E_toomany,	<too many open files>
doserr	5,	E_access,	<access denied>
doserr	6,	E_ihandle,	<invalid handle>
doserr	7,	E_arena,	<arena trashed>
doserr	8,	E_nomem,	<not enough memory>
doserr	9,	E_iblock,	<invalid block>
doserr	10,	E_badenv,	<bad environment>
doserr	11,	E_badfmt,	<bad format>
doserr	12,	E_iaccess,	<invalid access code>
doserr	13,	E_idata,	<invalid data>
doserr	14,	E_unknown,	<??? unknown error ???>
doserr	15,	E_idrive,	<invalid drive>
doserr	16,	E_curdir,	<current directory>
doserr	17,	E_difdev,	<not same device>
doserr	18,	E_nomore,	<no more files>
doserr	19,	E_maxerr2,	<unknown error - Version 2.0>

; the following errors can occur only in DOS 3.0

doserr	32, E_sharerr,	<sharing violation>
doserr	33, E_lockerr,	<locking violation>
doserr	34,	E_maxerr3,	<unknown error - Version 3.0>


;	DOS file attributes

A_ro	equ	01H			; read-only file
A_h	equ	02H			; hidden
A_s	equ	04H			; system
A_v	equ	08H			; volume ID
A_d	equ	10H			; directory
A_a	equ	20H			; archive

A_mod	equ	A_ro+A_h+A_s+A_a	; modifiable attributes

;	end of msdos.inc
;-----------------------------------------------------------------------

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\nmsghdr.asm ===
title	nmsghdr       - near message header and finder

;--------------------------------------------------------------------------
;
;	Microsoft C Compiler Runtime for MS-DOS
;
;	(C)Copyright Microsoft Corporation, 1986
;
;--------------------------------------------------------------------------
;
;	Revision History
;
;	04/03/86	Greg Whitten
;
;	05/28/86	Randy Nevin
;			some pointers removed from the nhdr segment to
;			save space. they were there in anticipation of
;			being used as a method of changing messages, but
;			it turns out they are not needed
;
;--------------------------------------------------------------------------


?DF=		1		; this is special for c startup
include version.inc
?PLM=		1		; pascal calling conventions
.xlist
include cmacros.inc
include msdos.inc
.list

createSeg	_TEXT,	code,	byte,	public, CODE,	<>

createSeg	_DATA,	data,	word,	public, DATA,	DGROUP

createSeg	HDR,	nhdr,	byte,	public, CONST,	DGROUP
createSeg	MSG,	nmsg,	byte,	public, CONST,	DGROUP
createSeg	PAD,	npad,	byte,	common, CONST,	DGROUP
createSeg	EPAD,	nepad,	byte,	common, CONST,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET	equ	offset _TEXT:
dataOFFSET	equ	offset DGROUP:


sBegin	nhdr
assumes ds,DGROUP

	db	'<<NMSG>>'
stnmsg	label	byte

sEnd

sBegin	npad
assumes ds,DGROUP

	dw	-1			; message padding marker

sEnd

sBegin	nepad
assumes ds,DGROUP

	db	-1

sEnd


sBegin	code
assumes cs,code
assumes ds,DGROUP

;------------------------------------------------------------------------
;
;	char * pascal __NMSG_TEXT ( messagenumber)
;
;	This routine returns a near pointer to the message associated with
;	messagenumber.	If the message does not exist, then a 0 is returned.
;
;	This routine reestablishes DS = ES = DGROUP

cProc	__NMSG_TEXT,<PUBLIC>,<si,di>	; pascal calling

parmW	msgt

cBegin
	mov	ax,DGROUP
	mov	ds,ax			; ds = DGROUP (force it always)
	push	ds
	pop	es
	mov	dx,msgt 		; dx = message number
	mov	si,dataOFFSET stnmsg	; start of near messages

tloop:
	lodsw				; ax = current message number
	cmp	ax,dx
	je	found			;   found it - return address
	inc	ax
	xchg	ax,si
	jz	found			;   at end and not found - return 0
	xchg	di,ax
	xor	ax,ax
	mov	cx,-1
	repne	scasb			; skip until 00
	mov	si,di
	jmp	tloop			; try next entry

found:
	xchg	ax,si
cEnd

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\mixed.inc ===
; High-Level-Language Interface Macros - Version 2.0
;   for Microsoft Macro Assembler 5.10
; (C) Copyright Microsoft Corporation, 1987.

;   Syntax                   Purpose
;   ------                   -------
;
;   setModel                 Sets model from text equate
;
;   hProc  <name [NEAR|FAR]> [,<USES reglist>] [,arg[:type] [,arg[:type]]]...
;                            Starts a procedure with optional stack arguments
;
;   hLocal var[:type] [,var[:type]]...
;                            Defines local stack variables
;
;   hRet                     Returns from the current procedure
;
;   hEndp                    Ends the current procedure
;
;   ifFP  statement          Assembles statement if far data
;
;   FPoperand                Conditionally provides ES override for data
;
;   pLes  register,address   Conditionally loads data through ES
;
;   pLds  register,address   Conditionally loads data through DS

;if1

; Translate command-line arguments


; Initialize procName

    procName equ <foo>

; Set model passed from command line

setModel macro mod

    ifdef cLang
      .model mod, C
      lang  EQU   <C>
    elseifdef BASIC
      .model mod, Basic
    elseifdef FORTRAN
      .model mod, FORTRAN
    elseifdef Pascal
      .model mod, Pascal
    endif

; FP - supply far pointer ES overide as needed - must be inside for setModel

    if @Datasize
      FP equ <es:>
    else
      FP equ <>
    endif

endm

; FP - supply far pointer ES overide as needed - must be outside for .MODEL

ifdef @Datasize
    if @Datasize
      FP equ <es:>
    else
      FP equ <>
    endif
endif

; Declare high level routine and parameters

hProc macro funName, a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr

    ii instr <funName>,< >
    if ii
      procName subStr <funName>,1,ii
      nearFar subStr <funName>,ii
    else
      procName equ <funName>
      nearFar equ <>
    endif

    argstr equ <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineProc %nearFar, %argstr
endm

defineProc Macro size,args
procName proc size args
endm

; Declare local stack variables

hLocal macro a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr
    argstr EQU <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineLocal %argstr
endm

defineLocal macro args
    &local args
endm

; Generate high level return

hRet macro
    ret
endm

; End a high level procedure

hEndp macro
    procName endp
endm

; Execute instruction if far data

ifFP macro a,b,c,d,e,f,g,h,i,j

    if @datasize
       a b c d e f g h i j
    endif
endm

; Load 16/32 bit pointers into [ES:] reg

pLes macro reg, address

    if @datasize

        les reg,address
    else
        mov reg,address

    endif
endm

;Load 16/32 bit pointers into [DS:] reg

pLds macro reg, address

    if @datasize

        lds reg,address
    else
        mov reg,address

    endif
endm

;endif ; Pass 1 only
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\mkmsg.c ===
/*
** MKMSG [-h cfile] [-inc afile] [-asm srcfile [-min|-max]] txtfile
**
** take message file and produce assembler source file. lines in txtfile
** can be of 6 types:
**      1) "<<NMSG>>"   -- use near segment
**      2) "<<FMSG>>"   -- use far segment
**      3) "#anything"  -- comment line (ignore)
**      4) ""           -- blank line (ignore)
**      5) "handle<tab>number<tab>message_text"
**              -- message with number and symbolic handle
**      6) "<tab>number<tab>message_text"
**              -- message with number but no symbolic handle
**
** the -h file gets "#define handle number" for those messages with handles.
** the -inc file gets "handle = number" for the same messages. the -asm file
** gets standard segment definitions, then the messages are placed either in
** a near segment (MSG) or a far segment (FAR_MSG) depending on if they follow
** a <<NMSG>> or a <<FMSG>>. if neither is present, <<NMSG>> is assumed. if
** -min or -max is given with -asm, the minimum or maximum amount of 0-padding
** is calculated and placed in the .asm file. any combination of the options
** may be given, and if none are present then the input is only checked for
** syntactic validity. maximum and minimum amount of padding depends on the
** length of the individual messages, and is defined in the cp/dos spec
**
** If the -32 switch is supplied then the -asm file will be compatible
** with a 32 bit flat model operating system. In which case <<NMSG>> and
** <<FMSG>> cause the messages to be placed in two tables. The tables are
** named MSG_tbl and FAR_MSG_tbl respectively. These are within the 32 bit
** small model data segment.
**
** NOTE: This file is no longer used for NT MASM. Instead its output was
** converted to asmmsg.h and asmmsg2.h and slimed. This was the quick and
** dirty way to be able to compile masm for other processors. (Jeff Spencer)
** For more info read the header on asmmsg2.h.
**
** randy nevin, microsoft, 4/86
** (c)copyright microsoft corp, 1986
**
** Modified for 32 bit by Jeff Spencer 10/90
*/

#include <stdio.h>
#include <ctype.h>

void SetNear( void );
void SetFar( void );

char usage[] =
  "usage: MKMSG [-h cfile] [-inc afile] [-asm srcfile [-min|-max]] [-32] txtfile\n";
char ex[] = "expected escape sequence: %s\n";

char n1[] = "HDR segment byte public \'MSG\'\nHDR ends\n";
char n2[] = "MSG segment byte public \'MSG\'\nMSG ends\n";
char n3[] = "PAD segment byte public \'MSG\'\nPAD ends\n";
char n4[] = "EPAD segment byte common \'MSG\'\nEPAD ends\n";
char n5[] = "DGROUP group HDR,MSG,PAD,EPAD\n\n";

char f1[] = "FAR_HDR segment byte public \'FAR_MSG\'\nFAR_HDR ends\n";
char f2[] = "FAR_MSG segment byte public \'FAR_MSG\'\nFAR_MSG ends\n";
char f3[] = "FAR_PAD segment byte public \'FAR_MSG\'\nFAR_PAD ends\n";
char f4[] = "FAR_EPAD segment byte common \'FAR_MSG\'\nFAR_EPAD ends\n";
char f5[] = "FMGROUP group FAR_HDR,FAR_MSG,FAR_PAD,FAR_EPAD\n\n";

int f32Bit = 0;         /* -32?, produce 32bit flat model code */
char didnear = 0;
char didfar = 0;
FILE *fasm = NULL;      /* -asm stream */

__cdecl main( argc, argv )
        int argc;
        char **argv;
        {
        FILE *f;                /* the input file */
        char *h = NULL;         /* -h file name */
        FILE *fh = NULL;        /* -h stream */
        char *inc = NULL;       /* -inc file name */
        FILE *finc = NULL;      /* -inc stream */
        char *asm = NULL;       /* -asm file name */
        int min = 0;            /* -min? */
        int max = 0;            /* -max? */
        int asmstate = 0;       /* 0=nothing, 1=doing nmsg, 2=doing fmsg */
        int instring;           /* db "... */
        char buf[256];          /* line buffer */
        int ch;
        int i;
        int number;             /* index of message number in line */
        int msg;                /* index of message text in line */
        int npad = 0;           /* cumulative amount of near padding */
        int fpad = 0;           /* cumulative amount of far padding */
        int length;
        double factor;
        double result;

        argc--;  /* skip argv[0] */
        argv++;

        while (argc && **argv == '-')  /* process options */
                if (!strcmp( "-h", *argv )) {  /* create .h file */
                        argc--;
                        argv++;

                        if (!argc)
                                printf( "no -h file given\n" );
                        else if (h) {
                                printf( "extra -h file %s ignored\n", *argv );
                                argc--;
                                argv++;
                                }
                        else    {  /* remember -h file */
                                h = *argv;
                                argc--;
                                argv++;
                                }
                        }
                else if (!strcmp( "-inc", *argv )) {  /* create .inc file */
                        argc--;
                        argv++;

                        if (!argc)
                                printf( "no -inc file given\n" );
                        else if (inc) {
                                printf( "extra -inc file %s ignored\n", *argv );
                                argc--;
                                argv++;
                                }
                        else    {  /* remember -inc file */
                                inc = *argv;
                                argc--;
                                argv++;
                                }
                        }
                else if (!strcmp( "-asm", *argv )) {  /* create .asm file */
                        argc--;
                        argv++;

                        if (!argc)
                                printf( "no -asm file given\n" );
                        else if (asm) {
                                printf( "extra -asm file %s ignored\n", *argv );
                                argc--;
                                argv++;
                                }
                        else    {  /* remember -asm file */
                                asm = *argv;
                                argc--;
                                argv++;
                                }
                        }
                else if (!strcmp( "-min", *argv )) {  /* minimum padding */
                        argc--;
                        argv++;

                        if (min)
                                printf( "redundant -min\n" );

                        min = 1;
                        }
                else if (!strcmp( "-max", *argv )) {  /* maximum padding */
                        argc--;
                        argv++;

                        if (max)
                                printf( "redundant -max\n" );

                        max = 1;
                        }
                else if (!strcmp( "-32", *argv )) {  /* 32bit code */
                        argc--;
                        argv++;
                        f32Bit = 1;
                        }
                else    {
                        printf( "unknown option %s ignored\n", *argv );
                        argc--;
                        argv++;
                        }

        if ((min || max) && !asm) {
                printf( "-min/-max ignored; no -asm file\n" );
                min = max = 0;
                }

        if (min && max) {
                printf( "-min and -max are mutually exclusive; -min chosen\n" );
                max = 0;
                }

        if (!argc) {  /* no arguments */
                printf( usage );
                exit( -1 );
                }

        if (argc != 1)  /* extra arguments */
                printf( "ignoring extra arguments\n" );

        if (!(f = fopen( *argv, "rb" ))) {
                printf( "can't open txtfile %s for binary reading\n", *argv );
                exit( -1 );
                }

        if (asm && !(fasm = fopen( asm, "w" ))) {
                printf( "can't open -asm file %s for writing\n", asm );
                exit( -1 );
                }

        if (h && !(fh = fopen( h, "w" ))) {
                printf( "can't open -h file %s for writing\n", h );
                exit( -1 );
                }

        if (inc && !(finc = fopen( inc, "w" ))) {
                printf( "can't open -inc file %s for writing\n", inc );
                exit( -1 );
                }

        if( fasm && f32Bit ){
                fprintf( fasm, "\t.386\n" );
                fprintf( fasm, "\t.model small,c\n" );
                fprintf( fasm, "\t.data\n\n" );
                }

        while ((ch = getc( f )) != EOF)  /* process lines */
                if (ch == '<') {  /* <<NMSG>> or <<FMSG>> */
                        buf[0] = ch;
                        i = 1;

                        while ((ch = getc( f )) != EOF && ch != '\r'
                                        && ch != '\n')
                                if (i < 255)
                                        buf[i++] = ch;

                        buf[i] = '\0';

                        if (!strcmp( "<<NMSG>>", buf ))/*near msgs follow*/
                                if (asmstate == 0) {
                                        if (fasm) {
                                                SetNear();
                                                asmstate = 1;
                                                }
                                        }
                                else if (asmstate == 1)
                                        printf( "already in nmsg\n" );
                                else if (asmstate == 2) {
                                        if (fasm) {
                                                if( !f32Bit ){
                                                       fprintf( fasm, "FAR_MSG ends\n\n" );
                                                       }
                                                SetNear();
                                                asmstate = 1;
                                                }
                                        }
                                else    {
                                        printf( "internal error\n" );
                                        exit( -1 );
                                        }
                        else if (!strcmp( "<<FMSG>>", buf ))/*far msgs follow*/
                                if (asmstate == 0) {
                                        if (fasm) {
                                                SetFar();
                                                asmstate = 2;
                                                }
                                        }
                                else if (asmstate == 1) {
                                        if (fasm) {
                                                if( !f32Bit ){
                                                        fprintf( fasm, "MSG ends\n\n" );
                                                        }
                                                SetFar();
                                                asmstate = 2;
                                                }
                                        }
                                else if (asmstate == 2)
                                        printf( "already in fmsg\n" );
                                else    {
                                        printf( "internal error\n" );
                                        exit( -1 );
                                        }
                        else
                                printf( "ignoring bad line: %s\n", buf );
                        }
                else if (ch == '#')  /* comment line */
                        while ((ch = getc( f )) != EOF && ch != '\r'
                                && ch != '\n')
                                ;
                else if (ch != '\r' && ch != '\n') {  /* something to do */
                        buf[0] = ch;
                        i = 1;

                        while ((ch = getc( f )) != EOF && ch != '\r'
                                        && ch != '\n')
                                if (i < 255)
                                        buf[i++] = ch;

                        buf[i] = '\0';

                        if (buf[i = 0] != '\t')
                                while (buf[i] && buf[i] != '\t')
                                        i++;

                        if (!buf[i]) {
                                printf( "expected <TAB>: %s\n", buf );
                                continue;
                                }
                        else
                                i++;

                        if (!buf[i] || buf[i] == '\t') {
                                printf( "expected msgnum: %s\n", buf );
                                continue;
                                }

                        number = i;

                        while (buf[i] && buf[i] != '\t')
                                i++;

                        if (buf[i] != '\t') {
                                printf( "expected <TAB>: %s\n", buf );
                                continue;
                                }

                        msg = ++i;

                        if (buf[0] != '\t') {  /* possible -h and/or -inc */
                                if (h) {
                                        fprintf( fh, "#define\t" );

                                        for (i = 0; i < msg-1; i++)
                                                putc( buf[i], fh );

                                        putc( '\n', fh );
                                        }

                                if (inc) {
                                        for (i = 0; i < number; i++)
                                                putc( buf[i], finc );

                                        fprintf( finc, "=\t" );

                                        while (i < msg-1)
                                                putc( buf[i++], finc );

                                        putc( '\n', finc );
                                        }
                                }

                        if (fasm) {  /* write asmfile */
                                if (asmstate == 0) {
                                        SetNear();
                                        asmstate = 1;
                                        }

                                fprintf( fasm, "\tdw\t" );

                                for (i = number; i < msg-1; i++)
                                        putc( buf[i], fasm );

                                fprintf( fasm, "\n\tdb\t" );
                                instring = 0;

                                for (i = msg, length = 0; buf[i];
                                                i++, length++)
                                                /* allocate message */
                                        if (buf[i] == '\\')
                                                /* C escape sequence */
                                                switch (buf[++i]) {
                                                case 'r':
                                                case 'n':
                                                case 't':
                                                case 'f':
                                                case 'v':
                                                case 'b':
                                                case '\'':
                                                case '"':
                                                case '\\':
                                                        if (instring) {
                                                                putc( '"',
                                                                        fasm );
                                                                putc( ',',
                                                                        fasm );
                                                                instring = 0;
                                                                }

                                                        if (buf[i] == 'r')
                                                                fprintf( fasm,
                                                                        "13" );
                                                        else if (buf[i] == 'n')
                                                                fprintf( fasm,
                                                                        "10" );
                                                        else if (buf[i] == 't')
                                                                fprintf( fasm,
                                                                        "9" );
                                                        else if (buf[i] == 'f')
                                                                fprintf( fasm,
                                                                        "12" );
                                                        else if (buf[i] == 'v')
                                                                fprintf( fasm,
                                                                        "11" );
                                                        else if (buf[i] == 'b')
                                                                fprintf( fasm,
                                                                        "8" );
                                                        else if (buf[i] == '\'')
                                                                fprintf( fasm,
                                                                        "39" );
                                                        else if (buf[i] == '"')
                                                                fprintf( fasm,
                                                                        "34" );
                                                        else if (buf[i] == '\\')
                                                                fprintf( fasm,
                                                                        "92" );

                                                        putc( ',', fasm );
                                                        break;
                                                case '\0':
                                                        printf( ex, buf );
                                                        i--;
                                                        break;
                                                default:
                                                        if (!instring) {
                                                                putc( '"',
                                                                        fasm );
                                                                instring = 1;
                                                                }

                                                        putc( buf[i], fasm );
                                                        break;
                                                }
                                        else if (instring)
                                                /* keep building string */
                                                putc( buf[i], fasm );
                                        else    {  /* start building string */
                                                putc( '"', fasm );
                                                instring = 1;
                                                putc( buf[i], fasm );
                                                }

                                if (instring) {  /* close string */
                                        putc( '"', fasm );
                                        putc( ',', fasm );
                                        }

                                putc( '0', fasm );
                                putc( '\n', fasm );

                                /* calculate padding */
                                /* depends on msg length */

                                if (min || max) {
                                        if (min)
                                                if (length <= 10)
                                                        factor = 1.01;
                                                else if (length <= 20)
                                                        factor = 0.81;
                                                else if (length <= 30)
                                                        factor = 0.61;
                                                else if (length <= 50)
                                                        factor = 0.41;
                                                else if (length <= 70)
                                                        factor = 0.31;
                                                else
                                                        factor = 0.30;
                                        else if (length <= 10)
                                                factor = 2.00;
                                        else if (length <= 20)
                                                factor = 1.00;
                                        else if (length <= 30)
                                                factor = 0.80;
                                        else if (length <= 50)
                                                factor = 0.60;
                                        else if (length <= 70)
                                                factor = 0.40;
                                        else
                                                factor = 0.30;

                                        result = (double)length * factor;

                                        if (asmstate == 1) {
                                                npad += (int)result;

                                                if (result
                                                        > (float)((int)result))
                                                        npad++;
                                                }
                                        else if (asmstate == 2) {
                                                fpad += (int)result;

                                                if (result
                                                        > (float)((int)result))
                                                        fpad++;
                                                }
                                        }
                                }
                        }

        if (fasm) {  /* finish up asm file */
                if( !f32Bit ){
                        if (asmstate == 1)
                                fprintf( fasm, "MSG ends\n\n");
                        else if (asmstate == 2)
                                fprintf( fasm, "FAR_MSG ends\n\n");

                        if (npad) {  /* add near padding */
                                fprintf( fasm, "PAD segment\n\tdb\t%d dup(0)\n",
                                        npad );
                                fprintf( fasm, "PAD ends\n\n" );
                                }

                        if (fpad) {  /* add far padding */
                                fprintf( fasm, "FAR_PAD segment\n\tdb\t%d dup(0)\n",
                                        fpad );
                                fprintf( fasm, "FAR_PAD ends\n\n" );
                                }
                        }
                fprintf( fasm, "\tend\n" );
                fclose( fasm );
                }

        if (fh)
                fclose( fh );

        if (finc)
                fclose( finc );

        fclose( f );
        exit( 0 );
        }


void SetNear()
{
        if( f32Bit ) {
                if( !didnear ){
                        fprintf( fasm, "MSG_tbl EQU $\n" );
                        fprintf( fasm, "\tpublic MSG_tbl\n" );
                        didnear++;
                        }
                else{
                        /* Rather than modify mkmsg to handle mixed NEAR / FAR */
                        /* I (Jeff Spencer) chose the quick route of limiting it's capabilities */
                        /* As this capability wasn't needed for MASM 5.1 */
                        printf( "error - 32 bit version doesn't support alternating NEAR and FAR messages\n" );
                        exit( -1 );
                        }
                }
        else{
                if (!didnear) {
                        didnear++;
                        fprintf( fasm, n1 );
                        fprintf( fasm, n2 );
                        fprintf( fasm, n3 );
                        fprintf( fasm, n4 );
                        fprintf( fasm, n5 );
                        }

                fprintf( fasm,
                        "MSG segment\n" );
                }
        }





void SetFar()
{

        if( f32Bit ){
                if( !didfar ){
                        fprintf( fasm, "FAR_MSG_tbl EQU $\n" );
                        fprintf( fasm, "\tpublic FAR_MSG_tbl\n" );
                        didfar++;
                        }
                else{
                        /* Rather than modify mkmsg to handle mixed NEAR / FAR */
                        /* I (Jeff Spencer) chose the quick route of limiting it's capabilities */
                        /* As this capability wasn't needed for MASM 5.1 */
                        printf( "error - 32 bit version doesn't support alternating NEAR and FAR messages\n" );
                        exit( -1 );
                        }
                }
        else{
                if (!didfar) {
                        didfar++;
                        fprintf( fasm, f1 );
                        fprintf( fasm, f2 );
                        fprintf( fasm, f3 );
                        fprintf( fasm, f4 );
                        fprintf( fasm, f5 );
                        }

                fprintf( fasm,
                        "FAR_MSG segment\n" );
                }
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\ui.c ===
/* dos prompting-style user interface
**
** currently supports interfaces for:
**	masm, cref
**
** written by:
**	randy nevin, microsoft, 5/15/85
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
**
** (c)copyright microsoft corp 1985
*/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
void terminate( unsigned short message, char *arg1, char *arg2, char *arg3 );

#if defined OS2_2 || defined OS2_NT   /* OS2 2.0 or NT? */
/* Use common MSDOS code also */
    #define MSDOS
    #define FLATMODEL
    #define FAR
    #define PASCAL
#else
    #define FAR far
    #define PASCAL pascal
#endif

#ifdef MSDOS
    #include <dos.h>
#endif

#ifdef MASM
    #include "asmmsg.h"
#else
    #include "crefmsg.h"
#endif

#define GLOBAL		/* C functions and external vars global by default */
#define	LOCAL		static
#define EXTERNAL	extern

#define MASTER	0	/* file name must be present, and is inherited */
#define INHERIT	1	/* if no file name, inherit from Master */
#define NUL	2	/* file name is NUL.ext if not given */

#define SLASHORDASH	0
#define SLASHONLY	1
#define DASHONLY	2

#define TOLOWER(c)	(c | 0x20)	/* works only for alpha inputs */

#ifdef MSDOS
    #define SEPARATOR	'\\'
    #define ALTSEPARATOR	'/'
    #if !defined CPDOS && !defined OS2_2 && !defined OS2_NT
        #define ARGMAX	 128	 /* maximum length of all arguments */
    #else
        #define ARGMAX	 512	 /* maximum length of all arguments */
    #endif
LOCAL char Nul[] = "NUL";
//  extern char *getenv();
    #ifdef MASM
LOCAL unsigned char switchar = SLASHORDASH;
EXTERNAL short errorcode;
    #else
LOCAL unsigned char switchar = SLASHONLY;
    #endif
    #define ERRFILE	stdout
#else
    #define SEPARATOR	'/'
    #define ARGMAX		5120	/* maximum length of all arguments */
LOCAL char Nul[] = "nul";
LOCAL unsigned char switchar = DASHONLY;
    #define ERRFILE	stderr
#endif

#if defined MSDOS && !defined FLATMODEL
extern char near * pascal __NMSG_TEXT();
extern char FAR * pascal __FMSG_TEXT();
#endif
#if defined MSDOS && defined FLATMODEL
/* For FLATMODEL map message functions to the replacements	 */
    #define __NMSG_TEXT NMsgText
    #define __FMSG_TEXT FMsgText
extern char * NMsgText();
extern char * FMsgText();
#endif

#ifdef MASM
    #define FILES		4	/* number to prompt for */
    #define EX_HEAP	8	/* exit code if heap fails */
    #define EX_DSYM		10	/* error defining symbol from command line */
    #define PX87		1

    #define CVLINE		1
    #define CVSYMBOLS	2

    #define TERMINATE(message, exitCode)\
	terminate((exitCode << 12) | message, 0, 0, 0)

    #define TERMINATE1(message, exitCode, a1)\
	terminate((exitCode << 12) | message, a1, 0, 0)

    #ifdef MSDOS
LOCAL char *Prompt[FILES] = {
    "Source filename [",
    "Object filename [",
    "Source listing  [",
    "Cross-reference ["
};
    #endif

LOCAL char *Ext[FILES] = {  /* default extensions */
    #ifdef MSDOS
    ".ASM",
    ".OBJ",
    ".LST",
    ".CRF"
    #else
    ".asm",
    ".obj",
    ".lst",
    ".crf"
    #endif
};

LOCAL unsigned char Default[FILES] = {  /* default root file name */
    MASTER,
    INHERIT,
    NUL,
    NUL
};
#endif

#ifdef CREF
    #define FILES		2	/* number to prompt for */
    #define EX_HEAP	1	/* exit code if heap fails */

    #ifdef MSDOS
LOCAL char *Prompt[FILES] = {
    "Cross-reference [",
    "Listing ["
};
    #endif

LOCAL char *Ext[FILES] = {  /* default extensions */
    #ifdef MSDOS
    ".CRF",
    ".REF"
    #else
    ".crf",
    ".ref"
    #endif
};

LOCAL unsigned char Default[FILES] = {  /* default root file name */
    MASTER,
    INHERIT
};
#endif

GLOBAL char *file[FILES];  /* results show up here; caller knows how many */

LOCAL char *Buffer;
LOCAL char *Master = NULL;
LOCAL unsigned char Nfile = 0;      /* file[Nfile] is the next one to set */
LOCAL unsigned char FirstLine = 1;  /* defaults are different for first line */

extern unsigned short warnlevel;    /* warning level */
extern unsigned short codeview;     /* codeview obj level */
extern char loption;            /* listing options */
extern char crefopt;            /* cross reference options */

#ifdef MSDOS
    #if defined OS2_2 || defined OS2_NT
/* OS2 2.0 command line variables will go here */
    #else
        #if defined CPDOS
/* OS2 1.X variables */
EXTERNAL unsigned _aenvseg;
EXTERNAL unsigned _acmdln;
        #else
/* DOS variables */
EXTERNAL unsigned _psp;  /* segment addr of program segment prefix */
        #endif
    #endif
#endif

#ifdef MASM
LOCAL unsigned char lflag = 0;
LOCAL unsigned char cflag = 0;
EXTERNAL char terse;
EXTERNAL unsigned short errornum;
EXTERNAL char lbuf[256 + 512 + 1];
void PASCAL error_line (struct _iobuf *, unsigned char *, short);
#else
char lbuf[512];
#endif

#ifndef MSDOS
EXTERNAL char *gets();
#endif

//EXTERNAL char *strcat(), *strcpy(), *_strdup(), *strchr(), *strrchr();

LOCAL int DoArgs(); /* defined below */
LOCAL int DoName(); /* defined below */
LOCAL int DoNull(); /* defined below */
LOCAL char *DoSwitch(); /* defined below */
LOCAL HeapError();  /* defined below */

#ifdef MSDOS
LOCAL DoPrompt();  /* defined below */
LOCAL TryAgain();  /* defined below */
#endif



GLOBAL void
UserInterface (
              /* get file names & switches from args and subsequent prompts */
              int argc,
              char **argv,
              char *banner
              ){
    register char *p;
    register unsigned length;
#if defined MSDOS && !defined OS2_2 && !defined OS2_NT
    char FAR *q;
#else
    unsigned count;
#endif

    Buffer = lbuf;

#ifdef MASM
    #ifdef MSDOS
    if ((p = getenv("MASM"))) { /* do initialization vars first */
        strcpy( Buffer, p ); /* fetch them into the buffer */
        DoArgs(); /* process them */
    }
    #endif
#endif

    p = Buffer;

#if defined MSDOS && !defined OS2_2 && !defined OS2_NT
    #if defined CPDOS
    /* this is how we get the command line if we're on CPDOS */

    FP_SEG( q ) = _aenvseg;
    FP_OFF( q ) = _acmdln;

    while (*q++) ;          /* skip argv[0] */

    while (isspace( *q ))  /* skip blanks between argv[0] and argv[1] */
        q++;

    length = sizeof(lbuf) - 1;
    while (length-- && (*p++ = *q++)) /* copy command line arguments */
        ;
    #else
    /* this is how we get the command line if we're on MSDOS */
    FP_SEG( q ) = _psp;
    FP_OFF( q ) = 0x80;
    length = *q++ & 0xFF;

    while (length--)
        *p++ = *q++;

    *p = '\0';
    #endif
#else
    /* this is how we get the command line if we're on XENIX or OS2 2.0 */
    argv++;
    count = ARGMAX - 1;

    while (--argc) {  /* concatenate args */
        if ((length = strlen( *argv )) > count)  /* don't overflow */
            length = count;

        strncpy( p, *argv++, length );
        p += length;

        if ((count -= length) && *argv) {  /* separator */
            *p++ = ' ';
            count--;
        }
    }

    #if !defined OS2_2 && !defined OS2_NT
    *p++ = ';';
    #endif
    *p = '\0';
#endif

#ifdef CREF
    printf( "%s", banner );
#endif

    DoArgs();

#ifdef MASM
    if (!terse)
        printf( "%s", banner );
#endif

#ifdef MSDOS
    FirstLine = 0;

    while (Nfile < FILES)
        DoPrompt();
#endif

    if (Master && Master != Nul)
        free( Master );
}


LOCAL int
DoArgs ()
/* process concatenated args looking for file names and switches */
{
    register char *p;
    register char *q;
    char *filename = NULL;

    for (p = Buffer; *p; p++)
#ifdef MSDOS
        if (*p == '/'
            && (switchar == SLASHONLY || switchar == SLASHORDASH)
            || *p == '-'
            && (switchar == DASHONLY || switchar == SLASHORDASH))
#else
        if (*p == '-')
#endif
        {  /* application dependent switch */
#ifdef MSDOS
            if (switchar == SLASHORDASH)
                switchar = *p == '/' ? SLASHONLY : DASHONLY;
#endif
            p = DoSwitch( p );
        } else if (*p == ';') {  /* use defaults for everything else */
            if (DoName( filename )) {  /* possibly NULL */
#ifdef MSDOS
                TryAgain();
                return( 1 );
#else
    #ifdef MASM
                printf( __NMSG_TEXT(ER_EXS) );
    #else
                printf( __NMSG_TEXT(ER_EXC) );
    #endif
                exit( 1 );
#endif
            }

            FirstLine = 0;  /* ...and away we go! */

            while (Nfile < FILES)
                if (DoNull()) {
#ifdef MSDOS
                    TryAgain();
                    return( 1 );
#else
    #ifdef MASM
                    printf( __NMSG_TEXT(ER_EXS) );
    #else
                    printf( __NMSG_TEXT(ER_EXC) );
    #endif
                    exit( 1 );
#endif
                }

            return( 0 );
        } else if (*p == ',') {  /* file name separator */
            if (DoName( filename )) {  /* possibly NULL */
#ifdef MSDOS
                TryAgain();
                return( 1 );
#else
    #ifdef MASM
                printf( __NMSG_TEXT(ER_EXS) );
    #else
                printf( __NMSG_TEXT(ER_EXC) );
    #endif
                exit( 1 );
#endif
            }

            filename = NULL;
        } else if (!isspace( *p )) {  /* gather filename */
            q = p + 1;

            while (*q && *q != ';' && *q != ',' && !isspace( *q )) {
#ifdef MSDOS
                if (*q == '/')
                    if (switchar == SLASHONLY)
                        break;
                    else if (switchar == SLASHORDASH) {
                        switchar = SLASHONLY;
                        break;
                    }
#endif
                q++;
            }

            if (filename) {  /* already have one */
                if (DoName( filename )) {
#ifdef MSDOS
                    TryAgain();
                    return( 1 );
#else
    #ifdef MASM
                    printf( __NMSG_TEXT(ER_EXS) );
    #else
                    printf( __NMSG_TEXT(ER_EXC) );
    #endif
                    exit( 1 );
#endif
                }
            }

            if (!(filename = malloc( (size_t)(q - p + 1) )))
                HeapError();
            else {  /* remember file name */
                strncpy( filename, p, (size_t)(q - p) );
                filename[q - p] = '\0';
            }

            p = q - 1;  /* go to end of file name */
        }

    if (filename && DoName( filename )) {
#ifdef MSDOS
        TryAgain();
        return( 1 );
#else
    #ifdef MASM
        printf( __NMSG_TEXT(ER_EXS) );
    #else
        printf( __NMSG_TEXT(ER_EXC) );
    #endif
        exit( 1 );
#endif
    }

    return( 0 );
}


LOCAL int
DoName ( filename )
/* enter filename as next file name, if appropriate (possibly NULL) */
char *filename;
{
    register char *p;
    register char *q;
    int cb;

    if (Nfile >= FILES) {  /* too many file names */
        if (filename) {
            fprintf(ERRFILE,__NMSG_TEXT(ER_EXT) );
            free( filename );
        }

        return( 0 );
    }

    if (!filename)  /* try (MASTER)/INHERIT/NUL */
        return( DoNull() );

    if (p = strrchr( filename, SEPARATOR ))
        p++;
#ifdef MSDOS
    else if ((p = strrchr( filename, ':' )) &&   /* look for drive specifier */
             p[1] != 0 )

        p++;
#endif
    else
        p = filename;

#ifdef MSDOS
    if (q = strrchr( p, ALTSEPARATOR ))
        p = q + 1;
#endif

    /* p points to first char of filename past last '\' or ':', if any */

    if (!*p)  /* last char of filename is '\' or ':'; assume directory */
        switch (Default[Nfile]) {
            case MASTER:
#ifdef MSDOS
                fprintf(ERRFILE,__NMSG_TEXT(ER_INV) );
#endif
                free( filename );
                return( 1 );
                break;
            default:
                /* case NUL: */
#ifdef MSDOS
                if (!FirstLine) {
                    if (!(p = malloc( strlen( filename )
                                      + strlen( Nul )
                                      + strlen( Ext[Nfile] ) + 1 )))
                        HeapError();

                    strcat( strcat( strcpy( p, filename ), Nul ), Ext[Nfile] );
                    break;
                }
                /* else just treat as inherited from Master */
#endif
            case INHERIT:
                if (!Master)
                    Master = Nul;

                if (!(p = malloc( strlen( filename )
                                  + strlen( Master )
                                  + strlen( Ext[Nfile] ) + 1 )))
                    HeapError();

                strcat( strcat( strcpy( p, filename ), Master ), Ext[Nfile] );
                break;
        } else {  /* some sort of file name is present */
        if (Default[Nfile] == MASTER)  /* save Master file name */
            if (q = strchr( p, '.' )) {
                if (!(Master = malloc( (size_t)(q - p + 1) )))
                    HeapError();

                strncpy( Master, p, (size_t)(q - p) );
                Master[q - p] = '\0';
            } else if (!(Master = _strdup( p )))
                HeapError();

        if (strchr( p, '.' )) {  /* extension present */
            if (!(p = _strdup( filename )))
                HeapError();
        } else {  /* supply default extension */
            cb = 0;

            if (p[1] == ':' && p[2] == 0)
                cb = strlen(Master);

            if (!(p = malloc( strlen( filename )
                              + strlen( Ext[Nfile] ) + 1 + cb ) ))
                HeapError();

            strcat(strcat(strcpy( p,
                                  filename ),
                          (cb)? Master: ""),
                   Ext[Nfile] );
        }
    }

    file[Nfile++] = p;
    free( filename );
    return( 0 );
}


LOCAL int
DoNull ()
/* select the default name (depends on if FirstLine or not) */
{
    char *p;

    switch (Default[Nfile]) {
        case MASTER:
#ifdef MSDOS
            fprintf(ERRFILE,__NMSG_TEXT(ER_INV) );
#endif
            return( 1 );
            break;
        default:
            /* case NUL: */
            if (!FirstLine
#ifdef MASM
                && !(lflag && Nfile == 2)
                && !(cflag && Nfile == 3)
#endif
               ) {
                if (!(p = malloc( strlen( Nul ) + 1
                                  + strlen( Ext[Nfile] ) )))
                    HeapError();

                strcat( strcpy( p, Nul ), Ext[Nfile] );
                break;
            }
            /* else just treat as inherited from Master */
        case INHERIT:
            if (!Master)
                Master = Nul;

            if (!(p = malloc( strlen( Master ) + 1
                              + strlen( Ext[Nfile] ) )))
                HeapError();

            strcat( strcpy( p, Master ), Ext[Nfile] );
            break;
    }

    file[Nfile++] = p;
    return( 0 );
}


#ifdef MASM
    #define FALSE		0
    #define TRUE		1

    #ifdef MSDOS
        #define DEF_OBJBUFSIZ 8
    #endif

    #define CASEU		0
    #define CASEL		1
    #define CASEX		2

    #define INCLUDEMAX	10
    #define EX_ARGE	1

    #ifdef MSDOS
EXTERNAL unsigned short obufsiz;
    #endif

EXTERNAL char segalpha;
EXTERNAL char debug;
EXTERNAL char fltemulate;
EXTERNAL char X87type;
EXTERNAL char inclcnt;
EXTERNAL char *inclpath[];
EXTERNAL char caseflag;
EXTERNAL char dumpsymbols;
EXTERNAL char verbose;
EXTERNAL char origcond;
EXTERNAL char listconsole;
EXTERNAL char checkpure;

int PASCAL definesym();

/* process masm switches */

LOCAL char * DoSwitch ( p )
register char *p;
{
    char *q;
    char *r;
    char c;
    int i;

    switch (TOLOWER(*++p)) {
        case 'a':
            segalpha = TRUE;
            break;
    #ifdef MSDOS
        case 'b':
            for (p++; isdigit(p[1]); p++);

            break;
    #endif
        case 'c':
            cflag = TRUE;
            if (isalpha (p[1])) {
                if (TOLOWER(*++p) == 's')
                    crefopt++;
                else {
                    TERMINATE1(ER_UNS, EX_ARGE, (char *)*p );
                    return 0;
                }
            }
            break;

        case 'd':
            if (!*++p || isspace( *p ) || *p == ',' || *p == ';') {
                debug = TRUE;
                p--;
            } else {
                for (q = p + 1; *q && !isspace( *q )
                    && *q != '=' && *q != ','
                    && *q != ';'; q++)
                    ;

                if (*q == '=') {
                    q++;
                    while (*q && !isspace( *q )
                           && *q != ',' && *q != ';')
                        q++;
                }

                c = *q;
                *q = '\0';
                definesym( p );

                if (errorcode) {
                    error_line (ERRFILE, "command line", 0);

                    if (errornum)
                        exit (EX_DSYM);
                }
                *q = c;
                p = q - 1;
            }

            break;

        case 'e':
            fltemulate = TRUE;
            X87type = PX87;
            break;
        case 'h':
    #ifdef FLATMODEL
            printf("%s\n", __FMSG_TEXT(ER_HDUSE));
    #else
            printf("%Fs\n", __FMSG_TEXT(ER_HDUSE));
    #endif
            for (i = ER_H01; i <= ER_H18; i++)
    #ifdef FLATMODEL
                printf( "\n/%s", __FMSG_TEXT(i));
    #else
                printf( "\n/%Fs", __FMSG_TEXT(i));
    #endif

            exit( 0 ); /* let him start again */
            break;
        case 'i':
            for (q = ++p; *q &&
                !isspace( *q ) && *q != ',' && *q != ';' &&
                *q != (switchar == DASHONLY? '-': '/'); q++)
                ;

            if (q == p)
                TERMINATE(ER_PAT, EX_ARGE );

            if (inclcnt < INCLUDEMAX - 1) {
                if (!(r = malloc( (size_t)(q - p + 1) )))
                    HeapError();

                strncpy( r, p, (size_t)(q - p) );
                r[q - p] = '\0';
                inclpath[inclcnt++] = r;
            }

            p = q - 1;
            break;
        case 'l':
            lflag = TRUE;
            if (isalpha (p[1])) {
                if (TOLOWER(*++p) == 'a')
                    loption++;
                else {
                    TERMINATE1(ER_UNS, EX_ARGE, (char *)*p );
                    return 0;
                }
            }
            break;
        case 'm':
            switch (TOLOWER(*++p)) {
                case 'l':
                    caseflag = CASEL;
                    break;
                case 'u':
                    caseflag    =    CASEU;
                    break;
                case 'x':
                    caseflag = CASEX;
                    break;
                default:
                    TERMINATE1(ER_UNC, EX_ARGE, (char *)*p );
                    return 0;
            }

            break;
        case 'n':
            dumpsymbols = FALSE;
            break;
        case 'p':
            checkpure = TRUE;
            break;
        case 'r':           /* old switch ignored */
            break;
        case 's':
            segalpha = FALSE;
            break;
        case 't':
            terse = TRUE;
            verbose = FALSE;
            break;
        case 'v':
            verbose = TRUE;
            terse = FALSE;
            break;

        case 'w':
            if (! isdigit(p[1]) ||
                (warnlevel = (unsigned short)(atoi(&p[1]) > 2))) {

                TERMINATE(ER_WAN, EX_ARGE );
                return 0;
            }

            for (p++; isdigit(p[1]); p++);
            break;

        case 'x':
            origcond = TRUE;
            break;
        case 'z':   /* Zd or Zi apply to codeview */

            if (TOLOWER(p[1]) == 'd') {
                codeview = CVLINE;
                p++;
                break;
            } else if (TOLOWER(p[1]) == 'i') {
                codeview = CVSYMBOLS;
                p++;
                break;
            }

            /* else its just a Z */

            listconsole = TRUE;
            break;
        default:
            TERMINATE1(ER_UNS, EX_ARGE, (char *)*p );
            return 0;
    }

    return( p );
}
#endif

#ifdef CREF
LOCAL char *
DoSwitch ( /* p */ )
/* process cref switches (presently, none) */
/* char *p; */
{
    fprintf( stderr, "cref has no switches\n" );
    exit( 1 );
}
#endif


#ifdef MSDOS
LOCAL
DoPrompt ()
/* prompt user for a file name (any number of optional switches) */
{
    unsigned char oldNfile;

    fprintf(stderr, Prompt[Nfile] );

    switch (Default[Nfile]) {
        case MASTER:
            break;
        case INHERIT:
            fprintf(stderr, Master );
            break;
        default:
            /* case NUL: */
            fprintf(stderr, Nul );
            break;
    }

    fprintf(stderr, "%s]: ", Ext[Nfile] );

    if (!gets( Buffer )) {
        fprintf(ERRFILE,__NMSG_TEXT(ER_SIN) );

    #ifdef MASM
        exit( EX_ARGE );
    #else
        exit( 1 );
    #endif
    }

    oldNfile = Nfile;

    if (!DoArgs() && oldNfile == Nfile && DoNull())
        TryAgain();
    return (0);
}
#endif


LOCAL
HeapError ()
/* malloc() has failed; exit program */
{
#ifdef CREF

    fprintf(ERRFILE,__NMSG_TEXT(ER_HEP));
    exit(EX_HEAP);
#else
    TERMINATE(ER_HEP, EX_HEAP);
#endif
    return (0);
}


#ifdef MSDOS
LOCAL
TryAgain ()
/* user caused fatal error; start reprompting from beginning */
{
    if (Master && Master != Nul) {
        free( Master );
        Master = NULL;
    }

    while (Nfile)
        free( file[--Nfile] );

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\version.c ===
char version[] = "@(#) Microsoft (R) Macro Assembler Version 5.NT.02";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\masm\version.inc ===
?PLM = 0		; no pl/m calling conventions
?WIN = 0

ifndef NOCODENEAR
 CODENEAR equ 1
endif

ifdef SMALL
 memS	equ	1	; small model
endif

ifdef MEDIUM
 memM	equ	1	; medium model
endif

ifdef LARGE
 memL	equ	1	; large model
endif

ifndef SMALL
 ifndef MEDIUM
  ifndef LARGE
%out <must choose a memory model; SMALL/MEDIUM/LARGE>
  endif
 endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\mclex.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mclex.c

Abstract:

    This file contains the input lexer for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 21-Aug-1991

Revision History:

--*/


#include "mc.h"

#define MAXLINELENGTH  8192

WCHAR LineBuffer[ MAXLINELENGTH ];
WCHAR *CurrentChar;
BOOL ReturnCurrentToken;

PNAME_INFO KeywordNames;

typedef struct _COMMENT_INFO {
    struct _COMMENT_INFO *Next;
    WCHAR Text[ 1 ];
} COMMENT_INFO, *PCOMMENT_INFO;

PCOMMENT_INFO Comments, CurrentComment;

BOOL
McInitLexer( void )
{
    ReturnCurrentToken = FALSE;
    McAddName( &KeywordNames, L"MessageIdTypedef",   MCTOK_MSGIDTYPE_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"SeverityNames",      MCTOK_SEVNAMES_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"FacilityNames",      MCTOK_FACILITYNAMES_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"LanguageNames",      MCTOK_LANGNAMES_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"MessageId",          MCTOK_MESSAGEID_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"Severity",           MCTOK_SEVERITY_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"Facility",           MCTOK_FACILITY_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"SymbolicName",       MCTOK_SYMBOLNAME_KEYWORD, NULL );
    McAddName( &KeywordNames, L"Language",           MCTOK_LANGUAGE_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"OutputBase",         MCTOK_OUTBASE_KEYWORD,    NULL );
    McAddName( &KeywordNames, L"MessageIdTypedefMacro",  MCTOK_MSGTYPEDEF_KEYWORD, NULL );
    return( TRUE );
}


BOOL
McOpenInputFile( void )
{
    char *PatchExt, *s, *FilePart;
    BOOL Result;

    PatchExt = NULL;
    s = MessageFileName + strlen( MessageFileName );
    FilePart = MessageFileName;
//    while (--s > MessageFileName) {
    while ((s = CharPrev(MessageFileName, s)) > MessageFileName) {
        if (*s == '.' && PatchExt == NULL) {
            PatchExt = s;
            *PatchExt = '\0';
        } else
        if (*s == ':' || *s == '\\' || *s == '/') {
            FilePart = s+1;
            break;
        }
    }
    MessageFileNameNoExt = malloc( strlen( FilePart ) + 1 );
    if (!MessageFileNameNoExt) {
        McInputErrorA( "Out of memory capturing file name", TRUE, NULL );
        return FALSE;
    }

    strcpy( MessageFileNameNoExt, FilePart );

    strcat( DebugFileName, MessageFileNameNoExt );
    strcat( DebugFileName, ".dbg" );
    strcat( HeaderFileName, MessageFileNameNoExt );
    strcat( HeaderFileName, "." );
    strcat( HeaderFileName, HeaderFileExt );
    strcat( RcInclFileName, MessageFileNameNoExt );
    strcat( RcInclFileName, ".rc" );

    if (PatchExt == NULL) {
        strcat( MessageFileName, ".mc" );
    } else {
        *PatchExt = '.';
    }

    MessageFileLineNumber = 0;
    LineBuffer[ 0 ] = L'\0';
    CurrentChar = NULL;

    Result = FALSE;
    MessageFile = fopen( MessageFileName, "rb" );
    if (MessageFile == NULL) {
        McInputErrorA( "unable to open input file", TRUE, NULL );
    } else {

        if (GenerateDebugFile) {
            DebugFile = fopen( DebugFileName, "wb" );
            if (DebugFile == NULL) {
                McInputErrorA( "unable to open output file - %s", TRUE, DebugFileName );
                goto fail;
            }
        }

        HeaderFile = fopen( HeaderFileName, "wb" );
        if (HeaderFile == NULL) {
            McInputErrorA( "unable to open output file - %s", TRUE, HeaderFileName );
        } else {
            RcInclFile = fopen( RcInclFileName, "wb" );
            if (RcInclFile == NULL) {
                McInputErrorA( "unable to open output file - %s", TRUE, RcInclFileName );
            } else {
                Result = TRUE;
            }
        }
    }

fail:
    if (!Result) {
        McCloseInputFile();
        McCloseOutputFiles(Result);
    }

    return( Result );
}


void
McCloseInputFile( void )
{
    if (MessageFile != NULL) {
        fclose( MessageFile );
        MessageFile = NULL;
        CurrentChar = NULL;
        LineBuffer[ 0 ] = L'\0';
    }
}


void
McClearArchiveBit( LPSTR Name )
{
    DWORD Attributes;

    Attributes = GetFileAttributes(Name);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(Name, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }

    return;
}

void
McCloseOutputFiles(
    BOOL Success
    )
{
    if (DebugFile != NULL) {
        fclose( DebugFile );
        if (!Success) {
            _unlink(DebugFileName);
        } else {
            McClearArchiveBit(DebugFileName);
        }
    }

    if (HeaderFile != NULL) {
        fclose( HeaderFile );
        if (!Success) {
            _unlink(HeaderFileName);
        } else {
            McClearArchiveBit(HeaderFileName);
        }
    }

    if (RcInclFile != NULL) {
        fclose( RcInclFile );
        if (!Success) {
            _unlink(RcInclFileName);
        } else {
            McClearArchiveBit(RcInclFileName);
        }
    }
}


void
McInputErrorA(
    char *Message,
    BOOL Error,
    PVOID Argument
    )
{
    if (Error) {
        InputErrorCount += 1;
    }

    fprintf( stderr,
             "%s(%d) : %s : ",
             MessageFileName,
             MessageFileLineNumber,
             Error ? "error" : "warning"
           );

    fprintf( stderr, Message, Argument );
    fprintf( stderr, "\n" );
}


void
McInputErrorW(
    WCHAR *Message,
    BOOL Error,
    PVOID Argument
    )
{
    WCHAR buffer[ 256 * 2 ];

    fprintf( stderr,
             "%s(%d) : %s : ",
             MessageFileName,
             MessageFileLineNumber,
             Error ? "error" : "warning"
           );

    if (Error) {
        InputErrorCount += 1;
    }

    swprintf( buffer, Message, Argument );
    wcscat( buffer, L"\n" );

    if (UnicodeInput) {
        DWORD dwMode;
        DWORD cbWritten;
        HANDLE fh;

        fh = (HANDLE) _get_osfhandle( _fileno( stderr ) );
        if (GetConsoleMode( fh, &dwMode ))
            WriteConsoleW( fh, buffer, wcslen( buffer ), &cbWritten, NULL );
        else
            fwprintf( stderr, buffer );
    } else {
        BYTE chBuf[ 256 * 2 ];

        memset( chBuf, 0, sizeof( chBuf ) );
        WideCharToMultiByte( CP_OEMCP, 0, buffer, -1, chBuf, sizeof(chBuf), NULL, NULL );
        fprintf( stderr, chBuf );
    }
}


WCHAR *
McGetLine( void )
{
    WCHAR *s;

    if (MessageFile == NULL || feof( MessageFile )) {
        return( NULL );
    }

    if (fgetsW( LineBuffer,
                (sizeof( LineBuffer ) / sizeof( WCHAR )) - 1,
                MessageFile ) == NULL) {
        return( NULL );
    }

    s = LineBuffer + wcslen( LineBuffer );
    if (s > LineBuffer && *--s == L'\n') {
        if (s > LineBuffer && *--s != L'\r') {
            *++s = L'\r';
            *++s = L'\n';
            *++s = L'\0';
        }
    }

    MessageFileLineNumber++;
    return( CurrentChar = LineBuffer );
}


void
McSkipLine( void )
{
    CurrentChar = NULL;
}


WCHAR
McGetChar(
    BOOL SkipWhiteSpace
    )
{
    BOOL SawWhiteSpace;
    BOOL SawNewLine;
    PCOMMENT_INFO p;

    SawWhiteSpace = FALSE;

tryagain:
    SawNewLine = FALSE;
    if (CurrentChar == NULL) {
        McGetLine();
        if (CurrentChar == NULL) {
            return( L'\0' );
            }

        SawNewLine = TRUE;
    }

    if (SkipWhiteSpace) {
        while (*CurrentChar <= L' ') {
            SawWhiteSpace = TRUE;
            if (!*CurrentChar++) {
                CurrentChar = NULL;
                break;
            }
        }
    }

    if (SawNewLine) {
        if (CurrentChar != NULL) {

            /* Check for Byte Order Mark during Unicode input */
            if (UnicodeInput) {
                if (*CurrentChar == 0xFEFF) {
                    CurrentChar++;
                }
            }

            if (*CurrentChar == MCCHAR_END_OF_LINE_COMMENT) {
                p = malloc( sizeof( *p ) + wcslen( ++CurrentChar ) * sizeof( WCHAR ));
                if (!p) {
                    McInputErrorA( "Out of memory reading chars", TRUE, NULL );
                    return 0;
                }
                p->Next = NULL;
                wcscpy( p->Text, CurrentChar );
                if (CurrentComment == NULL) {
                    Comments = p;
                } else {
                    CurrentComment->Next = p;
                }
                CurrentComment = p;

                CurrentChar = NULL;
            }
        }
    }

    if (CurrentChar == NULL && SkipWhiteSpace) {
        goto tryagain;
    }

    if (SawWhiteSpace) {
        return( L' ' );
    } else {
        return( *CurrentChar++ );
    }
}


void
McFlushComments( void )
{
    PCOMMENT_INFO p;

    while (p = Comments) {
        fprintf( HeaderFile, "%ws", p->Text );

        Comments = Comments->Next;
        free( p );
    }
    Comments = NULL;
    CurrentComment = NULL;

    fflush( HeaderFile );
    return;
}


void
McUnGetChar(
    WCHAR c
    )
{
    if (CurrentChar > LineBuffer) {
        *--CurrentChar = c;
    } else {
        LineBuffer[ 0 ] = c;
        LineBuffer[ 1 ] = L'\0';
        CurrentChar = LineBuffer;
    }
}


unsigned int
McGetToken(
    BOOL KeywordExpected
    )
{
    WCHAR c, *dst;

    if (ReturnCurrentToken) {
        ReturnCurrentToken = FALSE;
        if (Token == MCTOK_NAME && KeywordExpected) {
            TokenKeyword = McFindName( KeywordNames, TokenCharValue );
            if (TokenKeyword == NULL) {
                McInputErrorW( L"expected keyword - %s", TRUE, TokenCharValue );
                Token = MCTOK_END_OF_FILE;
            } else {
                Token = (unsigned int)TokenKeyword->Id;
            }
        }

        return( Token );
    }

    Token = MCTOK_END_OF_FILE;
    dst = TokenCharValue;
    *dst = L'\0';
    TokenNumericValue = 0L;

    while (TRUE) {
        c = McGetChar( (BOOL)(Token == MCTOK_END_OF_FILE) );
        if (Token == MCTOK_NUMBER) {
            if (iswdigit( c ) ||
                c == L'x' ||
                (c >= L'a' && c <= L'f') ||
                (c >= L'A' && c <= L'F')
               ) {
                *dst++ = c;
            } else {
                McUnGetChar( c );
                *dst = L'\0';

                if (!McCharToInteger( TokenCharValue, 0, &TokenNumericValue )) {
                    McInputErrorW( L"invalid number - %s", TRUE, TokenCharValue );
                    Token = MCTOK_END_OF_FILE;
                } else {
                    return( Token );
                }
            }
        } else
        if (Token == MCTOK_NAME) {
            if (iswcsym( c )) {
                *dst++ = c;
            } else {
                McUnGetChar( c );
                *dst = L'\0';

                if (KeywordExpected) {
                    TokenKeyword = McFindName( KeywordNames, TokenCharValue );
                    if (TokenKeyword == NULL) {
                        McInputErrorW( L"expected keyword - %s", TRUE, TokenCharValue );
                        Token = MCTOK_END_OF_FILE;
                    } else {
                        Token = (unsigned int)TokenKeyword->Id;
                    }
                }
                return( Token );
            }
        } else
        if (iswdigit( c )) {
            *dst++ = c;
            Token = MCTOK_NUMBER;
        } else
        if (iswcsymf( c )) {
            *dst++ = c;
            Token = MCTOK_NAME;
        } else
        if (c == L'=') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_EQUAL;
            return( Token );
        } else
        if (c == L'(') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_LEFT_PAREN;
            return( Token );
        } else
        if (c == L')') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_RIGHT_PAREN;
            return( Token );
        } else
        if (c == L':') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_COLON;
            return( Token );
        } else
        if (c == L'+') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_PLUS;
            return( Token );
        } else
        if (c == L' ') {
        } else
        if (c == MCCHAR_END_OF_LINE_COMMENT) {
            Token = MCTOK_END_OF_LINE_COMMENT;
            wcscpy( TokenCharValue, CurrentChar );
            CurrentChar = NULL;
            return( Token );
        } else
        if (c == L'\0') {
            return( Token );
        } else {
            McInputErrorW( L"invalid character (0x%02x)", TRUE, (PVOID)UlongToPtr((UCHAR)c) );
        }
    }
}


void
McUnGetToken( void )
{
    ReturnCurrentToken = TRUE;
}

WCHAR *
McSkipWhiteSpace(
    WCHAR *s
    )
{
    while (*s <= L' ') {
        if (!*s++) {
            s = NULL;
            break;
        }
    }

    return( s );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\mcparse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mcparse.c

Abstract:

    This file contains the parse logic for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 22-Aug-1991

Revision History:

--*/

#include "mc.h"

WCHAR * wszMessageType = L"DWORD";      // Init to a known state

BOOL
McParseFile( void )
{
    unsigned int t;
    BOOL FirstMessageDefinition = TRUE;
    PNAME_INFO p;

    if (!McOpenInputFile()) {
        fprintf( stderr, "MC: Unable to open %s for input\n", MessageFileName );
        return( FALSE );
    }

    fprintf( stderr, "MC: Compiling %s\n", MessageFileName );
    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) {
        switch (t) {
        case MCTOK_MSGIDTYPE_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                    wszMessageType = MessageIdTypeName = McMakeString( TokenCharValue );
                } else {
                    McInputErrorW( L"Symbol name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_MSGTYPEDEF_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                    MessageIdTypeMacro = McMakeString( TokenCharValue );
                } else {
                    McInputErrorW( L"Symbol name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_OUTBASE_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                    if (TokenNumericValue == 16) {
                        GenerateDecimalMessageValues = FALSE;
                    } else if (TokenNumericValue == 10) {
                        GenerateDecimalMessageValues = TRUE;
                    } else {
                        McInputErrorW( L"Illegal value for %s=", TRUE, TokenKeyword->Name );
                    }
                } else {
                    McInputErrorW( L"Number must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_SEVNAMES_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) {
                    if (!McParseNameList( &SeverityNames, FALSE, 0x3L )) {
                        return( FALSE );
                    }
                } else {
                    McInputErrorW( L"Left parenthesis name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_FACILITYNAMES_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) {
                    if (!McParseNameList( &FacilityNames, FALSE, 0xFFFL )) {
                        return( FALSE );
                    }
                } else {
                    McInputErrorW( L"Left parenthesis name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_LANGNAMES_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) {
                    if (!McParseNameList( &LanguageNames, TRUE, 0xFFFFL )) {
                        return( FALSE );
                    }
                } else {
                    McInputErrorW( L"Left parenthesis name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_MESSAGEID_KEYWORD:
            McUnGetToken();
            if (FirstMessageDefinition) {
                FirstMessageDefinition = FALSE;
                McFlushComments();
                if (OleOutput) {
                    fputs(
                        "//\r\n"
                        "//  Values are 32 bit values layed out as follows:\r\n"
                        "//\r\n"
                        "//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\r\n"
                        "//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\r\n"
                        "//  +-+-+-+-+-+---------------------+-------------------------------+\r\n"
                        "//  |S|R|C|N|r|    Facility         |               Code            |\r\n"
                        "//  +-+-+-+-+-+---------------------+-------------------------------+\r\n"
                        "//\r\n"
                        "//  where\r\n"
                        "//\r\n"
                        "//      S - Severity - indicates success/fail\r\n"
                        "//\r\n"
                        "//          0 - Success\r\n"
                        "//          1 - Fail (COERROR)\r\n"
                        "//\r\n"
                        "//      R - reserved portion of the facility code, corresponds to NT's\r\n"
                        "//              second severity bit.\r\n"
                        "//\r\n"
                        "//      C - reserved portion of the facility code, corresponds to NT's\r\n"
                        "//              C field.\r\n"
                        "//\r\n"
                        "//      N - reserved portion of the facility code. Used to indicate a\r\n"
                        "//              mapped NT status value.\r\n"
                        "//\r\n"
                        "//      r - reserved portion of the facility code. Reserved for internal\r\n"
                        "//              use. Used to indicate HRESULT values that are not status\r\n"
                        "//              values, but are instead message ids for display strings.\r\n"
                        "//\r\n"
                        "//      Facility - is the facility code\r\n"
                        "//\r\n"
                        "//      Code - is the facility's status code\r\n"
                        "//\r\n",
                        HeaderFile );
                } else {
                    fputs(
                        "//\r\n"
                        "//  Values are 32 bit values layed out as follows:\r\n"
                        "//\r\n"
                        "//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\r\n"
                        "//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\r\n"
                        "//  +---+-+-+-----------------------+-------------------------------+\r\n"
                        "//  |Sev|C|R|     Facility          |               Code            |\r\n"
                        "//  +---+-+-+-----------------------+-------------------------------+\r\n"
                        "//\r\n"
                        "//  where\r\n"
                        "//\r\n"
                        "//      Sev - is the severity code\r\n"
                        "//\r\n"
                        "//          00 - Success\r\n"
                        "//          01 - Informational\r\n"
                        "//          10 - Warning\r\n"
                        "//          11 - Error\r\n"
                        "//\r\n"
                        "//      C - is the Customer code flag\r\n"
                        "//\r\n"
                        "//      R - is a reserved bit\r\n"
                        "//\r\n"
                        "//      Facility - is the facility code\r\n"
                        "//\r\n"
                        "//      Code - is the facility's status code\r\n"
                        "//\r\n",
                        HeaderFile );
                }

                fputs(
                    "//\r\n"
                    "// Define the facility codes\r\n"
                    "//\r\n",
                    HeaderFile );

                p = FacilityNames;
                while( p ) {
                    if (p->Value) {
                        fprintf( HeaderFile, GenerateDecimalSevAndFacValues ?
                                             "#define %-32ws %ld\r\n" :
                                             "#define %-32ws 0x%lX\r\n",
                                 p->Value, p->Id
                               );
                    }

                    p = p->Next;
                }
                fputs(
                    "\r\n"
                    "\r\n"
                    "//\r\n"
                    "// Define the severity codes\r\n"
                    "//\r\n",
                    HeaderFile );

                p = SeverityNames;
                while( p ) {
                    if (p->Value) {
                        fprintf( HeaderFile, GenerateDecimalSevAndFacValues ?
                                             "#define %-32ws %ld\r\n" :
                                             "#define %-32ws 0x%lX\r\n",
                                 p->Value, p->Id
                               );
                    }

                    p = p->Next;
                }

                fputs(
                    "\r\n"
                    "\r\n",
                    HeaderFile );

                if (GenerateDebugFile) {
                    fputs(
                        "//\n"
                        "// This file maps message Id values in to a text string that contains\n"
                        "// the symbolic name used for the message Id.  Useful for debugging\n"
                        "// output.\n"
                        "//\n\n"
                        "struct {\n",
                        DebugFile );

                    fprintf(
                        DebugFile,
                        "    %ws MessageId;\n"
                        "    char *SymbolicName;\n"
                        "} %sSymbolicNames[] = {\n",
                        wszMessageType,
                        MessageFileNameNoExt );
                }
            }

            if (!McParseMessageDefinition()) {
                return( FALSE );
            }
            break;

        default:
            McInputErrorW( L"Invalid message file token - '%s'", TRUE, TokenCharValue );
            return( FALSE );
            break;
        }
    }

    if (GenerateDebugFile) {
        fprintf( DebugFile, " (%ws) 0xFFFFFFFF, NULL\n};\n", wszMessageType );
    }

    McFlushComments();
    return( TRUE );
}


BOOL
McParseMessageDefinition( void )
{
    unsigned int t;
    PMESSAGE_INFO MessageInfo;
    BOOL MessageIdSeen;
    PMESSAGE_INFO MessageInfoTemp, *pp;

    McFlushComments();

    MessageInfo = malloc( sizeof( *MessageInfo ) );
    if (!MessageInfo) {
        McInputErrorA( "Out of memory parsing memory definitions.", TRUE, NULL );
        return( FALSE );
    }
    MessageInfo->Next = NULL;
    MessageInfo->Id = 0;
    MessageInfo->Method = MSG_PLUS_ONE;
    MessageInfo->SymbolicName = NULL;
    MessageInfo->EndOfLineComment = NULL;
    MessageInfo->MessageText = NULL;
    MessageIdSeen = FALSE;

    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) {
        switch (t) {
        case MCTOK_MESSAGEID_KEYWORD:
            if (MessageIdSeen) {
                McInputErrorA( "Invalid message definition - text missing.", TRUE, NULL );
                return( FALSE );
            }

            MessageIdSeen = TRUE;
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                    MessageInfo->Id = TokenNumericValue;
                    MessageInfo->Method = MSG_ABSOLUTE;
                } else
                if (t == MCTOK_PLUS) {
                    if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                        MessageInfo->Id = TokenNumericValue;
                        MessageInfo->Method = MSG_PLUS_VALUE;
                    } else {
                        McInputErrorW( L"Number must follow %s=+", TRUE, TokenKeyword->Name );
                        return( FALSE );
                    }
                } else {
                    McUnGetToken();
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_SEVERITY_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if (!McParseName( SeverityNames, &CurrentSeverityName )) {
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_FACILITY_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if (!McParseName( FacilityNames, &CurrentFacilityName )) {
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_SYMBOLNAME_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                    MessageInfo->SymbolicName = McMakeString( TokenCharValue );
                } else {
                    McInputErrorW( L"Symbol name must follow %s=+", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;


        case MCTOK_END_OF_LINE_COMMENT:
            MessageInfo->EndOfLineComment = McMakeString( TokenCharValue );
            break;

        case MCTOK_LANGUAGE_KEYWORD:
            McUnGetToken();


            if (MessageInfo->Method == MSG_PLUS_ONE) {
                MessageInfo->Id = CurrentFacilityName->LastId + 1;
            } else
            if (MessageInfo->Method == MSG_PLUS_VALUE) {
                MessageInfo->Id = CurrentFacilityName->LastId + MessageInfo->Id;
            }

            if (MessageInfo->Id > 0xFFFFL) {
                McInputErrorA( "Message Id value (%lx) too large", TRUE, (PVOID)UlongToPtr(MessageInfo->Id) );
                return( FALSE );
            }

            MessageInfo->Id |= (CurrentSeverityName->Id << 30) |
                               CustomerMsgIdBit |
                               (CurrentFacilityName->Id << 16);

            fprintf( HeaderFile, "//\r\n" );
            if (MessageInfo->SymbolicName) {
                fprintf( HeaderFile, "// MessageId: %ws\r\n",
                                     MessageInfo->SymbolicName
                       );
            } else {
                fprintf( HeaderFile, "// MessageId: 0x%08lXL (No symbolic name defined)\r\n",
                                     MessageInfo->Id
                       );
            }

            fprintf( HeaderFile, "//\r\n" );
            fprintf( HeaderFile, "// MessageText:\r\n" );
            fprintf( HeaderFile, "//\r\n" );

            if (McParseMessageText( MessageInfo )) {
                fprintf( HeaderFile, "//\r\n" );
                if (MessageInfo->SymbolicName) {
                    if (GenerateDebugFile) {
                        fprintf( DebugFile, " (%ws) %ws, \"%ws\",\n",
                                 wszMessageType,
                                 MessageInfo->SymbolicName,
                                 MessageInfo->SymbolicName
                               );
                    }

                    if (MessageIdTypeMacro != NULL) {
                        fprintf( HeaderFile, GenerateDecimalMessageValues ?
                                             "#define %-32ws %ws(%ldL)" :
                                             "#define %-32ws %ws(0x%08lXL)",
                                             MessageInfo->SymbolicName,
                                             MessageIdTypeMacro,
                                             MessageInfo->Id
                               );
                    } else {
                        if (MessageIdTypeName != NULL) {
                            fprintf( HeaderFile, GenerateDecimalMessageValues ?
                                                 "#define %-32ws ((%ws)%ldL)" :
                                                 "#define %-32ws ((%ws)0x%08lXL)",
                                                 MessageInfo->SymbolicName,
                                                 wszMessageType,
                                                 MessageInfo->Id
                                   );
                        } else {
                            fprintf( HeaderFile, GenerateDecimalMessageValues ?
                                                 "#define %-32ws %ldL" :
                                                 "#define %-32ws 0x%08lXL",
                                                 MessageInfo->SymbolicName,
                                                 MessageInfo->Id
                                   );
                        }
                    }
                }

                if (MessageInfo->EndOfLineComment) {
                    fprintf( HeaderFile, "    %ws", MessageInfo->EndOfLineComment );
                } else {
                    fprintf( HeaderFile, "\r\n" );
                }
                fprintf( HeaderFile, "\r\n" );

                //
                //  Scan the existing messages to see if this message
                //  exists in the message file.
                //
                //  If it does, generate and error for the user.  Otherwise
                //  insert new message in list in ascending Id order.
                //

                pp = &Messages;
                while (MessageInfoTemp = *pp) {
                    if (MessageInfoTemp->Id == MessageInfo->Id) {
                        if (MessageInfo->SymbolicName && MessageInfoTemp->SymbolicName) {
                            fprintf( stderr,
                                     "%s(%d) : error : Duplicate message ID - 0x%x (%ws and %ws)\n",
                                     MessageFileName,
                                     MessageFileLineNumber,
                                     MessageInfo->Id,
                                     MessageInfoTemp->SymbolicName,
                                     MessageInfo->SymbolicName
                                     );
                        } else {
                            McInputErrorA( "Duplicate message ID - 0x%lx", TRUE, (PVOID)UlongToPtr(MessageInfo->Id) );
                        }
                    } else {
                        if (MessageInfoTemp->Id > MessageInfo->Id) {
                            break;
                        }
                    }

                    pp = &MessageInfoTemp->Next;
                }

                MessageInfo->Next = *pp;
                *pp = MessageInfo;

                CurrentMessage = MessageInfo;
                CurrentFacilityName->LastId = MessageInfo->Id & 0xFFFF;
                return( TRUE );
            } else {
                return( FALSE );
            }

        default:
            McInputErrorW( L"Invalid message definition token - '%s'", TRUE, TokenCharValue );
            return( FALSE );
        }
    }

    return( FALSE );
}


WCHAR MessageTextBuffer[ 32767 ];

BOOL
McParseMessageText(
    PMESSAGE_INFO MessageInfo
    )
{
    PLANGUAGE_INFO MessageText, *pp;
    WCHAR *src, *dst;
    unsigned int t, n;
    BOOL FirstLanguageProcessed;

    pp = &MessageInfo->MessageText;

    FirstLanguageProcessed = FALSE;
    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) {
        if (t == MCTOK_LANGUAGE_KEYWORD) {
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if (!McParseName( LanguageNames, &CurrentLanguageName )) {
                    return( FALSE );
                }
                GetCPInfo(CurrentLanguageName->CodePage, &CPInfo);
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
        } else {
            McUnGetToken();
            break;
        }

        MessageText = malloc( sizeof( *MessageText ) );
        MessageText->Next = NULL;
        MessageText->Id = CurrentLanguageName->Id;
        MessageText->Length = 0;
        MessageText->Text = NULL;

        dst = MessageTextBuffer;
        *MessageTextBuffer = L'\0';
        while (src = McGetLine()) {
            n = wcslen( MessageTextBuffer );
            // If the message buffer is complete, see if this is a '.' record.
            if (((n == 0) || *(MessageTextBuffer+n-1) == L'\n') &&
                !wcscmp( src, L".\r\n" )) {
                if (MessageText->Length == 0) {
                    if (MessageInfo->SymbolicName) {
                        wcscpy( dst, MessageInfo->SymbolicName );
                    } else {
                        swprintf( dst, L"No symbolic name defined for0x%08lXL" );
                    }

                    wcscat( dst, L"\r\n" );
                    if (!FirstLanguageProcessed) {
                        fprintf( HeaderFile, "//  %ws", dst );
                    }

                    n = wcslen( dst );
                    dst += n;
                    MessageText->Length += n;
                }

                McSkipLine();
                break;
            }
            else if (!_wcsnicmp( src, L"LanguageId=", 11 ) ||
                     !_wcsnicmp( src, L"MessageId=", 10 )) {
                McInputErrorA( "Unterminated message definition", TRUE, NULL );
                return( FALSE );
            }

            if (!FirstLanguageProcessed) {
                // To write DBCS comments to the header file.
                //
                // fprintf() does not work correctly with Unicode
                // to write DBCS characters.  Convert Unicode to
                // MultiByte and use the Ansi string instead...
                char * pch;

                int len = WideCharToMultiByte(CurrentLanguageName->CodePage,
                                              0,        // No flags
                                              src,      // The buffer to convert
                                              -1,       // It's zero terminated
                                              NULL,
                                              0,        // Tell us how much to allocate
                                              NULL,     // No default char
                                              NULL);    // No used default char

                pch = malloc(len + 1);

                WideCharToMultiByte(CurrentLanguageName->CodePage,
                                              0,
                                              src,
                                              -1,
                                              pch,      // The buffer to fill in
                                              len,      // How big it is
                                              NULL,
                                              NULL);

                fprintf( HeaderFile, "//  %s", pch );
                free(pch);
            }

            n = wcslen( src );
            if (MessageText->Length + n > sizeof( MessageTextBuffer )) {
                McInputErrorA( "Message text too long (> %ld)", TRUE,
                              (PVOID)UlongToPtr((ULONG)sizeof( MessageTextBuffer ))
                            );
                return( FALSE );
            }

            wcscpy( dst, src );
            dst += n;
            MessageText->Length += n;

            if (MaxMessageLength != 0 && (MessageText->Length > (ULONG)MaxMessageLength)) {
                McInputErrorA( "Message text larger than size specified by -m %d",
                               TRUE,
                               (PVOID)IntToPtr(MaxMessageLength)
                             );
            }
        }
        *dst = L'\0';

        // Add NULL terminator if requested
        if (NULLTerminate) 
        {
            MessageText->Length -= 2;
            MessageTextBuffer[MessageText->Length] = L'\0';
        }
        n = (((USHORT)MessageText->Length) + 1) * sizeof( WCHAR );
        MessageText->Text = malloc( n );
        memcpy( MessageText->Text, MessageTextBuffer, n );
        if (UnicodeOutput)
            MessageText->Length = n - sizeof( WCHAR );
        else
            MessageText->Length = WideCharToMultiByte(
                    CurrentLanguageName->CodePage,
                    0, MessageTextBuffer, MessageText->Length,
                    NULL, 0, NULL, NULL );
        *pp = MessageText;
        pp = &MessageText->Next;
        FirstLanguageProcessed = TRUE;
    }

    return( TRUE );
}


BOOL
McParseNameList(
    PNAME_INFO *NameListHead,
    BOOL ValueRequired,
    ULONG MaximumValue
    )
{
    unsigned int t;
    PNAME_INFO p = NULL;
    WCHAR *Name;
    ULONG Id;
    PVOID Value;

    Name = NULL;
    Id = 0;

    while ((t = McGetToken( FALSE )) != MCTOK_END_OF_FILE) {
        if (t == MCTOK_RIGHT_PAREN) {
            return( TRUE );
        }

        if (t == MCTOK_NAME) {
            Name = McMakeString( TokenCharValue );
            Id = 0;
            Value = NULL;
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                    Id = TokenNumericValue;
                    if ((t = McGetToken( FALSE )) == MCTOK_COLON) {
                        if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                            Value = McMakeString( TokenCharValue );
                        } else {
                            McInputErrorA( "File name must follow =%ld:", TRUE, (PVOID)UlongToPtr(Id) );
                            return( FALSE );
                        }
                    } else {
                        if (ValueRequired) {
                            McInputErrorA( "Colon must follow =%ld", TRUE, (PVOID)UlongToPtr(Id) );
                            return( FALSE );
                        }

                        McUnGetToken();
                    }
                } else {
                    McInputErrorW( L"Number must follow %s=", TRUE, Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign name must follow %s", TRUE, Name );
                return( FALSE );
            }

            if (Id > MaximumValue) {
                McInputErrorA( "Value is too large (> %lx)", TRUE, (PVOID)UlongToPtr(MaximumValue) );
                return( FALSE );
            }

            p = McAddName( NameListHead, Name, Id, Value );
            free( Name );
        }
        else if (t == MCTOK_COLON && p) {
            if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                p->CodePage = (USHORT)TokenNumericValue;
                if (!IsValidCodePage(TokenNumericValue)) {
                    McInputErrorW( L"CodePage %d is invalid", TRUE, (PVOID)UlongToPtr(TokenNumericValue) );
                    return( FALSE );
                }
                if (VerboseOutput) {
                    fprintf( stderr, "Using CodePage %d for Language %04x\n", TokenNumericValue, Id);
                }
            } else {
                McInputErrorW( L"CodePage must follow %s=:", TRUE, Name );
                return( FALSE );
            }
        }
    }

    return( FALSE );
}

BOOL
McParseName(
    PNAME_INFO NameListHead,
    PNAME_INFO *Result
    )
{
    unsigned int t;
    PNAME_INFO p;

    if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
        p = McFindName( NameListHead, TokenCharValue );
        if (p != NULL) {
            *Result = p;
            return( TRUE );
        } else {
            McInputErrorW( L"Invalid name - %s", TRUE, TokenCharValue );
        }
    } else {
        McInputErrorW( L"Missing name after %s=", TRUE, TokenKeyword->Name );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\mc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mc.c

Abstract:

    This is the main source file for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 21-Aug-1991

Revision History:

--*/

#include "mc.h"
#include "version.h"
#include <ntverp.h>
#include <common.ver>

NAME_INFO DefaultLanguageName;

int UnicodeOutput=TRUE;
BOOL fUniqueBinName = FALSE;

void
ConvertAppToOem( unsigned argc, char* argv[] )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for (i = 0; i < argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}


void
InitializeMCNls( void );


void
McPrintUsage( void )
{
    fprintf(stderr,
            "Microsoft (R) Message Compiler  Version 1.12.%04d\n"
            VER_LEGALCOPYRIGHT_STR
            "\n\n",
            VER_PRODUCTBUILD);

    fputs("usage: MC [-?aAcdnosuUvw] [-m maxmsglen] [-h dirspec] [-e extension] [-r dirspec] [-x dbgFileSpec] filename.mc\n"
          "       -? - displays this message\n"
          "       -a - input file is ANSI (default).\n"
          "       -A - messages in .BIN file should be ANSI.\n"
          "       -b - .BIN filename should have .mc filename_ included for uniqueness.\n"
          "       -c - sets the Customer bit in all the message Ids.\n"
          "       -d - FACILTY and SEVERITY values in header file in decimal.\n"
          "            Sets message values in header to decimal initially.\n"
          "       -e extension - Specify the extension for the header file.\n"
          "                      From 1 - 3 chars.\n"
          "       -h pathspec - gives the path of where to create the C include file\n"
          "                     Default is .\\\n"
          "       -m maxmsglen - generate a warning if the size of any message exceeds\n"
          "                      maxmsglen characters.\n"
          "       -n - terminates all strings with null's in the message tables.\n"
          "       -o - generate OLE2 header file (use HRESULT definition instead of\n"
          "            status code definition)\n"
          "       -r pathspec - gives the path of where to create the RC include file\n"
          "                     and the binary message resource files it includes.\n"
          "                     Default is .\\\n"
          "       -s - insert symbolic name as first line of each message.\n"
          "       -u - input file is Unicode.\n"
          "       -U - messages in .BIN file should be Unicode (default).\n"
          "       -v - gives verbose output.\n"
          "       -w - warns if message text contains non-OS/2 compatible inserts.\n"
          "       -x pathspec - gives the path of where to create the .dbg C include\n"
          "                        file that maps message Ids to their symbolic name.\n"
          "       filename.mc - gives the names of a message text file\n"
          "                     to compile.\n"
          "       Generated files have the Archive bit cleared.\n",
          stderr);
}


int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char c, *s, *s1;
    int i;
    int ShowUsage;

    setlocale(LC_ALL, "");

    if (argc == 1) {
        McPrintUsage();
        exit(1);
    }

    ConvertAppToOem( argc, argv );

    // Initialize CurrentLanguageName

    DefaultLanguageName.CodePage = GetOEMCP();
    CurrentLanguageName = &DefaultLanguageName;

    CurrentFacilityName =
    McAddName( &FacilityNames, L"Application",  0x0, NULL );
    CurrentSeverityName =
    McAddName( &SeverityNames, L"Success",       0x0, NULL );

    McAddName( &SeverityNames, L"Informational", 0x1, NULL );
    McAddName( &SeverityNames, L"Warning",       0x2, NULL );
    McAddName( &SeverityNames, L"Error",         0x3, NULL );

    McAddName( &LanguageNames,
               L"English",
               MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
               L"MSG00001"
             );

    strcpy( DebugFileName, ".\\" );
    strcpy( HeaderFileName, ".\\" );
    strcpy( HeaderFileExt, "h" );
    strcpy( RcInclFileName, ".\\" );
    strcpy( BinaryMessageFileName, ".\\" );
    MessageFileName[ 0 ] = '\0';

    McInitLexer();

    NULLTerminate = FALSE;
    VerboseOutput = FALSE;
    WarnOs2Compatible = FALSE;
    GenerateDecimalSevAndFacValues = FALSE;
    GenerateDecimalMessageValues = FALSE;
    GenerateDebugFile = FALSE;
    MaxMessageLength = 0;           // No limit
    ShowUsage = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (c = *++s) {
                switch( tolower( c ) ) {
                    case '?':
                        McPrintUsage();
                        exit( 0 );
                        break;

                    case 'a':
                        if (c == 'a') {
                            UnicodeInput = FALSE;
                        } else {
                            UnicodeOutput = FALSE;
                        }
                        break;

                    case 'b':
                        fUniqueBinName = TRUE;
                        break;

                    case 'c':
                        CustomerMsgIdBit = 0x1 << 29;
                        break;

                    case 'd':
                        GenerateDecimalSevAndFacValues = TRUE;
                        GenerateDecimalMessageValues = TRUE;
                        break;

                    case 'e':
                        if (--argc) {
                            strcpy( HeaderFileExt, *++argv );
                            i = strlen( HeaderFileExt );
                            if ((i < 1) || (i > 3) || (*HeaderFileExt == '.')) {
                                fprintf( stderr, "MC: invalid argument for -%c switch\n", (USHORT)c );
                                ShowUsage = TRUE;
                            }
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 'h':
                        if (--argc) {
                            strcpy( s1 = HeaderFileName, *++argv );
//                            s1 += strlen( s1 ) - 1;
                            s1 += strlen(s1);
                            s1 = CharPrev( HeaderFileName, s1 );

                            if (*s1 != '\\' && *s1 != '/') {
//                                *++s1 = '\\';
                                s1 = CharNext( s1 );
                                *s1 = '\\';
                                *++s1 = '\0';
                            }
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 'm':
                        if (--argc) {
                            MaxMessageLength = atoi(*++argv);
                            if (MaxMessageLength <= 0) {
                                fprintf( stderr, "MC: invalid argument (%s) for -%c switch\n", *argv, (USHORT)c );
                                ShowUsage = TRUE;
                            }
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 'n':
                        NULLTerminate = TRUE;
                        break;

                    case 'o':
                        OleOutput = TRUE;
                        break;

                    case 'r':
                        if (--argc) {
                            strcpy( s1 = RcInclFileName, *++argv );
//                            s1 += strlen( s1 ) - 1;
                            s1 += strlen( s1 );
                            s1 = CharPrev( HeaderFileName, s1 );
                            if (*s1 != '\\' && *s1 != '/') {
//                                *++s1 = '\\';
                                s1 = CharNext( s1 );
                                *s1 = '\\';
                                *++s1 = '\0';
                            }

                            strcpy( BinaryMessageFileName, RcInclFileName );
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 's':
                        InsertSymbolicName = TRUE;
                        break;

                    case 'u':
                        if (c == 'u') {
                            UnicodeInput = TRUE;
                        } else {
                            UnicodeOutput = TRUE;
                        }
                        break;

                    case 'v':
                        VerboseOutput = TRUE;
                        break;

                    case 'w':
                        WarnOs2Compatible = TRUE;
                        break;

                    case 'x':
                        if (--argc) {
                            strcpy( s1 = DebugFileName, *++argv );
//                            s1 += strlen( s1 ) - 1;
                            s1 += strlen( s1 );
                            s1 = CharPrev( HeaderFileName, s1 );
                            if (*s1 != '\\' && *s1 != '/') {
//                                *++s1 = '\\';
                                s1 = CharNext( s1 );
                                *s1 = '\\';
                                *++s1 = '\0';
                            }
                            GenerateDebugFile = TRUE;
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    default:
                        fprintf( stderr, "MC: Invalid switch: %c\n", (USHORT)c );
                        ShowUsage = TRUE;
                        break;
                }
            }
        } else if (strlen( MessageFileName )) {
            fprintf( stderr, "MC: may only specify one message file to compile.\n" );
            ShowUsage = TRUE;
        } else {
            strcpy( MessageFileName, s );
        }
    }

    if (ShowUsage) {
        McPrintUsage();
        exit( 1 );
    }

    if (fUniqueBinName) {
        _splitpath(MessageFileName, NULL, NULL, FNameMsgFileName, NULL);
        strcat(BinaryMessageFileName, FNameMsgFileName);
        strcat(BinaryMessageFileName, "_");
    }

    if (UnicodeInput) {
        if (!IsFileUnicode( MessageFileName )) {
            fprintf( stderr, "MC: -u switch cannot be used with non-Unicode message file!\n" );
            exit( 1 );
        }
    } else {
        if (IsFileUnicode( MessageFileName )) {
            fprintf( stderr, "MC: -u switch must be used with Unicode message file!\n" );
            exit( 1 );
        }
    }

    InputErrorCount = 0;
    ResultCode = 1;
    if (McParseFile() && McBlockMessages() &&
        (UnicodeOutput ? McWriteBinaryFilesW() : McWriteBinaryFilesA())) {
        if (InputErrorCount == 0) {
            ResultCode = 0;
        }
    }

    McCloseInputFile();
    McCloseOutputFiles((BOOL)(ResultCode == 0));

    return( ResultCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\mc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mc.h

Abstract:

    This is the main include file for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 21-Aug-1991

Revision History:

--*/

#include <process.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <fcntl.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <wchar.h>
#include <assert.h>
#include <locale.h>
#include <windows.h>

//
// Global constants
//

#define MCCHAR_END_OF_LINE_COMMENT    L';'

#define MCTOK_END_OF_FILE             0x0000

#define MCTOK_NUMBER                  0x0001
#define MCTOK_NAME                    0x0002
#define MCTOK_EQUAL                   0x0003
#define MCTOK_LEFT_PAREN              0x0004
#define MCTOK_RIGHT_PAREN             0x0005
#define MCTOK_COLON                   0x0006
#define MCTOK_PLUS                    0x0007
#define MCTOK_END_OF_LINE_COMMENT     0x0008

#define MCTOK_MSGIDTYPE_KEYWORD       0x0011
#define MCTOK_SEVNAMES_KEYWORD        0x0012
#define MCTOK_FACILITYNAMES_KEYWORD   0x0013
#define MCTOK_LANGNAMES_KEYWORD       0x0014
#define MCTOK_MESSAGEID_KEYWORD       0x0015
#define MCTOK_SEVERITY_KEYWORD        0x0016
#define MCTOK_FACILITY_KEYWORD        0x0017
#define MCTOK_SYMBOLNAME_KEYWORD      0x0018
#define MCTOK_LANGUAGE_KEYWORD        0x0019
#define MCTOK_OUTBASE_KEYWORD         0x001A
#define MCTOK_MSGTYPEDEF_KEYWORD      0x001B


//
// Global data types
//

typedef struct _LANGUAGE_INFO {
    struct _LANGUAGE_INFO *Next;
    ULONG Id;
    ULONG Length;
    WCHAR *Text;
} LANGUAGE_INFO, *PLANGUAGE_INFO;

typedef struct _MESSAGE_INFO {
    struct _MESSAGE_INFO *Next;
    ULONG Id;
    ULONG Method;
    WCHAR *SymbolicName;
    WCHAR *EndOfLineComment;
    PLANGUAGE_INFO MessageText;
} MESSAGE_INFO, *PMESSAGE_INFO;

#define MSG_PLUS_ONE 0
#define MSG_PLUS_VALUE 1
#define MSG_ABSOLUTE 2

typedef struct _MESSAGE_BLOCK {
    struct _MESSAGE_BLOCK *Next;
    ULONG LowId;
    ULONG HighId;
    ULONG InfoLength;
    PMESSAGE_INFO LowInfo;
} MESSAGE_BLOCK, *PMESSAGE_BLOCK;

typedef struct _NAME_INFO {
    struct _NAME_INFO *Next;
    ULONG LastId;
    ULONG Id;
    PVOID Value;
    BOOL Used;
    UINT  CodePage;
    WCHAR Name[ 1 ];
} NAME_INFO, *PNAME_INFO;


//
// Global variables
//

int VerboseOutput;
int WarnOs2Compatible;
int InsertSymbolicName;
int MaxMessageLength;
int GenerateDecimalSevAndFacValues;
int GenerateDecimalMessageValues;
int ResultCode;
ULONG InputErrorCount;
int NULLTerminate;
int OleOutput;
int UnicodeInput;
int UnicodeOutput;
ULONG CustomerMsgIdBit;

FILE *MessageFile;
char MessageFileName[ MAX_PATH ];
char *MessageFileNameNoExt;
unsigned int MessageFileLineNumber;
unsigned int Token;
WCHAR TokenCharValue[ 256 ];
ULONG TokenNumericValue;
PNAME_INFO TokenKeyword;

FILE *HeaderFile;
char HeaderFileName[ MAX_PATH ];
char HeaderFileExt[ MAX_PATH ];
FILE *RcInclFile;
char RcInclFileName[ MAX_PATH ];
FILE *BinaryMessageFile;
char BinaryMessageFileName[ MAX_PATH ];
int GenerateDebugFile;
FILE *DebugFile;
char DebugFileName[ MAX_PATH ];

WCHAR *MessageIdTypeName;
WCHAR *MessageIdTypeMacro;

PNAME_INFO FacilityNames;
PNAME_INFO CurrentFacilityName;
PNAME_INFO SeverityNames;
PNAME_INFO CurrentSeverityName;
PNAME_INFO LanguageNames;
PNAME_INFO CurrentLanguageName;
CPINFO CPInfo;

PMESSAGE_INFO Messages;
PMESSAGE_INFO CurrentMessage;

BOOL fUniqueBinName;
CHAR FNameMsgFileName[_MAX_FNAME];

//
// c-runtime macros
//

#define iswcsymf(_c)   (iswalpha(_c) || ((_c) == L'_'))
#define iswcsym(_c)    (iswalnum(_c) || ((_c) == L'_'))


//
// Functions defined in mc.c
//

void
McPrintUsage( void );


//
// Functions defined in mcparse.c
//

BOOL
McParseFile( void );

BOOL
McParseMessageDefinition( void );

BOOL
McParseMessageText(
    PMESSAGE_INFO MessageInfo
    );

BOOL
McParseNameList(
    PNAME_INFO *NameListHead,
    BOOL ValueRequired,
    ULONG MaximumValue
    );

BOOL
McParseName(
    PNAME_INFO NameListHead,
    PNAME_INFO *Result
    );


//
// Functions defined in mcout.c
//

BOOL
McBlockMessages( void );


BOOL
McWriteBinaryFilesA( void );


BOOL
McWriteBinaryFilesW( void );

VOID
McClearArchiveBit( LPSTR Name );


//
// Functions defined in mclex.c
//

BOOL
McInitLexer( void );

BOOL
McOpenInputFile( void );

void
McFlushComments( void );

void
McCloseInputFile( void );

void
McCloseOutputFiles( BOOL );

void
McInputErrorA(
    char *Message,
    BOOL Error,
    PVOID Argument
    );

void
McInputErrorW(
    WCHAR *Message,
    BOOL Error,
    PVOID Argument
    );

WCHAR *
McGetLine( void );

void
McSkipLine( void );

WCHAR
McGetChar(
    BOOL SkipWhiteSpace
    );

void
McUnGetChar(
    WCHAR c
    );

unsigned int
McGetToken(
    BOOL KeywordExpected
    );

void
McUnGetToken( void );

WCHAR *
McSkipWhiteSpace(
    WCHAR *s
    );

//
// Functions defined in mcutil.c
//

PNAME_INFO
McAddName(
    PNAME_INFO *NameListHead,
    WCHAR *Name,
    ULONG Id,
    PVOID Value
    );


PNAME_INFO
McFindName(
    PNAME_INFO NameListHead,
    WCHAR *Name
    );


BOOL
McCharToInteger(
    WCHAR * String,
    int Base,
    PULONG Value
    );

WCHAR *
McMakeString(
    WCHAR *String
    );

BOOL
IsFileUnicode(
    char * fName
    );

WCHAR *
fgetsW(
    WCHAR * string,
    long count,
    FILE * fp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\mcout.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mcout.c

Abstract:

    This file contains the output functions of the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 22-Aug-1991

Revision History:

--*/

#include "mc.h"

PMESSAGE_BLOCK MessageBlocks = NULL;
int NumberOfBlocks = 0;

BOOL
McBlockMessages( void )
{
    PMESSAGE_BLOCK p, *pp;
    PMESSAGE_INFO MessageInfo;

    pp = &MessageBlocks;
    p = NULL;

    MessageInfo = Messages;
    while (MessageInfo) {
        if (p) {
            if (p->HighId+1 == MessageInfo->Id) {
                p->HighId += 1;
                }
            else {
                pp = &p->Next;
                }
            }

        if (!*pp) {
            NumberOfBlocks += 1;
            p = malloc( sizeof( *p ) );
            if (!p) {
                McInputErrorA( "Out of memory reading messages", TRUE, NULL );
                return FALSE;
                }

            p->Next = NULL;
            p->LowId = MessageInfo->Id;
            p->HighId = MessageInfo->Id;
            p->LowInfo = MessageInfo;
            *pp = p;
            }

        MessageInfo = MessageInfo->Next;
        }

    return( TRUE );
}


BOOL
McWriteBinaryFilesA( void )
{
    PNAME_INFO LanguageName, *pp;
    PLANGUAGE_INFO LanguageInfo;
    PMESSAGE_INFO MessageInfo;
    PMESSAGE_BLOCK BlockInfo;
    char *FileName;
    ULONG cb, cbNeeded;
    ULONG MessageOffset;
    MESSAGE_RESOURCE_ENTRY MessageEntry;
    MESSAGE_RESOURCE_BLOCK MessageBlock;
    MESSAGE_RESOURCE_DATA  MessageData;
    ULONG Zeroes = 0;
    ULONG NumberOfMessages;
    LPBYTE lpBuf;
    ULONG Size = 256;


    FileName = BinaryMessageFileName;
    FileName += strlen( FileName );

    lpBuf = malloc( Size );
    if (!lpBuf) {
        McInputErrorA( "Out of memory writing to output file - %s", TRUE, BinaryMessageFileName );
        return( FALSE );
    }

    pp = &LanguageNames;
    while (LanguageName = *pp) {
        pp = &LanguageName->Next;
        if (!LanguageName->Used) {
            continue;
            }

        WideCharToMultiByte( CP_OEMCP, 0, LanguageName->Value, -1, FileName,
                sizeof( BinaryMessageFileName ) - strlen( FileName ), NULL, NULL );
        strcat( FileName, ".bin" );
        if (!(BinaryMessageFile = fopen( BinaryMessageFileName, "wb" ))) {
            McInputErrorA( "unable to open output file - %s", TRUE, BinaryMessageFileName );
            return( FALSE );
            }

        if (VerboseOutput) {
            fprintf( stderr, "Writing %s\n", BinaryMessageFileName );
            }

        fprintf( RcInclFile, "LANGUAGE 0x%x,0x%x\r\n",
                             PRIMARYLANGID( LanguageName->Id ),
                             SUBLANGID( LanguageName->Id )
               );

        if (fUniqueBinName) {
            fprintf(RcInclFile, "1 11 %s_%s\r\n", FNameMsgFileName, FileName);
        } else {
            fprintf( RcInclFile, "1 11 %s\r\n", FileName );
        }

        NumberOfMessages = 0L;

        MessageData.NumberOfBlocks = NumberOfBlocks;
        MessageOffset = fwrite( &MessageData,
                                1,
                                (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_DATA,
                                                      Blocks[ 0 ]
                                                    ),
                                BinaryMessageFile
                              );
        MessageOffset += NumberOfBlocks * sizeof( MessageBlock );

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageBlock.LowId = BlockInfo->LowId;
            MessageBlock.HighId = BlockInfo->HighId;
            MessageBlock.OffsetToEntries = MessageOffset;
            fwrite( &MessageBlock, 1, sizeof( MessageBlock ), BinaryMessageFile );

            BlockInfo->InfoLength = 0;
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         WideCharToMultiByte( LanguageName->CodePage,
                                              0,
                                              LanguageInfo->Text,
                                              LanguageInfo->Length,
                                              NULL, 0, NULL, NULL ) + 1;

                    cb = (cb + 3) & ~3;
                    BlockInfo->InfoLength += cb;
                    }
                else {
                    fprintf( stderr,
                             "MC: No %ws language text for %ws\n",
                             LanguageName->Name,
                             MessageInfo->SymbolicName
                           );
                    fclose( BinaryMessageFile );
                    return( FALSE );
                    }

                MessageInfo = MessageInfo->Next;
                }

            if (VerboseOutput) {
                fprintf( stderr, "    [%08lx .. %08lx] - %lu bytes\n",
                         BlockInfo->LowId,
                         BlockInfo->HighId,
                         BlockInfo->InfoLength
                       );
                }

            MessageOffset += BlockInfo->InfoLength;
            BlockInfo = BlockInfo->Next;
            }

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cbNeeded = WideCharToMultiByte( LanguageName->CodePage,
                                                    0,
                                                    LanguageInfo->Text,
                                                    LanguageInfo->Length,
                                                    NULL, 0, NULL, NULL );

                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         cbNeeded + 1;

                    cb = (cb + 3) & ~3;

                    MessageEntry.Length = (USHORT)cb;
                    MessageEntry.Flags = 0;

                    cb = fwrite( &MessageEntry,
                                 1,
                                 (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY,
                                                       Text[ 0 ]
                                                     ),
                                 BinaryMessageFile
                               );

                    if (Size < cbNeeded ) {
                        lpBuf = realloc( lpBuf, cbNeeded );
                        if (!lpBuf) {
                            McInputErrorA( "Out of memory writing to output file - %s",
                                           TRUE, BinaryMessageFileName );
                            return( FALSE );
                        }
                        Size = cbNeeded;
                    }
                    WideCharToMultiByte( LanguageName->CodePage,
                                         0,
                                         LanguageInfo->Text,
                                         LanguageInfo->Length,
                                         lpBuf, cbNeeded, NULL, NULL );

                    cb += fwrite( lpBuf,
                                  1,
                                  (size_t)cbNeeded,
                                  BinaryMessageFile
                                );

                    NumberOfMessages++;

                    cb = MessageEntry.Length - cb;
                    if (cb) {
                        fwrite( &Zeroes,
                                1,
                                (size_t)cb,
                                BinaryMessageFile
                              );
                        }
                    }

                MessageInfo = MessageInfo->Next;
                }

            BlockInfo = BlockInfo->Next;
            }

        if (VerboseOutput) {
            fprintf( stderr, "    Total of %lu messages, %lu bytes\n",
                             NumberOfMessages,
                             ftell( BinaryMessageFile )
                   );
            }

        fclose( BinaryMessageFile );
        McClearArchiveBit( BinaryMessageFileName );
        }

    free( lpBuf );
    return( TRUE );
}


BOOL
McWriteBinaryFilesW( void )
{
    PNAME_INFO LanguageName, *pp;
    PLANGUAGE_INFO LanguageInfo;
    PMESSAGE_INFO MessageInfo;
    PMESSAGE_BLOCK BlockInfo;
    char *FileName;
    ULONG cb;
    ULONG MessageOffset;
    MESSAGE_RESOURCE_ENTRY MessageEntry;
    MESSAGE_RESOURCE_BLOCK MessageBlock;
    MESSAGE_RESOURCE_DATA  MessageData;
    ULONG Zeroes = 0;
    ULONG NumberOfMessages;

    FileName = BinaryMessageFileName;
    FileName += strlen( FileName );

    pp = &LanguageNames;
    while (LanguageName = *pp) {
        pp = &LanguageName->Next;
        if (!LanguageName->Used) {
            continue;
            }

        WideCharToMultiByte( CP_OEMCP, 0, LanguageName->Value, -1,
                             FileName, sizeof( BinaryMessageFileName ), NULL, NULL);
        strcat( FileName, ".bin" );
        if (!(BinaryMessageFile = fopen( BinaryMessageFileName, "wb" ))) {
            McInputErrorA( "unable to open output file - %s", TRUE, BinaryMessageFileName );
            return( FALSE );
            }

        if (VerboseOutput) {
            fprintf( stderr, "Writing %s\n", BinaryMessageFileName );
            }

        fprintf( RcInclFile, "LANGUAGE 0x%x,0x%x\r\n",
                             PRIMARYLANGID( LanguageName->Id ),
                             SUBLANGID( LanguageName->Id )
               );

        if (fUniqueBinName) {
            fprintf(RcInclFile, "1 11 %s_%s\r\n", FNameMsgFileName, FileName);
        } else {
            fprintf( RcInclFile, "1 11 %s\r\n", FileName );
        }

        NumberOfMessages = 0L;

        MessageData.NumberOfBlocks = NumberOfBlocks;
        MessageOffset = fwrite( &MessageData,
                                1,
                                (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_DATA,
                                                      Blocks[ 0 ]
                                                    ),
                                BinaryMessageFile
                              );
        MessageOffset += NumberOfBlocks * sizeof( MessageBlock );

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageBlock.LowId = BlockInfo->LowId;
            MessageBlock.HighId = BlockInfo->HighId;
            MessageBlock.OffsetToEntries = MessageOffset;
            fwrite( &MessageBlock, 1, sizeof( MessageBlock ), BinaryMessageFile );

            BlockInfo->InfoLength = 0;
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         ( LanguageInfo->Length + 1 );

                    cb = (cb + 3) & ~3;
                    BlockInfo->InfoLength += cb;
                    }
                else {
                    fprintf( stderr,
                             "MC: No %ws language text for %ws\n",
                             LanguageName->Name,
                             MessageInfo->SymbolicName
                           );
                    fclose( BinaryMessageFile );
                    _unlink( BinaryMessageFileName );
                    return( FALSE );
                    }

                MessageInfo = MessageInfo->Next;
                }

            if (VerboseOutput) {
                fprintf( stderr, "    [%08lx .. %08lx] - %lu bytes\n",
                         BlockInfo->LowId,
                         BlockInfo->HighId,
                         BlockInfo->InfoLength
                       );
                }

            MessageOffset += BlockInfo->InfoLength;
            BlockInfo = BlockInfo->Next;
            }

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         ( LanguageInfo->Length + 1 ) ;

                    cb = (cb + 3) & ~3;

                    MessageEntry.Length = (USHORT)cb;
                    MessageEntry.Flags = MESSAGE_RESOURCE_UNICODE;

                    cb = fwrite( &MessageEntry,
                                 1,
                                 (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY,
                                                       Text[ 0 ]
                                                     ),
                                 BinaryMessageFile
                               );
                    cb += fwrite( LanguageInfo->Text,
                                  1,
                                  (size_t)( LanguageInfo->Length ),
                                  BinaryMessageFile
                                );

                    NumberOfMessages++;

                    cb = MessageEntry.Length - cb;
                    if (cb) {
                        fwrite( &Zeroes,
                                1,
                                (size_t)cb,
                                BinaryMessageFile
                              );
                        }
                    }

                MessageInfo = MessageInfo->Next;
                }

            BlockInfo = BlockInfo->Next;
            }

        if (VerboseOutput) {
            fprintf( stderr, "    Total of %lu messages, %lu bytes\n",
                             NumberOfMessages,
                             ftell( BinaryMessageFile )
                   );
            }

        fclose( BinaryMessageFile );
        McClearArchiveBit( BinaryMessageFileName );
        }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\mcutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mcutil.c

Abstract:

    This file contains utility functions for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 22-Aug-1991

Revision History:

--*/

#include "mc.h"

typedef BOOL (*PISTEXTUNICODE_ROUTINE)(
    CONST LPVOID lpBuffer,
    size_t cb,
    LPINT lpi
    );

PISTEXTUNICODE_ROUTINE OptionalIsTextUnicode = NULL;

BOOL
DefaultIsTextUnicode(
    CONST LPVOID lpBuffer,
    size_t cb,
    LPINT lpi
    )
{
    return FALSE;
}

PNAME_INFO
McAddName(
    PNAME_INFO *NameListHead,
    WCHAR *Name,
    ULONG Id,
    PVOID Value
    )
{
    PNAME_INFO p;
    int n;

    while (p = *NameListHead) {
        if (!(n = _wcsicmp( p->Name, Name ))) {
            if (p->Id != Id) {
                McInputErrorW( L"Redefining value of %s", FALSE, Name );
            }

            p->Id = Id;
            p->Value = Value;
            p->Used = FALSE;
            return( p );
        } else if (n < 0) {
            break;
        }

        NameListHead = &p->Next;
    }

    p = malloc( sizeof( *p ) + ( wcslen( Name ) + 1 ) * sizeof( WCHAR ) );
    if (!p) {
        McInputErrorA( "Out of memory capturing name.", TRUE, NULL );
        return( NULL );
    }
    p->LastId = 0;
    p->Id = Id;
    p->Value = Value;
    p->Used = FALSE;
    p->CodePage = GetOEMCP();
    wcscpy( p->Name, Name );
    p->Next = *NameListHead;
    *NameListHead = p;
    return( p );
}


PNAME_INFO
McFindName(
    PNAME_INFO NameListHead,
    WCHAR *Name
    )
{
    PNAME_INFO p;

    p = NameListHead;
    while (p) {
        if (!_wcsicmp( p->Name, Name )) {
            p->Used = TRUE;
            break;
        }

        p = p->Next;
    }

    return( p );
}


BOOL
McCharToInteger(
    WCHAR *String,
    int Base,
    PULONG Value
    )
{
    WCHAR c;
    ULONG Result, Digit, Shift;

    c = *String++;
    if (!Base) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            c = *String++;
            if (c == L'x') {
                Base = 16;
                Shift = 4;
            } else if (c == L'o') {
                Base = 8;
                Shift = 3;
            } else if (c == L'b') {
                Base = 2;
                Shift = 1;
            } else {
                String--;
            }

            c = *String++;
        }
    } else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( FALSE );
        }
    }

    Result = 0;
    while (c) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
        }
        else if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
        }
        else if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
        } else {
            break;
        }

        if ((int)Digit >= Base) {
            break;
        }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
        } else {
            Result = (Result << Shift) | Digit;
        }

        c = *String++;
    }

    *Value = Result;
    return( TRUE );
}


WCHAR *
McMakeString(
    WCHAR *String
    )
{
    WCHAR *s;

    s = malloc( ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
    if (!s) {
        McInputErrorA( "Out of memory copying string.", TRUE, String );
        return NULL;
    }
    wcscpy( s, String );
    return( s );
}


BOOL
IsFileUnicode (char * fName)
{
#define CCH_READ_MAX  200
    size_t   cbRead;
    INT      value = 0xFFFFFFFF;
    FILE    *fp;
    LPVOID   lpBuf;
    BOOL     result;

    if (OptionalIsTextUnicode == NULL) {
        OptionalIsTextUnicode = (PISTEXTUNICODE_ROUTINE)GetProcAddress( LoadLibrary( "ADVAPI32.DLL" ), "IsTextUnicode" );
        if (OptionalIsTextUnicode == NULL) {
            OptionalIsTextUnicode = DefaultIsTextUnicode;
        }
    }

    if ( ( fp = fopen( fName, "rb" ) ) == NULL )
        return (FALSE);

    lpBuf = malloc( CCH_READ_MAX + 10 );
    if (!lpBuf) {
        fclose( fp );
        return( FALSE );
    }

    cbRead = fread( lpBuf, 1, CCH_READ_MAX, fp );
    result = (*OptionalIsTextUnicode)( lpBuf, cbRead, &value );

    fclose( fp );
    free( lpBuf );

    return( result );
}

BOOL
MyIsDBCSLeadByte(UCHAR c)
{
    int i;
    CPINFO* PCPInfo = &CPInfo;

    if (PCPInfo == NULL) {
        return FALSE;
    }

    if (!PCPInfo->MaxCharSize) {
        return(IsDBCSLeadByte(c));
    }

    if (PCPInfo->MaxCharSize == 1) {
        return FALSE;
    }

    for (i=0 ; i<MAX_LEADBYTES ; i+=2) {
        if (PCPInfo->LeadByte[i] == 0 && PCPInfo->LeadByte[i+1] == 0)
            return FALSE;
        if (c >= PCPInfo->LeadByte[i] && c <= PCPInfo->LeadByte[i+1])
            return TRUE;
    }
    return FALSE;
}

WCHAR *
fgetsW (WCHAR * string, long count, FILE * fp)
{
    UCHAR ch[2];
    WCHAR *pch = string;
    DWORD nBytesRead;

    assert (string != NULL);
    assert (fp != NULL);

    if (count <= 0)
        return (NULL);

    while (--count) {
        if (UnicodeInput) {
            nBytesRead = fread (ch, 1, sizeof(WCHAR), fp);
        } else {
            nBytesRead = fread (ch, 1, 1, fp);
            ch[1] = '\0';
        }

        //
        //  if there are no more characters, end the line
        //

        if (feof (fp)) {
            if (pch == string)
                return (NULL);
            break;
        }

        if (ch[0] < 128 || UnicodeInput) {
            *pch = *(WCHAR*)&ch[0];
        } else if (MyIsDBCSLeadByte(ch[0])) {
            nBytesRead = fread (&ch[1], 1, 1, fp);
            MultiByteToWideChar(CurrentLanguageName->CodePage, 0, ch, 2, pch, 1);
        } else {
            MultiByteToWideChar(CurrentLanguageName->CodePage, 0, ch, 1, pch, 1);
        }

        pch++;
        if (*(pch-1) == L'\n') {
            break;
        }
    }

    *pch = L'\0';

    return (string);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\makefile.inc ===
$(O)\memsnap.res: memsnap.rc

$(O)\sortlog.res: sortlog.rc

$(O)\poolsnap.res: poolsnap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memavail\makefile.inc ===
$(O)\memavail.res: memavail.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\memfiltres.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    memfiltres.h

Abstract:

    This module defines resource identifiers for MEMFILT.

Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba
    
        Modified module to conform to coding standards.

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mc\version.h ===
#define rmj		1
#define rmm		0
#define rup		5239
#define szVerName	"Message Compiler"
#define szVerUser	"NTDEV-SD1"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\memfilt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    memfilt.cpp

Abstract:

    This module filters out the useful information from a sorted memsnap output file.
    
Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba

        Modified module to conform to coding standards.

--*/


#include <nt.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define MF_NEW_PROCESS 0
#define MF_UPDATE 1

// globals

LONG MinimumCommitChangeToReport = 1;
LONG MinimumHandleChangeToReport = 1;
BOOLEAN ReportIncreasesOnly = TRUE;


VOID
PrintUsage(
    )

/*++

Routine Description:

    This routine prints an informational message about the proper usage of MEMFILT.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    
    _ftprintf(stderr, _T("Summarizes possible leaks in a sorted MEMSNAP output file.\n\n"));
    _ftprintf(stderr, _T("MEMFILT file [/MINCOMMIT:n] [/MINHANDLES:n] [/ALL]\n\n"));
    _ftprintf(stderr, _T("file            A sorted memsnap output file.\n"));
    _ftprintf(stderr, _T("/MINCOMMIT:n    Reports only processes where commit charge increased by\n"));
    _ftprintf(stderr, _T("                   at least n.\n"));
    _ftprintf(stderr, _T("/MINHANDLES:n   Reports only processes where handle count increased by\n"));
    _ftprintf(stderr, _T("                   at least n.\n"));
    _ftprintf(stderr, _T("/ALL            Reports decreases as well as increases.\n"));
    
}

VOID
PrintProcessInformation(
    IN BOOLEAN CommitAlwaysGrows,
    IN BOOLEAN HandlesAlwaysGrow,
    IN LPTSTR ProcessName, 
    IN LONG InitialCommit,
    IN LONG FinalCommit,
    IN LONG InitialHandles,
    IN LONG FinalHandles
    )

/*++

Routine Description:

    This routine reports the memory usage of a single process.
    
Arguments:

    CommitAlwaysGrows - TRUE if commit monotonically increases.
    
    HandlesAlwaysGrow - TRUE if handles monotonically increase.
    
    ProcessName - the name of the process being reported.
    
    InitialCommit - initial commit charge for this process.
    
    FinalCommit - final commit charge for this process.
    
    InitialHandles - initial handle count for this process.
    
    FinalHandles - final handle count for this process.

Return value:

    None.

--*/

{
    _TCHAR CommitString[64];
    _TCHAR HandlesString[64];
    
    if(((!ReportIncreasesOnly) && 
        (abs(FinalCommit - InitialCommit) >= 
        MinimumCommitChangeToReport)) ||
        (FinalCommit - InitialCommit >= 
        MinimumCommitChangeToReport)) {
        
        _stprintf(CommitString, _T("%10d->%10d"), InitialCommit, FinalCommit);
            
    } else {
        
        _tcscpy(CommitString, _T("                      "));
        
    }
    
    if(((!ReportIncreasesOnly) &&
        (abs(FinalHandles - InitialHandles) >=
        MinimumHandleChangeToReport)) ||
        (FinalHandles - InitialHandles >=
        MinimumHandleChangeToReport)) {
            
        _stprintf(HandlesString, _T("%10d->%10d"), InitialHandles, FinalHandles);
        
    } else {
        
        _tcscpy(HandlesString, _T("                      "));
        
    }
    
    _tprintf(_T("%c%c %s %s %s\n"), 
        (CommitAlwaysGrows && (FinalCommit != InitialCommit) ? _T('!') : _T(' ')),
        (HandlesAlwaysGrow && (FinalHandles != InitialHandles) ? _T('!') : _T(' ')),
        ProcessName, CommitString, HandlesString);
}

LONG _cdecl 
_tmain(
    IN LONG argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This routine parses program arguments, reads the input file, and outputs the result.
    
Arguments:

    argc - Number of command line arguments.
    
    argv - Command line arguments.

Return value:

    0 if filtering is successful, 1 otherwise.

--*/

{
    
    try {

        FILE *InputFile = NULL;
        _TCHAR LineBuffer[256];
        _TCHAR ProcessName[64];
        LONG CurrentState = MF_NEW_PROCESS;
        LONG InitialCommit = 0;
        LONG FinalCommit = 0;
        LONG NewCommit = 0;
        LONG InitialHandles = 0;
        LONG FinalHandles = 0;
        LONG NewHandles = 0;
        LONG MonotonicallyIncreasing = 0;
        BOOLEAN CommitAlwaysGrows = TRUE;
        BOOLEAN HandlesAlwaysGrow = TRUE;
        BOOLEAN InterpretedArgument = FALSE;
        LONG Processes = 0;
        LPTSTR InputFileName = NULL;

        // make sure ProcessName is properly terminated

        ProcessName[30]=_T('\0');

        // parse command line arguments

        if(argc < 2) {

            PrintUsage();
            return 1;

        }

        for(LONG n=1; n<argc; n++) {

            InterpretedArgument = FALSE;

            switch(argv[n][0]) {

            case _T('-'):

            case _T('/'):

                // it's a switch

                if(!_tcsicmp(argv[n]+1, _T("all"))) {

                    ReportIncreasesOnly = FALSE;
                    InterpretedArgument = TRUE;

                }

                if(!_tcsnicmp(argv[n]+1, _T("mincommit:"), 10)) {

                    MinimumCommitChangeToReport = _ttoi(argv[n]+10);
                    InterpretedArgument = TRUE;

                }

                if(!_tcsnicmp(argv[n]+1, _T("minhandles:"), 11)) {

                    MinimumHandleChangeToReport = _ttoi(argv[n]+11);
                    InterpretedArgument = TRUE;

                }

                break;

            default:

                if(InputFileName != NULL) {

                    // too many filenames

                    PrintUsage();
                    return 1;

                }

                InputFileName = argv[n];
                InterpretedArgument = TRUE;
                break;

            }

            if(!InterpretedArgument) {

                PrintUsage();
                return 1;

            }

        }

        if(InputFileName == NULL) {

            // filename not specified
            PrintUsage();
            return 1;

        }

        InputFile = _tfopen(InputFileName, _T("rt"));

        if(InputFile == NULL) {

            _ftprintf(stderr, _T("Cannot open input file.\n"));
            return 1;

        }

        // skip header

        if (!_fgetts(LineBuffer, 256, InputFile)) {
            _ftprintf(stderr, _T("Cannot read input file.\n"));
            return 1;
        }

        if (!_fgetts(LineBuffer, 256, InputFile)) {
            _ftprintf(stderr, _T("Cannot read input file.\n"));
            return 1;
        }

        while(!feof(InputFile)) {

            if(!_tcscmp(LineBuffer,_T("\n"))) {

                // blank line indicates a new process

                CurrentState = MF_NEW_PROCESS;

                // does the most recent process meet the criteria to be reported?
                if(ReportIncreasesOnly) {

                    if(((FinalCommit - InitialCommit) >= MinimumCommitChangeToReport) || 
                        ((FinalHandles - InitialHandles) >= MinimumHandleChangeToReport)) {

                        PrintProcessInformation(CommitAlwaysGrows, HandlesAlwaysGrow,
                            ProcessName, InitialCommit, FinalCommit, InitialHandles,
                            FinalHandles);

                    }

                } else {

                   if((abs(FinalCommit - InitialCommit) >= MinimumCommitChangeToReport) || 
                        (abs(FinalHandles - InitialHandles) >= MinimumHandleChangeToReport)) {

                        PrintProcessInformation(CommitAlwaysGrows, HandlesAlwaysGrow,
                            ProcessName, InitialCommit, FinalCommit, InitialHandles,
                            FinalHandles);

                    }                

                }

            } else {

                if(_tcslen(LineBuffer) <= 80) {

                    _ftprintf(stderr, _T("Format violated.\n"));
                    return 1;

                }

                switch(CurrentState) {

                case MF_NEW_PROCESS:

                    _tcsncpy(ProcessName, LineBuffer, 30);
                    if (_stscanf(LineBuffer+70, _T("%d"), &InitialCommit) != 1) break;
                    if (_stscanf(LineBuffer+80, _T("%d"), &InitialHandles) != 1) break;

                    FinalCommit = 0;
                    FinalHandles = 0;

                    CommitAlwaysGrows = TRUE;
                    HandlesAlwaysGrow = TRUE;
                    CurrentState = MF_UPDATE;

                    break;

                case MF_UPDATE:

                    if (_stscanf(LineBuffer+70, _T("%d"), &NewCommit) != 1) break;
                    if (_stscanf(LineBuffer+80, _T("%d"), &NewHandles) != 1) break;

                    if(NewCommit < FinalCommit) {

                        CommitAlwaysGrows = FALSE;

                    }

                    if(NewHandles < FinalHandles) {

                        HandlesAlwaysGrow = FALSE;

                    }

                    FinalCommit = NewCommit;
                    FinalHandles = NewHandles;

                    break;

                }

            }

            if (!_fgetts(LineBuffer, 256, InputFile)) {
                _ftprintf(stderr, _T("Cannot read input file.\n"));
                return 1;
            }

        }

        fclose(InputFile);
        return 0;
        
    } catch (...) { 
        
        // this is mostly intended to catch out-of-memory errors
        
        _tprintf(_T("\nAn exception was detected.  MEMFILT aborted.\n"));
        return 1;
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memavail\memavail.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    memavail.c

Abstract:

    Program to display the size of physical RAM, and paging file space.

Author:

    03-Dec-1996 Steve Wood (stevewo)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    MEMORYSTATUS MemoryStatus;

    GlobalMemoryStatus( &MemoryStatus );

    MemoryStatus.dwTotalPhys /= 1024 * 1024;
    MemoryStatus.dwAvailPhys /= 1024 * 1024;
    MemoryStatus.dwTotalPageFile /= 1024 * 1024;
    MemoryStatus.dwAvailPageFile /= 1024 * 1024;
    MemoryStatus.dwTotalVirtual /= 1024 * 1024;
    MemoryStatus.dwAvailVirtual /= 1024 * 1024;
    printf( "Memory Availability (Numbers in MegaBytes)\n" );
    printf( "\n" );
    printf( "          Total Available\n" );
    printf( "\n" );

    printf( "Physical: %5u %5u\n", MemoryStatus.dwTotalPhys, MemoryStatus.dwAvailPhys );
    printf( "PageFile: %5u %5u\n", MemoryStatus.dwTotalPageFile, MemoryStatus.dwAvailPageFile );
    printf( "Virtual:  %5u %5u\n", MemoryStatus.dwTotalVirtual, MemoryStatus.dwAvailVirtual );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\memsnap.c ===
// memsnap.c 
//
// this simple program takes a snapshot of all the process
// and their memory usage and append it to the logfile (arg)
// pmon was model for this
//

// includes

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <srvfsctl.h>

// declarations

#define INIT_BUFFER_SIZE 4*1024

#include "tags.c"


VOID Usage(VOID)
{
    printf( "memsnap [-t] [-g] [-?] [<logfile>]\n" );
    printf( "memsnap logs system memory usage to <logfile>\n" );
    printf( "<logfile> = memsnap.log by default\n" );
    printf( "-t   Add tagging information (time (GMT), date, machinename)\n" );
    printf( "-g   Add GDI and USER resource counts\n");
    printf( "-?   Gets this message\n" );
    exit(-1);
}


void _cdecl main(int argc, char* argv[])
{
    FILE* LogFile;                      // log file handle
    BOOL  bTags= FALSE;                 // true if we are to output tags
    BOOL  bGuiCount= FALSE;             // true if we are to output GUI counters
    PCHAR pszFileName;                  // name of file to log to
    INT   iArg;
    ULONG Offset1;
    PUCHAR CurrentBuffer=NULL;
    ULONG CurrentSize;
    NTSTATUS Status=STATUS_SUCCESS;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    
    
    //
    // Get higher priority in case this is a bogged down machine 
    //

    if ( GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }



    //
    // Scan off the command line options
    //

    pszFileName= &"memsnap.log";      // this is the default log file if none is given

    for( iArg=1; iArg < argc; iArg++ ) {
        if( (*argv[iArg] == '-' ) || (*argv[iArg] == '/') ) {
           switch( *(argv[iArg]+1) ) {

              //
              // -t  --  Add tags
              //

              case 't':
              case 'T':
                  bTags= TRUE;
                  break;

              //
              // -g  -- Add GUI counters like User and Gdi handles
              //

              case 'g':
              case 'G':
                  bGuiCount= TRUE;
                  break;
          
              default:
                 printf("invalid switch: %s\n",argv[iArg]);
                 Usage();
           }
        }
        else {  // must be the log filename
            pszFileName= argv[iArg];
        }
    }


    //
    // Open the output file
    //

    LogFile= fopen( pszFileName, "a" );

    if( LogFile == NULL ) {
        printf("Error opening file %s\n",pszFileName);
        exit(-1);
    }
    

    //
    // print file header once 
    //

    if (_filelength(_fileno(LogFile)) == 0 ) {
        fprintf(LogFile,"Process ID         Proc.Name Wrkng.Set PagedPool  NonPgdPl  Pagefile    Commit   Handles   Threads" );

        if( bGuiCount ) {
            fprintf( LogFile, "      User       Gdi");
        }
    }
    
    fprintf( LogFile, "\n" );

    if( bTags ) {
        OutputStdTags(LogFile,"memsnap");
    }
    
    //
    // grab all process information 
    // log line format:
    // pid,name,WorkingSetSize,QuotaPagedPoolUsage,QuotaNonPagedPoolUsage,PagefileUsage,CommitCharge,User,Gdi
    //
    

    //
    // Keep trying larger buffers until we get all the information
    //

    CurrentSize=INIT_BUFFER_SIZE;
    for(;;) {
        CurrentBuffer= LocalAlloc( LPTR, CurrentSize );
        if( NULL == CurrentBuffer ) {
            printf("Out of memory\n");
            exit(-1);
        }

        Status= NtQuerySystemInformation(
                   SystemProcessInformation,
                   CurrentBuffer,
                   CurrentSize,
                   NULL
                   );

        if( Status != STATUS_INFO_LENGTH_MISMATCH ) break;

        LocalFree( CurrentBuffer );
      
        CurrentSize= CurrentSize * 2;
    };

    
    if( Status == STATUS_SUCCESS ) {
        Offset1= 0;
        do {
    
            //
            // get process info from buffer 
            //

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];
            Offset1 += ProcessInfo->NextEntryOffset;
    
            //
            // print in file
            //

            fprintf(LogFile,
                "%8p%20ws%10u%10u%10u%10u%10u%10u%10u",
                ProcessInfo->UniqueProcessId,
                ProcessInfo->ImageName.Buffer,
                ProcessInfo->WorkingSetSize,
                ProcessInfo->QuotaPagedPoolUsage,
                ProcessInfo->QuotaNonPagedPoolUsage,
                ProcessInfo->PagefileUsage,
                ProcessInfo->PrivatePageCount,
                ProcessInfo->HandleCount,
                ProcessInfo->NumberOfThreads
                );


            //
            // put optional GDI and USER counts at the end
            // If we can't open the process to get the information, report zeros
            //

            if( bGuiCount ) {
                DWORD dwGdi, dwUser;   // Count of GDI and USER handles
                HANDLE hProcess;       // process handle

                dwGdi= dwUser= 0;
    
                hProcess= OpenProcess( PROCESS_QUERY_INFORMATION,
                                       FALSE, 
                                       PtrToUlong(ProcessInfo->UniqueProcessId) );
                if( hProcess ) {
                   dwGdi=  GetGuiResources( hProcess, GR_GDIOBJECTS );
                   dwUser= GetGuiResources( hProcess, GR_USEROBJECTS );
                   CloseHandle( hProcess );
                }
        
                fprintf(LogFile, "%10u%10u", dwUser, dwGdi );

            }

            fprintf(LogFile, "\n" );
        } while( ProcessInfo->NextEntryOffset != 0 );
    }
    else {
        fprintf(LogFile, "NtQuerySystemInformation call failed!  NtStatus= %08x\n",Status);
        exit(-1);
    }
    
    //
    // free buffer
    //

    LocalFree(CurrentBuffer);
    
    //
    // close file
    //

    fclose(LogFile);
    
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\poolfiltres.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    poolfiltres.h

Abstract:

    This module defines resource identifiers for POOLFILT.

Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba
    
        Modified module to conform to coding standards.

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\bsc.c ===
//
// bsc.c -- manage queries on the database
//
//	Copyright <C> 1988, Microsoft Corporation
//
// Revision History:
//
//

#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>
#include <stddef.h>
#define LINT_ARGS
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#include <dos.h>
#else
#include <windows.h>
#endif



#include "hungary.h"
#include "mbrcache.h"
#include "version.h"
#include "sbrbsc.h"
#include "bsc.h"

#define LISTALLOC 50		// Browser max list size

// static data

static FILEHANDLE       fhBSC = (FILEHANDLE)(-1);             // .BSC file handle

static BYTE		fCase;			// TRUE for case compare
static BYTE		MaxSymLen;		// longest symbol length
static WORD		ModCnt; 		// count of modules

static ISYM 		Unknown;		// UNKNOWN symbol index

static WORD	 	ModSymCnt;		// count of modsyms
static WORD 		SymCnt; 		// count of symbols
static WORD 		PropCnt;		// count of properties
static DWORD 		RefCnt; 		// count of references
static WORD 		DefCnt; 		// count of definitions
static WORD 		CalCnt; 		// count of calls
static WORD 		CbyCnt; 		// count of called bys
static WORD 		lastAtomPage;		// last atom page #
static WORD 		lastAtomCnt;		// last atom page size

static WORD 		cbModSymCnt;		// size of list of modsyms
static WORD 		cbSymCnt;		// size of list of symbols
static WORD 		cbPropCnt;		// size of list of properties
static WORD 		cbRefCnt;		// size of list of references
static WORD 		cbDefCnt;		// size of list of definitions
static WORD 		cbCalCnt;		// size of list of calls
static WORD 		cbCbyCnt;		// size of list of called bys

static WORD 		MaxModSymCnt;		// max list of modsyms
static WORD 		MaxSymCnt;		// max list of symbols
static WORD 		MaxPropCnt;		// max list of properties
static WORD 		MaxRefCnt;		// max list of references
static WORD 		MaxDefCnt;		// max list of references
static WORD 		MaxCalCnt;		// max list of calls
static WORD 		MaxCbyCnt;		// max list of called bys

static DWORD		lbModSymList;		// modsym    list file start
static DWORD		lbSymList;		// symbol    list file start
static DWORD		lbPropList;		// property  list file start
static DWORD		lbRefList;		// reference list file start
static DWORD		lbDefList;		// def'n     list file start
static DWORD		lbCalList;		// calls     list file start
static DWORD		lbCbyList;		// call bys  list file start
static DWORD		lbSbrList;		// sbr       list file start
static DWORD		lbAtomCache;		// atom     cache file start

static WORD		CurModSymPage  = 0;	// Current page of modsyms
static WORD		CurSymPage     = 0;	// Current page of symbols
static WORD		CurPropPage    = 0;	// Current page of properties
static WORD		CurRefPage     = 0;	// Current page of references
static WORD		CurDefPage     = 0;	// Current page of definitions
static WORD		CurCalPage     = 0;	// Current page of calls
static WORD		CurCbyPage     = 0;	// Current page of called bys

static LSZ		lszBSCName     = NULL;	// name of .bsc file

static MODLIST	   far	*pfModList     = NULL;	// module    list cache start
static MODSYMLIST  far	*pfModSymList  = NULL;	// modsym    list cache start
static SYMLIST	   far	*pfSymList     = NULL;	// symbol    list cache start
static PROPLIST    far	*pfPropList    = NULL;	// property  list cache start
static REFLIST	   far	*pfRefList     = NULL;	// reference list cache start
static REFLIST	   far	*pfDefList     = NULL;	// def'n     list cache start
static USELIST	   far	*pfCalList     = NULL;	// calls     list cache start
static USELIST	   far	*pfCbyList     = NULL;	// call bys  list cache start

static WORD		AtomPageTblMac = 0;		// last cache page used
static CACHEPAGE	AtomPageTbl[MAXATOMPAGETBL];	// Atom Cache table

#define bMOD(imod)	(pfModList[imod])
#define bMODSYM(isym)   (pfModSymList[isym])
#define bSYM(isym)      (pfSymList[isym])
#define bPROP(iprop)    (pfPropList[iprop])

#define bREF(iref)      (pfRefList[iref])
#define bDEF(idef)      (pfDefList[idef])

#define bCAL(iuse)      (pfCalList[iuse])
#define bCBY(iuse)      (pfCbyList[iuse])
#define bUSE(iuse)      (pfCalList[iuse])
#define bUBY(iuse)      (pfCbyList[iuse])

// prototypes
//

#define BSCIn(v) ReadBSC(&v, sizeof(v));

static VOID	GetBSC (DWORD lpos, LPV lpv, WORD cb);
static VOID	ReadBSC(LPV lpv, WORD cb);
static WORD	SwapPAGE (DWORD, LPV, WORD, WORD, WORD *, DWORD);
static LPCH	GetAtomCache (WORD);

static VOID
ReadBSC(LPV lpv, WORD cb)
// read a block of data from the BSC file
//
{
    if (BSCRead(fhBSC, lpv, cb) != cb)
	ReadError(lszBSCName);
}

static VOID
GetBSC(DWORD lpos, LPV lpv, WORD cb)
// Read a block of the specified size from the specified position
//
{
#if defined (OS2)
    if (BSCSeek(fhBSC, lpos, SEEK_SET) == -1)
#else
    if (BSCSeek(fhBSC, lpos, FILE_BEGIN) == -1)
        SeekError(lszBSCName);
#endif

    if (BSCRead(fhBSC, lpv, cb) != cb)
	ReadError(lszBSCName);
}

static WORD
SwapPAGE (DWORD lbuflist, LPV pfTABLE, WORD tblsiz,
/* */      WORD lstsiz, WORD * pcurpage, DWORD idx)
//
//
// SwapPAGE -	Swap in the table page for the table pfTABLE[idx]
//		and return the table's new index in the page.
{
    WORD page;
    WORD newidx;

    page   = (WORD)(idx / lstsiz);
    newidx = (WORD)(idx % lstsiz);

    if (page == *pcurpage)
	return newidx;

    GetBSC(lbuflist+((long)tblsiz*(long)page), pfTABLE, tblsiz);

    *pcurpage = page;
    return newidx;
}

static WORD
ModSymPAGE (IMOD imod)
// Swap in the ModSym page for ModSym[imod]
// return the ModSym's index in the page.
//
{
    return SwapPAGE (lbModSymList, pfModSymList,
	cbModSymCnt, MaxModSymCnt, &CurModSymPage, (IDX)imod);
}

static WORD
SymPAGE (ISYM isym)
// Swap in the Symbol page for symbol[isym]
// return the Symbol's index in the page.
//
{
    return SwapPAGE (lbSymList, pfSymList,
	cbSymCnt, MaxSymCnt, &CurSymPage, (IDX)isym);
}

static WORD
PropPAGE (IINST iinst)
// Swap in the Property page for Property[idx]
// return the Property's index in the page.
//
{
    return SwapPAGE (lbPropList, pfPropList,
	cbPropCnt, MaxPropCnt, &CurPropPage, (IDX)iinst);
}

static WORD
RefPAGE (IREF iref)
// Swap in the Reference page for Reference[idx] 
// return the Reference's index in the page.
//
{
    return SwapPAGE (lbRefList, pfRefList,
	cbRefCnt, MaxRefCnt, &CurRefPage, (IDX)iref);
}

static WORD
DefPAGE (IDEF idef)
// Swap in the Deference page for Definition[idef]  
// return the Definitions index in the page.
//
{
    return SwapPAGE (lbDefList, pfDefList,
	cbDefCnt, MaxDefCnt, &CurDefPage, (IDX)idef);
}

static WORD
CalPAGE (IUSE iuse)
// Swap in the Usage page for Usage[iuse]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCalList, pfCalList,
	cbCalCnt, MaxCalCnt, &CurCalPage, (IDX)iuse);
}

static WORD
CbyPAGE (IUSE iuse)
// Swap in the Usage page for Usage[iuse]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCbyList, pfCbyList,
	cbCbyCnt, MaxCbyCnt, &CurCbyPage, (IDX)iuse);
}

static LPCH
GetAtomCache (WORD Page)
// load the requested page into the cache
//
{
    register	WORD ipg;
    WORD	pagesize;
    LPCH 	pfAtomCsave;

    for (ipg = 0; ipg < AtomPageTblMac; ipg++) {
	if (AtomPageTbl[ipg].uPage == Page)
	    return AtomPageTbl[ipg].pfAtomCache;
    }

    if (ipg != MAXATOMPAGETBL) {
	if (AtomPageTbl[ipg].pfAtomCache ||
	   (AtomPageTbl[ipg].pfAtomCache = LpvAllocCb(ATOMALLOC)))
		AtomPageTblMac++;
    }

    pfAtomCsave = AtomPageTbl[AtomPageTblMac-1].pfAtomCache;

    for (ipg = AtomPageTblMac-1; ipg; ipg--)
	AtomPageTbl[ipg] = AtomPageTbl[ipg-1];		// move up

    AtomPageTbl[0].pfAtomCache = pfAtomCsave;
    AtomPageTbl[0].uPage = Page;

    if (Page == lastAtomPage)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    GetBSC(lbAtomCache+ATOMALLOC*(long)Page,
		AtomPageTbl[0].pfAtomCache, pagesize);

    return AtomPageTbl[0].pfAtomCache;
}

LSZ BSC_API
LszNameFrSym (ISYM isym)
// Swap in the Atom page for the symbol isym
// return the atom's address in the page.
//
{
    SYMLIST sym;

    sym = bSYM(isym);
    return GetAtomCache (sym.Page) + sym.Atom;
}

LSZ BSC_API
LszNameFrMod (IMOD imod)
// Swap in the Atom page for the module isym
// return the atom's address in the page.
//
{
   return LszNameFrSym(bMOD(imod).ModName);
}

int BSC_API
CaseCmp(LSZ lsz1, LSZ lsz2)
//
// think of lsz1 and lsz2 being in a list of things that are sorted
// case insensitively and then case sensitively within that.  This is
// the case for browser symbols
//
// return -1, 0, or 1 if lsz1 before, at, or after lsz2 in the list
//
{
    int ret;

    // do case insensitive compare
    ret = _stricmp(lsz1, lsz2);

    // if this is good enough then use it, or if we are only doing
    // a case insensitive search then this is good enough

    if (ret || !fCase) return ret;

    // if we must, do the case sensitive compare

    return strcmp(lsz1, lsz2);
}


ISYM BSC_API
IsymFrLsz (LSZ lszReqd)
// find the symbol with the specifed name
//
{
    ISYM  Lo, Hi, Mid;
    int  Cmp;
    LSZ	 lszCur;

    Lo = 0;
    Hi = (ISYM)(SymCnt - 1);

    while (Lo <= Hi) {
        Mid = (ISYM)((Hi + Lo) / 2);

	lszCur = LszNameFrSym (Mid);
	Cmp = CaseCmp (lszReqd, lszCur);

	if (Cmp == 0)
	    return Mid;
	    
	if (Cmp < 0)
            Hi = (ISYM)(Mid - 1);
	else
            Lo = (ISYM)(Mid + 1);
	}
    return isymNil;
}

IMOD BSC_API
ImodFrLsz (LSZ lszReqd)
// find the module with the specifed name
//
{
    IMOD imod;

    for (imod = 0; imod < ModCnt; imod++) {
        if (_stricmp (lszReqd, LszNameFrSym (bMOD(imod).ModName)) == 0)
	    return imod;
	}

    return imodNil;
}

ISYM BSC_API
IsymMac()
// return the biggest isym in this database
//
{
   return SymCnt;
}

IMOD BSC_API
ImodMac()
// return the biggest imod in this database
//
{
   return ModCnt;
}

IINST BSC_API
IinstMac()
// return the biggest iinst in this database
//
{
   return PropCnt;
}

VOID BSC_API
MsRangeOfMod(IMOD imod, IMS *pimsFirst, IMS *pimsLast)
// fill in the module information
//
{
   *pimsFirst = imod ? bMOD(imod-1).mSymEnd : 0;
   *pimsLast  = bMOD(imod).mSymEnd;
}

IINST BSC_API
IinstOfIms(IMS ims)
// give the instance (PROP) index of the modsym
//
{
   return bMODSYM(ims).ModSymProp;
}

VOID BSC_API
InstRangeOfSym(ISYM isym, IINST *piinstFirst, IINST *piinstLast)
// fill in the range of inst values for this symbol
//
{
   *piinstFirst = isym ? bSYM(isym-1).PropEnd:0;
   *piinstLast  = bSYM(isym).PropEnd;
}

VOID BSC_API
InstInfo(IINST iinst, ISYM *pisymInst, TYP *pTyp, ATR *pAtr)
// get the information that qualifies this instance
//
{
   *pisymInst  = bPROP(iinst).PropName;
   *pAtr       = bPROP(iinst).PropAttr & 0x3ff;
   *pTyp       = (bPROP(iinst).PropAttr >> 11) & 0x1f;
}

VOID BSC_API
RefRangeOfInst(IINST iinst, IREF *pirefFirst, IREF *pirefLast)
// fill in the reference ranges from the inst
//
{
   *pirefFirst = iinst ? bPROP(iinst-1).RefEnd : 0;
   *pirefLast  = bPROP(iinst).RefEnd;
}

VOID BSC_API
DefRangeOfInst(IINST iinst, IDEF *pidefFirst, IDEF *pidefLast)
// fill in the definition ranges from the inst
//
{
   *pidefFirst = iinst ? bPROP(iinst-1).DefEnd : 0;
   *pidefLast  = bPROP(iinst).DefEnd;
}

VOID BSC_API
UseRangeOfInst(IINST iinst, IUSE *piuseFirst, IUSE *piuseLast)
// fill in the use ranges from the inst
//
{
   *piuseFirst = iinst ? bPROP(iinst-1).CalEnd : 0;
   *piuseLast  = bPROP(iinst).CalEnd;
}

VOID BSC_API
UbyRangeOfInst(IINST iinst, IUBY *piubyFirst, IUBY *piubyLast)
// fill in the used by ranges from the inst
//
{
   *piubyFirst = iinst ? bPROP(iinst-1).CbyEnd : 0;
   *piubyLast  = bPROP(iinst).CbyEnd;
}

VOID BSC_API
UseInfo(IUSE iuse, IINST *piinst, WORD *pcnt)
// fill in the information about this things which an inst uses
//
{
   *piinst = bUSE(iuse).UseProp;
   *pcnt   = bUSE(iuse).UseCnt;
}

VOID BSC_API
UbyInfo(IUBY iuby, IINST *piinst, WORD *pcnt)
// fill in the information about this things which an inst is used by
//
{
   *piinst = bUBY(iuby).UseProp;
   *pcnt   = bUBY(iuby).UseCnt;
}

VOID BSC_API
RefInfo(IREF iref, LSZ *plszName, WORD *pline)
// fill in the information about this reference
//
{
   *pline    = bREF(iref).RefLin;
   *plszName = LszNameFrSym(bREF(iref).RefNam);
}

VOID BSC_API
DefInfo(IDEF idef, LSZ *plszName, WORD *pline)
// fill in the information about this definition
//
{
   *pline    = bDEF(idef).RefLin;
   *plszName = LszNameFrSym(bDEF(idef).RefNam);
}

VOID BSC_API
CloseBSC()
// close database and free as much memory as possible
//
{
    int i;

    // close file if open

    if (fhBSC != (FILEHANDLE)(-1)) {
	BSCClose (fhBSC);
        fhBSC = (FILEHANDLE)(-1);
    }

    // free any memory we may have allocated

    if (pfModList)    { FreeLpv (pfModList);	pfModList    = NULL; }
    if (pfModSymList) { FreeLpv (pfModSymList); pfModSymList = NULL; }
    if (pfSymList)    { FreeLpv (pfSymList);	pfSymList    = NULL; }
    if (pfPropList)   { FreeLpv (pfPropList);	pfPropList   = NULL; }
    if (pfRefList)    { FreeLpv (pfRefList);	pfRefList    = NULL; }
    if (pfDefList)    { FreeLpv (pfDefList);	pfDefList    = NULL; }
    if (pfCalList)    { FreeLpv (pfCalList);	pfCalList    = NULL; }
    if (pfCbyList)    { FreeLpv (pfCbyList);	pfCbyList    = NULL; }

    for (i=0; i < MAXATOMPAGETBL; i++) {
	if (AtomPageTbl[i].pfAtomCache) {
	    FreeLpv (AtomPageTbl[i].pfAtomCache);  // dispose Atom Cache
	    AtomPageTbl[i].pfAtomCache = NULL;
	}
    }
}

BOOL BSC_API
FOpenBSC (LSZ lszName)
//  Open the specified data base.
//  Allocate buffers for cache areas
//  Initialize the data cache from the data base.
//
//  Return TRUE iff successful, FALSE if database can't be read
//
{
    WORD	pagesize;

    BYTE	MajorVer;		// .bsc version (major)
    BYTE	MinorVer;		// .bsc version (minor)
    BYTE	UpdatVer;		// .bsc version (updat)

    WORD	MaxModCnt;		// max list of modules
    WORD	cbModCnt;		// size of list of modules
    DWORD	lbModList;		// module  list file start

    int 	i;

    #define ABORT_OPEN	CloseBSC(); return FALSE;

    lszBSCName = lszName;

#if defined (OS2)
    fhBSC = BSCOpen(lszBSCName, O_BINARY|O_RDONLY);
#else
    fhBSC = BSCOpen(lszBSCName, GENERIC_READ);
#endif

    // if the .bsc file doesn't exist then we don't do any work
    // this is the cold compile case
    //

    if (fhBSC == (FILEHANDLE)(-1)) {ABORT_OPEN;}

    // read and check BSC version (major, minor and update)

    BSCIn(MajorVer);
    BSCIn(MinorVer);
    BSCIn(UpdatVer);

    BSCPrintf("Browser Data Base: %s ver %d.%d.%d\n\n",
	 lszBSCName, MajorVer, MinorVer, UpdatVer);

    if ((MajorVer !=  BSC_MAJ) ||
	(MinorVer !=  BSC_MIN) ||
	(UpdatVer !=  BSC_UPD)) {

	    CloseBSC();
	    BadBSCVer(lszBSCName);
	    return FALSE;
	}

    // read Case sense switch, max symbol length and Unknown module id

    BSCIn(fCase);
    BSCIn(MaxSymLen);
    BSCIn(Unknown);

    // this will make the formatting look more reasonable if there are
    // only very short names in the database

    if (MaxSymLen < 8 ) MaxSymLen = 8;

    // read counts (sizes) of each data area

    BSCIn(ModCnt);
    BSCIn(ModSymCnt);
    BSCIn(SymCnt);
    BSCIn(PropCnt);
    BSCIn(RefCnt);
    BSCIn(DefCnt);
    BSCIn(CalCnt);
    BSCIn(CbyCnt);
    BSCIn(lastAtomPage);
    BSCIn(lastAtomCnt);

    // read BSC data area offsets

    BSCIn(lbModList);
    BSCIn(lbModSymList);
    BSCIn(lbSymList);
    BSCIn(lbPropList);
    BSCIn(lbRefList);
    BSCIn(lbDefList);
    BSCIn(lbCalList);
    BSCIn(lbCbyList);
    BSCIn(lbAtomCache);
    BSCIn(lbSbrList);

    // determine data cache area sizes

    #define MIN(a,b) ((a)>(b) ? (b) : (a))

    MaxModCnt    = ModCnt;              // max list of modules
    MaxModSymCnt = ModSymCnt;           // max list of modsyms
    MaxSymCnt    = SymCnt+ModCnt;       // max list of symbols
    MaxPropCnt   = PropCnt;             // max list of props
    MaxRefCnt    = RefCnt;              // max list of refs
    MaxDefCnt    = DefCnt;              // max list of defs
    MaxCalCnt    = CalCnt;              // max list of cals
    MaxCbyCnt    = CbyCnt;              // max list of cbys

    cbModCnt	 = sizeof(MODLIST)    * MaxModCnt;	// size of mods list
    cbModSymCnt  = sizeof(MODSYMLIST) * MaxModSymCnt;	// size of modsyms list
    cbSymCnt	 = sizeof(SYMLIST)    * MaxSymCnt;	// size of syms list
    cbPropCnt	 = sizeof(PROPLIST)   * MaxPropCnt;	// size of props list
    cbRefCnt	 = sizeof(REFLIST)    * MaxRefCnt;	// size of refs list
    cbDefCnt	 = sizeof(REFLIST)    * MaxDefCnt;	// size of defs list
    cbCalCnt	 = sizeof(USELIST)    * MaxCalCnt;	// size of cals list
    cbCbyCnt	 = sizeof(USELIST)    * MaxCbyCnt;	// size of cbys list

    // Allocate buffers for each of the object types

    if (!(pfModList	= LpvAllocCb(cbModCnt)))	{ ABORT_OPEN; }
    if (!(pfModSymList	= LpvAllocCb(cbModSymCnt)))	{ ABORT_OPEN; }
    if (!(pfSymList	= LpvAllocCb(cbSymCnt)))	{ ABORT_OPEN; }
    if (!(pfPropList	= LpvAllocCb(cbPropCnt)))	{ ABORT_OPEN; }
    if (!(pfRefList	= LpvAllocCb(cbRefCnt)))	{ ABORT_OPEN; }
    if (!(pfDefList	= LpvAllocCb(cbDefCnt)))	{ ABORT_OPEN; }
    if (!(pfCalList	= LpvAllocCb(cbCalCnt)))	{ ABORT_OPEN; }
    if (!(pfCbyList	= LpvAllocCb(cbCbyCnt)))	{ ABORT_OPEN; }

    // read data areas

    if (lastAtomPage == 0)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    // clear out the atom cache
    // we must be able to allocate at least one page

    AtomPageTblMac = 0;

    for (i=0; i < MAXATOMPAGETBL; i++)
	AtomPageTbl[i].pfAtomCache = NULL;

    AtomPageTbl[0].uPage = 65535;
    AtomPageTbl[0].pfAtomCache = LpvAllocCb(pagesize);
    if (!AtomPageTbl[0].pfAtomCache) { ABORT_OPEN; }


    GetBSC(lbModList,    pfModList,    cbModCnt);    // Init Mod    cache
    GetBSC(lbModSymList, pfModSymList, cbModSymCnt); // Init ModSym cache
    GetBSC(lbSymList,    pfSymList,    cbSymCnt);    // Init Sym    cache
    GetBSC(lbPropList,   pfPropList,   cbPropCnt);   // Init Prop   cache
    GetBSC(lbRefList,    pfRefList,    cbRefCnt);    // Init Ref    cache
    GetBSC(lbDefList,    pfDefList,    cbDefCnt);    // Init Def    cache
    GetBSC(lbCalList,    pfCalList,    cbCalCnt);    // Init Cal    cache
    GetBSC(lbCbyList,    pfCbyList,    cbCbyCnt);    // Init Cby    cache

    // current page for all database items is now page zero

    CurModSymPage = 0;
    CurSymPage    = 0;
    CurPropPage   = 0;
    CurRefPage    = 0;
    CurDefPage    = 0;
    CurCalPage    = 0;
    CurCbyPage    = 0;

    GetAtomCache (0);  // Init Atom cache

    return TRUE;
}

WORD BSC_API
BSCMaxSymLen()
// return the length of the largest symbol in the database
//
{
    return MaxSymLen;
}

BOOL BSC_API
FCaseBSC()
// is this database built with a case sensitive language?
//
{
   return fCase;
}

VOID BSC_API
SetCaseBSC(BOOL fNewCase)
// set case sensitivity of database
//
{
   fCase = (BYTE)!!fNewCase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\sortlog.c ===
// sortlog.c 
//
// this program sorts memsnap and poolsnap logs into a more readable form 
// sorts by pid 
// scans the data file one time, inserts record offsets based on PID into linked list 
// then writes data into new file in sorted order 
// determine whether we have a poolsnap or memsnap log - in pid is equivalent 
// to pooltag for our sorting 

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <stdlib.h>

// definitions 
#define RECSIZE     1024   // record size  (max line size)
#define MAXTAGSIZE  200    // max length of tag name

#define DEFAULT_INFILE  "memsnap.log"
#define DEFAULT_OUTFILE "memsort.log"

typedef enum _FILE_LOG_TYPES {
    MEMSNAPLOG=0,
    POOLSNAPLOG,
    UNKNOWNLOG
} FILE_LOG_TYPES;

//
// Linked list of unique PID or PoolTag
//

typedef struct PIDList {
    char            PIDItem[11];
    struct RecList* RecordList;
    struct PIDList* Next;
    DWORD           Count;                // number of items pointed to by RecordList
};

//
// For each PID or pool tag, we have a linked list of offsets into file of each line
//

typedef struct RecList {
    LONG            rOffset;
    struct RecList* Next;
};

// global data 
FILE_LOG_TYPES CurrentFileType= UNKNOWNLOG;
CHAR szHeader[RECSIZE];         // first line of file 
BOOL bIgnoreTransients= FALSE;  // Ignore tags or processes that aren't in every snapshot
DWORD g_MaxSnapShots= 0;        // max snap shots in the file 

#define INVALIDOFFSET (-2)   /* invalid file offset */

// prototypes 
VOID ScanFile(FILE *, struct PIDList *);
VOID WriteFilex(FILE *, FILE *, struct PIDList *);

VOID Usage(VOID)
{

    printf("sortlog [-?] [<logfile>] [<outfile>]\n");
    printf("Sorts an outputfile from memsnap.exe/poolsnap.exe in PID/PoolTag order\n");
    printf("-?        prints this help\n");
    printf("-i        ignore tags or processes that are not in every snapshot\n");
    printf("<logfile> = %s by default\n",DEFAULT_INFILE );
    printf("<outfile> = %s by default\n",DEFAULT_OUTFILE);
    exit(-1);
}

// CheckPointer
//
// Make sure it is not NULL.  Otherwise print error message and exit.
//


VOID CheckPointer( PVOID ptr )
{
    if( ptr == NULL ) {
        printf("Out of memory\n");
       exit(-1);
    }
}

#include "tags.c"

int __cdecl main(int argc, char* argv[])
{
    FILE* InFile;
    FILE* OutFile;
    struct PIDList ThePIDList = {0};
    CHAR* pszInFile= NULL;              // input filename
    CHAR* pszOutFile= NULL;             // output filename
    INT   iFileIndex= 0;
    INT   iCmdIndex;                    // index into argv

    ThePIDList.RecordList = (struct RecList *)LocalAlloc(LPTR, sizeof(struct RecList));
    CheckPointer( ThePIDList.RecordList );
    ThePIDList.RecordList->rOffset= INVALIDOFFSET;

    //
    // parse command line
    //

    for( iCmdIndex=1; iCmdIndex<argc; iCmdIndex++ ) {
        CHAR chr;

        chr= argv[iCmdIndex][0];

        if( (chr=='-') || (chr=='/') ) {
            chr= argv[iCmdIndex][1];
            switch( chr ) {
                case '?':
                    Usage();
                    break;
                case 'i':         // ignore all process that weren't running the whole time
                    bIgnoreTransients= TRUE;
                    break;
                default:
                    printf("Invalid switch %s\n",argv[iCmdIndex]);
                    Usage();
                    break;
            }
        }
        else {
            if( iFileIndex == 0 ) {
                pszInFile= argv[iCmdIndex];
                iFileIndex++;
            }
            else if( iFileIndex == 1 ) {
                pszOutFile= argv[iCmdIndex];
                iFileIndex++;
            }
            else {
                printf("Too many files specified\n");
                Usage();
            }
        }
    }

    //
    // fill in default filenames if some aren't given
    //

    switch( iFileIndex ) {
       case 0:
          pszInFile=  DEFAULT_INFILE;
          pszOutFile= DEFAULT_OUTFILE;
          break;

       case 1:
          pszOutFile= DEFAULT_OUTFILE;
          break;
      
       default:
           break;
    }


    //
    // open the files
    //

    InFile= fopen( pszInFile, "r" );
    if( InFile == NULL ) {
        printf("Error opening input file %s\n",pszInFile);
        return( 0 );
    }
    
    OutFile= fopen( pszOutFile, "a" );
    if( OutFile == NULL ) {
        printf("Error opening output file %s\n",pszOutFile);
        return( 0 );
    }

    //
    // read in the data and set up the list
    //

    ScanFile(InFile, &ThePIDList);

    //
    // write the output file 
    //

    WriteFilex(InFile, OutFile, &ThePIDList);

    // close and exit 
    _fcloseall();
    return 0;
}

// read the input file and get the offset to each record in order and put in list

VOID ScanFile(FILE *InFile, struct PIDList *ThePIDList)
{
    char inchar = 0;
    char inBuff[RECSIZE] = {0};
    char PID[11] = {0};
    LONG Offset = 0;
    BOOL Found = FALSE;
    struct PIDList *TmpPIDList;
    struct RecList *TmpRecordList;
    INT iGarb = 0;

    /* initialize temp list pointer */
    TmpPIDList = ThePIDList;

    /* read to the first newline, check for EOF */
    /* determine whether it is a poolsnap or memsnap log */
    if ((fscanf(InFile, "%[^\n]", &szHeader)) == EOF)
        return;
    if (strncmp("Process ID", szHeader, 10) == 0)
        CurrentFileType= MEMSNAPLOG;
    if (strncmp(" Tag  Type", szHeader, 10) == 0)
        CurrentFileType= POOLSNAPLOG;

    if( CurrentFileType == UNKNOWNLOG )
    {
        printf("unrecognized log file\n");
        return;
    }

    inBuff[0] = 0;

    /* read to the end of file */
    while (!feof(InFile)) {
        /* record the offset */
        Offset = ftell(InFile);

        /* if first char == newline, skip to next */
        if ((fscanf(InFile, "%[^\n]", &inBuff)) == EOF)
            return;
        /* read past delimiter */
        inchar = (char)fgetc(InFile);
        // skip if its an empty line
        if (strlen(inBuff) == 0) {
            continue;
        }
        // 
        // Handle tags if this is a tagged line
        //

        if( inBuff[0] == '!' )
        {
            ProcessTag( inBuff+1 );
            continue;
        }


        if (3 == sscanf(inBuff, "%2u\\%2u\\%4u", &iGarb, &iGarb, &iGarb)){
            continue;
        }

        /* read the PID */
        strncpy(PID,inBuff,10);

        // scan list of PIDS, find matching, if no matching, make new one
        // keep this list sorted

        TmpPIDList = ThePIDList;    /* point to top of list */
        Found= FALSE;
        while( TmpPIDList->Next != 0 ) {
            int iComp;

            iComp= strcmp( PID, TmpPIDList->PIDItem);
            if( iComp == 0 ) {  // found
                Found= TRUE;
                break;
            } else {            // not found
                if( iComp < 0 ) {  // exit if we have gone far enough
                   break;
                }
                TmpPIDList= TmpPIDList->Next;
            }
        }

        // if matching, append offset to RecordList
        // add offset to current PID list

        if( Found ) {
            TmpPIDList->Count= TmpPIDList->Count + 1;
            if( TmpPIDList->Count > g_MaxSnapShots ) g_MaxSnapShots= TmpPIDList->Count;

            TmpRecordList= TmpPIDList->RecordList;
            // walk to end of list
            while( TmpRecordList->Next != 0 ) {
                TmpRecordList= TmpRecordList->Next;
            }

            TmpRecordList->Next= (struct RecList*)LocalAlloc(LPTR, sizeof(struct RecList));
            CheckPointer( TmpRecordList->Next );
            TmpRecordList->Next->rOffset= Offset;
        }
        // make new PID list, add new PID, add offset
        else {
            struct PIDList* pNewPID;
            // allocate a new PID,
            // copy current PID information to it
            // overwrite current PID information with new PID information
            // have current PID point to new PID which may point on

            pNewPID= (struct PIDList*) LocalAlloc(LPTR, sizeof(struct PIDList));
            CheckPointer( pNewPID );
            memcpy( pNewPID, TmpPIDList, sizeof(*pNewPID) );

            strcpy( TmpPIDList->PIDItem, PID );
            TmpPIDList->RecordList= (struct RecList*) LocalAlloc(LPTR, sizeof(struct RecList));
            CheckPointer( TmpPIDList->RecordList );
            TmpPIDList->RecordList->rOffset= Offset;
            TmpPIDList->Next= pNewPID;
            TmpPIDList->Count= 1;
 
        }

        /* if EOF, return */
        /* clear the inBuff */
        inBuff[0] = 0;
    }

}

// look for the next PID line in the first table 

VOID WriteFilex(FILE *InFile, FILE *OutFile, struct PIDList *ThePIDList)
{
    struct PIDList *TmpPIDList;
    struct RecList *TmpRecordList;
    char inBuff[RECSIZE] = {0};    

    /* initialize temp list pointer */
    TmpPIDList = ThePIDList;

    /* heading */
    fprintf(OutFile,"%s\n",szHeader);

    OutputTags( OutFile );


    /* while not end of list, write records at offset to end of output file */
    while (TmpPIDList != 0) {
        TmpRecordList = TmpPIDList->RecordList;


        if( (!bIgnoreTransients) || (TmpPIDList->Count == g_MaxSnapShots) ) {
            while (TmpRecordList != 0) {
                LONG Offset;
    
                Offset= TmpRecordList->rOffset;
                if( Offset != INVALIDOFFSET ) {
                    /* read in record */
                    if (fseek(InFile, TmpRecordList->rOffset, SEEK_SET) == -1) break;
                    if (fscanf(InFile, "%[^\n]", &inBuff) != 1) break;
    
                    /* read out record */
                    fprintf(OutFile, "%s\n", &inBuff);
                 }
    
                /* get next record */
                TmpRecordList = TmpRecordList->Next;
            }
    
            /* add a line here */
            fputc('\n', OutFile);
        }

        /* get next record */
        TmpPIDList = TmpPIDList->Next;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\poolfilt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    poolfilt.cpp

Abstract:

    This module filters out the useful information from a sorted poolsnap output file.
    
Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba

        Modified module to conform to coding standards.

--*/

#include <nt.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define PF_NEW_TAG 0
#define PF_UPDATE 1

// globals

LONG MinimumAllocationsChangeToReport=1;
LONG MinimumBytesChangeToReport=1;
BOOLEAN ReportIncreasesOnly = TRUE;


VOID 
PrintUsage(
    )

/*++

Routine Description:

    This routine prints an informational message about the proper usage of POOLFILT.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    
    _ftprintf(stderr, _T("Summarizes possible leaks in a sorted poolsnap output file.\n\n"));
    _ftprintf(stderr, _T("POOLFILT file [/MINALLOCS:n] [/MINBYTES:n] [/ALL]\n\n"));
    _ftprintf(stderr, _T("file           The sorted poolsnap output file to summarize.\n"));
    _ftprintf(stderr, _T("/MINALLOCS:n   Reports only tags where open allocations change by at least n.\n"));
    _ftprintf(stderr, _T("/MINBYTES:n    Reports only tags where bytes allocated change by at least n.\n"));
    _ftprintf(stderr, _T("/ALL           Reports decreases as well as increases.\n"));
    
}


VOID
PrintTagInformation(
    IN BOOLEAN AllocationsAlwaysGrow,
    IN BOOLEAN BytesAlwaysGrow,
    IN LPTSTR TagName, 
    IN LONG InitialAllocations,
    IN LONG FinalAllocations,
    IN LONG InitialBytes,
    IN LONG FinalBytes
    )

/*++

Routine Description:

    This routine reports the memory usage of a single process.
    
Arguments:

    AllocationsAlwaysGrow - TRUE if number of open allocations monotonically increases.
    
    BytesAlwaysGrow - TRUE if number of bytes allocated monotonically increases.
    
    TagName - the name of the tag being reported.
    
    InitialAllocations - initial number of open allocations for this tag.
    
    FinalAllocations - final number fo open allocations for this tag.
    
    InitialBytes - initial number of bytes allocated for this tag.
    
    FinalBytes - final number of bytes allocated for this tag.

Return value:

    None.

--*/

{
    
    _TCHAR AllocationsString[64];
    _TCHAR BytesString[64];
    
    if(((!ReportIncreasesOnly) && 
        (abs(FinalAllocations - InitialAllocations) >= 
        MinimumAllocationsChangeToReport)) ||
        (FinalAllocations - InitialAllocations >= 
        MinimumAllocationsChangeToReport)) {
        
        _stprintf(AllocationsString, _T("%10d->%10d"), InitialAllocations, FinalAllocations);
            
    } else {
        
        _tcscpy(AllocationsString, _T("                      "));
        
    }
    
    if(((!ReportIncreasesOnly) &&
        (abs(FinalBytes - InitialBytes) >=
        MinimumBytesChangeToReport)) ||
        (FinalBytes - InitialBytes >=
        MinimumBytesChangeToReport)) {
            
        _stprintf(BytesString, _T("%10d->%10d"), InitialBytes, FinalBytes);
        
    } else {
        
        _tcscpy(BytesString, _T("                      "));
        
    }
    
    _tprintf(_T("%c%c %s %s %s\n"), 
        (AllocationsAlwaysGrow && (FinalAllocations != InitialAllocations) ? _T('!') : _T(' ')),
        (BytesAlwaysGrow && (FinalBytes != InitialBytes) ? _T('!') : _T(' ')),
        TagName, AllocationsString, BytesString);

}

LONG _cdecl 
_tmain(
    IN LONG argc, 
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This routine parses program arguments, reads the input file, and outputs the result.
    
Arguments:

    argc - Number of command line arguments.
    
    argv - Command line arguments.

Return value:

    0 if filtering is successful, 1 otherwise.

--*/

{

    try {
        
        _TCHAR LineBuffer[256];
        _TCHAR PoolTag[11];
        LONG CurrentState = PF_NEW_TAG;
        LONG InitialAllocations = 0;
        LONG FinalAllocations = 0;
        LONG NewAllocations = 0;
        LONG InitialBytes = 0;
        LONG FinalBytes = 0;
        LONG NewBytes = 0;
        BOOLEAN AllocationsAlwaysGrow = TRUE;
        BOOLEAN BytesAlwaysGrow = TRUE;
        LPTSTR InputFileName = NULL;
        BOOLEAN InterpretedArgument = FALSE;
        FILE *InputFile = NULL;

        // make sure PoolTag is properly terminated

        PoolTag[10]=_T('\0');

        // process arguments

        for(LONG n = 1; n < argc; n++) {

            InterpretedArgument = FALSE;
            switch(argv[n][0]) {

            case _T('-'):

            case _T('/'):

                // it's a switch

                if(!_tcsnicmp(argv[n]+1, _T("minallocs:"), 10)) {

                    MinimumAllocationsChangeToReport = _ttoi(argv[n]+11);
                    InterpretedArgument = TRUE;

                }

                if(!_tcsnicmp(argv[n]+1, _T("minbytes:"), 9)) {

                    MinimumBytesChangeToReport = _ttoi(argv[n]+10);
                    InterpretedArgument = TRUE;

                }

                if(!_tcsicmp(argv[n]+1, _T("all"))) {

                    ReportIncreasesOnly = FALSE;
                    InterpretedArgument = TRUE;

                }

                break;

            default:

                // it's a filename

                if(InputFileName != NULL) {

                    // already have the filename

                    PrintUsage();
                    return 1;

                }

                InputFileName = argv[n];
                InterpretedArgument = TRUE;

                break;

            }

            if(!InterpretedArgument) {

                PrintUsage();
                return 1;

            }

        }

        if(InputFileName == NULL) {

            // user didn't specify filename

            PrintUsage();
            return 1;

        }

        InputFile = _tfopen(InputFileName, _T("rt"));

        if(InputFile == NULL) {

            _ftprintf(stderr, _T("Cannot open input file."));
            return 1;

        }

        // get first line

        _fgetts(LineBuffer, 256, InputFile);

        // simple check for sorted poolsnap output

        if(_tcsncmp(LineBuffer, _T(" Tag  Type     Allocs     Frees      Diff   Bytes  Per Alloc"), 60)) {

            _ftprintf(stderr, _T("Input is not a sorted poolsnap log."));
            return 1;

        }

        // get next line

        _fgetts(LineBuffer, 256, InputFile);

        while(!feof(InputFile)) {

            if(!_tcscmp(LineBuffer,_T("\n"))) {

                CurrentState = PF_NEW_TAG;

                if(ReportIncreasesOnly) {

                    if(((FinalAllocations - InitialAllocations) >= MinimumAllocationsChangeToReport) 
                        || ((FinalBytes - InitialBytes) >= MinimumBytesChangeToReport)) {

                        PrintTagInformation(AllocationsAlwaysGrow, BytesAlwaysGrow,
                            PoolTag, InitialAllocations, FinalAllocations,
                            InitialBytes, FinalBytes);

                    }

                } else {

                    if((abs(FinalAllocations - InitialAllocations) >= MinimumAllocationsChangeToReport) 
                        || (abs(FinalBytes - InitialBytes) >= MinimumBytesChangeToReport)) {

                        PrintTagInformation(AllocationsAlwaysGrow, BytesAlwaysGrow,
                            PoolTag, InitialAllocations, FinalAllocations,
                            InitialBytes, FinalBytes);

                    }

                }

            } else {

                if(_tcslen(LineBuffer) <= 42) {

                    _ftprintf(stderr, _T("Format violated.\n"));
                    return 1;

                }

                switch(CurrentState) {

                case PF_NEW_TAG:

                    // get tag and paged/non-paged

                    _tcsncpy(PoolTag, LineBuffer+1, 10);

                    // get allocs

                    _stscanf(LineBuffer+32, _T("%d"), &InitialAllocations);

                    // get bytes

                    _stscanf(LineBuffer+42, _T("%d"), &InitialBytes);

                    // assume this always grows until we find a counterexample

                    AllocationsAlwaysGrow = TRUE;
                    BytesAlwaysGrow = TRUE;

                    // this is initial and final until we find another

                    FinalAllocations = InitialAllocations;
                    FinalBytes = InitialBytes;

                    // keep updating this tag

                    CurrentState = PF_UPDATE;
                    break;

                case PF_UPDATE:

                    // get allocs

                    _stscanf(LineBuffer+32, _T("%d"), &NewAllocations);

                    // get bytes

                    _stscanf(LineBuffer+42, _T("%d"), &NewBytes);

                    // did allocs decrease?

                    if(NewAllocations < FinalAllocations) {

                        AllocationsAlwaysGrow = FALSE;

                    }

                    // did bytes decrease?

                    if(NewBytes < FinalBytes) {

                        BytesAlwaysGrow = FALSE;

                    }

                    // copy new to final

                    FinalAllocations = NewAllocations;
                    FinalBytes = NewBytes;

                    break;

                }

            }

            // get next line
            _fgetts(LineBuffer, 256, InputFile);

        }

        // done
        fclose(InputFile);
        return 0;
        
    } catch (...) {
        
        // this is mostly intended to catch out-of-memory conditions
        
        _tprintf(_T("\nAn exception was detected.  POOLFILT aborted.\n"));
        return 1;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\poolsnap.c ===
// poolsnap.c 
// this program takes a snapshot of all the kernel pool tags. 
// and appends it to the logfile (arg) 
// pmon was model for this 

/* includes */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <srvfsctl.h>
#include <search.h>

#include "tags.c"

//
// declarations
//

int __cdecl ulcomp(const void *e1,const void *e2);

NTSTATUS
QueryPoolTagInformationIterative(
    PUCHAR *CurrentBuffer,
    size_t *CurrentBufferSize
    );

//
// definitions
//

#define NONPAGED 0
#define PAGED 1
#define BOTH 2


// from poolmon 
// raw input 

PSYSTEM_POOLTAG_INFORMATION PoolInfo;

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

//
// the buffer used for NtQuerySystemInformation
//

PUCHAR CurrentBuffer = NULL;

//
// the size of the buffer used for NtQuerySystemInformation
//

size_t CurrentBufferSize = 0;

//
// formatted output
//

typedef struct _POOLMON_OUT {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    UCHAR  NullByte;
    BOOL   Changed;
    ULONG  Type;
    SIZE_T Allocs;
    SIZE_T AllocsDiff;
    SIZE_T Frees;
    SIZE_T FreesDiff;
    SIZE_T Allocs_Frees;
    SIZE_T Used;
    SIZE_T UsedDiff;
    SIZE_T Each;
} POOLMON_OUT, *PPOOLMON_OUT;

PPOOLMON_OUT OutBuffer;
PPOOLMON_OUT Out;

UCHAR *PoolType[] = {
    "Nonp ",
    "Paged"};


VOID Usage(VOID)
{
    printf("poolsnap [-?] [-t] [<logfile>]\n");
    printf("poolsnap logs system pool usage to <logfile>\n");
    printf("-?  Gives this help\n");
    printf("-t  Output extra tagged information\n");
    printf("<logfile> = poolsnap.log by default\n");
    exit(-1);
}

/*
 * FUNCTION: Main
 *
 * ARGUMENTS: See Usage
 *
 * RETURNS: 0
 *
 */

int __cdecl main(int argc, char* argv[])
{
    NTSTATUS Status;                   // status from NT api
    FILE*    LogFile= NULL;            // log file handle 
    DWORD    x= 0;                     // counter
    SIZE_T   NumberOfPoolTags;
    INT      iCmdIndex;                // index into argv
    BOOL     bOutputTags= FALSE;       // if true, output standard tags

    // get higher priority in case system is bogged down 
    if ( GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    //
    // parse command line arguments
    //

    for( iCmdIndex=1; iCmdIndex < argc; iCmdIndex++ ) {

        CHAR chr;

        chr= *argv[iCmdIndex];

        if( (chr=='-') || (chr=='/') ) {
            chr= argv[iCmdIndex][1];
            switch( chr ) {
                case '?':
                    Usage();
                    break;
                case 't': case 'T':
                    bOutputTags= TRUE;
                    break;
                default:
                    printf("Invalid switch: %s\n",argv[iCmdIndex]);
                    Usage();
                    break;
            }
        }
        else {
            if( LogFile ) {
                printf("Error: more than one file specified: %s\n",argv[iCmdIndex]);
                return(0);
            }
            LogFile= fopen(argv[iCmdIndex],"a");
            if( !LogFile ) {
                printf("Error: Opening file %s\n",argv[iCmdIndex]);
                return(0);
            }
        }
    }


    //
    // if no file specified, use default name
    //

    if( !LogFile ) {
        if( (LogFile = fopen("poolsnap.log","a")) == NULL ) {
            printf("Error: opening file poolsnap.log\n");
            return(0);
        }
    }

    //
    // print file header once
    //

    if( _filelength(_fileno(LogFile)) == 0 ) {
        fprintf(LogFile," Tag  Type     Allocs     Frees      Diff   Bytes  Per Alloc\n");
    }
    fprintf(LogFile,"\n");


    if( bOutputTags ) {
         OutputStdTags(LogFile, "poolsnap" );
    }

    // grab all pool information
    // log line format, fixed column format

    Status = QueryPoolTagInformationIterative(
                &CurrentBuffer,
                &CurrentBufferSize
                );

    if (! NT_SUCCESS(Status)) {
        printf("Failed to query pool tags information (status %08X). \n", Status);
        printf("Please check if pool tags are enabled. \n");
        return (0);
    }

    PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)CurrentBuffer;

    //
    // Allocate the output buffer.
    //

    OutBuffer = malloc (PoolInfo->Count * sizeof(POOLMON_OUT));

    if (OutBuffer == NULL) {
        printf ("Error: cannot allocate internal buffer of %p bytes \n",
                PoolInfo->Count * sizeof(POOLMON_OUT));
        return (0);
    }

    Out = OutBuffer;

    if( NT_SUCCESS(Status) ) {
        for (x = 0; x < (int)PoolInfo->Count; x++) {
            // get pool info from buffer 

            // non-paged 
            if (PoolInfo->TagInfo[x].NonPagedAllocs != 0) {
                Out->Allocs = PoolInfo->TagInfo[x].NonPagedAllocs;
                Out->Frees = PoolInfo->TagInfo[x].NonPagedFrees;
                Out->Used = PoolInfo->TagInfo[x].NonPagedUsed;
                Out->Allocs_Frees = PoolInfo->TagInfo[x].NonPagedAllocs -
                                    PoolInfo->TagInfo[x].NonPagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[x].TagUlong;
                Out->Type = NONPAGED;
                Out->Changed = FALSE;
                Out->NullByte = '\0';
                Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
            }

            // paged
            if (PoolInfo->TagInfo[x].PagedAllocs != 0) {
                Out->Allocs = PoolInfo->TagInfo[x].PagedAllocs;
                Out->Frees = PoolInfo->TagInfo[x].PagedFrees;
                Out->Used = PoolInfo->TagInfo[x].PagedUsed;
                Out->Allocs_Frees = PoolInfo->TagInfo[x].PagedAllocs -
                                    PoolInfo->TagInfo[x].PagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[x].TagUlong;
                Out->Type = PAGED;
                Out->Changed = FALSE;
                Out->NullByte = '\0';
                Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
            }
            Out += 1;
        }
    }

    else {
        fprintf(LogFile, "Query pooltags Failed %lx\n",Status);
        fprintf(LogFile, "  Be sure to turn on 'enable pool tagging' in gflags and reboot.\n");
        if( bOutputTags ) {
            fprintf(LogFile, "!Error:Query pooltags failed %lx\n",Status);
            fprintf(LogFile, "!Error:  Be sure to turn on 'enable pool tagging' in gflags and reboot.\n");
        }

        // If there is an operator around, wake him up, but keep moving

        Beep(1000,350); Beep(500,350); Beep(1000,350);
        exit(0);
    }

    //
    // sort by tag value which is big endian 
    // 

    NumberOfPoolTags = Out - OutBuffer;
    qsort((void *)OutBuffer,
          (size_t)NumberOfPoolTags,
          (size_t)sizeof(POOLMON_OUT),
          ulcomp);

    //
    // print in file
    //

    for (x = 0; x < (int)PoolInfo->Count; x++) {
        fprintf(LogFile,
#ifdef _WIN64
                " %4s %5s %18I64d %18I64d  %16I64d %14I64d     %12I64d\n",
#else
                " %4s %5s %9ld %9ld  %8ld %7ld     %6ld\n",
#endif
                OutBuffer[x].Tag,
                PoolType[OutBuffer[x].Type],
                OutBuffer[x].Allocs,
                OutBuffer[x].Frees,
                OutBuffer[x].Allocs_Frees,
                OutBuffer[x].Used,
                OutBuffer[x].Each
               );
    }


    // close file
    fclose(LogFile);

    return 0;
}

// comparison function for qsort 
// Tags are big endian

int __cdecl ulcomp(const void *e1,const void *e2)
{
    ULONG u1;

    u1 = ((PUCHAR)e1)[0] - ((PUCHAR)e2)[0];
    if (u1 != 0) {
        return u1;
    }
    u1 = ((PUCHAR)e1)[1] - ((PUCHAR)e2)[1];
    if (u1 != 0) {
        return u1;
    }
    u1 = ((PUCHAR)e1)[2] - ((PUCHAR)e2)[2];
    if (u1 != 0) {
        return u1;
    }
    u1 = ((PUCHAR)e1)[3] - ((PUCHAR)e2)[3];
    return u1;

}


/*
 * FUNCTION:
 *
 *      QueryPoolTagInformationIterative
 *
 * ARGUMENTS: 
 *
 *      CurrentBuffer - a pointer to the buffer currently used for 
 *                      NtQuerySystemInformation( SystemPoolTagInformation ).
 *                      It will be allocated if NULL or its size grown 
 *                      if necessary.
 *
 *      CurrentBufferSize - a pointer to a variable that holds the current 
 *                      size of the buffer. 
 *                      
 *
 * RETURNS: 
 *
 *      NTSTATUS returned by NtQuerySystemInformation or 
 *      STATUS_INSUFFICIENT_RESOURCES if the buffer must grow and the
 *      heap allocation for it fails.
 *
 */

NTSTATUS
QueryPoolTagInformationIterative(
    PUCHAR *CurrentBuffer,
    size_t *CurrentBufferSize
    )
{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        //
        // there is no buffer allocated yet
        //

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;
        
        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            free( *CurrentBuffer );
            
            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\memsnap\tags.c ===
// tags.c

typedef struct TagList {
    struct TagList* Next;
    CHAR* pszValue;
    DWORD dwValue1;
    DWORD dwValue2;
    CHAR* pszTagName;
} TAGLIST;

TAGLIST* TagHead=NULL;

//
// AddTag - add tag to end of global list
//

VOID AddTag( TAGLIST* pTag )
{
    TAGLIST* pTag1;
    TAGLIST* pTagPrev;

    //
    // place new tag at end of list
    //

    pTag1= TagHead;
    pTagPrev= NULL;

    while( pTag1 ) {
       pTagPrev= pTag1;
       pTag1= pTag1->Next;
    }

    if( pTagPrev) {
        pTagPrev->Next= pTag;
    }
    else {
        TagHead= pTag;
    }

}

// GetLocalString
//
// Allocate a heap block and copy string into it.
//
// return: pointer to heap block
//

CHAR* GetLocalString( CHAR* pszString )
{
   INT len;
   CHAR* pszTemp;

   len= strlen( pszString ) + 1;

   pszTemp= (CHAR*) LocalAlloc( LPTR, len );

   if( !pszTemp ) return NULL;

   strcpy( pszTemp, pszString );

   return( pszTemp );

}

//
// CreateTag - Create tag
//
//

TAGLIST* CreateTag( CHAR* pszTagName, CHAR* pszTagValue )
{
    TAGLIST* pTag;

    pTag= (TAGLIST*) LocalAlloc( LPTR, sizeof(TAGLIST) );
    if( !pTag ) {
        return( NULL );
    }

    pTag->pszTagName= GetLocalString(pszTagName);

    if( !pTag->pszTagName ) {
       LocalFree( pTag );
       return( NULL );
    }

    pTag->pszValue= (CHAR*) GetLocalString(pszTagValue);
    if( !pTag->pszValue ) {
        LocalFree( pTag->pszTagName );
        LocalFree( pTag );
        return( NULL );
    }

    return( pTag );
}


// OutputTags
//
// Output tags, but do some processing on some we know about.
//

VOID OutputTags( FILE* OutFile )
{
    TAGLIST* pTagList;
    CHAR* pszFirstComputerName= NULL;
    DWORD dwMinTime=0;
    DWORD dwMaxTime=0;
    DWORD dwBuildNumber=0;
    BOOL  bErrorComputerName= FALSE;      // true if more than 1 computer name
    BOOL  bErrorTickCount= FALSE;
    BOOL  bErrorBuildNumber= FALSE;

    pTagList= TagHead;

    while( pTagList ) {
        CHAR* pszTagName= pTagList->pszTagName;

        if( _stricmp(pszTagName,"computername") == 0 ) {
            if( pszFirstComputerName==NULL ) {
                pszFirstComputerName= pTagList->pszValue;
            }
            else {
                if( _stricmp(pszFirstComputerName, pTagList->pszValue) != 0 ) {
                    if( !bErrorComputerName ) {
                        fprintf(stderr,"Two different computer names in log file\n");
                        fprintf(OutFile,"!error=Two different computer names in log file.\n");
                        bErrorComputerName= TRUE;
                    }
                }
            }
        }

        else if( _stricmp(pszTagName,"tickcount") == 0 ) {
            DWORD dwValue= atol( pTagList->pszValue );

            if( dwMinTime==0 ) {
                dwMinTime= dwValue;
            }
            if( ( dwValue < dwMinTime ) || ( dwMaxTime > dwValue )  ) {
                if( !bErrorTickCount ) {
                    fprintf(stderr,"TickCount did not always increase\n");
                    fprintf(stderr,"  Did you reboot and use the same log file?\n");
                    fprintf(OutFile,"!error=TickCount did not always increase\n");
                    fprintf(OutFile,"!error=Did you reboot and use same log file?\n");
                    bErrorTickCount= TRUE;
                }
            }
            dwMaxTime= dwValue;
        }

        else if( _stricmp(pszTagName,"buildnumber") == 0 ) {
            DWORD dwValue= atol( pTagList->pszValue );

            if( dwBuildNumber && (dwBuildNumber!=dwValue) ) {
                if( !bErrorBuildNumber ) {
                    fprintf(stderr,"Build number not always the same.\n");
                    fprintf(stderr,"  Did you reboot and use the same log file?\n");
                    fprintf(OutFile,"!error=Build number not always the same.\n");
                    fprintf(OutFile,"!error=Did you reboot and use same log file?\n");
                    bErrorBuildNumber= TRUE;
                }
            }
            else {
                dwBuildNumber= dwValue;
            }
        }


        // if we don't know about it, just write it out

        else {
            fprintf(OutFile,"!%s=%s\n",pszTagName,pTagList->pszValue);
        }

        pTagList= pTagList->Next;
    }

    fprintf(OutFile,"!ComputerName=%s\n",pszFirstComputerName);
    fprintf(OutFile,"!BuildNumber=%d\n", dwBuildNumber);
    fprintf(OutFile,"!ElapseTickCount=%u\n",dwMaxTime-dwMinTime);

}

// ProcessTag
//
//

VOID ProcessTag( CHAR* inBuff )
{
    CHAR* pszTagName;
    CHAR* pszEqual;
    CHAR* pszTagValue;
    TAGLIST* pTag;


    pszTagName= inBuff;
    for( pszEqual= inBuff; *pszEqual; pszEqual++ ) {
        if( *pszEqual == '=' )
            break;
    }

    if( *pszEqual==0 ) {
        return;
    }
    *pszEqual=  0;   // null terminate the name
    pszTagValue= pszEqual+1;      // point to value

    if( *pszTagValue == 0 ) {
        return;
    }


    pTag= CreateTag( pszTagName, pszTagValue );

    if( pTag ) {
        AddTag( pTag );
    }

}

VOID OutputStdTags( FILE* LogFile, CHAR* szLogType )
{
    BOOL bSta;
    CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize;
    DWORD TickCount;
    SYSTEMTIME SystemTime;
    OSVERSIONINFO osVer;

    fprintf(LogFile,"!LogType=%s\n",szLogType);

    // ComputerName

    dwSize= sizeof(szComputerName);
    bSta= GetComputerName( szComputerName, &dwSize );

    if( bSta ) {
        fprintf(LogFile,"!ComputerName=%s\n",szComputerName);
    }

    // Build Number

    osVer.dwOSVersionInfoSize= sizeof(osVer);
    if( GetVersionEx( &osVer ) ) {
        fprintf(LogFile,"!buildnumber=%d\n",osVer.dwBuildNumber);
    }

    // Debug/Retail build

    if( GetSystemMetrics(SM_DEBUG) ) {
        fprintf(LogFile,"!buildtype=debug\n");
    }
    else {
        fprintf(LogFile,"!buildtype=retail\n");
    }


    // CSD information

    if( osVer.szCSDVersion && strlen(osVer.szCSDVersion) ) {
        fprintf(LogFile,"!CSDVersion=%s\n",osVer.szCSDVersion);
    }

    // SystemTime (UTC not local time)

    GetSystemTime(&SystemTime);
                
    fprintf(LogFile,"!SystemTime=%02i\\%02i\\%04i %02i:%02i:%02i.%04i (GMT)\n",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond,
                SystemTime.wMilliseconds);

    // TickCount

    TickCount= GetTickCount();

    fprintf(LogFile,"!TickCount=%u\n",TickCount);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\calltree.c ===
//
// calltree.c
//
// two routines for printing out ascii call tree's
//
#include <stdio.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>


#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// forward declarations
static BOOL FUsedInst(IINST iinst);
static VOID dCallTree(IINST iinst, WORD cuse);


// static variables
static BYTE *UseBits = NULL;
static WORD cNest = 0;

VOID BSC_API
CallTreeInst (IINST iinst)
// emit the call tree starting from the given inst
//
{
    WORD iinstMac;
    int igrp;

    iinstMac = IinstMac();

    // allocate memory for bit array
    UseBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

    // no memory -- no call tree
    if (!UseBits) return;

    igrp = iinstMac/8+1;

    while (--igrp>=0)
	UseBits[igrp] = 0;

    cNest = 0;

    dCallTree(iinst, 1);

    FreeLpv(UseBits);
}


static VOID 
dCallTree (IINST iinst, WORD cuse)
// emit the call tree starting from the given inst
//
// there are many block variables to keep the stack to a minimum...
{
    {
	ISYM isym;

	{
		TYP typ;
		ATR atr;

	    InstInfo(iinst, &isym, &typ, &atr);

	    if (typ > INST_TYP_LABEL)
		return;
	}

	    
	{
	    WORD i;
	    cNest++;
	    for (i = cNest; i; i--) BSCPrintf ("| ");
	}

	if (cuse > 1)
	    BSCPrintf ("%s[%d]", LszNameFrSym (isym), cuse);
	else
	    BSCPrintf ("%s", LszNameFrSym (isym));
    }

    {
	IDEF idef, idefMac;
	LSZ  lsz;
	WORD w;

	DefRangeOfInst(iinst, &idef, &idefMac);
	DefInfo(idef, &lsz, &w);

        if (strcmp("<Unknown>", lsz) == 0) {
	    BSCPrintf ("?\n");
	    cNest--;
	    return;
	}
    }

    if (FUsedInst(iinst)) {
	BSCPrintf ("...\n");
	cNest--;
	return;
    }
	
    BSCPrintf ("\n");

    {
	IUSE iuse, iuseMac;
	IINST iinstUse;

	UseRangeOfInst(iinst, &iuse, &iuseMac);

	for (; iuse < iuseMac; iuse++) {
	    UseInfo(iuse, &iinstUse, &cuse);
	    dCallTree (iinstUse, cuse);
	}
    }

    cNest--;
}

BOOL BSC_API
FCallTreeLsz(LSZ lszName)
// print out a call tree based on the given name
//
{
    IMOD imod;
    ISYM isym;

    cNest = 0;

    if (!lszName)
	return FALSE;

    {
	IINST iinstMac;
	int  igrp;

	iinstMac = IinstMac();

	// allocate memory for bit array
        UseBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

	// no memory -- no call tree
	if (!UseBits) return FALSE;

	igrp = iinstMac/8+1;

	while (--igrp >= 0)
	    UseBits[igrp] = 0;
    }

    if ((imod = ImodFrLsz (lszName)) != imodNil) {
	IMS ims, imsMac;

	MsRangeOfMod(imod, &ims, &imsMac);

	BSCPrintf ("%s\n", LszNameFrMod (imod));

	for ( ; ims < imsMac ; ims++)
	    dCallTree (IinstOfIms(ims), 1);
	
    	FreeLpv(UseBits);
	return TRUE;
    }

    if ((isym = IsymFrLsz (lszName)) != isymNil) {
	IINST iinst, iinstMac;

	BSCPrintf ("%s\n", LszNameFrSym (isym));

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for (; iinst < iinstMac; iinst++)
	    dCallTree (iinst, 1);
	
	FreeLpv(UseBits);
	return TRUE;
    }

    FreeLpv(UseBits);
    return FALSE;
}

static BOOL
FUsedInst(IINST iinst)
// return the status bit for this iinst and set it true
//
{
    WORD igrp;
    BOOL fOut;
    WORD mask;

    igrp = iinst / 8;
    mask = (1 << (iinst % 8));

    fOut = !!(UseBits[igrp] & mask);
    UseBits[igrp] |= mask;
    return fOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\bscdump.c ===
// 
//
//  DumpBSC   - Dump Source Data Base.
//		Walk the symbol tree dumping stuff.
//
#include <string.h>
#include <stdio.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

VOID BSC_API
DumpBSC()
// Dump the contents of the .BSC file to the Output Function
//
{
    IMOD  imod,  imodMac;
    IMS   ims,   imsMac;
    ISYM  isym,  isymMac, isymT;
    IINST iinst, iinstMac, iinstT;
    IDEF  idef,  idefMac;
    IREF  iref,  irefMac;
    IUSE  iuse,  iuseMac;
    IUBY  iuby,  iubyMac;
    WORD  wLine, cnt;
    LSZ	  lsz;

    imodMac = ImodMac();

    BSCPrintf("Modules:\n\n");

    for (imod = 0; imod < imodMac; imod++) {
	BSCPrintf("%s\n", LszNameFrMod(imod));

	MsRangeOfMod(imod, &ims, &imsMac);

	for ( ;ims < imsMac; ims++) {
	    BSCPrintf("\t  contains  ");
	    DumpInst(IinstOfIms(ims));
	    BSCPrintf("\n");
	}
    }

    isymMac = IsymMac();

    BSCPrintf("\nSymbols:\n\n");

    for (isym = 0; isym < isymMac; isym++) {

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for ( ;iinst < iinstMac; iinst++) {
		TYP typ;
		ATR atr;

	    DumpInst(iinst);
	    BSCPrintf("\n");

	    InstInfo(iinst, &isymT, &typ, &atr);

	    if  (isym != isymT)
		BSCPrintf("\t  ERROR instance points back to wrong symbol!\n");

	    DefRangeOfInst(iinst, &idef, &idefMac);
	    for (; idef < idefMac; idef++) {
		DefInfo(idef, &lsz, &wLine);
		BSCPrintf ("\t  def'd   %s(%d)\n", lsz, wLine);
	    }

	    RefRangeOfInst(iinst, &iref, &irefMac);
	    for (; iref < irefMac; iref++) {
		RefInfo(iref, &lsz, &wLine);
		BSCPrintf ("\t  ref'd   %s(%d)\n", lsz, wLine);
	    }

	    UseRangeOfInst(iinst, &iuse, &iuseMac);
	    for (; iuse < iuseMac; iuse++) {
		BSCPrintf ("\t  uses    ");

		UseInfo(iuse, &iinstT, &cnt);
		DumpInst(iinstT);
		if (cnt > 1) BSCPrintf("[%d]", cnt);
		BSCPrintf ("\n");
	    }

	    UbyRangeOfInst(iinst, &iuby, &iubyMac);
	    for (; iuby < iubyMac; iuby++) {
		BSCPrintf ("\t  used-by ");

		UbyInfo(iuby, &iinstT, &cnt);
		DumpInst(iinstT);
		if (cnt > 1) BSCPrintf("[%d]", cnt);
		BSCPrintf ("\n");
	    }

	    BSCPrintf("\n");
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\dump.c ===
// 
// support for instance dumping
//
#include <string.h>
#include <stdio.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

char *ptyptab[] = {
      "undef",		    			// SBR_TYP_UNKNOWN
      "function",	    			// SBR_TYP_FUNCTION
      "label",		 			// SBR_TYP_LABEL
      "parameter",	    			// SBR_TYP_PARAMETER
      "variable",	    			// SBR_TYP_VARIABLE
      "constant",	    			// SBR_TYP_CONSTANT
      "macro",		    			// SBR_TYP_MACRO
      "typedef",	    			// SBR_TYP_TYPEDEF
      "strucnam",	    			// SBR_TYP_STRUCNAM
      "enumnam",	    			// SBR_TYP_ENUMNAM
      "enummem",	    			// SBR_TYP_ENUMMEM
      "unionnam",	    			// SBR_TYP_UNIONNAM
      "segment",	    			// SBR_TYP_SEGMENT   
      "group",		    			// SBR_TYP_GROUP
      "program"					// SBR_TYP_PROGRAM
};

#define C_ATR 11

char	*patrtab[] = {
      "local",		    			// SBR_ATR_LOCAL
      "static", 	    			// SBR_ATR_STATIC
      "shared", 	    			// SBR_ATR_SHARED	
      "near",		    			// SBR_ATR_NEAR     
      "common", 	    			// SBR_ATR_COMMON	
      "decl_only", 	    			// SBR_ATR_DECL_ONLY
      "public",		    			// SBR_ATR_PUBLIC	
      "named",		    			// SBR_ATR_NAMED
      "module",		    			// SBR_ATR_MODULE
      "?", "?"		    			// reserved for expansion
};

VOID BSC_API
DumpInst(IINST iinst)
// dump a single instance
{
     ISYM isym;
     WORD i;
     LSZ  lsz;
     WORD len;
     TYP typ;
     ATR atr;

     len = BSCMaxSymLen();

     InstInfo(iinst, &isym, &typ, &atr);

     lsz = LszNameFrSym(isym);

     BSCPrintf("%s", lsz);

     for (i = strlen(lsz); i < len; i++)
	BSCPrintf(" ");

     BSCPrintf(" (%s", ptyptab[typ]);

     for (i=0; i < C_ATR; i++)
	  if (atr & (1<<i)) BSCPrintf (":%s", patrtab[i]);

     BSCPrintf(")");
}

LSZ BSC_API
LszTypInst(IINST iinst)
// return the type string of a single inst
//
{
    ISYM isym;
    TYP typ;
    ATR atr;

    InstInfo(iinst, &isym, &typ, &atr);
    return ptyptab[typ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\filter.c ===
// filter.c
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

BOOL BSC_API
FInstFilter (IINST iinst, MBF mbf)
// return true if the given inst has the required properties
//
{
    ISYM isym;
    TYP typ;
    ATR atr;
    
    InstInfo(iinst, &isym, &typ, &atr);

    if (typ <= INST_TYP_LABEL)
	 return !!(mbf & mbfFuncs);

    if (typ <= INST_TYP_VARIABLE || typ >= INST_TYP_SEGMENT)
	 return !!(mbf & mbfVars);

    if (typ <= INST_TYP_MACRO)
	 return !!(mbf & mbfMacros);

    return !!(mbf & mbfTypes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\outline.c ===
//
// outline.c
//
// these are the file outline routines
//
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// forward ref

VOID BSC_API
OutlineMod(IMOD imod, MBF mbf)
// print the outline for this module
//
{
    IMS ims, imsMac;
    IINST iinst;

    BSCPrintf("\n%s\n", LszNameFrMod(imod));

    MsRangeOfMod(imod, &ims, &imsMac);
    for ( ;ims < imsMac; ims++) {
	iinst = IinstOfIms(ims);

	if (FInstFilter (iinst, mbf)) {
	    BSCPrintf("  ");
	    DumpInst(iinst);
	    BSCPrintf("\n");
	    }
    }
}

BOOL BSC_API
FOutlineModuleLsz (LSZ lszName, MBF mbf)
// generate an outline for all files matching the given name/pattern
// showing only those items which match the required attribute
//
{
    IMOD imod, imodMac;
    BOOL fRet = FALSE;

    if (!lszName) 
	return FALSE;

    imodMac = ImodMac();

    // we match base names only

    lszName = LszBaseName(lszName);
    for (imod = 0; imod < imodMac; imod++) {
	if (FWildMatch(lszName, LszBaseName(LszNameFrMod(imod)))) {
	    OutlineMod (imod, mbf);
	    fRet = TRUE;
	}
    }

    return fRet;
}

LSZ BSC_API
LszBaseName (LSZ lsz)
// return the base name part of a path
//
{
     LSZ lszBase;

     // check for empty string

     if (!lsz || !lsz[0]) return lsz;

     // remove drive

     if (lsz[1] == ':') lsz += 2;

     // remove up to trailing backslash

     if (lszBase = strrchr(lsz, '\\')) lsz = lszBase+1;

     // then remove up to trailing slash

     if (lszBase = strrchr(lsz, '/'))  lsz = lszBase+1;

     return lsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\printf.c ===
//
// printf.c
//
// simple minded printf replacement
//
// only supports %s and %d but it is *small*
//
#include <string.h>
#include <io.h>
#include <stdlib.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

static char lpchBuf[1024];
static LPCH lpchPos = NULL;

VOID BSC_API
BSCPrintf(LSZ lszFormat, ...)
// printf replacement
//
{
    va_list va;
    LPCH lpch;
    char ch;

    if (!lpchPos) {
	lpchPos = lpchBuf;
    }

    va_start(va, lszFormat);

    BSCFormat(lpchPos, lszFormat, va);

    // write out a line at a time
    // 
    for (;;) {
        lpch = strchr(lpchPos, '\n');
	if (!lpch) {
            lpchPos += strlen(lpchPos);
	    return;
	}

        ch = *++lpch;
	*lpch = 0;
	BSCOutput(lpchBuf);
	*lpch = ch;
        strcpy(lpchBuf, lpch);
	if (!ch)
	    lpchPos = lpchBuf;
	else
            lpchPos = lpchBuf + strlen(lpchBuf);
    }
}

#ifdef DEBUG

static char lpchDBuf[256];
static LPCH lpchDPos = NULL;

VOID BSC_API
BSCDebug(LSZ lszFormat, ...)
// printf clone for debug output
//
{
    va_list va;
    LPCH lpch;
    char ch;

    if (!lpchDPos) {
	lpchDPos = lpchDBuf;
    }

    va_start(va, lszFormat);

    BSCFormat(lpchDPos, lszFormat, va);

    // write out a line at a time
    // 
    for (;;) {
        lpch = strchr(lpchDPos, '\n');
	if (!lpch) {
            lpchDPos += strlen(lpchDPos);
	    return;
	}

        ch = *++lpch;
	*lpch = 0;
	BSCDebugOut(lpchDBuf);
	*lpch = ch;
        strcpy(lpchDBuf, lpch);
	if (!ch)
	    lpchDPos = lpchDBuf;
	else
            lpchDPos = lpchDBuf + strlen(lpchDBuf);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\format.c ===
//
// format.c
//
// simple minded printf replacement
//
// only supports %s and %d but it is *small*
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

VOID static near pascal _ultoa(DWORD, LSZ);

VOID BSC_API
BSCFormat(LPCH lpchOut, LSZ lszFormat, va_list va)
// format to lpchOut as specified byh format
//
// this is a very simple minded formatter
{
    LPCH lpch;
    WORD i;
    DWORD l;

    lpch = lpchOut;

    while (*lszFormat) {
	if (*lszFormat == '%') {
	    switch (lszFormat[1]) {

	    case '%':
		*lpch++ = '%';
		break;

	    case 's':
                strcpy(lpch, va_arg(va, LSZ));
                lpch += strlen(lpch);
		break;

	    case 'd':
		i = va_arg(va, WORD);
		_ultoa((DWORD)i, lpch);
                lpch += strlen(lpch);
		break;
		
	    case 'l':
		l = va_arg(va, DWORD);
		_ultoa(l, lpch);
                lpch += strlen(lpch);
		break;

	    default:
		lpch[0] = '%';
		lpch[1] = lszFormat[1];
		lpch  += 2;
		break;
	    }
	    lszFormat += 2;
	}
	else
	    *lpch++ = *lszFormat++;
    }
    *lpch = 0;
}

VOID BSC_API
BSCSprintf(LPCH lpchOut, LSZ lszFormat, ...)
// sprintf replacement
//
{
    va_list va;

    va_start(va, lszFormat);

    BSCFormat(lpchOut, lszFormat, va);
}

static DWORD pow10[8] = {
		10L, 100L, 1000L, 10000L,
		100000L , 1000000L, 10000000L, 100000000L
		};

VOID static near pascal
_ultoa(DWORD dw, LSZ lsz)
{
	int log;

	for (log = 0; log < 8; log++)
		if (dw < pow10[log])
			break;

	lsz[++log] = 0;

	while (--log >= 0) {
		lsz[log] = (char)(((int)(dw%10)) + '0');
		dw/=10;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\listref.c ===
// listref.c
//
// list database references
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

#include <stdlib.h>

// forward references
//
static VOID ListRefSym (ISYM isym, MBF mbf);
static VOID ListRefUse (IINST iinst, WORD icol, WORD cuse);
static VOID PutLine(VOID);
static VOID ListRefTitle(LSZ lszType, LSZ lszUsers, MBF mbf);

// static variables
//
static WORD MaxSymLen;
static LPCH bufg;


BOOL BSC_API
ListRefs (MBF mbfReqd)
// scan the database for items which would match the requirements
// and emit their uses and used by lists
//
{
    static char szFunction[] = "FUNCTION";
    static char szVariable[] = "VARIABLE";
    static char szType[]     = "TYPE";
    static char szMacro[]    = "MACRO";
    static char szCalledBy[] = "CALLED BY LIST";
    static char szUsedBy[]   = "USED BY LIST";

    bufg = LpvAllocCb(1024);

    // no memory.. no reference list
    if (!bufg) return FALSE;

    MaxSymLen = BSCMaxSymLen();

    if (mbfReqd & mbfFuncs)  ListRefTitle(szFunction, szCalledBy, mbfFuncs);
    if (mbfReqd & mbfVars)   ListRefTitle(szVariable, szUsedBy,   mbfVars);
    if (mbfReqd & mbfMacros) ListRefTitle(szMacro,    szUsedBy,   mbfMacros);
    if (mbfReqd & mbfTypes)  ListRefTitle(szType,     szUsedBy,   mbfTypes);

    FreeLpv(bufg);
    return TRUE;
}

static VOID
ListRefTitle(LSZ lszType, LSZ lszUsers, MBF mbf)
// format a title
//
{
    WORD i,l;
    ISYM isym, isymMac;

    isymMac = IsymMac();

    // format titles
    //

    strcpy (bufg, lszType);
    for (i=strlen(bufg); i < MaxSymLen+5; i++) bufg[i] = ' ';
    strcpy (bufg+i, lszUsers);
    PutLine();

    //  underscore titles
    //
    l = strlen(lszType);
    for (i=0; i<l; i++)		 bufg[i] = '-';
    for (; i < MaxSymLen+5; i++) bufg[i] = ' ';
    l = i + strlen(lszUsers);
    for (; i<l; i++)		 bufg[i] = '-';
    bufg[i] = 0;
    PutLine();

    for (isym = 0; isym < isymMac; isym++)
	ListRefSym (isym, mbf);

    strcpy (bufg, " ");
    PutLine();
}

static VOID
ListRefSym (ISYM isym, MBF mbf)
// list all the references associated with this symbol
{
    IINST iinst, iinstMac, iinstUby;
    IUBY  iuby, iubyMac;
    WORD csym;
    WORD icol = MaxSymLen+5;
    WORD maxcol = 80 / (MaxSymLen+5)-1;
    WORD cnt;

    InstRangeOfSym(isym, &iinst, &iinstMac);

    for ( ;iinst < iinstMac ; iinst++) {

	if (!FInstFilter (iinst, mbf))
	    continue;

	csym = 0;
        strcpy (bufg, "   ");
        strcat (bufg, LszNameFrSym(isym));
        strcat (bufg, ": ");

	UbyRangeOfInst(iinst, &iuby, &iubyMac);

	for ( ;iuby < iubyMac; iuby++) {
	    if (++csym > maxcol) {
		csym = 1;
		PutLine();
	    }

	    UbyInfo(iuby, &iinstUby, &cnt);
            ListRefUse (iinstUby, (WORD)(csym*icol), cnt);
	}
    }
    if (bufg[0]) PutLine();
}

static VOID
ListRefUse (IINST iinst, WORD icol, WORD cuse)
// dump information about the given prop in the location provided
//
{
    WORD i, len;
    ISYM isym;
    BOOL fVar;
    TYP typ;
    ATR atr;
    LSZ lsz;

    InstInfo(iinst, &isym, &typ, &atr);

    fVar = (typ > INST_TYP_LABEL);

    len = strlen(bufg);

    lsz = LszNameFrSym(isym);

    for (i=len; i<icol; i++) bufg[i] = ' ';

    bufg[icol] = 0;

    if (fVar) {
	if (cuse > 1)
            BSCSprintf(bufg+icol, "(%s)[%d]  ", lsz, cuse);
	else
            BSCSprintf(bufg+icol, "(%s)  ", lsz);
    }
    else {
	if (cuse > 1)
            BSCSprintf(bufg+icol, "%s[%d]  ", lsz, cuse);
	else
            BSCSprintf(bufg+icol, "%s  ", lsz);
    }
}

static VOID
PutLine()
// write out a single line from the buffer
{
    BSCPrintf("%s\n", bufg);
    *bufg = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\query.c ===
//
// query.c
//
// perform database queries
//
#include <stddef.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// these keep track of the current query, they are globally visible so
// that users can see how the query is progressing
//
// you may not write on these

IDX far idxQyStart;
IDX far idxQyCur;
IDX far idxQyMac;

// this is auxilliary information about the current bob which some
// queries may choose to make available
//

static BOOL fWorking;
static LSZ lszModLast = NULL;	// for removing duplicate modules

// prototypes for the query worker functions
//

static BOB BobQyFiles(VOID);
static BOB BobQySymbols (VOID);
static BOB BobQyContains (VOID);
static BOB BobQyCalls (VOID);
static BOB BobQyCalledBy (VOID);
static BOB BobQyUses (VOID);
static BOB BobQyUsedBy (VOID);
static BOB BobQyUsedIn (VOID);
static BOB BobQyDefinedIn(VOID);
static BOB BobQyRefs(VOID);
static BOB BobQyDefs(VOID);

// current bob worker function
static BOB (*bobFn)(VOID) = NULL;

BOOL BSC_API
InitBSCQuery (QY qy, BOB bob)
// do the request query on the given bob
//
{
    fWorking = FALSE;

    if (lszModLast == NULL)
	lszModLast = LpvAllocCb(1024);	// REVIEW -- how much to alloc? [rm]

    // no memory -- no query
    if (lszModLast == NULL)
	return FALSE;

    strcpy(lszModLast, "");

    switch (qy) {

    case qyFiles:
	bobFn	   = BobQyFiles;
	idxQyStart = (IDX)0;
	idxQyMac   = (IDX)ImodMac();
	break;

    case qySymbols:
	bobFn	   = BobQySymbols;
	idxQyStart = (IDX)0;
	idxQyMac   = (IDX)IinstMac();
	break;

    case qyContains:
	{
	IMS ims, imsMac;

	bobFn	   = BobQyContains;

	if (ClsOfBob(bob) != clsMod) return FALSE;
	MsRangeOfMod(ImodFrBob(bob), &ims, &imsMac);

	idxQyStart = (IDX)ims;
	idxQyMac   = (IDX)imsMac;

	break;
	}

    case qyCalls:
	{
	IUSE iuse, iuseMac;

	bobFn	   = BobQyCalls;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UseRangeOfInst(IinstFrBob(bob), &iuse, &iuseMac);

	idxQyStart = (IDX)iuse;
	idxQyMac   = (IDX)iuseMac;

	break;
	}

    case qyUses:
	{
	IUSE iuse, iuseMac;

	bobFn	   = BobQyUses;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UseRangeOfInst(IinstFrBob(bob), &iuse, &iuseMac);

	idxQyStart = (IDX)iuse;
	idxQyMac   = (IDX)iuseMac;

	break;
	}

    case qyCalledBy:
	{
	IUBY iuby, iubyMac;

	bobFn	   = BobQyCalledBy;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UbyRangeOfInst(IinstFrBob(bob), &iuby, &iubyMac);

	idxQyStart = (IDX)iuby;
	idxQyMac   = (IDX)iubyMac;

	break;
	}

    case qyUsedBy:
	{
	IUBY iuby, iubyMac;

	bobFn	   = BobQyUsedBy;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UbyRangeOfInst(IinstFrBob(bob), &iuby, &iubyMac);

	idxQyStart = (IDX)iuby;
	idxQyMac   = (IDX)iubyMac;

	break;
	}

    case qyUsedIn:
	{
	IREF iref, irefMac;

	bobFn	   = BobQyUsedIn;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	RefRangeOfInst(IinstFrBob(bob), &iref, &irefMac);

	idxQyStart = (IDX)iref;
	idxQyMac   = (IDX)irefMac;

	break;
	}

    case qyDefinedIn:
	{
	IDEF idef, idefMac;

	bobFn	   = BobQyDefinedIn;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	DefRangeOfInst(IinstFrBob(bob), &idef, &idefMac);

	idxQyStart = (IDX)idef;
	idxQyMac   = (IDX)idefMac;

	break;
	}

    case qyRefs:
	{
	IINST iinst, iinstMac;

	bobFn	   = BobQyRefs;

	switch (ClsOfBob(bob)) {

	default:
	    return FALSE;

	case clsSym:
	    InstRangeOfSym(IsymFrBob(bob), &iinst, &iinstMac);

	    idxQyStart = (IDX)iinst;
	    idxQyMac   = (IDX)iinstMac;
	    break;

	case clsInst:
	    idxQyStart = (IDX)IinstFrBob(bob);
	    idxQyMac   = idxQyStart+1;
	    break;
	}

	break;
	}

    case qyDefs:
	{
	IINST iinst, iinstMac;

	bobFn	   = BobQyDefs;

	switch (ClsOfBob(bob)) {

	default:
	    return FALSE;

	case clsSym:
	    InstRangeOfSym(IsymFrBob(bob), &iinst, &iinstMac);

	    idxQyStart = (IDX)iinst;
	    idxQyMac   = (IDX)iinstMac;
	    break;

	case clsInst:
	    idxQyStart = (IDX)IinstFrBob(bob);
	    idxQyMac   = idxQyStart+1;
	    break;
	}

	break;
	}
    }

    idxQyCur   = idxQyStart;
    return TRUE;
}

BOB BSC_API
BobNext()
// return the next Bob in the query
{
    if (idxQyCur < idxQyMac && bobFn != NULL)
	return (*bobFn)();

    return bobNil;
}

static BOB
BobQyFiles()
// return the next File in a file query
//
{
    BOB bob;

    while (idxQyCur < idxQyMac) {
	IMS ims1, ims2;

	MsRangeOfMod((IMOD)idxQyCur, &ims1, &ims2);
	if (ims1 != ims2) {
	    bob = BobFrClsIdx(clsMod, idxQyCur);
	    idxQyCur++;
	    return bob;
	}
	else
	    idxQyCur++;
    }
    return bobNil;
}

static BOB
BobQySymbols ()
// get the next symbol in a symbol query
//
{
    BOB bob;

    bob = BobFrClsIdx(clsInst, idxQyCur);
    idxQyCur++;
    return bob;
}

static BOB
BobQyContains ()
// get the next symbol in a contains query
//
{
    BOB bob;

    bob = BobFrClsIdx(clsInst, IinstOfIms((IMS)idxQyCur));
    idxQyCur++;
    return bob;
}

static BOB
BobQyCalls ()
// get the next symbol which query focus calls
//
{
    WORD cuse;
    IINST iinst;
    ISYM  isym;
    TYP typ;
    ATR atr;
    BOB bob;
	
    for (; idxQyCur < idxQyMac; idxQyCur++) {

	UseInfo((IUSE)idxQyCur, &iinst, &cuse);
	InstInfo(iinst, &isym, &typ, &atr);

	if (typ > INST_TYP_LABEL)
	    continue;

	bob = BobFrClsIdx(clsInst, iinst);
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

static BOB
BobQyCalledBy ()
// get the next symbol which query focus is called by
//
{
    WORD cuse;
    IINST iinst;
    ISYM  isym;
    TYP typ;
    ATR atr;
    BOB bob;
	
    for (; idxQyCur < idxQyMac; idxQyCur++) {

	UbyInfo((IUBY)idxQyCur, &iinst, &cuse);
	InstInfo(iinst, &isym, &typ, &atr);

	if (typ > INST_TYP_LABEL)
	    continue;

	bob = BobFrClsIdx(clsInst, iinst);
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

static BOB
BobQyUses ()
// get the next symbol which query focus calls
//
{
    WORD cuse;
    IINST iinst;
    BOB bob;
	
    UseInfo((IUSE)idxQyCur, &iinst, &cuse);
    bob = BobFrClsIdx(clsInst, iinst);
    idxQyCur++;
    return bob;
}

static BOB
BobQyUsedBy ()
// get the next symbol which query focus calls
//
{
    WORD cuse;
    IINST iinst;
    BOB bob;
	
    UbyInfo((IUBY)idxQyCur, &iinst, &cuse);
    bob = BobFrClsIdx(clsInst, iinst);
    idxQyCur++;
    return bob;
}

static BOB
BobQyUsedIn ()
// get the next module which query focus is used in
//
{
    WORD wLine;
    BOB  bob;
    LSZ  lszMod;

    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {
	RefInfo((IREF)idxQyCur, &lszMod, &wLine);
	
        if (strcmp(lszMod, lszModLast) == 0)
	    continue;

        strcpy(lszModLast, lszMod);

	bob = BobFrClsIdx(clsMod, ImodFrLsz(lszMod));
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

static BOB
BobQyDefinedIn ()
// get the next module which query focus is defined in
//
{
    WORD wLine;
    LSZ  lszMod;
    BOB  bob;

    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {
	DefInfo((IDEF)idxQyCur, &lszMod, &wLine);
	
        if (strcmp(lszMod, lszModLast) == 0)
	    continue;

        strcpy(lszModLast, lszMod);

	bob = BobFrClsIdx(clsMod, ImodFrLsz(lszMod));
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

LSZ BSC_API
LszNameFrBob(BOB bob)
// return the name of the given bob
//
{
    switch (ClsOfBob(bob)) {

    case clsMod:
	return LszNameFrMod(ImodFrBob(bob));

    case clsSym:
	return LszNameFrSym(IsymFrBob(bob));

    case clsInst:
	{
	ISYM isym;
	TYP typ;
	ATR atr;

	InstInfo(IinstFrBob(bob), &isym, &typ, &atr);
	return LszNameFrSym(isym);
	}

    case clsRef:
	{
	LSZ lsz;
	WORD wLine;

	RefInfo(IrefFrBob(bob), &lsz, &wLine);
	return lsz;
	}

    case clsDef:
	{
	LSZ lsz;
	WORD wLine;

	DefInfo(IdefFrBob(bob), &lsz, &wLine);
	return lsz;
	}

    default:
	return "?";
    }
}

BOB BSC_API
BobFrName(LSZ lszName)
// return the best bob we can find from the given name
//
{
    ISYM isym;
    IMOD imod, imodMac;
    IINST iinst, iinstMac;

    if ((isym = IsymFrLsz(lszName)) != isymNil) {
	InstRangeOfSym(isym, &iinst, &iinstMac);
	return BobFrClsIdx(clsInst, iinst);
    }

    if ((imod = ImodFrLsz(lszName)) != imodNil) {
	return BobFrClsIdx(clsMod, imod);
    }

    imodMac = ImodMac();

    // no exact match -- try short names
    lszName = LszBaseName(lszName);
    for (imod = 0; imod < imodMac; imod++) 
        if (_stricmp(lszName, LszBaseName(LszNameFrMod(imod))) == 0)
	    return BobFrClsIdx(clsMod, imod);

    return bobNil;
}

static BOB
BobQyRefs()
// return the next File in a file query
//
{
    BOB bob;
    static IREF iref, irefMac;

    for (;;) {
	if (!fWorking) {
	    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {

		RefRangeOfInst((IINST)idxQyCur, &iref, &irefMac);
		if (iref != irefMac) 
		    break;
	    }
	    if (idxQyCur >= idxQyMac)
		    return bobNil;

	    fWorking = TRUE;
	}

	if (iref < irefMac) {
	    bob = BobFrClsIdx(clsRef, iref);
	    iref++;
	    return bob;
	}

	idxQyCur++;
	fWorking = FALSE;
    }
}

static BOB
BobQyDefs()
// return the next File in a file query
//
{
    BOB bob;
    static IDEF idef, idefMac;

    for (;;) {
	if (!fWorking) {
	    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {

		DefRangeOfInst((IINST)idxQyCur, &idef, &idefMac);
		if (idef != idefMac) 
		    break;
	    }
	    if (idxQyCur >= idxQyMac)
		    return bobNil;

	    fWorking = TRUE;
	}

	if (idef < idefMac) {
	    bob = BobFrClsIdx(clsDef, idef);
	    idef++;
	    return bob;
	}

	idxQyCur++;
	fWorking = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\stats.c ===
// 
// stats.c	dump statistics about the database
//
#include <string.h>
#include <stdio.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

VOID BSC_API
StatsBSC()
// Dump statistics about the BSC using the output function
//
{
    IMOD  imod,  imodMac;
    IMS   ims,   imsMac;
    ISYM  isym,  isymMac, isymT;
    IINST iinst, iinstMac;
    IDEF  idef,  idefMac;
    IREF  iref,  irefMac;
    IUSE  iuse,  iuseMac;
    IUBY  iuby,  iubyMac;
    TYP   typ;
    ATR   atr;

    isymMac = IsymMac();
    imodMac = ImodMac();
    MsRangeOfMod((IMOD)(imodMac-1), &ims, &imsMac);
    InstRangeOfSym((ISYM)(isymMac-1), &iinst, &iinstMac);
    RefRangeOfInst((IINST)(iinstMac-1), &iref, &irefMac);
    DefRangeOfInst((IINST)(iinstMac-1), &idef, &idefMac);
    UseRangeOfInst((IINST)(iinstMac-1), &iuse, &iuseMac);
    UbyRangeOfInst((IINST)(iinstMac-1), &iuby, &iubyMac);

    BSCPrintf("Totals\n------\n");
    BSCPrintf("MOD	: %d\n", imodMac);
    BSCPrintf("MODSYM	: %d\n", imsMac);
    BSCPrintf("SYM	: %d\n", isymMac);
    BSCPrintf("INST	: %d\n", iinstMac);
    BSCPrintf("REF      : %l\n", irefMac);
    BSCPrintf("DEF      : %d\n", idefMac);
    BSCPrintf("USE      : %d\n", iuseMac);
    BSCPrintf("UBY      : %d\n", iubyMac);

    BSCPrintf("\n\nDetail\n\n");

    for (imod = 0; imod < imodMac; imod++) {
	MsRangeOfMod(imod, &ims, &imsMac);
	BSCPrintf("%s Modsyms:%d\n", LszNameFrMod(imod), imsMac-ims);
    }

    isymMac = IsymMac();

    for (isym = 0; isym < isymMac; isym++) {

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for ( ;iinst < iinstMac; iinst++) {

	    DumpInst(iinst);
	    BSCPrintf(" ");

	    InstInfo(iinst, &isymT, &typ, &atr);

	    if  (isym != isymT)
		BSCPrintf("\t  ERROR instance points back to wrong symbol!\n");

	    DefRangeOfInst(iinst, &idef, &idefMac);
	    BSCPrintf ("DEF %d ", idefMac-idef);

	    RefRangeOfInst(iinst, &iref, &irefMac);
	    BSCPrintf ("REF %d ", irefMac-iref);

	    UseRangeOfInst(iinst, &iuse, &iuseMac);
	    BSCPrintf ("USE %d ", iuseMac-iuse);

	    UbyRangeOfInst(iinst, &iuby, &iubyMac);
	    BSCPrintf ("UBY %d\n", iubyMac-iuby);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\revtree.c ===
//
// revtree.c
//
// two routines for printing out ascii reverse call tree's
//
#include <stdio.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>


#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// forward declarations
static BOOL FUsedInst(IINST iinst);
static VOID dRevTree(IINST iinst, WORD cuby);


// static variables
static BYTE *UbyBits = NULL;
static WORD cNest = 0;

VOID BSC_API
RevTreeInst (IINST iinst)
// emit the call tree starting from the given inst
//
{
    WORD iinstMac;
    int igrp;

    iinstMac = IinstMac();

    // allocate memory for bit array
    UbyBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

    // no memory -- no call tree
    if (!UbyBits) return;

    igrp = iinstMac/8+1;

    while (--igrp>=0)
	UbyBits[igrp] = 0;

    cNest = 0;

    dRevTree(iinst, 1);

    FreeLpv(UbyBits);
}


static VOID 
dRevTree (IINST iinst, WORD cuby)
// emit the call tree starting from the given inst
//
// there are many block variables to keep the stack to a minimum...
{
    {
	ISYM isym;

	{
	    ATR atr;
	    TYP typ;

	    InstInfo(iinst, &isym, &typ, &atr);

	    if (typ > INST_TYP_LABEL)
		return;
	}

	    
	{
	    WORD i;
	    cNest++;
	    for (i = cNest; i; i--) BSCPrintf ("| ");
	}

	if (cuby > 1)
	    BSCPrintf ("%s[%d]", LszNameFrSym (isym), cuby);
	else
	    BSCPrintf ("%s", LszNameFrSym (isym));
    }

    if (FUsedInst(iinst)) {
	BSCPrintf ("...\n");
	cNest--;
	return;
    }
	
    BSCPrintf ("\n");

    {
	IUBY iuby, iubyMac;
	IINST iinstUby;

	UbyRangeOfInst(iinst, &iuby, &iubyMac);

	for (; iuby < iubyMac; iuby++) {
	    UbyInfo(iuby, &iinstUby, &cuby);
	    dRevTree (iinstUby, cuby);
	}
    }

    cNest--;
}

BOOL BSC_API
FRevTreeLsz(LSZ lszName)
// print out a call tree based on the given name
//
{
    IMOD imod;
    ISYM isym;

    cNest = 0;

    if (!lszName)
	return FALSE;

    {
	IINST iinstMac;
	int  igrp;

	iinstMac = IinstMac();

	// allocate memory for bit array
        UbyBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

	// no memory -- no call tree
	if (!UbyBits) return FALSE;

	igrp = iinstMac/8+1;

	while (--igrp >= 0)
	    UbyBits[igrp] = 0;
    }

    if ((imod = ImodFrLsz (lszName)) != imodNil) {
	IMS ims, imsMac;

	MsRangeOfMod(imod, &ims, &imsMac);

	BSCPrintf ("%s\n", LszNameFrMod (imod));

	for ( ; ims < imsMac ; ims++)
	    dRevTree (IinstOfIms(ims), 1);
	
    	FreeLpv(UbyBits);
	return TRUE;
    }

    if ((isym = IsymFrLsz (lszName)) != isymNil) {
	IINST iinst, iinstMac;

	BSCPrintf ("%s\n", LszNameFrSym (isym));

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for (; iinst < iinstMac; iinst++)
	    dRevTree (iinst, 1);
	
	FreeLpv(UbyBits);
	return TRUE;
    }

    FreeLpv(UbyBits);
    return FALSE;
}

static BOOL
FUsedInst(IINST iinst)
// return the status bit for this iinst and set it true
//
{
    WORD igrp;
    BOOL fOut;
    WORD mask;

    igrp = iinst / 8;
    mask = (1 << (iinst % 8));

    fOut = !!(UbyBits[igrp] & mask);
    UbyBits[igrp] |= mask;
    return fOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bscdump\bscdump.c ===
/*
 *  BSCdump - Browser Data Base (.BSC) Dumper
 *	      (C) 1988 By Microsoft
 *
 *
 */
#include <stdio.h>
#include <string.h>
#define LINT_ARGS
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>


#include "bscdump.h"
#include "version.h"
#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"
#include "sbrvers.h"

// this is gross but I don't know where these are supposed to come from
// 

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#if defined (DEBUG)
char	fDEBUG = FALSE;
#endif

char	*psymbol = NULL;
char	*OutlineFileName = NULL;
char far * fname;

extern char *strdup();

void DumpRefsLsz(LSZ);
void DumpDefsLsz(LSZ);
void ListRdds(MBF);

main (argc, argv)
int argc;
char *argv[];
{
    unsigned char Cont;
    unsigned char fCalltree = FALSE;
    unsigned char fSymRefs = FALSE;
    unsigned char fSymDefs = FALSE;
    unsigned char fRevtree  = FALSE;
    unsigned char fDumpStats = FALSE;
    unsigned char fRedundant = FALSE;
    MBF mbf = mbfNil, mbfRef = mbfNil, mbfRdd = mbfNil;

    char *s;
    --argc;
    ++argv;
    while (argc && ((**argv == '-') || (**argv == '-'))) {
	Cont = TRUE;
	while (Cont && *++*argv)
	    switch (**argv) {
		case 'o':
		    s = *argv+1;
		    while (*s) {
			switch (*s) {
			case 'F':  mbf |= mbfFuncs;  break;
			case 'M':  mbf |= mbfMacros; break;
			case 'V':  mbf |= mbfVars;   break;
			case 'T':  mbf |= mbfTypes;  break;
			}
			s++;
		    }

		    if (mbf == mbfNil) mbf = mbfAll;
		    if (--argc == 0)
			Usage();
		    OutlineFileName = *++argv;
		    Cont = FALSE;
		    break;

		case 'l':
		    s = *argv+1;
		    while (*s) {
			switch (*s) {
			case 'F':  mbfRef |= mbfFuncs;  break;
			case 'M':  mbfRef |= mbfMacros; break;
			case 'V':  mbfRef |= mbfVars;   break;
			case 'T':  mbfRef |= mbfTypes;  break;
			}
			s++;
		    }

		    if (mbfRef == mbfNil) mbfRef = mbfAll;
		    Cont = FALSE;
		    break;

                case 'u':
		    s = *argv+1;
		    while (*s) {
			switch (*s) {
			case 'F':  mbfRdd |= mbfFuncs;  break;
			case 'M':  mbfRdd |= mbfMacros; break;
		        case 'V':  mbfRdd |= mbfVars;   break;
   		        case 'T':  mbfRdd |= mbfTypes;  break;
		        }
			s++;
		    }

		    if (mbfRdd == mbfNil) mbfRdd = mbfAll;
		    Cont = FALSE;
		    break;

		case 't':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fCalltree = TRUE;
		    Cont = FALSE;
		    break;

		case 'r':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fSymRefs = TRUE;
		    Cont = FALSE;
		    break;

		case 'd':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fSymDefs = TRUE;
		    Cont = FALSE;
		    break;

		case 'b':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fRevtree = TRUE;
		    Cont = FALSE;
		    break;

		case 's':
		    fDumpStats = TRUE;
		    break;

		default:
		    Usage();
		    break;
		}
	--argc;
	++argv;
	}

    if (argc < 1) {
	Usage();
	}

    fname = strdup(*argv++);

    if (!FOpenBSC(fname)) {
	BSCPrintf("BSCdump: cannot open database %s\n", fname);
	exit(4);
    }

    if (fDumpStats)
	StatsBSC();
    else if (fCalltree)
	FCallTreeLsz(psymbol);
    else if (fSymRefs)
	DumpRefsLsz(psymbol);
    else if (fSymDefs)
	DumpDefsLsz(psymbol);
    else if (fRevtree)
	FRevTreeLsz(psymbol);
    else if (OutlineFileName)
	FOutlineModuleLsz(OutlineFileName, mbf);
    else if (mbfRef)
	ListRefs(mbfRef);
    else if (mbfRdd)
        ListRdds(mbfRdd);
    else
        DumpBSC();

    CloseBSC();

    free (fname);
}

Usage()
{
    BSCPrintf("Microsoft (R) BSCdump Utility ");
    BSCPrintf(VERS(rmj, rmm, rup));
    BSCPrintf(CPYRIGHT);

    BSCPrintf("Usage: bscdump [options] file.bsc\n\n");
    BSCPrintf("  -o[FVMT] <file> outline\n");
    BSCPrintf("  -l[FVMT]        List References\n");
    BSCPrintf("  -u[FVMT]        List Redundant definitions\n");
    BSCPrintf("  -t <sym>        Calltree <sym>\n");
    BSCPrintf("  -b <sym>        Backwards Calltree <sym>\n");
    BSCPrintf("  -s              Emit BSC stats\n");
    BSCPrintf("  -r <sym>        List all references to symbol\n");
    BSCPrintf("  -d <sym>        List all definitions of symbol\n");
    exit(1);
}

void DumpDefsLsz(LSZ lszSym)
{
    ISYM isym;
    IINST iinst, iinstMac;
    IDEF idef, idefMac;
    LSZ  lsz;
    WORD line;

    isym = IsymFrLsz(lszSym);

    if (isym == isymNil) {
	BSCPrintf("unknown symbol %s\n", lszSym);
	return;
    }

    InstRangeOfSym(isym, &iinst, &iinstMac);

    for (;iinst < iinstMac; iinst++) {

	DefRangeOfInst(iinst, &idef, &idefMac);

	for ( ; idef < idefMac; idef++) {
	    DefInfo(idef, &lsz, &line);
	    BSCPrintf("%s %d\n", lsz, line);
	}
    }
    
}

void DumpRefsLsz(LSZ lszSym)
{
    ISYM isym;
    IINST iinst, iinstMac;
    IREF iref, irefMac;
    LSZ  lsz;
    WORD line;

    isym = IsymFrLsz(lszSym);

    if (isym == isymNil) {
	BSCPrintf("unknown symbol %s\n", lszSym);
	return;
    }

    InstRangeOfSym(isym, &iinst, &iinstMac);

    for (;iinst < iinstMac; iinst++) {

	RefRangeOfInst(iinst, &iref, &irefMac);

	for ( ; iref < irefMac; iref++) {
	    RefInfo(iref, &lsz, &line);
	    BSCPrintf("%s %d\n", lsz, line);
	}
    }
    
}

void ListRdds(MBF mbf)
{
    ISYM isym, isymMac, isymname;
    IINST iinst, iinstMac;
    IUBY iubyFirst, iubyLast;
    LSZ lszsymname;
    TYP iinsttyp;
    ATR iinstattr;

    isymMac = IsymMac();

    for (isym = 0 ; isym < isymMac ; isym++)
    {
	lszsymname = LszNameFrSym(isym);
        InstRangeOfSym(isym,&iinst,&iinstMac);

        for ( ; iinst < iinstMac ; iinst++)
        {
	    UbyRangeOfInst(iinst,&iubyFirst,&iubyLast);

	    if (iubyFirst == iubyLast)
	    {
               InstInfo(iinst,&isymname, &iinsttyp, &iinstattr);

               // iinstattr &= INST_TYPMASK;

               if (iinsttyp <= INST_TYP_LABEL && !!(mbf & mbfFuncs))

	          BSCPrintf("Function not called  : %s\n",lszsymname);

               else if
                  ((iinsttyp <= INST_TYP_VARIABLE ||
                    iinsttyp >= INST_TYP_SEGMENT     ) && !!(mbf & mbfVars))
		
		  BSCPrintf("Variable not used    : %s\n",lszsymname);

	       else if
                  (iinsttyp <= INST_TYP_MACRO && !!(mbf & mbfMacros))

		  BSCPrintf("Macro not referenced : %s\n",lszsymname);

	       else if (!!(mbf & mbfTypes))

		  BSCPrintf("Type not referenced  : %s\n",lszsymname);
	   
	    }
	}
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP