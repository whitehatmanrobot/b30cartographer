                                                Urb,
                                                URB_FUNCTION_CLASS_ENDPOINT,
                                                0,                  // transferFlags,
                                                hidWritePacket->reportBuffer,
                                                hidWritePacket->reportBufferLen,
                                                0x22,               // requestType= Set_Report Request,
                                                0x09,               // request=SET_REPORT,
                                                (0x0200 + hidWritePacket->reportId), // value= reportType 'output' &reportId,
                                                deviceInputEndpoint, // index= interrupt input endpoint for this device
                                                hidWritePacket->reportBufferLen    // reqLength (not used)
                                               );
                    } 
                    else {
                        ntStatus = STATUS_DATA_ERROR;
                    }
                } 
                else {

                    interruptPipe = GetInterruptOutputPipeForDevice(DeviceExtension);
                    if (interruptPipe){
                        /*
                         *  This device has an interrupt output pipe.
                         */

                        Urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
                        Urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

                        ASSERT(interruptPipe->PipeHandle);
                        Urb->UrbBulkOrInterruptTransfer.PipeHandle = interruptPipe->PipeHandle;

                        Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = hidWritePacket->reportBufferLen;
                        Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
                        Urb->UrbBulkOrInterruptTransfer.TransferBuffer = hidWritePacket->reportBuffer;
                        Urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_OUT;
                        Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
                    } 
                    else {
                        /*
                         *  This device does not have an interrupt output pipe.
                         *  Send the report on the control pipe.
                         */

                        /*
                         *   A control operation consists of 3 stages: setup, data, and status.
                         *   In the setup stage the device receives an 8-byte frame comprised of
                         *   the following fields of a _URB_CONTROL_VENDOR_OR_CLASS_REQUEST structure:
                         *   See section 7.2 in the USB HID specification for how to fill out these fields.
                         *
                         *      UCHAR RequestTypeReservedBits;
                         *      UCHAR Request;
                         *      USHORT Value;
                         *      USHORT Index;
                         *
                         */
                        HumBuildClassRequest(
                                                Urb,
                                                URB_FUNCTION_CLASS_INTERFACE,
                                                0,                  // transferFlags,
                                                hidWritePacket->reportBuffer,
                                                hidWritePacket->reportBufferLen,
                                                0x22,               // requestType= Set_Report Request,
                                                0x09,               // request=SET_REPORT,
                                                (0x0200 + hidWritePacket->reportId), // value= reportType 'output' &reportId,
                                                DeviceExtension->Interface->InterfaceNumber, // index= interrupt input interface for this device
                                                hidWritePacket->reportBufferLen    // reqLength (not used)
                                               );
                    }
                }
                
                if (ntStatus == STATUS_UNSUCCESSFUL) {
                    IoSetCompletionRoutine(Irp, HumWriteCompletion, Urb, TRUE, TRUE, TRUE);

                    nextIrpStack->Parameters.Others.Argument1 = Urb;
                    nextIrpStack->MajorFunction = currentIrpStack->MajorFunction;
                    nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
                    nextIrpStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);

                    //
                    // We need to keep track of the number of pending requests
                    // so that we can make sure they're all cancelled properly during
                    // processing of a stop device request.
                    //

                    if (NT_SUCCESS(HumIncrementPendingRequestCount( DeviceExtension )) ) {

                        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                        *NeedsCompletion = FALSE;
                        
                    } else {
                        ExFreePool(Urb);

                        ntStatus = STATUS_NO_SUCH_DEVICE;
                    }

                } else {
                    ExFreePool(Urb);
                }
            } 
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            ntStatus = STATUS_DATA_ERROR;
        }
    } 
    else {
        ntStatus = STATUS_DATA_ERROR;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumWriteCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HumWriteCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PURB urb = (PURB)Context;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ASSERT(urb);

    if (NT_SUCCESS(Irp->IoStatus.Status)){
        //
        //  Record the number of bytes written.
        //
        Irp->IoStatus.Information = (ULONG)urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    }

    ExFreePool(urb);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    /*
     *  Balance the increment we did when we issued the write.
     */
    HumDecrementPendingRequestCount(deviceExtension);

    return STATUS_SUCCESS;
}



/*
 ********************************************************************************
 *  HumGetPhysicalDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetPhysicalDescriptor(  IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp,
                                    BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION IrpStack;
    ULONG bufferSize;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    /*
     *  Check buffer size before trying to use Irp->MdlAddress.
     */
    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    if (bufferSize){

        PVOID buffer = HumGetSystemAddressForMdlSafe(Irp->MdlAddress);
        if (buffer){
            ntStatus = HumGetDescriptorRequest(DeviceObject,
                                               URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                               HID_PHYSICAL_DESCRIPTOR_TYPE,
                                               &buffer,
                                               &bufferSize,
                                               sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                               0, // Index. NOTE: will only get first physical descriptor set
                                               0); 
        } 
        else {
            ntStatus = STATUS_INVALID_USER_BUFFER;
        }
    } 
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumGetStringDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetStringDescriptor(    IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_PENDING;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PVOID buffer;
    ULONG bufferSize;
    BOOLEAN isIndexedString;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode){
        case IOCTL_HID_GET_INDEXED_STRING:
            /*
             *  IOCTL_HID_GET_INDEXED_STRING uses buffering method
             *  METHOD_OUT_DIRECT, which passes the buffer in the MDL.
             *
             *  The MDL is built by the kernel for any non-zero-length
             *  buffer passed in by the client.  So we don't need to
             *  verify the integrity of the MDL, but we do have to check
             *  that it's non-NULL.
             */
            buffer = HumGetSystemAddressForMdlSafe(Irp->MdlAddress);
            isIndexedString = TRUE;
            break;

        case IOCTL_HID_GET_STRING:
            /*
             *  IOCTL_HID_GET_STRING uses buffering method
             *  METHOD_NEITHER, which passes the buffer in Irp->UserBuffer.
             */
            buffer = Irp->UserBuffer;
            isIndexedString = FALSE;
            break;

        default:
            ASSERT(0);
            buffer = NULL;
            break;
    }

    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (buffer && bufferSize){

        /*
         *  String id and language id are in Type3InputBuffer field
         *  of IRP stack location.
         *
         *  Note: the string ID should be identical to the string's
         *        field offset given in Chapter 9 of the USB spec.
         */
        ULONG languageId = (PtrToUlong(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)) >> 16;
        ULONG stringIndex;

        if (isIndexedString){
            stringIndex = (PtrToUlong(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) & 0x0ffff);
        } 
        else {
            ULONG stringId = (PtrToUlong(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) & 0x0ffff);

            switch (stringId){
                case HID_STRING_ID_IMANUFACTURER: 
                    stringIndex = DeviceExtension->DeviceDescriptor->iManufacturer;
                    break;
                case HID_STRING_ID_IPRODUCT: 
                    stringIndex = DeviceExtension->DeviceDescriptor->iProduct;
                    break;
                case HID_STRING_ID_ISERIALNUMBER: 
                    stringIndex = DeviceExtension->DeviceDescriptor->iSerialNumber;
                    break;
                default:
                    stringIndex = -1;
                    break;
            }
        }

        if (stringIndex == -1){
            ntStatus = STATUS_INVALID_PARAMETER;
        } 
        else {
            PWCHAR tmpDescPtr;
            ULONG tmpDescPtrLen;

            /*
             *  USB descriptors begin with an extra two bytes for length and type.
             *  So we need to allocate a slightly larger buffer.
             */
            tmpDescPtrLen = bufferSize + 2;
            tmpDescPtr = ExAllocatePoolWithTag(NonPagedPool, tmpDescPtrLen, HIDUSB_TAG);
            if (tmpDescPtr){
                ntStatus = HumGetDescriptorRequest(DeviceObject,
                                                   URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                                   USB_STRING_DESCRIPTOR_TYPE,
                                                   &tmpDescPtr,
                                                   &tmpDescPtrLen,
                                                   sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                   stringIndex, 
                                                   languageId); // LanguageID,

                if (NT_SUCCESS(ntStatus)){
                    /*
                     *  USB descriptors always begin with two bytes for the length
                     *  and type.  Remove these.
                     */
                    PWCHAR descPtr = (PWCHAR)buffer;
                    ULONG descLen = (ULONG)(((PCHAR)tmpDescPtr)[0]);
                    WCHAR unicodeNULL = UNICODE_NULL;

                    if (descLen <= bufferSize+2){
                        ULONG i;
                        for (i = 1; (i < descLen/sizeof(WCHAR)) && (i-1 < bufferSize/sizeof(WCHAR)); i++){
                            RtlCopyMemory(&descPtr[i-1], &tmpDescPtr[i], sizeof(WCHAR));
                        }
                        if (i-1 < bufferSize/sizeof(WCHAR)){
                            RtlCopyMemory(&descPtr[i-1], &unicodeNULL, sizeof(WCHAR));
                        }
                    } 
                    else {
                        /*
                         *  Compensate for a device bug which causes
                         *  a partial string to be returned if the buffer is too small.
                         */
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                    }
                }

                ExFreePool(tmpDescPtr);
            } 
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    } 
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumGetSetReportCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetSetReportCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PURB urb = (PURB)Context;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (NT_SUCCESS(Irp->IoStatus.Status)){
        /*
         *  Record the number of bytes written.
         */
        Irp->IoStatus.Information = (ULONG)urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    }

    ExFreePool(urb);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    /*
     *  Balance the increment we did when we issued this IRP.
     */
    HumDecrementPendingRequestCount(deviceExtension);

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HumGetSetReport
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetSetReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack, nextIrpStack;
    PHID_XFER_PACKET reportPacket;
    
    ULONG transferFlags;
    UCHAR request;
    USHORT value;

    PIO_STACK_LOCATION  irpSp;
    
    PAGED_CODE();
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){
    case IOCTL_HID_GET_INPUT_REPORT:
        transferFlags = USBD_TRANSFER_DIRECTION_IN;
        request = 0x01;
        value = 0x0100;
        break;
    case IOCTL_HID_SET_OUTPUT_REPORT:
        transferFlags = USBD_TRANSFER_DIRECTION_OUT;
        request = 0x09;
        value = 0x0200;
        break;
    case IOCTL_HID_SET_FEATURE:
        transferFlags = USBD_TRANSFER_DIRECTION_OUT;
        request = 0x09;
        value = 0x0300;
        break;
    case IOCTL_HID_GET_FEATURE:
        transferFlags = USBD_TRANSFER_DIRECTION_IN;
        request = 0x01;
        value = 0x0300;
        break;
    default:
        DBGBREAK;
    }

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    nextIrpStack = IoGetNextIrpStackLocation(Irp);

    reportPacket = Irp->UserBuffer;
    if (reportPacket && reportPacket->reportBuffer && reportPacket->reportBufferLen){
        PURB Urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), HIDUSB_TAG);

        if (Urb){

            RtlZeroMemory(Urb, sizeof( URB ));

            value += reportPacket->reportId;

            /*
             *   A control operation consists of 3 stages: setup, data, and status.
             *   In the setup stage the device receives an 8-byte frame comprised of
             *   the following fields of a _URB_CONTROL_VENDOR_OR_CLASS_REQUEST structure:
             *   See section 7.2 in the USB HID specification for how to fill out these fields.
             *
             *      UCHAR RequestTypeReservedBits;
             *      UCHAR Request;
             *      USHORT Value;
             *      USHORT Index;
             *
             */
            if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
                HumBuildClassRequest(
                                        Urb,
                                        URB_FUNCTION_CLASS_ENDPOINT,
                                        transferFlags,
                                        reportPacket->reportBuffer,
                                        reportPacket->reportBufferLen,
                                        0x22, // requestType= Set_Report Request,
                                        request,
                                        value, // value= reportType 'report' &reportId,
                                        1,                  // index= endpoint 1,
                                        hidWritePacket->reportBufferLen    // reqLength (not used)
                                       );
            } 
            else {
                HumBuildClassRequest(
                                        Urb,
                                        URB_FUNCTION_CLASS_INTERFACE,
                                        transferFlags,
                                        reportPacket->reportBuffer,
                                        reportPacket->reportBufferLen,
                                        0x22, // requestType= Set_Report Request,
                                        request,
                                        value, // value= reportType 'report' &reportId,
                                        DeviceExtension->Interface->InterfaceNumber, // index= interface,
                                        hidWritePacket->reportBufferLen    // reqLength (not used)
                                       );
            }

            IoSetCompletionRoutine(Irp, HumGetSetReportCompletion, Urb, TRUE, TRUE, TRUE);

            nextIrpStack->Parameters.Others.Argument1 = Urb;
            nextIrpStack->MajorFunction = currentIrpStack->MajorFunction;
            nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
            nextIrpStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);

            //
            // We need to keep track of the number of pending requests
            // so that we can make sure they're all cancelled properly during
            // processing of a stop device request.
            //

            if (NT_SUCCESS(HumIncrementPendingRequestCount( DeviceExtension )) ) {

                ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                *NeedsCompletion = FALSE;
                
            } else {
                ExFreePool(Urb);

                ntStatus = STATUS_NO_SUCH_DEVICE;
            }

        } 
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    } 
    else {
        ntStatus = STATUS_DATA_ERROR;
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumGetMsGenreDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetMsGenreDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION IrpStack;
    ULONG bufferSize;
    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGOUT(("Received request for genre descriptor in hidusb"))

    /*
     *  Check buffer size before trying to use Irp->MdlAddress.
     */
    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    if (bufferSize){

        PVOID buffer = HumGetSystemAddressForMdlSafe(Irp->MdlAddress);
        if (buffer){
            PURB Urb;

            //
            // Allocate Descriptor buffer
            //
            Urb = ExAllocatePoolWithTag(NonPagedPool, 
                                        sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST),
                                        HIDUSB_TAG);
            if (!Urb){
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory(Urb, sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST));

            RtlZeroMemory(buffer, bufferSize);
            HumBuildOsFeatureDescriptorRequest(Urb,
                              sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST),
                              DeviceExtension->Interface->InterfaceNumber,
                              MS_GENRE_DESCRIPTOR_INDEX,
                              buffer,
                              NULL,
                              bufferSize,
                              NULL);
            DBGOUT(("Sending os feature request to usbhub"))
            ntStatus = HumCallUSB(DeviceObject, Urb);
            if (NT_SUCCESS(ntStatus)){
                if (USBD_SUCCESS(Urb->UrbHeader.Status)){
                    DBGOUT(("Genre descriptor request successful!"))
                    ntStatus = STATUS_SUCCESS;
                } else {
                    DBGOUT(("Genre descriptor request unsuccessful"))
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
            } 

            ExFreePool(Urb);
        } 
        else {
            ntStatus = STATUS_INVALID_USER_BUFFER;
        }
    } 
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}

NTSTATUS
HumSendIdleNotificationRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    BOOLEAN *NeedsCompletion
    )
{
    PIO_STACK_LOCATION current, next;

    current = IoGetCurrentIrpStackLocation(Irp);
    next = IoGetNextIrpStackLocation(Irp);

    if (current->Parameters.DeviceIoControl.InputBufferLength < sizeof(HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ASSERT(sizeof(HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO) == sizeof(USB_IDLE_CALLBACK_INFO));

    if (sizeof(HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO) != sizeof(USB_IDLE_CALLBACK_INFO)) {
        return STATUS_INFO_LENGTH_MISMATCH; 
    }

    *NeedsCompletion = FALSE;
    next->MajorFunction = current->MajorFunction;
    next->Parameters.DeviceIoControl.InputBufferLength =
        current->Parameters.DeviceIoControl.InputBufferLength;
    next->Parameters.DeviceIoControl.Type3InputBuffer = 
        current->Parameters.DeviceIoControl.Type3InputBuffer;
    next->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;
    next->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);

    return IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract


Author:

    Jay Senior

Environment:

    Kernel mode only

Revision History:


--*/



#include <wdm.h>
#include <usbdrivr.h>
#include <hidport.h>
#include <hidusb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\hidusb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hidusb.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:

    Daniel Dean, Mercury Engineering.

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

#if DBG
    ULONG HIDUSB_DebugLevel = 0;    // 1 is lowest debug level
    BOOLEAN dbgTrapOnWarn = FALSE;
#endif 


NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION hidMinidriverRegistration;

    DBGPRINT(1,("DriverEntry Enter"));

    DBGPRINT(1,("DriverObject (%lx)", DriverObject));

    
    //
    // Create dispatch points
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = HumCreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HumInternalIoctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = HumPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = HumPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = HumSystemControl;
    DriverObject->DriverExtension->AddDevice                    = HumAddDevice;
    DriverObject->DriverUnload                                  = HumUnload;


    //
    // Register USB layer with HID.SYS module
    //

    hidMinidriverRegistration.Revision              = HID_REVISION;
    hidMinidriverRegistration.DriverObject          = DriverObject;
    hidMinidriverRegistration.RegistryPath          = registryPath;
    hidMinidriverRegistration.DeviceExtensionSize   = sizeof(DEVICE_EXTENSION);

    /*
     *  HIDUSB is a minidriver for USB devices, which do not need to be polled.
     */
    hidMinidriverRegistration.DevicesArePolled      = FALSE;

    DBGPRINT(1,("DeviceExtensionSize = %x", hidMinidriverRegistration.DeviceExtensionSize));

    DBGPRINT(1,("Registering with HID.SYS"));

    ntStatus = HidRegisterMinidriver(&hidMinidriverRegistration);

    KeInitializeSpinLock(&resetWorkItemsListSpinLock);

    DBGPRINT(1,("DriverEntry Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS HumCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION   IrpStack;
    NTSTATUS             ntStatus = STATUS_SUCCESS;

    DBGPRINT(1,("HumCreateClose Enter"));

    DBGBREAK;

    //
    // Get a pointer to the current location in the Irp.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            DBGPRINT(1,("IRP_MJ_CREATE"));
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            DBGPRINT(1,("IRP_MJ_CLOSE"));
            Irp->IoStatus.Information = 0;
            break;

        default:
            DBGPRINT(1,("Invalid CreateClose Parameter"));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Save Status for return and complete Irp
    //

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(1,("HumCreateClose Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS HumAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT FunctionalDeviceObject)
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject - pointer to a device object pointer created by the bus

Return Value:

    NT status code.

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension;

    DBGPRINT(1,("HumAddDevice Entry"));

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(FunctionalDeviceObject);

    deviceExtension->DeviceFlags = 0;
    
    deviceExtension->NumPendingRequests = 0;
    KeInitializeEvent( &deviceExtension->AllRequestsCompleteEvent,
                       NotificationEvent,
                       FALSE);

    deviceExtension->ResetWorkItem = NULL;
    deviceExtension->DeviceState = DEVICE_STATE_NONE;
    deviceExtension->functionalDeviceObject = FunctionalDeviceObject;

    DBGPRINT(1,("HumAddDevice Exit = %x", ntStatus));

    return ntStatus;
}



VOID HumUnload(IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    DBGPRINT(1,("HumUnload Enter"));

    DBGPRINT(1,("Unloading DriverObject = %x", DriverObject));

    ASSERT (NULL == DriverObject->DeviceObject);

    DBGPRINT(1,("Unloading Exit = VOID"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:
            forrestf
            ervinp
            jdunn

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


/*
 ************************************************************
 *  HumInternalIoctl
 ************************************************************
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 *
 *  Note:  this is an INTERNAL IOCTL handler, so no buffer
 *         validation is required.
 */
NTSTATUS HumInternalIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  irpSp;
    BOOLEAN             NeedsCompletion = TRUE;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

    case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumGetHidDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_REPORT_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumGetReportDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_READ_REPORT:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumReadReport(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_WRITE_REPORT:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumWriteReport (DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_GET_STRING:
        /*
         *  Get the friendly name for the device.
         *
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumGetStringDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_INDEXED_STRING:
        ntStatus = HumGetStringDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_GET_FEATURE:
    case IOCTL_HID_GET_INPUT_REPORT:
    case IOCTL_HID_SET_OUTPUT_REPORT:
        ntStatus = HumGetSetReport(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_ACTIVATE_DEVICE:
    case IOCTL_HID_DEACTIVATE_DEVICE:
        /*
         *  We don't do anything for these IOCTLs but some minidrivers might.
         */
        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        /*
         *  This IOCTL gets information related to the human body part used
         *  to control a device control.
         */
        ntStatus = HumGetPhysicalDescriptor(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         *  If the IRP is coming to us from user space,
         *  we must validate the buffer.
         */
        ntStatus = HumGetDeviceAttributes(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_MS_GENRE_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         *  If the IRP is coming to us from user space,
         *  we must validate the buffer.
         */
        ntStatus = HumGetMsGenreDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST:
        ntStatus = HumSendIdleNotificationRequest(DeviceObject, Irp, &NeedsCompletion);
        break;

    default:
        /*
         *  Note: do not return STATUS_NOT_SUPPORTED;
         *  Just keep the default status (this allows filter drivers to work).
         */
        ntStatus = Irp->IoStatus.Status;
        break;
    }

    /* 
     *  Complete the IRP only if we did not pass it to a lower driver.
     */
    if (NeedsCompletion) {
        ASSERT(ntStatus != STATUS_PENDING);
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\hidusb.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hidusb.h

Abstract:


Author:

    Daniel Dean.

Environment:

    Kernel & user mode

Revision History:



--*/
#ifndef __HIDUSB_H__
#define __HIDUSB_H__


#include <PSHPACK1.H>

typedef struct _USB_HID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdHID;
    UCHAR   bCountry;
    UCHAR   bNumDescriptors;
    UCHAR   bReportType;
    USHORT  wReportLength;

} USB_HID_DESCRIPTOR, * PUSB_HID_DESCRIPTOR;

#include <POPPACK.H>


//
// Device Class Constants for HID
//
#define HID_GET_REPORT      0x01
#define HID_GET_IDLE        0x02
#define HID_GET_PROTOCOL    0x03

#define HID_SET_REPORT      0x09
#define HID_SET_IDLE        0x0A
#define HID_SET_PROTOCOL    0x0B

//
// USB Constants that should be defined in a USB header...
//
#define USB_INTERFACE_CLASS_HID     0x03

#define USB_DESCRIPTOR_TYPE_HID         0x21

typedef struct _DEVICE_EXTENSION
{
    ULONG                           DeviceState;

    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    PUSBD_INTERFACE_INFORMATION     Interface;
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    LONG                            NumPendingRequests;
    KEVENT                          AllRequestsCompleteEvent;

    ULONG                           DeviceFlags;

    PIO_WORKITEM                    ResetWorkItem;
    USB_HID_DESCRIPTOR              HidDescriptor;

    PDEVICE_OBJECT                  functionalDeviceObject;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


/*
 *  This structure is used to pass information to the 
 *  resetWorkItem callback.
 */
typedef struct tag_resetWorkItemContext {
                    #define RESET_WORK_ITEM_CONTEXT_SIG 'tesR'
                    ULONG sig;
                    PIO_WORKITEM ioWorkItem;
                    PDEVICE_OBJECT deviceObject;
                    PIRP irpToComplete;

                    struct tag_resetWorkItemContext *next;
} resetWorkItemContext;

#define DEVICE_STATE_NONE           0
#define DEVICE_STATE_STARTING       1
#define DEVICE_STATE_RUNNING        2
#define DEVICE_STATE_STOPPING       3
#define DEVICE_STATE_STOPPED        4
#define DEVICE_STATE_REMOVING       5
#define DEVICE_STATE_START_FAILED   6

#define DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE   0x00000001

//
// Interface slection options
//
#define HUM_SELECT_DEFAULT_INTERFACE    0
#define HUM_SELECT_SPECIFIED_INTERFACE  1

//
// Device Extension Macros
//

#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) ((PDEVICE_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_HIDCLASS_DEVICE_EXTENSION(DO) ((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)

#define GET_NEXT_DEVICE_OBJECT(DO) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)


#if DBG
    extern ULONG HIDUSB_DebugLevel;
    extern BOOLEAN dbgTrapOnWarn;

    #define DBGBREAK                                        \
        {                                               \
            DbgPrint("'HIDUSB> Code coverage trap: file %s, line %d \n",  __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }
    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("'HIDUSB> *** WARNING *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("'    > "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("'HIDUSB> *** ERROR *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("'    > "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("'HIDUSB> "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGPRINT(lvl, args_in_parens) \
                if (lvl <= HIDUSB_DebugLevel){ \
                    DBGOUT(args_in_parens); \
                } 
#else // DBG
    #define DBGPRINT(lvl, arg)
    #define DBGBREAK
    #define DBGWARN(args_in_parens)                                
    #define DBGERR(args_in_parens)                                
    #define DBGOUT(args_in_parens)                                
#endif // DBG



#define HumBuildGetDescriptorRequest(urb, \
                                     function, \
                                     length, \
                                     descriptorType, \
                                     index, \
                                     languageId, \
                                     transferBuffer, \
                                     transferBufferMDL, \
                                     transferBufferLength, \
                                     link) { \
            (urb)->UrbHeader.Function =  (function); \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbControlDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbControlDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbControlDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlDescriptorRequest.DescriptorType = (descriptorType); \
            (urb)->UrbControlDescriptorRequest.Index = (index); \
            (urb)->UrbControlDescriptorRequest.LanguageId = (languageId); \
            (urb)->UrbControlDescriptorRequest.UrbLink = (link); }


#define HumBuildClassRequest(urb, \
                                       function, \
                                       transferFlags, \
                                       transferBuffer, \
                                       transferBufferLength, \
                                       requestType, \
                                       request, \
                                       value, \
                                       index, \
                                       reqLength){ \
            (urb)->UrbHeader.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST); \
            (urb)->UrbHeader.Function = function; \
            (urb)->UrbControlVendorClassRequest.Index = (index); \
            (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = (requestType); \
            (urb)->UrbControlVendorClassRequest.Request = (request); \
            (urb)->UrbControlVendorClassRequest.Value = (value); \
            (urb)->UrbControlVendorClassRequest.TransferFlags = (transferFlags); \
            (urb)->UrbControlVendorClassRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlVendorClassRequest.TransferBufferLength = (transferBufferLength); }

#define HumBuildSelectConfigurationRequest(urb, \
                                         length, \
                                         configurationDescriptor) { \
            (urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_CONFIGURATION; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbSelectConfiguration.ConfigurationDescriptor = (configurationDescriptor);    }

#define HumBuildOsFeatureDescriptorRequest(urb, \
                              length, \
                              interface, \
                              index, \
                              transferBuffer, \
                              transferBufferMDL, \
                              transferBufferLength, \
                              link) { \
            (urb)->UrbHeader.Function = URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbOSFeatureDescriptorRequest.InterfaceNumber = (interface); \
            (urb)->UrbOSFeatureDescriptorRequest.MS_FeatureDescriptorIndex = (index); \
            (urb)->UrbOSFeatureDescriptorRequest.UrbLink = (link); }

#define BAD_POINTER ((PVOID)0xFFFFFFFE)

/*
 *  HIDUSB signature tag for memory allocations
 */
#define HIDUSB_TAG (ULONG)'UdiH'

//
// Function prototypes
//

NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath);
NTSTATUS    HumAbortPendingRequests(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumInternalIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumPnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumPower(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumCreateDevice(IN PDRIVER_OBJECT DriverObject, IN OUT PDEVICE_OBJECT *DeviceObject);
NTSTATUS    HumAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT FunctionalDeviceObject);
NTSTATUS    HumStartDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumPnpCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HumInitDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumStopDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumRemoveDevice(IN PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS    HumCallUSB(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb);
VOID        HumUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    HumGetHidDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumReadReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HumWriteReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumGetSetReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumWriteCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HumGetString(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumGetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetDescriptorRequest(IN PDEVICE_OBJECT DeviceObject, IN USHORT Function, IN ULONG DescriptorType, IN OUT PVOID *Descriptor, IN OUT ULONG *DescSize, IN ULONG TypeSize, IN ULONG Index, IN ULONG LangID);
NTSTATUS    HumSetIdle(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumSelectConfiguration(IN PDEVICE_OBJECT DeviceObject, IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor);
NTSTATUS    HumParseHidInterface(IN PDEVICE_EXTENSION DeviceExtension, IN PUSB_INTERFACE_DESCRIPTOR InterfaceDesc, IN ULONG InterfaceLength, OUT PUSB_HID_DESCRIPTOR *HidDescriptor);
NTSTATUS    HumGetDeviceDescriptor(IN PDEVICE_OBJECT, IN PDEVICE_EXTENSION);
NTSTATUS    HumGetConfigDescriptor(IN PDEVICE_OBJECT DeviceObject, OUT PUSB_CONFIGURATION_DESCRIPTOR *ConfigurationDesc, OUT PULONG ConfigurationDescLength);
NTSTATUS    HumGetHidInfo(IN PDEVICE_OBJECT DeviceObject, IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc, IN ULONG DescriptorLength);
NTSTATUS    DumpConfigDescriptor(IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc, IN ULONG DescriptorLength);
VOID        HumDecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension);
NTSTATUS    HumIncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension);
NTSTATUS    HumResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context);
NTSTATUS    HumResetParentPort(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumGetPortStatus(IN PDEVICE_OBJECT DeviceObject, IN PULONG PortStatus);
NTSTATUS    HumResetInterruptPipe(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetStringDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetPhysicalDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion);
NTSTATUS    HumGetMsGenreDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumSendIdleNotificationRequest(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion);

extern KSPIN_LOCK resetWorkItemsListSpinLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\sysctrl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sysctrl.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:
            ervinp

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HumSystemControl)
#endif


/*
 ************************************************************
 *  HumSystemControl
 ************************************************************
 *
 */
NTSTATUS HumSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  thisStackLoc;

    PAGED_CODE();

    thisStackLoc = IoGetCurrentIrpStackLocation(Irp);

    switch(thisStackLoc->Parameters.DeviceIoControl.IoControlCode){

        default:
            /*
             *  Note: do not return STATUS_NOT_SUPPORTED;
             *  If completing the IRP here,
             *  just keep the default status 
             *  (this allows filter drivers to work).
             */
            status = Irp->IoStatus.Status;
            break;
    }


    IoCopyCurrentIrpStackLocationToNext(Irp);

    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HumPnP)
    #pragma alloc_text(PAGE, HumStartDevice)
    #pragma alloc_text(PAGE, HumStopDevice)
    #pragma alloc_text(PAGE, HumRemoveDevice)
    #pragma alloc_text(PAGE, HumAbortPendingRequests)
#endif


/*
 ************************************************************
 *  HumPnP
 ************************************************************
 *
 *  Process PnP IRPs sent to this device.
 *
 */
NTSTATUS HumPnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION DeviceExtension;
    KEVENT event;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    switch(irpSp->MinorFunction){

    case IRP_MN_START_DEVICE:
        ntStatus = HumStartDevice(DeviceObject);
        break;

    case IRP_MN_STOP_DEVICE:
        if (DeviceExtension->DeviceState == DEVICE_STATE_RUNNING) {
            ntStatus = HumStopDevice(DeviceObject);
        } else {
            ntStatus = STATUS_SUCCESS;
        }
        break;

    case IRP_MN_REMOVE_DEVICE:
        return HumRemoveDevice(DeviceObject, Irp);
        break;
    }
    
    if (NT_SUCCESS(ntStatus)){
        /*
         *  Our processing has succeeded.
         *  So pass this IRP down to the next driver.
         */

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               HumPnpCompletion,
                               &event,    // context
                               TRUE,                       
                               TRUE,
                               TRUE );                     
        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
     
        if (ntStatus == STATUS_PENDING) {
           // wait for it...
           KeWaitForSingleObject(&event, 
                                 Executive, 
                                 KernelMode, 
                                 FALSE,
                                 NULL);
        }
        
        ntStatus = Irp->IoStatus.Status;
    
        switch(irpSp->MinorFunction) {
        case IRP_MN_START_DEVICE:
            if (NT_SUCCESS(ntStatus)) {
                DeviceExtension->DeviceState = DEVICE_STATE_RUNNING;

                ntStatus = HumInitDevice(DeviceObject);

                if (!NT_SUCCESS(ntStatus)) {
                    DBGWARN(("HumInitDevice failed; failing IRP_MN_START_DEVICE."));
                    DeviceExtension->DeviceState = DEVICE_STATE_START_FAILED;
                    Irp->IoStatus.Status = ntStatus;
                }
            }
            else {
                DBGWARN(("Pdo failed start irp with status %x", ntStatus));
                DeviceExtension->DeviceState = DEVICE_STATE_START_FAILED;
            }
            break;

        case IRP_MN_STOP_DEVICE:

            DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

            /*
             *  Release resources
             */
            if (DeviceExtension->Interface) {
                ExFreePool(DeviceExtension->Interface);
                DeviceExtension->Interface = NULL;
            }
            if (DeviceExtension->DeviceDescriptor) {
                ExFreePool(DeviceExtension->DeviceDescriptor);
                DeviceExtension->DeviceDescriptor = NULL;
            }
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            /*
             *  The lower driver set the capabilities flags for this device.
             *  Since all USB devices are hot-unpluggable,
             *  add the SurpriseRemovalOK bit.
             */
            if (NT_SUCCESS(ntStatus)){
                irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
            }
            break;
        }
    } else {
        DBGWARN(("A PnP irp is going to be failed. Status = %x.", ntStatus));
    }
    
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}



NTSTATUS HumPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    NTSTATUS status;
   
    ASSERT(DeviceObject);

    status = Irp->IoStatus.Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (NT_SUCCESS(status)){
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type){
            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState) {
                case PowerDeviceD0:
                    /*
                     *  We just resumed from SUSPEND.
                     *  Send down a SET_IDLE to prevent keyboards
                     *  from chattering after the resume.
                     */
                    status = HumSetIdle(DeviceObject);
/*                    if (!NT_SUCCESS(status)){
                        DBGWARN(("HumPowerCompletion: SET_IDLE failed with %xh (only matters for keyboard).", status));
                    }*/
                    break;
                }
                break;
            }

            break;
        }
    }

    return STATUS_SUCCESS;
}


/*
 ************************************************************
 *  HumPower 
 ************************************************************
 *
 *  Process Power IRPs sent to this device.
 *
 */
NTSTATUS HumPower(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS status;

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, HumPowerCompletion, NULL, TRUE, TRUE, TRUE);
    status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    return status;
}


/*
 ************************************************************
 *  HumStartDevice
 ************************************************************
 *
 *  Initializes a given instance of the UTB device on the USB.
 *
 */
NTSTATUS HumStartDevice(IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_EXTENSION DeviceExtension;
    ULONG oldDeviceState;
    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    oldDeviceState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = DEVICE_STATE_STARTING;

    /*
     *  We may have been previously stopped, in which case the AllRequestsCompleteEvent
     *  is still in the signalled state.  It's very important that we reset it to
     *  the non-signalled state so that we wait on it properly on the next stop/remove.
     */
    KeResetEvent(&DeviceExtension->AllRequestsCompleteEvent);

    ASSERT(oldDeviceState != DEVICE_STATE_REMOVING);

    if ((oldDeviceState == DEVICE_STATE_STOPPING) ||
        (oldDeviceState == DEVICE_STATE_STOPPED)  ||
        (oldDeviceState == DEVICE_STATE_REMOVING)){

        /*
         *  We did an extra decrement when the device was stopped.
         *  Now that we're restarting, we need to bump it back to zero.
         */
        NTSTATUS incStat = HumIncrementPendingRequestCount(DeviceExtension);
        ASSERT(NT_SUCCESS(incStat));
        ASSERT(DeviceExtension->NumPendingRequests == 0);
        DBGWARN(("Got start-after-stop; re-incremented pendingRequestCount"));
    }

    DeviceExtension->Interface = NULL;

    return STATUS_SUCCESS;
}




/*
 ************************************************************
 *  HumInitDevice 
 ************************************************************
 *
 *   Get the device information and attempt to initialize a configuration
 *   for a device.  If we cannot identify this as a valid HID device or
 *   configure the device, our start device function is failed.
 *
 *   Note:  This function is called from the PnP completion routine,
 *          so it cannot be pageable.
 */
NTSTATUS HumInitDevice(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc = NULL;
    ULONG DescriptorLength;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     *  Get the Device descriptor and store it in the device extension
     */
    ntStatus = HumGetDeviceDescriptor(DeviceObject, DeviceExtension);
    if (NT_SUCCESS(ntStatus)){

        /*
         *  Get config descriptor
         */
        ntStatus = HumGetConfigDescriptor(DeviceObject, &ConfigDesc, &DescriptorLength);
        if (NT_SUCCESS(ntStatus)) {

            ASSERT(ConfigDesc);

            #if DBG
                // NOTE:    This debug function is currently confused
                //          by power descriptors.  Restore when fixed.
                // DumpConfigDescriptor(ConfigDesc, DescriptorLength);
            #endif

            ntStatus = HumGetHidInfo(DeviceObject, ConfigDesc, DescriptorLength);
            if (NT_SUCCESS(ntStatus)) {

                ntStatus = HumSelectConfiguration(DeviceObject, ConfigDesc);
                if (NT_SUCCESS(ntStatus)) {
                    HumSetIdle(DeviceObject);
                }
            }

            ExFreePool(ConfigDesc);
        }

    }

    return ntStatus;
}


/*
 ************************************************************
 *  HumStopDevice
 ************************************************************
 *
 *  Stops a given instance of a device on the USB.
 *
 */
NTSTATUS HumStopDevice(IN PDEVICE_OBJECT DeviceObject)
{
    PURB        Urb;
    ULONG       Size;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    DeviceExtension->DeviceState = DEVICE_STATE_STOPPING;

    /*
     *  Abort all pending IO on the device.
     *  We do an extra decrement here, which causes the
     *  NumPendingRequests to eventually go to -1, which causes
     *  AllRequestsCompleteEvent to get set.
     *  NumPendingRequests will get reset to 0 when we re-start.
     */
    HumAbortPendingRequests(DeviceObject);
    HumDecrementPendingRequestCount(DeviceExtension);
    KeWaitForSingleObject( &DeviceExtension->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    /*
     *  Submit an open configuration Urb to the USB stack
     *  (with a NULL pointer for the configuration handle).
     */
    Size = sizeof(struct _URB_SELECT_CONFIGURATION);
    Urb = ExAllocatePoolWithTag(NonPagedPool, Size, HIDUSB_TAG);
    if (Urb){
        UsbBuildSelectConfigurationRequest(Urb, (USHORT) Size, NULL);

        ntStatus = HumCallUSB(DeviceObject, Urb);
        ASSERT(NT_SUCCESS(ntStatus));

        ExFreePool(Urb);
    } 
    else {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(ntStatus)){
        /*
         *  We will not pass this IRP down, 
         *  so our completion routine will not set the device's
         *  state to DEVICE_STATE_STOPPED; so set it here.
         */
        ASSERT(NT_SUCCESS(ntStatus));
        DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;
    }

    return ntStatus;
}



/*
 ************************************************************
 *  HumAbortPendingRequests
 ************************************************************
 *
 *
 */
NTSTATUS HumAbortPendingRequests(IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_EXTENSION deviceExtension;
    PURB urb;
    PVOID pipeHandle;
    ULONG urbSize;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION( DeviceObject );

    /*
     *  Create and send down an abort pipe request.
     */
    urbSize = sizeof(struct _URB_PIPE_REQUEST);
    urb = ExAllocatePoolWithTag(NonPagedPool, urbSize, HIDUSB_TAG);
    if (urb){
   
        if (deviceExtension->Interface &&
            (deviceExtension->Interface->NumberOfPipes != 0)){

            pipeHandle = deviceExtension->Interface->Pipes[0].PipeHandle;
            if (pipeHandle) {
                urb->UrbHeader.Length = (USHORT)urbSize;
                urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                urb->UrbPipeRequest.PipeHandle = pipeHandle;

                status = HumCallUSB(DeviceObject, urb);
                if (!NT_SUCCESS(status)){
                    DBGWARN(("URB_FUNCTION_ABORT_PIPE returned %xh in HumAbortPendingRequests", status));
                }
            }
            else {
                ASSERT(pipeHandle);
                status = STATUS_NO_SUCH_DEVICE;
            }
        }
        else {
            DBGERR(("No such device in HumAbortPendingRequests"));
            status = STATUS_NO_SUCH_DEVICE;
        }

        ExFreePool(urb);
    }
    else {
        ASSERT(urb);
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*
 ************************************************************
 *  HumPnpCompletion
 ************************************************************
 *
 */
NTSTATUS HumPnpCompletion(  IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP           Irp,
                            IN PVOID          Context)
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}


/*
 ************************************************************
 *  HumRemoveDevice
 ************************************************************
 *
 *  Removes a given instance of a device on the USB.
 *
 */
NTSTATUS HumRemoveDevice(IN PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    ULONG oldDeviceState;

    PAGED_CODE();

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    //  Set device state, this prevents new IOs from starting
    //

    oldDeviceState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = DEVICE_STATE_REMOVING;


    /*
     *  Note: RemoveDevice does an extra decrement, so we complete 
     *        the REMOVE IRP on the transition to -1, whether this 
     *        happens in RemoveDevice itself or subsequently while
     *        RemoveDevice is waiting for this event to fire.
     */
    if ((oldDeviceState == DEVICE_STATE_STOPPING) || 
        (oldDeviceState == DEVICE_STATE_STOPPED)){
        /*
         *  HumStopDevice did the extra decrement and aborted the 
         *  pending requests.
         */
    }
    else {
        HumDecrementPendingRequestCount(DeviceExtension);
    }

    //
    // Cancel any outstanding IRPs if the device was running
    //
    if (oldDeviceState == DEVICE_STATE_RUNNING){
        HumAbortPendingRequests(DeviceObject);
    } 
    else if (oldDeviceState == DEVICE_STATE_STOPPING){
        ASSERT(!(PVOID)"PnP IRPs are not synchronized! -- got REMOVE_DEVICE before STOP_DEVICE completed!");
    }

    KeWaitForSingleObject( &DeviceExtension->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    ASSERT(DeviceExtension->NumPendingRequests == -1);

    //
    // Fire and forget
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    //
    //  Release any resources
    //

    if (DeviceExtension->Interface) {
        ExFreePool(DeviceExtension->Interface);
        DeviceExtension->Interface = NULL;
    }
    
    if (DeviceExtension->DeviceDescriptor) {
        ExFreePool(DeviceExtension->DeviceDescriptor);
        DeviceExtension->DeviceDescriptor = NULL;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\inc\bluescrn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bluescrn.h

Abstract

    Private IOCTL definition for keyboard driver to use during blue screen

Author:

    Darryl Richman

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef __BLUESCRN_H__
#define __BLUESCRN_H__

#include <hidclass.h>

#define IOCTL_INTERNAL_HID_SET_BLUESCREEN                   HID_IN_CTL_CODE(99)

    // Blue Screen definitions

typedef VOID (t_BluescreenFunction)(PVOID Context, PCHAR Buffer);

    // Blue Screen IOCTL struct
typedef struct _BlueScreen {
    PVOID Context;                          // Context to pass to processing routine
    t_BluescreenFunction *BluescreenFunction;// Processing routine
    ULONG *IsBluescreenTime;                // Non zero -> blue screen happening
} BLUESCREEN, *PBLUESCREEN;


#endif  // __BLUESCRN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\inc\hidtoken.h ===
/*++

Copyright (c) 1996      Microsoft Corporation

Module Name:

        HIDPI.H

Abstract:

   Public Definitions of HID USAGES.

Environment:

    Kernel & user mode

Revision History:

    Aug-1996 : created Kenneth D. Ray

--*/

#ifndef _HIDTOKEN_H
#define _HIDTOKEN_H

#define HIDP_ITEM_LONG           0xFE
#define HIDP_ITEM_LENGTH_DATA    0x03

#define HIDP_IS_MAIN_ITEM(item)  (((item) & 0xC) == 0x0)
#define HIDP_IS_GLOBAL_ITEM(item) (((item) & 0xC) == 0x4)
#define HIDP_IS_LOCAL_ITEM(item)  (((item) & 0xC) == 0x8)
#define HIDP_IS_RESERVED_ITEM(item) (((item) & 0xC) == 0xC)

// Main Items
// Only main items with one byte data (bSize = 1) are supported.
#define HIDP_MAIN_INPUT_1        0x81
#define HIDP_MAIN_INPUT_2        0x82
#define HIDP_MAIN_OUTPUT_1       0x91
#define HIDP_MAIN_OUTPUT_2       0x92
#define HIDP_MAIN_FEATURE_1      0xB1
#define HIDP_MAIN_FEATURE_2      0xB2
#define HIDP_MAIN_COLLECTION     0xA1
#define HIDP_MAIN_ENDCOLLECTION  0xC0
#define HIDP_ISMAIN(x) (0 == ((x) & 0x0C))
#define HIDP_MAIN_COLLECTION_LINK 0x00
#define HIDP_MAIN_COLLECTION_APP  0x01

// Global Items
#define HIDP_GLOBAL_USAGE_PAGE_1   0x05  // UsagePage of 1 byte
#define HIDP_GLOBAL_USAGE_PAGE_2   0x06  // UsagePage of 2 bytes
#define HIDP_GLOBAL_USAGE_PAGE_4   0x07  // UsagePage of 4 bytes
#define HIDP_GLOBAL_LOG_MIN_1      0x15  // minimum value of size 1 byte.
#define HIDP_GLOBAL_LOG_MIN_2      0x16  // minimum value of size 2 bytes.
#define HIDP_GLOBAL_LOG_MIN_4      0x17  // minimum value of size 4 bytes.
#define HIDP_GLOBAL_LOG_MAX_1      0X25  // maximum of size 1 byte.
#define HIDP_GLOBAL_LOG_MAX_2      0X26  // maximum of size 2 bytes.
#define HIDP_GLOBAL_LOG_MAX_4      0X27  // maximum of size 4 bytes.

#define HIDP_GLOBAL_PHY_MIN_1      0x35  // minimum value of size 1 byte.
#define HIDP_GLOBAL_PHY_MIN_2      0x36  // minimum value of size 2 bytes.
#define HIDP_GLOBAL_PHY_MIN_4      0x37  // minimum value of size 4 bytes.
#define HIDP_GLOBAL_PHY_MAX_1      0X45  // maximum of size 1 byte.
#define HIDP_GLOBAL_PHY_MAX_2      0X46  // maximum of size 2 bytes.
#define HIDP_GLOBAL_PHY_MAX_4      0X47  // maximum of size 4 bytes.

#define HIDP_GLOBAL_UNIT_EXP_1     0x55  // Exponent of size 1 byte.
#define HIDP_GLOBAL_UNIT_EXP_2     0x56  // Exponent of size 2 bytes.
#define HIDP_GLOBAL_UNIT_EXP_4     0x57  // Exponent of size 4 bytes.
#define HIDP_GLOBAL_UNIT_1         0x65  // UNIT of size 1 byte.
#define HIDP_GLOBAL_UNIT_2         0x66  // UNIT of size 2 bytes.
#define HIDP_GLOBAL_UNIT_4         0x67  // UNIT of size 4 bytes.

#define HIDP_GLOBAL_REPORT_SIZE    0x75  // Report size in bits
#define HIDP_GLOBAL_REPORT_ID      0x85  // ID only size 1 byte supported
#define HIDP_GLOBAL_REPORT_COUNT_1 0x95  // Number of data fields 1 byte
#define HIDP_GLOBAL_REPORT_COUNT_2 0x96  // Number of data fields 2 bytes
#define HIDP_GLOBAL_PUSH           0xA4  // The dreaded PUSH command
#define HIDP_GLOBAL_POP            0xB4  // And the dreaded POP command

// Local Items
#define HIDP_LOCAL_USAGE_1         0x09  //
#define HIDP_LOCAL_USAGE_2         0x0A  //
#define HIDP_LOCAL_USAGE_4         0x0B  //
#define HIDP_LOCAL_USAGE_MIN_1     0x19
#define HIDP_LOCAL_USAGE_MIN_2     0x1A
#define HIDP_LOCAL_USAGE_MIN_4     0x1B
#define HIDP_LOCAL_USAGE_MAX_1     0x29
#define HIDP_LOCAL_USAGE_MAX_2     0x2A
#define HIDP_LOCAL_USAGE_MAX_4     0x2B
#define HIDP_LOCAL_DESIG_INDEX     0x39  // Designators of byte size supported
#define HIDP_LOCAL_DESIG_MIN       0x49
#define HIDP_LOCAL_DESIG_MAX       0x59
#define HIDP_LOCAL_STRING_INDEX    0x79  // String indices of size byte supported
#define HIDP_LOCAL_STRING_MIN      0x89
#define HIDP_LOCAL_STRING_MAX      0x99
#define HIDP_LOCAL_DELIMITER       0xA9

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\gameenum\exe\game.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    USBHUB.C

Abstract:

    This module contains the common private declarations for the game port
    enumerator.

Author:

    Kenneth Ray

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef GAMEENUM_H
#define GAMEENUM_H


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


#define GAME_HARDWARE_IDS L"GamePort\\XYZPDQ_1234\0"
#define GAME_HARDWARE_IDS_LENGTH sizeof (GAME_HARDWARE_IDS)


#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


WCHAR   Hardware[GAME_HARDWARE_IDS_LENGTH];


typedef struct _GAME_PORT {
    HANDLE                      File;
    // an open file handle to the gameport enumerator bus

    GAMEENUM_PORT_DESC          Desc;
    // A description of this game port

    PGAMEENUM_EXPOSE_HARDWARE   Hardware;
    // A copy of the hardware structure we want the enumerator to expose.
} GAME_PORT, *PGAME_PORT;


//
// Prototypes
//

BOOLEAN
FindKnownGamePorts (
   OUT PGAME_PORT *     GamePorts, // A array of struct _GAME_PORT.
   OUT PULONG           NumberDevices // the length in elements of this array.
   );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\hidusb\usb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usb.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"
#include <USBDLIB.H>


NTSTATUS
HumGetHidInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
    IN ULONG DescriptorLength
    )
/*++

Routine Description:

    Given a config descriptor for a device, finds whether the device has a valid
    HID interface and a valid HID descriptor in that interface.  Saves this to
    our device extension for later.

Arguments:

    DeviceObject - pointer to a device object.

    ConfigDesc - pointer to USB configuration descriptor

    DescriptorLength - length of valid data in config descriptor

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PUSB_INTERFACE_DESCRIPTOR InterfaceDesc;

    DBGPRINT(1,("HumGetHidInfo Entry"));

    /*
     *  Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     *  Init our HID descriptor
     */
    RtlZeroMemory((PUCHAR) &DeviceExtension->HidDescriptor, sizeof(USB_HID_DESCRIPTOR));

    /*
     *  Walk the interfaces
     */
    InterfaceDesc = USBD_ParseConfigurationDescriptorEx(
                                ConfigDesc,
                                ConfigDesc,
                                -1,
                                -1,
                                USB_INTERFACE_CLASS_HID,
                                -1,
                                -1);
    if (InterfaceDesc){
        PUSB_HID_DESCRIPTOR pHidDescriptor = NULL;

        ASSERT(InterfaceDesc->bLength >= sizeof(USB_INTERFACE_DESCRIPTOR));

        /*
         *  If this is a HID interface, look for a HID descriptor.
         */
        if (InterfaceDesc->bInterfaceClass == USB_INTERFACE_CLASS_HID) {
            HumParseHidInterface(DeviceExtension, InterfaceDesc, 0, &pHidDescriptor);
        }
        else {
            ASSERT(!(PVOID)"USBD_ParseConfigurationDescriptorEx returned non-HID iface descriptor!");
        }

        //
        // Did we find a HID descriptor?
        //

        if (pHidDescriptor) {

            //
            // Yes, copy HID descriptor to our private storage
            //

            DBGPRINT(1,("Copying device descriptor to DeviceExtension->HidDescriptor"));

            RtlCopyMemory((PUCHAR) &DeviceExtension->HidDescriptor, (PUCHAR) pHidDescriptor, sizeof(USB_HID_DESCRIPTOR));
        }
        else {
            DBGWARN(("Failed to find a HID Descriptor!"));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else {
        DBGWARN(("USBD_ParseConfigurationDescriptorEx() failed!"));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    DBGPRINT(1,("HumGetHidInfo Exit = 0x%x", ntStatus));

    return ntStatus;
}


NTSTATUS
HumGetDeviceDescriptor(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PDEVICE_EXTENSION DeviceData
    )
/*++

Routine Description:

    Returns a configuration descriptor for the device

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG DescriptorLength = sizeof (USB_DEVICE_DESCRIPTOR);

    DBGPRINT(1,("HumGetDeviceDescriptor Entry"));

    //
    // Get config descriptor
    //

    ntStatus = HumGetDescriptorRequest(
                        DeviceObject,
                        URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                        USB_DEVICE_DESCRIPTOR_TYPE,
                        (PVOID *) &DeviceData->DeviceDescriptor,
                        &DescriptorLength,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                        0,
                        0);

    if (NT_SUCCESS(ntStatus)){
        //
        // Dump device descriptor
        //
        ASSERT (sizeof(USB_DEVICE_DESCRIPTOR) == DescriptorLength);
        DBGPRINT(2,("Device->bLength              = 0x%x", DeviceData->DeviceDescriptor->bLength));
        DBGPRINT(2,("Device->bDescriptorType      = 0x%x", DeviceData->DeviceDescriptor->bDescriptorType));
        DBGPRINT(2,("Device->bDeviceClass         = 0x%x", DeviceData->DeviceDescriptor->bDeviceClass));
        DBGPRINT(2,("Device->bDeviceSubClass      = 0x%x", DeviceData->DeviceDescriptor->bDeviceSubClass));
        DBGPRINT(2,("Device->bDeviceProtocol      = 0x%x", DeviceData->DeviceDescriptor->bDeviceProtocol));
        DBGPRINT(2,("Device->idVendor             = 0x%x", DeviceData->DeviceDescriptor->idVendor));
        DBGPRINT(2,("Device->idProduct            = 0x%x", DeviceData->DeviceDescriptor->idProduct));
        DBGPRINT(2,("Device->bcdDevice            = 0x%x", DeviceData->DeviceDescriptor->bcdDevice));
    }
    else {
        DBGWARN(("HumGetDescriptorRequest failed w/ %xh in HumGetDeviceDescriptor", (ULONG)ntStatus));
    }

    DBGPRINT(1,("HumGetDeviceDescriptor Exit = 0x%x", ntStatus));

    return ntStatus;
}

NTSTATUS
HumGetConfigDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUSB_CONFIGURATION_DESCRIPTOR *ConfigurationDesc,
    OUT PULONG ConfigurationDescLength
    )
/*++

Routine Description:

    Returns a configuration descriptor for the device

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG DescriptorLength;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc = NULL;

    DescriptorLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);

    //
    // Just get the base config descriptor, so that we can figure out the size,
    // then allocate enough space for the entire descriptor.
    //
    ntStatus = HumGetDescriptorRequest(DeviceObject,
                                       URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                       USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                       (PVOID *) &ConfigDesc,
                                       &DescriptorLength,
                                       sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                       0,
                                       0);

    if (NT_SUCCESS(ntStatus)){

        ASSERT(DescriptorLength >= sizeof(USB_CONFIGURATION_DESCRIPTOR));

        DescriptorLength = ConfigDesc->wTotalLength;

        ExFreePool(ConfigDesc);

        if (!DescriptorLength) {
            //
            // The config descriptor is bad. Outta here.
            //
            return STATUS_DEVICE_DATA_ERROR;
        }

        //
        // Set this to NULL so we know to allocate a new buffer
        //
        ConfigDesc = NULL;

        ntStatus = HumGetDescriptorRequest(DeviceObject,
                                           URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                           USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                           (PVOID *) &ConfigDesc,
                                           &DescriptorLength,
                                           sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                           0,
                                           0);

        if (NT_SUCCESS(ntStatus)) {

            //
            // Dump config descriptor
            //

            DBGPRINT(1,("Config = 0x%x", ConfigDesc));

            DBGPRINT(2,("Config->bLength              = 0x%x", ConfigDesc->bLength));
            DBGPRINT(2,("Config->bDescriptorType      = 0x%x", ConfigDesc->bDescriptorType));
            DBGPRINT(2,("Config->wTotalLength         = 0x%x", ConfigDesc->wTotalLength));
            DBGPRINT(2,("Config->bNumInterfaces       = 0x%x", ConfigDesc->bNumInterfaces));
            DBGPRINT(2,("Config->bConfigurationValue  = 0x%x", ConfigDesc->bConfigurationValue));
            DBGPRINT(2,("Config->iConfiguration       = 0x%x", ConfigDesc->iConfiguration));
            DBGPRINT(2,("Config->bmAttributes         = 0x%x", ConfigDesc->bmAttributes));
            DBGPRINT(2,("Config->MaxPower             = 0x%x", ConfigDesc->MaxPower));

            ASSERT (ConfigDesc->bLength >= sizeof(USB_CONFIGURATION_DESCRIPTOR));

            #ifndef STRICT_COMPLIANCE
                if (ConfigDesc->bLength < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
                    DBGPRINT(1,("WARINING -- Correcting bad Config->bLength"));
                    ConfigDesc->bLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);
                }
            #endif
        }
        else {
            DBGWARN(("HumGetDescriptorRequest failed in HumGetConfigDescriptor (#1)"));
        }
    }
    else {
        DBGWARN(("HumGetDescriptorRequest failed in HumGetConfigDescriptor (#2)"));
    }

    *ConfigurationDesc = ConfigDesc;
    *ConfigurationDescLength = DescriptorLength;

    return ntStatus;
}

NTSTATUS
HumParseHidInterface(
    IN  PDEVICE_EXTENSION DeviceExtension,
    IN  PUSB_INTERFACE_DESCRIPTOR InterfaceDesc,
    IN  ULONG InterfaceLength,
    OUT PUSB_HID_DESCRIPTOR *HidDescriptor
    )
/*++

Routine Description:

    Find a valid HID descriptor in a HID Interface

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG iEndpoint;
    PUSB_ENDPOINT_DESCRIPTOR EndpointDesc;
    PUSB_COMMON_DESCRIPTOR CommonDesc;

    DBGPRINT(1,("HumParseHidInterface Entry"));

    //
    // Set to null until we find the HidDescriptor
    //

    *HidDescriptor = NULL;

    //
    // This routine should only be called on HID interface class interfaces.
    //

    ASSERT (InterfaceDesc->bInterfaceClass == USB_INTERFACE_CLASS_HID);

    //
    // Check for valid length
    //

    if (InterfaceDesc->bLength < sizeof(USB_INTERFACE_DESCRIPTOR)) {

        DBGWARN(("Interface->bLength (%d) is invalid", InterfaceDesc->bLength));
        goto Bail;
    }


    //
    // For HID 1.0 draft 4 compliance, the next descriptor is HID.  However, for earlier
    // drafts, endpoints come first and then HID.  We're trying to support both.
    //

    DeviceExtension->DeviceFlags &= ~DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE;

    //
    // What draft of HID 1.0 are we looking at?
    //

    CommonDesc = (PUSB_COMMON_DESCRIPTOR) ((ULONG_PTR)InterfaceDesc + InterfaceDesc->bLength);

    if (CommonDesc->bLength < sizeof (USB_COMMON_DESCRIPTOR)) {
        DBGWARN(("Descriptor->bLength (%d) is invalid", CommonDesc->bLength));
        goto Bail;
    }

    if (CommonDesc->bDescriptorType != USB_DESCRIPTOR_TYPE_HID) {

        DeviceExtension->DeviceFlags |= DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE;

    }
    else {
        //
        // Validate the length
        //

        if (CommonDesc->bLength == sizeof(USB_HID_DESCRIPTOR)) {

            *HidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;

            CommonDesc = (PUSB_COMMON_DESCRIPTOR)((ULONG_PTR)*HidDescriptor +
                                (*HidDescriptor)->bLength);

        }
        else {
            DBGWARN(("HID descriptor length (%d) is invalid!", CommonDesc->bLength));
            goto Bail;
        }
    }

    //
    // Walk endpoints
    //

    EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) CommonDesc;

    for (iEndpoint = 0; iEndpoint < InterfaceDesc->bNumEndpoints; iEndpoint++) {

        if (EndpointDesc->bLength < sizeof(USB_ENDPOINT_DESCRIPTOR)) {

            DBGWARN(("Endpoint->bLength (%d) is invalid", EndpointDesc->bLength));
            goto Bail;
        }

        EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) ((ULONG_PTR)EndpointDesc + EndpointDesc->bLength);
    }

    if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
        CommonDesc = (PUSB_COMMON_DESCRIPTOR) EndpointDesc;

        if (CommonDesc->bDescriptorType == USB_DESCRIPTOR_TYPE_HID) {

            *HidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;

        }
        else {
            //
            // This is either an unknown type of descriptor or the device is
            // reporting back a bad descriptor type.
            //
            DBGWARN(("Unknown descriptor in HID interface"));

            #ifndef STRICT_COMPLIANCE
                if (CommonDesc->bLength == sizeof(USB_HID_DESCRIPTOR)) {
                    DBGWARN(("WARINING -- Guessing descriptor of length %d is actually HID!", sizeof(USB_HID_DESCRIPTOR)));
                    *HidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;
                }
            #endif
        }
    }

    //
    //  End of endpoint/hid descriptor parsing.
    //

    if (*HidDescriptor) {

        DBGPRINT(1,("HidDescriptor = 0x%x", *HidDescriptor));

        DBGPRINT(2,("HidDescriptor->bLength          = 0x%x", (*HidDescriptor)->bLength));
        DBGPRINT(2,("HidDescriptor->bDescriptorType  = 0x%x", (*HidDescriptor)->bDescriptorType));
        DBGPRINT(2,("HidDescriptor->bcdHID           = 0x%x", (*HidDescriptor)->bcdHID));
        DBGPRINT(2,("HidDescriptor->bCountryCode     = 0x%x", (*HidDescriptor)->bCountry));
        DBGPRINT(2,("HidDescriptor->bNumDescriptors  = 0x%x", (*HidDescriptor)->bNumDescriptors));
        DBGPRINT(2,("HidDescriptor->bReportType      = 0x%x", (*HidDescriptor)->bReportType));
        DBGPRINT(2,("HidDescriptor->wReportLength    = 0x%x", (*HidDescriptor)->wReportLength));
     }

Bail:

    if (*HidDescriptor == NULL) {

        //
        // We did not find a HID descriptor in this interface!
        //

        DBGWARN(("Failed to find a valid HID descriptor in interface!"));
        DBGBREAK;

        ntStatus = STATUS_UNSUCCESSFUL;
    }


    DBGPRINT(1,("HumParseHidInterface Exit = 0x%x", ntStatus));

    return ntStatus;
}


NTSTATUS
HumSelectConfiguration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++

Routine Description:

    Initializes an USB device which may have multiple interfaces

Arguments:

    DeviceObject - pointer to the device object

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
    USBD_INTERFACE_LIST_ENTRY interfaceList[2];
    PUSBD_INTERFACE_INFORMATION usbInterface;

    DBGPRINT(1,("HumSelectConfiguration Entry"));

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    interfaceList[0].InterfaceDescriptor =
        USBD_ParseConfigurationDescriptorEx(
                        ConfigurationDescriptor,
                        ConfigurationDescriptor,
                        -1,
                        -1,
                        USB_INTERFACE_CLASS_HID,
                        -1,
                        -1);

    // terminate the list
    interfaceList[1].InterfaceDescriptor =
        NULL;

    if (interfaceList[0].InterfaceDescriptor) {

        urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,
                &interfaceList[0]);

        if (urb) {

            ntStatus = HumCallUSB(DeviceObject, urb);

            //
            // If the device is configured, save the configuration handle
            //
            if (NT_SUCCESS(ntStatus)) {
                DeviceExtension->ConfigurationHandle = urb->UrbSelectConfiguration.ConfigurationHandle;


                //
                // Now we need to find the HID interface and save the pointer to it
                //

                usbInterface = &urb->UrbSelectConfiguration.Interface;

                ASSERT(usbInterface->Class == USB_INTERFACE_CLASS_HID);

                DBGPRINT(1,("USBD Interface = 0x%x", usbInterface));

            }
            else {
                DBGWARN(("HumCallUSB failed in HumSelectConfiguration"));
                DeviceExtension->ConfigurationHandle = NULL;
            }

        }
        else {
            DBGWARN(("USBD_CreateConfigurationRequestEx failed in HumSelectConfiguration"));
            ntStatus = STATUS_NO_MEMORY;
        }
    }
    else {
        DBGWARN(("Bad interface descriptor in HumSelectConfiguration"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(ntStatus)) {

        DeviceExtension->Interface = ExAllocatePoolWithTag(NonPagedPool, usbInterface->Length, HIDUSB_TAG);

        if (DeviceExtension->Interface) {

            //
            // save a copy of the interface information returned
            //

            RtlCopyMemory(DeviceExtension->Interface, usbInterface, usbInterface->Length);

            #if DBG
                {
                    ULONG j;
                    //
                    // Dump the interface to the debugger
                    //
                    DBGPRINT (2,("---------"));
                    DBGPRINT (2,("NumberOfPipes 0x%x", DeviceExtension->Interface->NumberOfPipes));
                    DBGPRINT (2,("Length 0x%x", DeviceExtension->Interface->Length));
                    DBGPRINT (2,("Alt Setting 0x%x", DeviceExtension->Interface->AlternateSetting));
                    DBGPRINT (2,("Interface Number 0x%x", DeviceExtension->Interface->InterfaceNumber));
                    DBGPRINT (2,("Class, subclass, protocol 0x%x 0x%x 0x%x",
                        DeviceExtension->Interface->Class,
                        DeviceExtension->Interface->SubClass,
                        DeviceExtension->Interface->Protocol));

                    // Dump the pipe info

                    for (j=0; j<DeviceExtension->Interface->NumberOfPipes; j++) {
                        PUSBD_PIPE_INFORMATION pipeInformation;

                        pipeInformation = &DeviceExtension->Interface->Pipes[j];

                        DBGPRINT (2,("---------"));
                        DBGPRINT (2,("PipeType 0x%x", pipeInformation->PipeType));
                        DBGPRINT (2,("EndpointAddress 0x%x", pipeInformation->EndpointAddress));
                        DBGPRINT (2,("MaxPacketSize 0x%x", pipeInformation->MaximumPacketSize));
                        DBGPRINT (2,("Interval 0x%x", pipeInformation->Interval));
                        DBGPRINT (2,("Handle 0x%x", pipeInformation->PipeHandle));
                        DBGPRINT (2,("MaximumTransferSize 0x%x", pipeInformation->MaximumTransferSize));
                    }

                    DBGPRINT (2,("---------"));
                }
            #endif

        }
    }

    if (urb) {
        ExFreePool(urb);
    }

    DBGPRINT(1,("HumSelectConfiguration Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS HumSetIdle(IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:

    Initializes the idle timeout value for a HID device

Arguments:

    DeviceObject - pointer to the device object for this instance of a UTB

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PURB Urb;
    ULONG TypeSize;
    PDEVICE_EXTENSION DeviceExtension;

    DBGPRINT(1,("HumSetIdle Enter"));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (DeviceExtension) {
        //
        // Allocate buffer
        //

        TypeSize = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        Urb = ExAllocatePoolWithTag(NonPagedPool, TypeSize, HIDUSB_TAG);

        if(Urb) {
            RtlZeroMemory(Urb, TypeSize);

            if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
                HumBuildClassRequest(Urb,
                                    URB_FUNCTION_CLASS_ENDPOINT,   // function
                                    0,              // transferFlags
                                    NULL,           // transferBuffer
                                    0,              // transferBufferLength
                                    0x22,           // requestTypeFlags
                                    HID_SET_IDLE,   // request
                                    0,              // value
                                    0,              // index
                                    0);             // reqLength
            } else {
                HumBuildClassRequest(Urb,
                                    URB_FUNCTION_CLASS_INTERFACE,   // function
                                    0,                                  // transferFlags
                                    NULL,                               // transferBuffer
                                    0,                                  // transferBufferLength
                                    0x22,                               // requestTypeFlags
                                    HID_SET_IDLE,                       // request
                                    0,                                  // value
                                    DeviceExtension->Interface->InterfaceNumber,    // index
                                    0);                                 // reqLength
            }

            ntStatus = HumCallUSB(DeviceObject, Urb);

            ExFreePool(Urb);
        }
        else {
            ntStatus = STATUS_NO_MEMORY;
        }
    }
    else {
        ntStatus = STATUS_NOT_FOUND;
    }

    DBGPRINT(1,("HumSetIdle Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS
HumGetDescriptorRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT Function,
    IN ULONG DescriptorType,
    IN OUT PVOID *Descriptor,
    IN OUT ULONG *DescSize,
    IN ULONG TypeSize,
    IN ULONG Index,
    IN ULONG LangID
    )
/*++

Routine Description:

    Retrieves the specified descriptor for this device. Allocates buffer, if
    necessary.

Arguments:

    DeviceObject - pointer to the device object
    Function -


Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PURB Urb;
    BOOLEAN AllocOnBehalf = FALSE;

    DBGPRINT(1,("HumGetDescriptorRequest Enter"));
    DBGPRINT(1,("DeviceObject = %x", DeviceObject));

    //
    // Allocate Descriptor buffer
    //
    Urb = ExAllocatePoolWithTag(NonPagedPool, TypeSize, HIDUSB_TAG);
    if (Urb){

        RtlZeroMemory(Urb, TypeSize);

        //
        // Allocate Buffer for Caller if wanted
        //

        if (!*Descriptor){
            ASSERT(*DescSize > 0);
            *Descriptor = ExAllocatePoolWithTag(NonPagedPool, *DescSize, HIDUSB_TAG);
            AllocOnBehalf = TRUE;
        }

        if (*Descriptor){
            RtlZeroMemory(*Descriptor, *DescSize);
            HumBuildGetDescriptorRequest(Urb,
                                         (USHORT) Function,
                                         (SHORT)TypeSize,
                                         (UCHAR) DescriptorType,
                                         (UCHAR) Index,
                                         (USHORT) LangID,
                                         *Descriptor,
                                         NULL,
                                         *DescSize,
                                         NULL);

            ntStatus = HumCallUSB(DeviceObject, Urb);
            if (NT_SUCCESS(ntStatus)){
                DBGPRINT(1,("Descriptor = %x, length = %x, status = %x", *Descriptor, Urb->UrbControlDescriptorRequest.TransferBufferLength, Urb->UrbHeader.Status));

                if (USBD_SUCCESS(Urb->UrbHeader.Status)){
                    ntStatus = STATUS_SUCCESS;
                    *DescSize = Urb->UrbControlDescriptorRequest.TransferBufferLength;
                }
                else {
                    ntStatus = STATUS_UNSUCCESSFUL;
                    goto HumGetDescriptorRequestFailure;
                }
            }
            else {
HumGetDescriptorRequestFailure:
                if (AllocOnBehalf) {
                    ExFreePool(*Descriptor);
                    *Descriptor = NULL;
                }
                *DescSize = 0;
            }
        }
        else {
            ntStatus = STATUS_NO_MEMORY;
        }

        ExFreePool(Urb);
    }
    else {
        ntStatus = STATUS_NO_MEMORY;
    }

    DBGPRINT(1,("HumGetDescriptorRequest Exit = %x", ntStatus));

    return ntStatus;
}

NTSTATUS HumCallUsbComplete(IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PKEVENT Event)
{
    ASSERT(Event);
    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS HumCallUSB(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb)
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this instance of a UTB

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    PIRP Irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION NextStack;

    DBGPRINT(2,("HumCallUSB Entry"));

    DBGPRINT(2,("DeviceObject = %x", DeviceObject));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPRINT(2,("DeviceExtension = %x", DeviceExtension));

    //
    // issue a synchronous request to read the UTB
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB,
                                        GET_NEXT_DEVICE_OBJECT(DeviceObject),
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE, /* INTERNAL */
                                        &event,
                                        &ioStatus);

    if (Irp){
        DBGPRINT(2,("Irp = %x", Irp));

        DBGPRINT(2,("PDO = %x", GET_NEXT_DEVICE_OBJECT(DeviceObject)));

        //
        // Set a completion routine so that we can avoid this race condition:
        // 1) Wait times out.
        // 2) Irp completes and gets freed
        // 3) We call IoCancelIrp (boom!)
        //
        IoSetCompletionRoutine(
            Irp,
            HumCallUsbComplete,
            &event,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // pass the URB to the USB 'class driver'
        //

        NextStack = IoGetNextIrpStackLocation(Irp);
        ASSERT(NextStack != NULL);

        DBGPRINT(2,("NextStack = %x", NextStack));

        NextStack->Parameters.Others.Argument1 = Urb;

        DBGPRINT(2,("Calling USBD"));

        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

        DBGPRINT(2,("IoCallDriver(USBD) = %x", ntStatus));

        if (ntStatus == STATUS_PENDING) {
            NTSTATUS waitStatus;

            /*
             *  Specify a timeout of 5 seconds for this call to complete.
             */
            static LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

            DBGPRINT(2,("Wait for single object"));
            waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeout);
            if (waitStatus == STATUS_TIMEOUT){

                DBGWARN(("URB timed out after 5 seconds in HumCallUSB() !!"));

                //
                //  Cancel the Irp we just sent.
                //
                IoCancelIrp(Irp);

                //
                //  Now wait for the Irp to be cancelled/completed below
                //
                waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

                /*
                 *  Note - Return STATUS_IO_TIMEOUT, not STATUS_TIMEOUT.
                 *  STATUS_IO_TIMEOUT is an NT error status, STATUS_TIMEOUT is not.
                 */
                ioStatus.Status = STATUS_IO_TIMEOUT;
            }

            DBGPRINT(2,("Wait for single object returned %x", waitStatus));

        }

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        if (ntStatus == STATUS_PENDING) {
            //
            // If the request was asynchronous, the iostatus field has
            // our real status.
            //
            ntStatus = ioStatus.Status;
        }

        DBGPRINT(2,("URB status = %x status = %x", Urb->UrbHeader.Status, ntStatus));
    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2,("HumCallUSB Exit = %x", ntStatus));

    return ntStatus;
}



#if DBG
    NTSTATUS DumpConfigDescriptor(  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
                                    IN ULONG DescriptorLength)
    /*++

    Routine Description:

        Dumps a given config descriptor

    Arguments:

        ConfigDesc - pointer to the USB configuration descriptor

        DescriptorLength - length of config descriptor

    Return Value:

        NT status code.

    --*/
    {
        NTSTATUS ntStatus = STATUS_SUCCESS;
        ULONG iInterface;
        ULONG iEndpoint;
        ULONG iCommon;
        PUSB_INTERFACE_DESCRIPTOR InterfaceDesc;
        PUSB_ENDPOINT_DESCRIPTOR EndpointDesc;
        PUSB_COMMON_DESCRIPTOR CommonDesc;
        PUSB_HID_DESCRIPTOR pHidDescriptor = NULL;
        PVOID EndOfDescriptor;

        //
        // Determine end of valid data
        //

        if (ConfigDesc->wTotalLength > DescriptorLength) {
            EndOfDescriptor = (PVOID)((ULONG_PTR)ConfigDesc + DescriptorLength);
        }
        else {
            EndOfDescriptor = (PVOID)((ULONG_PTR)ConfigDesc + ConfigDesc->wTotalLength);
        }

        DBGPRINT(2,("EndOfDescriptor = 0x%x", EndOfDescriptor));


        //
        // Begin parsing config descriptor
        //

        DBGPRINT(2,("Config = 0x%x", ConfigDesc));

        DBGPRINT(2,("Config->bLength              = 0x%x", ConfigDesc->bLength));
        DBGPRINT(2,("Config->bDescriptorType      = 0x%x", ConfigDesc->bDescriptorType));
        DBGPRINT(2,("Config->wTotalLength         = 0x%x", ConfigDesc->wTotalLength));
        DBGPRINT(2,("Config->bNumInterfaces       = 0x%x", ConfigDesc->bNumInterfaces));
        DBGPRINT(2,("Config->bConfigurationValue  = 0x%x", ConfigDesc->bConfigurationValue));
        DBGPRINT(2,("Config->iConfiguration       = 0x%x", ConfigDesc->iConfiguration));
        DBGPRINT(2,("Config->bmAttributes         = 0x%x", ConfigDesc->bmAttributes));
        DBGPRINT(2,("Config->MaxPower             = 0x%x", ConfigDesc->MaxPower));

        ASSERT (ConfigDesc->bLength >= sizeof(USB_CONFIGURATION_DESCRIPTOR));

        #ifndef STRICT_COMPLIANCE
            if (ConfigDesc->bLength < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
                DBGPRINT(2,("WARINING -- Correcting bad Config->bLength"));
                ConfigDesc->bLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);
            }
        #endif

        //
        // Walk interfaces
        //

        InterfaceDesc = (PUSB_INTERFACE_DESCRIPTOR) ((ULONG_PTR)ConfigDesc + ConfigDesc->bLength);

        for (iInterface = 0; iInterface < ConfigDesc->bNumInterfaces; iInterface++) {

            DBGPRINT(2,("Interface[%d] = 0x%x", iInterface, InterfaceDesc));

            DBGPRINT(2,("Interface[%d]->bLength             = 0x%x", iInterface, InterfaceDesc->bLength));
            DBGPRINT(2,("Interface[%d]->bDescriptorType     = 0x%x", iInterface, InterfaceDesc->bDescriptorType));
            DBGPRINT(2,("Interface[%d]->bInterfaceNumber    = 0x%x", iInterface, InterfaceDesc->bNumEndpoints));
            DBGPRINT(2,("Interface[%d]->bAlternateSetting   = 0x%x", iInterface, InterfaceDesc->bAlternateSetting));
            DBGPRINT(2,("Interface[%d]->bNumEndpoints       = 0x%x", iInterface, InterfaceDesc->bNumEndpoints));
            DBGPRINT(2,("Interface[%d]->bInterfaceClass     = 0x%x", iInterface, InterfaceDesc->bInterfaceClass));
            DBGPRINT(2,("Interface[%d]->bInterfaceSubClass  = 0x%x", iInterface, InterfaceDesc->bInterfaceSubClass));
            DBGPRINT(2,("Interface[%d]->bInterfaceProtocol  = 0x%x", iInterface, InterfaceDesc->bInterfaceProtocol));
            DBGPRINT(2,("Interface[%d]->iInterface          = 0x%x", iInterface, InterfaceDesc->iInterface));

            ASSERT (InterfaceDesc->bLength >= sizeof(USB_INTERFACE_DESCRIPTOR));

            CommonDesc = (PUSB_COMMON_DESCRIPTOR) ((ULONG_PTR)InterfaceDesc + InterfaceDesc->bLength);

            if (CommonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) {
                DBGPRINT(2,("HID Device < HID 1.0 Draft 4 spec compliant"));

                //
                // Walk endpoints for old style device
                //

                EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) CommonDesc;

                for (iEndpoint = 0; iEndpoint < InterfaceDesc->bNumEndpoints; iEndpoint++) {

                    DBGPRINT(2,("Endpoint[%d] = 0x%x", iEndpoint, EndpointDesc));

                    DBGPRINT(2,("Endpoint[%d]->bLength           = 0x%x", iEndpoint, EndpointDesc->bLength));
                    DBGPRINT(2,("Endpoint[%d]->bDescriptorType   = 0x%x", iEndpoint, EndpointDesc->bDescriptorType));
                    DBGPRINT(2,("Endpoint[%d]->bEndpointAddress  = 0x%x", iEndpoint, EndpointDesc->bEndpointAddress));

                    ASSERT (EndpointDesc->bLength >= sizeof(USB_ENDPOINT_DESCRIPTOR));

                    EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) ((ULONG_PTR)EndpointDesc + EndpointDesc->bLength);
                }

                CommonDesc = (PUSB_COMMON_DESCRIPTOR) EndpointDesc;

            }
            else {
                DBGPRINT(2,("HID Device is HID 1.0 Draft 4 compliant"));
            }

            //
            // Walk misc/common descriptors
            //

            iCommon = 0;

            while (((PVOID)CommonDesc < EndOfDescriptor) &&
                    (CommonDesc->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE) &&
                    (CommonDesc->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE)) {

                DBGPRINT(2,("Common[%d] = 0x%x", iCommon, CommonDesc));

                DBGPRINT(2,("Common[%d]->bLength          = 0x%x", iCommon, CommonDesc->bLength));
                DBGPRINT(2,("Common[%d]->bDescriptorType  = 0x%x", iCommon, CommonDesc->bDescriptorType));

                ASSERT (CommonDesc->bLength >= sizeof(USB_COMMON_DESCRIPTOR));


                if (CommonDesc->bLength == 0) {
                    DBGPRINT(2,("WARNING: Common[%d]->bLength          = 0x%x", iCommon, CommonDesc->bLength));
                    break;
                }

                //
                // Is this a HID Interface?
                //

                if (InterfaceDesc->bInterfaceClass == USB_INTERFACE_CLASS_HID) {

                    //
                    // Is this the HID Descriptor?
                    //

                    if (CommonDesc->bDescriptorType == USB_DESCRIPTOR_TYPE_HID) {

                        pHidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;

                    }
                    else {
                        //
                        // This is either an unknown type of descriptor or the device is
                        // reporting back a bad descriptor type.
                        //
                        DBGPRINT(2,("WARINING -- Unknown descriptor in HID interface"));

                        #ifndef STRICT_COMPLIANCE
                            if (CommonDesc->bLength == sizeof(USB_HID_DESCRIPTOR)) {
                                DBGPRINT(2,("WARINING -- Guessing descriptor of length %d is actually HID!", sizeof(USB_HID_DESCRIPTOR)));
                                pHidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;
                                break;
                            }
                        #endif
                    }
                }

                CommonDesc = (PUSB_COMMON_DESCRIPTOR) ((ULONG_PTR)CommonDesc + CommonDesc->bLength);
                iCommon++;
            }


            if (CommonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) {
                //
                // Walk endpoints for full draft 4 HID 1.0 device
                //

                EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) CommonDesc;

                for (iEndpoint = 0; iEndpoint < InterfaceDesc->bNumEndpoints; iEndpoint++) {

                    DBGPRINT(2,("Endpoint[%d] = 0x%x", iEndpoint, EndpointDesc));

                    DBGPRINT(2,("Endpoint[%d]->bLength           = 0x%x", iEndpoint, EndpointDesc->bLength));
                    DBGPRINT(2,("Endpoint[%d]->bDescriptorType   = 0x%x", iEndpoint, EndpointDesc->bDescriptorType));
                    DBGPRINT(2,("Endpoint[%d]->bEndpointAddress  = 0x%x", iEndpoint, EndpointDesc->bEndpointAddress));

                    ASSERT (EndpointDesc->bLength >= sizeof(USB_ENDPOINT_DESCRIPTOR));

                    EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) ((ULONG_PTR)EndpointDesc + EndpointDesc->bLength);
                }

                CommonDesc = (PUSB_COMMON_DESCRIPTOR) EndpointDesc;
            }

            //
            // If we have found the HID descriptor, we don't need to look at the
            // rest of the interfaces for this device.
            //

            if (pHidDescriptor) {
                break;
            }

            InterfaceDesc = (PUSB_INTERFACE_DESCRIPTOR) CommonDesc;
        }

        if (pHidDescriptor) {

            ASSERT (pHidDescriptor->bLength >= sizeof(USB_HID_DESCRIPTOR));


            DBGPRINT(2,("pHidDescriptor = 0x%x", pHidDescriptor));

            DBGPRINT(2,("pHidDescriptor->bLength          = 0x%x", pHidDescriptor->bLength));
            DBGPRINT(2,("pHidDescriptor->bDescriptorType  = 0x%x", pHidDescriptor->bDescriptorType));
            DBGPRINT(2,("pHidDescriptor->bcdHID           = 0x%x", pHidDescriptor->bcdHID));
            DBGPRINT(2,("pHidDescriptor->bCountryCode     = 0x%x", pHidDescriptor->bCountry));
            DBGPRINT(2,("pHidDescriptor->bNumDescriptors  = 0x%x", pHidDescriptor->bNumDescriptors));
            DBGPRINT(2,("pHidDescriptor->bReportType      = 0x%x", pHidDescriptor->bReportType));
            DBGPRINT(2,("pHidDescriptor->wReportLength    = 0x%x", pHidDescriptor->wReportLength));

        }
        else {

            //
            // We did not find a HID interface or HID descriptor!
            //

            DBGPRINT(2,("Failed to find a HID Descriptor!"));
            DBGBREAK;

            ntStatus = STATUS_UNSUCCESSFUL;

        }

        return ntStatus;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\gameenum\exe\locate.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    locate.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    Kernel & user mode

@@BEGIN_DDKSPLIT
Revision History:

    Nov-96 : Created by Kenneth D. Ray
    
@@END_DDKSPLIT

--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include <initguid.h>
#include <stdio.h>
#include <winioctl.h>
#include "gameport.h"
#include "game.h"

#define USAGE "Usage: gameenum [-e] [-r]\n" \
"\t -e Expose -hardware\n"  \
"\t -r Remove hardware\n"

BOOLEAN bExpose,bRemove;

__cdecl main (int argc, char *argv[])
{
    PGAME_PORT      GamePorts; // A array of struct _GAME_PORT.
    ULONG           NumberDevices; // the length in elements of this array.

    bExpose = bRemove = FALSE;

    if(argc <2) {
end:    printf(USAGE);
        exit(0);
    }
    if(argv[1][0] == '-')
    {
        if(argv[1][1] == 'e' || argv[1][1] == 'E')
            bExpose = TRUE;
        else if(argv[1][1] == 'r' || argv[1][1] == 'R')
            bRemove = TRUE;
        else
            goto end;
    }
    else
        goto end;

    if( !FindKnownGamePorts (&GamePorts, &NumberDevices) )
        printf("Error: FindKnownGamePorts returned FALSE\n");

    return 0;
}

BOOLEAN
OpenGamePort (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
    IN OUT   PGAME_PORT                  GamePort
    );

BOOLEAN
FindKnownGamePorts (
   OUT PGAME_PORT *     GamePorts, // A array of struct _GAME_PORT.
   OUT PULONG           NumberDevices // the length in elements of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find, the all the HID devices in
   the system at this time.
--*/
{
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PGAME_PORT               gamePortInst;
   LPGUID                   gamePortGuid;

   gamePortGuid = (LPGUID) &GUID_GAMEENUM_BUS_ENUMERATOR;

   *GamePorts = NULL;
   *NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           gamePortGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess to start
   //
   *NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      *NumberDevices *= 2;

      if (*GamePorts) {
         *GamePorts =
               realloc (*GamePorts, (*NumberDevices * sizeof (GAME_PORT)));
      } else {
         *GamePorts = calloc (*NumberDevices, sizeof (GAME_PORT));
      }

      if (NULL == *GamePorts) {
         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return FALSE;
      }

      gamePortInst = *GamePorts + i;

      for (; i < *NumberDevices; i++, gamePortInst++) {
         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                          0, // No care about specific PDOs
                                          gamePortGuid,
                                          i,
                                          &deviceInfoData)) {

            if( !OpenGamePort (hardwareDeviceInfo, &deviceInfoData, gamePortInst) )
                printf("Error: OpenGamePort returned FALSE\n");

         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   *NumberDevices = i;

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   return TRUE;
}

BOOLEAN
OpenGamePort (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
    IN OUT   PGAME_PORT                  GamePort
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    ULONG                                i, bytes;
    GAMEENUM_REMOVE_HARDWARE             remove;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    if (functionClassDeviceData == NULL) {
        printf("Allocation failed, could not get details!\n");
        return FALSE;
    }
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
        printf("Error in SetupDiGetDeviceInterfaceDetail\n");
        free (functionClassDeviceData);
        return FALSE;
    }

    printf("Opening %s\n", functionClassDeviceData->DevicePath);

    GamePort->File = CreateFile (
                              functionClassDeviceData->DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              0, // FILE_SHARE_READ | FILE_SHARE_WRITE
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              0, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == GamePort->File) {
        printf("Error in CreateFile: %x", GetLastError());
        free (functionClassDeviceData);
        return FALSE;
    }
    printf("File Opened!!!\n");

    GamePort->Desc.Size = sizeof (GamePort->Desc);

    if (!DeviceIoControl (GamePort->File,
                          IOCTL_GAMEENUM_PORT_DESC,
                          &GamePort->Desc, sizeof (GamePort->Desc),
                          &GamePort->Desc, sizeof (GamePort->Desc),
                          &bytes, NULL)) {
        printf("Error in DeviceIoctl IOCTL_GAMEENUM_PORT_DESC: %x", GetLastError());
        free (functionClassDeviceData);
        return FALSE;
    }

    printf("Description: Size (%d), Handle (0x%p), Address (0x%p) \n",
           GamePort->Desc.Size,
           GamePort->Desc.PortHandle,
           GamePort->Desc.PortAddress);


    //
    // Set the port up
    //
    if(bExpose) {
        printf("\nThis handle is not valid for remove!!!\n\nExposing port\n");

        GamePort->Hardware = malloc (bytes = (sizeof (GAMEENUM_EXPOSE_HARDWARE) +
                                              GAME_HARDWARE_IDS_LENGTH));
        if (GamePort->Hardware == NULL) {
            printf("Allocation failed, could not expose hardware!\n");
            return FALSE;                                                            
        }

        GamePort->Hardware->Size = sizeof (GAMEENUM_EXPOSE_HARDWARE);
        GamePort->Hardware->PortHandle = GamePort->Desc.PortHandle;
        printf("Enter Number of Joysticks:");
        scanf("%d",&GamePort->Hardware->NumberJoysticks);
        printf("Enter Number of Buttons:");
        scanf("%d", &GamePort->Hardware->NumberButtons); 
        printf("Enter Number of Axes:");
        scanf("%d", &GamePort->Hardware->NumberAxis);
        memcpy (GamePort->Hardware->HardwareIDs,
                GAME_HARDWARE_IDS,
                GAME_HARDWARE_IDS_LENGTH);

        if (!DeviceIoControl (GamePort->File,
                              IOCTL_GAMEENUM_EXPOSE_HARDWARE,
                              GamePort->Hardware, bytes,
                              GamePort->Hardware, bytes,
                              &bytes, NULL)) {
              free (functionClassDeviceData);
              free (GamePort->Hardware);
              GamePort->Hardware = NULL;
              printf("Error in DeviceIoctl IOCTL_GAMEENUM_EXPOSE_HARDWARE:  0x%x\n", GetLastError());
              return FALSE;
        }
        printf("Hardware handle 0x%p   <-----  Save this handle!!!\n",GamePort->Hardware->HardwareHandle);
        printf("\t\tGameEnum -r will not be able retrieve it for you.\n");

        free (GamePort->Hardware);
        GamePort->Hardware = NULL;
    }

    if(bRemove) {
        printf("Removing  port\n");

        remove.Size = bytes = sizeof (remove);
        printf("Enter hardware handle: ");
        scanf("%x",&remove.HardwareHandle);
        printf("Entered Handle: %p", remove.HardwareHandle);
   
        if (!DeviceIoControl (GamePort->File,
                              IOCTL_GAMEENUM_REMOVE_HARDWARE,
                              &remove, bytes,
                              &remove, bytes,
                              &bytes, NULL)) {
            printf("Error in DeviceIoctl IOCTL_GAMEENUM_REMOVE_HARDWARE:  0x%x\n", GetLastError());
            return FALSE;
        }
    }

    free (functionClassDeviceData);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\gameenum\exe\select.c ===
#include <windows.h>
#include <winnt.h>
#include <subauth.h>

#include <stdarg.h>
#include <stdio.h>
#include <winioctl.h>
#include "gameport.h"
#include <malloc.h>

#define IRP_MJ_INTERNAL_DEVICE_CONTROL 0x0f;


int __cdecl
main(int argc, char **argv) {

   HANDLE     hand;

   if (INVALID_HANDLE_VALUE
         == (hand = CreateFile(
                        STIM_SYM_ANAME,
                        GENERIC_READ | GENERIC_WRITE,
                        0,              /* No sharing */
                        NULL,           /* No Security */
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL            /* No temp file handle */
                        )))
   {
      printf ("Can't get a handle to the driver %d\n",
              GetLastError());
      return -2;
   }

   printf("Wow - it really worked!!!\n");

   helloIn.Len = helloOut.Len = sizeof (in);
   helloIn.Buffer = in;
   helloOut.Buffer = out;
   status = DeviceIoControl (hand, IOCTL_STIM_HELLO,
                             &helloIn, sizeof (STIM_HELLO),
                             &helloOut,sizeof (STIM_HELLO),
                             &bytes, NULL);
   printf ("Status: 0x%x, 0x%x\n", status, GetLastError());
   printf ("This is what I did received: (%d) %s\n", bytes, out);


   printf("calling Stim connect\n");
   connect.DesiredAccess = FILE_ALL_ACCESS;
   connect.DeviceObjectName = STUB_DEVICE_NAME;

   status = DeviceIoControl (hand, IOCTL_STIM_CONNECT,
                             &connect, sizeof (STIM_CONNECT),
                             NULL, 0,
                             &bytes, NULL);
   printf ("Status: 0x%x, 0x%x\n", status, GetLastError());
   printf ("This is what I really received: %d\n", bytes);


   junk.Thing = 37;
   junk.Hello = in;
   junk.Jello = out;
   junk.Status = 15;


   memory = malloc (bytes = (sizeof (STIM_CALL_DRIVER_MEMORY) +
                             sizeof (STIM_CALL_DRIVER_MEMORY_ITEM) * 3));
   memset (memory, 0, bytes);

   pointer = malloc (bytes = (sizeof (STIM_CALL_DRIVER_POINTER) +
                              sizeof (STIM_CALL_DRIVER_POINTER_ITEM) * 2));
   memset (pointer, 0, bytes);

   memory->Count = 3;
   memory->Memory[0].Lock = TRUE;
   memory->Memory[0].Address = &junk;
   memory->Memory[0].Length = sizeof (junk);
   memory->Memory[1].Lock = TRUE;
   memory->Memory[1].Address = in;
   memory->Memory[1].Length = strlen (in);
   memory->Memory[2].Lock = TRUE;
   memory->Memory[2].Address = out;
   memory->Memory[2].Length = strlen (out);

   pointer->Count = 2;
   pointer->Pointer[0].Address = &junk.Hello;
   pointer->Pointer[1].Address = &junk.Jello;

   memset (&call, 0, sizeof (STIM_CALL_DRIVER));

   call.MajorFunction = 0x0f; // IRP_MJ_INTERNAL_DEVICE_CONTROL
   call.MinorFunction = 0;
   call.Flags = 0;
   call.Context = (PVOID) 0x12345678;
   call.FileObject = (PVOID) 0x09876543;

   // Create a pointer to the kernel mode copy of junk;
   call.StackParameters[0].IsPointer = TRUE;
   call.StackParameters[0].Value = (ULONG) &junk;

   // a pointer to the user mode junk
   call.StackParameters[1].Value = (ULONG) &junk;

   call.Memory = memory;
   call.Pointer = pointer;

   status = DeviceIoControl (hand, IOCTL_STIM_CALL_DRIVER,
                             &call, sizeof (STIM_CALL_DRIVER),
                             NULL, 0,
                             &bytes, NULL);
   printf ("Status: 0x%x, 0x%x\n", status, GetLastError());
   printf ("This is what I really received: %d\n", bytes);

   CloseHandle (hand);

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\gameenum\sys\gameenum.c ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    GAMEENUM.C

Abstract:

    This module contains contains the entry points for a standard bus
    PNP / WDM driver.

@@BEGIN_DDKSPLIT

Author:

    Kenneth D. Ray
    Doron J. Holan

@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#include <initguid.h>
#include "gameport.h"
#include "gameenum.h"
#include "stdio.h"

//
// Global Debug Level
//

#if DBG
ULONG GameEnumDebugLevel = GAME_DEFAULT_DEBUG_OUTPUT_LEVEL;
#endif

//
// Declare some entry functions as pageable, and make DriverEntry
// discardable
//

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, Game_DriverUnload)
#pragma alloc_text (PAGE, Game_PortParameters)
#pragma alloc_text (PAGE, Game_CreateClose)
#pragma alloc_text (PAGE, Game_IoCtl)
#pragma alloc_text (PAGE, Game_InternIoCtl)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING UniRegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    PDEVICE_OBJECT  device;

    UNREFERENCED_PARAMETER (UniRegistryPath);

    Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Driver Entry\n"));

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = Game_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_SYSTEM_CONTROL] = Game_SystemControl;
    DriverObject->MajorFunction [IRP_MJ_PNP] = Game_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] = Game_Power;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = Game_IoCtl;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL]
        = Game_InternIoCtl;

    DriverObject->DriverUnload = Game_DriverUnload;
    DriverObject->DriverExtension->AddDevice = Game_AddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
Game_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:
    Some outside source is trying to create a file against us.

    If this is for the FDO (the bus itself) then the caller is trying to
    open the propriatary conection to tell us which game port to enumerate.

    If this is for the PDO (an object on the bus) then this is a client that
    wishes to use the game port.
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    KEVENT              event;
    PFDO_DEVICE_DATA    data;

    PAGED_CODE ();

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    status = Game_IncIoCount (data);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
    
    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:

        Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Create \n"));

        if (0 != irpStack->FileObject->FileName.Length) {
            //
            // The caller is trying to open a subdirectory off the device
            // object name.  This is not allowed.
            //
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_CLOSE:
        Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Close \n"));
        ;
    }

    Game_DecIoCount (data);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
Game_IoCtl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Handle user mode expose, remove, and device description requests.
    
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    ULONG                   inlen;
    ULONG                   outlen;
    PCOMMON_DEVICE_DATA     commonData;
    PFDO_DEVICE_DATA        fdoData;
    PVOID                   buffer;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // We only take Device Control requests for the FDO.
    // That is the bus itself.
    //
    // The request is one of the propriatary Ioctls for
    //
    // NB we are not a filter driver, so we do not pass on the irp.
    //

    inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outlen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (!commonData->IsFDO) {
        //
        // These commands are only allowed to go to the FDO.
        //
        status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;

    }

    if (!fdoData->Started) {
        status = STATUS_DEVICE_NOT_READY;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    status = Game_IncIoCount (fdoData);
    if (!NT_SUCCESS (status)) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // resond to external requests.
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_GAMEENUM_EXPOSE_HARDWARE:
        if ((inlen == outlen) &&
            //
            // Make sure it is at least two nulls (ie, an empty multi sz)
            // and the size field is set to the declared size of the struct
            //
            ((sizeof (GAMEENUM_EXPOSE_HARDWARE) + sizeof(UNICODE_NULL) * 2) <=
             inlen) &&

            //
            // The size field should be set to the sizeof the struct as declared
            // and *not* the size of the struct plus the multi sz
            //
            (sizeof (GAMEENUM_EXPOSE_HARDWARE) ==
             ((PGAMEENUM_EXPOSE_HARDWARE) buffer)->Size)) {

            Game_KdPrint(fdoData, GAME_DBG_IOCTL_TRACE, ("Expose called\n"));

            status= Game_Expose((PGAMEENUM_EXPOSE_HARDWARE)buffer,
                                inlen,
                                fdoData);
            Irp->IoStatus.Information = outlen;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_GAMEENUM_REMOVE_HARDWARE:

        if ((sizeof (GAMEENUM_REMOVE_HARDWARE) == inlen) &&
            (inlen == outlen) &&
            (((PGAMEENUM_REMOVE_HARDWARE)buffer)->Size == inlen)) {

            Game_KdPrint(fdoData, GAME_DBG_IOCTL_TRACE, ("Remove called\n"));

            status= Game_Remove((PGAMEENUM_REMOVE_HARDWARE)buffer, fdoData);
            Irp->IoStatus.Information = outlen;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_GAMEENUM_PORT_DESC:

        if ((sizeof (GAMEENUM_PORT_DESC) == inlen) &&
            (inlen == outlen) &&
            (((PGAMEENUM_PORT_DESC)buffer)->Size == inlen)) {

            Game_KdPrint(fdoData, GAME_DBG_IOCTL_TRACE, ("Port desc called\n"));

            //
            // Fill in the information first.  If there is a lower driver, it
            // will change replace the values that gameenum has placed in the
            // buffer.  We don't care if the call down succeeds or not
            //
            status = Game_ListPorts ((PGAMEENUM_PORT_DESC) buffer, fdoData);

            Game_SendIrpSynchronously (fdoData->TopOfStack,
                                       Irp,
                                       FALSE,
                                       TRUE); 

            Irp->IoStatus.Information = outlen;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
       break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

    Game_DecIoCount (fdoData);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
Game_InternIoCtl (
    PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

--*/
{
    PIO_STACK_LOCATION          irpStack, next;
    NTSTATUS                    status;
    PCOMMON_DEVICE_DATA         commonData;
    PPDO_DEVICE_DATA            pdoData;
    PVOID                       buffer;
    BOOLEAN                     validAccessors;
    ULONG                       inlen;
    ULONG                       outlen;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_INTERNAL_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    pdoData = (PPDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outlen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // We only take Internal Device Control requests for the PDO.
    // That is the objects on the bus (representing the game ports)
    //
    // The request is from a FDO driver attached to this game port device object
    // inquiring about the port itself.
    //
    // NB we are not a filter driver, so we do not pass on the irp.
    //

    if (commonData->IsFDO) {
        Game_KdPrint(((PFDO_DEVICE_DATA) commonData), GAME_DBG_IOCTL_ERROR,
                     ("internal ioctl called on fdo!\n"))

        status = STATUS_ACCESS_DENIED;

    } else if (!pdoData->Started) {
        //
        // The bus has not been started yet
        //
        status = STATUS_DEVICE_NOT_READY;

    } else if (pdoData->Removed) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // resond to external requests.
        //
        status = STATUS_DELETE_PENDING;

    } else {
        buffer = Irp->UserBuffer;

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_GAMEENUM_PORT_PARAMETERS:
            if ((inlen == outlen) &&
                (outlen == ((PGAMEENUM_PORT_PARAMETERS) buffer)->Size)) {
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_TRACE,
                             ("Port parameters called\n"));
    
                status = Game_PortParameters ((PGAMEENUM_PORT_PARAMETERS) buffer,
                                              pdoData);
            }
            else {
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_ERROR,
                             ("InBufLen:  %d, OutBufLen:  %d, Size:  %d\n",
                              inlen, outlen,
                             ((PGAMEENUM_PORT_PARAMETERS) buffer)->Size));
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        case IOCTL_GAMEENUM_EXPOSE_SIBLING:
            if ((inlen == outlen) &&
                //
                // Make sure that the buffer passed in is of the correct size
                //
                (sizeof (GAMEENUM_EXPOSE_SIBLING) == inlen) &&
    
                //
                // The size field should be set to the sizeof the struct 
                //
                (sizeof (GAMEENUM_EXPOSE_SIBLING) ==
                 ((PGAMEENUM_EXPOSE_SIBLING) buffer)->Size)) {
                
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_TRACE, ("Expose sibling"));
            
                status = Game_ExposeSibling ((PGAMEENUM_EXPOSE_SIBLING) buffer,
                                              pdoData);
            }
            else {
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_ERROR, 
                             ("Expected an input and output buffer lengths to be equal (in = %d, out %d)\n"
                              "Expected an input buffer length of %d, received %d\n"
                              "Expected GAME_EXPOSE_SIBLING.Size == %d, received %d\n",
                              inlen, outlen,
                              sizeof (GAMEENUM_EXPOSE_SIBLING), inlen,
                              sizeof (GAMEENUM_EXPOSE_SIBLING), 
                              ((PGAMEENUM_EXPOSE_SIBLING) buffer)->Size));

                status = STATUS_INVALID_PARAMETER;
            }

            break;

        case IOCTL_GAMEENUM_REMOVE_SELF:
            Game_KdPrint(pdoData, GAME_DBG_IOCTL_TRACE, ("Remove self\n"));

            status = Game_RemoveSelf (pdoData);
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


VOID
Game_DriverUnload (
    IN PDRIVER_OBJECT Driver
    )
/*++
Routine Description:
    Clean up everything we did in driver entry.

--*/
{
    #if (!DBG)
    UNREFERENCED_PARAMETER (Driver);
    #endif

    PAGED_CODE ();

    //
    // All the device objects should be gone.
    //

    ASSERT (NULL == Driver->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //
    return;
}


NTSTATUS
Game_PortParameters (
    PGAMEENUM_PORT_PARAMETERS   Parameters,
    PPDO_DEVICE_DATA            PdoData
    )
{
    PFDO_DEVICE_DATA            fdoData;
    GAMEENUM_ACQUIRE_ACCESSORS  gameAccessors;
    PIO_STACK_LOCATION          next;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             iosb;
    KEVENT                      event;
    PIRP                        accessorIrp;

    PAGED_CODE ();

    if (sizeof (GAMEENUM_PORT_PARAMETERS) != Parameters->Size) {
        Game_KdPrint(PdoData, GAME_DBG_IOCTL_ERROR,
                     ("Wanted %d, got %d for size of buffer\n",
                      sizeof(GAMEENUM_PORT_PARAMETERS), Parameters->Size));
        
        return STATUS_INVALID_PARAMETER;
    }

    fdoData = FDO_FROM_PDO (PdoData);

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    RtlZeroMemory(&gameAccessors, sizeof(GAMEENUM_ACQUIRE_ACCESSORS));
    gameAccessors.Size = sizeof(GAMEENUM_ACQUIRE_ACCESSORS);

    accessorIrp =
        IoBuildDeviceIoControlRequest (IOCTL_GAMEENUM_ACQUIRE_ACCESSORS,
                                       fdoData->TopOfStack,
                                       NULL,
                                       0,
                                       &gameAccessors,
                                       sizeof (GAMEENUM_PORT_PARAMETERS),
                                       TRUE,
                                       &event,
                                       &iosb);
    if (!accessorIrp) {
        goto Game_NoCustomAccessors;
    }

    status = IoCallDriver(fdoData->TopOfStack, accessorIrp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject (&event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status) ||
        !(gameAccessors.GameContext   &&
          gameAccessors.WriteAccessor && gameAccessors.ReadAccessor)) {

        //
        // If TopOfStack or below does not handle this IOCTL, we better have
        // received the necessary resources to allow our children to read and
        // write to their devices
        //
        ASSERT (fdoData->GamePortAddress != NULL);
        ASSERT (fdoData->ReadPort != NULL);
        ASSERT (fdoData->WritePort != NULL);

Game_NoCustomAccessors:
        //
        // No filter below us (either the IOCTL failed, or not all of the req. 
        // fields were filled in) ... fill in w/standard values
        //
        Parameters->ReadAccessor = fdoData->ReadPort;
        Parameters->WriteAccessor = fdoData->WritePort;
        Parameters->ReadAccessorDigital = NULL;
        Parameters->GameContext = fdoData->GamePortAddress; 
    }
    else {
        //
        // There is a filter below us, fill in w/the appropriate values
        //
        Parameters->ReadAccessor = gameAccessors.ReadAccessor;
        Parameters->WriteAccessor = gameAccessors.WriteAccessor;
        Parameters->ReadAccessorDigital = gameAccessors.ReadAccessorDigital;
        Parameters->GameContext = gameAccessors.GameContext;

        if (gameAccessors.PortContext) {
            fdoData->LowerAcquirePort = gameAccessors.AcquirePort;
            fdoData->LowerReleasePort = gameAccessors.ReleasePort;
            fdoData->LowerPortContext = gameAccessors.PortContext;
        }
    }

    //
    // Acquire/release always goes through the gameenum even if a lower
    // filter exists
    //
    Parameters->AcquirePort = (PGAMEENUM_ACQUIRE_PORT) Game_AcquirePort;
    Parameters->ReleasePort = (PGAMEENUM_RELEASE_PORT) Game_ReleasePort;
    Parameters->PortContext = fdoData;

    Parameters->Portion = PdoData->Portion;
    Parameters->NumberAxis = PdoData->NumberAxis;
    Parameters->NumberButtons = PdoData->NumberButtons;
    RtlCopyMemory (&Parameters->OemData,
                   &PdoData->OemData,
                   sizeof(GAMEENUM_OEM_DATA));

    return STATUS_SUCCESS;
}

NTSTATUS
Game_IncIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    InterlockedIncrement (&Data->OutstandingIO);
    if (Data->Removed) {

        if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
            KeSetEvent (&Data->RemoveEvent, 0, FALSE);
        }
        return STATUS_DELETE_PENDING;
    }
    return STATUS_SUCCESS;
}

VOID
Game_DecIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
        KeSetEvent (&Data->RemoveEvent, 0, FALSE);
    }
}

NTSTATUS
Game_AcquirePort(
    PFDO_DEVICE_DATA fdoData
    )
{
    if (fdoData->Removed) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) was removed....\n", fdoData));
        return STATUS_NO_SUCH_DEVICE;
    }
    else if (!fdoData->Started) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) is not started....\n", fdoData));
        return STATUS_NO_SUCH_DEVICE;
    }
    else if (!fdoData->NumPDOs) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) has no devices attached....\n", fdoData));
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // If fdoData->Acquired is TRUE, then no exchange will take place and the
    // value of fdoData->Acquired (TRUE) will be returned
    //
    if (InterlockedCompareExchange(&fdoData->Acquired, TRUE, FALSE)) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) was already acquired....\n", fdoData));
        return STATUS_DEVICE_BUSY;
    }
    
    if (fdoData->LowerPortContext) {
        return (*fdoData->LowerAcquirePort)(fdoData->LowerPortContext);
    }
    else {
        return STATUS_SUCCESS;
    }
}

VOID
Game_ReleasePort(
    PFDO_DEVICE_DATA fdoData
    )
{
    ASSERT(fdoData->Acquired);

    InterlockedExchange(&fdoData->Acquired, FALSE);

    if (fdoData->LowerPortContext) {
        (*fdoData->LowerReleasePort)(fdoData->LowerPortContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\gameenum\sys\gameenum.h ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    GAMEENUM.H

Abstract:

    This module contains the common private declarations for the game port
    enumerator.

@@BEGIN_DDKSPLIT

Author:

    Kenneth Ray
    
@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef GAMEENUM_H
#define GAMEENUM_H

#define GAMEENUM_COMPATIBLE_IDS L"GamePort\\GameDevice\0\0"
#define GAMEENUM_COMPATIBLE_IDS_LENGTH 21 // NB wide characters.

#define GAMEENUM_INSTANCE_ID_BASE L"Game\\Inst_0"
#define GAMEENUM_INSTANCE_ID_BASE_LENGTH 12
#define GAMEENUM_INSTANCE_ID_BASE_PORT_INDEX 10

#define GAMEENUM_PDO_NAME_BASE L"\\Device\\Gameport_Joystick_"

#define GAMEENUM_UNIQUEID_START (-1)

#define GAMEENUM_POOL_TAG (ULONG) 'emaG'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, GAMEENUM_POOL_TAG)


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
// Debugging Output Levels
//

#define GAME_DBG_ALWAYS                 0x00000000

#define GAME_DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define GAME_DBG_SS_NOISE               0x00000001
#define GAME_DBG_SS_TRACE               0x00000002
#define GAME_DBG_SS_INFO                0x00000004
#define GAME_DBG_SS_ERROR               0x00000008

#define GAME_DBG_PNP_MASK               0x000000F0
#define GAME_DBG_PNP_NOISE              0x00000010
#define GAME_DBG_PNP_TRACE              0x00000020
#define GAME_DBG_PNP_INFO               0x00000040
#define GAME_DBG_PNP_ERROR              0x00000080

#define GAME_DBG_IOCTL_MASK             0x00000F00
#define GAME_DBG_IOCTL_NOISE            0x00000100
#define GAME_DBG_IOCTL_TRACE            0x00000200
#define GAME_DBG_IOCTL_INFO             0x00000400
#define GAME_DBG_IOCTL_ERROR            0x00000800

#define GAME_DBG_ACQUIRE_ERROR          0x00001000
#define GAME_DBG_ACQUIRE_NOISE          0x00002000
#define GAME_DBG_RELEASE_ERROR          0x00004000
#define GAME_DBG_RELEASE_NOISE          0x00008000

#if DBG
extern ULONG GameEnumDebugLevel;
#define GAME_DEFAULT_DEBUG_OUTPUT_LEVEL 0x00005888

#define Game_KdPrint(_d_,_l_, _x_) \
            if (!(_l_) || (_d_)->DebugLevel & (_l_)) { \
               DbgPrint ("GameEnum.SYS: "); \
               DbgPrint _x_; \
            }

#define Game_KdPrint_Cont(_d_,_l_, _x_) \
            if (!(_l_) || (_d_)->DebugLevel & (_l_)) { \
               DbgPrint _x_; \
            }

#define Game_KdPrint_Def(_l_, _x_) \
            if (!(_l_) || GameEnumDebugLevel & (_l_)) { \
               DbgPrint ("GameEnum.SYS: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)
#else

#define GAME_DEFAULT_DEBUG_OUTPUT_LEVEL 0x0
#define Game_KdPrint(_d_, _l_, _x_)
#define Game_KdPrint_Cont(_d_, _l_, _x_)
#define Game_KdPrint_Def(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif


//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    CHAR            Reserved[2];
    BOOLEAN         SurpriseRemoved;
    BOOLEAN         IsFDO;

    // A boolean to distringuish between PDO and FDO.

    ULONG           DebugLevel;

    GAMEENUM_OEM_DATA  OemData;
    USHORT             UnitID;
    USHORT             _Unused;
    // user supplied data

    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;

    
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the game ports of which this bus driver enumerates.
//
typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParrentFdo;
    // A back pointer to the bus

    PWCHAR      HardwareIDs;
    // An array of (zero terminated wide character strings).
    // The array itself also null terminated

    ULONG UniqueID;
    // Globally unique id in the system

    BOOLEAN     AnalogCompatible;
    // TRUE if the device can be supported by the analog joystick driver

    BOOLEAN     Started;
    BOOLEAN     Attached;
    BOOLEAN     Removed;
    // When a device (PDO) is found on a bus and presented as a device relation
    // to the PlugPlay system, Attached is set to TRUE, and Removed to FALSE.
    // When the bus driver determines that this PDO is no longer valid, because
    // the device has gone away, it informs the PlugPlay system of the new
    // device relastions, but it does not delete the device object at that time.
    // The PDO is deleted only when the PlugPlay system has sent a remove IRP,
    // and there is no longer a device on the bus.
    //
    // If the PlugPlay system sends a remove IRP then the Removed field is set
    // to true, and all client (non PlugPlay system) accesses are failed.
    // If the device is removed from the bus Attached is set to FALSE.
    //
    // Durring a query relations Irp Minor call, only the PDOs that are
    // attached to the bus (and all that are attached to the bus) are returned
    // (even if they have been removed).
    //
    // Durring a remove device Irp Minor call, if and only if, attached is set
    // to FALSE, the PDO is deleted.
    //


    // For legacy joysticks only
    USHORT      NumberAxis;
    USHORT      NumberButtons;
    GAMEENUM_PORTION Portion;

    LIST_ENTRY  Link;
    // the link point to hold all the PDOs for a single bus together
} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    BOOLEAN         MappedPorts;
    // Were the ports mapped with MmMapIoSpace?
    BOOLEAN         PowerQueryLock;
    // Are we currently in a query power state?
    BOOLEAN         Started;
    // Are we on, have resources, etc?
    BOOLEAN         Removed;
    // Has this device been removed?  Should we fail any requests?

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

    LIST_ENTRY      PDOs;
    ULONG           NumPDOs;
    // The PDOs currently enumerated.

    FAST_MUTEX      Mutex;
    // A syncronization for access to the device extension.

    ULONG           OutstandingIO;
    // the number of IRPs sent from the bus to the underlying device object
    // can't use NT RtlRemoveLocks b/c win 9x does not have them

    KEVENT          RemoveEvent;
    // On remove device plugplay request we must wait until all outstanding
    // requests have been completed before we can actually delete the device
    // object.

    UNICODE_STRING DevClassAssocName;
    // The name returned from IoRegisterDeviceClass Association,
    // which is used as a handle for IoSetDev... and friends.

    PHYSICAL_ADDRESS    PhysicalAddress;
    PGAMEENUM_READPORT  ReadPort;
    PGAMEENUM_WRITEPORT WritePort;
    PVOID               GamePortAddress;
    ULONG               GamePortAddressLength;

    //
    // If there is a bus lower filter these will be used after sanity checks
    //
    PVOID                  LowerPortContext;
    PGAMEENUM_ACQUIRE_PORT LowerAcquirePort;
    PGAMEENUM_RELEASE_PORT LowerReleasePort;

    LONG                UniqueIDCount;

    KEVENT              PoweredDownEvent;
    LONG                PoweredDownDevices;

    LONG             Acquired;
} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

#define FDO_FROM_PDO(pdoData) ((PFDO_DEVICE_DATA) (pdoData)->ParrentFdo->DeviceExtension)


//
// Prototypes
//

NTSTATUS
Game_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_SystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Game_DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Game_CompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
Game_SendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN NotImplementedIsValid,
    IN BOOLEAN CopyToNext   
    );

NTSTATUS
Game_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
Game_CreatePdo (
    PFDO_DEVICE_DATA    FdoData,
    PUCHAR              NameIndex,
    PDEVICE_OBJECT *    PDO
    );

VOID
Game_InitializePdo (
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    );

NTSTATUS
Game_CheckHardwareIDs (
    PWCHAR                      pwszTestId,
    PULONG                      puLenLimit,
    PFDO_DEVICE_DATA            FdoData
    );

NTSTATUS
Game_Expose (
    PGAMEENUM_EXPOSE_HARDWARE   Expose,
    ULONG                       ExposeLength,
    PFDO_DEVICE_DATA            DeviceData
    );

NTSTATUS
Game_ExposeSibling (
    PGAMEENUM_EXPOSE_SIBLING    ExposeSibling,
    PPDO_DEVICE_DATA            SiblingPdo
    );

NTSTATUS
Game_Remove (
    PGAMEENUM_REMOVE_HARDWARE   Remove,
    PFDO_DEVICE_DATA            DeviceData
    );

NTSTATUS
Game_RemoveSelf (
    PPDO_DEVICE_DATA            DeviceData
    );

NTSTATUS
Game_RemoveEx (
    PDEVICE_OBJECT              RemoveDO,
    PFDO_DEVICE_DATA            DeviceData
    );

void 
Game_RemoveFdo (
    PFDO_DEVICE_DATA    FdoData
    );

NTSTATUS
Game_RemovePdo (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    );

NTSTATUS
Game_ListPorts (
    PGAMEENUM_PORT_DESC Desc,
    PFDO_DEVICE_DATA    DeviceData
    );

NTSTATUS
Game_PortParameters (
    PGAMEENUM_PORT_PARAMETERS   Parameters,
    PPDO_DEVICE_DATA            PdoDeviceData
    );

NTSTATUS
Game_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Game_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Game_StartFdo (
    IN  PFDO_DEVICE_DATA            FdoData,
    IN  PCM_PARTIAL_RESOURCE_LIST   partialResourceList,
    IN  PCM_PARTIAL_RESOURCE_LIST   partialResourceListTranslated
    );

NTSTATUS
Game_IncIoCount (
    PFDO_DEVICE_DATA   Data
    );

VOID
Game_DecIoCount (
    PFDO_DEVICE_DATA   Data
    );

NTSTATUS
Game_FDO_Power (
    PFDO_DEVICE_DATA    FdoData,
    PIRP                Irp
    );

NTSTATUS
Game_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    );

NTSTATUS
Game_AcquirePort (
    PFDO_DEVICE_DATA    FdoData
    );

VOID
Game_ReleasePort (
    PFDO_DEVICE_DATA    FdoData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\gameenum\sys\pnp.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    PNP.C

Abstract:

    This module contains contains the plugplay calls
    PNP / WDM BUS driver.

@@BEGIN_DDKSPLIT

Author:

    Kenneth D. Ray
    Doron J. Holan
    
@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#include "gameport.h"
#include "gameenum.h"
#include "stdio.h"

#define HWID_TEMPLATE L"gameport"
#define HWID_TEMPLATE_LENGTH 8
#define LOWERCASE(_x_) (_x_|0x20)
#define MAX_DEVICE_ID_LEN     300

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Game_AddDevice)
#pragma alloc_text (PAGE, Game_SystemControl)
#pragma alloc_text (PAGE, Game_PnP)
#pragma alloc_text (PAGE, Game_Power)
#pragma alloc_text (PAGE, Game_FDO_Power)
#pragma alloc_text (PAGE, Game_PDO_Power)
#pragma alloc_text (PAGE, Game_CreatePdo)
#pragma alloc_text (PAGE, Game_InitializePdo)
#pragma alloc_text (PAGE, Game_CheckHardwareIDs)
#pragma alloc_text (PAGE, Game_Expose)
#pragma alloc_text (PAGE, Game_ExposeSibling)
#pragma alloc_text (PAGE, Game_Remove)
#pragma alloc_text (PAGE, Game_RemoveSelf)
#pragma alloc_text (PAGE, Game_RemoveEx)
#pragma alloc_text (PAGE, Game_RemovePdo)
#pragma alloc_text (PAGE, Game_RemoveFdo)
#pragma alloc_text (PAGE, Game_ListPorts)
#pragma alloc_text (PAGE, Game_FDO_PnP)
#pragma alloc_text (PAGE, Game_PDO_PnP)
#endif

NTSTATUS
Game_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusPhysicalDeviceObject - Device object representing the bus.  That to which we
                      attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    deviceData;

#if DBG
    ULONG               nameLength;
    PWCHAR              deviceName;
#endif

    PAGED_CODE ();

    Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Add Device: 0x%x\n",
                                          BusPhysicalDeviceObject));

    status = IoCreateDevice (
                    DriverObject,  // our driver object
                    sizeof (FDO_DEVICE_DATA), // device object extension size
                    NULL, // FDOs do not have names
                    FILE_DEVICE_BUS_EXTENDER,
                    0, // No special characteristics
                    TRUE, // our FDO is exclusive
                    &deviceObject); // The device object created

    if (NT_SUCCESS (status)) {
        deviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
        RtlFillMemory (deviceData, sizeof (FDO_DEVICE_DATA), 0);

#if DBG
        deviceData->DebugLevel = GameEnumDebugLevel;
#endif
        deviceData->IsFDO = TRUE;
        deviceData->Self = deviceObject;
        ExInitializeFastMutex (&deviceData->Mutex);

        deviceData->Removed = FALSE;
        InitializeListHead (&deviceData->PDOs);

        // Set the PDO for use with PlugPlay functions
        deviceData->UnderlyingPDO = BusPhysicalDeviceObject;

        //
        // Will get preincremented everytime a new PDO is created ... want the
        // first ID to be zero
        //
        deviceData->UniqueIDCount = GAMEENUM_UNIQUEID_START;

        //
        // Attach our filter driver to the device stack.
        // the return value of IoAttachDeviceToDeviceStack is the top of the
        // attachment chain.  This is where all the IRPs should be routed.
        //
        // Our filter will send IRPs to the top of the stack and use the PDO
        // for all PlugPlay functions.
        //
        deviceData->TopOfStack = IoAttachDeviceToDeviceStack (
                                        deviceObject,
                                        BusPhysicalDeviceObject);

        if (deviceData->TopOfStack == NULL) {
            IoDeleteDevice(deviceObject);
            return STATUS_DEVICE_NOT_CONNECTED; 
        }
        
        // Bias outstanding request to 1 so that we can look for a
        // transition to zero when processing the remove device PlugPlay IRP.
        deviceData->OutstandingIO = 1;

        KeInitializeEvent(&deviceData->RemoveEvent,
                          SynchronizationEvent,
                          FALSE); // initialized to not signalled

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        //
        // Tell the PlugPlay system that this device will need an interface
        // device class shingle.
        //
        // It may be that the driver cannot hang the shingle until it starts
        // the device itself, so that it can query some of its properties.
        // (Aka the shingles guid (or ref string) is based on the properties
        // of the device.)
        //
        status = IoRegisterDeviceInterface (
                    BusPhysicalDeviceObject,
                    (LPGUID) &GUID_GAMEENUM_BUS_ENUMERATOR,
                    NULL, // No ref string
                    &deviceData->DevClassAssocName);

        if (!NT_SUCCESS (status)) {
            Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                          ("AddDevice: IoRegisterDeviceInterface failed (%x)", status));
            IoDeleteDevice (deviceObject);
            return status;
        }

        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceInterface might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // deviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

#if DBG
        nameLength = 0;
        status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                      DevicePropertyPhysicalDeviceObjectName,
                                      0,
                                      NULL,
                                      &nameLength);

        // 
        // Proceed only if the PDO has a name
        //
        if (status == STATUS_BUFFER_TOO_SMALL && nameLength != 0) {
    
            deviceName = ExAllocatePool (NonPagedPool, nameLength);
    
            if (NULL == deviceName) {
                IoDeleteDevice (deviceObject);
                Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                              ("AddDevice: no memory to alloc DeviceName (0x%x)",
                               nameLength));
                return STATUS_INSUFFICIENT_RESOURCES;
            }
    
            IoGetDeviceProperty (BusPhysicalDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 nameLength,
                                 deviceName,
                                 &nameLength);
    
            Game_KdPrint (deviceData, GAME_DBG_SS_TRACE,
                          ("AddDevice: %x to %x->%x (%ws) \n",
                           deviceObject,
                           deviceData->TopOfStack,
                           BusPhysicalDeviceObject,
                           deviceName));
    
            ExFreePool(deviceName);
        }

        status = STATUS_SUCCESS;
#endif

        if (!NT_SUCCESS (status)) {
            Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                          ("AddDevice: IoGetDeviceClass failed (%x)", status));
            return status;
        }
    }

    return status;
}

NTSTATUS
Game_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver (((PFDO_DEVICE_DATA) commonData)->TopOfStack, Irp);
    }
    else {
        //
        // The PDO, just complete the request with the current status
        //
        NTSTATUS status = Irp->IoStatus.Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
Game_PnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
Routine Description:
    Answer the plithera of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        Game_KdPrint (commonData, GAME_DBG_PNP_TRACE,
                      ("PNP: Functional DO: %x IRP: %x\n", DeviceObject, Irp));

        status = Game_FDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PFDO_DEVICE_DATA) commonData);
    } else {
        Game_KdPrint (commonData, GAME_DBG_PNP_TRACE,
                      ("PNP: Physical DO: %x IRP: %x\n", DeviceObject, Irp));

        status = Game_PDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PPDO_DEVICE_DATA) commonData);
    }

    return status;
}

NTSTATUS
Game_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations, oldRelations;
    PIO_STACK_LOCATION  stack;

    PAGED_CODE ();

    status = Game_IncIoCount (DeviceData);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //

        if (DeviceData->Started) {
            status = STATUS_SUCCESS;
            break;
        }

        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Start Device\n"));
        status = Game_SendIrpSynchronously (DeviceData->TopOfStack, Irp, TRUE, TRUE);

        if (NT_SUCCESS(status)) {

            //
            // Now we can touch the lower device object as it is now started.
            //
            if ((NULL == stack->Parameters.StartDevice.AllocatedResources) ||
                (NULL == stack->Parameters.StartDevice.AllocatedResourcesTranslated)) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = Game_StartFdo (DeviceData,
                                    &stack->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList,
                                    &stack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0].PartialResourceList);

            //
            // find the translated resources and store them someplace
            // safe for given out for the PDOs.
            //
            if (NT_SUCCESS (status)) {
                //
                // Turn on the shingle and point it to the given device object.
                //
                DeviceData->Started = TRUE;
                IoSetDeviceInterfaceState(&DeviceData->DevClassAssocName, TRUE);
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        Irp->IoStatus.Information = 0;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Query Stop Device\n"));

        //
        // Test to see if there are any PDO created as children of this FDO
        // If there are then conclude the device is busy and fail the
        // query stop.
        //
        // ISSUE
        // We could do better, by seing if the children PDOs are actually
        // currently open.  If they are not then we could stop, get new
        // resouces, fill in the new resouce values, and then when a new client
        // opens the PDO use the new resources.  But this works for now.
        //
        if (DeviceData->NumPDOs) {
            status = STATUS_UNSUCCESSFUL;
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
        } else {
            status = STATUS_SUCCESS;

            Irp->IoStatus.Status = status;
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (DeviceData->TopOfStack, Irp);
        }

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Stop Device\n"));

        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //
        // Stop device means that the resources given durring Start device
        // are no revoked.  So we need to stop using them
        //
        if (DeviceData->Started) {
            DeviceData->Started = FALSE;

            //
            // Free resources given by start device.
            //
            if (DeviceData->MappedPorts) {
                MmUnmapIoSpace (DeviceData->GamePortAddress,
                                DeviceData->GamePortAddressLength);
            }
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_SURPRISE_REMOVAL:
        ASSERT(!DeviceData->Acquired);

        Game_RemoveFdo(DeviceData);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Remove Device\n"));

        //
        // We should assert this because Game_IncIoCount will not succeed if a
        // remove has already been sent down.
        //
        ASSERT(!DeviceData->Removed);
        ASSERT(!DeviceData->Acquired);

        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!DeviceData->Removed);
        //
        // We will accept no new requests
        //
        DeviceData->Removed = TRUE;
        
        //
        // Complete any outstanding IRPs queued by the driver here.
        //

        // Perform (surpise) remove code
        Game_RemoveFdo(DeviceData);

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Fire and forget
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        //
        // Wait for all outstanding requests to complete
        //
        i = InterlockedDecrement (&DeviceData->OutstandingIO);

        ASSERT (0 < i);

        if (0 != InterlockedDecrement (&DeviceData->OutstandingIO)) {
            NTSTATUS waitStatus;

            Game_KdPrint (DeviceData, GAME_DBG_PNP_INFO,
                          ("Remove Device waiting for request to complete\n"));

            waitStatus = KeWaitForSingleObject (&DeviceData->RemoveEvent,
                                                Executive,
                                                KernelMode,
                                                FALSE, // Not Alertable
                                                NULL); // No timeout
            ASSERT (waitStatus == STATUS_SUCCESS);
        }

        //
        // Free the associated resources
        //

        //
        // Detatch from the undelying devices.
        //
        Game_KdPrint(DeviceData, GAME_DBG_PNP_INFO,
                        ("IoDetachDevice: 0x%x\n", DeviceData->TopOfStack));
        IoDetachDevice (DeviceData->TopOfStack);

        Game_KdPrint(DeviceData, GAME_DBG_PNP_INFO,
                        ("IoDeleteDevice1: 0x%x\n", DeviceObject));

        ExAcquireFastMutex (&DeviceData->Mutex);
    
        for (entry = DeviceData->PDOs.Flink;
             entry != &DeviceData->PDOs;
             ) {
    
            pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);

            ASSERT (pdoData->Removed);
            ASSERT (pdoData->Attached);

            //
            // We set this to false so that Game_RemovePdo will delete the DO
            // and free any of the allocated memory associated with the PDO.
            //
            pdoData->Attached = FALSE;

            //
            // Go to the next link in the list.  Once the pdo is deleted, entry
            // is no longer a valid pointer.
            //
            entry = entry->Flink;

            //
            // Once Game_RemovePdo is called, pdoData and the pdo itself cannot
            // be touched becuase they will have been deleted.   RemoveEntryList
            // does not modify the value Link->Flink, so the state after this 
            // one is safe
            //
            RemoveEntryList (&pdoData->Link);

            Game_RemovePdo (pdoData->Self, pdoData);

            DeviceData->NumPDOs--;
        }

        ASSERT(DeviceData->NumPDOs == 0);

        ExReleaseFastMutex (&DeviceData->Mutex);
    
        IoDeleteDevice (DeviceObject);

        return status;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (BusRelations != IrpStack->Parameters.QueryDeviceRelations.Type) {
            //
            // We don't support this
            //
            goto GAME_FDO_PNP_DEFAULT;
        }

        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Query Relations "));

        //
        // Tell the plug and play system about all the PDOs.
        //
        // There might also be device relations below and above this FDO,
        // so, be sure to propagate the relations from the upper drivers.
        //
        // No Completion routine is needed so long as the status is preset
        // to success.  (PDOs complete plug and play irps with the current
        // IoStatus.Status and IoStatus.Information as the default.)
        //
        ExAcquireFastMutex (&DeviceData->Mutex);

        oldRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
        if (oldRelations) {
            i = oldRelations->Count; 
            if (!DeviceData->NumPDOs) {
                //
                // There is a device relations struct already present and we have
                // nothing to add to it, so just call IoSkip and IoCall
                //
                ExReleaseFastMutex (&DeviceData->Mutex);
                goto GAME_FDO_PNP_DEFAULT;
            }
        }
        else  {
            i = 0;
        }

        // The current number of PDOs
        Game_KdPrint_Cont (DeviceData, GAME_DBG_PNP_TRACE,
                           ("#PDOS = %d + %d\n", i, DeviceData->NumPDOs));

        //
        // Need to allocate a new relations structure and add our
        // PDOs to it.
        //
        length = sizeof(DEVICE_RELATIONS) +
                ((DeviceData->NumPDOs + i) * sizeof (PDEVICE_OBJECT));

        relations = (PDEVICE_RELATIONS) ExAllocatePool (PagedPool, length);

        if (NULL == relations) {
            ExReleaseFastMutex (&DeviceData->Mutex);
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                  relations->Objects,
                  oldRelations->Objects,
                  i * sizeof (PDEVICE_OBJECT));
        }
        relations->Count = DeviceData->NumPDOs + i;

        //
        // For each PDO on this bus add a pointer to the device relations
        // buffer, being sure to take out a reference to that object.
        // The PlugPlay system will dereference the object when it is done with
        // it and free the device relations buffer.
        //
        for (entry = DeviceData->PDOs.Flink;
             entry != &DeviceData->PDOs;
             entry = entry->Flink, i++) {

            pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
            ASSERT (pdoData->Attached);
            relations->Objects[i] = pdoData->Self;
            ObReferenceObject (pdoData->Self);
        }

        //
        // Replace the relations structure in the IRP with the new
        // one.
        //
        if (oldRelations) {
            ExFreePool (oldRelations);
        }
        Irp->IoStatus.Information = (ULONG_PTR) relations;

        ExReleaseFastMutex (&DeviceData->Mutex);

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        //
        // For query remove, if we were to fail this call then we would need to
        // complete the IRP here.  Since we are not, set the status to SUCCESS
        // and call the next driver.
        //
        // For the cancel(s), we must set the status to notify the PnP subsystem
        // that the irp was correctly handled
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Game_DecIoCount (DeviceData);
        return status;

GAME_FDO_PNP_DEFAULT:
    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //

        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Game_DecIoCount (DeviceData);
        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    Game_DecIoCount (DeviceData);

    return status;
}

UCHAR
Game_ReadPortUchar (
    IN  UCHAR * x
    )
{
    return READ_PORT_UCHAR (x);
}

VOID
Game_WritePortUchar (
    IN  UCHAR * x,
    IN  UCHAR   y
    )
{
    WRITE_PORT_UCHAR (x,y);
}

UCHAR
Game_ReadRegisterUchar (
    IN  UCHAR * x
    )
{
    return READ_REGISTER_UCHAR (x);
}

VOID
Game_WriteRegisterUchar (
    IN  UCHAR * x,
    IN  UCHAR   y
    )
{
    WRITE_REGISTER_UCHAR (x,y);
}

NTSTATUS
Game_StartFdo (
    IN  PFDO_DEVICE_DATA            FdoData,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceList,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceListTranslated
    )
/*++

Routine Description:

    Parses the resource lists to see what type of accessors to use. 
    
Arguments:

    DeviceObject - Pointer to the device object.
    PartialResourceList - untranslated resources
    PartialResourceListTranslated - translated resources

Return Value:

    Status is returned.

--*/
{
    ULONG i;
    NTSTATUS status = STATUS_SUCCESS;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceTrans;

    Game_KdPrint (FdoData, GAME_DBG_PNP_TRACE, ("StartFdo\n"));

    for (i = 0,
         resource = &PartialResourceList->PartialDescriptors[0],
         resourceTrans = &PartialResourceListTranslated->PartialDescriptors[0];

         i < PartialResourceList->Count && NT_SUCCESS(status);
         i++, resource++, resourceTrans++) {

        switch (resource->Type) {
        case CmResourceTypePort:

#if _X86_
            FdoData->ReadPort = READ_PORT_UCHAR; 
            FdoData->WritePort = WRITE_PORT_UCHAR;
#else
            FdoData->ReadPort = Game_ReadPortUchar;
            FdoData->WritePort = Game_WritePortUchar;
#endif
            FdoData->PhysicalAddress = resource->u.Port.Start;
            Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
                          ("HardwareResource: Port (%x) -> ",
                           FdoData->PhysicalAddress.LowPart));

            switch (resourceTrans->Type) {
            case CmResourceTypePort:


                // Nothing to do here but note the address;
//@@BEGIN_DDKSPLIT
                // On Win9x, VJoyD.VxD handles the resources for gameports.
                // It only uses ports and it assumes that the first range is 
                // always the gameport.  It uses a second range of a devnode 
                // only if the second range is within the original standard 
                // range of 200-20f.  All other ports are assumed to be audio 
                // ports on the hosting sound card.
//@@END_DDKSPLIT
                // For better compatibility with Win9x, always use only the 
                // first port range.

                if( FdoData->GamePortAddress == 0 ) {
                    FdoData->GamePortAddress =
                        (PVOID)(ULONG_PTR) resourceTrans->u.Port.Start.QuadPart;

                    ASSERT (resourceTrans->u.Port.Length == resource->u.Port.Length);
                    FdoData->GamePortAddressLength = resourceTrans->u.Port.Length;

                    Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                       ("Port: (%x)\n", FdoData->GamePortAddress));
                } else {
                    Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                       ("Ignoring additional port: (%x)\n", FdoData->GamePortAddress));
                }
                break;

            case CmResourceTypeMemory:
                //
                // We need to map the memory
                //

                FdoData->GamePortAddress =
                    MmMapIoSpace (resourceTrans->u.Memory.Start,
                                  resourceTrans->u.Memory.Length,
                                  MmNonCached);

                ASSERT (resourceTrans->u.Port.Length == resource->u.Port.Length);
                FdoData->GamePortAddressLength = resourceTrans->u.Memory.Length;

                FdoData->MappedPorts = TRUE;

                Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                   ("Mem: (%x)\n", FdoData->GamePortAddress));
                break;

            default:
                Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                   ("Unknown \n", FdoData->GamePortAddress));
                TRAP ();
            }

            break;

        case CmResourceTypeMemory:

            ASSERT (CmResourceTypeMemory == resourceTrans->Type);

#if _X86_
            FdoData->ReadPort = READ_REGISTER_UCHAR; 
            FdoData->WritePort = WRITE_REGISTER_UCHAR;
#else
            FdoData->ReadPort = Game_ReadRegisterUchar; 
            FdoData->WritePort = Game_WriteRegisterUchar; 
#endif
            FdoData->PhysicalAddress = resource->u.Memory.Start;
            FdoData->GamePortAddress =
                MmMapIoSpace (resourceTrans->u.Memory.Start,
                              resourceTrans->u.Memory.Length,
                              MmNonCached);

            FdoData->MappedPorts = TRUE;

            Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
                          ("HardwareResource: Memory (%x) -> Mem (%x)",
                           FdoData->PhysicalAddress.LowPart,
                           FdoData->GamePortAddress));

            break;

        case CmResourceTypeInterrupt:
        default:
            // Hun?  Allow this to succeed...perhaps whomever enumerated the PDO
            // below us needs this resource for the game port
            Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR,
                          ("Unhandled resource type (0x%x)\n",
                           resource->Type));
            // status = STATUS_UNSUCCESSFUL;
        }
    }
    return status;
}

void
Game_RemoveFdo (
    IN PFDO_DEVICE_DATA FdoData
    ) 
/*++
Routine Description:
    
    Frees any memory allocated by the FDO and unmaps any IO mapped as well.
    
--*/
{
    PAGED_CODE ();

    if (FdoData->SurpriseRemoved) {
        return;
    }

    //
    // We set this b/c if we get called twice, that means a surprise removal
    // called this function first
    //
    FdoData->SurpriseRemoved =  TRUE;

    //
    // Clean up any resources here
    //
    if (FdoData->Started) {
        FdoData->Started = FALSE;

        //
        // Free resources given by start device.
        //
        if (FdoData->MappedPorts) {
            MmUnmapIoSpace (FdoData->GamePortAddress, 1);
            // Here we are assuming that joysticks only use on port.
            // This is the way it has always been, and might always
            // continue to be.  This assumption is everywhere in this stack.
        }

        IoSetDeviceInterfaceState (&FdoData->DevClassAssocName, FALSE);
    }

    //
    // Make the DI go away.  Some drivers may choose to remove the DCA
    // when they receive a stop or even a query stop.  We just don't care.
    //
    if (FdoData->DevClassAssocName.Buffer != NULL) {
        ExFreePool (FdoData->DevClassAssocName.Buffer);
        RtlZeroMemory (&FdoData->DevClassAssocName,
                       sizeof (UNICODE_STRING)); 
    }
}

NTSTATUS
Game_SendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN NotImplementedIsValid,
    IN BOOLEAN CopyToNext   
    )
{
    KEVENT   event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    if (CopyToNext) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp,
                           Game_CompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    if (NotImplementedIsValid && (status == STATUS_NOT_IMPLEMENTED ||
                                  status == STATUS_INVALID_DEVICE_REQUEST)) {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
Game_CompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    // if (Irp->PendingReturned) {
    //     IoMarkIrpPending( Irp );
    // }

    KeSetEvent ((PKEVENT) Context, 1, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
Game_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{ 
    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer, buffer2;
    ULONG                   length, length2, i, j;
    NTSTATUS                status;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;

    //
    // NB: since we are a bus enumerator, we have no one to whom we could
    // defer these irps.  Therefore we do not pass them down but merely
    // return them.
    //

    switch (IrpStack->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Query Caps \n"));

        //
        // Get the packet.
        //
        deviceCapabilities=IrpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // Set the capabilities.
        //

        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

        // We cannot wake the system.
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

        // We have no latencies
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

        // No locking or ejection
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

        // Device can be physically removed.
        // Technically there is no physical device to remove, but this bus
        // driver can yank the PDO from the PlugPlay system, when ever it
        // receives an IOCTL_GAMEENUM_REMOVE_PORT device control command.
        deviceCapabilities->Removable = FALSE;
        deviceCapabilities->SurpriseRemovalOK = TRUE;

        // not Docking device
        deviceCapabilities->DockDevice = FALSE;

        deviceCapabilities->UniqueID = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_ID:
        // Query the IDs of the device
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE,
                      ("QueryID: 0x%x\n", IrpStack->Parameters.QueryId.IdType));

        //
        // If the query requires having a hardware ID, check we have one
        // 
#if DBG
        if (( IrpStack->Parameters.QueryId.IdType == BusQueryDeviceID ) 
         || ( IrpStack->Parameters.QueryId.IdType == BusQueryHardwareIDs ) 
         || ( IrpStack->Parameters.QueryId.IdType == BusQueryInstanceID )) {
            if (DeviceData->HardwareIDs) {
                ULONG tmplength = 1024;  // No reason to be as long as this
                ASSERT( NT_SUCCESS( Game_CheckHardwareIDs (DeviceData->HardwareIDs,
                                    &tmplength, FDO_FROM_PDO (DeviceData) ) ) );
            } else {
                ASSERT( !"No hardware ID for QueryId" );
            }

        }
#endif

        switch (IrpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            // this can be the same as the hardware ids (which requires a multi
            // sz) ... we are just allocating more than enough memory
        case BusQueryHardwareIDs:
            // return a multi WCHAR (null terminated) string (null terminated)
            // array for use in matching hardare ids in inf files;
            //

            buffer = DeviceData->HardwareIDs;

            while (*(buffer++)) {
                while (*(buffer++)) {
                    ;
                }
            }
            length = (ULONG)(buffer - DeviceData->HardwareIDs) * sizeof (WCHAR);
          
            buffer = ExAllocatePool (PagedPool, length);
            if (buffer) {
                RtlCopyMemory (buffer, DeviceData->HardwareIDs, length);
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            Irp->IoStatus.Information = (ULONG_PTR) buffer;
            break;

        case BusQueryInstanceID:
            //
            // Take the first hardware id and append an underscore and number
            // to it
            // total length = 
            // length of hw id + underscore + number (11 digits to be safe) +
            // null 
            //
            buffer = buffer2 = DeviceData->HardwareIDs;

            while (*(buffer++)) {
                while (*(buffer++)) {
                    ;
                }
            }
            while ('\\' != *(buffer2++)) {
                ;
            }
            length = (ULONG)(buffer - buffer2) * sizeof (WCHAR);

            length += 1 + 11 + 1;

            buffer = ExAllocatePool (PagedPool, length);
            if (buffer) {
                swprintf(buffer, L"%ws_%02d", buffer2, DeviceData->UniqueID);
                Game_KdPrint (DeviceData, GAME_DBG_PNP_INFO,
                             ("UniqueID: %ws\n", buffer));
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            Irp->IoStatus.Information = (ULONG_PTR) buffer;
            break;


        case BusQueryCompatibleIDs:
            // The generic ids for installation of this pdo.
            if (DeviceData->AnalogCompatible) {
                // Only applicable for analog devices

                length = GAMEENUM_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);
                buffer = ExAllocatePool (PagedPool, length);
                if (buffer) {
                    RtlCopyMemory (buffer, GAMEENUM_COMPATIBLE_IDS, length);
                    status = STATUS_SUCCESS;
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
            }
            else {
                // For incompatible devices report an empty list
                buffer = ExAllocatePool (PagedPool, sizeof(L"\0"));
                if (buffer) {
                    *(ULONG *)buffer = 0;  // double unicode-NULL.
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
            }
            break;
        }
        break;

    case IRP_MN_START_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Start Device \n"));
        // Here we do what ever initialization and ``turning on'' that is
        // required to allow others to access this device.
        DeviceData->Started = TRUE;
        DeviceData->Removed = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Stop Device \n"));
        // Here we shut down the device.  The opposite of start.
        DeviceData->Started = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        // just mark that it happened, cleaning up the device extension will
        // occur later
        ASSERT(!(FDO_FROM_PDO (DeviceData))->Acquired);
        DeviceData->SurpriseRemoved = TRUE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Remove Device \n"));

        ASSERT(!(FDO_FROM_PDO (DeviceData))->Acquired);

        //
        // The remove IRP code for a PDO uses the following steps:
        //
        //  Complete any requests queued in the driver
        //  If the device is still attached to the system,
        //   then complete the request and return.
        //  Otherwise, cleanup device specific allocations, memory, events...
        //  Call IoDeleteDevice
        //  Return from the dispatch routine.
        //
        status = Game_RemovePdo(DeviceObject, DeviceData);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Q Stop Device \n"));
        // No reason here why we can't stop the device.
        // If there were a reason we should speak now for answering success
        // here may result in a stop device irp.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Cancel Stop Device \n"));
        //
        // The stop was canceled.  Whatever state we set, or resources we put
        // on hold in anticipation of the forcoming STOP device IRP should be
        // put back to normal.  Someone, in the long list of concerned parties,
        // has failed the stop device query.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Q Remove Device \n"));
        //
        // Just like Query Stop only now the impending doom is the remove irp
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Can Remove Device \n"));
        //
        // Clean up a remove that did not go through, just like cancel STOP.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (TargetDeviceRelation ==
            IrpStack->Parameters.QueryDeviceRelations.Type) {
            PDEVICE_RELATIONS deviceRelations;

            deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information; 
            if (!deviceRelations) {
                deviceRelations = (PDEVICE_RELATIONS)
                    ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

                if (!deviceRelations) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
            }
            else if (deviceRelations->Count != 0) {
                //
                // Nobody but the PDO should be setting this value!
                //
                ASSERT(deviceRelations->Count == 0);

                //
                // Deref any objects that were previously in the list
                //
                for (i = 0; i < deviceRelations->Count; i++) {
                    ObDereferenceObject(deviceRelations->Objects[i]);
                    deviceRelations->Objects[i] = NULL;
                }
            }

            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = DeviceData->Self;
            ObReferenceObject(DeviceData->Self);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

            break;
        }

        // fall through

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG: // we have no config space
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
    default:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE,
                      ("PNP Not handled 0x%x\n", IrpStack->MinorFunction));
        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
Game_RemovePdo (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    )
/*++
Routine Description:
    The PlugPlay subsystem has instructed that this PDO should be removed.

    We should therefore
     Complete any requests queued in the driver
     If the device is still attached to the system,
      then complete the request and return.
     Otherwise, cleanup device specific allocations, memory, events...
     Call IoDeleteDevice
     Return from the dispatch routine.

    Note that if the device is still connected to the bus (IE in this case
    the control panel has not yet told us that the game device has disappeared)
    then the PDO must remain around, and must be returned during any
    query Device relaions IRPS.

--*/

{
    PAGED_CODE ();

    PdoData->Removed = TRUE;

    //
    // Complete any outsanding requests with STATUS_DELETE_PENDING.
    //
    // Game enum does not queue any irps at this time so we have nothing to do.
    //
    // Attached is set to true when the pdo is exposed via one of the IOCTLs.
    // It is set to FALSE when a remove IOCTL is received.  This means that we
    // can get a remove on a device that still exists, so we don't delete it.
    //
    if (PdoData->Attached) {
        return STATUS_SUCCESS;
    }

    //
    // Free any resources.
    //
    if (PdoData->HardwareIDs) {
        ExFreePool (PdoData->HardwareIDs);
        PdoData->HardwareIDs = NULL;
    }

    Game_KdPrint(PdoData, GAME_DBG_PNP_INFO,
                        ("IoDeleteDevice2: 0x%x\n", Device));
    IoDeleteDevice (Device);
    return STATUS_SUCCESS;
}

NTSTATUS
Game_CreatePdo (
    PFDO_DEVICE_DATA    FdoData,
    PUCHAR              NameIndex,
    PDEVICE_OBJECT *    PDO
    )
/*++
Routine Description:
    Iteratively try to create the PDO until we get a name w/out collision
    
--*/
{
    UNICODE_STRING      pdoUniName;
    WCHAR               pdoName[30];
    NTSTATUS            status;

    PAGED_CODE ();

    //
    // Create the PDOs
    //
    RtlInitUnicodeString (&pdoUniName,
                          pdoName);
    pdoUniName.MaximumLength = sizeof(pdoName);

    do {
        swprintf(pdoName, L"%ws%d",
                 GAMEENUM_PDO_NAME_BASE, (ULONG) ((*NameIndex)++));
        pdoUniName.Length = wcslen(pdoName) * sizeof(WCHAR);

        Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
              ("PDO Name: %ws\n",
               pdoName));

        status = IoCreateDevice(FdoData->Self->DriverObject,
                                sizeof (PDO_DEVICE_DATA),
                                &pdoUniName,
                                FILE_DEVICE_BUS_EXTENDER,
                                0,
                                FALSE,
                                PDO);
    } while (STATUS_OBJECT_NAME_COLLISION == status);

    if (!NT_SUCCESS (status)) {
        *PDO = NULL; 
    }

    return status;
}

VOID
Game_InitializePdo (
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    )
/*++
Routine Description:
    Set the PDO into a known good starting state
    
--*/
{
    PPDO_DEVICE_DATA pdoData;

    PAGED_CODE ();

    pdoData = (PPDO_DEVICE_DATA)  Pdo->DeviceExtension;

    Game_KdPrint(pdoData, GAME_DBG_SS_NOISE, 
                 ("pdo 0x%x, extension 0x%x\n", Pdo, pdoData));

    //
    // Initialize the rest
    //
    pdoData->IsFDO = FALSE;
    pdoData->Self =  Pdo;
#if DBG
    pdoData->DebugLevel = GameEnumDebugLevel;
#endif

    pdoData->ParrentFdo = FdoData->Self;

    pdoData->Started = FALSE; // irp_mn_start has yet to be received
    pdoData->Attached = TRUE; // attached to the bus
    pdoData->Removed = FALSE; // no irp_mn_remove as of yet

    pdoData->UniqueID = InterlockedIncrement(&FdoData->UniqueIDCount);

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Pdo->Flags |= DO_POWER_PAGABLE;

    ExAcquireFastMutex (&FdoData->Mutex);
    InsertTailList(&FdoData->PDOs, &pdoData->Link);
    FdoData->NumPDOs++;
    ExReleaseFastMutex (&FdoData->Mutex);
}

NTSTATUS
Game_CheckHardwareIDs (
    PWCHAR                      pwszOrgId,
    PULONG                      puLenLimit,
    PFDO_DEVICE_DATA            FdoData
    )
/*++
Routine Description:
    Check that the hardware ID we've been given is matches format "Gameport\XXX" where XXX must
    be between 0x20 and 0x7f inclusive but not be a ',' or '\'. We also have to make sure that we 
    do not overrun our buffer length. The length of the total buffer must be less than MAX_DEVICE_ID_LEN
    and each individual entry must be less than 64 characters
--*/
{
    PWCHAR                      pwszId;
    ULONG                       total_length=0;
    UCHAR                       ucEntries = 0;
#if DBG
    PWCHAR                      pwszLastId;
#else
    UNREFERENCED_PARAMETER (FdoData);
#endif

    PAGED_CODE ();

    Game_KdPrint (FdoData, GAME_DBG_PNP_TRACE, ("Game_CheckHardwareIDs - given ID string %.64lS length %d \n",pwszOrgId,*puLenLimit));
    pwszId = pwszOrgId;

    //
    // Trivial rejection first  - null string
    if (*pwszId == UNICODE_NULL)
    {
        Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR,("hardware ID invalid - buffer NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Loop through at most 2 hardware IDs until the NULL terminator or end of buffer 
    //
    
    while (*pwszId != UNICODE_NULL && total_length<=*puLenLimit) 
    {
        PWCHAR                      pwszTemplate = HWID_TEMPLATE;
        ULONG                       length=0;

#if DBG
        //
        // Keep track of the beginning of each ID for debug messages
        //
        pwszLastId = pwszId;
#endif
        //
        // Limit us to 2 entries
        //
        if (++ucEntries>2)
            break;
        
        //
        // Length remaining must be long enough for an completion entry
        // Which is template + 4 characters (slash,char,null,null)
        //
        if (HWID_TEMPLATE_LENGTH + 4 > (*puLenLimit)-total_length)
        {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - entry too short\n",pwszLastId));
                return STATUS_INVALID_PARAMETER;
        }

        
        //
        // Hardware ID must start with HWID_TEMPLATE
        //
        while (++length <= HWID_TEMPLATE_LENGTH)
        {
            if (LOWERCASE(*(pwszId++)) != *(pwszTemplate++))
            {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - does not match template\n",pwszLastId));
                return STATUS_INVALID_PARAMETER;
            }
        }
        //
        // Must have a separator
        //
        if ((*(pwszId++) != OBJ_NAME_PATH_SEPARATOR)) 
        {
            Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                      ("hardware ID \"%.64lS\" invalid - no separator\n",pwszLastId));
            return STATUS_INVALID_PARAMETER;
        }
        //
        // We have a successful match of HWID_TEMPLATE_LENGTH + 1 characters
        // Now our Id string check - check for NULL case first
        //
        if (*pwszId == UNICODE_NULL)
        {
            Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                      ("hardware ID \"%.64lS\" invalid format\n",pwszLastId));
            return STATUS_INVALID_PARAMETER;
        }
        //
        // Otherwise we loop until we overrun or hit NULL
        while ((++length + total_length < *puLenLimit) && (*pwszId != UNICODE_NULL))
        {
            if ((*pwszId == OBJ_NAME_PATH_SEPARATOR) ||
                (*pwszId < 0x20) ||
                (*pwszId > 0x7f) ||
                (*pwszId == L','))
            {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - bad character at length=%d\n",pwszLastId,length));
                return STATUS_INVALID_PARAMETER;
            }
            if (length > 64)
            {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - ID %d too long at length=%d\n",pwszLastId,ucEntries,length));
                return STATUS_INVALID_PARAMETER;
            }
            pwszId++;
        }

        //
        // We need to increment to either the second NULL or next string
        // If we had a null we test for either another entry or final NULL
        // in the while loop
        // If we ran too far we will pick it up in the while loop test and break 
        // out of the loop.
        //
        total_length += length;
        pwszId++;
    }

    // 
    // If we have run off the end of the buffer return an error
    //
    if (total_length > *puLenLimit) 
    {
        Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                      ("hardware ID \"%.64lS\" invalid - length > buffer limit\n",pwszLastId));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy the actual (maybe truncated) length back to the caller
    //
    *puLenLimit = ++total_length;

    Game_KdPrint (FdoData, GAME_DBG_PNP_TRACE, ("Game_CheckHardwareIDs - succeeded. Final ID string \"%.64lS\" length %d \n",pwszOrgId,*puLenLimit));

    return STATUS_SUCCESS;
}

NTSTATUS
Game_Expose (
    PGAMEENUM_EXPOSE_HARDWARE   Expose,
    ULONG                       ExposeSize,
    PFDO_DEVICE_DATA            FdoData
    )
/*++
Routine Description:
    This driver has just detected a new device on the bus.  (Actually the
    control panels has just told us that something has arived, but who is
    counting?)

    We therefore need to create a new PDO, initialize it, add it to the list
    of PDOs for this FDO bus, and then tell Plug and Play that all of this
    happened so that it will start sending prodding IRPs.
--*/
{
    PDEVICE_OBJECT      pdo, firstPdo = NULL;
    PLIST_ENTRY         entry;
    PPDO_DEVICE_DATA    pdoData;
    NTSTATUS            status;
    ULONG               length;
    KIRQL               irql;
    BOOLEAN             first = TRUE;
    UCHAR               nameIndex, i;

    PAGED_CODE ();

    if (FdoData->Self != Expose->PortHandle) {
        return STATUS_INVALID_PARAMETER;
    }
    else if (FdoData->NumPDOs != 0) {
        //
        // Only one valid expose per PDO ... a remove hardware will decrement
        //  NumPDOs to 0
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    else if (Expose->NumberJoysticks > 2 || Expose->NumberJoysticks < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    length = (ExposeSize - sizeof (GAMEENUM_EXPOSE_HARDWARE))/sizeof(WCHAR);
    if (length >MAX_DEVICE_ID_LEN) {
     Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                  ("Expose failed because length of Hardware ID too long at %d\n",length));
       return STATUS_INVALID_PARAMETER;
    }
    Game_KdPrint (FdoData, GAME_DBG_PNP_INFO, 
                  ("Exposing PDO\n"
                   "======PortHandle:     0x%x\n"
                   "======NumJoysticks:   %d\n"
                   "======NumAxis:        %d\n"
                   "======NumButtons:     %d\n"
                   "======HardwareId:     %ws\n"
                   "======Length:         %d\n",
                   Expose->PortHandle,
                   Expose->NumberJoysticks,
                   Expose->NumberAxis,
                   Expose->NumberButtons,
                   Expose->HardwareIDs,
                   length));

#if DBG
    for (i = 0; i < SIZE_GAMEENUM_OEM_DATA; i++) {
        Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
                      ("=====OemData[%d] = 0x%x\n",
                       i,
                       Expose->OemData[i]
                       ));
    }
#endif

    status = Game_CheckHardwareIDs (Expose->HardwareIDs, &length, FdoData);
            
    if (!NT_SUCCESS (status)) {
        return status;
    }

    //
    // Create the PDOs
    //
    nameIndex = 0;
    length *= sizeof(WCHAR);
    
    Game_KdPrint(FdoData, GAME_DBG_PNP_NOISE,
                 ("GAME:  Expose->HardwareHandle = 0x%x\n", FdoData->TopOfStack));

    Expose->HardwareHandle = FdoData->TopOfStack;

    for (i = 0; i < Expose->NumberJoysticks; i++) {
        status = Game_CreatePdo (FdoData,
                                 &nameIndex,
                                 &pdo);

        if (!NT_SUCCESS (status)) {
            pdo = NULL;
            goto GameExposeError;
        }

        ASSERT (pdo != NULL);

        if (!firstPdo) {
            firstPdo = pdo;
        }

        pdoData = (PPDO_DEVICE_DATA) pdo->DeviceExtension;

        //
        // Copy the hardware IDs
        //
        if (NULL == (pdoData->HardwareIDs = ExAllocatePool(NonPagedPool, length))) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GameExposeError;
        }
        RtlCopyMemory (pdoData->HardwareIDs, Expose->HardwareIDs, length);

        //
        // If there are more than two IDs, the check returns the length for 
        // the first two.  In case there were more than two, zero out the 
        // last WCHAR of the copy in order to double NULL terminate.
        //
        pdoData->HardwareIDs[(length/sizeof(WCHAR))-1] = UNICODE_NULL;

        if (1 == Expose->NumberJoysticks) {
            pdoData->Portion = GameenumWhole;
        }
        else if (2 == Expose->NumberJoysticks) {
            if (first) {
                pdoData->Portion = GameenumFirstHalf;
                first = FALSE;
            }
            else {
                pdoData->Portion = GameenumSecondHalf;
            }
        }


        pdoData->UnitID = Expose->UnitID;
        pdoData->NumberAxis = Expose->NumberAxis;
        pdoData->NumberButtons = Expose->NumberButtons;

        
        pdoData->AnalogCompatible = ( Expose->Flags & ( GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID ) )
                                    != ( GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID );

        RtlCopyMemory (&pdoData->OemData,
                       &Expose->OemData,
                       sizeof(GAMEENUM_OEM_DATA));

        Game_InitializePdo (pdo,
                            FdoData);
    }

    IoInvalidateDeviceRelations (FdoData->UnderlyingPDO, BusRelations);

GameExposeError:
    if (!NT_SUCCESS(status)) {

        //
        // Clean up the current pdo.  
        //
        if (pdo) {
            IoDeleteDevice(pdo);
        }

        //
        // delete the first PDO if it exists.  More to do here b/c it was
        // actually fully initialized
        //
        if (!first) {
            ASSERT(firstPdo != NULL);

            pdoData = (PPDO_DEVICE_DATA) firstPdo->DeviceExtension;

            ASSERT (pdoData->Portion == GameenumFirstHalf);
            ExFreePool (pdoData->HardwareIDs);
            pdoData->HardwareIDs = NULL;

            IoDeleteDevice (firstPdo);
        }

        //
        // remove all pdos from our linked list
        //
        for (entry = FdoData->PDOs.Flink;
             entry != &FdoData->PDOs;
             entry = entry->Flink) {
            pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
            RemoveEntryList (&pdoData->Link);
        }

        FdoData->NumPDOs = 0;
        FdoData->UniqueIDCount = GAMEENUM_UNIQUEID_START;
        Expose->HardwareHandle = NULL;
    }

    return status;
}

NTSTATUS
Game_ExposeSibling (
    PGAMEENUM_EXPOSE_SIBLING    ExposeSibling,
    PPDO_DEVICE_DATA            SiblingPdo
    )
/*++
Routine Description:
    This driver has just detected a new device on the bus.  (Actually the
    control panels has just told us that something has arived, but who is
    counting?)

    We therefore need to create a new PDO, initialize it, add it to the list
    of PDOs for this FDO bus, and then tell Plug and Play that all of this
    happened so that it will start sending prodding IRPs.
--*/
{
    UCHAR               nameIndex, i;
    PDEVICE_OBJECT      pdo;
    PPDO_DEVICE_DATA    pdoData;
    PFDO_DEVICE_DATA    fdoData;
    ULONG               length;
    PWCHAR              buffer;

    NTSTATUS            status;

    PAGED_CODE ();

    fdoData = FDO_FROM_PDO (SiblingPdo);

    //
    // Check to make sure we have a valid multi sz string before we allocate
    // device objects and other assorted items
    //
    if (ExposeSibling->HardwareIDs) {
        //
        // We don't know how long the hardware IDs are but the value 
        // of MAX_DEVICE_ID_LEN is the most allowed.
        //
        length = MAX_DEVICE_ID_LEN;
        status = Game_CheckHardwareIDs (ExposeSibling->HardwareIDs, &length, fdoData);
    }
    else {
        length = 0;
        status = STATUS_SUCCESS;
    }

    Game_KdPrint (SiblingPdo, GAME_DBG_PNP_INFO, 
                  ("Exposing Sibling PDO\n"
                   "======HardwareHandle: 0x%x\n"
                   "======UnitID:         %d\n"
                   "======Sting Length:   %d\n",
                   ExposeSibling->HardwareHandle,
                   (ULONG) ExposeSibling->UnitID,
                   length
                   ));

#if DBG
    for (i = 0; i < SIZE_GAMEENUM_OEM_DATA; i++) {
        Game_KdPrint (SiblingPdo, GAME_DBG_PNP_INFO,
                      ("=====OemData[%d] = 0x%x\n",
                       i,
                       ExposeSibling->OemData[i]
                       ));
    }
#endif


    if (!NT_SUCCESS (status)) {
        return status;
    }

    //
    // nameIndex could start at fdoData->NumPDOs, but if a sibling is removed
    // then we want to fill the "hole" it left in the gameenum namespace
    //
    nameIndex = 0;

    status = Game_CreatePdo (fdoData,
                             &nameIndex,
                             &pdo);

    if (!NT_SUCCESS (status)) {
        if (pdo) 
            IoDeleteDevice (pdo);

        return status;
    } 

    ASSERT (pdo != NULL);

    Game_KdPrint (fdoData, GAME_DBG_PNP_NOISE,
                  ("ExposeSibling->HardwareHandle = 0x%x\n", pdo));

    ExposeSibling->HardwareHandle = pdo;

    pdoData = (PPDO_DEVICE_DATA) pdo->DeviceExtension;
    pdoData->UnitID = ExposeSibling->UnitID;
    RtlCopyMemory (&pdoData->OemData,
                   &ExposeSibling->OemData,
                   sizeof(GAMEENUM_OEM_DATA));

    //
    // Check to see if the multi sz was supplied
    //
    if (length) {
        //
        // Another hardware ID was given ... use it!
        //
        Game_KdPrint (fdoData, GAME_DBG_PNP_INFO,
                      ("Using IDs from struct\n"));

        //
        // Length now represents the actual size of memory to copy instead of 
        // the number of chars in the array
        //
        length *= sizeof(WCHAR);
        buffer = ExposeSibling->HardwareIDs;
    }
    else {
        //
        // No hardware ID was given, use the siblings ID
        //
        Game_KdPrint (fdoData, GAME_DBG_PNP_INFO,
                      ("Using IDs from sibling\n"));

        buffer = SiblingPdo->HardwareIDs;
    
        while (*(buffer++)) {
            while (*(buffer++)) {
                ;
            }
        }
 
        length = (ULONG) (buffer - SiblingPdo->HardwareIDs) * sizeof (WCHAR);
        buffer = SiblingPdo->HardwareIDs;
    }

    pdoData->HardwareIDs = ExAllocatePool(NonPagedPool, length);
    if (NULL == pdoData->HardwareIDs) {
        IoDeleteDevice (pdo);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (pdoData->HardwareIDs, buffer, length);

    //
    // If there are more than two IDs, the check returns the length for the 
    // first two.  In case there were more than two, zero out the last WCHAR 
    // of the copy in order to double NULL terminate.
    //
    pdoData->HardwareIDs[(length/sizeof(WCHAR))-1] = UNICODE_NULL;

    pdoData->AnalogCompatible = SiblingPdo->AnalogCompatible;

    Game_InitializePdo (pdo,
                        fdoData);

    IoInvalidateDeviceRelations (fdoData->UnderlyingPDO, BusRelations);

    return status;
}

NTSTATUS
Game_Remove (
    PGAMEENUM_REMOVE_HARDWARE   Remove,
    PFDO_DEVICE_DATA            FdoData
    )
{
    PAGED_CODE ();

    ASSERT (Remove->Size == sizeof(GAMEENUM_REMOVE_HARDWARE));

    if (Remove->HardwareHandle != FdoData->TopOfStack) {
        Game_KdPrint(FdoData, GAME_DBG_PNP_NOISE,
                     ("GAME:  Remove->HardwareHandle = 0x%x, expecting 0x%x\n",
                      Remove->HardwareHandle, FdoData->TopOfStack));
    
        return STATUS_INVALID_PARAMETER;
    }

    return Game_RemoveEx (NULL, FdoData);
}

NTSTATUS
Game_RemoveSelf (
    PPDO_DEVICE_DATA            PdoData
    )
{
    PAGED_CODE ();

    return Game_RemoveEx (PdoData->Self, FDO_FROM_PDO (PdoData) );
}

NTSTATUS
Game_RemoveEx (
    PDEVICE_OBJECT              RemoveDO,
    PFDO_DEVICE_DATA            FdoData
    )
/*++
Routine Description:
    This driver has just detected that a device has departed from the bus.
    (Atcually either the control panel has just told us that somehting has
    departed or a PDO has removed itself)
    
    We therefore need to flag the PDO as no longer attached, remove it from
    the linked list of PDOs for this bus, and then tell Plug and Play about it.
    
Parameters

    RemoveDO - if NULL, then remove all the items in the list, otherwise
               it is the PDO to remove from the list

    FdoData - contains the list to iterate over                    
                    
Returns:

    STATUS_SUCCESS upon successful removal from the list
    STATUS_INVALID_PARAMETER if the removal was unsuccessful
    
--*/
{
    PLIST_ENTRY         entry;
    PPDO_DEVICE_DATA    pdoData;
    BOOLEAN             found = FALSE, removeAll = (RemoveDO == NULL);
    PVOID               handle = NULL;

    PAGED_CODE ();

    ExAcquireFastMutex (&FdoData->Mutex);

    if (removeAll) {
        Game_KdPrint (FdoData, GAME_DBG_IOCTL_NOISE,
                      ("removing all the pdos!\n"));
    }
    else {
        Game_KdPrint (FdoData, GAME_DBG_IOCTL_NOISE,
                      ("removing 0x%x\n", RemoveDO));
    }

    if (FdoData->NumPDOs == 0) {
        //
        // We got a 2nd remove...somebody in user space isn't playing nice!!!
        //
        Game_KdPrint (FdoData, GAME_DBG_IOCTL_ERROR,
                      ("BAD BAD BAD...2 removes!!! Send only one!\n"));
        ExReleaseFastMutex (&FdoData->Mutex);
        return STATUS_NO_SUCH_DEVICE;
    }

    for (entry = FdoData->PDOs.Flink;
         entry != &FdoData->PDOs;
         entry = entry->Flink) {

        pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
        handle = pdoData->Self;

        Game_KdPrint (FdoData, GAME_DBG_IOCTL_NOISE,
                      ("found DO 0x%x\n", handle));

        if (removeAll || handle == RemoveDO) {
            Game_KdPrint (FdoData, GAME_DBG_IOCTL_INFO,
                          ("removed 0x%x\n", handle));

            pdoData->Attached = FALSE;
            RemoveEntryList (&pdoData->Link);
            FdoData->NumPDOs--;
            found = TRUE;
            if (!removeAll) {
                break;
            }
        }
    }
    ExReleaseFastMutex (&FdoData->Mutex);

    if (FdoData->NumPDOs == 0) {
        FdoData->UniqueIDCount = GAMEENUM_UNIQUEID_START;
    }
    
    if (found) {
        IoInvalidateDeviceRelations (FdoData->UnderlyingPDO, BusRelations);
        return STATUS_SUCCESS;
    }

    Game_KdPrint (FdoData, GAME_DBG_IOCTL_ERROR,
                  ("0x%x was not removed (not in list)\n", RemoveDO));
    return STATUS_INVALID_PARAMETER;
}


NTSTATUS
Game_ListPorts (
    PGAMEENUM_PORT_DESC Desc,
    PFDO_DEVICE_DATA    FdoData
    )
/*++
Routine Description:
    This driver has just detected that a device has departed from the bus.
    (Actually the control panels has just told us that something has departed,
    but who is counting?

    We therefore need to flag the PDO as no longer attached, remove it from
    the linked list of PDOs for this bus, and then tell Plug and Play about it.
--*/
{
    PAGED_CODE ();

    Desc->PortHandle = FdoData->Self;
    Desc->PortAddress = FdoData->PhysicalAddress;

    return STATUS_SUCCESS;
}

NTSTATUS
Game_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
    We do nothing special for power;

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = Game_FDO_Power ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                                Irp);
    } else {
        status = Game_PDO_Power ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                                Irp);
    }

    return status;
}

NTSTATUS
Game_PowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
Game_FdoPowerTransitionPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA fdoData;

    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (IoStatus);

    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (SystemStateIrp);

    if (DevicePowerState.DeviceState == PowerDeviceD0) {
        //
        // We are powering up (the D0 Irp just completed).  Since we sent the
        // S irp down the stack and requested the D irp on the way back up the
        // stack, just complete the S irp now
        //

        PoSetPowerState (DeviceObject,
                         stack->Parameters.Power.Type,
                         stack->Parameters.Power.State);
    
        fdoData->SystemState = stack->Parameters.Power.State.SystemState;

        SystemStateIrp->IoStatus.Status = IoStatus->Status;
        PoStartNextPowerIrp (SystemStateIrp);
        IoCompleteRequest (SystemStateIrp, IO_NO_INCREMENT);

        //
        // From Game_FDO_Power when we originally received the IRP
        //
        Game_DecIoCount (fdoData);
    }
    else {
        //
        // We are powering down (the D3 Irp just completed).  Since we requested
        // the D irp before sending the S irp down the stack, we must send it 
        // down now.  We will catch the S irp on the way back up to record the 
        // S state
        //
        ASSERT (DevicePowerState.DeviceState == PowerDeviceD3);
    
        IoCopyCurrentIrpStackLocationToNext (SystemStateIrp);

        IoSetCompletionRoutine (SystemStateIrp,
                                Game_PowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);
    
        PoCallDriver (fdoData->TopOfStack, SystemStateIrp);
    }
}

VOID
Game_PdoPowerDownComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDO_DEVICE_DATA data = (PFDO_DEVICE_DATA) Context;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);

#if !DBG
    UNREFERENCED_PARAMETER (IoStatus);
#endif

    ASSERT( NT_SUCCESS (IoStatus->Status));

    if (0 == InterlockedDecrement (&data->PoweredDownDevices)) {
        KeSetEvent (&data->PoweredDownEvent, 1, FALSE);
    }
}

NTSTATUS
Game_PowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (Context);

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;
    status = STATUS_SUCCESS; 

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:

            //
            // Power up complete
            //
            ASSERT (powerState.DeviceState < data->DeviceState);
            data->DeviceState = powerState.DeviceState;
            PoSetPowerState (data->Self, powerType, powerState);
            break;

        case SystemPowerState:
            //
            // Ususally the work of requesting the Device Power IRP on
            // behalf of the SystemPower Irp is work done by the Function
            // (FDO) driver.  In order, however that Joystick function drivers
            // have a more simplified power code path (AKA they merely need
            // pass on ALL power IRPS) will will do this work for them in the
            // PDO.
            //
            // NB: This assumes that we will never have any "clever" power
            // management for a gaming device attached through a legacy
            // gaming port.  By which I mean that the HIDGame driver will not
            // be able to select a "D" state based on the "S" state; as it is
            // done for the HidGame driver.
            //
            // Any yahoo putting wakeup capabilities into a legacy joystick
            // should be shot.  It will require special hardware.  If you are
            // adding extra hardware then you should not be doing so to this
            // nasty RC circuit.
            //

            if (powerState.SystemState > data->SystemState) {
                //
                // Powering Down...
                //
                // We are on the completion end of an S irp.  (The D3 power irp
                // has already been sent and completed down this stack.)  The
                // remaining thing to do is set the state in the extension, then
                // decrement the IoCount that was incremented when we first got
                // the irp (this is done at the end of this function).
                //
                data->SystemState = powerState.SystemState;

                PoSetPowerState (data->Self,
                                 stack->Parameters.Power.Type,
                                 stack->Parameters.Power.State);
            }
            else {
                //
                // Powering Up...
                //
                // Request a D power irp for ourself.  Do not complete this S irp
                // until the D irp has been completed.  (Completion of the S irp
                // is done in Game_FdoPowerTransitionPoRequestComplete). 
                // Decrementing the IO count will happen in the same function.
                //
                ASSERT (powerState.SystemState < data->SystemState);
    
                powerState.DeviceState = PowerDeviceD0;
                status =
                    PoRequestPowerIrp (data->Self,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       Game_FdoPowerTransitionPoRequestComplete,
                                       Irp, 
                                       NULL); // no return Irp
    
                if (status != STATUS_PENDING) {
                    ASSERT (!NT_SUCCESS (status));
    
                    Irp->IoStatus.Status = status;
                    PoStartNextPowerIrp (Irp);
    
                    Game_DecIoCount (data);
                }
                else {
                    //
                    // We need to:
                    // Start next power irp, release the removelock, and complete
                    // the irp in the PoRequestComplete routine.
                    //
                    //
                    // The irp might completed by the time we get here, so call
                    // PoStartNextPowerIrp in the PO irp completion function.
                    //
                    status = STATUS_MORE_PROCESSING_REQUIRED; 
                }
    
                return status;
            }
            break;
        }
        break;

    default:
        #define GAME_UNHANDLED_MN_POWER 0x0
        ASSERT (0xBADBAD == GAME_UNHANDLED_MN_POWER);
        #undef GAME_UNHANDLED_MN_POWER 
        
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (NT_SUCCESS(status)) {
        PoStartNextPowerIrp (Irp);
        Game_DecIoCount (data);
    }

    return status;
}

NTSTATUS
Game_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
{
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE, wait = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PLIST_ENTRY         entry;
    PPDO_DEVICE_DATA    pdoData;

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    PAGED_CODE ();

    status = Game_IncIoCount (Data);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Game_KdPrint(Data,
                     GAME_DBG_PNP_TRACE,
                     ("Game-PnP Setting %s state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:

            status = Irp->IoStatus.Status = STATUS_SUCCESS;

            if (Data->DeviceState == powerState.DeviceState) {
                break;

            } else if (Data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //

                //
                // Iterate through the PDOs and make sure that they are all
                // powered down.
                //
                // Initially set PoweredDownDevices to the number of PDOs.  If
                // a pdo is not powered down, PoweredDownDevices will be
                // decremented upon completion of the power down irp sent to 
                // that particular PDO.  Otherwise, the PDO is already powered
                // down so just decrement the count.
                //
                Data->PoweredDownDevices = Data->NumPDOs;
                KeInitializeEvent (&Data->PoweredDownEvent,
                                   SynchronizationEvent,
                                   FALSE);

                for (entry = Data->PDOs.Flink;
                     entry != &Data->PDOs;
                     entry = entry->Flink) {
            
                    pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
                    if (pdoData->DeviceState == PowerDeviceD0) {
                        wait = TRUE;

                        powerState.DeviceState = PowerDeviceD3;
                        PoRequestPowerIrp (pdoData->Self,
                                           IRP_MN_SET_POWER,
                                           powerState,
                                           Game_PdoPowerDownComplete, 
                                           Data, 
                                           NULL);
                    }
                    else {
                        //
                        // All the power down irps to the PDOs can complete 
                        // before we get to this already powered down PDO, so
                        // set the event if it is the last and we have a PDO 
                        // that needed powering down.
                        //
                        if (InterlockedDecrement(&Data->PoweredDownDevices) == 0
                            && wait) {
                            KeSetEvent (&Data->PoweredDownEvent, 1, FALSE);
                        }

                    }

                }

                if (wait) {
                    KeWaitForSingleObject (&Data->PoweredDownEvent,
                                                    Executive,
                                                    KernelMode,
                                                    FALSE, 
                                                    NULL); 

#if DBG
                    ///
                    // Make SURE that all the PDOs are trully powered down
                    //
                    for (entry = Data->PDOs.Flink;
                         entry != &Data->PDOs;
                         entry = entry->Flink) {
                        pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
                        ASSERT(pdoData->DeviceState != PowerDeviceD0);
                    }
#endif
                }

                ASSERT(Data->PoweredDownDevices == 0);

                //
                // Make sure powerState is the one sent down to us, not the 
                // modified version above
                //
                powerState = stack->Parameters.Power.State;
                PoSetPowerState (Data->Self, powerType, powerState);
                Data->DeviceState = powerState.DeviceState;

            } else {
                //
                // Powering Up
                //
                hookit = TRUE;
            }

            break;

        case SystemPowerState:

            if (Data->SystemState == powerState.SystemState) {
                status = STATUS_SUCCESS;

            } else if (Data->SystemState < powerState.SystemState) {
                //
                // Powering down
                //

                //
                // Request a D3 irp in response to this S irp.  The D3 irp must
                // completed before send this S irp down the stack.  We will send
                // the S irp down the stack when
                // Game_FdoPowerTransitionPoRequestComplete is called.
                //

                //
                // We don't need to increment our IO count b/c we incremented it
                // at the beginning of this function and won't decrement it until
                // the S Irp completes
                // 
                IoMarkIrpPending (Irp);
                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (Data->Self,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   Game_FdoPowerTransitionPoRequestComplete,
                                   Irp,
                                   NULL);  // no IRP
                
                return STATUS_PENDING;

            } else {
                //
                // Powering Up
                //
                
                // 
                // We must request a D irp for this S irp, but only after the S
                // irp has come back up the stack.  Hook the return of the irp
                // and request the D irp in Game_PowerComplete
                //
                hookit = TRUE;
            }
            break;
        }

        break;

    case IRP_MN_QUERY_POWER:
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        break;
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    if (hookit) {
        ASSERT (STATUS_SUCCESS == status);
        //
        // If we are returning STATUS_PENDING, the irp must marked as such as well
        //
        IoMarkIrpPending (Irp);

        IoSetCompletionRoutine (Irp,
                                Game_PowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        //
        // NOTE!!! PoCallDriver NOT IoCallDriver.
        //
        PoCallDriver (Data->TopOfStack, Irp);

        //
        // We are returning pending instead of the result from PoCallDriver becuase:
        // 1  we are changing the status in the completion routine
        // 2  we will not be completing this irp in the completion routine
        //
        status = STATUS_PENDING;
    } else {
        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power
        // irp.  This can be called here, or in the completetion
        // routine, but never the less must be called.
        //
        PoStartNextPowerIrp (Irp);

        status =  PoCallDriver (Data->TopOfStack, Irp);

        Game_DecIoCount (Data);
    }

    return status;
}

VOID
Game_PdoPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  stack;
    PPDO_DEVICE_DATA    pdoData;

    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (DevicePowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    pdoData = (PPDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (SystemStateIrp);

    PoSetPowerState (DeviceObject,
                     stack->Parameters.Power.Type,
                     stack->Parameters.Power.State);

    pdoData->SystemState = stack->Parameters.Power.State.SystemState;
    
    //
    // Set the S irp's status to the status of the D irp
    //
    SystemStateIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp (SystemStateIrp);
    IoCompleteRequest (SystemStateIrp, IO_NO_INCREMENT);
}

NTSTATUS
Game_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
{
    KIRQL               irql;
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            PoSetPowerState (PdoData->Self, powerType, powerState);
            PdoData->DeviceState = powerState.DeviceState;
            break;

        case SystemPowerState:

            //
            // Make the IRP pending and request a D irp for this stack.  When
            // the D irp completes, Game_PdoPoRequestComplete will be called.  In
            // that function, we complete this S irp
            //
            IoMarkIrpPending(Irp);

            if (PowerSystemWorking == powerState.SystemState) {
                powerState.DeviceState = PowerDeviceD0;
            } else {
                powerState.DeviceState = PowerDeviceD3;
            }

            status = PoRequestPowerIrp (PdoData->Self,
                                        IRP_MN_SET_POWER,
                                        powerState,
                                        Game_PdoPoRequestComplete, 
                                        Irp, 
                                        NULL); // no return IRP

            if (status != STATUS_PENDING) {
                ASSERT (!NT_SUCCESS (status));
                break;
            }

            return status;

        default:
            TRAP ();
            status = STATUS_NOT_IMPLEMENTED;
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
    default:
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    PoStartNextPowerIrp (Irp);
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\analog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    analog.h

Abstract:  Contains definitions specific to analog joysticks.


Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    MarcAnd     03-Jan-99   Split from hidgame.h and hidjoy.c

Revision History:


@@END_DDKSPLIT

--*/
#ifndef __ANALOG_H__
    #define __ANALOG_H__

/*
 *  If you change any of the scaling or timeout values you have to check
 *  that overflows are still avoided under reasonable circumstances.
 */

/*
 *  The timeout value should be passed in DEVICE_EXTENSION.oemData.Timeout
 *  so these limits are a sanity check and default value
 *  The largest expected value is 8mS, use 10 for safety
 */
    #define ANALOG_POLL_TIMEOUT_MIN     (   100L )
    #define ANALOG_POLL_TIMEOUT_DFT     ( 10000L )
    #define ANALOG_POLL_TIMEOUT_MAX     ( 20000L )


/*
 *  Slowest CPU frequency considered when calibrating the CPU timer 
 *  against the performance counter.
 */

    #define HIDGAME_SLOWEST_X86_HZ      ( 45000000 )

/*
 *  Valid axis values are scaled such that a poll of exactly 
 *  ANALOG_POLL_TIMEOUT_MAX mS should return this value
 *  Any analog value greater than this is a timeout
 */
    #define AXIS_FULL_SCALE         ( ANALOG_POLL_TIMEOUT_MAX )

/*
 *  Number of bits to shift left to get a scaled value
 *  This is used so that we can always use an integer multiply of the 
 *  number of counter ticks the poll took to scale the value.
 */
    #define SCALE_SHIFT             16

/*
 *  Macro to calculate a scaling factor from a (ULONGLONG)frequency
 */
#if AXIS_FULL_SCALE == ANALOG_POLL_TIMEOUT_MAX
    #define CALCULATE_SCALE( _Freq_ ) \
        (ULONG)( ( (ULONGLONG)( 1000000 ) << SCALE_SHIFT ) \
               / _Freq_ )
#else
    #define CALCULATE_SCALE( _Freq_ ) \
        (ULONG)( ( (ULONGLONG)AXIS_FULL_SCALE \
                 * ( (ULONGLONG)( 1000000 ) << SCALE_SHIFT ) ) \
                   / ANALOG_POLL_TIMEOUT_MAX ) \
               / _Freq_ )
#endif



    #define HGM_NUMBER_DESCRIPTORS      ( 1 )


    #define MAX_AXES                    ( 4 )
    #define PORT_BUTTONS                ( 4 )
    #define MAX_BUTTONS                 ( 10 )

    #define INVALID_INDEX               ( 0x80 )


/* Specific settings for joystick hardware */
    #define JOY_HWS_HASZ                ( 0x00000001l )     /* has Z info? */
    #define JOY_HWS_HASPOV              ( 0x00000002l )     /* point of view hat present */
    #define JOY_HWS_POVISBUTTONCOMBOS   ( 0x00000004l )     /* pov done through combo of buttons */
    #define JOY_HWS_POVISPOLL           ( 0x00000008l )     /* pov done through polling */

    #define JOY_HWS_ISYOKE              ( 0x00000010l )     /* joystick is a flight yoke */
    #define JOY_HWS_ISGAMEPAD           ( 0x00000020l )     /* joystick is a game pad */
    #define JOY_HWS_ISCARCTRL           ( 0x00000040l )     /* joystick is a car controller */
    
    #define JOY_HWS_HASR                ( 0x00080000l )     /* has R (4th axis) info */
    #define JOY_HWS_HASU                ( 0x00800000l )     /* has U (5th axis) info */
    #define JOY_HWS_HASV                ( 0x01000000l )     /* has V (6th axis) info */

/*
 *  The following flags are for changing which gameport bit should be polled 
 *  for an axis.  These are only interpreted by the analog driver and could 
 *  therefore be safely reinterpreted in other ways by other drivers.
 */

/* X defaults to J1 X axis */
    #define JOY_HWS_XISJ1Y              ( 0x00000080l )     /* X is on J1 Y axis */
    #define JOY_HWS_XISJ2X              ( 0x00000100l )     /* X is on J2 X axis */
    #define JOY_HWS_XISJ2Y              ( 0x00000200l )     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
    #define JOY_HWS_YISJ1X              ( 0x00000400l )     /* Y is on J1 X axis */
    #define JOY_HWS_YISJ2X              ( 0x00000800l )     /* Y is on J2 X axis */
    #define JOY_HWS_YISJ2Y              ( 0x00001000l )     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
    #define JOY_HWS_ZISJ1X              ( 0x00002000l )     /* Z is on J1 X axis */
    #define JOY_HWS_ZISJ1Y              ( 0x00004000l )     /* Z is on J1 Y axis */
    #define JOY_HWS_ZISJ2X              ( 0x00008000l )     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
    #define JOY_HWS_POVISJ1X            ( 0x00010000l )     /* pov done through J1 X axis */
    #define JOY_HWS_POVISJ1Y            ( 0x00020000l )     /* pov done through J1 Y axis */
    #define JOY_HWS_POVISJ2X            ( 0x00040000l )     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
    #define JOY_HWS_RISJ1X              ( 0x00100000l )     /* R done through J1 X axis */
    #define JOY_HWS_RISJ1Y              ( 0x00200000l )     /* R done through J1 Y axis */
    #define JOY_HWS_RISJ2Y              ( 0x00400000l )     /* R done through J2 X axis */


/*
 *  If POV is button-combo we overload this meaningless axis selection bit
 *  to indicate a second POV.
 */
    #define JOY_HWS_HASPOV2             JOY_HWS_POVISJ2X


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct HIDGAME_INPUT_DATA |
 *
 *          Our HID reports always have 4 axis values (one of which may be a 
 *          polled POV), 2 digital POVs and 10 buttons.
 *          Depending on the HWS flags and number of buttons some of the 
 *          fields will report constant data.
 *
 *          Note, this structure should be byte aligned so that the 
 *          sizeof(it) is the same as HID will calculate given the report 
 *          descriptor.  (In this case it happens to be aligned anyway.)
 *
 *  @field  ULONG | Axis[MAX_AXES] |
 *
 *          Axes data values.
 *
 *  @field  UCHAR | hatswitch[2] |
 *
 *          digital POVs (derived from button combos)
 *
 *  @field  UCHAR | Button[MAX_BUTTONS] |
 *
 *          Button data values.
 *
 *****************************************************************************/
#include <pshpack1.h>

typedef struct _HIDGAME_INPUT_DATA
{
    ULONG   Axis[MAX_AXES];
    UCHAR   hatswitch[2];
    UCHAR   Button[MAX_BUTTONS];
} HIDGAME_INPUT_DATA, *PHIDGAME_INPUT_DATA;
typedef struct _HIDGAME_INPUT_DATA UNALIGNED *PUHIDGAME_INPUT_DATA;

#include <poppack.h>




/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct OEMDATA |
 *
 *          OEMData is send to gameEnum as a parameter to IOCTL_EXPOSE_HARDWARE.
 *          Defined as 8 DWORDS. We interpert them here
 *
 *  @field  USHORT | VID |
 *
 *          Vendor ID
 *
 *  @field  USHORT | PID |
 *
 *          Product ID
 *
 *  @field  ULONG | joy_hws_dwFlags |
 *
 *          The dwFlags fields for the device ( Usually read from the registry )
 *
 *  @field  ULONG   | Timeout |
 *
 *          Global timeout for device polling in micro seconds
 *
 *  @field  ULONG   | Reserved |
 *
 *          Reserved for future use.
 *
 *
 *****************************************************************************/
typedef struct _OEMDATA
{
    USHORT  VID;
    USHORT  PID;
    ULONG   joy_hws_dwFlags;
    ULONG   Timeout;
    ULONG   Reserved;

} OEMDATA, *POEMDATA;


typedef struct _HIDGAME_OEM_DATA
{
    union
    {
        OEMDATA OemData[2];
        GAMEENUM_OEM_DATA   Game_Oem_Data;
    };
} HIDGAME_OEM_DATA, *PHIDGAME_OEM_DATA;




/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct ANALOG_DEVICE |
 *
 *          Analog Device specific data.
 *
 *  @field  USHORT | nAxes |
 *
 *          Number of axis this device has.
 *
 *  @field  USHORT | nButtons|
 *
 *          Number of buttons this device has.
 *
 *  @field  HIDGAME_OEM_DATA | HidGameOemData |
 *
 *          The OEM Data field ( Contains joy_hws_dwFlags, vid & pid )
 *
 *  @field  ULONG | ScaledTimeout |
 *          The number value at which an axis is considered to be not present.
 *
 *  @field  ULONG | ScaledThreshold |
 *
 *          The minimum resolution of a polling cycle.
 *          This is used to detect if we've been
 *          pre-empted or interrupted during a polling loop.
 *
 *  @field  ULONG | LastGoodAxis[MAX_AXES] | 
 *
 *          Value of the axes on last good poll.
 *
 *  @field  UCHAR | LastGoodButton[PORT_BUTTONS] | 
 *
 *          Value of the buttons on last good poll.
 *
 *  @field  int | AxisMap[MAX_AXES] |
 *
 *          Index of axes remapping.
 *
 *  @field  int | povMap |
 *
 *          Index of axis where POV is mapped.
 *
 *  @field  UCHAR | resistiveInputMask |
 *
 *          Resisitive Input mask.
 *
 *  @field  UCHAR | bSiblingState |
 *
 *          Indicates the state of an expose sibling\remove self transition
 *
 *  @field  BOOLEAN | fSiblingFound |
 *
 *          Set to true if this device has a sibling.
 *
 *****************************************************************************/

typedef struct _ANALOG_DEVICE
{
    /*
     *  Number of axis
     */
    USHORT                      nAxes;

    /*
     *  Number of buttons
     */
    USHORT                      nButtons;

    /*
     *  Oem Data Field
     */
    HIDGAME_OEM_DATA            HidGameOemData;

    /*  
     *  The value at which an axis in considered not present. 
     */
    ULONG                       ScaledTimeout;

    /*
     *  The minimum resolution of a polling cycle.
     *  This is used to detect if we've been pre-empted or interrupted 
     *  during a polling loop.
     */
    ULONG                       ScaledThreshold;

    /*
     *  Last known good values.  Returned if an axis result is corrupted 
     */
    ULONG                       LastGoodAxis[4];
    UCHAR                       LastGoodButton[4];

    /*
     *  Indexes used to map the data returned from a poll to the axes values 
     *  declared by the device.
     */
    int                         AxisMap[MAX_AXES];

    /*  
     *  Index of polled POV axis in the poll results
     */
    int                         povMap;

    /*
     *  Cutoff poll value between on and off for axes treated as buttons
     */
    ULONG                       button5limit;
    ULONG                       button6limit;
    
    /* 
     *  Resisitive Input mask
     */
    UCHAR                       resistiveInputMask;

    /*
     *  Set to true if the device has siblings
     */
    BOOLEAN                     fSiblingFound;

} ANALOG_DEVICE, *PANALOG_DEVICE;


#endif /* __ANALOG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\hidgame.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    hidgame.c

Abstract: Human Interface Device (HID) Gameport driver

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    Eliyas Yakub (Mar, 10, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998
    OmSharma ( April 12, 1998 )
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT

--*/


#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text( INIT, DriverEntry )
    #pragma alloc_text( PAGE, HGM_CreateClose)
    #pragma alloc_text( PAGE, HGM_AddDevice)
    #pragma alloc_text( PAGE, HGM_Unload)
    #pragma alloc_text( PAGE, HGM_SystemControl)
#endif /* ALLOC_PRAGMA */

HIDGAME_GLOBAL Global;
ULONG          debugLevel;

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | DriverEntry |
 *
 *          Installable driver initialization entry point.
 *          <nl>This entry point is called directly by the I/O system.
 *
 *  @parm   IN PDRIVER_OBJECT | DriverObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PUNICODE_STRING | RegistryPath |
 *
 *          Pointer to a unicode string representing the path,
 *          to driver-specific key in the registry.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | returned HidRegisterMinidriver()
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    DriverEntry
    (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                        ntStatus;
    HID_MINIDRIVER_REGISTRATION     hidMinidriverRegistration;

    debugLevel = HGM_DEFAULT_DEBUGLEVEL;

    HGM_DBGPRINT(FILE_HIDGAME| HGM_WARN, \
                   ("Hidgame.sys: Built %s at %s\n", __DATE__, __TIME__));

    HGM_DBGPRINT( FILE_HIDGAME | HGM_FENTRY,
                    ("DriverEntry(DriverObject=0x%x,RegistryPath=0x%x)",
                     DriverObject, RegistryPath)
                  );

    C_ASSERT(sizeof( OEMDATA[2] ) == sizeof(GAMEENUM_OEM_DATA) );


    ntStatus = HGM_DriverInit();

    if( NT_SUCCESS(ntStatus) )
    {
        DriverObject->MajorFunction[IRP_MJ_CREATE]    =
            DriverObject->MajorFunction[IRP_MJ_CLOSE] = HGM_CreateClose;
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
            HGM_InternalIoctl;
        DriverObject->MajorFunction[IRP_MJ_PNP]   = HGM_PnP;
        DriverObject->MajorFunction[IRP_MJ_POWER] = HGM_Power;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = HGM_SystemControl;
        DriverObject->DriverUnload                = HGM_Unload;
        DriverObject->DriverExtension->AddDevice  = HGM_AddDevice;

        /*
         * Register  with HID.SYS module
         */
        RtlZeroMemory(&hidMinidriverRegistration, sizeof(hidMinidriverRegistration));

        hidMinidriverRegistration.Revision            = HID_REVISION;
        hidMinidriverRegistration.DriverObject        = DriverObject;
        hidMinidriverRegistration.RegistryPath        = RegistryPath;
        hidMinidriverRegistration.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
        hidMinidriverRegistration.DevicesArePolled    = TRUE;


        HGM_DBGPRINT( FILE_HIDGAME |  HGM_BABBLE2,
                        ("DeviceExtensionSize = %d",
                         hidMinidriverRegistration.DeviceExtensionSize)
                      );

        ntStatus = HidRegisterMinidriver(&hidMinidriverRegistration);


        HGM_DBGPRINT(FILE_HIDGAME | HGM_BABBLE2,
                       ("Registered with HID.SYS, returnCode=%x",
                        ntStatus)
                      );

        if( NT_SUCCESS(ntStatus) )
        {
            /*
             *  Protect the list with a Mutex
             */
            ExInitializeFastMutex (&Global.Mutex);

            /*
             *  Initialize the device list head
             */
            InitializeListHead(&Global.DeviceListHead);

            /*
             *  Initialize gameport access spinlock
             */
            KeInitializeSpinLock(&Global.SpinLock);
        }
        else
        {
            HGM_DBGPRINT(FILE_HIDGAME | HGM_ERROR,
                           ("Failed to registered with HID.SYS, returnCode=%x",
                            ntStatus)
                          );
        }
    }
    else
    {
        HGM_DBGPRINT(FILE_HIDGAME | HGM_ERROR,
                       ("Failed to initialize a timer")
                      );
    }


    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK , "DriverEntry", ntStatus);

    return ntStatus;
} /* DriverEntry */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_CreateClose |
 *
 *          Process the create and close IRPs sent to this device.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_INVALID_PARAMETER  | Irp not handled
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_CreateClose
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION   IrpStack;
    NTSTATUS             ntStatus = STATUS_SUCCESS;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_HIDGAME | HGM_FENTRY,
                   ("HGM_CreateClose(DeviceObject=0x%x,Irp=0x%x)",
                    DeviceObject, Irp) );

    /*
     * Get a pointer to the current location in the Irp.
     */
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            HGM_DBGPRINT(FILE_HIDGAME | HGM_BABBLE,
                           ("HGM_CreateClose:IRP_MJ_CREATE") );
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            HGM_DBGPRINT(FILE_HIDGAME | HGM_BABBLE,
                           ("HGM_CreateClose:IRP_MJ_CLOSE") );
            Irp->IoStatus.Information = 0;
            break;

        default:
            HGM_DBGPRINT(FILE_HIDGAME | HGM_WARN,
                           ("HGM_CreateClose:Not handled IrpStack->MajorFunction 0x%x",
                            IrpStack->MajorFunction) );
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    /*
     * Save Status for return and complete Irp
     */

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK, "HGM_CreateClose", ntStatus);
    return ntStatus;
} /* HGM_CreateClose */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_AddDevice |
 *
 *          Called by hidclass, allows us to initialize our device extensions.
 *
 *  @parm   IN PDRIVER_OBJECT | DriverObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PDEVICE_OBJECT | FunctionalDeviceObject |
 *
 *          Pointer to a functional device object created by hidclass.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *
 *****************************************************************************/
NTSTATUS  EXTERNAL
    HGM_AddDevice
    (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          DeviceObject;
    PDEVICE_EXTENSION       DeviceExtension;

    PAGED_CODE ();

    HGM_DBGPRINT( FILE_HIDGAME | HGM_FENTRY,
                    ("HGM_AddDevice(DriverObject=0x%x,FunctionalDeviceObject=0x%x)",
                     DriverObject, FunctionalDeviceObject) );

    ASSERTMSG("HGM_AddDevice:", FunctionalDeviceObject != NULL);
    DeviceObject = FunctionalDeviceObject;

    /*
     * Initialize the device extension.
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    /*
     * Initialize the list
     */
    InitializeListHead(&DeviceExtension->Link);

    /*
     *  Acquire mutex before modifying the Global Linked list of devices
     */
    ExAcquireFastMutex (&Global.Mutex);

    /*
     * Add this device to the linked list of devices
     */
    InsertTailList(&Global.DeviceListHead, &DeviceExtension->Link);

    /*
     *  Release the mutex
     */
    ExReleaseFastMutex (&Global.Mutex);

    /*
     * Initialize the remove lock 
     */
    DeviceExtension->RequestCount = 1;
    KeInitializeEvent(&DeviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK, "HGM_AddDevice", ntStatus);

    return ntStatus;
} /* HGM_AddDevice */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_SystemControl |
 *
 *          Process the WMI IRPs sent to this device.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_INVALID_PARAMETER  | Irp not handled
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_SystemControl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    HGM_DBGPRINT(FILE_HIDGAME | HGM_FENTRY,
                   ("HGM_SystemControl(DeviceObject=0x%x,Irp=0x%x)",
                    DeviceObject, Irp) );

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
} /* HGM_SystemControl */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void  | HGM_Unload |
 *
 *          Free all the allocated resources, etc.
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *
 *****************************************************************************/
VOID EXTERNAL
    HGM_Unload
    (
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();
    HGM_DBGPRINT(FILE_HIDGAME | HGM_FENTRY,
                   ("HGM_Unload Enter"));


    /*
     * All the device objects should be gone
     */

    ASSERT ( NULL == DriverObject->DeviceObject);

    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK, "HGM_Unload:", STATUS_SUCCESS );
    return;
} /* HGM_Unload */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\debug.h ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:  Contains definitions and macros to aid debugging
           data types for the joystick driver.


Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    MarcAnd     15-Oct-98   Pulled out of hidgame.h

Revision History:

@@END_DDKSPLIT

--*/
/*
 *  Debugging macros
 */
    #undef  C_ASSERT
    #define C_ASSERT(e) switch(0) case(e): case(0):

    #define FILE_HIDGAME                0x00010000
    #define FILE_PNP                    0x00020000
    #define FILE_POLL                   0x00040000
    #define FILE_IOCTL                  0x00080000
    #define FILE_HIDJOY                 0x00100000
    #define FILE_TIMING                 0x00200000

    #define HGM_ERROR                 0x00000001
    #define HGM_WARN                  0x00000002
    #define HGM_BABBLE                0x00000004
    #define HGM_BABBLE2               0x00000008
    #define HGM_FENTRY                0x00000010
    #define HGM_FEXIT                 0x00000020
    #define HGM_GEN_REPORT            0x00008000
/*
 *  Squak if the return status is not SUCCEESS
 */
    #define HGM_FEXIT_STATUSOK        0x00001000

    #define HGM_DEFAULT_DEBUGLEVEL    0x0000001

/* @@BEGIN_DDKSPLIT */
/* Use set USER_C_FLAGS=/DDEBUGLEVEL=0x0000803f for full internal debug */
#ifdef DEBUGLEVEL
    #undef  HGM_DEFAULT_DEBUGLEVEL
    #define HGM_DEFAULT_DEBUGLEVEL    DEBUGLEVEL
#endif
/* @@END_DDKSPLIT */

    #define HGM_POOL_TAG              ('maGH')

    /* WDM.H defines DBG.  Make sure DBG is both defined and non-zero  */
    #ifdef DBG
        #if DBG
            #define TRAP()  DbgBreakPoint()
        #endif
    #endif

    #ifdef TRAP
        extern ULONG debugLevel;
        #define HGM_DBGPRINT( _debugMask_,  _x_) \
            if( (((_debugMask_) & debugLevel)) ){ \
                DbgPrint("HIDGAME.SYS: ");\
                DbgPrint _x_  ; \
                DbgPrint("\n"); \
            }
        #define HGM_EXITPROC(_debugMask_, _x_, ntStatus) \
            if( ((_debugMask_)&HGM_FEXIT_STATUSOK) && !NT_SUCCESS(ntStatus) ) {\
                HGM_DBGPRINT( (_debugMask_|HGM_ERROR), (_x_ "  ntStatus(0x%x)", ntStatus) ); }\
            else { HGM_DBGPRINT((_debugMask_), (_x_ " ntStatus(0x%x)", ntStatus));}
        #define ExAllocPool( Type, Size ) \
            ExAllocatePoolWithTag( Type, Size, HIDGAME_POOL_TAG )

    #else

        #define HGM_DBGPRINT(_x_,_y_)
        #define HGM_EXITPROC(_x_,_y_,_z_)
        #define TRAP()
        #define ExAllocPool( Type, Size ) ExAllocatePool( Type, Size )

    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\hidgame.h ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    hidgame.h

Abstract:  Contains definitions of all constants and
           data types for the joystick driver.


Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    Eliyas Yakub (Mar, 10, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998
    OmSharma ( April 12, 1998)
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT

--*/
/*****************************************************************************
 * @doc     EXTERNAL
 *
 * @module  HidGame | Analog WDM/HID Joystick driver.
 *
 *          HidGame is the HID minidriver for analog joysticks.
 *          This driver registers with the HID class driver and
 *          responds to IRPs put out by HIDclass. It informs HIDClass
 *          about the capabilities of the joystick and polls the joystick
 *          in response to a read IOCTL.
 *
 *          This driver is loaded in reponse to a "New hardware Found"
 *          PnP event, and consequently must have an entry in an inf file
 *          that binds a PnP hardware ID to this driver.
 *
 *          Gameport joysticks are not true PnP devices, so the user has to
 *          inform the system about the joystick that was added to the 
 *          gameport by using the Game Controllers CPL "Add" a joystick.
 *          An example of how a new joystick type can be created is provided 
 *          in the accompanying inf file.
 *
 *          Once a user selects a joystick and gameport, the GameCPL passes 
 *          this information to DirectInput which sends an IOCTL to the 
 *          gameport bus driver (GameEnum), specifying the number of axes, 
 *          buttons and a PnPHardware ID for the joystick. The Gameport Bus 
 *          informs PnP of a new device arrival. PnP searches the system for 
 *          a match for the hardwareID and loads the appropriate driver.
 *
 *
 *          The following files are part of this driver.
 *
 *          <nl>HidGame.c
 *              <nl>DriverEntry, CreateClose, AddDevice and Unload Routines.
 *              This code performs functions required for any device driver 
 *              and so can probably be used without changes for any game 
 *              other game device.
 *
 *          <nl>PnP.c
 *              <nl>Support routines for PnP IOCTLs.
 *              
 *          <nl>Ioctl.c
 *              <nl>Support routines for Non PnP IOCTLs
 *              These deal with all the HID IOCTLs required for an ordinary 
 *              game device and so could be used without change as there is 
 *              no analog specific funtionality in these routines.  
 *              Drivers for some devices may need to add code to support more 
 *              complex devices.
 *
 *          <nl>HidJoy.c
 *              <nl>Support routines to translate legacy joystick flags and 
 *              data into HID descriptors.  The majority of this code is 
 *              needed to support the wide variety of analog joysticks 
 *              available so is not relevant to drivers written for specific 
 *              devices.
 *
 *          <nl>Poll.c
 *              <nl>Support routines to read analog joystick data from a 
 *              gameport.  These functions are likely to be of little use 
 *              in a digital joystick driver.
 *
 *          <nl>i386\timing.c
 *              <nl>Support routines to use x86 Time Stamp Counter.
 *              Includes code to check for the presence of, calibrate and 
 *              read the high speed CPU timer.
 *
 *          <nl>Hidgame.h
 *              <nl>Common include file.
 *              The general definitions are likely to be of use in most 
 *              drivers for game devices but some customization will be needed.
 *
 *          <nl>Debug.h
 *              <nl>Definitions to aid debugging.
 *              This contains the tag for the driver name used in debug output 
 *              which must be changed.
 *
 *          <nl>Analog.h
 *              <nl>Specific include file.
 *              Definitions specific to analog joystick devices.
 *
 *          <nl>OemSetup.inf
 *              <nl>Sample inf file.
 *              See comments in this file for how to install devices.
 *
 *          <nl>Source
 *              <nl> Source file for the NT build utility
 *
 *          <nl>Makefile
 *              <nl> Used as part of the build process
 *
 *****************************************************************************/
#ifndef __HIDGAME_H__
    #define __HIDGAME_H__

/* @@BEGIN_DDKSPLIT
 *
 *  Only define CHANGE_DEVICE in DDK sample
 */
#if 0
/* @@END_DDKSPLIT */
/*
 *  When CHANGE_DEVICE is defined it turns on code to use expose sibling and
 *  remove self to allow the driver to change its capabilities on-the-fly.
 *  This code is not used in the retail version of HIDGame.
 */
    #define CHANGE_DEVICE
/* @@BEGIN_DDKSPLIT */
#endif
/* @@END_DDKSPLIT */

/* @@BEGIN_DDKSPLIT  Disable common benign warnings for W4 testing */
    #pragma warning( disable:4514 ) /* unreferenced inline function has been removed */
    #pragma warning( disable:4214 ) /* nonstandard extension used : bit field types other than int */
/* @@END_DDKSPLIT */

/*
 *  Include Files
 */
    #include "wdm.h"
    #include "hidtoken.h"
    #include "hidusage.h"
    #include "hidport.h"
    #include "gameport.h"
    #include "debug.h"
    #include "analog.h"

/*
 *  A value guaranteed to be considered a timeout
 */
    #define AXIS_TIMEOUT            ( 0xffffffffL )




/*
 *  Defines for hidgame
 */

    #define HIDGAME_VERSION_NUMBER  ((USHORT) 1)

    #define JOY_START_TIMERS        ( 0 )


    #define MAXBYTES_GAME_REPORT    ( 256 )

    #define BUTTON_1   0x10
    #define BUTTON_2   0x20
    #define BUTTON_3   0x40
    #define BUTTON_4   0x80

    #define AXIS_X     0x01
    #define AXIS_Y     0x02
    #define AXIS_R     0x04
    #define AXIS_Z     0x08

    #define BUTTON_BIT 0
    #define BUTTON_ON ( 1 << BUTTON_BIT )


/*
 *  Function type used for timing.  
 *  MUST be compatible with KeQueryPerformanceCounter 
 */
typedef
LARGE_INTEGER
(*COUNTER_FUNCTION) (
    PLARGE_INTEGER  pDummy
    );



/*
 *  Typedef the structs we need
 */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct HIDGAME_GLOBAL |
 *
 *          Global struct to store driver wide data.
 *          Stuff we need to share across multiple instances of this driver.
 *
 *  @field  FAST_MUTEX | Mutex |
 *
 *          Mutex to synchronize access to the following list entry
 *
 *  @field  LIST_ENTRY | DeviceListHead |
 *
 *          Keeps a list of all devices.
 *
 *  @field  KSPIN_LOCK | SpinLock | 
 *
 *          Spinlock used to stop multiple processors polling gameports at 
 *          once.  It would be better to keep a list of spinlocks, one for 
 *          each gameport but then processors could contend for IO access 
 *          and we'd have to maintain another list.
 *
 *  @field  COUNTER_FUNCTION | ReadCounter | 
 *
 *          Function to retrieve clock time
 *
 *  @field  ULONG | CounterScale | 
 *
 *          The scale to be used.
 *
 *****************************************************************************/
typedef struct _HIDGAME_GLOBAL
{
    FAST_MUTEX          Mutex;          /* A syncronization for access to list */
    LIST_ENTRY          DeviceListHead; /* Keeps list of all the devices */
    KSPIN_LOCK          SpinLock;       /* Lock so that only one port is accessed */
    COUNTER_FUNCTION    ReadCounter;    /* Function to retrieve clock time */
    ULONG               CounterScale;   /* Clock scale factor */
} HIDGAME_GLOBAL;



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct DEVICE_EXTENSION |
 *
 *          Device specific data.
 *
 *  @field  PGAMEENUM_READPORT | ReadAccessor |
 *
 *          Read Accessor function for the gameport. Obtained in the return from
 *          IOCTL to the gameport.
 *
 *  @field  PGAMEENUM_WRITEPORT | WriteAccessor |
 *
 *          Write Accessor function for the gameport. Obtained in the return from
 *          IOCTL to the gameport.
 *
 *  @field  PGAMEENUM_READPORT_DIGITAL | ReadAccessorDigital |
 *
 *          Digital read accessor for the gameport. Obtained as part of return from
 *          IOCTL to the gameport
 *
 *  @field  PGAMEENUM_ACQUIRE_PORT | AcquirePort |
 *
 *          Function to call before reading/writing to the port. Obtained as 
 *          part of return from IOCTL to the gameport
 *
 *  @field  PGAMEENUM_RELEASE_PORT | ReleasePort |
 *
 *          Function to call when done reading/writing to the port. Obtained as 
 *          part of return from IOCTL to the gameport
 *
 *  @field  PVOID    | GameContext |
 *
 *          Token to read this game port. Obtained as part of the return from
 *          IOCTL to the gameport.
 *
 *  @field  PVOID    | PortContext |
 *
 *          Context to pass to AcquirePort and ReleasePort. Obtained as part 
 *          of the return from IOCTL to the gameport.
 *
 *  @field  LIST_ENTRY  | Link |
 *
 *          Link to other hidgame devices on the system.
 *
 *  @field  KEVENT | RemoveEvent |
 *
 *          The remove plugplay request must use this event to make sure all 
 *          other requests have completed before it deletes the device object.
 *
 *  @field  LONG | RequestCount |
 *
 *          Number of IRPs underway.
 *
 *  @field  PDEVICE_OBJECT | NextDeviceObject |
 *
 *          NOTE: Only present if CHANGE_DEVICE is defined
 *
 *          DeviceObject to send self created IRPs down to
 *
 *  @field  WORK_QUEUE_ITEM | WorkItem |
 *
 *          NOTE: Only present if CHANGE_DEVICE is defined
 *
 *          Work item used for expose sibling/remove self
 *
 *  @field  ANALOG_DEVICE | unnamed structure see ANALOG_DEVICE |
 *          
 *          Structure containing analog device specific information.
 *
 *          NOTE: this structure is placed after the DWORD aligned elements.
 *
 *  @xref   <t ANALOG_DEVICE>.
 *
 *  @field  BOOLEAN | fRemoved |
 *
 *          Set to true if the device has been removed => all requests should be failed
 *
 *  @field  BOOLEAN | fStarted |
 *
 *          Set to true is device has started.
 *
 *  @field  BOOLEAN | fSurpriseRemoved |
 *
 *          Set to true if the device has been surprise removed by PnPs device has started.
 *
 *****************************************************************************/
typedef struct _DEVICE_EXTENSION
{
    /*
     *  read accessor for the game port
     */
    PGAMEENUM_READPORT          ReadAccessor;

    /*
     *  write the game port
     */
    PGAMEENUM_WRITEPORT         WriteAccessor;

    /*
     *  Digital read accessor for the gameport
     */
    PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    /*
     * Function to call before reading/writing to the port
     */
    PGAMEENUM_ACQUIRE_PORT      AcquirePort;

    /*
     * Function to call when done reading/writing to the port
     */
    PGAMEENUM_RELEASE_PORT      ReleasePort;
    
    /*
     *  token to read this game port
     */
    PVOID                       GameContext;

    /* 
     * Context to pass to AcquirePort and ReleasePort
     */
    PVOID                       PortContext;

    /*
     *  List of other joystick devices
     */
    LIST_ENTRY                  Link;

    /*
     *  The remove plugplay request must use this event to make sure all 
     *  other requests have completed before it deletes the device object.
     */
    KEVENT                      RemoveEvent;

    /*
     *  Number of IRPs underway.
     */
    LONG                        RequestCount;


#ifdef CHANGE_DEVICE 
    /*
     *  DeviceObject to send self created IRPs down to.
     */
    PDEVICE_OBJECT              NextDeviceObject;

    /*
     *  Work item used for expose sibling/remove self
     */
    WORK_QUEUE_ITEM             WorkItem;
#endif /* CHANGE_DEVICE */

    /*
     *  Structure containing analog device specific information.
     */
    ANALOG_DEVICE;

    /*
     *  Set to true if the device has been removed => all requests should be failed
     */
    BOOLEAN                     fRemoved;

    /*
     *  Set to true if the device has started
     */
    BOOLEAN                     fStarted;

    /*
     *  Set to true if the device has been surprise removed by PnPs device has started.
     */
    BOOLEAN                     fSurpriseRemoved;

#ifdef CHANGE_DEVICE
    /*
     *  Indicates that a replacement sibling is being started
     */
    BOOLEAN                     fReplaced;
#endif /* CHANGE_DEVICE */

}  DEVICE_EXTENSION, *PDEVICE_EXTENSION;

    #define GET_MINIDRIVER_DEVICE_EXTENSION(DO)  \
    ((PDEVICE_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

    #define GET_NEXT_DEVICE_OBJECT(DO) \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)



/*
 *  Globals
 */
extern HIDGAME_GLOBAL Global;

/*
 * Function prototypes
 */

    #define INTERNAL   /* Called only within a translation unit */
    #define EXTERNAL   /* Called from other translation units */


/*
 *  hidgame.c
 */
NTSTATUS EXTERNAL
    DriverEntry
    (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS EXTERNAL
    HGM_CreateClose
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
    HGM_SystemControl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS  EXTERNAL
    HGM_AddDevice
    (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

VOID EXTERNAL
    HGM_Unload
    (
    IN PDRIVER_OBJECT DriverObject
    );

/*
 *  ioctl.c
 */


NTSTATUS EXTERNAL
    HGM_InternalIoctl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS EXTERNAL
    HGM_GetDeviceDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_GetReportDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_ReadReport
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_GetAttributes
    (
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

/*
 *  pnp.c
 */

NTSTATUS INTERNAL
    HGM_IncRequestCount
    (
    PDEVICE_EXTENSION DeviceExtension
    );

VOID INTERNAL
    HGM_DecRequestCount
    (
    PDEVICE_EXTENSION DeviceExtension
    );

VOID INTERNAL
    HGM_RemoveDevice
    (
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS  EXTERNAL
    HGM_PnP
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_InitDevice
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS INTERNAL
    HGM_Power
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    );

NTSTATUS INTERNAL
    HGM_GetResources
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_PnPComplete
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*
 *  hidjoy.c
 */
NTSTATUS EXTERNAL
    HGM_DriverInit
    (
    VOID
    );

NTSTATUS INTERNAL
    HGM_SetupButtons
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    );

NTSTATUS INTERNAL
    HGM_MapAxesFromDevExt
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    );

NTSTATUS INTERNAL
    HGM_GenerateReport
    (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT UCHAR           rgGameReport[MAXBYTES_GAME_REPORT],
    OUT PUSHORT         pCbReport
    );


NTSTATUS INTERNAL
    HGM_JoystickConfig
    (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS EXTERNAL
    HGM_InitAnalog
    (
    IN PDEVICE_OBJECT         DeviceObject
    );

/*
 *  Sample only code for changing the device
 */
#ifdef CHANGE_DEVICE 

VOID
    HGM_ChangeHandler
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    );

VOID
    HGM_DeviceChanged
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    );

#endif /* CHANGE_DEVICE */

VOID 
    HGM_Game2HID
    (
    IN      PDEVICE_EXTENSION       DeviceExtension,
    IN  OUT PUHIDGAME_INPUT_DATA    pHIDData
    );
 
/*
 *  poll.c
 */

NTSTATUS  INTERNAL
    HGM_AnalogPoll
    (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN UCHAR                resistiveInputMask,
    IN BOOLEAN              bApproximate,
    IN OUT ULONG            Axis[MAX_AXES],
    OUT UCHAR               Buttons[PORT_BUTTONS]
    );

NTSTATUS
    HGM_UpdateLatestPollData
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    );

/*
 * <CPU>\timing.c (or macro equivalents for external functions)
 */


#ifdef _X86_
BOOLEAN INTERNAL
    HGM_x86IsClockAvailable
    (
    VOID
    );

LARGE_INTEGER INTERNAL
    HGM_x86ReadCounter
    (
    IN      PLARGE_INTEGER      Dummy
    );

VOID INTERNAL
    HGM_x86SampleClocks
    (
    OUT PULONGLONG  pTSC,
    OUT PULONGLONG  pQPC
    );

BOOLEAN EXTERNAL
    HGM_x86CounterInit();
#define HGM_CPUCounterInit HGM_x86CounterInit

#else

/*
 *  For all other processors a value to cause the default timing to be used
 */

#define HGM_CPUCounterInit() FALSE

#endif /* _X86_ */


#endif  /* __HIDGAME_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\hidjoy.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract: This module contains routines Generate the HID report and
    configure the joystick.

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
  Author:

    Eliyas Yakub (Mar, 11, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998

@@END_DDKSPLIT

--*/

#include "hidgame.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text (INIT, HGM_DriverInit)
    #pragma alloc_text (PAGE, HGM_SetupButtons)
    #pragma alloc_text (PAGE, HGM_MapAxesFromDevExt)
    #pragma alloc_text (PAGE, HGM_GenerateReport)
    #pragma alloc_text (PAGE, HGM_JoystickConfig)
    #pragma alloc_text (PAGE, HGM_InitAnalog)
/*  Sample only functions */
#ifdef CHANGE_DEVICE 
    #pragma alloc_text (PAGE, HGM_ChangeHandler)
    #pragma alloc_text (PAGE, HGM_DeviceChanged)
#endif /* CHANGE_DEVICE */
#endif





/*
 *  A few look up tables to translate the JOY_HWS_* flags into axis masks.
 *  These flags allow any axis to be polled on any of the four axis bits in 
 *  the gameport.  For example, the X axis on a standard joystick is found on 
 *  bit 0 (LSB) and the Y axis is on bit 1; however many steering wheel/pedal 
 *  controllers have X on bit 0 but Y on bit 2.  Although very few of these
 *  combinations are known to be used, supporting all the flags only causes a 
 *  little extra work on setup.  For each axis, there are three flags, one for 
 *  each of the possible non-standard bit masks.  Since it is possible that 
 *  more than one of these may be set the invalid combinations are marked so 
 *  that they can be refused.
 */



#define NA ( 0x80 )

/*
 *  Short versions of bit masks for axes
 */
#define X1 AXIS_X
#define Y1 AXIS_Y
#define X2 AXIS_R
#define Y2 AXIS_Z

/*
 *  Per axis flag masks and look up tables.
 *  In each case, combinations with more than one bit set are invalid
 */
#define XMAPBITS    (JOY_HWS_XISJ2Y |   JOY_HWS_XISJ2X |   JOY_HWS_XISJ1Y)
/*
 *                          0                   0                   0           0001
 *                          0                   0                   1           0010
 *                          0                   1                   0           0100
 *                          1                   0                   0           1000
 */
static const unsigned char XLU[8] = { X1,Y1,X2,NA,Y2,NA,NA,NA };
#define XMAPSHFT 7

#define YMAPBITS    (JOY_HWS_YISJ2Y |   JOY_HWS_YISJ2X |   JOY_HWS_YISJ1X)
/*                          0                   0                   0           0010
 *                          0                   0                   1           0001
 *                          0                   1                   0           0100
 *                          1                   0                   0           1000
 */
static const unsigned char YLU[8] = { Y1,X1,X2,NA,Y2,NA,NA,NA };
#define YMAPSHFT 10

#define RMAPBITS    (JOY_HWS_RISJ2Y |   JOY_HWS_RISJ1X |   JOY_HWS_RISJ1Y)
/*                          0                   0                   0           0100
 *                          0                   0                   1           0010
 *                          0                   1                   0           0001
 *                          1                   0                   0           1000
 */
static const unsigned char RLU[8] = { X2,Y1,X1,NA,Y2,NA,NA,NA };
#define RMAPSHFT 20

#define ZMAPBITS    (JOY_HWS_ZISJ2X |   JOY_HWS_ZISJ1X |   JOY_HWS_ZISJ1Y)
/*                          0                   0                   0           1000
 *                          0                   0                   1           0010
 *                          0                   1                   0           0001
 *                          1                   0                   0           0100
 */
static const unsigned char ZLU[8] = { Y2,Y1,X1,NA,X2,NA,NA,NA };
#define ZMAPSHFT 13
#define POVMAPBITS  (JOY_HWS_POVISJ2X | JOY_HWS_POVISJ1X | JOY_HWS_POVISJ1Y)
/*
 *  POV is the same as Z but with a larger shift
 */
#define POVMAPSHFT 16

#undef X1
#undef Y1
#undef X2
#undef Y2

/*
 *  This translates from an axis bitmask to an axis value index.  The elements 
 *  used should be as follows (X marks unsed)   { X, 0, 1, X, 2, X, X, X, 3 }.
 */
static const unsigned char cAxisIndexTable[9] = { 0, 0, 1, 0, 2, 0, 0, 0, 3 };


typedef enum _POV1
{
    P1_NULL = 0x80,
    P1_0,
    P1_90,
    P1_180,
    P1_270    
} POV1;

typedef enum _POV2
{
    P2_NULL = 0xc0,
    P2_0,
    P2_90,
    P2_180,
    P2_270    
} POV2;

#define POV_MASK ((unsigned char)(~(P1_NULL | P2_NULL)))
/*
 *  Look up tables for button combos
 *  Buttons are zero based so use P1_NULL for a zero input so we don't have to 
 *  special case it as a do nothing button.
 *  The 7th Button can be mapped either from it's unique combination or as 
 *  foreward on a second POV being read as buttons 7 - 10.
 */
static const unsigned char c1PComboLU[] =   {   P1_NULL,0,      1,      P1_270,
                                                2,      4,      8,      P1_180,
                                                3,      5,      7,      P1_90,
                                                9,      6,      6,      P1_0 };

static const unsigned char c2PComboLU[] =   {   P1_NULL,0,      1,      P1_270,
                                                2,      4,      P2_180, P1_180,
                                                3,      5,      P2_90,  P1_90,
                                                P2_270, 6,      P2_0,   P1_0 };


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HGM_DriverInit |
 *
 *          Perform global initialization.
 *          <nl>This is called from DriverEntry.  Try to initialize a CPU 
 *          specific timer but if it fails set up default
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_UNSUCCESSFUL | not success
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_DriverInit()
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( !HGM_CPUCounterInit() )
    {
        LARGE_INTEGER QPCFrequency;

        KeQueryPerformanceCounter( &QPCFrequency );

        if( ( QPCFrequency.HighPart == 0 )
         && ( QPCFrequency.LowPart <= 10000 ) )
        {
            ntStatus = STATUS_UNSUCCESSFUL;

            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("QPC at %I64u Hz is unusable", 
                           QPCFrequency.QuadPart ));
        }
        else
        {
            Global.CounterScale = CALCULATE_SCALE( QPCFrequency.QuadPart );
            Global.ReadCounter = (COUNTER_FUNCTION)&KeQueryPerformanceCounter;

            HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE,\
                           ("QPC at %I64u Hz used with scale %d", 
                           QPCFrequency.QuadPart, Global.CounterScale ));
        }
    }

    return ntStatus;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HGM_SetupButtons |
 *
 *          Use the flags in the DeviceExtension to check and set up buttons.
 *          <nl>This is called both from HGM_JoystickConfig to validate the 
 *          configuration and HGM_GenerateReport to prepare for polling.
 *
 *  @parm   IN OUT PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the minidriver device extension
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR | The configuration is invalid
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_SetupButtons
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    if( DeviceExtension->fSiblingFound )
    {
        if( DeviceExtension->nButtons > 2 )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_SetupButtons: failing config of sibling device with %u buttons",\
                             DeviceExtension->nButtons));
        }
        if( DeviceExtension->HidGameOemData.OemData[1].joy_hws_dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_SetupButtons: failing config of sibling device with combo buttons" ));
        }
    }
    else
    {
        if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
        {
            if( DeviceExtension->nButtons > MAX_BUTTONS )
            {
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                ("HGM_SetupButtons: failing config of button combo device with %u buttons",\
                                 DeviceExtension->nButtons));
            }
        }
        else
        {
            if( DeviceExtension->nButtons > 4 )
            {
                if( DeviceExtension->resistiveInputMask & AXIS_R )
                {
                    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                    HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                    ("HGM_SetupButtons: failing config of device with R axis and %u buttons",\
                                     DeviceExtension->nButtons));
                }
                else
                {
                    /*
                     *  5th button always read from R axis.
                     *  Set the inital on/off boundary low
                     */
                    DeviceExtension->resistiveInputMask |= AXIS_R;
                    DeviceExtension->button5limit = 2;
                }

                if( DeviceExtension->nButtons > 5 )
                {
                    if( DeviceExtension->resistiveInputMask & AXIS_Z )
                    {
                        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                        ("HGM_SetupButtons: failing config of device with Z axis and %u buttons",\
                                         DeviceExtension->nButtons));
                    }
                    else
                    {
                        /*
                         *  6th button always read from Z axis.
                         *  Set the inital on/off boundary low
                         */
                        DeviceExtension->resistiveInputMask |= AXIS_Z;
                        DeviceExtension->button6limit = 2;
                    }

                    if( DeviceExtension->nButtons > 6 )
                    {
                        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                        ("HGM_SetupButtons: failing config of device with %u buttons",\
                                         DeviceExtension->nButtons));
                    }
                }
            }
        }
    }

    return( ntStatus );
} /* HGM_SetupButtons */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_MapAxesFromDevExt |
 *
 *          Use the flags in the DeviceExtension to generate mappings for each 
 *          axis.  
 *          <nl>This is called both from HGM_JoystickConfig to validate the 
 *          configuration and HGM_GenerateReport to use the axis maps.
 *          
 *
 *  @parm   IN OUT PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the minidriver device extension
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR | The configuration is invalid
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_MapAxesFromDevExt
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    )
{
    NTSTATUS    ntStatus;
    ULONG       dwFlags;
    int         nAxis;
    UCHAR       AxisMask;

    ntStatus = STATUS_SUCCESS;



    dwFlags = DeviceExtension->HidGameOemData.OemData[(DeviceExtension->fSiblingFound!=0)].joy_hws_dwFlags;  

    HGM_DBGPRINT( FILE_HIDJOY | HGM_BABBLE2,\
                    ("HGM_MapAxesFromDevExt: - - - dwFlags=0x%x - - -", dwFlags));

#define XIS (0)
#define YIS (1)
#define ZIS (2)
#define RIS (3)

    /* 
     *  Check X and Y last as Z, R and POV must not overlap
     *  The are no flags to indicate the presence of X or Y so if they 
     *  overlap, this indicates that they are not used,
     */

    DeviceExtension->resistiveInputMask = 0;
    for( nAxis=MAX_AXES; nAxis>=0; nAxis-- )
    {
        DeviceExtension->AxisMap[nAxis] = INVALID_INDEX;
    }
    nAxis = 0;
    DeviceExtension->povMap = INVALID_INDEX;

    if( dwFlags & JOY_HWS_HASZ )
    {
        AxisMask = ZLU[(dwFlags & ZMAPBITS) >> ZMAPSHFT];
        if( AxisMask >= NA )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_MapAxesFromDevExt: Z axis mapping error dwFlags=0x%x",\
                             dwFlags));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR; 
        }
        else
        {
            nAxis = 1;
            DeviceExtension->resistiveInputMask = AxisMask;
            DeviceExtension->AxisMap[ZIS] = cAxisIndexTable[AxisMask];
        }
    }


    if( dwFlags & JOY_HWS_HASR )
    {
        AxisMask = RLU[(dwFlags & RMAPBITS) >> RMAPSHFT];
        if( AxisMask >= NA )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_MapAxesFromDevExt: R axis mapping error dwFlags=0x%x",\
                             dwFlags));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR; 
        }
        else
        {
            if( DeviceExtension->resistiveInputMask & AxisMask )
            {
                HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR, \
                                ("HGM_MapAxesFromDevExt: R axis mapped to same as Z axis"));
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
            }
            else
            {
                nAxis++;
                DeviceExtension->resistiveInputMask |= AxisMask;
                DeviceExtension->AxisMap[RIS] = cAxisIndexTable[AxisMask];
            }
        }
    }


    if( dwFlags & JOY_HWS_HASPOV )
    {
        switch( dwFlags & ( JOY_HWS_POVISPOLL | JOY_HWS_POVISBUTTONCOMBOS ) )
        {
        case 0:
            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("HGM_MapAxesFromDevExt: POV is not polled or button combo"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            break;

        case JOY_HWS_POVISBUTTONCOMBOS:
            break;

        case JOY_HWS_POVISPOLL:
            AxisMask = ZLU[(dwFlags & POVMAPBITS) >> POVMAPSHFT];
            if( AxisMask >= NA )
            {
                HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                ("HGM_MapAxesFromDevExt: POV axis mapping error dwFlags=0x%x",\
                                 dwFlags));
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
            }
            else
            {
                if( DeviceExtension->resistiveInputMask & AxisMask )
                {
                    HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                    ("HGM_MapAxesFromDevExt: POV axis mapped to same as Z or R axis") );
                    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
                }
                else
                {
                    DeviceExtension->resistiveInputMask |= AxisMask;
                    DeviceExtension->povMap = cAxisIndexTable[AxisMask];
                }
            }
            break;

        case JOY_HWS_POVISPOLL | JOY_HWS_POVISBUTTONCOMBOS:
            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("HGM_MapAxesFromDevExt: POV reports button combo and polled"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            break;
        }
    }
    else if( dwFlags & ( JOY_HWS_POVISPOLL | JOY_HWS_POVISBUTTONCOMBOS ) )
    {
        HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                       ("HGM_MapAxesFromDevExt: non-existant POV is polled or button combo"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ;
    }


    AxisMask = XLU[( dwFlags & XMAPBITS ) >> XMAPSHFT];
    if( AxisMask >= NA )
    {
        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                        ("HGM_MapAxesFromDevExt: X axis mapping error dwFlags=0x%x",\
                         dwFlags));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
    }
    else
    {
        if( DeviceExtension->resistiveInputMask & AxisMask )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_WARN,\
                            ("HGM_MapAxesFromDevExt: X axis mapped to same as another axis") );
        }
        else
        {
            nAxis++;
            DeviceExtension->resistiveInputMask |= AxisMask;
            DeviceExtension->AxisMap[XIS] = cAxisIndexTable[AxisMask];
        }
    }


    AxisMask = YLU[( dwFlags & YMAPBITS ) >> YMAPSHFT];
    if( AxisMask >= NA )
    {
        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                        ("HGM_MapAxesFromDevExt: Y axis mapping error dwFlags=0x%x",\
                         dwFlags));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
    }
    else
    {
        if( DeviceExtension->resistiveInputMask & AxisMask )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_WARN,\
                            ("HGM_MapAxesFromDevExt: Y axis mapped to same as another axis") );
        }
        else
        {
            nAxis++;
            DeviceExtension->resistiveInputMask |= AxisMask;
            DeviceExtension->AxisMap[YIS] = cAxisIndexTable[AxisMask];
        }
    }

#undef XIS
#undef YIS
#undef ZIS
#undef RIS

#undef NA

    /*
     *  Don't fail for this if CHANGE_DEVICE is defined because an exposed 
     *  sibling will always have an nAxis of zero.
     */
#ifdef CHANGE_DEVICE
    if( DeviceExtension->nAxes )
    {
#endif /* CHANGE_DEVICE */
        if( nAxis != DeviceExtension->nAxes )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ;
            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("HGM_MapAxesFromDevExt: nAxis(%d) != DeviceExtension->nAxes(%d)", \
                            nAxis, (int) DeviceExtension->nAxes));
        }
#ifdef CHANGE_DEVICE
    }
    else
    {
        /*
         *  This must be an exposed sibling so store the calculated nAxis and 
         *  a nButton just to look different.
         */
        DeviceExtension->nAxes = (USHORT)nAxis;
        DeviceExtension->nButtons = MAX_BUTTONS;
    }
#endif /* CHANGE_DEVICE */


    HGM_DBGPRINT( FILE_HIDJOY | HGM_BABBLE,\
                    ("HGM_MapAxesFromDevExt:  uResistiveInputMask=0x%x",\
                     DeviceExtension->resistiveInputMask) );


    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = HGM_SetupButtons( DeviceExtension );
    }

    return( ntStatus );
} /* HGM_MapAxesFromDevExt */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GenerateReport |
 *
 *          Generates a hid report descriptor for a n-axis, m-button joystick,
 *          depending on number of buttons and joy_hws_flags field.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN OUT UCHAR * | rgGameReport[MAXBYTES_GAME_REPORT] |
 *
 *          Array that receives the HID report descriptor
 *
 *  @parm   OUT PUSHORT | pCbReport |
 *          
 *          Address of a short integer that receives size of 
 *          HID report descriptor. 
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_BUFFER_TOO_SMALL  | Need more memory for HID descriptor
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GenerateReport
    (
    IN PDEVICE_OBJECT       DeviceObject, 
    OUT UCHAR               rgGameReport[MAXBYTES_GAME_REPORT],
    OUT PUSHORT             pCbReport
    )
{
    NTSTATUS    ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    UCHAR       *pucReport; 
    int         Idx;
    int         UsageIdx;
    ULONG       dwFlags; 
    POEMDATA    OemData;

    int         InitialAxisMappings[MAX_AXES];


    typedef struct _USAGES
    {
        UCHAR UsagePage;
        UCHAR Usage;
    } USAGES, *PUSAGE;

    typedef struct _JOYCLASSPARAMS
    {
        UCHAR   TopLevelUsage;
        USAGES  Usages[MAX_AXES];
    } JOYCLASSPARAMS, *PJOYCLASSPARAMS;
    
    PJOYCLASSPARAMS pJoyParams;

    /* 
     *  Canned parameters for devices
     *  The top-level usage must be either HID_USAGE_GENERIC_JOYSTICK or 
     *  HID_USAGE_GENERIC_GAMEPAD in order for the device to be treated as a 
     *  game controller.
     *  The poll limits are specified in uSecs so the value stored here is 1000000/x
     */

    JOYCLASSPARAMS JoystickParams =
    {   
        HID_USAGE_GENERIC_JOYSTICK,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };

    JOYCLASSPARAMS GamepadParams =
    {   
        HID_USAGE_GENERIC_GAMEPAD,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };

    JOYCLASSPARAMS CarCtrlParams =
    {   
        HID_USAGE_GENERIC_JOYSTICK,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };

    JOYCLASSPARAMS FlightYokeParams =
    {   
        HID_USAGE_GENERIC_JOYSTICK,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };


    PAGED_CODE();

    HGM_DBGPRINT( FILE_HIDJOY | HGM_FENTRY,\
                    ("HGM_GenerateReport(ucIn=0x%x,DeviceObject=0x%x)",\
                     rgGameReport, DeviceObject) );

    /*
     *  Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     *  Although the axes have already been validated and mapped in 
     *  HGM_JoystickConfig this function destroys the mapping when it compacts 
     *  the axes towards the start of the descriptor report.  Since this 
     *  function will be called once to find the descriptor length and then 
     *  again to read the report, the mappings are regenerated again each 
     *  time through.  Although this results in the parameters being 
     *  interpreted three times (for validation, descriptor size and 
     *  descriptor content) it avoids the possibility of a discrepancy in 
     *  implementation of separate functions.
     */

    ntStatus = HGM_MapAxesFromDevExt( DeviceExtension );
    ASSERTMSG( "HGM_GenerateReport:", ntStatus == STATUS_SUCCESS );

    pucReport = rgGameReport;

    dwFlags = DeviceExtension->HidGameOemData.OemData[(DeviceExtension->fSiblingFound!=0)].joy_hws_dwFlags;  


    /* 
     *  What manner of beast have we ?
     */
    if( dwFlags & JOY_HWS_ISGAMEPAD )
    {
        pJoyParams = &GamepadParams;
    }
    else if( dwFlags & JOY_HWS_ISYOKE )
    {
        pJoyParams = &FlightYokeParams;
    }
    else if( dwFlags & JOY_HWS_ISCARCTRL )
    {
        pJoyParams = &CarCtrlParams;
    }
    else
    {
        pJoyParams = &JoystickParams;
    }

#define NEXT_BYTE( pReport, Data )   \
            ASSERTMSG( "HGM_GenerateReport:", pReport+sizeof(UCHAR)-rgGameReport < MAXBYTES_GAME_REPORT );  \
            *pReport++ = Data;    

#define NEXT_LONG( pReport, Data )   \
            ASSERTMSG( "HGM_GenerateReport:", pReport+sizeof(ULONG)-rgGameReport < MAXBYTES_GAME_REPORT);   \
            *(((LONG UNALIGNED*)(pReport))++) = Data;

#define ITEM_DEFAULT        0x00 /* Data, Array, Absolute, No Wrap, Linear, Preferred State, Has no NULL */
#define ITEM_VARIABLE       0x02 /* as ITEM_DEFAULT but value is a variable, not an array */
#define ITEM_HASNULL        0x40 /* as ITEM_DEFAULT but values out of range are considered NULL */
#define ITEM_ANALOG_AXIS    ITEM_VARIABLE
#define ITEM_DIGITAL_POV    (ITEM_VARIABLE|ITEM_HASNULL)
#define ITEM_BUTTON         ITEM_VARIABLE
#define ITEM_PADDING        0x01 /* Constant (nothing else applies) */


    /* USAGE_PAGE (Generic Desktop) */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_USAGE_PAGE_1);
    NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);

    /* USAGE (Joystick | GamePad ) */
    NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_1);
    NEXT_BYTE(pucReport,    pJoyParams->TopLevelUsage);

    /* Logical Min is the smallest value that could be produced by a poll */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MIN_4);
    NEXT_LONG(pucReport,    0 );

    /* Logical Max is the largest value that could be produced by a poll */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MAX_4);
    NEXT_LONG(pucReport,    AXIS_FULL_SCALE );

    /* Start a Linked collection */
    /*
     *  Since this is a generic driver we know knothing about the physical 
     *  distribution of controls on the device so we put everything in a 
     *  single collection.  If, for instance, we knew that some buttons were 
     *  on the base and some on the stick we could better describe them by 
     *  reporting them in separate collections.
     */
    NEXT_BYTE(pucReport,    HIDP_MAIN_COLLECTION); 
    NEXT_BYTE(pucReport,    0x0 ); 

    /* Define one axis at a time */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_COUNT_1);
    NEXT_BYTE(pucReport,    0x1);  

    /* Each axis is a 32 bits value */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
    NEXT_BYTE(pucReport,    8 * sizeof(ULONG) );

    /* 
     *  Do the axis 
     *  Although HID could cope with the "active" axes being mixed with the 
     *  dummy ones, it makes life simpler to move them to the start.
     *  Pass through all the axis maps generated by HGM_JoystickConfig 
     *  and map all the active ones into the descriptor, copying the usages 
     *  appropriate for the type of device.
     *  Since a polled POV is nothing more than a different interpretation 
     *  of axis data, this is added after any axes.
     */
    C_ASSERT( sizeof( InitialAxisMappings ) == sizeof( DeviceExtension->AxisMap ) );
    RtlCopyMemory( InitialAxisMappings, DeviceExtension->AxisMap, sizeof( InitialAxisMappings ) );



    Idx = 0;
    for( UsageIdx = 0; UsageIdx < MAX_AXES; UsageIdx++ )
    {
        if( InitialAxisMappings[UsageIdx] >= INVALID_INDEX )
        {
            continue;
        }

        DeviceExtension->AxisMap[Idx] = InitialAxisMappings[UsageIdx];

        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    pJoyParams->Usages[UsageIdx].Usage);
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    pJoyParams->Usages[UsageIdx].UsagePage);
        NEXT_BYTE(pucReport,    0x0);

        /* Data Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_ANALOG_AXIS);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Idx=%d, UsageIdx=%d, Mapping=%d, Usage=%02x, Page=%02x",\
                         Idx, UsageIdx, DeviceExtension->AxisMap[UsageIdx], \
                         pJoyParams->Usages[UsageIdx].Usage, pJoyParams->Usages[UsageIdx].UsagePage ) ) ;
        Idx++;
    }

    if( dwFlags & JOY_HWS_POVISPOLL )
    {
        /*
         *  A polled POV is just the same as an axis.
         *  Note, we have already checked that there is an axis for use as the POV.
         *  Also, this type of POV can be distinguished from a digital POV by it's 
         *  lack of a NULL value.
         */
        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    HID_USAGE_GENERIC_HATSWITCH);
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);
        NEXT_BYTE(pucReport,    0x0);

        /* Data Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_ANALOG_AXIS);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Idx=%d, Set to polled POV", Idx ) ) ;
        Idx++;
    }

    /*
     *  Now fill in any remaining axis values as dummys
     */
    while( Idx < MAX_AXES )
    {
        /* Constant Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Idx=%d, Set to constant field", Idx ) ) ;
        Idx++;
    }
        

    /*
     *  Now move on to the byte sized fields
     */


    if( dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
    {
        /*
         *  Redefine the logical and physical ranges from now on 
         *  A digital POV has a NULL value (a value outside the logical range) 
         *  when the POV is centered.  To make life easier call the NULL value 
         *  zero, so the logical range is from 1 to 4.

        /* Logical Min */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MIN_1);
        NEXT_BYTE(pucReport,    1 );

        /* Logical Max */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MAX_1);
        NEXT_BYTE(pucReport,    4 );

        /* 
         *  report for digital POV is 3 bits data plus 5 constant bits to fill 
         *  the byte.  
         */
        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    HID_USAGE_GENERIC_HATSWITCH);
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);
        NEXT_BYTE(pucReport,    0x0);

        /* Data Field */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x3);
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_DIGITAL_POV);

        /* top 5 bits constant */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x5);
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:First button combo POV is on" ) ) ;

        if( dwFlags & JOY_HWS_HASPOV2 )
        {
            NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
            NEXT_BYTE(pucReport,    HID_USAGE_GENERIC_HATSWITCH);
            NEXT_BYTE(pucReport,    0x0);
            NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);
            NEXT_BYTE(pucReport,    0x0);

            /* Data Field */
            NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
            NEXT_BYTE(pucReport,    0x3);
            NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
            NEXT_BYTE(pucReport,    ITEM_DIGITAL_POV);

            /* top 5 bits constant */
            NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
            NEXT_BYTE(pucReport,    0x5);
            NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
            NEXT_BYTE(pucReport,    ITEM_PADDING);

            HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                            ("HGM_GenerateReport:Second button combo POV is on" ) ) ;
        }
        else
        {
            /* 8 bits of constant data instead of second POV */
            NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
            NEXT_BYTE(pucReport,    0x8);

            /* Constant Field */
            NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
            NEXT_BYTE(pucReport,    ITEM_PADDING);

            HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                            ("HGM_GenerateReport:No second button combo POV" ) ) ;
        }
    } 
    else
    {
        /* 16 bits of constant data instead of button combo POVs */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x10);

        /* Constant Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Button combo POV are off" ) ) ;
    }


    /* 
     * Now the buttons 
     */
    for( Idx = 0x0; Idx < DeviceExtension->nButtons; Idx++ )
    {
        /* Report size is 1 bit for button */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x1);

        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    (UCHAR)(Idx + 1) );
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    HID_USAGE_PAGE_BUTTON);
        NEXT_BYTE(pucReport,    0x0);

        /* Data field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_BUTTON);

        /* 7 bits of constant data */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x7);
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY | HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Button %u on",Idx ) ) ;
    } 

    if( Idx < MAX_BUTTONS )
    {
        /* Constant report for 8 * unused buttons bits */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    (UCHAR)((MAX_BUTTONS-Idx)*8) );

        /* Constant Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY | HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Last %u buttons off",MAX_BUTTONS-Idx ) ) ;
    }

    /* End of collection,  We're done ! */
    NEXT_BYTE(pucReport,  HIDP_MAIN_ENDCOLLECTION); 


#undef NEXT_BYTE
#undef NEXT_LONG

    if( pucReport - rgGameReport > MAXBYTES_GAME_REPORT)
    {
        ntStatus   = STATUS_BUFFER_TOO_SMALL;
        *pCbReport = 0x0;
        RtlZeroMemory(rgGameReport, sizeof(rgGameReport));
    } else
    {
        *pCbReport = (USHORT) (pucReport - rgGameReport);
        ntStatus = STATUS_SUCCESS;
    }

    HGM_DBGPRINT( FILE_HIDJOY | HGM_GEN_REPORT,\
                    ("HGM_GenerateReport: ReportSize=0x%x",\
                     *pCbReport) );

    HGM_EXITPROC(FILE_HIDJOY | HGM_FEXIT_STATUSOK, "HGM_GenerateReport", ntStatus);

    return ( ntStatus );
} /* HGM_GenerateReport */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_JoystickConfig |
 *
 *          Check that the configuration is valid whilst there is still time 
 *          to refuse it.
 *          <nl>HGM_GenerateReport uses the results generated here if the 
 *          settings are OK.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR  | Invalid configuration specified
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_JoystickConfig 
    (
    IN PDEVICE_OBJECT         DeviceObject
    )
{
    PDEVICE_EXTENSION   DeviceExtension;
    POEMDATA            OemData;
    NTSTATUS            ntStatus;
    int                 Idx;

    PAGED_CODE();

    HGM_DBGPRINT( FILE_HIDJOY | HGM_FENTRY,\
                    ("HGM_JoystickConfig(DeviceObject=0x%x)",\
                     DeviceObject) );


    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ntStatus = HGM_MapAxesFromDevExt( DeviceExtension );

    if( DeviceExtension->ReadAccessorDigital )
    {
        DeviceExtension->ScaledTimeout = AXIS_TIMEOUT;
    }
    else
    {
        /*
         * Calculate time thresholds for analog device
         */
        if( ( DeviceExtension->HidGameOemData.OemData[0].Timeout < ANALOG_POLL_TIMEOUT_MIN )
          ||( DeviceExtension->HidGameOemData.OemData[0].Timeout > ANALOG_POLL_TIMEOUT_MAX ) )
        {
            HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE,\
                           ("Ignoring out of range timeout: %u uSecs",\
                            DeviceExtension->HidGameOemData.OemData[0].Timeout));

            DeviceExtension->ScaledTimeout = (ULONG)( ( (ULONGLONG)ANALOG_POLL_TIMEOUT_DFT
                                                      * (ULONGLONG)(AXIS_FULL_SCALE<<SCALE_SHIFT) )
                                                    / (ULONGLONG)ANALOG_POLL_TIMEOUT_MAX );
        }
        else
        {
            DeviceExtension->ScaledTimeout = (ULONG)( ( (ULONGLONG)DeviceExtension->HidGameOemData.OemData[0].Timeout
                                                      * (ULONGLONG)(AXIS_FULL_SCALE<<SCALE_SHIFT) )
                                                    / (ULONGLONG)ANALOG_POLL_TIMEOUT_MAX );
        }

        HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE,\
                       ("ScaledTimeout: %u",\
                        DeviceExtension->ScaledTimeout));

        /*
         *  Use one quarter of the minimum poll timeout as a starting value 
         *  for the time between two polls which will be considered to have 
         *  been interrupted.
         */
        DeviceExtension->ScaledThreshold = (ULONG)( ( (ULONGLONG)ANALOG_POLL_TIMEOUT_MIN
                                                    * (ULONGLONG)AXIS_FULL_SCALE )
                                                  / (ULONGLONG)ANALOG_POLL_TIMEOUT_MAX )>>2;
    }


    /*
     *  Set initial values of LastGoodAxis so that the device will not show
     *  up as present until we get at least one valid poll.
     */
    for( Idx = MAX_AXES; Idx >= 0; Idx-- )
    {
        DeviceExtension->LastGoodAxis[Idx] = AXIS_TIMEOUT;
    }

    HGM_EXITPROC(FILE_HIDJOY | HGM_FEXIT_STATUSOK, "HGM_JoystickConfig", ntStatus);

    return ntStatus;
} /* HGM_JoystickConfig */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_InitAnalog |
 *
 *          Check that the configuration is valid whilst there is still time 
 *          to refuse it.  
 *          <nl>Detect and validate sibling relationships and call 
 *          HGM_JoystickConfig for the rest of the work.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR  | Invalid configuration specified
 *
 *****************************************************************************/
/*
 *  Disable warning for variable used before set as it is hard for a compiler 
 *  to see that the use of DeviceExtension_Sibling is gated by a flag which 
 *  can only be set after DeviceExtension_Sibling is initialized.
 */
#pragma warning( disable:4701 )
NTSTATUS EXTERNAL
    HGM_InitAnalog
    (
    IN PDEVICE_OBJECT         DeviceObject
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PDEVICE_EXTENSION   DeviceExtension_Sibling;
    PLIST_ENTRY         pEntry;

#define ARE_WE_RELATED(_x_, _y_)                                \
    (                                                           \
        (_x_)->GameContext     == (_y_)->GameContext      &&    \
        (_x_)->WriteAccessor   == (_y_)->WriteAccessor    &&    \
        (_x_)->ReadAccessor    == (_y_)->ReadAccessor           \
    )

    PAGED_CODE ();
    
    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    

    /*
     *  No modifications to the Global List while we are looking at it
     */
    ExAcquireFastMutex (&Global.Mutex);

    /*
     *  For two joysticks interface two fdos are created to service them 
     *  but physically they both share the same port.
     *  For the second sibling certain extra rules must be applied so we 
     *  search our list of devices for another device using the same port 
     *  and if we find one mark this one as a sibling.
     */
    for(pEntry = Global.DeviceListHead.Flink;
       pEntry != &Global.DeviceListHead;
       pEntry = pEntry->Flink)
    {

        /*
         * Obtain the device Extension of the Sibling
         */
        DeviceExtension_Sibling = CONTAINING_RECORD(pEntry, DEVICE_EXTENSION, Link);

        if(       DeviceExtension_Sibling != DeviceExtension
               && TRUE == ARE_WE_RELATED(DeviceExtension, DeviceExtension_Sibling)
               && TRUE == DeviceExtension_Sibling->fStarted )
        {
#ifdef CHANGE_DEVICE
            if( DeviceExtension_Sibling->fReplaced )
            {
                HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Outgoing Sibling found (0x%x)", DeviceExtension_Sibling));
            }
            else
            {
#endif /* CHANGE_DEVICE */
                HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Sibling found (0x%x)", DeviceExtension_Sibling));

                DeviceExtension->fSiblingFound = TRUE;
#ifdef CHANGE_DEVICE
            }
#endif /* CHANGE_DEVICE */
            break;
        }
    }

    /*
     *  We are done, release the Mutex
     */
    ExReleaseFastMutex (&Global.Mutex);

    /*
     * check the axis and button configuration for the joystick
     */
    ntStatus = HGM_JoystickConfig(DeviceObject);

    if( NT_SUCCESS( ntStatus ) )
    {
        /*
         *  Make sure that sibling axes are not overlapped
         */
        if(  DeviceExtension->fSiblingFound &&
             (DeviceExtension_Sibling->resistiveInputMask & DeviceExtension->resistiveInputMask) != 0x0 )
        {

            HGM_DBGPRINT(FILE_HIDJOY |HGM_ERROR,\
                           ("HGM_InitDevice: OverLapping Resources ResisitiveInputMask(0x%x) Sibling(0x%x)",\
                            DeviceExtension->resistiveInputMask,DeviceExtension_Sibling->resistiveInputMask ));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;

        }
    }
    else
    {
        HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                       ("HGM_InitDevice: JoystickConfig Failed"));
    }

    return( ntStatus );

} /* HGM_InitAnalog */



/*
 *  Change device sample only code
 */
#ifdef CHANGE_DEVICE

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_ChangeHandler |
 *
 *          Use IOCTL_GAMEENUM_EXPOSE_SIBLING and IOCTL_GAMEENUM_REMOVE_SELF 
 *          to change the attributes of the device.
 *
 *  @parm   IN  OUT PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the mini-driver device extension.
 *
 *****************************************************************************/
VOID
    HGM_ChangeHandler
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    )
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    KEVENT                  IoctlCompleteEvent;
    IO_STATUS_BLOCK         IoStatus;
    PIO_STACK_LOCATION      irpStack, nextStack;
    PIRP                    pIrp;
    PVOID                   SiblingHandle;

    GAMEENUM_EXPOSE_SIBLING ExposeSibling;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_HIDJOY | HGM_FENTRY,\
                   ("HGM_ChangeHandler(DeviceExtension=0x%x)", DeviceExtension));


    KeInitializeEvent(&IoctlCompleteEvent, NotificationEvent, FALSE);

	pIrp = IoBuildDeviceIoControlRequest (
					IOCTL_GAMEENUM_EXPOSE_SIBLING,
					DeviceExtension->NextDeviceObject,
					&ExposeSibling,
					sizeof( ExposeSibling ),
					&ExposeSibling,
					sizeof( ExposeSibling ),
					TRUE,
					&IoctlCompleteEvent,
					&IoStatus);

    if( pIrp )
    {
        /*
         *  For demonstration purposes only, we don't actually change the 
         *  device, we just re-expose the same one.  If the device really 
         *  needs to be changed, this would be signalled either by a 
         *  change in the OemData on the newly exposed device or by using 
         *  a specific HardwareID string.
         *  Note the nAxis and nButton fields will always be zero for an 
         *  exposed sibling.
         */
        RtlZeroMemory( &ExposeSibling, sizeof( ExposeSibling ) );
        ExposeSibling.Size = sizeof( ExposeSibling );
        ExposeSibling.HardwareHandle = &SiblingHandle;

        C_ASSERT( sizeof( ExposeSibling.OemData ) == sizeof( DeviceExtension->HidGameOemData.Game_Oem_Data ) );
        RtlCopyMemory(ExposeSibling.OemData, DeviceExtension->HidGameOemData.Game_Oem_Data, sizeof(ExposeSibling.OemData));
        ASSERT( ExposeSibling.UnitID == 0 );
        
        /*
         *  Setting a NULL pointer causes the HardwareID of this sibling to be used
         */
        ExposeSibling.HardwareIDs = NULL;


        /*
         *  issue a synchronous request to GameEnum to expose this new sibling
         */
	    ntStatus = IoCallDriver( DeviceExtension->NextDeviceObject, pIrp );

	    if( ntStatus == STATUS_PENDING )
	    {	
		    ntStatus = KeWaitForSingleObject (&IoctlCompleteEvent, Executive, KernelMode, FALSE, NULL);
	    }
        
        if( NT_SUCCESS(ntStatus) )
        {
            /*
             *  All went well so remove self
             */
            HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Sibling exposed!"));

	        pIrp = IoBuildDeviceIoControlRequest (
					        IOCTL_GAMEENUM_REMOVE_SELF,
					        DeviceExtension->NextDeviceObject,
					        NULL,
					        0,
					        NULL,
					        0,
					        TRUE,
					        &IoctlCompleteEvent,
					        &IoStatus);

            if( pIrp )
            {
                /*
                 *  issue a synchronous request to GameEnum to remove self
                 */
	            ntStatus = IoCallDriver( DeviceExtension->NextDeviceObject, pIrp );

	            if( ntStatus == STATUS_PENDING )
	            {	
		            ntStatus = KeWaitForSingleObject( &IoctlCompleteEvent, Executive, KernelMode, FALSE, NULL );
	            }
        
                if( NT_SUCCESS(ntStatus) )
                {
                    /*
                     *  All done
                     */
                    HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Removed self!"));
                }
                else
                {
                    /*
                     *  Something bad happened but there's little we can do
                     */
                    HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                        ("Failed to remove self with GameEnum error: 0x%08x", \
                        ntStatus));
                }
            }
            else
            {
                ntStatus = STATUS_NO_MEMORY;
                HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR, \
                    ("Failed to create IRP for remove self") );
            }
        }
        else
        {
            /*
             *  Something bad happened so reset the flag and carry on
             */
            DeviceExtension->fReplaced = FALSE;
            HGM_DBGPRINT(FILE_HIDJOY | HGM_WARN,\
                ("Failed to expose sibling with GameEnum error: 0x%08x", ntStatus));
        }
    }
    else
    {
        ntStatus = STATUS_NO_MEMORY;
        DeviceExtension->fReplaced = FALSE;
        HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR, \
            ("Failed to create IRP for expose sibling") );
    }
        
    /*
     *  We've finished touching the DeviceExtension now.
     */
    HGM_DecRequestCount( DeviceExtension );

    HGM_EXITPROC(FILE_HIDJOY|HGM_FEXIT_STATUSOK, "HGM_ChangeHandler", ntStatus);

    return;
} /* HGM_ChangeHandler */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_DeviceChanged |
 *
 *          Start the process of changing the device attributes by stashing 
 *          away all the data needed and then initializing and queuing a work 
 *          item to call the IOCTL at the required PASSIVE_LEVEL.
 *
 *  @parm   IN  OUT PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the mini-driver device extension.
 *
 *****************************************************************************/
VOID
    HGM_DeviceChanged
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    )
{
    NTSTATUS    ntStatus;

    /*
     *  Since the work item will use the device extension, bump the usage 
     *  count up one in case anyone tries to remove the device between 
     *  now and when the work item gets to run.  If that fails, forget it.
     */
    ntStatus = HGM_IncRequestCount( DeviceExtension );

    if( NT_SUCCESS(ntStatus) )
    {
        DeviceExtension->fReplaced = TRUE;
        ExInitializeWorkItem( &DeviceExtension->WorkItem, 
            (PWORKER_THREAD_ROUTINE)HGM_ChangeHandler, DeviceExtension );


        ExQueueWorkItem( &DeviceExtension->WorkItem, DelayedWorkQueue );
    }
    else
    {
        HGM_DBGPRINT(FILE_HIDJOY | HGM_WARN, ("Failed to change device") );
    }
} /* HGM_DeviceChanged */

#endif /* CHANGE_DEVICE */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_Game2HID |
 *
 *          Process the data returned from polling the gameport into values 
 *          and buttons for returning to HID.
 *          <nl>The meaning of the data is interpreted according to the 
 *          characteristics of the device described in the hardware settings
 *          flags.
 *
 *  @parm   IN      PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the mini-driver device extension.
 *
 *  @parm   IN  OUT PUHIDGAME_INPUT_DATA | pHIDData | 
 *
 *          Pointer to the buffer into which the HID report should be written.
 *          This buffer must be assumed to be unaligned.
 *
 *****************************************************************************/
VOID 
    HGM_Game2HID
    (
    IN      PDEVICE_EXTENSION       DeviceExtension,
    IN  OUT PUHIDGAME_INPUT_DATA    pHIDData
    )
{
    LONG    Idx;

    /*
     *  Use a local buffer to assemble the report as the real buffer may not 
     *  be aligned.
     */
    HIDGAME_INPUT_DATA  LocalBuffer;

    RtlZeroMemory( &LocalBuffer, sizeof( LocalBuffer ) );

    /*
     * Remap axis
     */
    for(Idx = 0x0; Idx < DeviceExtension->nAxes; Idx++ )
    {
        LocalBuffer.Axis[Idx] = DeviceExtension->LastGoodAxis[DeviceExtension->AxisMap[Idx]];
    }

    /*
     * Copy buttons and remap any POVs
     */

    if( DeviceExtension->fSiblingFound )
    {
        /*
         *  Simplest case, 2nd half poll must be 2A 2B
         */
        LocalBuffer.Button[0] = DeviceExtension->LastGoodButton[2];
        LocalBuffer.Button[1] = DeviceExtension->LastGoodButton[3];
    }
    else if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
    {
        UCHAR Buttons = 0;

        for( Idx = 3; Idx >=0; Idx-- )
        {
            Buttons <<= 1;
            Buttons = (UCHAR)(Buttons + (UCHAR)(DeviceExtension->LastGoodButton[Idx] >> BUTTON_BIT));
        }

        if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_HASPOV2 )
        {
            Idx = c2PComboLU[Buttons];
        }
        else
        {
            Idx = c1PComboLU[Buttons];
        }

        if( Idx >= P1_NULL )
        {
            if( Idx < P2_NULL )
            {
                LocalBuffer.hatswitch[0] = (UCHAR)(Idx & POV_MASK);
            }
            else
            {
                LocalBuffer.hatswitch[1] = (UCHAR)(Idx & POV_MASK);
            }
        }
        else
        {
#ifdef CHANGE_DEVICE
            if( ( Idx >= DeviceExtension->nButtons ) && ( !DeviceExtension->fReplaced ) )
            {
                /*
                 *  If a higher button was pressed than expected, use 
                 *  remove_self/expose_sibling to change expectations.
                 */
                HGM_DeviceChanged( DeviceExtension );
            }
#endif /* CHANGE_DEVICE */
            LocalBuffer.Button[Idx] = BUTTON_ON;
        }
    }
    else
    {
        if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_POVISPOLL )
        {
            /*
             *  Following the axis mapping loop, Idx is one larger than 
             *  DeviceExtension->nAxes which is the correct index for a 
             *  polled POV.
             */
            LocalBuffer.Axis[Idx] = DeviceExtension->LastGoodAxis[DeviceExtension->povMap];
        }

        
        /*
         *  Check buttons on R and Z axes
         */
        if( DeviceExtension->nButtons > 5 )
        {
            if( DeviceExtension->LastGoodAxis[3] > DeviceExtension->button6limit )
            {
                /*
                 *  New max found so button is off
                 */
                HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                                ("HGM_Game2HID: Changing button 6 limit from %u to %u", \
                                DeviceExtension->button6limit, DeviceExtension->LastGoodAxis[3] ) ) ;
                DeviceExtension->button6limit = DeviceExtension->LastGoodAxis[3];
            }
            else if( DeviceExtension->LastGoodAxis[3] < (DeviceExtension->button6limit>>1) )
            {
                LocalBuffer.Button[5] = BUTTON_ON;
            }
        }
        if( DeviceExtension->nButtons > 4 )
        {
            Idx = 4;

            if( DeviceExtension->LastGoodAxis[2] > DeviceExtension->button5limit )
            {
                /*
                 *  New max found so button is off
                 */
                HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                                ("HGM_Game2HID: Changing button 5 limit from %u to %u", \
                                DeviceExtension->button5limit, DeviceExtension->LastGoodAxis[2] ) ) ;
                DeviceExtension->button5limit = DeviceExtension->LastGoodAxis[2];
            }
            else if( DeviceExtension->LastGoodAxis[2] < (DeviceExtension->button5limit>>1) )
            {
                LocalBuffer.Button[4] = BUTTON_ON;
            }
        }
        else
        {
            Idx = DeviceExtension->nButtons;
        }


        /*
         *  Copy all standard buttons
         */
        while( Idx-- )
        {
            LocalBuffer.Button[Idx] = DeviceExtension->LastGoodButton[Idx];
        }

    }

    C_ASSERT( sizeof( *pHIDData ) == sizeof( LocalBuffer ) );
    RtlCopyMemory( pHIDData, &LocalBuffer, sizeof( LocalBuffer ) );

    HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                    ("HGM_Game2HID: Axes: X: %08x   Y: %08x   Z: %08x   R: %08x", \
                    LocalBuffer.Axis[0], LocalBuffer.Axis[1], LocalBuffer.Axis[2], LocalBuffer.Axis[3] ) ) ;
    HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                    ("HGM_Game2HID: P1: %d   P2: %d   Buttons %d, %d,  %d, %d,  %d, %d,  %d, %d,  %d, %d", \
                    LocalBuffer.hatswitch[0], LocalBuffer.hatswitch[1], \
                    LocalBuffer.Button[0], LocalBuffer.Button[1], LocalBuffer.Button[2], LocalBuffer.Button[3], LocalBuffer.Button[4], \
                    LocalBuffer.Button[5], LocalBuffer.Button[6], LocalBuffer.Button[7], LocalBuffer.Button[8], LocalBuffer.Button[9] ) ) ;
} /* HGM_Game2HID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\pnp.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract: This module contains PnP Start, Stop, Remove,
          Power dispatch routines and IRP cancel routine.

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
  Author:

    Eliyas Yakub (Mar, 11, 1997)
Revision History:

    Updated by Eliyas on Feb 5 1998
    Om Sharma    ( April 15, 1998)
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT
--*/

#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, HGM_RemoveDevice)
    #pragma alloc_text (PAGE, HGM_PnP)
    #pragma alloc_text (PAGE, HGM_InitDevice)
    #pragma alloc_text (PAGE, HGM_GetResources)
    #pragma alloc_text (PAGE, HGM_Power)
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS  | HGM_IncRequestCount |
 *
 *          Try to increment the request count but fail if the device is 
 *          being removed.
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension.
 *
 *  @rvalue STATUS_SUCCESS | success
 *  @rvalue STATUS_DELETE_PENDING | PnP IRP received after device was removed
 *
 *****************************************************************************/
NTSTATUS  EXTERNAL
    HGM_IncRequestCount
    (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS    ntStatus;

    InterlockedIncrement( &DeviceExtension->RequestCount );
    ASSERT( DeviceExtension->RequestCount > 0 );
    
    if( DeviceExtension->fRemoved )
    {
        /*
         *  PnP has already told us to remove the device so fail and make 
         *  sure that the event has been set.
         */
        if( 0 == InterlockedDecrement( &DeviceExtension->RequestCount ) ) 
        {
            KeSetEvent( &DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE );
        }
        ntStatus = STATUS_DELETE_PENDING;
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}
    



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID  | HGM_DecRequestCount |
 *
 *          Decrement the request count and set event if this is the last.
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension.
 *
 *****************************************************************************/
VOID EXTERNAL
    HGM_DecRequestCount
    (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    LONG        LocalCount;

    LocalCount = InterlockedDecrement( &DeviceExtension->RequestCount );

    ASSERT( DeviceExtension->RequestCount >= 0 );
    
    if( LocalCount == 0 )
    {
        /*
         *  PnP has already told us to remove the device so the PnP remove 
         *  code should have set device as removed and should be waiting on
         *  the event.
         */
        ASSERT( DeviceExtension->fRemoved );
        KeSetEvent( &DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE );
    }

    return;
}
    

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_RemoveDevice |
 *
 *          FDO Remove routine 
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension.
 *
 *****************************************************************************/
VOID INTERNAL
    HGM_RemoveDevice
    (
    PDEVICE_EXTENSION DeviceExtension
    )
{
    if (DeviceExtension->fSurpriseRemoved) {
        return;
    }

    DeviceExtension->fSurpriseRemoved = TRUE;

    /*
     *  Acquire mutex before modifying the Global Linked list of devices
     */
    ExAcquireFastMutex (&Global.Mutex);
    
    /*
     * Remove this device from the linked list of devices
     */
    RemoveEntryList(&DeviceExtension->Link);
    
    /*
     *  Release the mutex
     */
    ExReleaseFastMutex (&Global.Mutex);
} /* HGM_RemoveDevice */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_PnP |
 *
 *          Plug and Play dispatch routine for this driver.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DELETE_PENDING | PnP IRP received after device was removed
 *  @rvalue   ???   | Return from IoCallDriver() or HGM_InitDevice()
 *
 *****************************************************************************/
NTSTATUS  EXTERNAL
    HGM_PnP
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    KEVENT            StartEvent;

    PAGED_CODE();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_PnP(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp ));
    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ntStatus = HGM_IncRequestCount( DeviceExtension );
    if (!NT_SUCCESS (ntStatus))
    {
        /*
         * Someone sent us another plug and play IRP after removed
         */

        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_PnP: PnP IRP after device was removed\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else
    {
        PIO_STACK_LOCATION IrpStack;

        /*
         * Get a pointer to the current location in the Irp
         */
        IrpStack = IoGetCurrentIrpStackLocation (Irp);

        switch(IrpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:

                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_START_DEVICE"));
                /*
                 * We cannot touch the device (send it any non pnp irps) until a
                 * start device has been passed down to the lower drivers.
                 */
                KeInitializeEvent(&StartEvent, NotificationEvent, FALSE);

                IoCopyCurrentIrpStackLocationToNext (Irp);
                IoSetCompletionRoutine (Irp, HGM_PnPComplete, &StartEvent, TRUE, TRUE, TRUE);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                if( NT_SUCCESS(ntStatus ) )
                {
                    ntStatus = KeWaitForSingleObject
                               (
                               &StartEvent,
                               Executive,   /* Waiting for reason of a driver */
                               KernelMode,  /* Waiting in kernel mode         */
                               FALSE,       /* No allert                      */
                               NULL         /* No timeout                     */
                               );
                }

                if(NT_SUCCESS(ntStatus))
                {
                    ntStatus = Irp->IoStatus.Status;
                }

                if(NT_SUCCESS (ntStatus))
                {
                    /*
                     * As we are now back from our start device we can do work.
                     */
                    ntStatus = HGM_InitDevice (DeviceObject, Irp);
                } else
                {
                    HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                                   ("HGM_Pnp: IRP_MN_START_DEVICE ntStatus =0x%x",\
                                    ntStatus));
                }


                DeviceExtension->fStarted = TRUE;

                /*
                 *      Return Status
                 */
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);

                break;

            case IRP_MN_STOP_DEVICE:

                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_STOP_DEVICE"));
                /*
                 * After the start IRP has been sent to the lower driver object, the bus may
                 * NOT send any more IRPS down ``touch'' until another START has occured.
                 * Whatever access is required must be done before Irp passed on.
                 */

                DeviceExtension->fStarted = FALSE;

                /*
                 * We don't need a completion routine so fire and forget.
                 * Set the current stack location to the next stack location and
                 * call the next device object.
                 */

                IoSkipCurrentIrpStackLocation (Irp);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                break;

            case IRP_MN_SURPRISE_REMOVAL:
                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_SURPRISE_REMOVAL"));

                HGM_RemoveDevice(DeviceExtension);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(Irp);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                break;

            case IRP_MN_REMOVE_DEVICE:
                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_REMOVE_DEVICE"));

                /*
                 * The PlugPlay system has dictacted the removal of this device. We
                 * have no choice but to detach and delete the device object.
                 * (If we wanted to express an interest in preventing this removal,
                 * we should have filtered the query remove and query stop routines.)
                 * Note: we might receive a remove WITHOUT first receiving a stop.
                 */

                /*
                 *  Make sure we do not allow more IRPs to start touching the device
                 */
                DeviceExtension->fRemoved = TRUE;

                /*
                 * Stop the device without touching the hardware.
                 */
                HGM_RemoveDevice(DeviceExtension);

                /*
                 * Send on the remove IRP
                 */
                IoSkipCurrentIrpStackLocation (Irp);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);


                /*
                 *  Remove this IRPs hold which should leave the initial 1 plus 
                 *  any other IRP holds.
                 */
                {
                    LONG RequestCount = InterlockedDecrement( &DeviceExtension->RequestCount );
                    ASSERT( RequestCount > 0 );
                }

                /*
                 *  If someone has already started, wait for them to finish
                 */
                if( InterlockedDecrement( &DeviceExtension->RequestCount ) > 0 )
                {
                    KeWaitForSingleObject( &DeviceExtension->RemoveEvent,
                        Executive, KernelMode, FALSE, NULL );
                }

                ntStatus = STATUS_SUCCESS;

                HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_PnP Exit 1", ntStatus);

                return ntStatus;

            default:
                HGM_DBGPRINT(FILE_PNP | HGM_WARN,\
                               ("HGM_PnP: IrpStack->MinorFunction Not handled 0x%x", \
                                IrpStack->MinorFunction));

                IoSkipCurrentIrpStackLocation (Irp);

                ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                break;
        }

        HGM_DecRequestCount( DeviceExtension );
    }

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT, "HGM_PnP", ntStatus);

    return ntStatus;
} /* HGM_PnP */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_InitDevice |
 *
 *          Get the device information and attempt to initialize a configuration
 *          for a device.  If we cannot identify this as a valid HID device or
 *          configure the device, our start device function is failed.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR | Resources overlap
 *  @rvalue   ???            | Return from HGM_GetResources() or HGM_JoystickConfig()
 *
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_InitDevice
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    ULONG  DescriptorLength;

    PAGED_CODE();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_InitDevice(DeviceObject=0x%x,Irp=0x%x)", \
                    DeviceObject,Irp));

    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     * Get resource information from GameEnum and store it in the device extension
     */
    ntStatus = HGM_GetResources(DeviceObject,Irp);
    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = HGM_InitAnalog(DeviceObject);
    }
    else
    {
        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_InitDevice: HGM_GetResources Failed"));
    }

    if( !NT_SUCCESS(ntStatus) )
    {
        /*
         *  Acquire mutex before modifying the Global Linked list of devices
         */
        ExAcquireFastMutex (&Global.Mutex);

        /*
         * Remove this device from the linked list of devices
         */
        RemoveEntryList(&DeviceExtension->Link);

        /*
         *  Release the mutex
         */
        ExReleaseFastMutex (&Global.Mutex);
    }

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_InitDevice", ntStatus);

    return ntStatus;
} /* HGM_InitDevice */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetResources |
 *
 *          Gets gameport resource information from the GameEnum driver
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | Return from IoCallDriver()
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetResources
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    GAMEENUM_PORT_PARAMETERS    PortInfo;
    POEMDATA            OemData;
    PDEVICE_EXTENSION   DeviceExtension;
    KEVENT              IoctlCompleteEvent;
    IO_STATUS_BLOCK     IoStatus;
    PIO_STACK_LOCATION  irpStack, nextStack;
    int                 i;
    PAGED_CODE ();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_GetResources(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp));

    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);


    /*
     * issue a synchronous request to get the resources info from GameEnum
     */

    KeInitializeEvent(&IoctlCompleteEvent, NotificationEvent, FALSE);

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERTMSG("HGM_GetResources:",nextStack != NULL);

    /*
     * pass the Portinfo buffer of the DeviceExtension
     */

    nextStack->MajorFunction                                    =
        IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode         =
        IOCTL_GAMEENUM_PORT_PARAMETERS;

    PortInfo.Size                                                   =
        nextStack->Parameters.DeviceIoControl.InputBufferLength     =
        nextStack->Parameters.DeviceIoControl.OutputBufferLength    =
        sizeof (PortInfo);

    Irp->UserBuffer =   &PortInfo;

    IoSetCompletionRoutine (Irp, HGM_PnPComplete,
                            &IoctlCompleteEvent, TRUE, TRUE, TRUE);

    HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                   ("calling GameEnum"));

    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT (DeviceObject), Irp);

    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = KeWaitForSingleObject(
                                        &IoctlCompleteEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

    }

    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = Irp->IoStatus.Status;
    }
    DeviceExtension->GameContext        = PortInfo.GameContext;
    DeviceExtension->ReadAccessor       = PortInfo.ReadAccessor;
    DeviceExtension->WriteAccessor      = PortInfo.WriteAccessor;
    DeviceExtension->ReadAccessorDigital= PortInfo.ReadAccessorDigital;
    DeviceExtension->AcquirePort        = PortInfo.AcquirePort;
    DeviceExtension->ReleasePort        = PortInfo.ReleasePort;
    DeviceExtension->PortContext        = PortInfo.PortContext;
    DeviceExtension->nAxes              = PortInfo.NumberAxis;
    DeviceExtension->nButtons           = PortInfo.NumberButtons;

#ifdef CHANGE_DEVICE
    /*
     *  Stash the NextDeviceObject in the device extension so that we can
     *  call GameEnum IRPs when we're not responding to an IRP
     */
    DeviceExtension->NextDeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);
#endif /* CHANGE_DEVICE */

    RtlCopyMemory(DeviceExtension->HidGameOemData.Game_Oem_Data, PortInfo.OemData, sizeof(PortInfo.OemData));

    for(i=0x0;
       i < sizeof(PortInfo.OemData)/sizeof(PortInfo.OemData[0]);
       i++)
    {
        HGM_DBGPRINT( FILE_HIDJOY | HGM_BABBLE2,\
                        ("JoystickConfig:  PortInfo.OemData[%d]=0x%x",\
                         i, PortInfo.OemData[i]) );
    }


    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_GetResources", Irp->IoStatus.Status);

    return Irp->IoStatus.Status;
} /* HGM_GetResources */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_PnPComplete |
 *
 *          Completion routine for PnP IRPs.  
 *          Not pageable because it is a completion routine.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue STATUS_MORE_PROCESSING_REQUIRED | We want the IRP back
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_PnPComplete
    (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    NTSTATUS ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_PnPComplete(DeviceObject=0x%x,Irp=0x%x,Context=0x%x)", \
                    DeviceObject, Irp, Context));

    UNREFERENCED_PARAMETER (DeviceObject);
    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT, "HGM_PnpComplete", ntStatus);

    return ntStatus;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_Power |
 *
 *          The power dispatch routine.
 *          <nl>This driver does not recognize power IRPS.  It merely sends them down,
 *          unmodified to the next device on the attachment stack.
 *          As this is a POWER irp, and therefore a special irp, special power irp
 *          handling is required. No completion routine is required.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | Return from PoCallDriver()
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_Power
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION  DeviceExtension;
    NTSTATUS           ntStatus;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("Enter HGM_Power(DeviceObject=0x%x,Irp=0x%x)",DeviceObject, Irp));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    /*
     * Since we do not know what to do with the IRP, we should pass
     * it on along down the stack.
     */

    ntStatus = HGM_IncRequestCount( DeviceExtension );
    if (!NT_SUCCESS (ntStatus))
    {
        /*
         * Someone sent us another plug and play IRP after removed
         */

        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_Power: PnP IRP after device was removed\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else
    {
        IoSkipCurrentIrpStackLocation (Irp);

        /*
         * Power IRPS come synchronously; drivers must call
         * PoStartNextPowerIrp, when they are ready for the next power irp.
         * This can be called here, or in the completetion routine.
         */
        PoStartNextPowerIrp (Irp);

        /*
         * NOTE!!! PoCallDriver NOT IoCallDriver.
         */
        ntStatus =  PoCallDriver (GET_NEXT_DEVICE_OBJECT (DeviceObject), Irp);

        HGM_DecRequestCount( DeviceExtension );
    }


    HGM_EXITPROC(FILE_IOCTL | HGM_FEXIT, "HGM_Power", ntStatus);
    return ntStatus;
} /* HGM_Power */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\ioctl.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Contains routines to support HIDCLASS internal
          ioctl queries for game devices.

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:
          Eliyas Yakub (Mar, 10, 1997)

Revision History:

        Updated by Eliyas on Feb 5 1998
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT

--*/

#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, HGM_GetDeviceDescriptor)
    #pragma alloc_text (PAGE, HGM_GetReportDescriptor)
    #pragma alloc_text (PAGE, HGM_GetAttributes      )
#endif



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_InternalIoctl |
 *
 *          Process the Control IRPs sent to this device.
 *          <nl>This function cannot be pageable because reads/writes
 *          can be made at dispatch-level
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_NOT_SUPPORT | Irp function not supported
 *  @rvalue   ???            | ???
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_InternalIoctl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,   \
                   ("HGM_InternalIoctl(DeviceObject=0x%x,Irp=0x%x)", \
                    DeviceObject, Irp));

    /*
     *  Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);


    ntStatus = HGM_IncRequestCount( DeviceExtension );
    if (!NT_SUCCESS (ntStatus))
    {
        /*
         *  Someone sent us another plug and play IRP after removed
         */

        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_InternalIoctl: PnP IRP after device was removed\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
    } else
    {
        switch(IrpStack->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE, \
                               ("IOCTL_HID_GET_DEVICE_DESCRIPTOR"));
                ntStatus = HGM_GetDeviceDescriptor(DeviceObject, Irp);
                break;

            case IOCTL_HID_GET_REPORT_DESCRIPTOR:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE, \
                               ("IOCTL_HID_GET_REPORT_DESCRIPTOR"));
                ntStatus = HGM_GetReportDescriptor(DeviceObject, Irp);
                break;

            case IOCTL_HID_READ_REPORT:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE,\
                               ("IOCTL_HID_READ_REPORT"));
                ntStatus = HGM_ReadReport(DeviceObject, Irp);
                break;

            case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE,\
                               ("IOCTL_HID_GET_DEVICE_ATTRIBUTES"));
                ntStatus = HGM_GetAttributes(DeviceObject, Irp);
                break;

            default:
                HGM_DBGPRINT(FILE_IOCTL | HGM_WARN,\
                               ("Unknown or unsupported IOCTL (%x)",
                                IrpStack->Parameters.DeviceIoControl.IoControlCode));
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }


        /*
         * Set real return status in Irp
         */
        Irp->IoStatus.Status = ntStatus;

        HGM_DecRequestCount( DeviceExtension );
    }


    if(ntStatus != STATUS_PENDING)
    {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        /*
         * NOTE: Real return status set in Irp->IoStatus.Status
         */
        ntStatus = STATUS_SUCCESS;
    } else
    {
        /*
         * No reason why there should be a status pending
         */
        HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR, \
                       ("HGM_InternalIoctl: Pending Status !"));
        IoMarkIrpPending( Irp );
    }

    HGM_EXITPROC(FILE_IOCTL | HGM_FEXIT_STATUSOK, "HGM_InternalIoctl", ntStatus);

    return ntStatus;
} /* HGM_InternalIoctl */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetDeviceDescriptor |
 *
 *          Respond to HIDCLASS IOCTL_HID_GET_DEVICE_DESCRIPTOR
 *          by returning a device descriptor
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_BUFFER_TOO_SMALL |  need more memory
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetDeviceDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHID_DESCRIPTOR pHidDescriptor;        /* Hid descriptor for this device */
    USHORT   cbReport;
    UCHAR               rgGameReport[MAXBYTES_GAME_REPORT] ;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_GetDeviceDescriptor(DeviceObject=0x%x,Irp=0x%x)",
                    DeviceObject, Irp));

    /*
     * Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    /*
     *  Get a pointer to the HID_DESCRIPTOR
     */
    pHidDescriptor =  (PHID_DESCRIPTOR) Irp->UserBuffer;


    if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(*pHidDescriptor)  )
    {

        HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR,\
                       ("HGM_GetDeviceDescriptor: OutBufferLength(0x%x) < sizeof(HID_DESCRIPTOR)(0x%x)", \
                        IrpStack->Parameters.DeviceIoControl.OutputBufferLength, sizeof(*pHidDescriptor)));


        ntStatus = STATUS_BUFFER_TOO_SMALL;
    } else
    {
        /*
         * Generate the report
         */
        ntStatus =  HGM_GenerateReport(DeviceObject, rgGameReport, &cbReport);

        if( NT_SUCCESS(ntStatus) )
        {
            RtlZeroMemory( pHidDescriptor, sizeof(*pHidDescriptor) );
            /*
             * Copy device descriptor to HIDCLASS buffer
             */
            pHidDescriptor->bLength                         = sizeof(*pHidDescriptor);
            pHidDescriptor->bDescriptorType                 = HID_HID_DESCRIPTOR_TYPE;
            pHidDescriptor->bcdHID                          = HID_REVISION;
            pHidDescriptor->bCountry                        = 0; /*not localized*/
            pHidDescriptor->bNumDescriptors                 = HGM_NUMBER_DESCRIPTORS;
            pHidDescriptor->DescriptorList[0].bReportType   = HID_REPORT_DESCRIPTOR_TYPE ;
            pHidDescriptor->DescriptorList[0].wReportLength = cbReport;

            /*
             * Report how many bytes were copied
             */
            Irp->IoStatus.Information = sizeof(*pHidDescriptor);
        } else
        {
            Irp->IoStatus.Information = 0x0;
        }
    }

    HGM_EXITPROC(FILE_IOCTL |HGM_FEXIT_STATUSOK, "HGM_GetDeviceDescriptor", ntStatus);

    return ntStatus;
} /* HGM_GetDeviceDescriptor */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetReportDescriptor |
 *
 *          Respond to HIDCLASS IOCTL_HID_GET_REPORT_DESCRIPTOR
 *          by returning appropriate the report descriptor
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | ???
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetReportDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION     DeviceExtension;
    PIO_STACK_LOCATION    IrpStack;
    NTSTATUS              ntStatus;
    UCHAR                 rgGameReport[MAXBYTES_GAME_REPORT] ;
    USHORT                cbReport;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_GetReportDescriptor(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp));

    /*
     * Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);


    /*
     * Generate the report
     */
    ntStatus =  HGM_GenerateReport(DeviceObject, rgGameReport, &cbReport);

    if( NT_SUCCESS(ntStatus) )
    {
        if( cbReport >  (USHORT) IrpStack->Parameters.DeviceIoControl.OutputBufferLength )
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;

            HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR,\
                           ("HGM_GetReportDescriptor: cbReport(0x%x) OutputBufferLength(0x%x)",\
                            cbReport, IrpStack->Parameters.DeviceIoControl.OutputBufferLength));

        } else
        {
            RtlCopyMemory( Irp->UserBuffer, rgGameReport, cbReport );
            /*
             * Report how many bytes were copied
             */
            Irp->IoStatus.Information = cbReport;
            ntStatus = STATUS_SUCCESS;
        }
    }

    HGM_EXITPROC(FILE_IOCTL |HGM_FEXIT_STATUSOK, "HGM_GetReportDescriptor", ntStatus);

    return ntStatus;
} /* HGM_GetReportDescriptor */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_ReadReport |
 *
 *          Poll the gameport, remap the axis and button data and package
 *          into the defined HID report field.
 *          <nl>This routine cannot be pageable as HID can make reads at 
 *          dispatch-level.
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_NOT_CONNECTED | Device Failed to Quiesce 
 *                                          ( not connected )
 *  @rvalue   STATUS_TIMEOUT  | Could not determine exact transition time for 
 *                              one or more axis but not a failure.
 *
 *****************************************************************************/
NTSTATUS  INTERNAL
    HGM_ReadReport
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_ReadReport(DeviceObject=0x%x,Irp=0x%x)", \
                    DeviceObject, Irp));

    /*
     * Get a pointer to the device extension.
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    /*
     * Get Stack location.
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     * First check the size of the output buffer (there is no input buffer)
     */

    if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <  sizeof(HIDGAME_INPUT_DATA) )
    {
        HGM_DBGPRINT(FILE_IOCTL | HGM_WARN,\
                       ("HGM_ReadReport: Buffer too small, output=0x%x need=0x%x", \
                        IrpStack->Parameters.DeviceIoControl.OutputBufferLength, 
                        sizeof(HIDGAME_INPUT_DATA) ) );

        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    if( DeviceExtension->fStarted == FALSE )
    {
        ntStatus = STATUS_DEVICE_NOT_READY ;
    }


    /*
     *  All the checking done so do device specific polling
     */
    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = HGM_UpdateLatestPollData( DeviceExtension );
    }

    /*
     *  If all's well, translate device specific data to HID report
     */
    if( NT_SUCCESS(ntStatus) )
    {
        HGM_Game2HID( DeviceExtension, (PHIDGAME_INPUT_DATA)Irp->UserBuffer );
        Irp->IoStatus.Information = sizeof(HIDGAME_INPUT_DATA);
    } 
    else
    {
        Irp->IoStatus.Information = 0x0;
    }

    Irp->IoStatus.Status = ntStatus;


    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT,  "HGM_ReadReport", ntStatus);

    return ntStatus;
} /* HGM_ReadReport */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetAttributes |
 *
 *          Respond to IOCTL_HID_GET_ATTRIBUTES, by filling
 *          the HID_DEVICE_ATTRIBUTES struct
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | ???
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetAttributes
    (
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpStack;

    PAGED_CODE();

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_GetAttributes(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp));

    /*
     * Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof (HID_DEVICE_ATTRIBUTES)   )
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;

        HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR,\
                       ("HGM_GetAttributes: cbReport(0x%x) OutputBufferLength(0x%x)",\
                        sizeof (HID_DEVICE_ATTRIBUTES), IrpStack->Parameters.DeviceIoControl.OutputBufferLength));
    } else
    {
        PDEVICE_EXTENSION       DeviceExtension;
        PHID_DEVICE_ATTRIBUTES  DeviceAttributes;
        POEMDATA    OemData;

        /*
         * Get a pointer to the device extension
         */
        DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
        DeviceAttributes = (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;


        OemData = &DeviceExtension->HidGameOemData.OemData[0];
        if( DeviceExtension->fSiblingFound)
        {
            OemData = &DeviceExtension->HidGameOemData.OemData[1];
        }

        RtlZeroMemory( DeviceAttributes, sizeof(*DeviceAttributes));

        /*
         * Report how many bytes were copied
         */

        Irp->IoStatus.Information   = sizeof(*DeviceAttributes);

        DeviceAttributes->Size          = sizeof (*DeviceAttributes);
        DeviceAttributes->VendorID      = OemData->VID;
        DeviceAttributes->ProductID     = OemData->PID;
        DeviceAttributes->VersionNumber = HIDGAME_VERSION_NUMBER;

    }

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_GetAttributes", ntStatus);

    return ntStatus;
} /* HGM_GetAttributes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\poll.c ===
/*---
Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    poll.c

Abstract: This module contains the routines to poll an analog gameport device

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    Eliyas Yakub (Mar, 11, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998
    MarcAnd     02-Jul-98   Quick tidy for DDK
    MarcAnd     04-Oct-98   Re-org

@@END_DDKSPLIT

--*/

#include "hidgame.h"


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HidAnalogPoll |
 *
 *          Polling routine for analog joysticks. 
 *  <nl>Polls the analog device for position and button information.
 *  The position  information in analog devices is conveyed by the
 *  duration of a pulse width. Each axis occupies one bit position.
 *  The read operation is started by writing a value to the joystick
 *  io address. Immediately thereafter we begin examing the values
 *  returned and the elapsed time.
 *
 *  This sort of device has a few limitations:
 *
 *  First, button information is not latched by the device, so if a
 *  button press which occurrs in between polls it will be lost.
 *  There is really no way to prevent this short of devoting
 *  the entire cpu to polling.  In reality this does not cause a problem.
 *
 *  Second, since it is necessary to measure the duration of the axis pulse, 
 *  the most accurate results would be obtained using the smallest possible 
 *  sense loop and no interruptions of this loop.   
 *  The typical range of pulse lengths is from around 10 uSecs to 1500 uSecs 
 *  but depending on the joystick and gameport, this could extend to at least 
 *  8000 uSecs.  Keeping interrupts disabled for this length of time causes 
 *  many problems, like modems losing connections to sound break ups.
 *
 *  Third, because each iteration of the poll loop requires an port read, the 
 *  speed of the loop is largely constrained by the speed of the IO bus.  
 *  This also means that when there is contention for the IO bus, the loop 
 *  will be slowed down.  IO contention is usually caused by DMAs (or FDMAs)
 *  which result in a significant slow down.
 *
 *  Forth, because of the previous two problems, the poll loop may be slowed 
 *  down or interrupted at any time so an external time source is needed to 
 *  measure the pulse width for each axis.  The only cross-platform high 
 *  resolution timer is the read with KeQueryPerformanceCounter.  
 *  Unfortunately the implementation of this often uses a 1.18MHz 8253 timer 
 *  which requires 3 IO accesses to read, compounding the third problem and 
 *  even then, the result may need to be reread if the counters were in the 
 *  wrong state.  Current CPUs have on board counters that can be used to 
 *  provide very accurate timing and more recent HAL implementations tend to 
 *  use these to implement KeQueryPerformanceCounter so this will be a problem 
 *  on less systems as time goes on.  In the majority of cases, a poor 
 *  KeQueryPerformanceCounter implementation is made irrelevant by testing 
 *  for the availability of a CPU time stamp counter on Intel architechtures 
 *  and using it directly if it is available.
 *
 *  The algorithm implemented here is not the most obvious but works as 
 *  follows:
 *  
 *  Once started, the axes read a value of one until the completion of their 
 *  pulse.  The axes are the four lower bits in the byte read from the port.
 *  The state of the axes in each iteration of the poll loop is therefore 
 *  represented as a value between 0 and 15.  The important time for each 
 *  axis is the time at which it changes from 1 to 0.  This is done by using 
 *  the value representing the state of the axes to index an array into which 
 *  time values are stored.  For each axis, the duration of its pulse width is 
 *  the latest time stored in the array at an index with the bit for that axis 
 *  set.  However since interrupts can occur at any time, it is not possible 
 *  to simultaneously read the port value and record that time in an atomic 
 *  operation the in each iteration, the current time is stored in two arrays, 
 *  one using the index before the time was recorded and the other using the 
 *  index after the time was recorded.
 *  Once all the axes being monitored have become 0, or a timeout value is 
 *  reached, the data left in the arrays is analysed to find the best 
 *  estimate for the transition time for each axis.  If the times before and 
 *  after the transition differ by too much, it is judged that an interrupt 
 *  must have occured so the last known good axis value is returned unless 
 *  that falls outside the range in which it is known that the transition 
 *  occured.
 *          
 *  This routine cannot be pageable as HID can make reads at dispatch-level.
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the device extension. 
 *
 *  @parm   IN UCHAR | resisitiveInputMask |
 *      
 *          Mask that describes the axes lines that are to be polled
 * 
 *  @parm   IN BOOLEAN | fApproximate |
 *
 *          Boolean value indicating if it is OK to approximate some
 *          value of the current axis state with the last axis state
 *          if polling was not successful (we took an interrput during polling) 
 *
 *  @parm   IN OUT ULONG | Axis[MAX_AXES] |
 *          
 *          The state of the axes. On entry the last axis state is passed
 *          into this routine. If the fApproximate flag is turned on, we can
 *          make use of the last axis state to "guess" the current axis state.
 *
 *  @parm   OUT UCHAR | Button[PORT_BUTTONS]|
 *
 *          Receives the state of the buttons. 0x0 specifies the button is not
 *          pressed and 0x1 indicates an armed button state.  
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_NOT_CONNECTED | Device Failed to Quiesce 
 *          ( not connected ) This is a failure code.
 *  @rvalue   STATUS_TIMEOUT  | Could not determine exact transition time for 
 *          one or more axis.  This is a success code.
 *
 *****************************************************************************/
/*
 *  Tell a compiler that we "a" won't use any aliasing and "t" want fast code
 */
#pragma optimize( "at", on )

/*
 *  Disable warning for variable used before set as it is hard for a compiler 
 *  to see that TimeNow is always initialized before it is used.
 */
#pragma warning( disable:4701 )

NTSTATUS  INTERNAL
    HGM_AnalogPoll
    (
    IN      PDEVICE_EXTENSION   DeviceExtension,
    IN      UCHAR               resistiveInputMask,
    IN      BOOLEAN             fApproximate,
    IN  OUT ULONG               Axis[MAX_AXES],
        OUT UCHAR               Button[PORT_BUTTONS]
    )

{
    ULONG               BeforeTimes[MAX_AXES*MAX_AXES];
    ULONG               AfterTimes[MAX_AXES*MAX_AXES];
    ULONGLONG           CounterFreq;
    PUCHAR              GameContext;
    NTSTATUS            ntStatus = STATUS_SUCCESS;


    /*  
     *  To improve compiler optimization, we cast the ReadAccessor function to 
     *  return a ULONG instead of a UCHAR.  This means that the result must 
     *  always be masked before use but this would be done anyway to remove 
     *  the parts of the UCHAR we are not interested in.  
     */
typedef ULONG (*PHIDGAME_READPORT) ( PVOID  GameContext );

    PHIDGAME_READPORT   ReadPort;
    ULONG               portLast, portMask;

    
    HGM_DBGPRINT( FILE_POLL | HGM_FENTRY, \
                    ("HGM_AnalogPoll DeviceExtension=0x%x, resistiveInputMask=0x%x",\
                     DeviceExtension, resistiveInputMask ));
    

    portMask = (ULONG)(resistiveInputMask & 0xf);

    /*
     *  Initialize Times to recognizable value
     */
    memset( (PVOID)BeforeTimes, 0, sizeof( BeforeTimes ) );
    memset( (PVOID)AfterTimes, 0, sizeof( AfterTimes ) );

    /*
     *  Find where our port and data area are, and related parameters
     */
    GameContext = DeviceExtension->GameContext;
    ReadPort = (PHIDGAME_READPORT)(*DeviceExtension->ReadAccessor);

    /*
     *  get the buttons (not forgetting that the top 3 bytes are garbage)
     */
    portLast = ReadPort(GameContext);
    Button[0] = (UCHAR)(( portLast & 0x10 ) == 0x0);
    Button[1] = (UCHAR)(( portLast & 0x20 ) == 0x0);
    Button[2] = (UCHAR)(( portLast & 0x40 ) == 0x0);
    Button[3] = (UCHAR)(( portLast & 0x80 ) == 0x0);

    portLast = portMask;

    /*
     *  Start the pots 
     *  (any debug output from here until the completion of the 
     *  while( portLast ) loop will destroy the axis data)
     */
    (*DeviceExtension->WriteAccessor)(GameContext, JOY_START_TIMERS);

    /*
     *  Keep reading until all the pots we care about are zero or we time out
     */

    {
        ULONG   TimeNow;
        ULONG   TimeStart;
        ULONG   TimeOut = DeviceExtension->ScaledTimeout/Global.CounterScale;
        ULONG   portVal = portMask;
        
        TimeStart = Global.ReadCounter(NULL).LowPart;
        
        while( portLast )
        {
            TimeNow = Global.ReadCounter(NULL).LowPart - TimeStart;
            AfterTimes[portLast] = TimeNow;
            portLast = portVal;
            portVal  = ReadPort(GameContext) & portMask;
            BeforeTimes[portVal] = TimeNow;

            if( TimeNow >= TimeOut ) break;
        } 

        if( portLast && ( TimeNow >= TimeOut ) )
        {
            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE, \
                ("HGM_AnalogPoll: TimeNow: 0x%08x TimeOut: 0x%08x", TimeNow, TimeOut ) );
        }
    }

    {
        LONG    axisIdx;

        for( axisIdx = 3; axisIdx>=0; axisIdx-- )
        {
            ULONG   axisMask;

            axisMask = 1 << axisIdx;
            if( axisMask & portMask )
            {
                if( axisMask & portLast )
                {
                    /*
                     *  Whether or not a hit was taken, this axis did not 
                     *  quiesce.  So update the axis time so that next poll 
                     *  the last value will be a timeout in case a hit is 
                     *  taken over both the transition and the timeout.  
                     */
                    Axis[axisIdx] = AXIS_TIMEOUT;
                    ntStatus = STATUS_DEVICE_NOT_CONNECTED;

                    HGM_DBGPRINT( FILE_POLL |  HGM_WARN, \
                                    ("HGM_AnalogPoll: axis %x still set at timeout", axisMask ) );
                }
                else
                {
                    ULONG       timeIdx;
                    ULONG       beforeThresholdTime;
                    ULONG       afterThresholdTime;
                    ULONG       delta;

                    afterThresholdTime = beforeThresholdTime = 0;
                    for( timeIdx = axisMask; timeIdx<= portMask; timeIdx=(timeIdx+1) | axisMask )
                    {
                        if( BeforeTimes[timeIdx] > beforeThresholdTime )
                        {
                            beforeThresholdTime = BeforeTimes[timeIdx];
                            afterThresholdTime  = AfterTimes[timeIdx];
                        }
                    }


                    /*
                     *  Convert the CPU specific timing values into 'wall clock' 
                     *  values so that they can be compared with the previous 
                     *  poll values and so that the range will be dependent on 
                     *  the gamecard/joystick characteristics, not the CPU 
                     *  and counter implementation.
                     *  Use a ULONGLONG temp to avoid overflow.
                     */
                    {
                        ULONGLONG   u64Temp;

                        u64Temp = beforeThresholdTime * Global.CounterScale;
                        beforeThresholdTime = (ULONG)(u64Temp >> SCALE_SHIFT);
                        u64Temp = afterThresholdTime * Global.CounterScale;
                        afterThresholdTime = (ULONG)(u64Temp >> SCALE_SHIFT);
                    }

                    delta = afterThresholdTime - beforeThresholdTime;
                    if( delta > DeviceExtension->ScaledThreshold )
                    {
                        /*
                         *  We took an unacceptable hit so only change the value
                         *  if we know the last value is no longer correct
                         *  Since the real time is somewhere between the before and
                         *  after, take the value closer to the last value.
                         */
                        if( fApproximate )
                        {
                            /* 
                             *  Be careful not to turn a failure into a success 
                             */
                            if( NT_SUCCESS(ntStatus) )
                            {
                                ntStatus = STATUS_TIMEOUT;
                            }
                        } 
                        else
                        {
                            ntStatus = STATUS_DEVICE_NOT_CONNECTED;
                        }
                
                        if( Axis[axisIdx] >= AXIS_FULL_SCALE )
                        {
                            /*
                             *  The previous poll was a timeout
                             */
                            if( afterThresholdTime < AXIS_FULL_SCALE )
                            {
                                /*
                                 *  This poll is not a timeout so split the 
                                 *  difference since there is nothing else
                                 *  to use for an estimate.
                                 *  Since these values are scaled, it would 
                                 *  be perfectly legitimate for their sum to 
                                 *  be greater than 32 bits.
                                 */
                                Axis[axisIdx] = (beforeThresholdTime>>1)
                                              + (afterThresholdTime>>1);
                                HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                                ("HGM_AnalogPoll:Axis=%d, using glitch average           %04x",\
                                                 axisIdx, Axis[axisIdx] ) ) ;
                            }
                            else
                            {
                                /*
                                 *  Since the previous poll was a timeout and 
                                 *  there is no evidence that this is not, call 
                                 *  this a timeout.
                                 */
                                ntStatus = STATUS_DEVICE_NOT_CONNECTED;

                                HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                                ("HGM_AnalogPoll:Axis=%d, repeating timeout on glitch",\
                                                 axisIdx ) ) ;
                            }
                        }
                        else if( beforeThresholdTime > Axis[axisIdx] )
                        {
                            Axis[axisIdx] = beforeThresholdTime;

                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:Axis=%d, using smaller glitch limit     %04x",\
                                             axisIdx, Axis[axisIdx] ) ) ;
                        } 
                        else if( afterThresholdTime < Axis[axisIdx] )
                        {
                            Axis[axisIdx] = afterThresholdTime;

                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:Axis=%d, using larger glitch limit      %04x",\
                                             axisIdx, Axis[axisIdx] ) ) ;
                        }
                        else 
                        {
                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:Axis=%d, repeating previous on glitch   %04x",\
                                             axisIdx, Axis[axisIdx] ) ) ;
                        }
                    } 
                    else
                    {
                        if( (delta <<= 1) < DeviceExtension->ScaledThreshold )
                        {
                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:  Updating ScaledThreshold from %d to %d",\
                                             DeviceExtension->ScaledThreshold, delta ) ) ;

                            /* 
                             *  Fastest change yet, update 
                             */
                            DeviceExtension->ScaledThreshold = delta;
                        }

                        /*
                         *  It is possible that afterThresholdTime is greater 
                         *  than the timeout limit but since the purpose of 
                         *  the timeout is to prevent excessive sampling of 
                         *  the gameport, the success or failure of an 
                         *  uninterrupted poll around this limit is not 
                         *  important. 
                         *  Since these values are scaled, it would be 
                         *  perfectly legitimate for their sum to be greater 
                         *  than 32 bits and the 1 bit of lost resolution is
                         *  utterly negligable.
                         */
                        Axis[axisIdx] = (beforeThresholdTime>>1)
                                      + (afterThresholdTime>>1);
                    }
                }
            }
        }
    }

    HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                    ("HGM_AnalogPoll:X=%d, Y=%d, R=%d, Z=%d Buttons=%d,%d,%d,%d",\
                     Axis[0], Axis[1], Axis[2], Axis[3],\
                     Button[0],Button[1],Button[2],Button[3] ) ) ;

    HGM_EXITPROC(FILE_POLL|HGM_FEXIT, "HGM_AnalogPoll", ntStatus);

    return ntStatus;
} /* HGM_AnalogPoll */
#pragma warning( default:4701 )
#pragma optimize( "", on )




/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HGM_UpdateLatestPollData |
 *
 *          Do whatever polling is required and possible to update the 
 *          LastGoodAxis and LastGoodButton arrays in the DeviceExtension.  
 *          Handles synchronization and non-fatal errors.
 *          <nl>This routine cannot be pageable as HID can make reads at 
 *          dispatch-level.
 *
 *  @parm   IN  OUT PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension containing the data to be updated 
 *          and the functions and to use.
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR  | Invalid configuration specified
 *
 *****************************************************************************/
#define APPROXIMATE_FAILS TRUE

NTSTATUS
    HGM_UpdateLatestPollData
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    )
{
    NTSTATUS            ntStatus;
    KIRQL               oldIrql;
    LONG                axisIdx;

    /*
     *  Acquire the global spinlock
     *  Read / Writes are made at dispatch level.
     */
    KeAcquireSpinLock(&Global.SpinLock, &oldIrql );

    /*
     *  First gain exclusive access to the hardware
     */
    ntStatus = (*DeviceExtension->AcquirePort)( DeviceExtension->PortContext );
    if( NT_SUCCESS(ntStatus) )
    {
        /*
         *  If it's available, let the hardware do the work
         */
        if( DeviceExtension->ReadAccessorDigital )
        {
            ntStatus = (*DeviceExtension->ReadAccessorDigital)(DeviceExtension->GameContext,
                                    DeviceExtension->resistiveInputMask,
                                    APPROXIMATE_FAILS,
                                    &DeviceExtension->LastGoodAxis[0],
                                    &DeviceExtension->LastGoodButton[0]);
        } 
        else
        {
            ntStatus = HGM_AnalogPoll(DeviceExtension,
                                      DeviceExtension->resistiveInputMask,
                                      APPROXIMATE_FAILS,
                                      &DeviceExtension->LastGoodAxis[0],
                                      &DeviceExtension->LastGoodButton[0]);
        }

        /*
         *  Either way, release the hardware ASAP
         */
        (*DeviceExtension->ReleasePort)( DeviceExtension->PortContext );

    }

    /*
     * Release the global spinlock and return to previous IRQL
     */
    KeReleaseSpinLock(&Global.SpinLock, oldIrql);

    if( ( ntStatus == STATUS_DEVICE_BUSY ) && APPROXIMATE_FAILS )
    {
        /*
         *  Clashed trying to access the gameport.  So work with the same 
         *  data as last time unless all failures must be reported or the 
         *  last data was a failure for these axes.
         */
        for( axisIdx=3; axisIdx>=0; axisIdx-- )
        {
            if( ( ( 1 << axisIdx ) & DeviceExtension->resistiveInputMask )
              &&( DeviceExtension->LastGoodAxis[axisIdx] 
                  >= DeviceExtension->ScaledTimeout ) )
            {
                break;
            }
        }
        if( axisIdx<0 )
        {
            ntStatus = STATUS_TIMEOUT;
        }
    }


    if( !NT_SUCCESS( ntStatus ) )
    {
        HGM_DBGPRINT(FILE_IOCTL | HGM_WARN,\
                       ("HGM_UpdateLatestPollData Failed 0x%x", ntStatus));
    }

    return( ntStatus );
} /* HGM_UpdateLatestPollData */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\hidgame\i386\timing.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    timing.c

Abstract: This module contains routines to perform X86 specific timing functions

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
  Author:

    MarcAnd     12-Oct-1998

Revision History:


@@END_DDKSPLIT

--*/

#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, HGM_x86IsClockAvailable)
    #pragma alloc_text (PAGE, HGM_x86SampleClocks)
    #pragma alloc_text (PAGE, HGM_x86CounterInit)
#endif



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LARGE_INTEGER | HGM_x86ReadCounter |
 *
 *          Read the x86 CPU Time Stamp Counter
 *          This function is not pageable as it is called from DISPATCH_LEVEL
 *
 *  @parm   IN PLARGE_INTEGER | Dummy |
 *
 *          Unused parameter to match KeQueryPerformanceCounter
 *
 *  @returns LARGE_INTEGER Counter value
 *
 *****************************************************************************/
_declspec( naked ) LARGE_INTEGER EXTERNAL
    HGM_x86ReadCounter
    (
    IN      PLARGE_INTEGER      Dummy
    )
{
#define RDTSC __asm _emit 0x0f __asm _emit 0x31
    __asm RDTSC
    __asm ret SIZE Dummy
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOLEAN | HGM_x86IsClockAvailable |
 *
 *          Use direct processor interogation to see if the current CPU
 *          supports the RDTSC instruction.
 *
 *  @rvalue   TRUE | instruction supported
 *  @rvalue   FALSE | instruction not supported
 *
 *****************************************************************************/

BOOLEAN INTERNAL
    HGM_x86IsClockAvailable
    (
    VOID
    )
{
#define CPU_ID __asm _emit 0x0f __asm _emit 0xa2

    BOOLEAN rc = FALSE;

    __asm
    {
        pushfd                      // Store original EFLAGS on stack
        pop     eax                 // Get original EFLAGS in EAX
        mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
        xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
        push    eax                 // Save new EFLAGS value on stack
        popfd                       // Replace current EFLAGS value
        pushfd                      // Store new EFLAGS on stack
        pop     eax                 // Get new EFLAGS in EAX
        xor     eax, ecx            // Can we toggle ID bit?
        jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
        mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
        push    ebx                 // Don't corrupt EBX
        CPU_ID                      // Get family/model/stepping/features
        pop     ebx
        test    edx, 0x00000010L    // Check if RDTSC is available
        jz      Done                // Jump if no
    }

    rc = TRUE;
Done:
    return( rc );
} /* HGM_IsRDTSCAvailable */



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | HGM_x86SampleClocks |
 *
 *          Sample the CPU time stamp counter and KeQueryPerformanceCounter
 *          and retry until the time between samples does not improve for
 *          three consecutive loops.  This should ensure that the sampling is
 *          done without interruption on the fastest time.  It does not
 *          mattter that the timing is not the same for all iterations as
 *          any interruption should cause a much larger delay than small
 *          differences in loop logic.
 *          NOTE: Do not put any debug output in this routine as the counter
 *          reported by KeQueryPerformanceCounter, depending on implementation,
 *          may 'slip' relative to the CPU counter.
 *
 *  @parm   OUT PULONGLONG | pTSC |
 *
 *          Pointer to a ULONGLONG into which sampled CPU time is stored.
 *
 *  @parm   OUT PULONGLONG | pQPC |
 *
 *          Pointer to a ULONGLONG into which sampled performance counter is
 *          stored.
 *
 *****************************************************************************/
VOID INTERNAL
    HGM_x86SampleClocks
    (
    OUT PULONGLONG  pTSC,
    OUT PULONGLONG  pQPC
    )
{
    ULONGLONG   TestQPC;
    ULONGLONG   TestTSC;
    ULONGLONG   LastQPC;
    ULONGLONG   Delta = (ULONGLONG)-1;
    int         Retries = 3;
                /*
                 *  The first iteration of the loop below should always be 
                 *  the best so far but just in case there's a timer glitch 
                 *  set Retries anyway.  If a timer is ever found to fail 
                 *  by decrementing by 1 three times in a row Delta could be 
                 *  tested and an abort return code added.
                 */

    TestQPC = KeQueryPerformanceCounter( NULL ).QuadPart;

    do
    {
        LastQPC = TestQPC;
        /*
         *  Keep the sampling as close together as we can
         */
        TestTSC = HGM_x86ReadCounter( NULL ).QuadPart;
        TestQPC = KeQueryPerformanceCounter( NULL ).QuadPart;

        /*
         *  See if this is the quickest sample yet.
         *  If it is, give it three more loops to get better still.
         */
        if( TestQPC - LastQPC < Delta )
        {
            Delta = TestQPC - LastQPC;
            Retries = 3;
            *pQPC = TestQPC;
            *pTSC = TestTSC;
        }
        else
        {
            Retries--;
        }
    } while( Retries );


} /* HGM_x86SampleClocks */



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOLEAN | HGM_x86CounterInit |
 *
 *          Detect and, if present, calibrate an x86 Time Stamp Counter.
 *
 *          Windows 98 ntkern does not export KeNumberProcessors (even though
 *          it is in wdm.h) so there is no really simple run-time test for
 *          multiple processors.  Given the remote chance of finding a system
 *          with processors that do not symetrically support RDTSC assume that
 *          the worst that can happen is very jittery axis data.
 *          Better almost-symetric-multi-processor support could be added most
 *          easily by dropping Windows 98 support and using non-WDM functions.
 *
 *  @rvalue   TRUE | specific counter function has been set up
 *  @rvalue   FALSE | no specific counter function set up, default needed
 *
 *****************************************************************************/

BOOLEAN EXTERNAL
    HGM_x86CounterInit()
{
    LARGE_INTEGER   QPCFreq;
    BOOLEAN         rf = FALSE;

    KeQueryPerformanceCounter( &QPCFreq );

    if( ( QPCFreq.HighPart == 0 )
     && ( QPCFreq.LowPart <= 10000 ) )
    {
        /*
         *  If the performance counter is too slow to use, bail as there's
         *  probably something more serious wrong.  This is only a warning 
         *  as the caller will try again to use QPC for the default and will 
         *  make more fuss then if it fails there as well.
         */
        HGM_DBGPRINT(FILE_TIMING | HGM_WARN,\
                       ("QPC unusable at reported %I64u Hz", QPCFreq.QuadPart ));
    }
    else if( !HGM_x86IsClockAvailable() )
    {
        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                       ("No RDTSC available, using %I64u Hz QPC", QPCFreq.QuadPart ));
    }
    else if( QPCFreq.HighPart )
    {
        /*
         *  If the query performance counter runs at at least 4GHz then it is
         *  probably CPU based and this is plenty fast enough.
         *  Use the QPC to reduce the risk of an extended delay causing an
         *  overflow in the scale calculations.
         */
        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                       ("QPC too fast not to use at %I64u Hz", QPCFreq.QuadPart ));
    }
    else
    {
        ULONGLONG       QPCStart;
        ULONGLONG       TSCStart;
        ULONGLONG       QPCEnd;
        ULONGLONG       TSCEnd;

        {
            LARGE_INTEGER Delay;

            Delay.QuadPart = -50000;

            /*
             *  Trivial rejections are now out of the way.  Get a pair of start
             *  time samples, then delay for long enough to allow both timers to 
             *  increase by a significant amount, then get a pair of end samples. 
             *  KeDelayExecutionThread is used to delay 5ms but if the actual 
             *  delay is longer this is taken into account in the calculation.
             *  see NOTE in HGM_x86SampleClocks about debug output.
             */
            HGM_x86SampleClocks( &TSCStart, &QPCStart );

            KeDelayExecutionThread(KernelMode, FALSE, &Delay);

            HGM_x86SampleClocks( &TSCEnd, &QPCEnd );
        }

        {
            LARGE_INTEGER TSCFreq;

            HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                           ("RDTSC:  Start: %I64u  End: %I64u  delta: %I64u",
                           TSCStart, TSCEnd, TSCEnd - TSCStart ));

            HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                           ("QPC:  Start: %I64u  End: %I64u  delta: %I64u",
                           QPCStart, QPCEnd, QPCEnd - QPCStart ));


            TSCFreq.QuadPart = (TSCEnd - TSCStart);

            if( TSCFreq.HighPart )
            {
                /*
                 *  Somehow the delay allowed the TSC to tick more than 2^32
                 *  times so bail as that would indicate a calibration error.
                 */
                HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                           ("Clock sample failed, using %I64u Hz QPC", 
                           QPCFreq.QuadPart ));
            }
            else
            {
                /*
                 *  QPC_freq / QPC_sampled = TSC_freq / TSC_sampled
                 *  so
                 *  TSC_sampled * QPC_freq / QPC_sampled = TSC_freq
                 */

                TSCFreq.QuadPart *= QPCFreq.QuadPart;

                HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                               ("TSC_sampled * QPC_freq: %I64u", TSCFreq.QuadPart ));

                TSCFreq.QuadPart /= QPCEnd - QPCStart;

                if( TSCFreq.LowPart < HIDGAME_SLOWEST_X86_HZ )
                {
                    /*
                     *  If the value for TSC is less than the slowest CPU we 
                     *  allow something probably went wrong in the calibration.
                     */
                    HGM_DBGPRINT(FILE_TIMING | HGM_ERROR,\
                               ("TSC calibrated at %I64u Hz is too slow to be believed", 
                               TSCFreq.QuadPart ));
                }
                else
                {
                    /*
                     *  The TSC looks usable so set up the global variables.
                     */
                    rf = TRUE;

                    Global.ReadCounter = (COUNTER_FUNCTION)&HGM_x86ReadCounter;

                    /*
                     *  There's no point in calibrating the TSC against QPC if QPC
                     *  is just returning TSC.  So if the reported QPC frequency
                     *  is large enough to be a CPU counter and the sampled QPC is
                     *  very marginally larger than the TSC both before and after
                     *  the poll then just use the QPCFreq.
                     */

                    /*
                     *  HGM_x86SampleClocks always sets QPC last so it must be larger.
                     *  The QPC frequency divided by 2^20 is a little less than 1ms
                     *  worth of ticks which should be a reasonable test.
                     */
                    if( ( QPCFreq.LowPart > HIDGAME_SLOWEST_X86_HZ )
                      &&( QPCStart > TSCStart )
                      &&( QPCEnd   > TSCEnd )
                      &&( TSCEnd   > QPCStart )
                      &&( TSCStart + (QPCFreq.LowPart>>20) > QPCStart )
                      &&( TSCEnd   + (QPCFreq.LowPart>>20) > QPCEnd ) )
                    {
                        Global.CounterScale = CALCULATE_SCALE( QPCFreq.QuadPart );
                        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                                       ("RDTSC at %I64u Hz assumed from QPC at %I64u Hz with scale %d",
                                       TSCFreq.QuadPart, QPCFreq.QuadPart, Global.CounterScale ));
                    }
                    else
                    {
                        Global.CounterScale = CALCULATE_SCALE( TSCFreq.QuadPart );
                        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                                       ("RDTSC calibrated at %I64u Hz from QPC at %I64u Hz with scale %d",
                                       TSCFreq.QuadPart, QPCFreq.QuadPart, Global.CounterScale ));
                    }
                }
            }
        }
    }

    return rf;
} /* HGM_x86CounterInit */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\actions.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_ACTIONS_CPP
#include "stdhdrs.h"
#include "actions.h"

//	@doc
/**********************************************************************
*
*	@module	Actions.cpp	|
*
*	Implementation of accessor functions for action objects.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	Actions	|
*	Contains the implementation of the accessor functions for the
*	EVENT, TIMED_EVENT, TIMED_MACRO, and related structures.
*
**********************************************************************/

/***********************************************************************************
**
**	@mfunc	Get an event in a TIMED_MACRO structure, given an index
**
**	@rdesc	Pointer to next event in TIMED_MACRO
**	@rdesc	NULL if index too big.
**
*************************************************************************************/
PTIMED_EVENT 
TIMED_MACRO::GetEvent
(
	ULONG uEventNum	//@parm [in] One based index of event to get.
)
{
	ASSERT( 0 != uEventNum && "GetEvent uses 1 based index of events!");
	//
	// Implement in terms of GetNextEvent
	//	
	PTIMED_EVENT pResult = NULL;
	ULONG uEventIndex=0;
	do
	{
		pResult = GetNextEvent(pResult, uEventIndex);
	}while(pResult && uEventIndex!=uEventNum);
	return pResult;
}

/***********************************************************************************
**
**	@mfunc	Get next TIMED_EVENT in a TIMED_MACRO structure.
**
**	@rdesc	Pointer to next TIMED_EVENT in TIMED_MACRO
**
*************************************************************************************/
PTIMED_EVENT
TIMED_MACRO::GetNextEvent
(
	PTIMED_EVENT pCurrentEvent,	// @parm [in] Pointer to current event.
	ULONG& rulCurrentEvent	// @parm [in\out] Current event before and after call.
)
{
	//
	//	Range check, is there even a next event.
	//
	if( ++rulCurrentEvent > ulEventCount )
	{
		return NULL;
	}

	//
	// Check if this is the first
	//
	if(rulCurrentEvent == 1)
	{
		return rgEvents;
	}

	//
	//	Otherwise skip to next
	//
	PCHAR pcBytePointer = reinterpret_cast<PCHAR>(pCurrentEvent);
	pcBytePointer += TIMED_EVENT::RequiredByteSize(pCurrentEvent->Event.ulNumXfers);
	
	//
	//	Sanity check on debug to make sure we haven't stepped over the edge.
	//
	ASSERT(pcBytePointer <= (reinterpret_cast<PCHAR>(this)+this->AssignmentBlock.CommandHeader.ulByteSize));
	
	//
	// Cast back to proper type
	//
	return reinterpret_cast<PTIMED_EVENT>(pcBytePointer);
}

/***********************************************************************************
**
**	@mfunc	Creates a TIMED_MACRO in an empty buffer.
**
**	@rdesc	Pointer to TIMED_MACRO (start of buffer), or NULL if buffer is too small
**
*************************************************************************************/
PTIMED_MACRO TIMED_MACRO::Init
(
	ULONG	ulVidPid,				// @parm [in] Vid/Pid for macro
	ULONG	ulFlagsParm,			// @parm [in] Flags for macro.
	PCHAR	pcBuffer,				// @parm [in] Pointer to raw buffer
	ULONG&	rulRemainingBuffer		// @parm [in\out] Size of buffer on entry, remaining buffer on exit
)
{
	//
	//	Make sure buffer is large enough
	//
	if( rulRemainingBuffer < sizeof(TIMED_MACRO))
	{
		return NULL;
	}

	
	PTIMED_MACRO pThis = reinterpret_cast<PTIMED_MACRO>(pcBuffer);
	
	//
	//	Copy flags
	//
	pThis->ulFlags = ulFlagsParm;

	//
	//	Calculate remaining buffer
	//
	rulRemainingBuffer -= (sizeof(TIMED_MACRO) - sizeof(TIMED_EVENT));

	//
	//	Fill out AssignmentBlock
	//
	pThis->AssignmentBlock.CommandHeader.eID = eTimedMacro;
	pThis->AssignmentBlock.CommandHeader.ulByteSize = (sizeof(TIMED_MACRO) - sizeof(TIMED_EVENT));
	pThis->AssignmentBlock.ulVidPid = ulVidPid;

	// Set no events as of yet
	pThis->ulEventCount=0;

	return pThis;
}

/***********************************************************************************
**
**	HRESULT AddEvent(PTIMED_EVENT pTimedEvent, PTIMED_MACRO pTimedMacro, ULONG& rulRemainingBuffer)
**
**	@mfunc	Adds an event to a TIMED_MACRO and recalulates remaining buffer.
**
**	@rdesc	S_OK on Success, E_OUTOFMEMORY if buffer is too small
**
*************************************************************************************/
HRESULT TIMED_MACRO::AddEvent
(
	PTIMED_EVENT pTimedEvent,	// @parm [in] Pointer to TIMED_EVENT to add
	ULONG& rulRemainingBuffer	// @parm [in\out] Remaining buffer before and after call.
)
{
	//
	//	Make sure buffer is large enough
	//
	ULONG ulEventLength = TIMED_EVENT::RequiredByteSize(pTimedEvent->Event.ulNumXfers);
	if( ulEventLength > rulRemainingBuffer)
	{
		return E_OUTOFMEMORY;
	}

	//
	//	Skip to end of TIMED_MACRO as is.
	//
	PCHAR pcBuffer = reinterpret_cast<PCHAR>(this) + AssignmentBlock.CommandHeader.ulByteSize;

	//
	//	Copy event
	//
	DualMode::BufferCopy
	( 
		reinterpret_cast<PVOID>(pcBuffer),
		reinterpret_cast<PVOID>(pTimedEvent),
		ulEventLength
	);

	//
	//	Fix up size in COMMAND_HEADER
	//
	AssignmentBlock.CommandHeader.ulByteSize += ulEventLength;
	
	//
	//	Increment number of Events
	//
	ulEventCount++;

	//
	//	Recalculate remaining buffer
	//
	rulRemainingBuffer -= ulEventLength;

	return S_OK;
}

/************************* MULTI_MACRO Functions **************************/

/***********************************************************************************
**
**	@mfunc	Get an event in a MULTI_MACRO structure, given an index
**
**	@rdesc	Pointer to next event in MULTI_MACRO
**	@rdesc	NULL if index too big.
**
*************************************************************************************/
EVENT* 
MULTI_MACRO::GetEvent
(
	ULONG uEventNum	//@parm [in] One based index of event to get.
)
{
	ASSERT( 0 != uEventNum && "GetEvent uses 1 based index of events!");
	//
	// Implement in terms of GetNextEvent
	//	
	EVENT* pResult = NULL;
	ULONG uEventIndex=0;
	do
	{
		pResult = GetNextEvent(pResult, uEventIndex);
	}while(pResult && uEventIndex!=uEventNum);
	return pResult;
}

/***********************************************************************************
**
**	@mfunc	Get next EVENT in a MULTI_MACRO structure.
**
**	@rdesc	Pointer to next EVENT in MULTI_MACRO
**
*************************************************************************************/
EVENT*
MULTI_MACRO::GetNextEvent
(
	EVENT* pCurrentEvent,	// @parm [in] Pointer to current event.
	ULONG& rulCurrentEvent	// @parm [in\out] Current event before and after call.
)
{
	//
	//	Range check, is there even a next event.
	//
	if( ++rulCurrentEvent > ulEventCount )
	{
		return NULL;
	}

	//
	// Check if this is the first
	//
	if(rulCurrentEvent == 1)
	{
		return rgEvents;
	}

	//
	//	Otherwise skip to next
	//
	PCHAR pcBytePointer = reinterpret_cast<PCHAR>(pCurrentEvent);
	pcBytePointer += EVENT::RequiredByteSize(pCurrentEvent->ulNumXfers);
	
	//
	//	Sanity check on debug to make sure we haven't stepped over the edge.
	//
	ASSERT(pcBytePointer <= (reinterpret_cast<PCHAR>(this)+this->AssignmentBlock.CommandHeader.ulByteSize));
	
	//
	// Cast back to proper type
	//
	return reinterpret_cast<EVENT*>(pcBytePointer);
}

/***********************************************************************************
**
**	@mfunc	Creates a MULTI_MACRO in an empty buffer.
**
**	@rdesc	Pointer to MULTI_MACRO (start of buffer), or NULL if buffer is too small
**
*************************************************************************************/
MULTI_MACRO* MULTI_MACRO::Init
(
	ULONG	ulVidPid,				// @parm [in] Vid/Pid for macro
	ULONG	ulFlagsParm,			// @parm [in] Flags for macro.
	PCHAR	pcBuffer,				// @parm [in] Pointer to raw buffer
	ULONG&	rulRemainingBuffer		// @parm [in\out] Size of buffer on entry, remaining buffer on exit
)
{
	//
	//	Make sure buffer is large enough
	//
	if( rulRemainingBuffer < sizeof(MULTI_MACRO))
	{
		return NULL;
	}

	
	MULTI_MACRO* pThis = reinterpret_cast<MULTI_MACRO*>(pcBuffer);
	
	//
	//	Copy flags
	//
	pThis->ulFlags = ulFlagsParm;

	//
	//	Calculate remaining buffer
	//
	rulRemainingBuffer -= (sizeof(MULTI_MACRO) - sizeof(EVENT));

	//
	//	Fill out AssignmentBlock
	//
	pThis->AssignmentBlock.CommandHeader.eID = eTimedMacro;
	pThis->AssignmentBlock.CommandHeader.ulByteSize = (sizeof(MULTI_MACRO) - sizeof(EVENT));
	pThis->AssignmentBlock.ulVidPid = ulVidPid;

	// Set no events as of yet
	pThis->ulEventCount=0;

	return pThis;
}

/***********************************************************************************
**
**	HRESULT AddEvent(EVENT* pTimedEvent, MULTI_MACRO* pTimedMacro, ULONG& rulRemainingBuffer)
**
**	@mfunc	Adds an event to a MULTI_MACRO and recalulates remaining buffer.
**
**	@rdesc	S_OK on Success, E_OUTOFMEMORY if buffer is too small
**
*************************************************************************************/
HRESULT MULTI_MACRO::AddEvent
(
	EVENT* pEvent,				// @parm [in] Pointer to EVENT to add
	ULONG& rulRemainingBuffer	// @parm [in\out] Remaining buffer before and after call.
)
{
	//
	//	Make sure buffer is large enough
	//
	ULONG ulEventLength = EVENT::RequiredByteSize(pEvent->ulNumXfers);
	if( ulEventLength > rulRemainingBuffer)
	{
		return E_OUTOFMEMORY;
	}

	//
	//	Skip to end of TIMED_MACRO as is.
	//
	PCHAR pcBuffer = reinterpret_cast<PCHAR>(this) + AssignmentBlock.CommandHeader.ulByteSize;

	//
	//	Copy event
	//
	DualMode::BufferCopy
	( 
		reinterpret_cast<PVOID>(pcBuffer),
		reinterpret_cast<PVOID>(pEvent),
		ulEventLength
	);

	//
	//	Fix up size in COMMAND_HEADER
	//
	AssignmentBlock.CommandHeader.ulByteSize += ulEventLength;
	
	//
	//	Increment number of Events
	//
	ulEventCount++;

	//
	//	Recalculate remaining buffer
	//
	rulRemainingBuffer -= ulEventLength;

	return S_OK;
}


/************************* MAP_LIST Functions (also CYCLE_MAP, KEYSTRING_MAP) **************************/


/***********************************************************************************
**
**	@mfunc	Creates a MAP_LIST in an empty buffer. The assignment block will be set
**			as eKeyString be sure to change it if you have other preferences
**
**	@rdesc	Pointer to MAP_LIST (start of buffer), or NULL if buffer is too small
**
*************************************************************************************/
MAP_LIST* MAP_LIST::Init
(
	ULONG	ulVidPid,				// @parm [in] Vid/Pid for macro
	ULONG	ulFlagsParm,			// @parm [in] Flags for macro.
	PCHAR	pcBuffer,				// @parm [in] Pointer to raw buffer
	ULONG&	rulRemainingBuffer		// @parm [in\out] Size of buffer on entry, remaining buffer on exit
)
{
	//
	//	Make sure buffer is large enough
	//
	if( rulRemainingBuffer < sizeof(MAP_LIST))
	{
		return NULL;
	}

	
	MAP_LIST* pThis = reinterpret_cast<MAP_LIST*>(pcBuffer);

	//
	//	Copy flags
	//
	pThis->ulFlags = ulFlagsParm;

	//
	//	Calculate remaining buffer
	//
	rulRemainingBuffer -= (sizeof(MAP_LIST) - sizeof(EVENT));

	//
	//	Fill out AssignmentBlock
	//
	pThis->AssignmentBlock.CommandHeader.eID = eKeyString;
	pThis->AssignmentBlock.CommandHeader.ulByteSize = (sizeof(MAP_LIST) - sizeof(EVENT));
	pThis->AssignmentBlock.ulVidPid = ulVidPid;

	//Init event count to zero
	pThis->ulEventCount=0;

	return pThis;
}

/***********************************************************************************
**
**	@mfunc	Get next EVENT in a MAP_LIST structure.
**
**	@rdesc	Pointer to requested EVENT in MAP_LIST, or NULL if index too big
**
*************************************************************************************/
PEVENT MAP_LIST::GetEvent
(
	ULONG uEventNum	//@parm [in] One based index of event to get.
)
{
	ASSERT( 0 != uEventNum && "GetEvent uses 1 based index of events!");
	//
	// Implement in terms of GetNextEvent
	//	
	PEVENT pResult = NULL;
	ULONG uEventIndex=0;
	do
	{
		pResult = GetNextEvent(pResult, uEventIndex);
	}while(pResult && uEventIndex!=uEventNum);
	return pResult;
}

/***********************************************************************************
**
**	PEVENT MAP_LIST::GetNextEvent(PEVENT pCurrentEvent, ULONG& rulCurrentEvent)
**
**	@mfunc	Gets the next event in a MAP_LIST
**
**	@rdesc	Pointer to next EVENT on success, NULL if no more EVENTs
**
*************************************************************************************/
PEVENT MAP_LIST::GetNextEvent
(
	PEVENT pCurrentEvent,	// @parm Pointer to current EVENT
	ULONG& rulCurrentEvent	// @parm [in/out] Event number before and after call.
)
{
	//
	//	Range check, is there even a next event.
	//
	if( ++rulCurrentEvent > ulEventCount )
	{
		return NULL;
	}

	//
	// Check if this is the first
	//
	if(rulCurrentEvent == 1)
	{
		return rgEvents;
	}

	//
	//	Otherwise skip to next
	//
	PCHAR pcBytePointer = reinterpret_cast<PCHAR>(pCurrentEvent);
	pcBytePointer += EVENT::RequiredByteSize(pCurrentEvent->ulNumXfers);
	
	//
	//	Sanity check on debug to make sure we haven't stepped over the edge.
	//
	ASSERT(pcBytePointer <= (reinterpret_cast<PCHAR>(this)+this->AssignmentBlock.CommandHeader.ulByteSize));
	
	//
	// Cast back to proper type
	//
	return reinterpret_cast<PEVENT>(pcBytePointer);
}

/***********************************************************************************
**
**	HRESULT AddEvent(PTIMED_EVENT pTimedEvent, PTIMED_MACRO pTimedMacro, ULONG& rulRemainingBuffer)
**
**	@mfunc	Adds an event to a TIMED_MACRO and recalulates remaining buffer.
**
**	@rdesc	S_OK on Success, E_OUTOFMEMORY if buffer is too small
**
*************************************************************************************/
HRESULT MAP_LIST::AddEvent
(
	EVENT* pEvent,				// @parm [in] Pointer to EVENT to add
	ULONG& rulRemainingBuffer	// @parm [in\out] Remaining buffer before and after call.
)
{
	//
	//	Make sure buffer is large enough
	//
	ULONG ulEventLength = EVENT::RequiredByteSize(pEvent->ulNumXfers);
	if( ulEventLength > rulRemainingBuffer)
	{
		return E_OUTOFMEMORY;
	}

	//
	//	Skip to end of MAP_LIST as is.
	//
	PCHAR pcBuffer = reinterpret_cast<PCHAR>(this) + AssignmentBlock.CommandHeader.ulByteSize;

	//
	//	Copy event
	//
	DualMode::BufferCopy
	( 
		reinterpret_cast<PVOID>(pcBuffer),
		reinterpret_cast<PVOID>(pEvent),
		ulEventLength
	);

	//
	//	Fix up size in COMMAND_HEADER
	//
	AssignmentBlock.CommandHeader.ulByteSize += ulEventLength;

	//
	//	Increment number of Events
	//
	ulEventCount++;

	//
	//	Recalculate remaining buffer
	//
	rulRemainingBuffer -= ulEventLength;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\actions.h ===
#ifndef __ACTIONS_H__
#define __ACTIONS_H__
//	@doc
/**********************************************************************
*
*	@module	Actions.h	|
*
*	Definitions of data structures for representing Actions and Events
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*	Jeffrey A. Davis	Modifications.
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@index	Actions | ACTIONS
*
*	@topic	Actions	|
*	Contains definitions of structures, constants, and macros
*	for building up and working with Actions and their constituent Events
*
**********************************************************************/
#include "controlitems.h"
#include "profile.h"		// legacy data structures.
#define	CF_RAWSCHEME	(0x201)


#pragma pack(push, actions_previous_alignment)
#pragma pack(1)

//
//	Flags included as part of commands type.
//	used to define different properties of some commands

#define	COMMAND_TYPE_FLAG_ASSIGNMENT	0x8000


//
//	Different types of command that can be sent to GcKernel
//
#define COMMAND_TYPE_ASSIGNMENT_TARGET	0x0001
#define COMMAND_TYPE_RECORDABLE			(0x0002 | COMMAND_TYPE_FLAG_ASSIGNMENT)
#define COMMAND_TYPE_BEHAVIOR			(0x0003 | COMMAND_TYPE_FLAG_ASSIGNMENT)
#define COMMAND_TYPE_FEEDBACK			(0x0004 | COMMAND_TYPE_FLAG_ASSIGNMENT)
#define COMMAND_TYPE_TRANSLATE			0x0005
#define COMMAND_TYPE_QUEUE				0x0006
#define COMMAND_TYPE_GENERAL			0x0007


//
//	@enum COMMAND_ID |
//	a.k.a ACTION_OBJECT_ID, and BEHAVIOR_OBJECT_ID
//	defines the sepcific command.
//	
typedef enum COMMAND_ID
{
	eDirectory = 0,											//@field Directory.

	//
	// Assignment Targets IDs
	//
	eAssignmentTargetPlaceTag = (COMMAND_TYPE_ASSIGNMENT_TARGET << 16),	//Beginning of Assignment Targets
	eRecordableAction,										//@field Recordable Action
	eBehaviorAction,										//@field Behavior Action
	eFeedbackAction,										//@field Feedback Action

	//
	// Recordable Assignment IDs
	//
	eAssignmentPlaceTag = (COMMAND_TYPE_RECORDABLE << 16),	//Beginning of assignments
	eTimedMacro,											//@field A timed macro
	eKeyString,												//@field An untimed string of keys
	eButtonMap,												//@field A single button mapped (or direction)
	eKeyMap,												//@field A single keyboard key mapped
	eCycleMap,												//@field A single keyboard key mapped
	eNone,													//@field Was eAxisMap used as NONE

	//
	// Mouse Input Assignment IDs - use with eRecordableAction assignment targets.
	// These are mutually exclusive with Macors and other recordable assignments.
	// The ones with FX (all except eMouseButtonMap) do nothing unless eMouseFXModel is sent to the device(below)
	eMouseButtonMap,										//@field Maps a mouse button
	eMouseFXAxisMap,										//@field Maps a mouse axis
	eMouseFXClutchMap,										//@field Maps the button to turn clutch on in Mouse FX model
	eMouseFXDampenMap,										//@field Maps the button to turn dampen on in Mouse FX model
	eMouseFXZoneIndicator,									//@field Maps an an input to indicate zone in Mouse FX model
	//
	// Axis IDs
	//
	eAxisMap,												//@field A mapping of one axis to another
    eAxisToKeyMap,                                          //@field A mapping of an axis to key (Used in Attila)

	// Atilla Macro (MultiMap?)
	eMultiMap,												//@field Maps to keys, delays, and mouse clicks

    //
	// Behavior Assignment IDs
	//
	eBehaviorPlaceTag = (COMMAND_TYPE_BEHAVIOR << 16),		//Beginning of Behaviors
	eStandardBehaviorCurve,									//@field A behavior curve assigned to and axes

	
    //
	// Feedback Assignment IDs
	//
	eFeedbackPlaceTag = (COMMAND_TYPE_FEEDBACK << 16),		//Beginning of Feedback types
    eForceMap,                                              //MapYToX, RTC, Gain (Driver Should Ignore) Sparky Zep Additions

	//
	// Translation IDs
	//
	eTranslatePlaceTag = (COMMAND_TYPE_TRANSLATE << 16),	//Beginning of Translate types
	eAtlasProfile,											//@field ATLAS entire Profile.
	eXenaProfile,											//@field XENA entire profile.
	eAtlasKeyboardMacro,									//@field ATLAS macro.
	eXenaKeyboardMacro,										//@field XENA macro.
	eAtlasTimedMacro,										//@field ATLAS macro.
	eXenaTimedMacro,										//@field XENA macro.
	eAtlasSetting,											//@field ATLAS Settings flags							
	eXenaSetting,											//@field XENA Settings flags							
	
	//
	// Queue Command IDs
	//
	eQueuePlaceTag = (COMMAND_TYPE_QUEUE << 16),			//Beginning of Queue
	eSetQueueInterruptMode,									//@field Cause one macro to interupt another
	eSetQueueOverlayMode,									//@field Causes macros to overlay each other
	eSetQueueSequenceMode,									//@field Causes macros to play in sequence

	//
	// General Command IDs
	//
	eGeneralCommandsPlaceTag = (COMMAND_TYPE_GENERAL << 16),//Beginning of General Commands
	eResetScheme,				//@field Resets all the settings of a scheme
} ACTION_OBJECT_ID, BEHAVIOR_OBJECT_ID;


// There are the different type of proportional axes
typedef enum AXIS_ID
{
    eX = 0,
    eY,
    eZ,
    eRX,
    eRY,
    eRZ
};


//
//	@struct COMMAND_HEADER |
//	Each command begins with a COMMAND_HEADER
typedef struct 
{
	COMMAND_ID	eID;			//@field ID of command
	ULONG		ulByteSize;		//@field Length of command including this header
} COMMAND_HEADER, *PCOMMAND_HEADER;

//
//	@struct COMMAND_DIRECTORY |
//	Dirtectory block that lists one or more sets of commands.
typedef struct tagCOMMAND_DIRECTORY
{
	COMMAND_HEADER CommandHeader;	//@field Command header
	USHORT	usNumEntries;			//@field Number of IDs that follow.
	ULONG	ulEntireSize;	
}	COMMAND_DIRECTORY, 
	*PCOMMAND_DIRECTORY;

//
//	@struct ASSIGNMENT_BLOCK |
//	Assignment blocks are any block with a
//	COMMAND_ID that has the COMMAND_TYPE_FLAG_ASSIGNMENT
//	set.  You can assume that these blocks start
//	with this structure as an extension of the COMMAND_HEADER
//	structure.
typedef struct ASSIGNMENT_BLOCK
{
	COMMAND_HEADER CommandHeader;	//@field Command header
	ULONG			ulVidPid;		//@field VIDPID.
} *PASSIGNMENT_BLOCK;

//
//	@func Get the type of command from a COMMAND_ID., 
//	
//	@rdesc COMMAND_TYPE_ASSIGNMENT	Command is an action assignment.
//	@rdesc COMMAND_TYPE_BEHAVIOR	Command is a behavior assignment.
//	@rdesc COMMAND_TYPE_QUEUE		Command changes properties of Action queue.
//	@rdesc COMMAND_TYPE_GENERAL		Command modifies a general property of the filter.
//
#ifdef __cplusplus
inline ULONG
CommandType
(
	COMMAND_ID eID  //@parm COMMAND_ID to get type of
)
{
	return static_cast<ULONG>(eID >> 16) & 0x0000FFFF;
}
#else //if not __cplusplus, define as macro instead
#define CommandType(__ID__) ((ULONG)(__ID__ >> 16) & 0x0000FFFF)
#endif //__cplusplus


//
//	@struct EVENT | Describes a single untimed event which may contain
//			device data or keystrokes.
//
//	@field ULONG | ulNumXfers | Number CONTROL_ITEM_XFER's in EVENT
//	@field CONTROL_ITEM_XFER | rgXfers[] | Array of events
typedef struct tagEVENT
{	
	ULONG			  ulNumXfers;	
	CONTROL_ITEM_XFER rgXfers[1];	

	//
	//	@mfunc static ULONG | EVENT | RequiredByteSize |
	//	Calculates the bytes required for an event given the number
	//	CONTROL_ITEM_XFER's.
	//
#ifdef __cplusplus
	static ULONG RequiredByteSize(
						ULONG ulNumXfers //@parm Number of CONTROL_ITEM_XFERs
						)
	{
		ASSERT(0!=ulNumXfers);
		return (ulNumXfers-1)*sizeof(CONTROL_ITEM_XFER)+sizeof(tagEVENT);
	}

	// Simple accessor for retrieval of Xfers by index
	CONTROL_ITEM_XFER& GetControlItemXfer(ULONG ulXferIndex)
	{
		ASSERT(ulXferIndex < ulNumXfers); // && TEXT("Requested Xfer is greater than the number of xfers"));
		return rgXfers[ulXferIndex];
	}

	// Assumes XFers are in the same order!!
	bool operator==(const tagEVENT& rhs)
	{
		if (ulNumXfers != rhs.ulNumXfers)
		{
			return false;
		}
		for (UINT i = 0; i < ulNumXfers; i++)
		{
			if (rgXfers[i] != rhs.rgXfers[i])
			{
				return false;
			}
		}

		// If we got this far all matched
		return true;
	}

	bool operator!=(const tagEVENT& rhs)
	{
		return !(operator==(rhs));
	}
#endif	__cplusplus
} EVENT, *PEVENT;

//
//	@struct TIMED_EVENT | Describes a single timed event which may contain
//			device data or keystrokes.
//
//	@field ULONG | ulDuration |	Duration of timed event.
//	@field EVENT | Event | Untimed EVENT
typedef struct tagTIMED_EVENT
{
	ULONG	ulDuration;		
	EVENT	Event;			
	
	//
	//	@mfunc static ULONG | TIMED_EVENT | RequiredByteSize |
	//	Calculates the bytes required for an event given the number
	//	CONTROL_ITEM_XFER's.
	//
#ifdef __cplusplus
	static ULONG RequiredByteSize(
					ULONG ulNumXfers //@parm Number of CONTROL_ITEM_XFERs
				)
	{
//		ASSERT(0!=ulNumXfers);
		return (ulNumXfers-1)*sizeof(CONTROL_ITEM_XFER)+sizeof(tagTIMED_EVENT);
	}
#endif
} TIMED_EVENT, *PTIMED_EVENT;


const ULONG ACTION_FLAG_AUTO_REPEAT			= 0x00000001;
const ULONG ACTION_FLAG_BLEED_THROUGH		= 0x00000002;
const ULONG ACTION_FLAG_PREVENT_INTERRUPT	= 0x00000004;

//
//	@struct TIMED_MACRO | Structure to represent a timed macro.
//	@field	COMMAND_HEADER	|	CmdHeader	|	Command header must have eID = eTimedMacro.
//	@field	ULONG	|	ulFlags	|	Flags modify the properties of the macro.<nl>
//									ACTION_FLAG_AUTO_REPEAT - Macro repeats as long as trigger is held.<nl>
//									ACTION_FLAG_BLEED_THROUGH - Allows bleed-through and coexisting macros <nl>
//									ACTION_FLAG_PREVENT_INTERRUPT - Prevents a macro from being interrupted by another.<nl>
//	@field ULONG	| ulEventCount	| Number of events in Macro.
//	@field TIMED_EVENT | rgEvents[1] | Events in macro - do not access directly, use accessors
//	@xref TIMED_MACRO::GetEvent
//	@xref TIMED_MACRO::GetNextEvent
typedef struct tagTIMED_MACRO
{
		//
		//	Data for TIMED_MACROS
		//
		ASSIGNMENT_BLOCK		AssignmentBlock;
		ULONG					ulFlags;
		ULONG					ulEventCount;

	#ifdef __cplusplus
		
		//
		// Accessor functions for events which are variable length,
		// so do not access private item directly
		PTIMED_EVENT GetEvent(ULONG uEventNum);
		PTIMED_EVENT GetNextEvent(PTIMED_EVENT pCurrentEvent, ULONG& ulCurrentEvent);
		static tagTIMED_MACRO *Init(ULONG ulVidPid,ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
		HRESULT AddEvent(PTIMED_EVENT pTimedEvent, ULONG& rulRemainingBuffer);
	
	 private:
	#endif //__cplusplus
		TIMED_EVENT			rgEvents[1];
	
} TIMED_MACRO, *PTIMED_MACRO; 

typedef struct tagMULTI_MACRO
{
		//
		//	Data for MULTI_MACRO
		//
		ASSIGNMENT_BLOCK		AssignmentBlock;
		ULONG					ulFlags;
		ULONG					ulEventCount;

	#ifdef __cplusplus
		
		//
		// Accessor functions for events which are variable length,
		// so do not access private item directly
		PEVENT GetEvent(ULONG uEventNum);
		PEVENT GetNextEvent(EVENT* pCurrentEvent, ULONG& ulCurrentEvent);
		static tagMULTI_MACRO *Init(ULONG ulVidPid, ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
		HRESULT AddEvent(EVENT* pEvent, ULONG& rulRemainingBuffer);
	
	 private:
	#endif //__cplusplus
		EVENT	rgEvents[1];
	
} MULTI_MACRO, *PMULTI_MACRO; 


typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	MACRO				Macro;
} XENA_MACRO_BLOCK, *PXENA_MACRO_BLOCK;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	ATLAS_MACRO			Macro;
} ATLAS_MACRO_BLOCK, *PATLAS_MACRO_BLOCK;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	SETTING				Setting;
} XENA_SETTING_BLOCK, *PXENA_SETTING_BLOCK;


typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	ATLAS_SETTING		Setting;
} ATLAS_SETTING_BLOCK, *PATLAS_SETTING_BLOCK;



typedef struct tagMAP_LIST
{
	ASSIGNMENT_BLOCK		AssignmentBlock;
	ULONG					ulFlags;
	ULONG					ulEventCount;
#ifdef __cplusplus
	//
	// Accessor functions for events which are variable length,
	// so do not access private item directly
	PEVENT GetEvent(ULONG uEventNum);
	PEVENT GetNextEvent(PEVENT pCurrentEvent, ULONG& ulCurrentEvent);

	static tagMAP_LIST* Init(ULONG ulVidPid,ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
	HRESULT AddEvent(EVENT* pTimedEvent, ULONG& rulRemainingBuffer);

	private:
#endif
	EVENT					rgEvents[1];
} MAP_LIST, *PMAP_LIST, CYCLE_MAP, *PCYCLE_MAP, KEYSTRING_MAP, *PKEYSTRING_MAP;

typedef struct tagX_MAP
{
	ASSIGNMENT_BLOCK		AssignmentBlock;
	ULONG					ulFlags;
	ULONG					ulEventCount;	// Not gauranteeing, but should always be 1
	EVENT					Event;
} KEY_MAP, *PKEY_MAP, BUTTON_MAP, *PBUTTON_MAP;

/*
*	BUGBUG	This structure is only useful for mapping axes of type CGenericItem or derivatives.
*	BUGBUG	This is due to limitations in GcKernel.  For example the Y-Z axis swap for
*	BUGBUG	for joysticks is currently broken.  See the comment in the declaration of CAxisMap
*	BUGBUG	in filter.h in the GcKernel.sys project for details.
*/
typedef struct tagAXIS_MAP
{
	ASSIGNMENT_BLOCK	AssignmentBlock;	//eAxisMap is the type
	LONG				lCoefficient1024x;	//A mapping coeffiecient times 1024 (should be between -1024 and 1024)
	CONTROL_ITEM_XFER	cixDestinationAxis; //Axis to map to.
} AXIS_MAP, *PAXIS_MAP;

typedef struct 
{
	short sX;
	short sY;
}CURVE_POINT;

typedef struct tagBEHAVIOR_CURVE
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	BOOLEAN				fDigital;			//This flag is only flag for PROPDPads that are software programmable.
	ULONG			ulRange;
	USHORT			usPointCount;
	CURVE_POINT		rgPoints[1];
#ifdef __cplusplus
	static ULONG RequiredByteSize(USHORT usNumPoints)
	{
		return (usNumPoints-1)*sizeof(CURVE_POINT)+sizeof(tagBEHAVIOR_CURVE);
	}
#endif
} BEHAVIOR_CURVE, *PBEHAVIOR_CURVE;


typedef struct
{
	COMMAND_HEADER		CommandHeader;
	CONTROL_ITEM_XFER	cixAssignment;
} ASSIGNMENT_TARGET, *PASSIGNMENT_TARGET;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	UCHAR				ucButtonNumber;
} MOUSE_BUTTON_MAP, *PMOUSE_BUTTON_MAP;

typedef struct tagMOUSE_MODEL_FX_PARAMETERS
{
	ULONG				ulAbsZoneSense;
	ULONG				ulContZoneMaxRate;
	ULONG				ulPulseWidth;
	ULONG				ulPulsePeriod;
	ULONG				ulInertiaTime;
	ULONG				ulAcceleration;
	BOOLEAN				fAccelerate;
	BOOLEAN				fPulse;
	USHORT				usReserved;
}	MOUSE_MODEL_PARAMETERS, *PMOUSE_MODEL_PARAMETERS;

typedef struct
{
	ASSIGNMENT_BLOCK		AssignmentBlock;
	BOOLEAN					fIsX; //TRUE = x; FALSE = y
	MOUSE_MODEL_PARAMETERS	AxisModelParameters;
} MOUSE_FX_AXIS_MAP, *PMOUSE_FX_AXIS_MAP;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
} MOUSE_FX_CLUTCH_MAP, *PMOUSE_FX_CLUTCH_MAP;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
} MOUSE_FX_DAMPEN_MAP, *PMOUSE_FX_DAMPEN_MAP;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	UCHAR				ucAxis;	//0 = X, 1=Y, 2=Z
} MOUSE_FX_ZONE_INDICATOR, *PMOUSE_FX_ZONE_INDICATOR; 

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
    UCHAR               bMapYToX;            //@field Bool value 
    USHORT              usRTC;               //@field return to center force (0-10000)
    USHORT              usGain;              //@field gain for the device
} *PFORCE_BLOCK, FORCE_BLOCK;

typedef struct tagAXISTOKEYMAPMODEL
{
	//
	//	Data for AXISTOKEYMAPMODEL
	//
	ASSIGNMENT_BLOCK		AssignmentBlock;
	ULONG					ulActiveAxes;		//@field Which axes have mappings
	ULONG					ulEventCount;		//@field How many axis have mappings

#ifdef __cplusplus
	
	//
	// Accessor functions for events which are variable length,
	// so do not access private item directly
//	PEVENT GetEvent(ULONG uEventNum);
//	PEVENT GetNextEvent(EVENT* pCurrentEvent, ULONG& ulCurrentEvent);
//	static tagMULTI_MACRO *Init(ULONG ulVidPid, ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
//	HRESULT AddEvent(EVENT* pEvent, ULONG& rulRemainingBuffer);

 private:
#endif //__cplusplus
	EVENT	rgEvents[1];						//@field Variable size array of events for mappings
} *PAXISTOKEYMAPMODEL_BLOCK, AXISTOKEYMAPMODEL_BLOCK;

#pragma pack(pop, actions_previous_alignment)

#endif //__ACTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitemcollection.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_CONTROLITEMCOLLECTION_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	ControlItemCollection.cpp	|
*
*	Implementation of CControlItemCollection implementation functions
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ControlItemCollection	|
*	This library encapsulates HID parsing and driver packet code.  It is
*   used it both the driver and the control panel applet.
*
**********************************************************************/



/***********************************************************************************
**
**	CControlItemCollectionImpl::Init
**
**	@mfunc	Initialize collection by calling factory to get items
**
**	@rdesc	S_OK on success, S_FALSE if factory failed to support one or
**			 more of the items, E_FAIL if device not supported or error from factory
**
*************************************************************************************/
HRESULT CControlItemCollectionImpl::Init(
		ULONG			  ulVidPid,				//@parm [in] Vid in the high word, Pid in the low word
		PFNGENERICFACTORY pfnFactory,			//@parm	[in] pointer to function which acts
												//			on pFactoryHandle
		PFNGENERICDELETEFUNC pfnDeleteFunc		//@parm [in] delete function to used for control items
		)
{
	CIC_DBG_ENTRY_PRINT(("CControlItemCollectionImpl::Init(0x%0.8x, 0x%0.8x)\n", ulVidPid, pfnFactory));
	
	
	HRESULT hr = S_OK;
	
	//
	//	Walk the table devices and find a matching VidPid
	//
	ULONG ulDeviceIndex=0;
	
	//
	// Endless loop, you get out by breaking, or returning from the function.
	//
	while(1)
	{
		//
		//	If we have reached the end of the table
		//
		if(0 == DeviceControlsDescList[ulDeviceIndex].ulVidPid )
		{
			ASSERT(FALSE); //Should never get here.
			return E_FAIL; //BUGBUGBUG need more descriptive error code here
		}
		if(DeviceControlsDescList[ulDeviceIndex].ulVidPid == ulVidPid)
		{
			break;
		}
		ulDeviceIndex++;
	}
	m_ulDeviceIndex = ulDeviceIndex;

	//
	//	Use the size argument to pre-allocate space for the list
	//
	hr = m_ObjectList.SetAllocSize(DeviceControlsDescList[m_ulDeviceIndex].ulControlItemCount, NonPagedPool);
	if( FAILED(hr) )
	{
		return hr;
	}

	//
	//	Set the delete function for the class
	//
	m_ObjectList.SetDeleteFunc(pfnDeleteFunc);
	
	//
	//	Walk through the control item list and call the factory for each one
	//
	CONTROL_ITEM_DESC		*pControlItems = reinterpret_cast<CONTROL_ITEM_DESC *>(DeviceControlsDescList[m_ulDeviceIndex].pControlItems);
	PVOID					pNewControlItem;
	HRESULT hrFactory;
	m_ulMaxXfers = 0;
	for(
			ULONG ulControlIndex = 0;
			ulControlIndex < DeviceControlsDescList[m_ulDeviceIndex].ulControlItemCount;
			ulControlIndex++
	)
	{
		//
		//	Call factory to get new control item
		//
		hrFactory = pfnFactory(pControlItems[ulControlIndex].usType, &pControlItems[ulControlIndex], &pNewControlItem);
		
		//
		//  If the factory fails mark an error
		//
		if( FAILED(hrFactory) )
		{
			hr = hrFactory;
			continue;
		}

		//
		//	If the factory does not support that control add a null to the list
		//	to hold the index as taken 
		//
		if( S_FALSE == hrFactory )
		{
			pNewControlItem = NULL;
		}
		else
		//an Xfer would be needed to get the state.
		{
			m_ulMaxXfers++;
		}

		//
		//	Add item (or NULL) to list of items in collection
		//
		hrFactory = m_ObjectList.Add(pNewControlItem);
		if( FAILED(hrFactory) )
		{
			hr = hrFactory;
		}
	}

	//
	//	Return error code
	//
	return hr;

}


/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::GetNext
**
**	@mfunc	Gets the next item in list
**
**	@rdesc	S_OK on success, S_FALSE if no more items
**
************************************************************************************/
HRESULT CControlItemCollectionImpl::GetNext
(
	PVOID *ppControlItem,		//@parm pointer to receive control item
	ULONG& rulCookie			//@parm cookie to keep track of enumeration
) const
{
	CIC_DBG_RT_ENTRY_PRINT(("CControlItemCollectionImpl::GetNext(0x%0.8x, 0x%0.8x)\n", ppControlItem, rulCookie));
	
	if(	rulCookie >= m_ObjectList.GetItemCount() )
	{
		*ppControlItem = NULL;
		CIC_DBG_EXIT_PRINT(("Exit GetNext - no more items\n"));
		return S_FALSE;
	}
	else
	{
		*ppControlItem = m_ObjectList.Get( rulCookie );
		rulCookie += 1;
		if(!*ppControlItem)
		{
			CIC_DBG_EXIT_PRINT(("Calling GetNext recursively\n"));
			return GetNext(ppControlItem, rulCookie);
		}
		CIC_DBG_RT_EXIT_PRINT(("Exit GetNext - *ppControlItem = 0x%0.8x\n", *ppControlItem));
		return S_OK;
	}
}

/***********************************************************************************
**
**	PVOID CControlItemCollectionImpl::GetFromControlItemXfer
**
**	@mfunc	Returns item given CONTROL_ITEM_XFER
**
**	@rdesc	Pointer to item on success, NULL if not
**
************************************************************************************/
PVOID CControlItemCollectionImpl::GetFromControlItemXfer(
		const CONTROL_ITEM_XFER& crControlItemXfer	//@parm [in] report selector to get object for
)
{
	CIC_DBG_RT_ENTRY_PRINT(("CControlItemCollectionImpl::GetFromControlItemXfer\n"));
	
	ULONG ulListIndex = crControlItemXfer.ulItemIndex - 1;
	
	ASSERT( m_ObjectList.GetItemCount() > ulListIndex);
	if( m_ObjectList.GetItemCount() <= ulListIndex)
	{
		return NULL;
	}
	
	CIC_DBG_RT_EXIT_PRINT(("Exiting CControlItemCollectionImpl::GetFromControlItemXfer\n"));	
	return m_ObjectList.Get(ulListIndex);
}

/***********************************************************************************
**
**	NTSTATUS CControlItemCollectionImpl::ReadFromReport
**
**	@mfunc	Recurses collection and asks each item to read its state.
**
**	@rdesc	Use NT_SUCCESS, NT_ERROR, SUCCEEDED, FAILED macros to parse.
**
************************************************************************************/
NTSTATUS CControlItemCollectionImpl::ReadFromReport
(
	PHIDP_PREPARSED_DATA pHidPPreparsedData,	//@parm hid preparsed data
	PCHAR pcReport,								//@parm report buffer
	LONG lReportLength,							//@parm length of report buffer
	PFNGETCONTROLITEM	GetControlFromPtr		//@parm pointer to function to get CControlItem *
)
{
	NTSTATUS NtStatus;
	NtStatus = ControlItemsFuncs::ReadModifiersFromReport(
					DeviceControlsDescList[m_ulDeviceIndex].pModifierDescTable,
					m_ulModifiers,
					pHidPPreparsedData,
					pcReport,
					lReportLength
					);
	if( NT_ERROR(NtStatus) )
	{
		CIC_DBG_ERROR_PRINT(("ReadModifiersFromReport returned 0x%0.8x\n", NtStatus));
				
		//
		//	Instead of returning, let's go on, the modifiers are important, but
		//	not important enough to cripple everything else.
		NtStatus = S_OK;
	}

	//
	//	Loop over all items and read them
	//
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;

	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		NtStatus= pControlItem->ReadFromReport(
						pHidPPreparsedData,
						pcReport,
						lReportLength
						);
		if( NT_ERROR(NtStatus) )
		{
			CIC_DBG_ERROR_PRINT(("pControlItem->ReadFromReport returned 0x%0.8x, ulCookie = 0x%0.8x\n", NtStatus, ulCookie));
			return NtStatus;
		}
		pControlItem->SetModifiers(m_ulModifiers);
		hr = GetNext(&pvControlItem, ulCookie);
	}
	return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS CControlItemCollectionImpl::WriteToReport
**
**	@mfunc	Recurses collection and asks each item to write its state to the report.
**
**	@rdesc	Use NT_SUCCESS, NT_ERROR, SUCCEEDED, FAILED macros to parse.
**
************************************************************************************/
NTSTATUS CControlItemCollectionImpl::WriteToReport
(
	PHIDP_PREPARSED_DATA pHidPPreparsedData,	//@parm hid preparsed data
	PCHAR pcReport,								//@parm report buffer
	LONG lReportLength,							//@parm length of report buffer
	PFNGETCONTROLITEM	GetControlFromPtr		//@parm pointer to function to get CControlItem *
) const
{
	//
	//	Loop over all items and write to them
	//
	NTSTATUS NtStatus;
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		NtStatus= pControlItem->WriteToReport(
						pHidPPreparsedData,
						pcReport,
						lReportLength
						);
		if( NT_ERROR(NtStatus) )
		{
			CIC_DBG_ERROR_PRINT(("pControlItem->WriteToReport returned 0x%0.8x, ulCookie = 0x%0.8x\n", NtStatus, ulCookie));
			return NtStatus;
		}
		hr = GetNext(&pvControlItem, ulCookie);
	}
	if( FAILED(hr) )
	{
		ASSERT(SUCCEEDED(hr));
		return hr;
	}

	NtStatus = ControlItemsFuncs::WriteModifiersToReport(
					DeviceControlsDescList[m_ulDeviceIndex].pModifierDescTable,
					m_ulModifiers,
					pHidPPreparsedData,
					pcReport,
					lReportLength
					);

	return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS CControlItemCollectionImpl::WriteToReport
**
**	@mfunc	Recurses collection and asks each item to set its self to its default state.
**
**	@rdesc	Use NT_SUCCESS, NT_ERROR, SUCCEEDED, FAILED macros to parse.
**
************************************************************************************/
void CControlItemCollectionImpl::SetDefaultState
(
	PFNGETCONTROLITEM	GetControlFromPtr //@parm pointer to function to get CControlItem *
)
{
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		pControlItem->SetDefaultState();
		hr = GetNext(&pvControlItem, ulCookie);
	}
	m_ulModifiers=0;
}


/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::GetState
**
**	@mfunc	Gets the state of each item in the collection and return it in the caller
**
**	@rdesc	S_OK on success, E_OUTOFMEMORY if buffer is not large enough
**
*************************************************************************************/
HRESULT CControlItemCollectionImpl::GetState
(
	ULONG& ulXferCount,						// @parm [in\out] specifies length of array on entry
											// and items used on exit
	PCONTROL_ITEM_XFER pControlItemXfers,	// @parm [out] caller allocated buffer to hold packets
	PFNGETCONTROLITEM	GetControlFromPtr	// @parm [in] function to get CControlItem *
)
{
	HRESULT hr = S_OK;

	ULONG ulCookie = 0;
	ULONG ulXferMax = ulXferCount;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	
	ulXferCount = 0;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		
		if( !pControlItem->IsDefaultState() )
		{
				if(ulXferCount >= ulXferMax)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					pControlItem->GetItemState(pControlItemXfers[ulXferCount]);
					pControlItemXfers[ulXferCount++].ulModifiers = m_ulModifiers;
				}
		}
		hr = GetNext(&pvControlItem, ulCookie);
	}
	return hr;	
}
		
HRESULT CControlItemCollectionImpl::SetState
(
	ULONG ulXferCount,						// @parm [in\out] specifies length of array on entry
											// and items used on exit
	PCONTROL_ITEM_XFER pControlItemXfers,	// @parm [out] caller allocated buffer to hold packets
	PFNGETCONTROLITEM	GetControlFromPtr	// @parm [in] function to get CControlItem *
)
{
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	while(ulXferCount--)
	{
		//
		// It is legit, that someone may have a keyboard Xfer mixed up in the
		// array, in which case we need to dismiss it.  If someone further down
		// gets it, they will ASSERT.
		//
		if( NonGameDeviceXfer::IsKeyboardXfer(pControlItemXfers[ulXferCount]) )
		{
			continue;
		}
		pvControlItem = GetFromControlItemXfer( pControlItemXfers[ulXferCount]);
		if(NULL == pvControlItem) continue;
		m_ulModifiers |= pControlItemXfers[ulXferCount].ulModifiers;
		pControlItem = GetControlFromPtr(pvControlItem);
		pControlItem->SetModifiers(pControlItemXfers[ulXferCount].ulModifiers);
		pControlItem->SetItemState( pControlItemXfers[ulXferCount]);
	}
	return S_OK;	
}

void CControlItemCollectionImpl::SetStateOverlayMode(
			PFNGETCONTROLITEM	GetControlFromPtr,
			BOOLEAN fEnable
			)
{
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		pControlItem->SetStateOverlayMode(fEnable);
		hr = GetNext(&pvControlItem, ulCookie);
	}
}
			
/***********************************************************************************
**
**	HRESULT ControlItemDefaultFactory
**
**	@func	Factory for a default collection
**
**	@rdesc	S_OK if successful, S_FALSE if not supported, E_FAIL for any failure.
**
************************************************************************************/
HRESULT ControlItemDefaultFactory
(
	USHORT usType,									//@parm [in] Type of object to create
	const CONTROL_ITEM_DESC* cpControlItemDesc,		//@parm [in] Item descriptor data
	CControlItem				**ppControlItem		//@parm [out] CControlItem we created
)
{
	HRESULT hr = S_OK;
	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppControlItem = new WDM_NON_PAGED_POOL CAxesItem(cpControlItemDesc);
			break;
		case ControlItemConst::usDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPropDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CPropDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usWheel:
			*ppControlItem= new WDM_NON_PAGED_POOL CWheelItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPOV:
			*ppControlItem = new WDM_NON_PAGED_POOL CPOVItem(cpControlItemDesc);
			break;
		case ControlItemConst::usThrottle:
			*ppControlItem = new WDM_NON_PAGED_POOL CThrottleItem(cpControlItemDesc);
			break;
		case ControlItemConst::usRudder:
			*ppControlItem = new WDM_NON_PAGED_POOL CRudderItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPedal:
			*ppControlItem = new WDM_NON_PAGED_POOL CPedalItem(cpControlItemDesc);
			break;
		case ControlItemConst::usButton:
			*ppControlItem = new WDM_NON_PAGED_POOL CButtonsItem(cpControlItemDesc);
			break;
		case ControlItemConst::usZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CZoneIndicatorItem(cpControlItemDesc);
			break;
        case ControlItemConst::usForceMap:
			*ppControlItem = new WDM_NON_PAGED_POOL CForceMapItem(cpControlItemDesc);
            break;
        case ControlItemConst::usDualZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CDualZoneIndicatorItem(cpControlItemDesc);
            break;
		default:
			*ppControlItem = NULL;
			return S_FALSE;
	}
	if(!*ppControlItem)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitems.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_CONTROLITEM_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	ControlItems.cpp	|
*
*	Implementation of CControlItem and derivative member functions,
*	 and non-member help functions.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
**********************************************************************/

const LONG c_lM1X = 1;
const LONG c_lM1Y = 2;
const LONG c_lM2X = 2;
const LONG c_lM2Y = 1;


long SignExtend(long lVal, ULONG ulNumValidBits)
{
	ULONG ulMask = 1 << (ulNumValidBits-1);
	if( ulMask & lVal )
	{
		return (~(ulMask-1))|lVal;
	}
	else
	{
		return (ulMask-1)&lVal;
	}
}
long ClearSignExtension(long lVal, ULONG ulNumValidBits)
{
	ULONG ulMask = 1 << ulNumValidBits;
	return lVal&(ulMask-1);
}

void ControlItemsFuncs::Direction2XY(LONG& rlValX, LONG& rlValY, LONG lDirection, const CONTROL_ITEM_DESC& crControlItemDesc)
{
	// Check East
	if( (lDirection >= ControlItemConst::lNorthEast) && (lDirection <= ControlItemConst::lSouthEast) )
	{
		rlValX = crControlItemDesc.DPAD.pRangeTable->lMaxX;
	}
	//	Check West
	else if( (lDirection >= ControlItemConst::lSouthWest) && (lDirection <= ControlItemConst::lNorthWest) )
	{
		rlValX = crControlItemDesc.DPAD.pRangeTable->lMinX;
	}
	//	Otherwise Centered w.r.t East-West
	else
	{
		//If max - min is an odd number we cheat the center to the high side(i.e. add back the remainder)
		rlValX 	= crControlItemDesc.DPAD.pRangeTable->lCenterX;
	}
	// Check North (North cannot do range, because NorthWest is not contiguous
	if( 
		(lDirection == ControlItemConst::lNorthEast) || 
		(lDirection == ControlItemConst::lNorth) || 
		(lDirection == ControlItemConst::lNorthWest)
	)
	{
		rlValY = crControlItemDesc.DPAD.pRangeTable->lMinY;
	}
	//	Check South
	else if( (lDirection >= ControlItemConst::lSouthEast) && (lDirection <= ControlItemConst::lSouthWest) )
	{
		rlValY = crControlItemDesc.DPAD.pRangeTable->lMaxY;
	}
	// Otherwsie Centered w.r.t North-South
	else
	{
		//If max - min is an odd number we cheat the center to the high side (i.e. add back the remainder)
		rlValY = crControlItemDesc.DPAD.pRangeTable->lCenterY;
	}

}

void ControlItemsFuncs::XY2Direction(LONG lValX, LONG lValY, LONG& rlDirection, const CONTROL_ITEM_DESC& crControlItemDesc)
{
	const ULONG localNorth	= 0x01;
	const ULONG localSouth	= 0x02;
	const ULONG localEast	= 0x04;
	const ULONG localWest	= 0x08;

	// Check North - North equals minimum Y value
	rlDirection = 0;
	if( crControlItemDesc.DPAD.pRangeTable->lNorth >= lValY )
	{
		rlDirection += localNorth;
	}
	//Check South - South equals maximum Y value
	else if( crControlItemDesc.DPAD.pRangeTable->lSouth <= lValY )
	{
		rlDirection += localSouth;
	}
	// Check East - East equals maximum X value
	if( crControlItemDesc.DPAD.pRangeTable->lEast <= lValX )
	{
		rlDirection += localEast;
	}
	//Check West - West equals minimum X value
	else if( crControlItemDesc.DPAD.pRangeTable->lWest >= lValX )
	{
		rlDirection += localWest;
	}

	//We have built a uniue value for each direction, but it is not what we need
	//use lookup table to convert to what we need
	static LONG DirectionLookUp[] =
	{
		ControlItemConst::lCenter,		// 0 = Nothing
		ControlItemConst::lNorth,		// 1 = localNorth 
		ControlItemConst::lSouth,		// 2 = localSouth
		ControlItemConst::lCenter,		// 3 = Not Possible with above code
		ControlItemConst::lEast,		// 4 = localEast
		ControlItemConst::lNorthEast,	// 5 = localNorth + localEast
		ControlItemConst::lSouthEast,	// 6 = localSouth + localEast
		ControlItemConst::lCenter,		// 7 = Not Possible with above code
		ControlItemConst::lWest,		// 8 = localWest
		ControlItemConst::lNorthWest,	// 9 = localNorth + localWest
		ControlItemConst::lSouthWest	// 10 = localSouth + localWest
	};
	rlDirection = DirectionLookUp[rlDirection];
}

NTSTATUS CAxesItem::ReadFromReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
)
{
	NTSTATUS NtStatus;
	
	//
	//	Read X
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageX,
			reinterpret_cast<PULONG>(&m_ItemState.Axes.lValX),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	if( FAILED(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	// Sign extend it (only if there are negatives)
	if (m_cpControlItemDesc->Axes.pRangeTable->lMinX < 0)
	{
		m_ItemState.Axes.lValX = SignExtend(m_ItemState.Axes.lValX, m_cpControlItemDesc->usBitSize);
	}

	//
	//	Read Y
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageY,
			reinterpret_cast<PULONG>(&m_ItemState.Axes.lValY),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	// Sign extend it (only if there are negatives)
	if (m_cpControlItemDesc->Axes.pRangeTable->lMinY < 0)
	{
		m_ItemState.Axes.lValY = SignExtend(m_ItemState.Axes.lValY, m_cpControlItemDesc->usBitSize);
	}
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS CAxesItem::WriteToReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
) const
{
	NTSTATUS NtStatus;

	// Clear the sign extension before writing
	ULONG ulX, ulY;
	// Sign extend it (only if there are negatives)
	if (m_cpControlItemDesc->Axes.pRangeTable->lMinX < 0)
	{
		ulX = static_cast<ULONG>(ClearSignExtension(m_ItemState.Axes.lValX, m_cpControlItemDesc->usBitSize));
	}
	else
	{
		ulX = static_cast<ULONG>(m_ItemState.Axes.lValX);
	}

	if (m_cpControlItemDesc->Axes.pRangeTable->lMinY < 0)
	{
		ulY = static_cast<ULONG>(ClearSignExtension(m_ItemState.Axes.lValY, m_cpControlItemDesc->usBitSize));
	}
	else
	{
		ulY = static_cast<ULONG>(m_ItemState.Axes.lValY);
	}

	//
	//	Write X
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageX,
			ulX,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif
	
    if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//
	//	Write Y
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Axes.UsageY,
			ulY,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS CDPADItem::ReadFromReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
)
{
	NTSTATUS NtStatus;
	
	//
	//	Read X
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageX,
			reinterpret_cast<PULONG>(&m_ItemState.DPAD.lValX),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//Sign extend it
	m_ItemState.DPAD.lValX = SignExtend(m_ItemState.DPAD.lValX, m_cpControlItemDesc->usBitSize);

	//
	//	Read Y
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageY,
			reinterpret_cast<PULONG>(&m_ItemState.DPAD.lValY),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	//Sign extend it
	m_ItemState.DPAD.lValY = SignExtend(m_ItemState.DPAD.lValY, m_cpControlItemDesc->usBitSize);
	return NtStatus;
}

NTSTATUS CDPADItem::WriteToReport
(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
) const
{
	NTSTATUS NtStatus;
	// Clear the sign extension before writing
	ULONG ulX, ulY;
	ulX = static_cast<ULONG>(ClearSignExtension(m_ItemState.DPAD.lValX, m_cpControlItemDesc->usBitSize));
	ulY = static_cast<ULONG>(ClearSignExtension(m_ItemState.DPAD.lValY, m_cpControlItemDesc->usBitSize));
	//
	//	Write X
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageX,
			ulX,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif
    
    if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//
	//	Write Y
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->DPAD.UsageY,
			ulY,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS CPropDPADItem::ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
{
	NTSTATUS NtStatus;
	
	//
	//	Read X
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageX,
			reinterpret_cast<PULONG>(&m_ItemState.PropDPAD.lValX),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

    if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//Sign extend it
	m_ItemState.PropDPAD.lValX = SignExtend(m_ItemState.PropDPAD.lValX, m_cpControlItemDesc->usBitSize);

	//
	//	Read Y
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageY,
			reinterpret_cast<PULONG>(&m_ItemState.PropDPAD.lValY),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	//Sign extend it
	m_ItemState.PropDPAD.lValY = SignExtend(m_ItemState.PropDPAD.lValY, m_cpControlItemDesc->usBitSize);

	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;

}
NTSTATUS CPropDPADItem::WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
{
	NTSTATUS NtStatus;
	//Clear sign extension before writing
	ULONG ulX, ulY;
	ulX = static_cast<ULONG>(ClearSignExtension(m_ItemState.PropDPAD.lValX, m_cpControlItemDesc->usBitSize));
	ulY = static_cast<ULONG>(ClearSignExtension(m_ItemState.PropDPAD.lValY, m_cpControlItemDesc->usBitSize));
	//
	//	Write X
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageX,
			ulX,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	if( NT_ERROR(NtStatus) )
	{
		ASSERT( NT_SUCCESS(NtStatus) );
		return NtStatus;
	}
	//
	//	Write Y
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->PropDPAD.UsageY,
			ulY,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

BOOLEAN CPropDPADItem::GetModeSwitchFeaturePacket(BOOLEAN fDigital, UCHAR rguReport[2], PHIDP_PREPARSED_DATA pHidPreparsedData)
{
	if(m_fProgrammable)
	{
		PMODIFIER_ITEM_DESC pModifierDesc;
		ASSERT(m_cpControlItemDesc->pModifierDescTable->ulModifierCount > m_ucProgramModifierIndex);
		pModifierDesc = &m_cpControlItemDesc->pModifierDescTable->pModifierArray[m_ucProgramModifierIndex];
		
		rguReport[0] = pModifierDesc->ucReportId;
		rguReport[1] = NULL;
		NTSTATUS NtStatus;
		ULONG ulNumButtons = 1;
		if(fDigital)
		{
			NtStatus = HidP_SetButtons( 
					HidP_Feature,
					pModifierDesc->UsagePage,
					pModifierDesc->usLinkCollection,
					&pModifierDesc->Usage,
					&ulNumButtons,
					pHidPreparsedData,
					(char *)rguReport,
					2);
		}
		else
		{
			NtStatus = HidP_UnsetButtons( 
					HidP_Feature,
					pModifierDesc->UsagePage,
					pModifierDesc->usLinkCollection,
					&pModifierDesc->Usage,
					&ulNumButtons,
					pHidPreparsedData,
					(char *)rguReport,
					2);
			if(HIDP_STATUS_BUTTON_NOT_PRESSED == NtStatus)
			{
				NtStatus = HIDP_STATUS_SUCCESS;
			}
		}
		ASSERT(NT_SUCCESS(NtStatus));
		if( NT_ERROR(NtStatus) )
		{
			return FALSE;
		}
	}
	return m_fProgrammable;
}

/***********************************************************************************
**
**	CControlItemCollectionImpl::InitDigitalModeInfo
**
**	@mfunc	Initializes info regarding whether and how digital\proportional
**			information can be manipulated.
**
*************************************************************************************/
void CPropDPADItem::InitDigitalModeInfo()
{
	//Walk modifiers table looking for a proportional\digital mode switch
	//The first in the table should always be a bit in the input report
	//that indicates the state.  This is true of all proportional\digital
	//axes controls.  After that we look for a feature request that should
	//be at least writable.  If we find one, than we indicate that device programmable.
	PMODIFIER_DESC_TABLE pModifierDescTable = m_cpControlItemDesc->pModifierDescTable;
	PMODIFIER_ITEM_DESC pModifierItemDesc;
	ULONG ulModifierIndex;
	m_ucDigitalModifierBit = 0xff; //initialize to indicate none
	for(
		ulModifierIndex = pModifierDescTable->ulShiftButtonCount; //skip shift buttons
		ulModifierIndex < pModifierDescTable->ulModifierCount; //don't overun aray
		ulModifierIndex++
	)
	{
		//Get pointer to item desc for convienence
		pModifierItemDesc = &pModifierDescTable->pModifierArray[ulModifierIndex];
		if(
			(ControlItemConst::HID_VENDOR_PAGE == pModifierItemDesc->UsagePage) &&
			(ControlItemConst::ucReportTypeInput == pModifierItemDesc->ucReportType)
		)
		{
			if(ControlItemConst::HID_VENDOR_TILT_SENSOR == pModifierItemDesc->Usage)
			{
				m_ucDigitalModifierBit = static_cast<UCHAR>(ulModifierIndex);
				ulModifierIndex++;
				break;
			}
			if(ControlItemConst::HID_VENDOR_PROPDPAD_MODE == pModifierItemDesc->Usage)
			{
				m_ucDigitalModifierBit = static_cast<UCHAR>(ulModifierIndex);
				ulModifierIndex++;
				break;
			}
		}
	}
	m_fProgrammable = FALSE;
	m_ucProgramModifierIndex = 0xFF;
	//Now look for switching feature
	for(
		ulModifierIndex = 0;	//start at 0 index
		ulModifierIndex < pModifierDescTable->ulModifierCount; //don't overun aray
		ulModifierIndex++
	)
	{
		//Get pointer to item desc for convienence
		pModifierItemDesc = &pModifierDescTable->pModifierArray[ulModifierIndex];
		if(
			(ControlItemConst::HID_VENDOR_PAGE == pModifierItemDesc->UsagePage) &&
			(ControlItemConst::ucReportTypeFeature & pModifierItemDesc->ucReportType) &&
			(ControlItemConst::ucReportTypeWriteable & pModifierItemDesc->ucReportType) &&
			(ControlItemConst::HID_VENDOR_PROPDPAD_SWITCH == pModifierItemDesc->Usage)
		)
		{
			m_fProgrammable = TRUE;
			m_ucProgramModifierIndex = static_cast<UCHAR>(ulModifierIndex);
			break;
		}
	}
}

NTSTATUS CButtonsItem::ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
{
	NTSTATUS NtStatus;
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from 15 to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(15 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[15];
	
	ULONG ulNumUsages = static_cast<ULONG>(m_cpControlItemDesc->usReportCount);

	NtStatus = HidP_GetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNumUsages,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	ASSERT( NT_SUCCESS(NtStatus) );
	if( NT_SUCCESS(NtStatus) )
	{
		//
		// Start with all buttons up
		//
		m_ItemState.Button.ulButtonBitArray = 0x0;
		if(ulNumUsages)
		{
			m_ItemState.Button.usButtonNumber = pUsages[0];
		}
		else
		{
			m_ItemState.Button.usButtonNumber = 0;
		}

		//
		//	Now that we have button info fill in the state information
		//
		for(ULONG ulIndex = 0; ulIndex < ulNumUsages; ulIndex++)
		{
			//
			//	Check Range and set bit of down buttons in range
			//
			if(
				(pUsages[ulIndex] >= m_cpControlItemDesc->Buttons.UsageMin) &&
				(pUsages[ulIndex] <= m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				//
				//	Set Bit in array
				//
				m_ItemState.Button.ulButtonBitArray |=
					(1 << (pUsages[ulIndex]-m_cpControlItemDesc->Buttons.UsageMin));
				//
				//	Update lowest number
				//
				if( m_ItemState.Button.usButtonNumber > pUsages[ulIndex] )
				{
					m_ItemState.Button.usButtonNumber = pUsages[ulIndex];
				}

			} //end of check if in range
		} //end of loop over buttons
	} //end of check for success
	
	return NtStatus;
}

NTSTATUS CButtonsItem::WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
{
	NTSTATUS NtStatus;
	
	ULONG ulMaxUsages = 
		(m_cpControlItemDesc->Buttons.UsageMax -
		m_cpControlItemDesc->Buttons.UsageMin) + 1;

	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from 10 to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(10 >= ulMaxUsages && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[10];
		
	//
	//	Fill in array of usages
	//
	ULONG ulNextToFill=0;
	for(ULONG ulIndex = 0; ulIndex < ulMaxUsages; ulIndex++)
	{
		if( (1 << ulIndex) & m_ItemState.Button.ulButtonBitArray )
		{
			pUsages[ulNextToFill++] = static_cast<USAGE>(ulIndex + 
										m_cpControlItemDesc->Buttons.UsageMin);
		}
	}

	NtStatus = HidP_SetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNextToFill,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	ASSERT( NT_SUCCESS(NtStatus) );
	
	return NtStatus;

}

//------------------------------------------------------------------
//	Implementation of CZoneIndicatorItem
//------------------------------------------------------------------
const ULONG CZoneIndicatorItem::X_ZONE = 0x00000001;
const ULONG CZoneIndicatorItem::Y_ZONE = 0x00000002;
const ULONG CZoneIndicatorItem::Z_ZONE = 0x00000004;

//
//	Read\Write to Report
//
NTSTATUS CZoneIndicatorItem::ReadFromReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	)
{
	NTSTATUS NtStatus;
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value three was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from three to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(3 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[3];
	
	ULONG ulNumUsages = static_cast<ULONG>(m_cpControlItemDesc->usReportCount);

	NtStatus = HidP_GetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNumUsages,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

    ASSERT( NT_SUCCESS(NtStatus) );
	if( NT_SUCCESS(NtStatus) )
	{
		//
		// Start with no indicators set
		//
		m_ItemState.ZoneIndicators.ulZoneIndicatorBits = 0x0;
		
		//
		//	Now that we have button info fill in the state information
		//
		for(ULONG ulIndex = 0; ulIndex < ulNumUsages; ulIndex++)
		{
			//
			//	Set Bit in array
			//
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |=
				(1 << (pUsages[ulIndex]-m_cpControlItemDesc->ZoneIndicators.BaseIndicatorUsage));
		} //end of loop over buttons
	} //end of check for success
	
	return NtStatus;
}

NTSTATUS CZoneIndicatorItem::WriteToReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	) const
{
	NTSTATUS NtStatus;
	
	ULONG ulMaxUsages = m_cpControlItemDesc->usReportCount;

	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value three was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from three to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(3 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[3];
	
	//
	//	Fill in array of usages
	//
	ULONG ulNextToFill=0;
	for(ULONG ulIndex = 0; ulIndex < ulMaxUsages; ulIndex++)
	{
		if( (1 << ulIndex) & m_ItemState.ZoneIndicators.ulZoneIndicatorBits )
		{
			pUsages[ulNextToFill++] = static_cast<USAGE>(ulIndex +
										m_cpControlItemDesc->ZoneIndicators.BaseIndicatorUsage);
		}
	}

	NtStatus = HidP_SetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNextToFill,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	ASSERT( NT_SUCCESS(NtStatus) );
	

	return NtStatus;

}



// **************** Implementation of DualZoneIndicator Item ******************* //
void CDualZoneIndicatorItem::SetActiveZone(LONG lZone)
{
	ASSERT((lZone >= 0) && (lZone <= m_cpControlItemDesc->DualZoneIndicators.lNumberOfZones));

	if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[1] == 0)
	{
		ASSERT(m_cpControlItemDesc->DualZoneIndicators.lNumberOfZones == 2);
		
		if (lZone == 1)
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[0];
		}
		else if (lZone == 2)
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[0];
		}
		else
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
		}
		return;
	}

	m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
	m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[1];
	switch (lZone)
	{
		case 1:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[0];
		case 2:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[1];
			break;
		case 3:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[1];
		case 4:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[0];
			break;
		case 5:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[0];
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[1];
		case 6:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[1];
			break;
		case 7:
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMax[1];
		case 8:
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lMin[0];
			break;
	}
}

/*
USHORT g_FourByFourTileMaps[7] =
{
	0x0000,
	0x0011,
	0xFFFF,
	0x3377,
	0xFFC0,
	0xC000,
	0x3348
};

USHORT g_EightByEightTiles[16] =	// 4 Entries (4 bits each) - 4x4 array
{
	0x0000, 0x0103, 0x2222, 0x2222,
	0x0000, 0x1232, 0x2222, 0x2222,
	0x0103, 0x2222, 0x2245, 0x4500,
	0x1265, 0x4500, 0x0000, 0x0000
};

// Currently Fixed for 8 zones
LONG CDualZoneIndicatorItem::GetActiveZone()
{
	LONG lxReading = 0 - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterX;
	LONG lyReading = 0 - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterY;

	LONG lxHalfRange = m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lMaxX - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterX;
	LONG lyHalfRange = m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lMaxY - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterY;

	for (int n = 0; n < 2; n++)
	{
		if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n] == HID_USAGE_GENERIC_X)
		{
			lxReading += m_ItemState.DualZoneIndicators.rglVal[n];
		}
		else
		{
			lyReading += m_ItemState.DualZoneIndicators.rglVal[n];
		}
	}

	// Translate to +/+ quadrant
	LONG lxTranslation = lxReading - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterX;
	if (lxTranslation < 0)
	{
		lxTranslation = 0 - lxTranslation;
	}
	LONG lyTranslation = lyReading - m_cpControlItemDesc->DualZoneIndicators.pRangeTable->lCenterY;
	if (lyTranslation < 0)
	{
		lyTranslation = 0 - lyTranslation;
	}

	// What 32nd of the Quadrant am I in (512 << 5 fits fine in a ULONG)
	USHORT us32QuadrantX = USHORT(ULONG((ULONG(lxTranslation << 5) + lxHalfRange - 1)/lxHalfRange));
	USHORT us32QuadrantY = USHORT(ULONG((ULONG(lyTranslation << 5) + lyHalfRange - 1)/lxHalfRange));

	// What Eight of the Quadrant am I in?
	USHORT us8QuadrantX = us32QuadrantX >> 2;
	USHORT us8QuadrantY = us32QuadrantY >> 2;

	// What Quarter of the Quadrant am I in
	USHORT us4QuadrantX = us8QuadrantX >> 1;
	USHORT us4QuadrantY = us8QuadrantX >> 1;

	// Use the magic from above to find the pixel value
	USHORT usOctantValue = g_EightByEightTiles[us4QuadrantX + us8QuadrantY];	// x + 4*y
	USHORT usOctantNibble = (us8QuadrantX % 2) + ((us8QuadrantY % 2) << 1) * 4;
	USHORT usOctantNibbleValue = (usOctantValue & (0x0F << usOctantNibble)) >> usOctantNibble;
	USHORT usBit = g_FourByFourTileMaps[usOctantNibbleValue] & (1 << ((us32QuadrantX % 4) + ((us32QuadrantX % 4) << 2)));

	return usBit;
};
*/

inline BOOLEAN FirstSlopeGreater(LONG x1, LONG y1, LONG x2, LONG y2)
{
	return BOOLEAN((y1 * x2) > (y2 * x1));
}

inline BOOLEAN FirstSlopeLess(LONG x1, LONG y1, LONG x2, LONG y2)
{
	return BOOLEAN((y1 * x2) < (y2 * x1));
}

// Dansan's method (much simplier)
// Currently Fixed for 8 zones (or 2)
LONG CDualZoneIndicatorItem::GetActiveZone(SHORT sXDeadZone, SHORT sYDeadZone)
{
	// Get the two values (assume x/y or just x)
	LONG lxReading = m_ItemState.DualZoneIndicators.rglVal[0] - m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
	LONG lyReading = 0;
	if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[1] != 0)
	{	// Also flip Y about the axis
		lyReading = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[1] - m_ItemState.DualZoneIndicators.rglVal[1];
	}
	else	// Single axis
	{
		if (lxReading < -sXDeadZone)
		{
			return 1;
		}
		if (lxReading > sXDeadZone)
		{
			return 2;
		}
		return 0;
	}

	// Rule out the center
	if (lxReading < sXDeadZone)
	{
		if (lxReading > -sXDeadZone)
		{
			if (lyReading < sYDeadZone)
			{
				if (lyReading > -sYDeadZone)
				{
					return 0;
				}
			}
		}
	}

	// First find the quadrant (++0 +-1 --2 -+3)
	UCHAR ucQuadrant = 0;
	if (lxReading >= 0)
	{
		ucQuadrant = (lyReading >= 0) ?  0 : 1;
	}
	else
	{
		ucQuadrant = (lyReading < 0) ? 2 : 3;
	}

	// Determine the reading based on the quadrant
	switch (ucQuadrant)
	{
		case 0:	// Slope goes from infinity to 0 (sectors 2,3,4)
			if (FirstSlopeGreater(lxReading, lyReading, c_lM1X, c_lM1Y))
			{
				return 2;
			}
			if (FirstSlopeLess(lxReading, lyReading, c_lM2X, c_lM2Y))
			{
				return 4;
			}
			return 3;
		case 1: // Slope goes from 0 to -infinity (sectors 4,5,6)
			if (FirstSlopeGreater(lxReading, lyReading, c_lM2X, -c_lM2Y))
			{
				return 4;
			}
			if (FirstSlopeLess(lxReading, lyReading, c_lM1X, -c_lM1Y))
			{
				return 6;
			}
			return 5;
		case 2:	// Slope goes from infinity to 0 (sectors 6,7,8)
			if (FirstSlopeGreater(lxReading, lyReading, -c_lM1X, -c_lM1Y))
			{
				return 6;
			}
			if (FirstSlopeLess(lxReading, lyReading, -c_lM2X, -c_lM2Y))
			{
				return 8;
			}
			return 7;
		case 3:	// Slope goes from 0 to -infinity (sectors 8,1,2)
			if (FirstSlopeGreater(lxReading, lyReading, -c_lM2X, c_lM2Y))
			{
				return 8;
			}
			if (FirstSlopeLess(lxReading, lyReading, -c_lM1X, c_lM1Y))
			{
				return 2;
			}
			return 1;
		default:
			ASSERT(FALSE);
			return 0;
	}
}

LONG CDualZoneIndicatorItem::GetActiveZone()
{
	return GetActiveZone(	SHORT(m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lDeadZone[0]), 
							SHORT(m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lDeadZone[1])
	);
}

//
//	Read\Write to Report
//
NTSTATUS CDualZoneIndicatorItem::ReadFromReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	)
{
	NTSTATUS NtStatus;

	//
	//	Read Data
	//
	for (int n = 0; n < 2; n++)
	{
		// Read if the item is valid
		if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n] != 0)
		{
			NtStatus = HidP_GetUsageValue( 
					HidP_Input,
					m_cpControlItemDesc->UsagePage,
					m_cpControlItemDesc->usLinkCollection,
					m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n],
					reinterpret_cast<PULONG>(&m_ItemState.DualZoneIndicators.rglVal[n]),
					pHidPreparsedData,
					pcReport,
					lReportLength
					);

			if( FAILED(NtStatus) )
			{
				ASSERT( NT_SUCCESS(NtStatus) );
				return NtStatus;
			}

			//Sign extend it
			m_ItemState.DualZoneIndicators.rglVal[n] = SignExtend(m_ItemState.DualZoneIndicators.rglVal[n], m_cpControlItemDesc->usBitSize);
		}
		else
		{
			m_ItemState.DualZoneIndicators.rglVal[n] = 0;
		}
	}

	return NtStatus;
}

NTSTATUS CDualZoneIndicatorItem::WriteToReport(
	PHIDP_PREPARSED_DATA pHidPreparsedData,
	PCHAR pcReport,
	LONG lReportLength
	) const
{
	NTSTATUS NtStatus;

	for (int n = 0; n < 2; n++)
	{
		// Clear the sign extension before writing
		ULONG ulItem =
			static_cast<ULONG>(ClearSignExtension(m_ItemState.DualZoneIndicators.rglVal[n], m_cpControlItemDesc->usBitSize));

		//	Write Item if it is valid
		if (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n] != 0)
		{
			NtStatus = HidP_SetUsageValue( 
				HidP_Input,
				m_cpControlItemDesc->UsagePage,
				m_cpControlItemDesc->usLinkCollection,
				m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[n],
				ulItem,
				pHidPreparsedData,
				pcReport,
				lReportLength
				);
    
			if( NT_ERROR(NtStatus) )
			{
				ASSERT( NT_SUCCESS(NtStatus) );
				return NtStatus;
			}
		}
	}

	return NtStatus;
}


		
NTSTATUS CGenericItem::ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
{
	NTSTATUS NtStatus;
	//
	//	Read Value
	//
	NtStatus = HidP_GetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Generic.Usage,
			reinterpret_cast<PULONG>(&m_ItemState.Generic.lVal),
			pHidPreparsedData,
			pcReport,
			lReportLength
			);

#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif

	//Sign extend it
	if(m_cpControlItemDesc->Generic.lMin < 0)
	{
		m_ItemState.Generic.lVal = SignExtend(m_ItemState.Generic.lVal, m_cpControlItemDesc->usBitSize);
	}
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}



/***********************************************************************************
**
**	CPedalItem::InitPedalPresentInfo
**
**	@mfunc	Initializes info how to read if pedals are present.
**
*************************************************************************************/
void	CPedalItem::InitPedalPresentInfo()
{
	//Walk modifiers table looking for a Pedals present switch
	//The first in the table should always be a bit in the input report
	//that indicates the state.  This is true of all proportional\digital
	//axes controls.  After that we look for a feature request that should
	//be at least writable.  If we find one, than we indicate that device programmable.
	PMODIFIER_DESC_TABLE pModifierDescTable = m_cpControlItemDesc->pModifierDescTable;
	PMODIFIER_ITEM_DESC pModifierItemDesc;
	ULONG ulModifierIndex;
	m_ucPedalsPresentModifierBit = 0xff; //initialize to indicate none
	for(
		ulModifierIndex = pModifierDescTable->ulShiftButtonCount; //skip shift buttons
		ulModifierIndex < pModifierDescTable->ulModifierCount; //don't overun aray
		ulModifierIndex++
	)
	{
		//Get pointer to item desc for convienence
		pModifierItemDesc = &pModifierDescTable->pModifierArray[ulModifierIndex];
		if(
			(ControlItemConst::HID_VENDOR_PAGE == pModifierItemDesc->UsagePage) &&
			(ControlItemConst::ucReportTypeInput == pModifierItemDesc->ucReportType)
		)
		{
			if(ControlItemConst::HID_VENDOR_PEDALS_PRESENT == pModifierItemDesc->Usage)
			{
				m_ucPedalsPresentModifierBit = static_cast<UCHAR>(ulModifierIndex);
				ulModifierIndex++;
				break;
			}
		}
	}
}

NTSTATUS CGenericItem::WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
{
	NTSTATUS NtStatus;
	//Clear sign extension before writing
	ULONG ulVal;
	if(m_cpControlItemDesc->Generic.lMin < 0)
	{
		ulVal = static_cast<ULONG>(ClearSignExtension(m_ItemState.Generic.lVal, m_cpControlItemDesc->usBitSize));
	}
	else
	{
		ulVal = m_ItemState.Generic.lVal;
	}
	//
	//	Write Value
	//
	NtStatus = HidP_SetUsageValue( 
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			m_cpControlItemDesc->Generic.Usage,
			ulVal,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);
#if 0
    //Should be okay without this check (Driver should handle it now)
    if (HIDP_STATUS_INCOMPATIBLE_REPORT_ID == NtStatus)
    {
        // according to the ddk documentation 2.6.3
        // HIDP_STATUS_INCOMPATIBLE_REPORT_ID is a 'valid' error
        // we try again with the next packet
        // keep the data unchanged
        return HIDP_STATUS_SUCCESS;
    }
#endif
	
	ASSERT( NT_SUCCESS(NtStatus) );
	return NtStatus;
}

NTSTATUS ControlItemsFuncs::ReadModifiersFromReport
(
	  PMODIFIER_DESC_TABLE pModifierDescTable,
	  ULONG& rulModifiers,
	  PHIDP_PREPARSED_DATA pHidPPreparsedData,
	  PCHAR	pcReport,
	  LONG	lReportLength
)
{
    if (NULL == pModifierDescTable)
        return 42;
	CIC_DBG_RT_ENTRY_PRINT(("ControlItemsFuncs::ReadModifiersFromReport ModTable = 0x%0.8x\n", pModifierDescTable));
	NTSTATUS NtStatus = 0;
	rulModifiers = 0;

	//	A caveat here is that each entry must have usReportCount as large as the largest
	ULONG ulNumUsages = static_cast<ULONG>(pModifierDescTable->pModifierArray->usReportCount);
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all originally.  If this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from ten to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(15 >= pModifierDescTable->pModifierArray->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[15];
	
	USAGE UsageToGet;

	//	Loop over all the modifiers
	ULONG ulIndex=0;
	for(ulIndex = 0; ulIndex < pModifierDescTable->ulModifierCount; ulIndex++)
	{
		//
		//	Only try to read inputs
		//
		if( ControlItemConst::ucReportTypeInput != pModifierDescTable->pModifierArray[ulIndex].ucReportType)
		{ continue;	}

		UsageToGet = pModifierDescTable->pModifierArray[ulIndex].Usage;
		// The tilt sensor (legacy) is a special case, it has a digital value,
		// but is actually a two bit value and therefore we transform it.
		if( ControlItemConst::HID_VENDOR_TILT_SENSOR == UsageToGet)
		{
			ULONG ulValueToRead;
			NtStatus = HidP_GetUsageValue(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				UsageToGet,
				&ulValueToRead,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
			if( NT_ERROR(NtStatus) )
			{
				break;
			}
			//Set the bit appropriately
			if(ulValueToRead)
			{
				rulModifiers |= (1 << ulIndex);
			}
			else
			{
				rulModifiers &= ~(1 << ulIndex);
			}
			continue;
		}
				
		//Processing for all modifiers other than the Tilt Sensor continues here
		ulNumUsages = static_cast<ULONG>(pModifierDescTable->pModifierArray->usReportCount);
		NtStatus = HidP_GetButtons(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				pUsages,
				&ulNumUsages,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
		if( NT_ERROR(NtStatus) )
		{
			CIC_DBG_CRITICAL_PRINT(("HidP_GetButtons returned = 0x%0.8x\n", NtStatus));
			break;
		}

		//
		// Loop over usages returned
		//
		for(ULONG ulUsageIndex = 0; ulUsageIndex < ulNumUsages; ulUsageIndex++)
		{
			if( pUsages[ulUsageIndex] == UsageToGet )
			{
				rulModifiers |= (1 << ulIndex);
				break;
			}
		}
	}
	return NtStatus;
}

NTSTATUS ControlItemsFuncs::WriteModifiersToReport
(
	  PMODIFIER_DESC_TABLE pModifierDescTable,
	  ULONG ulModifiers,
	  PHIDP_PREPARSED_DATA pHidPPreparsedData,
	  PCHAR	pcReport,
	  LONG	lReportLength
)
{
    if (NULL == pModifierDescTable)
        return 42;
	NTSTATUS NtStatus = 0;
	
	ULONG ulNumUsages=1;
	USAGE UsageToSet;


	//
	//	Loop over all the modifiers
	//
	ULONG ulIndex=0;
	for(ulIndex = 0; ulIndex < pModifierDescTable->ulModifierCount; ulIndex++)
	{
		ulNumUsages = 1;
		UsageToSet = pModifierDescTable->pModifierArray[ulIndex].Usage;

		// The tilt sensor (legacy) is a special case, it has a digital value,
		// but is actually a two bit value and therefore we transform it.
		if( ControlItemConst::HID_VENDOR_TILT_SENSOR == UsageToSet)
		{
			ULONG ValueToWrite = (ulModifiers & (1 << ulIndex)) ? 2 : 0;
			NtStatus = HidP_SetUsageValue(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				UsageToSet,
				ValueToWrite,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
			if( NT_ERROR(NtStatus) )
			{
				break;
			}
			continue;
		}
		
		//	All modifiers beside the legacy tilt-sensor are one bit values
		if( ulModifiers	& (1 << ulIndex) )
		{
			//	Now set the binary value
			NtStatus = HidP_SetButtons(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				&UsageToSet,
				&ulNumUsages,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
		}
		else
		{
			//	Now set the binary value
			NtStatus = HidP_UnsetButtons(
				HidP_Input,
				pModifierDescTable->pModifierArray[ulIndex].UsagePage,
				pModifierDescTable->pModifierArray[ulIndex].usLinkCollection,
				&UsageToSet,
				&ulNumUsages,
				pHidPPreparsedData,
				pcReport,
				lReportLength
				);
		}
		if( NT_ERROR(NtStatus) )
		{
			break;
		}
	}
	return NtStatus;
}



NTSTATUS CForceMapItem::ReadFromReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
)
{
	return HIDP_STATUS_SUCCESS;
}

NTSTATUS CForceMapItem::WriteToReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
) const
{
	return HIDP_STATUS_SUCCESS;
}

NTSTATUS CProfileSelector::ReadFromReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
)
{
	NTSTATUS NtStatus;
	
	/*
	**	IMPORTANT!  the array pUsages was previously allocated dynamically and deleted at the end
	**	of this function.  This function get called frequently!  The value ten was big enough for
	**	all get originally, if this assertion is ever hit in the future, it is very important
	**	to increase the value in the next to lines of code from 15 to whatever it must be to avoid
	**	this assertion.
	**/
	ASSERT(15 >= m_cpControlItemDesc->usReportCount && "!!!!IF HIT, MUST READ NOTE IN CODE");
	USAGE pUsages[15];
	
	ULONG ulNumUsages = static_cast<ULONG>(m_cpControlItemDesc->usReportCount);

	NtStatus = HidP_GetButtons(
			HidP_Input,
			m_cpControlItemDesc->UsagePage,
			m_cpControlItemDesc->usLinkCollection,
			pUsages,
			&ulNumUsages,
			pHidPreparsedData,
			pcReport,
			lReportLength
			);


	ASSERT( NT_SUCCESS(NtStatus) );
	if( NT_SUCCESS(NtStatus) )
	{
		for (int usageIndex = 0; usageIndex < (long)ulNumUsages; usageIndex++)
		{
			if (pUsages[usageIndex] >= m_cpControlItemDesc->ProfileSelectors.UsageButtonMin)
			{
				if (pUsages[usageIndex] <= m_cpControlItemDesc->ProfileSelectors.UsageButtonMax)
				{
					m_ItemState.ProfileSelector.lVal = pUsages[usageIndex] - m_cpControlItemDesc->ProfileSelectors.UsageButtonMin;
					if (m_cpControlItemDesc->ProfileSelectors.ulFirstProfile < m_cpControlItemDesc->ProfileSelectors.ulLastProfile)
					{
						m_ItemState.ProfileSelector.lVal += m_cpControlItemDesc->ProfileSelectors.ulFirstProfile;
					}
					else
					{
						m_ItemState.ProfileSelector.lVal = m_cpControlItemDesc->ProfileSelectors.ulFirstProfile - m_ItemState.ProfileSelector.lVal;
					}
					return NtStatus;
				}
			}
		}
	}
	
	return NtStatus;
}

NTSTATUS CProfileSelector::WriteToReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
) const
{
	return HIDP_STATUS_SUCCESS;
}

NTSTATUS CButtonLED::ReadFromReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
)
{
	return HIDP_STATUS_SUCCESS;		// We really don't care what they look like
}

NTSTATUS CButtonLED::WriteToReport
(
    PHIDP_PREPARSED_DATA pHidPreparsedData,
    PCHAR pcReport,
    LONG lReportLength
) const
{
	return HIDP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\devicedescriptions.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_DEVICEDESCRIPTIONS_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	DeviceDescriptions.cpp	|
*
*	Tables for parsing HID on specific devices
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*
**********************************************************************/
using namespace ControlItemConst;

#define HID_USAGE_RESERVED (static_cast<USAGE>(0))

//
//	Freestyle Pro - Modifier Table
//
MODIFIER_ITEM_DESC	rgFSModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)10, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	6, ControlItemConst::ucReportTypeInput, 0},
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_TILT_SENSOR, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	0, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE FSModifierDescTable = { 2, 1, rgFSModifierItems};

//
//	Freestyle Pro - Axes range table
//
AXES_RANGE_TABLE FSAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//	Freestyle Pro - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgFSControlItems[] =
	{
		{1L, usButton,		HID_USAGE_PAGE_BUTTON,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,	
			1,	4,	&FSModifierDescTable, (USAGE)1,						(USAGE)4,				0L, 0L},
		{2L, usButton,		HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	6,	&FSModifierDescTable, (USAGE)5,						(USAGE)9,				0L,	0L},
		{3L, usPOV,			HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
			4,	1,	&FSModifierDescTable, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,		0L,	7L},
		{4L, usPropDPAD,	HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		    10,	1,	&FSModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y, (LONG)&FSAxesRangeTable, 0L},
		{5L, usThrottle,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			6,	1,	&FSModifierDescTable, HID_USAGE_GENERIC_SLIDER,		HID_USAGE_RESERVED,		-32L,	31L}
	};

//
//	Precision Pro - Modifier Table
//
MODIFIER_ITEM_DESC	rgPPModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)9, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	5, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE PPModifierDescTable = { 1, 1, rgPPModifierItems};

//
//	Precision Pro - Axes range table
//
AXES_RANGE_TABLE PPAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//	Precision Pro - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgPPControlItems[] =
	{
		{1L, usButton,		HID_USAGE_PAGE_BUTTON,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,	
			1,	4,	&PPModifierDescTable, (USAGE)1,						(USAGE)4,				0L,	0L},
		{2L, usButton,		HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	5,	&PPModifierDescTable, (USAGE)5,						(USAGE)8,				0L,	0L},
		{3L, usPOV,			HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
			4,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,		0L,	7L},
		{4L, usAxes,		HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y,	(LONG)&PPAxesRangeTable, 0L},
		{5L, usRudder,		HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		   6,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_RZ,			HID_USAGE_RESERVED,		-32L,	31L},
		{6L, usThrottle,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   7,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_SLIDER,		HID_USAGE_RESERVED,		-64L,	63L}
	};

//
//	Zorro - Modifier Table
//
MODIFIER_ITEM_DESC	rgZRModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)9, 0, HID_USAGE_GENERIC_GAMEPAD, HID_USAGE_PAGE_GENERIC,	9, ControlItemConst::ucReportTypeInput, 0},
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PROPDPAD_MODE, 0, HID_USAGE_GENERIC_GAMEPAD, HID_USAGE_PAGE_GENERIC,	1, ControlItemConst::ucReportTypeInput, 0},
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PROPDPAD_SWITCH, 2, 0, ControlItemConst::HID_VENDOR_PAGE, 1, ControlItemConst::ucReportTypeFeatureRW, 0}
	};

MODIFIER_DESC_TABLE ZRModifierDescTable = { 3, 1, rgZRModifierItems};

//
//	Zorro - Axes range table
//
AXES_RANGE_TABLE ZRAxesRangeTable = { -128L, 0L, 127L, -128L, 0L, 127L, -64L, 64L, -64L, 64L};  

//
//	Zorro - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgZRControlItems[] =
	{
		{1L, usButton,		HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_GAMEPAD,	HID_USAGE_PAGE_GENERIC,	
			1,	9,	&ZRModifierDescTable, (USAGE)1,						(USAGE)8,				0L,	0L},
		{2L, usPropDPAD,		HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		    8,	1,	&ZRModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y,	(LONG)&ZRAxesRangeTable, 0L}
	};


//
//	Zulu - Modifier Table
//
MODIFIER_ITEM_DESC	rgZLModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)9, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	9, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE ZLModifierDescTable = { 1, 1, rgZLModifierItems};

//
//	Zulu - Axes range table
//
AXES_RANGE_TABLE ZLAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//	Zulu - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgZLControlItems[] =
	{
		{1L, usButton,	HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	9,	&ZLModifierDescTable, (USAGE)1,	(USAGE)8,	0L,	0L},
		{2L, usPOV,		HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			4,	1,	&ZLModifierDescTable, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,		0L,	7L},
		{3L, usAxes,	HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&ZLModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y,	(LONG)&ZLAxesRangeTable, 0L},
		{4L, usZoneIndicator,	ControlItemConst::HID_VENDOR_PAGE,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			1,	2,	&ZLModifierDescTable, HID_VENDOR_ZONE_INDICATOR_X,	HID_USAGE_RESERVED,	0x00000003,	0L}
	};

//
//	ZepLite - Modifier Table
//
MODIFIER_ITEM_DESC	rgZPLModifierItems[] =
	{
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PEDALS_PRESENT, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, ControlItemConst::ucReportTypeInput, 0}
	};
MODIFIER_DESC_TABLE ZPLModifierDescTable = { 1, 0, rgZPLModifierItems};

//
//	ZepLite - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgZPLControlItems[] =
	{
		{1L, usButton,	HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	8,	&ZPLModifierDescTable, (USAGE)1,	(USAGE)8,	0L,	0L},
		{2L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			6,	1,	&ZPLModifierDescTable, HID_USAGE_GENERIC_Y,	HID_USAGE_RESERVED,		0L,	63L},
		{3L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		    6,	1,	&ZPLModifierDescTable, HID_USAGE_GENERIC_RZ,	HID_USAGE_RESERVED,		0L, 63L},
		{4L, usWheel,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&ZPLModifierDescTable, HID_USAGE_GENERIC_X,	HID_USAGE_RESERVED,		-512L, 511L},
	};

//
//	SparkyZep - Modifier Table
//
MODIFIER_ITEM_DESC	rgSZPModifierItems[] =
	{
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PEDALS_PRESENT, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, ControlItemConst::ucReportTypeInput, 1}
	};

MODIFIER_DESC_TABLE SZPModifierDescTable = { 1, 0, rgSZPModifierItems};

//
//	SparkyZep - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgSZPControlItems[] =
	{
		{1L, usButton,	HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	8,	&SZPModifierDescTable, (USAGE)1,	(USAGE)8,	0L,	0L},
		{2L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			6,	1,	&SZPModifierDescTable, HID_USAGE_GENERIC_Y,	HID_USAGE_RESERVED,		0L,	63L},
		{3L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		    6,	1,	&SZPModifierDescTable, HID_USAGE_GENERIC_RZ,	HID_USAGE_RESERVED,		0L, 63L},
		{4L, usWheel,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&SZPModifierDescTable, HID_USAGE_GENERIC_X,	HID_USAGE_RESERVED,		-512L, 511L},
        {5L, usForceMap,HID_USAGE_PAGE_GENERIC,     0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,
        0,   0,  &SZPModifierDescTable, 0, 0, 0L, 10000L}
	};

//
// Tilt 2.0 TT2
//

//
// Mothra MOH
//
//
//	Mothra - Axes range table
//
AXES_RANGE_TABLE MOHAxesRangeTable = { 0L, 128L, 255L, 0L, 128L, 255L, 64L, 192L, 64L, 192L};  

//
//  Mothra - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgMOHControlItems[] =
{
    {1L, usButton,   HID_USAGE_PAGE_BUTTON,  0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, 8, NULL, (USAGE)1,                    (USAGE)8,            0L,                       0L},
    {2L, usAxes,     HID_USAGE_PAGE_GENERIC, 1,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 8, 2, NULL, HID_USAGE_GENERIC_X,         HID_USAGE_GENERIC_Y, (LONG)&MOHAxesRangeTable, 0L},
    {3L, usRudder,   HID_USAGE_PAGE_GENERIC, 0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 8, 1, NULL, HID_USAGE_GENERIC_RZ,        HID_USAGE_RESERVED,  0L,                       255L},
    {4L, usPOV,      HID_USAGE_PAGE_GENERIC, 0,  HID_USAGE_GENERIC_POINTER,  HID_USAGE_PAGE_GENERIC, 4, 1, NULL, HID_USAGE_GENERIC_HATSWITCH, HID_USAGE_RESERVED,  0L,                       7L},
    {5L, usThrottle, HID_USAGE_PAGE_GENERIC, 0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 7, 1, NULL, HID_USAGE_GENERIC_SLIDER,    HID_USAGE_RESERVED,  0L,                       255L}
};

//
// Godzilla GOD
// Ungraciously ripped from Mothra!
// TODO: The force feedback stuff needs to be added by MCOILL
//
//	Godzilla - Axes range table
//
AXES_RANGE_TABLE GODAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//  Godzilla - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgGODControlItems[] =
{
    {1L, usButton,		HID_USAGE_PAGE_BUTTON,  0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, 8, NULL, (USAGE)1,                    (USAGE)8,            0L,                       0L},
    {2L, usAxes,		HID_USAGE_PAGE_GENERIC, 1, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 10, 2, NULL, HID_USAGE_GENERIC_X,         HID_USAGE_GENERIC_Y, (LONG)&GODAxesRangeTable, 0L},
    {3L, usRudder,		HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 6, 1, NULL, HID_USAGE_GENERIC_RZ,        HID_USAGE_RESERVED,  -32L, 31L},
    {4L, usPOV,			HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_POINTER,  HID_USAGE_PAGE_GENERIC, 4, 1, NULL, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,  0L, 7L},
    {5L, usThrottle,	HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 7, 1, NULL, HID_USAGE_GENERIC_SLIDER,    HID_USAGE_RESERVED,  0L, 127L},
	{6L, usForceMap,	HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 0, 0, NULL, 0, 0, 0L, 10000L }
};

//
//	Attila - Modifier Table ATT
//
// There are three shift buttons.
MODIFIER_ITEM_DESC	rgATTModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE) 9, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 15, ControlItemConst::ucReportTypeInput, 0},
		{ HID_USAGE_PAGE_BUTTON, (USAGE)10, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 15, ControlItemConst::ucReportTypeInput, 0},
		{ HID_USAGE_PAGE_BUTTON, (USAGE)11, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 15, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE ATTModifierDescTable = { 3, 3, rgATTModifierItems};

//
//	Attila - Axes range table
//
//  These may need changes.  I found this in the control panel calibration window.
DUALZONE_RANGE_TABLE	ATTXYZoneRangeTable = { { -512L, -512L }, { 0L, 0L }, { 511L, 511L}, {70L, 70L} };
DUALZONE_RANGE_TABLE	ATTRudderZoneRangeTable = { {-512L, 0L}, { 0L, 0L}, { 511L, 0L }, {70L, 0L} };

//
//  Attila - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgATTControlItems[] =
    {
        {1L, usButton,  HID_USAGE_PAGE_BUTTON,      0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 
            1,  15, &ATTModifierDescTable, (USAGE)1,    (USAGE)6,   0L, 0L},
        {2L, usButton,  HID_USAGE_PAGE_BUTTON,      0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 
            1,  15, NULL, (USAGE)7,    (USAGE)8,   0L, 0L},
        {3L, usButton,  HID_USAGE_PAGE_BUTTON,      0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 
            1,  15, NULL, (USAGE)0xC,    (USAGE)0xC,   0L, 0L},
		{4L, usDualZoneIndicator, HID_USAGE_PAGE_GENERIC, 1, HID_USAGE_GENERIC_POINTER, HID_USAGE_PAGE_GENERIC,
			10,  1, 0, HID_USAGE_GENERIC_X, HID_USAGE_GENERIC_Y, (LONG)&ATTXYZoneRangeTable, 8L},
  		{5L, usDualZoneIndicator, HID_USAGE_PAGE_GENERIC, 1, HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
			10, 1,	0, HID_USAGE_GENERIC_RZ, 0, (LONG)&ATTRudderZoneRangeTable, 2L},
  		{6L, usButtonLED,	HID_USAGE_PAGE_LED,	0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   2,	6,	&ATTModifierDescTable, USAGE(1), USAGE(ucReportTypeFeatureRW),
					ULONG((0 << 24) | (1 << 16) | (ControlItemConst::LED_DEFAULT_MODE_CORRESPOND_ON << 8) | (0)),
					0
		},
		{7L, usProfileSelectors, HID_USAGE_PAGE_BUTTON, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,
			1,	15,	NULL, (USAGE)0xD, (USAGE)0xF, (ULONG)2, (ULONG)0
		}
    };

#undef HID_USAGE_RESERVED

//
//	List of supported devices
//
//NEWDEVICE
DEVICE_CONTROLS_DESC DeviceControlsDescList[] =
	{
		{0x045E000E, 5, rgFSControlItems, &FSModifierDescTable},	//Freestyle Pro (USB)
		{0x045E0008, 6, rgPPControlItems, &PPModifierDescTable},	//Precision Pro (USB)
		{0x045E0026, 2, rgZRControlItems, &ZRModifierDescTable},	//Zorro
		{0x045E0028, 4, rgZLControlItems, &ZLModifierDescTable},	//Zulu
		{0x045E001A, 4, rgZPLControlItems, &ZPLModifierDescTable},	//Zep Lite
		{0x045E0034, 5, rgSZPControlItems, &SZPModifierDescTable},	//SparkyZep


//		{0x045Effff, 0, NULL, NULL},                                //Tilt2    Dev11 TT2
		{0x045E0038, 5, rgMOHControlItems, NULL},                   //Mothra   Dev12 MOH
		{0x045E001B, 6, rgGODControlItems, NULL},                   //Godzilla Dev13 GOD
		{0x045E0033, 7, rgATTControlItems, &ATTModifierDescTable},  //Attila   Dev14 ATT
		{0x00000000, 0, 0x00000000}
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitemcollection.h ===
#ifndef __ControlItemCollection_h__
#define __ControlItemCollection_h__
//@doc
/*********************************************************************
*
*	@module	ControlItemCollection.h	|
*
*	Declares the ControlItemCollection class and related classes
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	CControlItemCollection	|
*	The ControlItemCollection class is a templatized class used for
*	representing the controls on a device.  The depends on the client
*	using the class are non-trivial and therefore the following sections
*	should be read carefully.<nl>
*
*	@topic Items in ControlItemCollection |
*	<c CControlItem> is the base class for all of the items in the collection.
*	X and Y axes on a joystick like device use <c XAxesItem>, DPAD uses
*	<c CDPADItem>, a proportional DPAD (as on Zorro, and also use for Tilt)
*	uses <c CPropDPADItem>, Buttons use the class <c CButtonsItem>, Throttle
*	uses <c CThrottleItem>, a Rudder uses <c CRudderItem>, etc.  All of there
*	class are derived virtually from <c CControlITem>.<nl>
*
*	@topic Custom Base class for <c CControlItem> |
*	The class was designed so that a client may create a custom base class.
*	To declare a collection of <c CMyBaseClass>, derive it *virtually*
*	from CControlItem.  Then derive each of the classes created by your factory
*	from the appropriate control specific derivative and from <c CMyBaseClass>.
*	For example, <c CMyButtonsItems> would be derived from <c CButtonsItems> and
*	<c CMyBaseClass>.  When creating the collection specify <c CMyBaseClass> in
*	template specifier for CControlItemCollection.<nl>
*
*
*********************************************************************/

//
//	Warning 4250 notifies you that some virtual functions are inherited via
//	dominance (See a good C++ text on virtual base classes).  This warning
//	would be generated by client code if they use scheme described above
//	for a custom base class for controls.
//
#pragma warning( disable : 4250 )

#include "ListAsArray.h"
#include "ControlItems.h"

//
//	@struct DEVICE_CONTROLS_DESC | Describes a paritcular device in terms
//	of its VidPid, it CONTROL_ITEM_DESC and it MODIFIER_DESC_TABLE.
//
struct DEVICE_CONTROLS_DESC
{
	ULONG					ulVidPid;				//@field VID in high word and PID in low
	ULONG					ulControlItemCount;		//@field Number of control descriptors
	RAW_CONTROL_ITEM_DESC	*pControlItems;			//@field Array of control descriptors
	MODIFIER_DESC_TABLE		*pModifierDescTable;	//@field Pointer to modifier descriptor table
};
typedef DEVICE_CONTROLS_DESC *PDEVICE_CONTROLS_DESC;

//
// This table is assumed to be linked in.
//
extern DEVICE_CONTROLS_DESC DeviceControlsDescList[]; 

typedef	HRESULT (*PFNGENERICFACTORY)
		(
			USHORT						usType,
			const CONTROL_ITEM_DESC*	cpControlItemDesc,
			PVOID						*ppControlItem
		);

typedef CControlItem *(*PFNGETCONTROLITEM)(PVOID);

typedef void (*PFNGENERICDELETEFUNC)(PVOID pItem);

//
//	@class | Implementation of CControlItemCollection
//
class CControlItemCollectionImpl
{	
	public:
		//
		//	@method | CControlItemCollection | CControlItemCollection |
		//	C'tor, takes preparsed data and a factory to generate classes
		//
		CControlItemCollectionImpl():m_ulMaxXfers(0), m_ulModifiers(0){}

		HRESULT Init(
			ULONG			  ulVidPid,				//@parm [in] Vid in the high word, Pid in the low word
			PFNGENERICFACTORY pfnFactory,			//@parm	[in] pointer to function which acts
													//			on pFactoryHandle
			PFNGENERICDELETEFUNC pfnDeleteFunc		//@parm [in] delete function to used for control items
		);

		//
		//	@method | CControlItemCollection | GetFirst  |
		//	Returns next control item in collection. If *pulCookie=0 on entry , returns first object.
		//	@rdesc TRUE on success, FALSE if no more items in collection
		//
		HRESULT GetNext(
			PVOID *ppControlItem,	//@parm	[out] Next control item in collection
			ULONG& rulCookie		//@parm [in\out] Cookie to continue enumeration
			) const;
		//
		//	@method | CControlItemCollection | GetFromControlItemXfer |
		//	Given a ControlItemXfer gets the corresponding control item from the collection.
		//	@rdesc Pointer to item, or NULL if not found
		PVOID GetFromControlItemXfer(
			const CONTROL_ITEM_XFER& crControlItemXfer	//@parm [in] report selector to get object for
			);

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength,
			PFNGETCONTROLITEM	GetControlFromPt
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength,
			PFNGETCONTROLITEM	GetControlFromPtr
			) const;

		//
		//	Functions dealing with internal state
		//
		inline ULONG GetMaxXferRequired() const
		{
			return m_ulMaxXfers;
		}
		
		void SetDefaultState( 
			PFNGETCONTROLITEM	GetControlFromPtr
			);

		HRESULT GetState( 
			ULONG& ulXferCount,
			PCONTROL_ITEM_XFER pControlItemXfers,
			PFNGETCONTROLITEM	GetControlFromPtr
		);
		
		HRESULT SetState( 
			ULONG				ulXferCount,
			PCONTROL_ITEM_XFER	pControlItemXfers,
			PFNGETCONTROLITEM	GetControlFromPtr
		);

		void SetStateOverlayMode(
			PFNGETCONTROLITEM	GetControlFromPtr,
			BOOLEAN fEnable
			);
		
		
		inline ULONG GetModifiers() const
		{
			return m_ulModifiers;
		}
		
		inline void SetModifiers(ULONG ulModifiers)
		{
			m_ulModifiers = ulModifiers;
		}

	private:
		CListAsArray		m_ObjectList;
		ULONG				m_ulDeviceIndex;
		ULONG				m_ulModifiers;
		ULONG				m_ulMaxXfers;
};


//	@class	CControlItemCollection	|
//			An instance of this class contains a list of control item objects which represent
//			the controls on the device.  The numbers and types of objects depend
//			not only the configuration of the device (obtained through the VidPid and a lookup table
//			- passed in the c'tor), but also on the CControlItemFactory which pairs
//			each control item with an object.
//	@tcarg class | T | Custom base class for control items to store in collection.

template<class T>
class CControlItemCollection
{
	public:
		typedef HRESULT (*PFNFACTORY)
		(
			USHORT						usType,
			const CONTROL_ITEM_DESC*	cpControlItemDesc,
			T							**ppDeviceUsage							
		);

		typedef void (*PFNDELETEFUNC)(T *pItem);
		//
		//	@method | CControlItemCollection | CControlItemCollection |
		//	C'tor, takes a VidPid and a factory to generate classes
		//
		CControlItemCollection(
			ULONG			ulVidPid,			//@parm [in] Vid in the high word, Pid in the low word
			PFNFACTORY		pfnFactory,			//@parm [in] pointer to factory method for control item objects
			PFNDELETEFUNC	pfnDeleteFunc=NULL	//@parm [in] pointer to function for deleting the objects
		)
		{
			if(!pfnDeleteFunc)
			{
				pfnDeleteFunc = DefaultDeleteFunc;
			}
			//
			// Init implementation
			//
			collectionImpl.Init(
				ulVidPid,
				reinterpret_cast<PFNGENERICFACTORY>(pfnFactory),
				reinterpret_cast<PFNGENERICDELETEFUNC>(pfnDeleteFunc)
			);
		}

		//
		//	@method | CControlItemCollection | CControlItemCollection |
		//	C'tor, which takes no parameters, much call init before using!
		//
		CControlItemCollection() : collectionImpl() {};

		//
		//	@method | CControlItemCollection | Init |
		//	Must call after the default constructor, does the collection initialization
		//
		HRESULT Init(
			ULONG			ulVidPid,			//@parm [in] Vid in the high word, Pid in the low word
			PFNFACTORY		pfnFactory,			//@parm [in] pointer to factory method for control item objects
			PFNDELETEFUNC	pfnDeleteFunc=NULL	//@parm [in] pointer to function for deleting the objects
		)
		{
			if(!pfnDeleteFunc)
			{
				pfnDeleteFunc = DefaultDeleteFunc;
			}
			//
			// Init implementation
			//
			return collectionImpl.Init(
				ulVidPid,
				reinterpret_cast<PFNGENERICFACTORY>(pfnFactory),
				reinterpret_cast<PFNGENERICDELETEFUNC>(pfnDeleteFunc)
			);
		}


		//
		//	@method | CControlItemCollection | GetFirst  |
		//	Returns next control item in the collection. If *pulCookie=0 on entry , returns first object.
		//	@rdesc TRUE on success, FALSE if no more objects in collection
		//
		inline HRESULT GetNext(
			T **ppControlItem,	//@parm	[out] Next control item object in collection
			ULONG& rulCookie	//@parm [in\out] Cookie to continue enumeration
			) const
		{
			//
			//	Defer to implementation
			//
			return collectionImpl.GetNext( reinterpret_cast<PVOID *>(ppControlItem), rulCookie );
		}
	
		//
		//	@method | CControlItemCollection | GetFromControlItemXfer |
		//	Given a ControlItemXfer gets the corresponding control item object from the collection.
		//	@rdesc Pointer to Control Item, or NULL if not found.
		inline T *GetFromControlItemXfer(
			const CONTROL_ITEM_XFER& crControlItemXfer	//@parm [in] ControlItemXfer to get control item object for
		)
		{
			//
			//	Defer to implementation
			//
			return reinterpret_cast<T *>(collectionImpl.GetFromControlItemXfer(crControlItemXfer));
		};

		static CControlItem *GetControlFromPtr(PVOID pvItem)
		{
			return static_cast<CControlItem *>(reinterpret_cast<T *>(pvItem));
		}

		static void DefaultDeleteFunc(T *pItem)
		{
			delete pItem;
		}

		//
		//	Read\Write to Report
		//
		inline NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			)
		{
			return collectionImpl.ReadFromReport(
										pHidPPreparsedData,
										pcReport,
										lReportLength,
										&GetControlFromPtr
										);
		}
		inline NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const
		{
			return collectionImpl.WriteToReport(
										pHidPPreparsedData,
										pcReport,
										lReportLength,
										&GetControlFromPtr
										);
		}
		
		inline void SetDefaultState()
		{
			collectionImpl.SetDefaultState(&GetControlFromPtr);
		}

		inline ULONG GetMaxXferRequired() const
		{
			return collectionImpl.GetMaxXferRequired();
		}
		
		inline HRESULT GetState( ULONG& ulXferCount, PCONTROL_ITEM_XFER pControlItemXfers)
		{
				return collectionImpl.GetState(
										ulXferCount,
										pControlItemXfers,
										&GetControlFromPtr
										);
		}
		inline HRESULT SetState( ULONG& ulXferCount, PCONTROL_ITEM_XFER pControlItemXfers)
		{
				return collectionImpl.SetState(
										ulXferCount,
										pControlItemXfers,
										&GetControlFromPtr
										);
		}

		inline ULONG GetModifiers() const
		{
				return collectionImpl.GetModifiers();
		}
		
		inline void SetModifiers(ULONG ulModifiers)
		{
			collectionImpl.SetModifiers(ulModifiers);
		}
		
		inline void SetStateOverlayMode(BOOLEAN fEnable)
		{
			collectionImpl.SetStateOverlayMode(&GetControlFromPtr, fEnable);
		}
	private:
		CControlItemCollectionImpl collectionImpl;
};


HRESULT
ControlItemDefaultFactory
(
	USHORT usType,
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CControlItem			**ppControlItem
);

//
//	@class	Default collection where objects in collection have only the
//			the CControlItem class as their base classes.
//
class CControlItemDefaultCollection : public CControlItemCollection<CControlItem>
{
	public:
		CControlItemDefaultCollection(ULONG	ulVidPid)
		: CControlItemCollection<CControlItem>(ulVidPid, &ControlItemDefaultFactory)
		{}
};

#endif //__ControlItemCollection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitems.h ===
#ifndef __ControlItems_h__
#define __ControlItems_h__
//@doc
/**********************************************************************
*
*	@module	ControlItems.h	|
*
*	Declares basic structures for CControlItem and derived objects
*	that go in CControlItemCollections
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ControlItems	|
*	Control items represent a group of controls that share the same
*	HID UsagePage, Link-Collection, and are in a range of USAGES.
*
**********************************************************************/

namespace ControlItemConst
{
	//Device Item Types
    const USHORT usAxes              =  1;
    const USHORT usDPAD              =  2;
    const USHORT usPropDPAD          =  3;
    const USHORT usWheel             =  4;
    const USHORT usPOV               =  5;
    const USHORT usThrottle          =  6;
    const USHORT usRudder            =  7;
    const USHORT usPedal             =  8;
    const USHORT usButton            =  9;
    const USHORT usZoneIndicator     = 10;
    const USHORT usShiftedButton     = 11;
    const USHORT usForceMap          = 12;
	const USHORT usButtonLED         = 13;
    const USHORT usAxisToKeyMapModel = 14;
	const USHORT usProfileSelectors  = 15;
	const USHORT usDualZoneIndicator = 16;
	// To be used where there is more than one shift button
    // Reserve 255 of these: 0x101 Shift 1, 0x102 Shift 2, ..., 0x1ff Shift 255
    const USHORT usShiftedButtonN = 0x100;
    
	//DPAD and POV directions
	const LONG lCenter		= -1;
	const LONG lNorth		= 0;
	const LONG lNorthEast	= 1;
	const LONG lEast		= 2;
	const LONG lSouthEast	= 3;
	const LONG lSouth		= 4;
	const LONG lSouthWest	= 5;
	const LONG lWest		= 6;
	const LONG lNorthWest	= 7;

	//Report Types
	const UCHAR ucReportTypeReadable	= 0x80;
	const UCHAR ucReportTypeWriteable	= 0x40;
	const UCHAR ucReportTypeInput		= 0x01 | ucReportTypeReadable;
	const UCHAR ucReportTypeOutput		= 0x02 | ucReportTypeWriteable;
	const UCHAR ucReportTypeFeature		= 0x04;
	const UCHAR ucReportTypeFeatureRO	= ucReportTypeFeature | ucReportTypeReadable;
	const UCHAR ucReportTypeFeatureWO	= ucReportTypeFeature | ucReportTypeWriteable;
	const UCHAR ucReportTypeFeatureRW	= ucReportTypeFeature | ucReportTypeReadable | ucReportTypeWriteable;

	//Non-standard HID definitions
	const USHORT HID_VENDOR_PAGE			= 0xff01;
	const USHORT HID_VENDOR_TILT_SENSOR		= 0x0001; //legacy
	const USHORT HID_VENDOR_PROPDPAD_MODE	= 0x0030;
	const USHORT HID_VENDOR_PROPDPAD_SWITCH	= 0x0030;
	const USHORT HID_VENDOR_ZONE_INDICATOR_X= 0x0046;
	const USHORT HID_VENDOR_ZONE_INDICATOR_Y= 0x0047;
	const USHORT HID_VENDOR_ZONE_INDICATOR_Z= 0x0048;
	const USHORT HID_VENDOR_PEDALS_PRESENT	= 0x0049;

	// Behaviours of Button LEDS							-- Default Modes
	const UCHAR LED_DEFAULT_MODE_ON					= 0;	// On
	const UCHAR LED_DEFAULT_MODE_OFF				= 1;	// Off
	const UCHAR LED_DEFAULT_MODE_BLINK				= 2;	// Blinking
	const UCHAR LED_DEFAULT_MODE_CORRESPOND_ON		= 3;	// On if corresp. button has action (else off)
	const UCHAR LED_DEFAULT_MODE_CORRESPOND_OFF		= 4;	// Off if corresp. button has action (else on)
	const UCHAR LED_DEFAULT_MODE_BLINK_OFF			= 5;	// Blinking if c. button has action (else off)
	const UCHAR LED_DEFAULT_MODE_BLINK_ON			= 6;	// Blinking if c. button has action (else on)
};


#pragma pack(push ,foo, 1)
//
//	@struct MODIFIER_ITEM_DESC |
//		Contains all the data for reading a modifier button
//
struct MODIFIER_ITEM_DESC
{
	USAGE	UsagePage;			// @field Usage Page of Modifier Button
	USAGE	Usage;				// @field Usage of Modifier Button
	USHORT	usLinkCollection;	// @field Link Collection Modifier Button is in
	USAGE	LinkUsage;			// @field Usage of Link Collection Modifier Button is in
	USAGE	LinkUsagePage;		// @field Usage Page of Link Collection Modifier Button is in 
	USHORT	usReportCount;		// @field Report count of Buttons in same collection
	UCHAR	ucReportType;		// @field Report Type (Input\Feature(RO\WO\RW)\Output)
	UCHAR	ucReportId;			// @field Report ID for modifier
};
typedef MODIFIER_ITEM_DESC *PMODIFIER_ITEM_DESC;

struct MODIFIER_DESC_TABLE
{
	ULONG				ulModifierCount;
	ULONG				ulShiftButtonCount;
	PMODIFIER_ITEM_DESC pModifierArray;
};
typedef MODIFIER_DESC_TABLE *PMODIFIER_DESC_TABLE;

typedef struct tagAXES_RANGE_TABLE
{
	LONG	lMinX;						// @field Minimum value of X axis
	LONG	lCenterX;					// @field Center value for X
	LONG	lMaxX;						// @field Maximum value of X axis	
	LONG	lMinY;						// @field Minimum value of Y axis
	LONG	lCenterY;					// @field Center value for Y
	LONG	lMaxY;						// @field Maximum value of Y axis
	LONG	lNorth;						// @field Cut off for North
	LONG	lSouth;						// @field Cut off for South
	LONG	lWest;						// @field Cut off for West
	LONG	lEast;						// @field Cut off for East
} AXES_RANGE_TABLE, *PAXES_RANGE_TABLE;	

typedef struct tagDUALZONE_AXES_RANGE_TABLE
{
	LONG	lMin[2];					// @field Minimum value of each axis
	LONG	lCenter[2];					// @field Center value for each axis
	LONG	lMax[2];					// @field Maximum value of each axis	
	LONG	lDeadZone[2];				// @field DeadZone value of each axis
} DUALZONE_RANGE_TABLE, *PDUALZONE_RANGE_TABLE;	

//
// @struct 	RAW_CONTROL_ITEM_DESC |
//	This first raw structure is good for declaring tables, it contains all the information
//	an object needs to know about it self statically.
//
struct RAW_CONTROL_ITEM_DESC
{
	ULONG					ulItemIndex;		// @field Index of item in collection
	USHORT					usType;				// @field Type of item (type defined in ControlItemConst namespace)
	USAGE					UsagePage;			// @field Usage Page of Item
	USHORT					usLinkCollection;	// @field Link of collection item is in  
	USAGE					LinkUsage;			// @field Usage of link collection item is in
	USAGE					LinkUsagePage;		// @field Usage PAge of link collection item is in
	USHORT					usBitSize;			// @field Number of bits item occupies in report
	USHORT					usReportCount;		// @field Number of count of items if array (or buttons)
	PMODIFIER_DESC_TABLE	pModifierDescTable;	// @field Points to modifier descriptor table
	USAGE					SubItemUsage1;		// @field Interpretation depends on usType
	USAGE					SubItemUsage2;		// @field Interpretation depends on usType
	LONG					lSubItemMin1;		// @field Interpretation depends on usType
	LONG					lSubItemMax1;		// @field Interpretation depends on usType
};
typedef RAW_CONTROL_ITEM_DESC *PRAW_CONTROL_ITEM_DESC;

//
//	@struct CONTROL_ITEM_DESC |
//	Same as RawControlItemDesc but uses Union to give better names to the SubItem fields.
//
struct CONTROL_ITEM_DESC
{
	ULONG					ulItemIndex;		// @field Index of item in collection
	USHORT					usType;				// @field Type of item (type defined in ControlItemConst namespace)
	USAGE					UsagePage;			// @field Usage Page of Item
	USHORT					usLinkCollection;	// @field Link of collection item is in  
	USAGE					LinkUsage;			// @field Usage of link collection item is in
	USAGE					LinkUsagePage;		// @field Usage Page of link collection item is in
	USHORT					usBitSize;			// @field Number of bits item occupies in report
	USHORT					usReportCount;		// @field Number of count of items if array (or buttons)
	PMODIFIER_DESC_TABLE	pModifierDescTable;	// @field Points to modifier descriptor table
	union
	{
		struct
		{
			USAGE	UsageX;						// @field Usage of X axis
			USAGE	UsageY;						// @field Usage of Y axis
			PAXES_RANGE_TABLE pRangeTable;		// @field Pointer to range table
			LONG	lReserved2;					// @field Placeholder to match other structs in union
		}	Axes, DPAD, PropDPAD;
		struct
		{
			USAGE	Usage;						// @field Usage of item
			USHORT	usSubIndex;					// @field If item is in array(usReportCount > 1), holds the index
			LONG	lMin;						// @field Minimum value of usage
			LONG	lMax;						// @field Maximum value of usage
		}	Generic, Wheel, POV, Throttle, Rudder, Pedal;
		struct
		{
			USAGE	UsageMin;					// @field Usage of minimum buton
			USAGE	UsageMax;					// @field Usage of maximum buton
			LONG	lReserved1;					// @field Placeholder to match other structs in union
			LONG	lReserved2;					// @field Placeholder to match other structs in union
		}	Buttons;
		struct
		{
			USAGE	BaseIndicatorUsage;			// @field Base Usage for Zone indicators	
			USAGE	ReservedUsage;				// @field Placeholder to match other structs in union
			ULONG	ulAxesBitField;				// @field Bit field showing which indicators are available. X is bit 0
			LONG	lReserved1;					// @field Placeholder to match other structs in union
		} ZoneIndicators;
		struct
		{
			USAGE	rgUsageAxis[2];						// @field Usage of the two axis
			PDUALZONE_RANGE_TABLE pZoneRangeTable;		// @field Pointer to range table
			LONG	lNumberOfZones;						// @field How many zones does this divide into
		} DualZoneIndicators;
        struct
        {
            USAGE   Usage;                      // @field Usage
            UCHAR   bMapYToX;                   // @field Bool value 
            USHORT  usRTC;                      // @field return to center force (0-10000)
            USHORT  usGain;                     // @field gain for the device
            UCHAR   ucReserved;                 // @field Placeholder to match other structs in union
        } ForceMap;
		struct
		{
			USAGE	UsageMinLED;				// @field Usage of lowest LED (they better be consecutive)
			UCHAR	ucReportType;				// @field Report Type LED is in (Input\Feature(RO\WO\RW)\Output)
			UCHAR	ucReportId;					// @field Report ID for LED
			UCHAR	ucCorrespondingButtonItem;	// @field What button item does this refer to?
			UCHAR	ucDefaultMode;				// @field Defaullt LED behaviour (see ControlItemConst)
			UCHAR	ucReserved;					// @field Reserved (should be 0)
			ULONG	ulReserved;					// @field Reserved (should be 0)
		} ButtonLEDs;
		struct
		{
			USAGE	UsageButtonMin;				// @field Usage of first button for selector
			USAGE	UsageButtonMax;				// @field Usage of last button for selector
			ULONG	ulFirstProfile;				// @field What profile does the min select
			ULONG	ulLastProfile;				// @field What profile does the max select
		} ProfileSelectors;
	};
};
typedef CONTROL_ITEM_DESC *PCONTROL_ITEM_DESC;

//
//	@struct CONTROL_ITEM_XFER |
//	Used to transfer states between device item objects in different collections - input to outputs.
//	Used to represent in the state of items in Actions, and to idendity the trigger element for an action.
//
struct CONTROL_ITEM_XFER
{
	ULONG	ulItemIndex;
	union
	{
		struct
		{
			LONG	lValX;
			LONG	lValY;
		} Axes, DPAD, PropDPAD;
		struct
		{
			LONG	rglVal[2];
		} DualZoneIndicators;
		struct
		{
			LONG	lVal;
		} Generic, Wheel, POV, Throttle, Rudder, Pedal, ProfileSelector;
		struct
		{
			USHORT	usButtonNumber;
			ULONG	ulButtonBitArray;
		} Button;
		struct
		{
			ULONG ulZoneIndicatorBits;
		}	ZoneIndicators;
		struct
		{
			UCHAR ucModifierByte;
			UCHAR rgucKeysDown[6];
		} Keyboard;
        struct
        {
            ULONG  bMapYToX : 1;
            ULONG  usRTC : 15; 
            ULONG  usGain: 15;
            ULONG  Reserved : 1;
        } ForceMap;
		struct
		{
			ULONG dwValue;	// In milliseconds
		} Delay;
		struct
		{
			ULONG dwMouseButtons;	// Bit field
		} MouseButtons;
	};
	ULONG ulModifiers;

#ifdef __cplusplus
	bool operator==(const CONTROL_ITEM_XFER& rhs)
	{
		// Are we even the same type
		if (ulItemIndex != rhs.ulItemIndex)
		{
			return false;
		}
		return ((Axes.lValX == rhs.Axes.lValX) && (Axes.lValY == rhs.Axes.lValY) && (ulModifiers == rhs.ulModifiers));
	}

	bool operator!=(const CONTROL_ITEM_XFER& rhs)
	{
		if (ulItemIndex != rhs.ulItemIndex)
		{
			return true;
		}
		return ((Axes.lValX != rhs.Axes.lValX) || (Axes.lValY != rhs.Axes.lValY) || (ulModifiers != rhs.ulModifiers));
	}
#endif __cplusplus
};

typedef CONTROL_ITEM_XFER *PCONTROL_ITEM_XFER;

#pragma pack(pop , foo)

#ifdef COMPILE_FOR_WDM_KERNEL_MODE
	namespace NonGameDeviceXfer
	{
		const ULONG c_ulMaxXFerKeys = 6;

		// Non game device XFers
		const ULONG ulKeyboardIndex = 0xFFFF0000;
		const ULONG ulMouseIndex = 0xFFFF0001;
		const ULONG ulDelayIndex = 0xFFFF0002;

		// Checks for non device xfer types
		inline BOOLEAN IsKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulKeyboardIndex);
		}
		inline BOOLEAN IsMouseXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulMouseIndex);
		}
		inline BOOLEAN IsDelayXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulDelayIndex);
		}
	};
#else
	#include "ieevents.h"	// For IE_KEYEVENT definition
	namespace NonGameDeviceXfer
	{
		const ULONG c_ulMaxXFerKeys = 6;
		const ULONG ulKeyboardIndex = 0xFFFF0000;
		const ULONG ulMouseIndex = 0xFFFF0001;
		const ULONG ulDelayIndex = 0xFFFF0002;

		inline BOOLEAN IsKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulKeyboardIndex);
		}
		inline BOOLEAN IsMouseXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulMouseIndex);
		}
		inline BOOLEAN IsDelayXfer(const CONTROL_ITEM_XFER& crControlItemXfer)
		{
			return (crControlItemXfer.ulItemIndex == ulDelayIndex);
		}

		void MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, ULONG ulScanCodeCount, const USHORT* pusScanCodes);
		void MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, const IE_KEYEVENT& rKeyEvent);
		void AddScanCodeToXfer(CONTROL_ITEM_XFER& rControlItemXfer, WORD wScanCode);
		void ScanCodesFromKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer, ULONG& rulScanCodeCount, USHORT* pusScanCodes);
		void MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, const IE_KEYEVENT& rKeyEvent);

		void MakeDelayXfer(CONTROL_ITEM_XFER& rControlItemXfer, DWORD dwDelay);
	};
#endif

namespace ControlItemsFuncs
{
	void Direction2XY(
		LONG&	rlValX,
		LONG&	rlValY,
		LONG	lDirection,
		const CONTROL_ITEM_DESC& crControlItemDesc
		);
	void XY2Direction(
		LONG	lValX,
		LONG	lValY,
		LONG&	rlDirection,
		const CONTROL_ITEM_DESC& crControlItemDesc
		);
	NTSTATUS ReadModifiersFromReport(
		PMODIFIER_DESC_TABLE pModifierDescTable,
		ULONG& rulModifiers,
		PHIDP_PREPARSED_DATA pHidPPreparsedData,
		PCHAR	pcReport,
		LONG	lReportLength
		);
	NTSTATUS WriteModifiersToReport(
		PMODIFIER_DESC_TABLE pModifierDescTable,
		ULONG rulModifiers,
		PHIDP_PREPARSED_DATA pHidPPreparsedData,
		PCHAR	pcReport,
		LONG	lReportLength
		);

};


/******************************************************************************/
/**	@class CControlItem |
/**	Base class for containing information about a control or group of controls
/** on a device
/******************************************************************************/
class CControlItem
{
	public:
		
		/**********************************************************************
		**
		**	CControlItem::CControlItem
		**
		**	@cmember c'tor initialize with pointer to table describing item
		**
		***********************************************************************/
		CControlItem() : m_ulFirstDwordMask(0), m_ulSecondDwordMask(0)
		{
			memset(&m_ItemState, 0, sizeof(CONTROL_ITEM_XFER));
		}

		/**********************************************************************
		**
		**	virtual CControlItem::~CControlItem
		**
		**	@cmember c'tor initialize with pointer to table describing item
		**
		***********************************************************************/
		virtual ~CControlItem(){}
		
		/***********************************************************************
		**
		**	inline USHORT CControlItem::GetType() const
		**
		**	@cmember Returns the type of the item. See ControlItemConst namespace
		**			 for constants representing the type
		***********************************************************************/
		inline USHORT CControlItem::GetType() const
		{
			return m_cpControlItemDesc->usType;
		}


		/***********************************************************************
		**
		**	inline void CControlItem::GetItemState
		**
		**	@cmember Returns the item state in a CONTROL_ITEM_XFER packet
		**
		***********************************************************************/
		inline void GetItemState
		(
			CONTROL_ITEM_XFER& rControlItemXfer	// @parm [out] state of device
		) const
		{
			rControlItemXfer = m_ItemState;
		}		

		/************************************************************************
		**
		**	inline BOOLEAN CControlItem::SetItemState
		**
		**	@cmember	Set the control items state from a CONTROL_ITEM_XFER.
		**
		**	@rdesc	TRUE if successful,
		**			FALSE if CONTROL_ITEM_XFER is not intended for item.
		**
		*************************************************************************/
		inline BOOLEAN SetItemState
		(
			const CONTROL_ITEM_XFER& crControlItemXfer	// @parm [in] const reference to CONTROL_ITEM_XFER
		)
		{
			if(m_ItemState.ulItemIndex != crControlItemXfer.ulItemIndex)
			{
				return FALSE;
			}
			
			//Copy the data
			m_ItemState.Axes.lValX &= m_ulFirstDwordMask;
			m_ItemState.Axes.lValX |= crControlItemXfer.Axes.lValX;
			m_ItemState.Axes.lValY &= m_ulSecondDwordMask;
			m_ItemState.Axes.lValY |= crControlItemXfer.Axes.lValY;
			m_ItemState.ulModifiers = crControlItemXfer.ulModifiers;
				 
			return TRUE;
		}
		
		virtual void SetDefaultState()=0;

		virtual BOOLEAN IsDefaultState()
		{
			return FALSE;
		}

		/****************************************************************************
		**
		**	inline ULONG CControlItem::GetNumModifiers
		**
		**	@cmember Gets the number of modifiers available.
		**
		*****************************************************************************/
		inline ULONG GetNumModifiers() const
		{
			if (m_cpControlItemDesc->pModifierDescTable == NULL)
			{
				return 0;
			}
			return m_cpControlItemDesc->pModifierDescTable->ulModifierCount;
		}

		/****************************************************************************
		**
		**	inline ULONG CControlItem::GetNumShiftButtons
		**
		**	@cmember Gets the number of modifiers available.
		**
		*****************************************************************************/
		inline ULONG GetNumShiftButtons() const
		{
			if (m_cpControlItemDesc->pModifierDescTable == NULL)
			{
				return 0;
			}
			return m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount;
		}

		/****************************************************************************
		**
		**	inline ULONG CControlItem::GetShiftButtonUsage
		**
		**	@cmember Gets the usage (bit array index) of the specified shift button
		**
		*****************************************************************************/
		inline USHORT GetShiftButtonUsage
		(
			USHORT uShiftButtonIndex	// @parm [in] Zero-based index of shift button
		) const
		{
			if ((m_cpControlItemDesc->pModifierDescTable == NULL) || (uShiftButtonIndex >= m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount))
			{
				return 0;
			}

			return m_cpControlItemDesc->pModifierDescTable->pModifierArray[uShiftButtonIndex].Usage;
		}
			
		/*****************************************************************************
		**
		**	inline void CControlItem::GetModifiers(ULONG& rulModifiers)
		**
		**	@cmember	Gets modifier bit array of item state.
		**
		******************************************************************************/
		inline void GetModifiers
		(
			ULONG& rulModifiers	// @parm [out] Bit Array showing state of modifiers
		) const
		{
			rulModifiers = m_ItemState.ulModifiers;
		}

		/*****************************************************************************
		**
		**	inline void CControlItem::GetShiftButtons(ULONG& rulShiftButtons)
		**
		**	@cmember	Gets Shift buttons from the modifier bit array of item state.
		**
		******************************************************************************/
		inline void GetShiftButtons
		(
			ULONG& rulShiftButtons	// @parm [out] Bit Array showing state of modifiers
		) const
		{
			if (m_cpControlItemDesc->pModifierDescTable == NULL)
			{
				rulShiftButtons = 0;
			}
			else
			{
				ULONG ulMask =  (1 << m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount)-1;
				rulShiftButtons = m_ItemState.ulModifiers & ulMask;
			}
			return;
		}


		/*****************************************************************************
		**
		**	inline void CControlItem::SetModifiers(ULONG ulModifiers)
		**
		**	@cmember	Set state modifier flags from bit array
		**
		******************************************************************************/
		inline void SetModifiers
		(
			ULONG ulModifiers	// @parm [in] Bit array showing state of modifiers
		)
		{
			m_ItemState.ulModifiers = ulModifiers;
		}

		/*****************************************************************************
		**
		**	inline void CControlItem::SetShiftButtons(ULONG ulShiftButtons)
		**
		**	@cmember	Gets Shift buttons from the modifier bit array of item state.
		**
		******************************************************************************/
		inline void SetShiftButtons
		(
			ULONG ulShiftButtons	// @parm [out] Bit Array showing state of modifiers
		)
		{
			if (m_cpControlItemDesc->pModifierDescTable != NULL)
			{
				ULONG ulMask =  (1 << m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount)-1;
				m_ItemState.ulModifiers = (ulShiftButtons & ulMask) | (m_ItemState.ulModifiers & ~ulMask);
			}
			return;
		}

		//
		//	Read\Write to Report
		//
		virtual NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA,
			PCHAR,
			LONG
			)
		{
			//
			//	Should always be overridden
			//
			ASSERT(FALSE);
			return E_FAIL;
		}
		virtual NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA,
			PCHAR,
			LONG
			) const
		{
			//
			//	Should always be overridden
			//
			ASSERT(FALSE);
			return E_FAIL;
		}

		virtual void SetStateOverlayMode(BOOLEAN){}
		
	protected:

		//@cmember Pointer to entry in table describing item
		const CONTROL_ITEM_DESC *m_cpControlItemDesc;	
		
		//
		//	State of item
		//
		//@cmember State of item
		CONTROL_ITEM_XFER m_ItemState;	
		//@cmember Oring mask for overlay flag
		ULONG	m_ulFirstDwordMask;
		ULONG	m_ulSecondDwordMask;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CControlItem& operator =(const CControlItem& rControlItem);
};

/******************************************************************************/
/**	@class CAxesItem |
/**	Derived from CControlItem represents Axes of device
******************************************************************************/
class CAxesItem : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CAxesItem::CAxesItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	c'tor initializes does nothing
		**
		*************************************************************************************/
		CAxesItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.Axes.lValX = m_cpControlItemDesc->Axes.pRangeTable->lCenterX;
			m_ItemState.Axes.lValY= m_cpControlItemDesc->Axes.pRangeTable->lCenterY	;
			m_ItemState.ulModifiers = 0;
		}
		
		virtual BOOLEAN IsDefaultState()
		{
			if(
					m_ItemState.Axes.lValX == m_cpControlItemDesc->Axes.pRangeTable->lCenterX &&
					m_ItemState.Axes.lValY == m_cpControlItemDesc->Axes.pRangeTable->lCenterY
			){
				return TRUE;
			}
			return FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CAxesItem::SetXY(ULONG lValX, ULONG lValY)
		**
		**	@cmember	Sets the X and Y states of the axes
		**
		*************************************************************************************/
		inline void SetXY
		(
			LONG lValX,	// @parm [in] Position of X axis
			LONG lValY	// @parm [in] Position of Y axis
		)
		{
			m_ItemState.Axes.lValX = lValX;
			m_ItemState.Axes.lValY = lValY;
		}

		/***********************************************************************************
		**
		**	inline void CAxesItem::GetXY(ULONG& rlValX, ULONG& rlValY) const
		**
		**	@cmember	Get the X and Y states of the device
		**
		*************************************************************************************/
		inline void GetXY
		(
			LONG& rlValX,	// @parm [out] X value of axis
			LONG& rlValY	// @parm [out] Y value of axis 
		) const
		{
			rlValX = m_ItemState.Axes.lValX;
			rlValY = m_ItemState.Axes.lValY;
		}

		/***********************************************************************************
		**
		**	inline void CAxesItem::GetXYRange(LONG& rlMinX,	LONG& rlMaxX, LONG& rlMinY,	LONG& rlMaxY) const
		**
		**	@cmember	Get the minimum and maximum values for X and Y
		**
		*************************************************************************************/
		inline void GetXYRange
		(
			LONG& rlMinX,	// @parm [out] Minimum value X can attain
			LONG& rlMaxX,	// @parm [out] Maximum value X can attain
			LONG& rlMinY,	// @parm [out] Minimum value Y can attain
			LONG& rlMaxY	// @parm [out] Maximum value Y can attain
		) const
		{
			rlMinX = m_cpControlItemDesc->Axes.pRangeTable->lMinX;
			rlMaxX = m_cpControlItemDesc->Axes.pRangeTable->lMaxX;
			rlMinY = m_cpControlItemDesc->Axes.pRangeTable->lMinY;
			rlMaxY = m_cpControlItemDesc->Axes.pRangeTable->lMaxY;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:

		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CAxesItem& operator =(const CAxesItem& rAxesItem);
};


/******************************************************************************/
/**	@class CDPADItem |
/**	Derived from CControlItem represents DPAD of device
******************************************************************************/
class CDPADItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CDPADItem::CDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	c'tor initializes DPAD to center
		**
		*************************************************************************************/
		CDPADItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.DPAD.lValX = m_cpControlItemDesc->DPAD.pRangeTable->lCenterX;
			m_ItemState.DPAD.lValY= m_cpControlItemDesc->DPAD.pRangeTable->lCenterY;
			m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			LONG lDirection;
			ControlItemsFuncs::XY2Direction
			(
				m_ItemState.DPAD.lValX,
				m_ItemState.DPAD.lValY,
				lDirection, 
				*m_cpControlItemDesc
			);
			if(ControlItemConst::lCenter == lDirection)
			{
				return TRUE;
			}
			return FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CDPADItem::SetDirection(LONG lDirection)
		**
		**	@cmember	Sets Direction of Item
		**
		*************************************************************************************/
		inline void SetDirection
		(
			LONG lDirection	// @parm [in] Direction to set
		)
		{
			ControlItemsFuncs::Direction2XY
			(
				m_ItemState.DPAD.lValX,
				m_ItemState.DPAD.lValY,
				lDirection, 
				*m_cpControlItemDesc
			);
		}

		/***********************************************************************************
		**
		**	inline void CDPADItem::GetDirection(LONG& rlDirection)
		**
		**	@cmember	Get Direction of DPAD item
		**
		*************************************************************************************/
		inline void GetDirection
		(
			LONG& rlDirection	// @parm [out] Direction of DPAD item
		) const
		{
			ControlItemsFuncs::XY2Direction
			(
				m_ItemState.DPAD.lValX,
				m_ItemState.DPAD.lValY,
				rlDirection, 
				*m_cpControlItemDesc
			);
		}
		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;

	private:
		
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CDPADItem& operator =(const CDPADItem& rDPADItem);

};

/******************************************************************************/
/**	@class CPropDPADItem |
/**	Derived from CControlItem represents DPAD of device
******************************************************************************/
class CPropDPADItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CDPADItem::CPropDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	c'tor initializes PropDPAD to center
		**
		*************************************************************************************/
		CPropDPADItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			//Get PropDPAD switch Info
			InitDigitalModeInfo();

			SetDefaultState();
		}
		
		virtual void SetDefaultState()
		{
			m_ItemState.PropDPAD.lValX = m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterX;
			m_ItemState.PropDPAD.lValY= m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterY	;
			m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			if(IsDigitalMode())
			{
				LONG lDirection;
				ControlItemsFuncs::XY2Direction
				(
					m_ItemState.PropDPAD.lValX,
					m_ItemState.PropDPAD.lValY,
					lDirection, 
					*m_cpControlItemDesc
				);
				if(ControlItemConst::lCenter == lDirection)
				{
					return TRUE;
				}
			}
			else
			{
				if(
					m_ItemState.PropDPAD.lValX == m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterX &&
					m_ItemState.PropDPAD.lValY == m_cpControlItemDesc->PropDPAD.pRangeTable->lCenterY
				)	return TRUE;
			}

			return FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetDigitalMode()
		**
		**	@cmember	Sets the packet to indicate digital mode
		**
		*************************************************************************************/
		inline void CPropDPADItem::SetDigitalMode()
		{
			m_ItemState.ulModifiers |= (1 << m_ucDigitalModifierBit);
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetProportionalMode()
		**
		**	@cmember	Sets the packet to indicate proportional mode
		**
		*************************************************************************************/
		inline void CPropDPADItem::SetProportionalMode()
		{
			m_ItemState.ulModifiers &= ~(1 << m_ucDigitalModifierBit);
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CPropDPADItem::IsDigitalMode()
		**
		**	@cmember Determines if th internal state is digital or proportional
		**	@rdesc TRUE if in digital mode, false if in proportional mode
		**
		*************************************************************************************/
		inline BOOLEAN CPropDPADItem::IsDigitalMode()
		{
			return (m_ItemState.ulModifiers & (1 << m_ucDigitalModifierBit)) ? TRUE : FALSE;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetXY(ULONG lValX, ULONG lValY)
		**
		**	@cmember	Sets the X and Y states of the axes
		**
		*************************************************************************************/
		inline void SetXY
		(
			LONG lValX,	// @parm [in] Position of X axis
			LONG lValY	// @parm [in] Position of Y axis
		)
		{
			m_ItemState.PropDPAD.lValX = lValX;
			m_ItemState.PropDPAD.lValY = lValY;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetXY(ULONG& rlValX, ULONG& rlValY)
		**
		**	@cmember	Get the X and Y states of the device
		**
		*************************************************************************************/
		inline void GetXY
		(
			LONG& rlValX,	// @parm [out] X value of axis
			LONG& rlValY	// @parm [out] Y value of axis 
		) const
		{
			rlValX = m_ItemState.PropDPAD.lValX;
			rlValY = m_ItemState.PropDPAD.lValY;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetXYRange(LONG& rlMinX,	LONG& rlMaxX, LONG& rlMinY,	LONG& rlMaxY) const
		**
		**	@cmember	Get the minimum and maximum values for X and Y
		**
		*************************************************************************************/
		inline void GetXYRange
		(
			LONG& rlMinX,	// @parm [out] Minimum value X can attain
			LONG& rlMaxX,	// @parm [out] Maximum value X can attain
			LONG& rlMinY,	// @parm [out] Minimum value Y can attain
			LONG& rlMaxY	// @parm [out] Maximum value Y can attain
		) const
		{
			rlMinX = m_cpControlItemDesc->PropDPAD.pRangeTable->lMinX;
			rlMaxX = m_cpControlItemDesc->PropDPAD.pRangeTable->lMaxX;
			rlMinY = m_cpControlItemDesc->PropDPAD.pRangeTable->lMinY;
			rlMaxY = m_cpControlItemDesc->PropDPAD.pRangeTable->lMaxY;
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::SetDirection(LONG lDirection)
		**
		**	@cmember	Sets Direction of Item
		**
		*************************************************************************************/
		inline void SetDirection
		(
			LONG lDirection	// @parm [in] Direction to set
		)
		{
			ControlItemsFuncs::Direction2XY
			(
				m_ItemState.PropDPAD.lValX,
				m_ItemState.PropDPAD.lValY,
				lDirection, 
				*m_cpControlItemDesc
			);
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetDirection(LONG& rlDirection)
		**
		**	@cmember	Get Direction of PropDPAD item
		**
		*************************************************************************************/
		inline void GetDirection
		(
			LONG& rlDirection	// @parm [out] Direction of PropDPAD item
		) const
		{
			ControlItemsFuncs::XY2Direction
			(
				m_ItemState.PropDPAD.lValX,
				m_ItemState.PropDPAD.lValY,
				rlDirection, 
				*m_cpControlItemDesc
			);
		}

	 	//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;

		
		//	Init Digital Mode Info
		void InitDigitalModeInfo();
		BOOLEAN GetModeSwitchFeaturePacket(BOOLEAN fDigital, UCHAR rguReport[2], PHIDP_PREPARSED_DATA pHidPreparsedData);
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CPropDPADItem& operator =(const CPropDPADItem& rPropDPADItem);
		UCHAR	m_ucDigitalModifierBit;	//Bit in ulModifiers that identifies the State of the switch
	protected:
		BOOLEAN	m_fProgrammable;		//Means that SetFeature/GetFeature can be used
		UCHAR	m_ucProgramModifierIndex; //Index in Modifier table that describes feature for setting mode
};

/******************************************************************************/
/**	@class CButtonsItem |
/**	Derived from CControlItem represents group of buttons on device
******************************************************************************/
class CButtonsItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CButtonsItem::CButtonsItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes all buttons up
		**
		*************************************************************************************/
		CButtonsItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.Button.usButtonNumber = 0;
			m_ItemState.Button.ulButtonBitArray = 0x00000000;
			m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			if(!m_ItemState.Button.usButtonNumber && !m_ItemState.Button.ulButtonBitArray)
			{
				return TRUE;
			}
			return FALSE;
		}
		/***********************************************************************************
		**
		**	inline USHORT	CButtonsItem::GetButtonMin()
		**
		**	@cmember	Gets the minimum button number
		**
		**	@rdesc	Number of the minimum button
		**
		*************************************************************************************/
		inline USHORT GetButtonMin() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->Buttons.UsageMin); 
		}

		/***********************************************************************************
		**
		**	inline USHORT CButtonsItem::GetButtonMax()
		**
		**	@cmember	Gets the maximum button number
		**
		**	@rdesc	Number of the maximum button
		**
		*************************************************************************************/
		inline USHORT GetButtonMax() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->Buttons.UsageMax);
		}

		/***********************************************************************************
		**
		**	inline void CButtonsItem::GetButtons(USHORT usButtonNum, ULONG ulButtonBitArray)
		**
		**	@cmember	Returns the Button Number and BitArray - these are really independent
		**			a client may use either field.  As an Action trigger the button number
		**			is used, as part of an Action Event the bit-array is used
		**			Reading from a packet sets the bitarray and the button number as the lowest
		**			button pressed.  The Bitarray is biased by the minimum usage.
		**			Writing to a report uses the BitArray and ignores the button number.
		**
		*************************************************************************************/
		inline void GetButtons
		(
			USHORT& rusButtonNumber,	// @parm [out] Button number that is down
			ULONG& rulButtonBitArray		// @parm [out] BitArray of Buttons that are down
		) const
		{
			rusButtonNumber		= m_ItemState.Button.usButtonNumber;
			rulButtonBitArray	= m_ItemState.Button.ulButtonBitArray;
		}

		inline BOOLEAN IsButtonDown(USHORT usButtonNumber) const
		{
			//
			// Range check DEBUG assert and return FALSE
			//
			if( 
				(usButtonNumber < m_cpControlItemDesc->Buttons.UsageMin) ||
				(usButtonNumber > m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				ASSERT(FALSE);
				return FALSE;
			}

			//
			//	Return state
			//
			USHORT usBitPos =  usButtonNumber - m_cpControlItemDesc->Buttons.UsageMin;
			return (m_ItemState.Button.ulButtonBitArray & (1 << usBitPos)) ? TRUE : FALSE;
		}

		inline NTSTATUS SetButton(USHORT usButtonNumber)
		{
			//
			// Range check DEBUG assert and return FALSE
			//
			if( 
				(usButtonNumber < m_cpControlItemDesc->Buttons.UsageMin) ||
				(usButtonNumber > m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				return E_INVALIDARG;
			}
			USHORT usBitPos =  usButtonNumber - m_cpControlItemDesc->Buttons.UsageMin;
			m_ItemState.Button.ulButtonBitArray |= (1 << usBitPos);
			m_ItemState.Button.usButtonNumber = usButtonNumber;
			return S_OK;
		}

		inline NTSTATUS ClearButton(USHORT usButtonNumber)
		{
			//
			// Range check DEBUG assert and return FALSE
			//
			if( 
				(usButtonNumber < m_cpControlItemDesc->Buttons.UsageMin) ||
				(usButtonNumber > m_cpControlItemDesc->Buttons.UsageMax)
			)
			{
				return E_INVALIDARG;
			}
			USHORT usBitPos =  usButtonNumber - m_cpControlItemDesc->Buttons.UsageMin;
			m_ItemState.Button.ulButtonBitArray &= ~(1 << usBitPos);
			return S_OK;
		}
		/***********************************************************************************
		**
		**	inline void CButtonsItem::SetButtons(USHORT usButtonNum, ULONG ulButtonBitArray)
		**
		**	@cmember	Set the Button Number and BitArray - these are really independent
		**			a client may use either field.  As an Action trigger the button number
		**			is used, as part of an Action Event the bit-array is used
		**			Reading from a report sets the bitarray and the button number as the lowest
		**			button pressed.  The Bitarray is biased by the minimum usage.
		**			Writing to a report uses the BitArray and ignores the button number.
		**
		*************************************************************************************/
		inline void SetButtons
		(
			USHORT usButtonNumber,	// @parm [in] Button number that is down
			ULONG ulButtonBitArray	// @parm [in] BitArray of Buttons that are down
		)
		{
			m_ItemState.Button.usButtonNumber = usButtonNumber;
			m_ItemState.Button.ulButtonBitArray = ulButtonBitArray;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
		virtual void SetStateOverlayMode(BOOLEAN fEnable)
		{
			if(fEnable)
			{
				m_ulFirstDwordMask = 0xFFFF0000;
				m_ulSecondDwordMask = 0x0000FFFF;
			}
			else
			{
				m_ulFirstDwordMask = 0;
				m_ulSecondDwordMask = 0;
			}
			return;
		}
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CButtonsItem& operator =(const CButtonsItem& rButtonsItem);
};

/******************************************************************************/
/**	@class CGenericItem |
/**	Derived from CControlItem represents generic control on device -
/** base class for POV, Throttle, Wheel, Pedals, etc.
******************************************************************************/

class CGenericItem  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CGenericItem::CGenericItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember	default c'tor
		**
		*************************************************************************************/
		CGenericItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		
		}

		virtual void SetDefaultState()
		{
				m_ItemState.Generic.lVal = m_cpControlItemDesc->Generic.lMin;
				m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			if(m_ItemState.Generic.lVal == m_cpControlItemDesc->Generic.lMin)
			{
				return TRUE;
			}
			return FALSE;
		}
		/***********************************************************************************
		**
		**	inline void CGenericItem::GetValue(LONG& rlVal)
		**
		**	@cmember	Gets value of item
		**
		*************************************************************************************/
		inline void GetValue
		(
			LONG& rlVal	// @parm [out] Value of control item
		) const
		{
			rlVal = m_ItemState.Generic.lVal;	
		}

		/***********************************************************************************
		**
		**	inline void CGenericItem::SetValue(LONG& rlVal)
		**
		**	@cmember	Sets value of item
		**
		*************************************************************************************/
		inline void SetValue
		(
			LONG lVal // @parm [in] Value of control item
		)
		{
			m_ItemState.Generic.lVal = lVal;	
		}

		/***********************************************************************************
		**
		**	inline void CPropDPADItem::GetRange(LONG& rlMin, LONG& rlMax) const
		**
		**	@cmember	Get the minimum and maximum values
		**
		*************************************************************************************/
		inline void GetRange
		(
			LONG& rlMin,	// @parm [out] Minimum value
			LONG& rlMax		// @parm [out] Maximum value
		) const
		{
			rlMin = m_cpControlItemDesc->Generic.lMin;
			rlMax = m_cpControlItemDesc->Generic.lMax;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CGenericItem& operator =(const CGenericItem& rGenericItem);
};

/******************************************************************************/
/**	@class CPOVItem |
/**	Derived from CGenericItem represents POV control on device
******************************************************************************/
class CPOVItem : public CGenericItem
{
	public:
		CPOVItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc){}


		virtual void SetDefaultState()
		{
				m_ItemState.Generic.lVal = -1;
		}
		virtual BOOLEAN IsDefaultState()
		{
			//POV is centered if not within range, which is the default
			LONG lMin, lMax;
			GetRange(lMin, lMax);
			if(m_ItemState.Generic.lVal >  lMax || m_ItemState.Generic.lVal < lMin)
			{
				return TRUE;
			}
			return FALSE;
		}
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CPOVItem& operator =(const CPOVItem& rPOVItem);
};

/******************************************************************************/
/**	@class CThrottleItem |
/**	Derived from CGenericItem represents Throttle control on device
******************************************************************************/
class CThrottleItem : public CGenericItem
{
	public:
		CThrottleItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc){}

	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CThrottleItem& operator =(const CThrottleItem& rThrottleItem);
};

/******************************************************************************/
/**	@class CRudderItem |
/**	Derived from CGenericItem represents rudder control on device
******************************************************************************/
class CRudderItem : public CGenericItem
{
	public:
		CRudderItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc){}

	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CRudderItem& operator =(const CRudderItem& rRudderItem);
};

/******************************************************************************/
/**	@class CWheelItem |
/**	Derived from CGenericItem represents Wheel control on device
******************************************************************************/
class CWheelItem : public CGenericItem
{
	public:
		CWheelItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc)
		{
			SetDefaultState();
		}
			
		virtual void SetDefaultState()
		{
				LONG lCenter = (m_cpControlItemDesc->Generic.lMin + m_cpControlItemDesc->Generic.lMax)/2;
				m_ItemState.Generic.lVal = lCenter;
				m_ItemState.ulModifiers = 0;
		}

		virtual BOOLEAN IsDefaultState()
		{
			LONG lCenter = (m_cpControlItemDesc->Generic.lMin + m_cpControlItemDesc->Generic.lMax)/2;
			if(m_ItemState.Generic.lVal == lCenter)
			{
				return TRUE;
			}
			return FALSE;
		}

	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CWheelItem& operator =(const CWheelItem& rWheelItem);
};

/******************************************************************************/
/**	@class CPedalItem |
/**	Derived from CGenericItem represents Pedal control on device
******************************************************************************/
class CPedalItem : public CGenericItem
{
	public:
		CPedalItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		)	: CGenericItem(cpControlItemDesc), m_ucPedalsPresentModifierBit(0xFF)
		{
			//Setup m_ucPedalsPresentModifierBit
			InitPedalPresentInfo();
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			if (IsYAxis())
			{
				m_ItemState.Generic.lVal = m_cpControlItemDesc->Generic.lMax;
			}
			else
			{
				m_ItemState.Generic.lVal = (m_cpControlItemDesc->Generic.lMax + m_cpControlItemDesc->Generic.lMin)/2;
			}
			m_ItemState.ulModifiers = 1 << m_ucPedalsPresentModifierBit;
		}

		virtual BOOLEAN IsDefaultState()
		{
			long int lDefault;
			if (IsYAxis())
			{
				lDefault = m_cpControlItemDesc->Generic.lMax;
			}
			else
			{
				lDefault = (m_cpControlItemDesc->Generic.lMax + m_cpControlItemDesc->Generic.lMin)/2;
			}

			if(m_ItemState.Generic.lVal == lDefault)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		void InitPedalPresentInfo();
		inline BOOLEAN ArePedalsRemovable()
		{
			return (0xFF == m_ucPedalsPresentModifierBit) ? FALSE : TRUE;
		}
		inline BOOLEAN ArePedalsPresent()
		{
			return (m_ItemState.ulModifiers & (1 << m_ucPedalsPresentModifierBit)) ? TRUE : FALSE;
		}
		inline BOOLEAN IsYAxis()
		{
			return (HID_USAGE_GENERIC_Y == m_cpControlItemDesc->Pedal.Usage) ? TRUE : FALSE;
		}
		inline BOOLEAN IsRZAxis()
		{
			return (HID_USAGE_GENERIC_RZ == m_cpControlItemDesc->Pedal.Usage) ? TRUE : FALSE;
		}
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CPedalItem& operator =(const CPedalItem& rPedalItem);
		UCHAR	m_ucPedalsPresentModifierBit;
};

/******************************************************************************/
/**	@class CZoneIndicatorItem |
/**	A zone indicator is a binary hid usage that indicates that an axis
/** on the hardware has moved into a particular zone.
******************************************************************************/
class CZoneIndicatorItem : public virtual CControlItem
{
	public:
		
		/***********************************************************************************
		**
		**	CZoneIndicatorItem::CZoneIndicatorItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes all buttons up
		**
		*************************************************************************************/
		CZoneIndicatorItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits = 0x00000000;
			m_ItemState.ulModifiers = 0;
		}
		virtual BOOLEAN IsDefaultState()
		{
			if(!m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			return FALSE;
		}
		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::HasXIndicator() const
		**
		**	@cmember	If this zone indicator group has X returns true, otherwise false
		**
		*************************************************************************************/
		inline BOOLEAN HasXIndicator() const
		{
			if( CZoneIndicatorItem::X_ZONE & m_cpControlItemDesc->ZoneIndicators.ulAxesBitField)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::HasYIndicator() const
		**
		**	@cmember	If this zone indicator group has Y returns true, otherwise false
		**
		*************************************************************************************/
		inline BOOLEAN HasYIndicator() const
		{
			if( CZoneIndicatorItem::Y_ZONE & m_cpControlItemDesc->ZoneIndicators.ulAxesBitField)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::HasZIndicator() const
		**
		**	@cmember	If this zone indicator group has Z returns true, otherwise false
		**
		*************************************************************************************/
		inline BOOLEAN HasZIndicator() const
		{
			if( CZoneIndicatorItem::Z_ZONE & m_cpControlItemDesc->ZoneIndicators.ulAxesBitField)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::GetXIndicator() const
		**
		**	@cmember	If the pointer is in the X zone returns true
		**
		*************************************************************************************/
		inline BOOLEAN GetXIndicator() const
		{
			ASSERT(HasXIndicator());
			if( CZoneIndicatorItem::X_ZONE & m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::GetYIndicator() const
		**
		**	@cmember	If the pointer is in the Y zone returns true
		**
		*************************************************************************************/
		inline BOOLEAN GetYIndicator() const
		{
			ASSERT(HasYIndicator());
			if( CZoneIndicatorItem::Y_ZONE & m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::GetZIndicator() const
		**
		**	@cmember	If the pointer is in the Z zone returns true
		**
		*************************************************************************************/
		inline BOOLEAN GetZIndicator() const
		{
			ASSERT(HasZIndicator());
			if( CZoneIndicatorItem::Z_ZONE & m_ItemState.ZoneIndicators.ulZoneIndicatorBits)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::SetXIndicator()
		**
		**	@cmember	Sets to indicate X is in the zone
		**
		*************************************************************************************/
		inline void SetXIndicator()
		{
			ASSERT(HasXIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |= CZoneIndicatorItem::X_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::SetYIndicator()
		**
		**	@cmember	Sets to indicate Y is in the zone
		**
		*************************************************************************************/
		inline void SetYIndicator()
		{
			ASSERT(HasYIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |= CZoneIndicatorItem::Y_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::SetZIndicator()
		**
		**	@cmember	Sets to indicate Z is in the zone
		**
		*************************************************************************************/
		inline void SetZIndicator()
		{
			ASSERT(HasZIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits |= CZoneIndicatorItem::Z_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::ClearXIndicator()
		**
		**	@cmember	Sets to indicate X is not in the zone
		**
		*************************************************************************************/
		inline void ClearXIndicator()
		{
			ASSERT(HasXIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits &= ~CZoneIndicatorItem::X_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::ClearYIndicator()
		**
		**	@cmember	Sets to indicate Y is not in the zone
		**
		*************************************************************************************/
		inline void ClearYIndicator()
		{
			ASSERT(HasYIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits &= ~CZoneIndicatorItem::Y_ZONE;
		}

		/***********************************************************************************
		**
		**	inline BOOLEAN CZoneIndicatorItem::ClearZIndicator()
		**
		**	@cmember	Sets to indicate Z is not in the zone
		**
		*************************************************************************************/
		inline void ClearZIndicator()
		{
			ASSERT(HasZIndicator());
			m_ItemState.ZoneIndicators.ulZoneIndicatorBits &= ~CZoneIndicatorItem::Z_ZONE;
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CZoneIndicatorItem& operator =(const CZoneIndicatorItem& rZoneIndicatorItem);

	public:
		static const ULONG X_ZONE;
		static const ULONG Y_ZONE;
		static const ULONG Z_ZONE;
};

/******************************************************************************/
/**	@class CDualZoneIndicatorItem |
/**	A dual zone indicator is an item that indicate movement into a particular section
/** of a two axis plane.
******************************************************************************/
class CDualZoneIndicatorItem : public virtual CControlItem
{
	public:
		/***********************************************************************************
		**
		**	CDualZoneIndicatorItem::CDualZoneIndicatorItem(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes item to default state (center)
		**
		*************************************************************************************/
		CDualZoneIndicatorItem
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;

			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[0];
			m_ItemState.DualZoneIndicators.rglVal[1] = m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[1];
			m_ItemState.ulModifiers = 0;

		}
		virtual BOOLEAN IsDefaultState()
		{
			for (int n = 0; n < 2; n++)
			{
				if (m_ItemState.DualZoneIndicators.rglVal[n] != m_cpControlItemDesc->DualZoneIndicators.pZoneRangeTable->lCenter[n])
				{
					return FALSE;
				}
			}
			return TRUE;
		}

		void SetActiveZone(LONG lZone);
		void SetActiveZone(LONG posOne, LONG posTwo)
		{
			m_ItemState.DualZoneIndicators.rglVal[0] = posOne;
			m_ItemState.DualZoneIndicators.rglVal[1] = posTwo;
		}

		LONG GetActiveZone();
		LONG GetActiveZone(SHORT sXDeadZone, SHORT sYDeadZone);

        LONG GetNumZones ()
        {
            return m_cpControlItemDesc->DualZoneIndicators.lNumberOfZones;
        }

		BOOLEAN IsXYIndicator()
		{
			return BOOLEAN(m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[0] == HID_USAGE_GENERIC_X);
		}

		BOOLEAN IsRzIndicator()
		{
			return (m_cpControlItemDesc->DualZoneIndicators.rgUsageAxis[0] == HID_USAGE_GENERIC_RZ);
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		CDualZoneIndicatorItem& operator =(const CDualZoneIndicatorItem& rDualZoneIndicatorItem);
};


/******************************************************************************/
/**	@class CForceMapItem |
/**	Derived from CGenericItem represents the Wheel force feedback control on device
******************************************************************************/
class CForceMapItem : public CGenericItem
{
    public:
        CForceMapItem
            (
            const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
            )	: CGenericItem(cpControlItemDesc)
        {
            SetDefaultState();
        }
    
        virtual void SetDefaultState()
        {
            m_ItemState.ForceMap.bMapYToX = m_cpControlItemDesc->ForceMap.bMapYToX;
            m_ItemState.ForceMap.usRTC    = m_cpControlItemDesc->ForceMap.usRTC;
            m_ItemState.ForceMap.usGain   = m_cpControlItemDesc->ForceMap.usGain;
            m_ItemState.ulModifiers = 0;
        }
    
        virtual BOOLEAN IsDefaultState()
        {
            if (m_ItemState.ForceMap.bMapYToX == m_cpControlItemDesc->ForceMap.bMapYToX  &&
                m_ItemState.ForceMap.usRTC    == m_cpControlItemDesc->ForceMap.usRTC     &&
                m_ItemState.ForceMap.usGain   == m_cpControlItemDesc->ForceMap.usGain)
            {
                return TRUE;
            }
            return FALSE;
        }
        
        void SetMapYtoX (BOOLEAN a_bMapYToX)
        {
            m_ItemState.ForceMap.bMapYToX = a_bMapYToX ? 0x1 : 0x0;
        }
        
        void SetRTC  (USHORT a_usRTC)
        {
            m_ItemState.ForceMap.usRTC    = a_usRTC & 0x7fff;
        }

        void SetGain (USHORT a_usGain)
        {
            m_ItemState.ForceMap.usGain   = a_usGain & 0x7fff;
        }

        BOOLEAN GetMapYToX ()
        {
            return m_ItemState.ForceMap.bMapYToX;
        }
        
        USHORT GetRTC  ()
        {
            return m_ItemState.ForceMap.usRTC;
        }

        USHORT GetGain ()
        {
            return m_ItemState.ForceMap.usGain;
        }
        
		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;

    private:
        //
        //	Dissallow use of assignment operator. (Do not define - it will cause a link error if
        //	anyone tries to use it.
        //
        CForceMapItem& operator =(const CForceMapItem& rWheelItem);
};

/******************************************************************************/
/**	@class CProfileSelector |
/**	Derived from CControlItem represents group of buttons on profile selector buttons
******************************************************************************/
class CProfileSelector  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CProfileSelector::CProfileSelector(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes selector to 0
		**
		*************************************************************************************/
		CProfileSelector
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			m_ItemState.ProfileSelector.lVal = m_cpControlItemDesc->ProfileSelectors.ulFirstProfile;
		}

		virtual BOOLEAN IsDefaultState()
		{
			return FALSE; // there is no such thing
		}

		inline void GetSelectedProfile
		(
			UCHAR& rucSelectedProfile		// @parm [out] Current selected profile (Slider Location)
		) const
		{
			rucSelectedProfile = UCHAR(m_ItemState.ProfileSelector.lVal);
		}

		inline void SetSelectedProfile
		(
			UCHAR ucSelectedProfile		// @parm [out] Current selected profile (Slider Location)
		)
		{
			m_ItemState.ProfileSelector.lVal = ucSelectedProfile;
		}

		/***********************************************************************************
		**
		**	inline USHORT	CProfileSelectorsItem::GetProfileSelectorMin()
		**
		**	@cmember	Gets the minimum button number for profile selector
		**
		**	@rdesc	Number of the minimum button
		**
		*************************************************************************************/
		inline USHORT GetProfileSelectorMin() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->ProfileSelectors.UsageButtonMin); 
		}

		/***********************************************************************************
		**
		**	inline USHORT CProfileSelectorsItem::GetProfileSelectorMax()
		**
		**	@cmember	Gets the maximum button number for profile selector
		**
		**	@rdesc	Number of the maximum button
		**
		*************************************************************************************/
		inline USHORT GetProfileSelectorMax() const
		{
			return static_cast<USHORT>(m_cpControlItemDesc->ProfileSelectors.UsageButtonMax);
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CProfileSelector& operator =(const CProfileSelector& rProfileSelectorItem);
};

/******************************************************************************/
/**	@class CButtonLED |
/**	Derived from CControlItem represents group of LEDs the encircle buttons
******************************************************************************/
class CButtonLED  : public virtual CControlItem
{
	public:

		/***********************************************************************************
		**
		**	CButtonLED::CButtonLED(const CONTROL_ITEM_DESC *cpControlItemDesc)
		**
		**	@cmember c'tor initializes selector to 0
		**
		*************************************************************************************/
		CButtonLED
		(
			const CONTROL_ITEM_DESC *cpControlItemDesc 	// @parm Pointer to table entry describing item
		) 
		{
			m_cpControlItemDesc = cpControlItemDesc;
			m_ItemState.ulItemIndex = cpControlItemDesc->ulItemIndex;
			SetDefaultState();
		}

		virtual void SetDefaultState()
		{
			// Nothing to do here really
		}

		virtual BOOLEAN IsDefaultState()
		{
			return FALSE; // there is no such thing
		}

		//
		//	Read\Write to Report
		//
		NTSTATUS ReadFromReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			);
		NTSTATUS WriteToReport(
			PHIDP_PREPARSED_DATA pHidPreparsedData,
			PCHAR pcReport,
			LONG lReportLength
			) const;
		
	private:
		//
		//	Dissallow use of assignment operator. (Do not define - it will cause a link error if
		//	anyone tries to use it.
		//
		CButtonLED& operator =(const CButtonLED& rCButtonLED);
};


//NEWDEVICE

#endif __ControlItems_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\debug.h ===
//**************************************************************************
//
//		DEBUG.H -- X2 Gaming Project
//
//		Version 4.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@topic	DEBUG.H | Global definitions for debugging output.
//**************************************************************************

#ifndef	CIC_DEBUG_H
#define	CIC_DEBUG_H

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

//
// DEBUG output types (NOT LEVELS) - there is a similar
// section of debug.h for gckernel, these need to be in sync
//
#ifndef DBG_ENTRY

#define DBG_ENTRY		0x00000001	//Traceout on entry to function
#define DBG_EXIT		0x00000002	//Traceout on exit from function
#define DBG_WARN		0x00000004	//Traceout signifying a warning (or informational)
#define DBG_TRACE		0x00000008	//Traceout signifying a warning (or informational)
#define DBG_ERROR		0x00000010	//Traceout signifying an error
#define DBG_CRITICAL	0x00000020	//Traceout signifying a critical error
#define DBG_RT_ENTRY	0x00000040	//Traceout on entry to function (TIME CRITICAL CODE)
#define DBG_RT_EXIT		0x00000080	//Traceout on exit from function (TIME CRITICAL CODE)
#define DBG_RT_WARN		0x00000100	//Traceout signifying a warning (or informational) (TIME CRITICAL CODE)

// Combos of above for setting warning levels easily
#define DBG_NOT_RT		0x0000003F	//Traceout all above except RT codes
#define DBG_RT			0x000001C0	//Traceout RT codes
#define DBG_WARN_ERROR	0x00000134	//Traceout warnings and errors including DBG_RT_WARN
#define DBG_ALL			0xFFFFFFFF	//Traceout all codes

#endif


#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#if (DBG==1)
#define USE_CIC_DBG_TRACEOUTS
#endif
#endif

#ifdef USE_CIC_DBG_TRACEOUTS

//
//	Declaration for debug module
//

//
//	Must start file with a #define for the DEBUG module
//
//i.e. #define __DEBUG_MODULE_IN_USE__  GCKERNEL_DEBUG_MODULE
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)\
	ULONG __DEBUG_MODULE_IN_USE__ = __x__;
#define SET_MODULE_DEBUG_LEVEL(__x__)\
	__DEBUG_MODULE_IN_USE__ = __x__;


//
//	Conditional debug output procedures
//

#define CIC_DBG_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ENTRY)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_EXIT)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_WARN)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_TRACE_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_TRACE)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_ERROR_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ERROR)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_CRITICAL_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_CRITICAL)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_RT_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_ENTRY)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_RT_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_EXIT)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define CIC_DBG_RT_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_WARN)\
	{\
		DbgPrint("CIC: ");\
		DbgPrint __x__;\
	}

#define	CIC_DBG_BREAK()	DbgBreakPoint()

#undef	PAGED_CODE
#define	PAGED_CODE() \
	if (KeGetCurrentIrql() > APC_LEVEL)	\
	{\
		CIC_DBG_CRITICAL_PRINT(("CIC: Pageable code called at IRQL %ld (file: %s, line:#%ld)\n", KeGetCurrentIrql(),__FILE__,__LINE__))\
   		ASSERT(FALSE);\
	}
#else		// DBG=0

#define	CIC_DBG_ENTRY_PRINT(__x__)
#define	CIC_DBG_EXIT_PRINT(__x__)
#define CIC_DBG_TRACE_PRINT(__x__)
#define	CIC_DBG_WARN_PRINT(__x__)
#define	CIC_DBG_ERROR_PRINT(__x__)
#define	CIC_DBG_CRITICAL_PRINT(__x__)
#define	CIC_DBG_RT_ENTRY_PRINT(__x__)
#define	CIC_DBG_RT_EXIT_PRINT(__x__)
#define	CIC_DBG_RT_WARN_PRINT(__x__)
#define	CIC_DBG_BREAK()
#undef	PAGED_CODE
#define	PAGED_CODE()
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)
#define SET_MODULE_DEBUG_LEVEL(__x__)


#endif	// DBG=?


//===========================================================================
//			End
//===========================================================================

#endif	// CIC_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dualmode.h ===
#ifndef __DUALMODE_H__
#define __DUALMODE_H__
//	@doc
/**********************************************************************
*
*	@module	DualMode.h	|
*
*	Contains functions/variables etc. for writing components that can
*	be run in user or kernel mode.
*	
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	DualMode	|
*			Provides special services for drivers that differ from
*			those of Ring3.  Particularly memory allocation.
*			This file should be included for any component library that
*			must be source compatible for WDM kernel, VxD ring 0, or
*			Win32 User mode.  Two compile time constants control the
*			compilation.<nl>
*			COMPILE_FOR_WDM_KERNEL_MODE is defined if the WDM version is needed.
*			COMPILE_FOR_VXD_RING0_MODE is defined if the VxD version is needed.<nl>
*			NOTIMPL<nl>
*			NOTIMPL - VxD version will only be done as a contigency<nl>
*			NOTIMPL<nl>

*			Neither is defined for user mode.<nl>
**********************************************************************/

#ifdef COMPILE_FOR_WDM_KERNEL_MODE

//
//	@topic Overriding global new and delete |
//			The global new and delete are overriden to require
//			a placement argument specify the pool memory comes from.
//			The POOL_TYPE structure is defined in the NTDDK specifying
//			the page.<nl>
//			The user mode version ignores the POOL_TYPE (but must typedef it)
//			and uses the global new and delete.
//
#if (DBG==1)
extern void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType, LPSTR lpszFile, unsigned int uLine);
#define EXTRANEWPARAMS ,__FILE__,__LINE__
#else
extern void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType);
#define EXTRANEWPARAMS
#endif

extern void __cdecl operator delete (void * pvRawMemory);

namespace DualMode
{
	template<class Type>
	Type *Allocate(POOL_TYPE poolType)
	{
		return new (poolType EXTRANEWPARAMS) Type;

	}
	template<class Type>
	void Deallocate(Type *pMemory)
	{
		delete pMemory;
	}

	template<class Type>
	Type *AllocateArray(POOL_TYPE poolType, ULONG ulLength)
	{
		return new (poolType EXTRANEWPARAMS) Type[ulLength];
	}
	template<class Type>
	void DeallocateArray(Type *pMemory)
	{
		delete [] pMemory;
	}

	inline void BufferCopy(PVOID pvDest, PVOID pvSrc, ULONG ulByteCount)
	{
		RtlCopyMemory(pvDest, pvSrc, ulByteCount);
	}
};



#if (DBG==1)

#define WDM_NON_PAGED_POOL (NonPagedPool, __FILE__, __LINE__)
#define WDM_PAGED_POOL (PagedPool, __FILE__, __LINE__)

#else

#define WDM_NON_PAGED_POOL (NonPagedPool)
#define WDM_PAGED_POOL (PagedPool)

#endif

#else //END WDM KERNEL MODE SECTION

typedef int POOL_TYPE;
#define NonPagedPool					0
#define NonPagedPoolMustSucceed			0
#define	NonPagedPoolCacheAligned		0
#define NonPagedPoolCacheAlignedMustS	0
#define PagedPool						0
#define	PagedPoolCacheAligned			0

namespace DualMode
{
	template<class Type>
	Type *Allocate(POOL_TYPE)
	{
		return new Type;
	}
	
	template<class Type>
	void Deallocate(Type *pMemory)
	{
		delete pMemory;
	}
	template<class Type>
	Type *AllocateArray(POOL_TYPE, ULONG ulLength)
	{
		return new Type[ulLength];
	}
	template<class Type>
	void DeallocateArray(Type *pMemory)
	{
		delete [] pMemory;
	}
	
	inline void BufferCopy(PVOID pvDest, PVOID pvSrc, ULONG ulByteCount)
	{
		memcpy(pvDest, pvSrc, ulByteCount);
	}
};


//
//	Macros for interpreting NTSTATUS codes
//
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)
#define WDM_NON_PAGED_POOL
//
//	Debug macro definitions
//
#ifndef ASSERT
#define ASSERT _ASSERTE
#endif

#endif	//END USER MODE SECTION

#endif //__DUALMODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dualmode.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_DUALMODE_CPP
#include "stdhdrs.h"

//@doc
//	@doc
/**********************************************************************
*
*	@module	DualMode.cpp	|
*
*	Implements functions that differ in USER and KERNEL modes.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	DualMode	|
*
**********************************************************************/

#ifdef COMPILE_FOR_WDM_KERNEL_MODE

//
//	@topic Overriding global new and delete |
//			The global new and delete are overriden to require
//			a placement argument specify the pool memory comes from.
//			The POOL_TYPE structure is defined in the NTDDK specifying
//			the page.<nl>
//			The user mode version ignores the POOL_TYPE (but must typedef it)
//			and uses the global new and delete.
//
//			The debug version of new uses ExAllocatePoolWithTag (the tag is CICN),
//			the release version uses ExAllocatePool

#if (DBG==1)
void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType, LPSTR lpszFile, unsigned int uLine)
{
	void *pvRet;
	pvRet = ExAllocatePoolWithTag(poolType, uSize, 'NCIC');
	DbgPrint("CIC: new allocating %d bytes at 0x%0.8x, called from file: %s, line:%d\n", uSize, pvRet, lpszFile, uLine);
	return pvRet;
}
#else
void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType)
{
	return ExAllocatePool(poolType, uSize);
}
#endif

void __cdecl operator delete (void * pvRawMemory)
{
#if (DBG==1)
	DbgPrint("CIC: delete called for 0x%0.8x\n", pvRawMemory);
#endif
	if( NULL == pvRawMemory ) return;
	ExFreePool( pvRawMemory );
	return;
}


#else //END WDM KERNEL MODE SECTION




#endif	//END USER MODE SECTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\listasarray.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_LISTASARRAY_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	ListAsArray.cpp	|
*
*	Implementation of CListAsArray
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ListAsArray	|
*
**********************************************************************/

CListAsArray::CListAsArray() : 
	m_ulListAllocSize(0),
	m_ulListUsedSize(0),
	m_DefaultPoolType(PagedPool),
	m_pList(NULL),
	m_pfnDeleteFunc(NULL)
	{}

CListAsArray::~CListAsArray()
{
	//
	//	delete array and contents if allocated
	//
	if( m_ulListAllocSize )
	{
		ASSERT( m_ulListUsedSize <= m_ulListAllocSize );
		for(ULONG ulIndex = 0; ulIndex < m_ulListUsedSize; ulIndex++)
		{
			//
			//	If a delete function was set, then use it
			//
			if( m_pfnDeleteFunc )
			{
				m_pfnDeleteFunc( m_pList[ulIndex] );
			}
			//
			//	Otherwise assume that it is OK to use the global delete.
			//
			else
			{
				delete m_pList[ulIndex];
				m_pList[ulIndex] = NULL;
			}
		}

		//
		//	Delete the array itself
		//
		DualMode::DeallocateArray<PVOID>(m_pList);
	}
}

HRESULT	CListAsArray::SetAllocSize(ULONG ulSize, POOL_TYPE PoolType)
{
	m_DefaultPoolType = PoolType;

	//
	//	if the currently allocated size is greater than or less than
	//	requested size return true. (mission accomplished).
	//	DEBUG assert as client probably didn't intend this,
	//	but may have.
	//
	if( m_ulListAllocSize >= ulSize )
	{
		ASSERT(FALSE);
		return S_OK;
	}

	//
	//	Try to allocate memory
	//
	PVOID *pTempList = DualMode::AllocateArray<PVOID>(m_DefaultPoolType, ulSize);

	//
	//	If allocation failed return FALSE, and DEBUG assert
	//
	if( !pTempList )
	{
		ASSERT(pTempList);
		return E_OUTOFMEMORY;
	}

	//
	//	If it was previously allocated move contents of old
	//	array and delete the old one
	//
	if( m_ulListAllocSize )
	{
		ASSERT( m_ulListUsedSize <= m_ulListAllocSize );
		for(ULONG ulIndex = 0; ulIndex < m_ulListUsedSize; ulIndex++)
		{
			pTempList[ulIndex] = m_pList[ulIndex];
		}
		DualMode::DeallocateArray<PVOID>(m_pList);
	}	
	
	//
	//	Store Temp List as new list
	//
	m_pList = pTempList;
	m_ulListAllocSize = ulSize;
	return S_OK;
}

PVOID	CListAsArray::Get(ULONG ulIndex) const
{
	ASSERT( ulIndex < m_ulListUsedSize );
	if(	!(ulIndex < m_ulListUsedSize) )
	{
		return NULL;
	}
	return m_pList[ulIndex];
}

HRESULT	CListAsArray::Add(PVOID pItem)
{
	HRESULT hr;
	//
	//	Check that there is room, if not double allocated size
	//
	if( !(m_ulListUsedSize < m_ulListAllocSize) )
	{
		hr = SetAllocSize(m_ulListAllocSize*2, m_DefaultPoolType);
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	//
	//	Now add item
	//
	m_pList[m_ulListUsedSize++] = pItem;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\scancodedefines.h ===
#ifndef __SCANCODEDEFINES_H__
#define __SCANCODEDEFINES_H__

// Alphabet
#define SCANCODE_A 0x001E
#define SCANCODE_B 0x0030
#define SCANCODE_C 0x002E
#define SCANCODE_D 0x0020
#define SCANCODE_E 0x0012
#define SCANCODE_F 0x0021
#define SCANCODE_G 0x0022
#define SCANCODE_H 0x0023
#define SCANCODE_I 0x0017
#define SCANCODE_J 0x0024
#define SCANCODE_K 0x0025
#define SCANCODE_L 0x0026
#define SCANCODE_M 0x0032
#define SCANCODE_N 0x0031
#define SCANCODE_O 0x0018
#define SCANCODE_P 0x0019
#define SCANCODE_Q 0x0010
#define SCANCODE_R 0x0013
#define SCANCODE_S 0x001F
#define SCANCODE_T 0x0014
#define SCANCODE_U 0x0016
#define SCANCODE_V 0x002F
#define SCANCODE_W 0x0011
#define SCANCODE_X 0x002D
#define SCANCODE_Y 0x0015
#define SCANCODE_Z 0x002C

// Numbers (non numberpad)
#define SCANCODE_0 0x000B
#define SCANCODE_1 0x0002
#define SCANCODE_2 0x0003
#define SCANCODE_3 0x0004
#define SCANCODE_4 0x0005
#define SCANCODE_5 0x0006
#define SCANCODE_6 0x0007
#define SCANCODE_7 0x0008
#define SCANCODE_8 0x0009
#define SCANCODE_9 0x000A

// Numbers (numberpad)
#define SCANCODE_NUMPAD_0 0x0052
#define SCANCODE_NUMPAD_1 0x004F
#define SCANCODE_NUMPAD_2 0x0050
#define SCANCODE_NUMPAD_3 0x0051
#define SCANCODE_NUMPAD_4 0x004B
#define SCANCODE_NUMPAD_5 0x004C
#define SCANCODE_NUMPAD_6 0x004D
#define SCANCODE_NUMPAD_7 0x0047
#define SCANCODE_NUMPAD_8 0x0048
#define SCANCODE_NUMPAD_9 0x0049

// Numpad non-numbers
#define SCANCODE_NUMPAD_NUMLOCK		0xE045
#define SCANCODE_NUMPAD_DIVIDE		0xE035
#define SCANCODE_NUMPAD_MULTIPLY	0x0037
#define SCANCODE_NUMPAD_SUBTRACT	0x004A
#define SCANCODE_NUMPAD_ADD			0x004E
#define SCANCODE_NUMPAD_ENTER		0xE01C
#define SCANCODE_NUMPAD_DELETE		0x0053

// Function keys
#define SCANCODE_F1		0x003B
#define SCANCODE_F2		0x003C
#define SCANCODE_F3		0x003D
#define SCANCODE_F4		0x003E
#define SCANCODE_F5		0x003F
#define SCANCODE_F6		0x0040
#define SCANCODE_F7		0x0041
#define SCANCODE_F8		0x0042
#define SCANCODE_F9		0x0043
#define SCANCODE_F10	0x0044
#define SCANCODE_F11	0x0057
#define SCANCODE_F12	0x0058

// Direction Arrows
#define SCANCODE_NORTH	0xE048
#define SCANCODE_EAST	0xE04D
#define SCANCODE_SOUTH	0xE050
#define SCANCODE_WEST	0xE04B

// Magic 3
#define SCANCODE_PRINT_SCREEN	0xE037
#define SCANCODE_SCROLL_LOCK	0x0046
#define SCANCODE_PAUSE_BREAK	0x0045  //What should this be?

// Magic 6
#define SCANCODE_INSERT		0xE052
#define SCANCODE_HOME		0xE047
#define SCANCODE_PAGE_UP	0xE049
#define SCANCODE_DELETE		0xE053
#define SCANCODE_END		0xE04F
#define SCANCODE_PAGEDOWN	0xE051

// Modifiers
#define SCANCODE_CTRL_LEFT		0x001D
#define SCANCODE_CTRL_RIGHT		0xE01D
#define SCANCODE_SHIFT_LEFT		0x002A
#define SCANCODE_SHIFT_RIGHT	0x0036
#define SCANCODE_ALT_LEFT		0x0038
#define SCANCODE_ALT_RIGHT		0xE038

// Symbols
#define SCANCODE_PERIOD			0x0034
#define SCANCODE_COMMA			0x0033
#define SCANCODE_LEFT_BRACKET	0x001A
#define SCANCODE_RIGHT_BRACKET	0x001B
#define SCANCODE_EQUALS			0x000D
#define SCANCODE_MINUS			0x000C
#define SCANCODE_SEMICOLON		0x0027
#define SCANCODE_APOSTROPHE		0x0028
#define SCANCODE_TILDE			0x0029
#define SCANCODE_BACKSLASH		0x002B
#define SCANCODE_QUESTIONMARK	0x0035

// Miscellania
#define SCANCODE_SPACE				0x0039
#define SCANCODE_RETURN				0x001C
#define SCANCODE_TAB				0x000F
#define SCANCODE_BACKSPACE			0x000E
#define SCANCODE_CAPSLOCK			0x003A
#define SCANCODE_ESCAPE				0x0001
#define SCANCODE_APPLICATION		0xE05D
#define SCANCODE_LEFT_WIN			0xE05B
#define SCANCODE_RIGHT_WIN			0xE05C
#define SCANCODE_NON_US_BACKSLASH	0x0056

// None english
#define SCANCODE_INTERNATIONAL1		0x0073	//Brazilian forward slash, and Japanese backslash
#define SCANCODE_INTERNATIONAL3		0x007D	//Japanese Yen
#define SCANCODE_INTERNATIONAL4		0x0079	//Japanese Henkan
#define SCANCODE_INTERNATIONAL5		0x007B	//Japanese Mu-Henkan
#define SCANCODE_BRAZILIAN_PERIOD	0x007E	//Brazilian Numpad Period 


#define SCANCODE_UNUSED				0x00FF	//Unused key
#endif	__SCANCODEDEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\listasarray.h ===
//@doc
#ifndef __ListAsArray_h__
#define __ListAsArray_h__
//	@doc
/**********************************************************************
*
*	@module	ListAsArray.h	|
*
*	Declares class that manages a list of void pointers in terms
*	of a resizable array.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ListAsArray	|
*			For type safety this class really ought to be encapsulated
*			by a template class.  SelectDeleteFunc ought to be used
*			when store objects by a pointer to a  base class that is then
*			cast to void, particularly in mulitple inheretance scenarios
*			as the pointer may not point to the beginning of the block.
*
**********************************************************************/

#include "DualMode.h"
//
//	@class	ListAsArray is used to implement a generic list
//			as an array.  It should compile for kernel or user mode
//
class CListAsArray
{
	public:
		CListAsArray();
		~CListAsArray();
		
		void	SetDeleteFunc( void (*pfnDeleteFunc)(PVOID pItem) )
		{
			m_pfnDeleteFunc = pfnDeleteFunc;
		}
		void	SetDefaultPool( POOL_TYPE PoolType )
		{
			m_DefaultPoolType = PoolType;
		}
		HRESULT	SetAllocSize(ULONG ulSize, POOL_TYPE PoolType = PagedPool);
		inline ULONG	GetItemCount() const { return m_ulListUsedSize; }
		inline ULONG	GetAllocSize() const { return m_ulListAllocSize; }
		PVOID	Get(ULONG ulIndex) const ;
		HRESULT	Add(PVOID pItem);

	private:
		ULONG		m_ulListAllocSize;
		ULONG		m_ulListUsedSize;
		PVOID		*m_pList;
		void		(*m_pfnDeleteFunc)(PVOID pItem);
		POOL_TYPE	m_DefaultPoolType;
};

#endif //__ListAsArray_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\keyboardxfer.cpp ===
//	@doc
/**********************************************************************
*
*	@module	KeyboardXfer.cpp	|
*
*	Implements MakeKeyboardXfer
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	KeyboardXfer	|
*			This module implements access function for Keyboard data in
*			CONTROL_ITEM_XFER packets.  At this time, there is only one:
*			<f MakeKeyboardXfer>.
**********************************************************************/
#include "stdhdrs.h"
#include "scancodedefines.h"

//
// Define the Keyboard usages
// Unfortunately, HIDUSAGE.H, included as part of the Win98 and Win2k
// DDK's. contains only a subset of these codes.  Thus we will define them
// all here. With a slight name change.  HID_USAGE_INDEX_ is used
// instead of HID USAGE, which makes sense, since these are really
// an 8 bit index into a 16-bit USAGE with a base of 0.  Notice that the
// entries in HIDUSAGE.H are cast to type USAGE.  For us, we prefer that they
// are naturally UCHARS.  (See discussion on Selectors in HID spec. for more
// info).
//

//  Technically they are all 16 bit usages.  However, all these
// usages are only 8 bits long, and furthermore our CONTROL_ITEM_XFER only
// stores an 8 bit offset from a range of usages starting with zero.
// Thus for our purposes it makes sense to make this byte long.
//
// The HID spec does not provide good identifier names.  I followed the notation in HIDUSAGE.H
// as much as possible.  However, I arbitrarily named many keys after only one of its functions.  For
// example, "Keyboard , and <" is called HID_USAGE_INDEX_KEYBOARD_COMMA.


#define HID_USAGE_INDEX_KEYBOARD_NOEVENT		0x00
#define HID_USAGE_INDEX_KEYBOARD_ROLLOVER		0x01
#define HID_USAGE_INDEX_KEYBOARD_POSTFAIL		0x02
#define HID_USAGE_INDEX_KEYBOARD_UNDEFINED		0x03
		// Letters
#define HID_USAGE_INDEX_KEYBOARD_aA				0x04
#define HID_USAGE_INDEX_KEYBOARD_bB				0x05
#define HID_USAGE_INDEX_KEYBOARD_cC				0x06
#define HID_USAGE_INDEX_KEYBOARD_dD				0x07
#define HID_USAGE_INDEX_KEYBOARD_eE				0x08
#define HID_USAGE_INDEX_KEYBOARD_fF				0x09
#define HID_USAGE_INDEX_KEYBOARD_gG				0x0A
#define HID_USAGE_INDEX_KEYBOARD_hH				0x0B
#define HID_USAGE_INDEX_KEYBOARD_iI				0x0C
#define HID_USAGE_INDEX_KEYBOARD_jJ				0x0D
#define HID_USAGE_INDEX_KEYBOARD_kK				0x0E
#define HID_USAGE_INDEX_KEYBOARD_lL				0x0F
#define HID_USAGE_INDEX_KEYBOARD_mM				0x10
#define HID_USAGE_INDEX_KEYBOARD_nN				0x11
#define HID_USAGE_INDEX_KEYBOARD_oO				0x12
#define HID_USAGE_INDEX_KEYBOARD_pP				0x13
#define HID_USAGE_INDEX_KEYBOARD_qQ				0x14
#define HID_USAGE_INDEX_KEYBOARD_rR				0x15
#define HID_USAGE_INDEX_KEYBOARD_sS				0x16
#define HID_USAGE_INDEX_KEYBOARD_tT				0x17
#define HID_USAGE_INDEX_KEYBOARD_uU				0x18
#define HID_USAGE_INDEX_KEYBOARD_vV				0x19
#define HID_USAGE_INDEX_KEYBOARD_wW				0x1A
#define HID_USAGE_INDEX_KEYBOARD_xX				0x1B
#define HID_USAGE_INDEX_KEYBOARD_yY				0x1C
#define HID_USAGE_INDEX_KEYBOARD_zZ				0x1D
        // Numbers
#define HID_USAGE_INDEX_KEYBOARD_ONE			0x1E
#define HID_USAGE_INDEX_KEYBOARD_TWO			0x1F
#define HID_USAGE_INDEX_KEYBOARD_THREE			0x20
#define HID_USAGE_INDEX_KEYBOARD_FOUR			0x21
#define HID_USAGE_INDEX_KEYBOARD_FIVE			0x22
#define HID_USAGE_INDEX_KEYBOARD_SIX			0x23
#define HID_USAGE_INDEX_KEYBOARD_SEVEN			0x24
#define HID_USAGE_INDEX_KEYBOARD_EIGHT			0x25
#define HID_USAGE_INDEX_KEYBOARD_NINE			0x26
#define HID_USAGE_INDEX_KEYBOARD_ZERO			0x27
		//Editing Keys
#define HID_USAGE_INDEX_KEYBOARD_RETURN			0x28
#define HID_USAGE_INDEX_KEYBOARD_ESCAPE			0x29
#define HID_USAGE_INDEX_KEYBOARD_BACKSPACE		0x2A //HID spec calls this "delete(backspace)", what we later call delete HID calls "delete forward"
#define HID_USAGE_INDEX_KEYBOARD_TAB			0x2B
#define HID_USAGE_INDEX_KEYBOARD_SPACEBAR		0x2C
#define HID_USAGE_INDEX_KEYBOARD_MINUS			0x2D
#define HID_USAGE_INDEX_KEYBOARD_EQUALS			0x2E
#define HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE		0x2F
#define HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE	0x30
#define HID_USAGE_INDEX_KEYBOARD_BACKSLASH		0x31
#define HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE	0x32
#define HID_USAGE_INDEX_KEYBOARD_COLON			0x33
#define HID_USAGE_INDEX_KEYBOARD_QUOTE			0x34
#define HID_USAGE_INDEX_KEYBOARD_TILDE			0x35
#define HID_USAGE_INDEX_KEYBOARD_COMMA			0x36
#define HID_USAGE_INDEX_KEYBOARD_PERIOD			0x37
#define HID_USAGE_INDEX_KEYBOARD_QUESTION		0x38
#define HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK		0x39
        // Funtion keys
#define HID_USAGE_INDEX_KEYBOARD_F1				0x3A
#define HID_USAGE_INDEX_KEYBOARD_F2				0x3B
#define HID_USAGE_INDEX_KEYBOARD_F3				0x3C
#define HID_USAGE_INDEX_KEYBOARD_F4				0x3D
#define HID_USAGE_INDEX_KEYBOARD_F5				0x3E
#define HID_USAGE_INDEX_KEYBOARD_F6				0x3F
#define HID_USAGE_INDEX_KEYBOARD_F7				0x40
#define HID_USAGE_INDEX_KEYBOARD_F8				0x41
#define HID_USAGE_INDEX_KEYBOARD_F9				0x42
#define HID_USAGE_INDEX_KEYBOARD_F10			0x43
#define HID_USAGE_INDEX_KEYBOARD_F11			0x44
#define HID_USAGE_INDEX_KEYBOARD_F12			0x45
		//More Edit Keys
#define HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN	0x46
#define HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK	0x47
#define HID_USAGE_INDEX_KEYBOARD_PAUSE			0x48
#define HID_USAGE_INDEX_KEYBOARD_INSERT			0x49
#define HID_USAGE_INDEX_KEYBOARD_HOME			0x4A
#define HID_USAGE_INDEX_KEYBOARD_PAGE_UP		0x4B
#define HID_USAGE_INDEX_KEYBOARD_DELETE			0x4C	//HID spec, DELETE FORWARD, DELETE is used for backspace
#define HID_USAGE_INDEX_KEYBOARD_END			0x4D
#define HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN		0x4E
#define HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW	0x4F
#define HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW		0x50
#define HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW		0x51
#define HID_USAGE_INDEX_KEYBOARD_UP_ARROW		0x52			
#define HID_USAGE_INDEX_KEYPAD_NUM_LOCK			0x53
#define HID_USAGE_INDEX_KEYPAD_BACKSLASH		0x54
#define HID_USAGE_INDEX_KEYPAD_ASTERICK			0x55
#define HID_USAGE_INDEX_KEYPAD_MINUS			0x56
#define HID_USAGE_INDEX_KEYPAD_PLUS				0x57
#define HID_USAGE_INDEX_KEYPAD_ENTER			0x58
#define HID_USAGE_INDEX_KEYPAD_ONE				0x59
#define HID_USAGE_INDEX_KEYPAD_TWO				0x5A
#define HID_USAGE_INDEX_KEYPAD_THREE			0x5B
#define HID_USAGE_INDEX_KEYPAD_FOUR				0x5C
#define HID_USAGE_INDEX_KEYPAD_FIVE				0x5D
#define HID_USAGE_INDEX_KEYPAD_SIX				0x5E
#define HID_USAGE_INDEX_KEYPAD_SEVEN			0x5F
#define HID_USAGE_INDEX_KEYPAD_EIGHT			0x60
#define HID_USAGE_INDEX_KEYPAD_NINE				0x61
#define HID_USAGE_INDEX_KEYPAD_ZERO				0x62
#define HID_USAGE_INDEX_KEYPAD_DECIMAL			0x63
#define HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH	0x64
#define HID_USAGE_INDEX_KEYBOARD_APPLICATION	0x65	//This is the Windows(R)TM Key
#define HID_USAGE_INDEX_KEYBOARD_POWER			0x66	//Not on standard 101 or 104
#define HID_USAGE_INDEX_KEYPAD_EQUALS			0x67	//Not on standard 101 or 104

//Bunch o' function keys not on supported keyboards
#define HID_USAGE_INDEX_KEYBOARD_F13			0x68
#define HID_USAGE_INDEX_KEYBOARD_F14			0x69
#define HID_USAGE_INDEX_KEYBOARD_F15			0x6A
#define HID_USAGE_INDEX_KEYBOARD_F16			0x6B
#define HID_USAGE_INDEX_KEYBOARD_F17			0x6C
#define HID_USAGE_INDEX_KEYBOARD_F18			0x6D
#define HID_USAGE_INDEX_KEYBOARD_F19			0x6E
#define HID_USAGE_INDEX_KEYBOARD_F20			0x6F
#define HID_USAGE_INDEX_KEYBOARD_F21			0x70
#define HID_USAGE_INDEX_KEYBOARD_F22			0x71
#define HID_USAGE_INDEX_KEYBOARD_F23			0x72
#define HID_USAGE_INDEX_KEYBOARD_F24			0x73

//More unsupported usages
#define HID_USAGE_INDEX_KEYBOARD_EXECUTE		0x74
#define HID_USAGE_INDEX_KEYBOARD_HELP			0x75
#define HID_USAGE_INDEX_KEYBOARD_MENU			0x76
#define HID_USAGE_INDEX_KEYBOARD_SELECT			0x77
#define HID_USAGE_INDEX_KEYBOARD_STOP			0x78
#define HID_USAGE_INDEX_KEYBOARD_AGAIN			0x79
#define HID_USAGE_INDEX_KEYBOARD_UNDO			0x7A
#define HID_USAGE_INDEX_KEYBOARD_CUT			0x7B
#define HID_USAGE_INDEX_KEYBOARD_COPY			0x7C
#define HID_USAGE_INDEX_KEYBOARD_PASTE			0x7D
#define HID_USAGE_INDEX_KEYBOARD_FIND			0x7E
#define HID_USAGE_INDEX_KEYBOARD_MUTE			0x7F
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_UP		0x80
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_DOWN	0x81
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_CAPS	0x82 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_NUM	0x83 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_SCROLL	0x84 //sent as a toggle, see HID USAGE Tables spec

//Stuff that we use on foreign keyboards, some needed, some not
#define HID_USAGE_INDEX_KEYPAD_COMMA			0x85 //According to HID usage table 1.1rc3 2/16/99, use for Brazilian keypad "."
#define HID_USAGE_INDEX_KEYPAD_EQUALS_AS400		0x86 //Only As\400, so we don't need to worry.
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1 0x87 //Brazilian forward slash "/", and Japanese backslash slash
#define HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2 0x88 //Picture looks like Hiragana according to Emi
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3 0x89 //Picture looks like Yen
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4 0x8A //Picture looks like Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5 0x8B //Picture looks like Mu-Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL6 0x8C
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL7 0x8D //Single byte/double byte toggle
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL8 0x8E //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL9 0x8F //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_LANG1			0x90 //Hangul/English
#define HID_USAGE_INDEX_KEYBOARD_LANG2			0x91 //Hanja conversion key
#define HID_USAGE_INDEX_KEYBOARD_LANG3			0x92 //Katakana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG4			0x93 //Hiragana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG5			0x94 //Defines the Zenkaku/Hankaku key for Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG6			0x95 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG7			0x96 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG8			0x97 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG9			0x98 //reserved for IME


// . . .
// Modifier Keys
#define HID_USAGE_INDEX_KEYBOARD_LCTRL			0xE0
#define HID_USAGE_INDEX_KEYBOARD_LSHFT			0xE1
#define HID_USAGE_INDEX_KEYBOARD_LALT			0xE2
#define HID_USAGE_INDEX_KEYBOARD_LGUI			0xE3
#define HID_USAGE_INDEX_KEYBOARD_RCTRL			0xE4
#define HID_USAGE_INDEX_KEYBOARD_RSHFT			0xE5
#define HID_USAGE_INDEX_KEYBOARD_RALT			0xE6
#define HID_USAGE_INDEX_KEYBOARD_RGUI			0xE7

//
//	The following table has each of our keyboard "USAGES"
//	(see note above on we these are UCHAR's) at the index
//	corresponding to their scan code.  Note there is always
//	a one-to-one correspondence between scan code and USAGE.
//	This table only works for one byte scan codes.  Scan codes
//	beginning with E0 have a second byte.  The next table
//	is used for those.  This table has 83 keys.
//
UCHAR XlateScanCodeToUsageTable[] =
{
/*SCANCODE*/	/*HID USAGE*/
/*0x00*/		HID_USAGE_INDEX_KEYBOARD_NOEVENT, //SCAN CODE ZERO IS UNUSED
/*0x01*/		HID_USAGE_INDEX_KEYBOARD_ESCAPE,
/*0x02*/		HID_USAGE_INDEX_KEYBOARD_ONE,
/*0x03*/		HID_USAGE_INDEX_KEYBOARD_TWO,
/*0x04*/		HID_USAGE_INDEX_KEYBOARD_THREE,
/*0x05*/		HID_USAGE_INDEX_KEYBOARD_FOUR,
/*0x06*/		HID_USAGE_INDEX_KEYBOARD_FIVE,
/*0x07*/		HID_USAGE_INDEX_KEYBOARD_SIX,
/*0x08*/		HID_USAGE_INDEX_KEYBOARD_SEVEN,
/*0x09*/		HID_USAGE_INDEX_KEYBOARD_EIGHT,
/*0x0A*/		HID_USAGE_INDEX_KEYBOARD_NINE,
/*0x0B*/		HID_USAGE_INDEX_KEYBOARD_ZERO,
/*0x0C*/		HID_USAGE_INDEX_KEYBOARD_MINUS,
/*0x0D*/		HID_USAGE_INDEX_KEYBOARD_EQUALS,
/*0x0E*/		HID_USAGE_INDEX_KEYBOARD_BACKSPACE,
/*0x0F*/		HID_USAGE_INDEX_KEYBOARD_TAB,
/*0x10*/		HID_USAGE_INDEX_KEYBOARD_qQ,
/*0x11*/		HID_USAGE_INDEX_KEYBOARD_wW,
/*0x12*/		HID_USAGE_INDEX_KEYBOARD_eE,
/*0x13*/		HID_USAGE_INDEX_KEYBOARD_rR,
/*0x14*/		HID_USAGE_INDEX_KEYBOARD_tT,
/*0x15*/		HID_USAGE_INDEX_KEYBOARD_yY,
/*0x16*/		HID_USAGE_INDEX_KEYBOARD_uU,
/*0x17*/		HID_USAGE_INDEX_KEYBOARD_iI,
/*0x18*/		HID_USAGE_INDEX_KEYBOARD_oO,
/*0x19*/		HID_USAGE_INDEX_KEYBOARD_pP,
/*0x1A*/		HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE,
/*0x1B*/		HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE,
/*0x1C*/		HID_USAGE_INDEX_KEYBOARD_RETURN,
/*0x1D*/		HID_USAGE_INDEX_KEYBOARD_LCTRL,
/*0x1E*/		HID_USAGE_INDEX_KEYBOARD_aA,
/*0x1F*/		HID_USAGE_INDEX_KEYBOARD_sS,
/*0x20*/		HID_USAGE_INDEX_KEYBOARD_dD,
/*0x21*/		HID_USAGE_INDEX_KEYBOARD_fF,
/*0x22*/		HID_USAGE_INDEX_KEYBOARD_gG,
/*0x23*/		HID_USAGE_INDEX_KEYBOARD_hH,
/*0x24*/		HID_USAGE_INDEX_KEYBOARD_jJ,
/*0x25*/		HID_USAGE_INDEX_KEYBOARD_kK,
/*0x26*/		HID_USAGE_INDEX_KEYBOARD_lL,
/*0x27*/		HID_USAGE_INDEX_KEYBOARD_COLON,
/*0x28*/		HID_USAGE_INDEX_KEYBOARD_QUOTE,
/*0x29*/		HID_USAGE_INDEX_KEYBOARD_TILDE,
/*0x2A*/		HID_USAGE_INDEX_KEYBOARD_LSHFT,
/*0x2B*/		HID_USAGE_INDEX_KEYBOARD_BACKSLASH,
/*0x2C*/		HID_USAGE_INDEX_KEYBOARD_zZ,
/*0x2D*/		HID_USAGE_INDEX_KEYBOARD_xX,
/*0x2E*/		HID_USAGE_INDEX_KEYBOARD_cC,
/*0x2F*/		HID_USAGE_INDEX_KEYBOARD_vV,
/*0x30*/		HID_USAGE_INDEX_KEYBOARD_bB,
/*0x31*/		HID_USAGE_INDEX_KEYBOARD_nN,
/*0x32*/		HID_USAGE_INDEX_KEYBOARD_mM,
/*0x33*/		HID_USAGE_INDEX_KEYBOARD_COMMA,
/*0x34*/		HID_USAGE_INDEX_KEYBOARD_PERIOD,
/*0x35*/		HID_USAGE_INDEX_KEYBOARD_QUESTION,
/*0x36*/		HID_USAGE_INDEX_KEYBOARD_RSHFT,
/*0x37*/		HID_USAGE_INDEX_KEYPAD_ASTERICK,  //Print screen, but it always comes with EO (for some reason Mitch had printscreen)
/*0x38*/		HID_USAGE_INDEX_KEYBOARD_LALT,
/*0x39*/		HID_USAGE_INDEX_KEYBOARD_SPACEBAR,
/*0x3A*/		HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK,
/*0x3B*/		HID_USAGE_INDEX_KEYBOARD_F1,
/*0x3C*/		HID_USAGE_INDEX_KEYBOARD_F2,
/*0x3D*/		HID_USAGE_INDEX_KEYBOARD_F3,
/*0x3E*/		HID_USAGE_INDEX_KEYBOARD_F4,
/*0x3F*/		HID_USAGE_INDEX_KEYBOARD_F5,
/*0x40*/		HID_USAGE_INDEX_KEYBOARD_F6,
/*0x41*/		HID_USAGE_INDEX_KEYBOARD_F7,
/*0x42*/		HID_USAGE_INDEX_KEYBOARD_F8,
/*0x43*/		HID_USAGE_INDEX_KEYBOARD_F9,
/*0x44*/		HID_USAGE_INDEX_KEYBOARD_F10,
/*0x45*/		HID_USAGE_INDEX_KEYPAD_NUM_LOCK,
/*0x46*/		HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK,
/*0x47*/		HID_USAGE_INDEX_KEYPAD_SEVEN,			//a.k.a. HOME on Keypad
/*0x48*/		HID_USAGE_INDEX_KEYPAD_EIGHT,			//a.k.a. UP ARROW on Keypad
/*0x49*/		HID_USAGE_INDEX_KEYPAD_NINE,			//a.k.a. PAGE UP on Keypad
/*0x4A*/		HID_USAGE_INDEX_KEYPAD_MINUS,			//a.k.a. GREY - on Keypad
/*0x4B*/		HID_USAGE_INDEX_KEYPAD_FOUR,			//a.k.a. LEFT ARROW on Keypad
/*0x4C*/		HID_USAGE_INDEX_KEYPAD_FIVE,			//a.k.a. CENTER on Keypad
/*0x4D*/		HID_USAGE_INDEX_KEYPAD_SIX,			//a.k.a. RIGHT on Keypad
/*0x4E*/		HID_USAGE_INDEX_KEYPAD_PLUS,			//a.k.a. GREY + on Keypad
/*0x4F*/		HID_USAGE_INDEX_KEYPAD_ONE,			//a.k.a. END on Keypad
/*0x50*/		HID_USAGE_INDEX_KEYPAD_TWO,			//a.k.a. DOWN ARROW on Keypad
/*0x51*/		HID_USAGE_INDEX_KEYPAD_THREE,			//a.k.a. PAGE DOWN on Keypad
/*0x52*/		HID_USAGE_INDEX_KEYPAD_ZERO,			//a.k.a. INSERT on Keypad
/*0x53*/		HID_USAGE_INDEX_KEYPAD_DECIMAL,		//a.k.a. DELETE on Keypad
/*0x54*/		0x00,
/*0x55*/		0x00,
/*0x56*/		HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH,
/*0x57*/		HID_USAGE_INDEX_KEYBOARD_F11,
/*0x58*/		HID_USAGE_INDEX_KEYBOARD_F12,
};


UCHAR XlateScanCodeToUsageTable2[] =
{
/*0x70*/		HID_USAGE_INDEX_KEYBOARD_LANG4,	//Hiragana
/*0x71*/		0x00,
/*0x72*/		0x00,
/*0x73*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1, //Brazilian forward slash
/*0x74*/		0x00,
/*0x75*/		0x00,
/*0x76*/		0x00,
/*0x77*/		0x00,
/*0x78*/		0x00,
/*0x79*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4, //Japanese Henkan
/*0x7A*/		0x00,
/*0x7B*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5, //Japanese Mu-Henkan 
/*0x7C*/		0x00,
/*0x7D*/		HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3, //Japanese Yen
/*0x7E*/		HID_USAGE_INDEX_KEYPAD_COMMA			 //Brazilian Number Pad "."
};

//The keys in this table appear only on extended (101 and 104 key, keyboards).
//These are two byte scan codes, where the first byte is 0xE0
struct EXT_SC_2_USAGE_ENTRY
{
	UCHAR	ucScanCodeLowByte;	//Low Byte of Extended Scan Code (High Byte is 0xE0
	UCHAR	ucHidUsageIndex;	//0 biased index to HID USAGE
};
EXT_SC_2_USAGE_ENTRY XlateExtendedScanCodeToUsageTable[] =
{
	{0x1C,	HID_USAGE_INDEX_KEYPAD_ENTER},
	{0x1D,	HID_USAGE_INDEX_KEYBOARD_RCTRL},
	//0x1E
	//	. . .
	//0x34
	{0x35,	HID_USAGE_INDEX_KEYPAD_BACKSLASH},
	//0x36
	{0x37,	HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN},
	{0x38,	HID_USAGE_INDEX_KEYBOARD_RALT},
	//0x39
	//. . .
	//0x44
	{0x45,	HID_USAGE_INDEX_KEYPAD_NUM_LOCK},
	//0x46
	{0x47,	HID_USAGE_INDEX_KEYBOARD_HOME},
	{0x48,	HID_USAGE_INDEX_KEYBOARD_UP_ARROW},
	{0x49,	HID_USAGE_INDEX_KEYBOARD_PAGE_UP},
	//0x4A
	{0x4B,	HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW},
	//0x4C
	{0x4D,	HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW},
	//0x4E
	{0x4F,	HID_USAGE_INDEX_KEYBOARD_END},
	{0x50,	HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW},
	{0x51,	HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN},
	{0x52,	HID_USAGE_INDEX_KEYBOARD_INSERT},
	{0x53,	HID_USAGE_INDEX_KEYBOARD_DELETE},
	{0x00,	0x00}	//terminates table
};


#define HIGHBYTEi2(__X__) (UCHAR)(__X__>>8)		//Acts on USHORT (2 byte integer)
#define LOWBYTEi2(__X__) (UCHAR)(__X__&0x00FF)	//Acts on USHORT (2 byte integer)

/***********************************************************************************
**
**	void NonGameDeviceXfer::MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, ULONG ulScanCodeCount, const PUSHORT pusScanCodes)
**
**	@mfunc	Converts an array of scancodes into a ControlItemXfer for a keyboard.
**
**	@rdesc	None
**
*************************************************************************************/
void NonGameDeviceXfer::MakeKeyboardXfer
(
	CONTROL_ITEM_XFER& rControlItemXfer,	// @parm [out] caller allocated ControlItemXfer which is initialized by routine
	ULONG ulScanCodeCount,				// @parm [in] Count of Scan codes in Array
	const USHORT* pusScanCodes				// @parm [in] Pointer to array of scan codes
)
{
	
	//Clear out the data completely first
	memset(&rControlItemXfer, 0, sizeof(CONTROL_ITEM_XFER));

	//This routine only supports up to six scan codes
	ASSERT(ulScanCodeCount <= c_ulMaxXFerKeys);
	
	UCHAR ucUsageIndex;
	ULONG ulKeyArrayIndex = 0;
	
	//Mark as Keyboard CONTROL_ITEM_XFER
	rControlItemXfer.ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	
	//Start with no modifier keys down
	rControlItemXfer.Keyboard.ucModifierByte = 0;
	
	//Loop over all scan codes
	for(ULONG ulScanCodeIndex = 0; ulScanCodeIndex < ulScanCodeCount; ulScanCodeIndex++)
	{
		//Check High Byte to determine which table
		if( 0xE0 == HIGHBYTEi2(pusScanCodes[ulScanCodeIndex]) )
		{
			//Use Extended keytable - need a search algorithm rather than direct lookup
			UCHAR ucScanCodeLowByte = LOWBYTEi2(pusScanCodes[ulScanCodeIndex]);
			ucUsageIndex = HID_USAGE_INDEX_KEYBOARD_UNDEFINED;
			//Sequential Search (there are only 15 items) BUGBUG - change to Binary search time permitting
			for(ULONG ulTableIndex=0; XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte != 0; ulTableIndex++)
			{
				if( XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte == ucScanCodeLowByte)
				{
					ucUsageIndex = XlateExtendedScanCodeToUsageTable[ulTableIndex].ucHidUsageIndex;
					break;
				}
			}
			ASSERT(HID_USAGE_INDEX_KEYBOARD_UNDEFINED != ucUsageIndex);
		}
		else
		{
			//Use Main Lookup table
			ASSERT( 0x7E >= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) &&
					0x54 != LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) &&
					0x55 != LOWBYTEi2(pusScanCodes[ulScanCodeIndex])
					);
			if( 0x58 >= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) )
			{
				ucUsageIndex = XlateScanCodeToUsageTable[ LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) ];
			}
			//Try lookup table 2
			else if( 
					0x70 <= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) &&	
					0x7E >= LOWBYTEi2(pusScanCodes[ulScanCodeIndex]) 
				)
			{
				ucUsageIndex = XlateScanCodeToUsageTable2[ LOWBYTEi2(pusScanCodes[ulScanCodeIndex])-0x70 ];
			}
			else
			{
				ucUsageIndex = 0x00;
			}
		}
		//Check if USAGE is a special one that belongs in modifier byte
		if(0xE0 <= ucUsageIndex &&  0xE7 >= ucUsageIndex)
		{
			//Set bit in modifier byte
			UCHAR ucModifierBitMask = 1 << (ucUsageIndex - 0xE0);
			rControlItemXfer.Keyboard.ucModifierByte |= ucModifierBitMask;
		}
		else
		//otherwise add to array of down keys
		{
			rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = ucUsageIndex;
		}
	}//end of loop over scan codes
	
	//Clean up unused spots in rgucKeysDownArray
	while(ulKeyArrayIndex < c_ulMaxXFerKeys)
	{
		rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = HID_USAGE_INDEX_KEYBOARD_NOEVENT;
	}
}

void NonGameDeviceXfer::MakeKeyboardXfer(CONTROL_ITEM_XFER& rControlItemXfer, const IE_KEYEVENT& rKeyEvent)
{
	//This routine only supports up to six scan codes
	ASSERT(rKeyEvent.uCount <= c_ulMaxXFerKeys);

	UCHAR ucUsageIndex;
	ULONG ulKeyArrayIndex = 0;

	//Clear out the data completely first
	memset(&rControlItemXfer, 0, sizeof(CONTROL_ITEM_XFER));
	
	//Mark as Keyboard CONTROL_ITEM_XFER
	rControlItemXfer.ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	
	//Start with no modifier keys down
	rControlItemXfer.Keyboard.ucModifierByte = 0;
	
	//Loop over all scan codes
	for(ULONG ulScanCodeIndex = 0; ulScanCodeIndex < rKeyEvent.uCount; ulScanCodeIndex++)
	{
		WORD wScanCode = rKeyEvent.KeyStrokes[ulScanCodeIndex].wScanCode;

		//Check High Byte to determine which table
		if( 0xE0 == HIGHBYTEi2(wScanCode) )
		{
			//Use Extended keytable - need a search algorithm rather than direct lookup
			UCHAR ucScanCodeLowByte = LOWBYTEi2(wScanCode);
			ucUsageIndex = HID_USAGE_INDEX_KEYBOARD_UNDEFINED;
			//Sequential Search (there are only 15 items) BUGBUG - change to Binary search time permitting
			for(ULONG ulTableIndex=0; XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte != 0; ulTableIndex++)
			{
				if( XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte == ucScanCodeLowByte)
				{
					ucUsageIndex = XlateExtendedScanCodeToUsageTable[ulTableIndex].ucHidUsageIndex;
					break;
				}
			}
			ASSERT(HID_USAGE_INDEX_KEYBOARD_UNDEFINED != ucUsageIndex);
		}
		else
		{
			//Use Main Lookup table
			ASSERT( 0x53 >= LOWBYTEi2(wScanCode) || 0x56 == LOWBYTEi2(wScanCode));
			ucUsageIndex = XlateScanCodeToUsageTable[ LOWBYTEi2(wScanCode) ];
		}
		//Check if USAGE is a special one that belongs in modifier byte
		if(0xE0 <= ucUsageIndex &&  0xE7 >= ucUsageIndex)
		{
			//Set bit in modifier byte
			UCHAR ucModifierBitMask = 1 << (ucUsageIndex - 0xE0);
			rControlItemXfer.Keyboard.ucModifierByte |= ucModifierBitMask;
		}
		else
		//otherwise add to array of down keys
		{
			rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = ucUsageIndex;
		}
	}//end of loop over scan codes
	
	//Clean up unused spots in rgucKeysDownArray
	while(ulKeyArrayIndex < c_ulMaxXFerKeys)
	{
		rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex++] = HID_USAGE_INDEX_KEYBOARD_NOEVENT;
	}
}


void NonGameDeviceXfer::AddScanCodeToXfer(CONTROL_ITEM_XFER& rControlItemXfer, WORD wScanCode)
{
	// Is the xfer event a keyboard one?
	_ASSERTE(rControlItemXfer.ulItemIndex == NonGameDeviceXfer::ulKeyboardIndex);
	if (rControlItemXfer.ulItemIndex != NonGameDeviceXfer::ulKeyboardIndex)
	{
		return;
	}

	UCHAR ucUsageIndex;

	//Check High Byte to determine which table
	if (0xE0 == HIGHBYTEi2(wScanCode))
	{
		//Use Extended keytable - need a search algorithm rather than direct lookup
		UCHAR ucScanCodeLowByte = LOWBYTEi2(wScanCode);
		ucUsageIndex = HID_USAGE_INDEX_KEYBOARD_UNDEFINED;
		//Sequential Search (there are only 15 items) BUGBUG - change to Binary search time permitting
		for (ULONG ulTableIndex=0; XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte != 0; ulTableIndex++)
		{
			if (XlateExtendedScanCodeToUsageTable[ulTableIndex].ucScanCodeLowByte == ucScanCodeLowByte)
			{
				ucUsageIndex = XlateExtendedScanCodeToUsageTable[ulTableIndex].ucHidUsageIndex;
				break;
			}
		}
		ASSERT(HID_USAGE_INDEX_KEYBOARD_UNDEFINED != ucUsageIndex);
	}
	else
	{	//Use Main Lookup table
		ASSERT (0x53 >= LOWBYTEi2(wScanCode) || 0x56 == LOWBYTEi2(wScanCode));
		ucUsageIndex = XlateScanCodeToUsageTable[LOWBYTEi2(wScanCode)];
	}

	// Check if USAGE is a special one that belongs in modifier byte
	if (0xE0 <= ucUsageIndex &&  0xE7 >= ucUsageIndex)
	{	//Set bit in modifier byte
		UCHAR ucModifierBitMask = 1 << (ucUsageIndex - 0xE0);
		rControlItemXfer.Keyboard.ucModifierByte |= ucModifierBitMask;
	}
	else
	{	//otherwise add to array of down keys
		ULONG ulKeyArrayIndex = 0;
		while (rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex] != HID_USAGE_INDEX_KEYBOARD_NOEVENT)
		{
			if (ulKeyArrayIndex >= c_ulMaxXFerKeys)
			{
				return;		// There is no space left
			}
			ulKeyArrayIndex++;
		}
		rControlItemXfer.Keyboard.rgucKeysDown[ulKeyArrayIndex] = ucUsageIndex;
	}
}


USHORT XlateUsageToScanCodeTable[] =
{

/*HID_USAGE_INDEX_KEYBOARD_NOEVENT(0x00)*/
/*HID_USAGE_INDEX_KEYBOARD_ROLLOVER(0x01)*/
/*HID_USAGE_INDEX_KEYBOARD_POSTFAIL(0x02)*/
/*HID_USAGE_INDEX_KEYBOARD_UNDEFINED(0x03)*/
//Due to above four special codes, 4 should be subtracted
//from the usage before lookup
/*HID_USAGE_INDEX_KEYBOARD_aA(0x04)*/				SCANCODE_A,
/*HID_USAGE_INDEX_KEYBOARD_bB(0x05)*/				SCANCODE_B,
/*HID_USAGE_INDEX_KEYBOARD_cC(0x06)*/				SCANCODE_C,
/*HID_USAGE_INDEX_KEYBOARD_dD(0x07)*/				SCANCODE_D,
/*HID_USAGE_INDEX_KEYBOARD_eE(0x08)*/				SCANCODE_E,
/*HID_USAGE_INDEX_KEYBOARD_fF(0x09)*/				SCANCODE_F,
/*HID_USAGE_INDEX_KEYBOARD_gG(0x0A)*/				SCANCODE_G,
/*HID_USAGE_INDEX_KEYBOARD_hH(0x0B)*/				SCANCODE_H,
/*HID_USAGE_INDEX_KEYBOARD_iI(0x0C)*/				SCANCODE_I,
/*HID_USAGE_INDEX_KEYBOARD_jJ(0x0D)*/				SCANCODE_J,
/*HID_USAGE_INDEX_KEYBOARD_kK(0x0E)*/				SCANCODE_K,
/*HID_USAGE_INDEX_KEYBOARD_lL(0x0F)*/				SCANCODE_L,
/*HID_USAGE_INDEX_KEYBOARD_mM(0x10)*/				SCANCODE_M,
/*HID_USAGE_INDEX_KEYBOARD_nN(0x11)*/				SCANCODE_N,
/*HID_USAGE_INDEX_KEYBOARD_oO(0x12)*/				SCANCODE_O,
/*HID_USAGE_INDEX_KEYBOARD_pP(0x13)*/				SCANCODE_P,
/*HID_USAGE_INDEX_KEYBOARD_qQ(0x14)*/				SCANCODE_Q,
/*HID_USAGE_INDEX_KEYBOARD_rR(0x15)*/				SCANCODE_R,
/*HID_USAGE_INDEX_KEYBOARD_sS(0x16)*/				SCANCODE_S,
/*HID_USAGE_INDEX_KEYBOARD_tT(0x17)*/				SCANCODE_T,
/*HID_USAGE_INDEX_KEYBOARD_uU(0x18)*/				SCANCODE_U,
/*HID_USAGE_INDEX_KEYBOARD_vV(0x19)*/				SCANCODE_V,
/*HID_USAGE_INDEX_KEYBOARD_wW(0x1A)*/				SCANCODE_W,
/*HID_USAGE_INDEX_KEYBOARD_xX(0x1B)*/				SCANCODE_X,
/*HID_USAGE_INDEX_KEYBOARD_yY(0x1C)*/				SCANCODE_Y,
/*HID_USAGE_INDEX_KEYBOARD_zZ(0x1D)*/				SCANCODE_Z,
/*HID_USAGE_INDEX_KEYBOARD_ONE(0x1E)*/				SCANCODE_1,
/*HID_USAGE_INDEX_KEYBOARD_TWO(0x1F)*/				SCANCODE_2,
/*HID_USAGE_INDEX_KEYBOARD_THREE(0x20)*/			SCANCODE_3,
/*HID_USAGE_INDEX_KEYBOARD_FOUR(0x21)*/				SCANCODE_4,
/*HID_USAGE_INDEX_KEYBOARD_FIVE(0x22)*/				SCANCODE_5,
/*HID_USAGE_INDEX_KEYBOARD_SIX(0x23)*/				SCANCODE_6,
/*HID_USAGE_INDEX_KEYBOARD_SEVEN(0x24)*/			SCANCODE_7,
/*HID_USAGE_INDEX_KEYBOARD_EIGHT(0x25)*/			SCANCODE_8,
/*HID_USAGE_INDEX_KEYBOARD_NINE(0x26)*/				SCANCODE_9,
/*HID_USAGE_INDEX_KEYBOARD_ZERO(0x27)*/				SCANCODE_0,
/*HID_USAGE_INDEX_KEYBOARD_RETURN(0x28)*/			SCANCODE_RETURN,
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE(0x29)*/			SCANCODE_ESCAPE,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE(0x2A)*/		SCANCODE_BACKSPACE,
/*HID_USAGE_INDEX_KEYBOARD_TAB(0x2B)*/				SCANCODE_TAB,
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR(0x2C)*/			SCANCODE_SPACE,
/*HID_USAGE_INDEX_KEYBOARD_MINUS(0x2D)*/			SCANCODE_MINUS,
/*HID_USAGE_INDEX_KEYBOARD_EQUALS(0x2E)*/			SCANCODE_EQUALS,					
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE(0x2F)*/		SCANCODE_LEFT_BRACKET,		
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE(0x30)*/		SCANCODE_RIGHT_BRACKET,	
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH(0x31)*/		SCANCODE_BACKSLASH,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE(0x32)*/		SCANCODE_BACKSLASH, //NOT SURE, got from hidparse.sys code
/*HID_USAGE_INDEX_KEYBOARD_COLON(0x33)*/			SCANCODE_SEMICOLON,		
/*HID_USAGE_INDEX_KEYBOARD_QUOTE(0x34)*/			SCANCODE_APOSTROPHE,		
/*HID_USAGE_INDEX_KEYBOARD_TILDE(0x35)*/			SCANCODE_TILDE,
/*HID_USAGE_INDEX_KEYBOARD_COMMA(0x36)*/			SCANCODE_COMMA,			
/*HID_USAGE_INDEX_KEYBOARD_PERIOD(0x37)*/			SCANCODE_PERIOD,
/*HID_USAGE_INDEX_KEYBOARD_QUESTION(0x38)*/			SCANCODE_QUESTIONMARK,
/*HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK(0x39)*/		SCANCODE_CAPSLOCK,
/*HID_USAGE_INDEX_KEYBOARD_F1(0x3A)*/				SCANCODE_F1,
/*HID_USAGE_INDEX_KEYBOARD_F2(0x3B)*/				SCANCODE_F2,
/*HID_USAGE_INDEX_KEYBOARD_F3(0x3C)*/				SCANCODE_F3,
/*HID_USAGE_INDEX_KEYBOARD_F4(0x3D)*/				SCANCODE_F4,
/*HID_USAGE_INDEX_KEYBOARD_F5(0x3E)*/				SCANCODE_F5,
/*HID_USAGE_INDEX_KEYBOARD_F6(0x3F)*/				SCANCODE_F6,
/*HID_USAGE_INDEX_KEYBOARD_F7(0x40)*/				SCANCODE_F7,
/*HID_USAGE_INDEX_KEYBOARD_F8(0x41)*/				SCANCODE_F8,
/*HID_USAGE_INDEX_KEYBOARD_F9(0x42)*/				SCANCODE_F9,
/*HID_USAGE_INDEX_KEYBOARD_F10(0x43)*/				SCANCODE_F10,
/*HID_USAGE_INDEX_KEYBOARD_F11(0x44)*/				SCANCODE_F11,
/*HID_USAGE_INDEX_KEYBOARD_F12(0x45)*/				SCANCODE_F12,
/*HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN(0x46)*/		SCANCODE_PRINT_SCREEN,
/*HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK(0x47)*/		SCANCODE_SCROLL_LOCK,
/*HID_USAGE_INDEX_KEYBOARD_PAUSE(0x48)*/			SCANCODE_PAUSE_BREAK,
/*HID_USAGE_INDEX_KEYBOARD_INSERT(0x49)*/			SCANCODE_INSERT,
/*HID_USAGE_INDEX_KEYBOARD_HOME(0x4A)*/				SCANCODE_HOME,	
/*HID_USAGE_INDEX_KEYBOARD_PAGE_UP(0x4B)*/			SCANCODE_PAGE_UP,
/*HID_USAGE_INDEX_KEYBOARD_DELETE(0x4C)*/			SCANCODE_DELETE,
/*HID_USAGE_INDEX_KEYBOARD_END(0x4D)*/				SCANCODE_END,
/*HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN(0x4E)*/		SCANCODE_PAGEDOWN,
/*HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW(0x4F)*/		SCANCODE_EAST,
/*HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW(0x50)*/		SCANCODE_WEST,	
/*HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW(0x51)*/		SCANCODE_SOUTH,	
/*HID_USAGE_INDEX_KEYBOARD_UP_ARROW(0x52)*/			SCANCODE_NORTH,
/*HID_USAGE_INDEX_KEYPAD_NUM_LOCK(0x53)*/			SCANCODE_NUMPAD_NUMLOCK,
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH(0x54)*/			SCANCODE_NUMPAD_DIVIDE,	
/*HID_USAGE_INDEX_KEYPAD_ASTERICK(0x55)*/			SCANCODE_NUMPAD_MULTIPLY,
/*HID_USAGE_INDEX_KEYPAD_MINUS(0x56)*/				SCANCODE_NUMPAD_SUBTRACT,
/*HID_USAGE_INDEX_KEYPAD_PLUS(0x57)*/				SCANCODE_NUMPAD_ADD,
/*HID_USAGE_INDEX_KEYPAD_ENTER(0x58)*/				SCANCODE_NUMPAD_ENTER,	
/*HID_USAGE_INDEX_KEYPAD_ONE(0x59)*/				SCANCODE_NUMPAD_1,
/*HID_USAGE_INDEX_KEYPAD_TWO(0x5A)*/				SCANCODE_NUMPAD_2,
/*HID_USAGE_INDEX_KEYPAD_THREE(0x5B)*/				SCANCODE_NUMPAD_3,
/*HID_USAGE_INDEX_KEYPAD_FOUR(0x5C)*/				SCANCODE_NUMPAD_4,
/*HID_USAGE_INDEX_KEYPAD_FIVE(0x5D)*/				SCANCODE_NUMPAD_5,
/*HID_USAGE_INDEX_KEYPAD_SIX(0x5E)*/				SCANCODE_NUMPAD_6,
/*HID_USAGE_INDEX_KEYPAD_SEVEN(0x5F)*/				SCANCODE_NUMPAD_7,
/*HID_USAGE_INDEX_KEYPAD_EIGHT(0x60)*/				SCANCODE_NUMPAD_8,
/*HID_USAGE_INDEX_KEYPAD_NINE(0x61)*/				SCANCODE_NUMPAD_9,
/*HID_USAGE_INDEX_KEYPAD_ZERO(0x62)*/				SCANCODE_NUMPAD_0,
/*HID_USAGE_INDEX_KEYPAD_DECIMAL(0x63)*/			SCANCODE_NUMPAD_DELETE,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH(0x64)*/ SCANCODE_NON_US_BACKSLASH,
/*HID_USAGE_INDEX_KEYBOARD_APPLICATION(0x65)*/		SCANCODE_APPLICATION
/*HID_USAGE_INDEX_KEYBOARD_POWER(0x66)*/			//Not a real key
/*HID_USAGE_INDEX_KEYPAD_EQUALS(0x67)*/				//Not on supported keyboards
};

USHORT XlateUsageToScanCodeTable2[] =
{
/*HID_USAGE_INDEX_KEYPAD_COMMA*/					SCANCODE_BRAZILIAN_PERIOD,
/*HID_USAGE_INDEX_KEYPAD_EQUALS*/					SCANCODE_UNUSED,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1*/			SCANCODE_INTERNATIONAL1,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2*/			SCANCODE_UNUSED,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL3*/			SCANCODE_INTERNATIONAL3,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL4*/			SCANCODE_INTERNATIONAL4,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL5*/			SCANCODE_INTERNATIONAL5
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL6*/			
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL7*/			
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL8*/			
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL9*/			
/*HID_USAGE_INDEX_KEYBOARD_LANG1*/					
/*HID_USAGE_INDEX_KEYBOARD_LANG2*/
/*HID_USAGE_INDEX_KEYBOARD_LANG3*/
/*HID_USAGE_INDEX_KEYBOARD_LANG4*/
/*HID_USAGE_INDEX_KEYBOARD_LANG5*/

};

USHORT XlateUsageModByteToScanCodeTable[] =
{
	/*HID_USAGE_INDEX_KEYBOARD_LCTRL(0xE0)*/	SCANCODE_CTRL_LEFT,
	/*HID_USAGE_INDEX_KEYBOARD_LSHFT(0xE1)*/	SCANCODE_SHIFT_LEFT,
	/*HID_USAGE_INDEX_KEYBOARD_LALT(0xE2)*/		SCANCODE_ALT_LEFT,
	/*HID_USAGE_INDEX_KEYBOARD_LGUI(0xE3)*/		SCANCODE_LEFT_WIN,
	/*HID_USAGE_INDEX_KEYBOARD_RCTRL(0xE4)*/	SCANCODE_CTRL_RIGHT,
	/*HID_USAGE_INDEX_KEYBOARD_RSHFT(0xE5)*/	SCANCODE_SHIFT_RIGHT,
	/*HID_USAGE_INDEX_KEYBOARD_RALT(0xE6)*/		SCANCODE_ALT_RIGHT,
	/*HID_USAGE_INDEX_KEYBOARD_RGUI(0xE7)*/		SCANCODE_RIGHT_WIN
};


/***********************************************************************************
**
**	void NonGameDeviceXfer::ScanCodesFromKeyboardXfer(const CONTROL_ITEM_XFER& crControlItemXfer, ULONG& rulScanCodeCount, PUSHORT pusScanCodes)
**
**	@mfunc	Reads a ControlItemXfer for a keyboard into an array of scan codes.
**
**
*************************************************************************************/
void NonGameDeviceXfer::ScanCodesFromKeyboardXfer
(
	const CONTROL_ITEM_XFER& crControlItemXfer,	// @parm [in] ControlItemXfer to read scan code from
	ULONG& rulScanCodeCount,					// @parm [in\out] Allocated space on entry, count returned on exit
	USHORT* pusScanCodes						// @parm [out] Pointer to array to receive scancode
)
{
	ULONG ulMaxScanCodes;
	ULONG ulIndex;
	ulMaxScanCodes = rulScanCodeCount;
	ASSERT(ulMaxScanCodes > 0);
	if(0==ulMaxScanCodes) return;
	rulScanCodeCount = 0;
	
	//make sure this really contains keyboard data.
	ASSERT( IsKeyboardXfer(crControlItemXfer) );
	if(!IsKeyboardXfer(crControlItemXfer))
			return;
	//Process modifier Byte
	for(ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		ULONG ulMask = (1 << ulIndex);
		if(crControlItemXfer.Keyboard.ucModifierByte & ulMask)
		{
			//lookup scan code
			pusScanCodes[rulScanCodeCount] = XlateUsageModByteToScanCodeTable[ulIndex];
			//move to next free spot in output, return if output is full
			if(ulMaxScanCodes == ++rulScanCodeCount)
				return;
		}
	}
	
	//Process array of up to six keys down first
	for(ulIndex = 0; ulIndex < c_ulMaxXFerKeys; ulIndex++)
	{
		//check main conversion table
		if(
			HID_USAGE_INDEX_KEYBOARD_aA <= crControlItemXfer.Keyboard.rgucKeysDown[ulIndex] &&
			HID_USAGE_INDEX_KEYBOARD_APPLICATION >= crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]
		)
		{
			//lookup scan code
			pusScanCodes[rulScanCodeCount] = XlateUsageToScanCodeTable[crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]-4];
			if( SCANCODE_UNUSED == pusScanCodes[rulScanCodeCount]) continue;
		}
		//check secondary table
		else if(
			HID_USAGE_INDEX_KEYPAD_COMMA <= crControlItemXfer.Keyboard.rgucKeysDown[ulIndex] &&
			HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5	>=	crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]
			)
		{
			//lookup scan code in secondary table
			pusScanCodes[rulScanCodeCount] = XlateUsageToScanCodeTable2[crControlItemXfer.Keyboard.rgucKeysDown[ulIndex]-HID_USAGE_INDEX_KEYPAD_COMMA];
			if( SCANCODE_UNUSED == pusScanCodes[rulScanCodeCount]) continue;
		}
		else
		{
			//not a supported key
			continue;
		}
		//move to next free spot in output, return if output is full
		if(ulMaxScanCodes == ++rulScanCodeCount)
			return;
	}
	return;
}

/************** Dealy XFer Functions ***************************/
void NonGameDeviceXfer::MakeDelayXfer(CONTROL_ITEM_XFER& rControlItemXfer, DWORD dwDelay)
{
	// Clear out the data completely first
	memset(&rControlItemXfer, 0, sizeof(CONTROL_ITEM_XFER));

	// Mark as Delay CONTROL_ITEM_XFER
	rControlItemXfer.ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	rControlItemXfer.Delay.dwValue = dwDelay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\joyinfoexcollection.h ===
// @doc
/******************************************************************************
*
* @module JoyInfoExCollection.h |
*
* CControlItemJoyInfoExCollection template class header file
*
* Implements the CControlItemJoyInfoExCollection control item collection class,
* which is used to convert back and forth between JOYINFOEX packets and 
* CONTROL_ITEM_XFER packets.
*
* History<nl>
* ---------------------------------------------------<nl>
* Daniel M. Sangster		Original		2/1/99<nl>
*<nl>
* (c) 1986-1999 Microsoft Corporation.  All rights reserved.<nl>
* <nl>
* 
******************************************************************************/

#ifndef __JoyInfoExCollection_H_
#define __JoyInfoExCollection_H_

#define JOY_FLAGS_PEDALS_NOT_PRESENT	2

/////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExControlItem, which derives virtually from CControlItem, is
// used as the base class for all items in the CControlItemJoyInfoExCollection.
// It has only two pure virtual functions.  GetItemState gets the current state
// of the item into a JOYINFOEX structure.  SetItemState does the opposite.
class CJoyInfoExControlItem : public virtual CControlItem
{
	public:
		CJoyInfoExControlItem();
		
		virtual HRESULT GetItemState(JOYINFOEX* pjix) = 0;
		virtual HRESULT SetItemState(JOYINFOEX* pjix) = 0;
};

///////////////////////////////////////////////////////////////////////////////
// @func ControlItemJoyInfoExFactory is the factory that is required by the
// CControlItemCollection template class to create control items derived from
// CJoyInfoExControlItem.
HRESULT ControlItemJoyInfoExFactory
(
	USHORT usType,
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CJoyInfoExControlItem	**ppControlItem
);

////////////////////////////////////////////////////////////////////////////////////
// @class CControlItemJoyInfoExCollection, which is derived from the template
// class CControlItemCollection, implements a collection of CJoyInfoExControlItems.
// Its two members, GetState2() and SetState2(), will get or set the current
// state of the collection into a JOYINFOEX structure.  Using the GetState()
// and SetState() members of ControlItemCollection, the user can freely convert
// between JOYINFOEX structures and CONTROL_ITEM_XFER structures.
class CControlItemJoyInfoExCollection : public CControlItemCollection<CJoyInfoExControlItem>
{
	public:
		CControlItemJoyInfoExCollection(ULONG ulVidPid);

		HRESULT GetState2(JOYINFOEX* pjix);
		HRESULT SetState2(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExAxesItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CAxesItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExAxesItem : public CJoyInfoExControlItem, public CAxesItem
{
	public:
		CJoyInfoExAxesItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExDPADItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CDPADItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExDPADItem : public CJoyInfoExControlItem, public CDPADItem
{
	public:
		CJoyInfoExDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc);
		
		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExPropDPADItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CPropDPADItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExPropDPADItem : public CJoyInfoExControlItem, public CPropDPADItem
{
	public:
		CJoyInfoExPropDPADItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExButtonsItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CButtonsItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExButtonsItem : public CJoyInfoExControlItem, public CButtonsItem
{
	public:
		CJoyInfoExButtonsItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExProfileSelectorsItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CProfileSelector, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExProfileSelectorsItem : public CJoyInfoExControlItem, public CProfileSelector
{
	public:
		CJoyInfoExProfileSelectorsItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExPOVItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CPOVItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExPOVItem : public CJoyInfoExControlItem, public CPOVItem
{
	public:
		CJoyInfoExPOVItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExThrottleItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CThrottleItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExThrottleItem : public CJoyInfoExControlItem, public CThrottleItem
{
	public:
		CJoyInfoExThrottleItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExRudderItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CRudderItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExRudderItem : public CJoyInfoExControlItem, public CRudderItem
{
	public:
		CJoyInfoExRudderItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExWheelItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CWheelItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExWheelItem : public CJoyInfoExControlItem, public CWheelItem
{
	public:
		CJoyInfoExWheelItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExPedalItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CPedalItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExPedalItem : public CJoyInfoExControlItem, public CPedalItem
{
	public:
		CJoyInfoExPedalItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

///////////////////////////////////////////////////////////////////////////////
// @class CJoyInfoExDualZoneIndicatorItem, which derives simultaneously from our
// custom CJoyInfoExControlItem and the standard CDualZoneIndicatorItem, implements
// an item whose state can be read/written as JOYINFOEX structures
// or CONTROL_ITEM_XFERs.
class CJoyInfoExDualZoneIndicatorItem : public CJoyInfoExControlItem, public CDualZoneIndicatorItem
{
	public:
		CJoyInfoExDualZoneIndicatorItem(const CONTROL_ITEM_DESC *cpControlItemDesc);

		virtual HRESULT GetItemState(JOYINFOEX* pjix);
		virtual HRESULT SetItemState(JOYINFOEX* pjix);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\joyinfoexcollection.cpp ===
// @doc
/******************************************************************************
*
* @module JoyInfoExCollection.cpp |
*
* CControlItemJoyInfoExCollectio and related classes implementation file
*
* History<nl>
* ---------------------------------------------------<nl>
* Daniel M. Sangster		Original		2/1/99
*
* (c) 1986-1999 Microsoft Corporation.  All rights reserved.
*
* @topic JOYINFOEX Collection |
* The CControlItemJoyInfoExCollection class, the various CJoyInfoExControlItem
* classes and the ControlItemJoyInfoExFactory taken together implement the JOYINFOEX
* collection.  This collection is designed as a way to convert between
* CONTROL_ITEM_XFERs and JOYINFOEX structures.  A user does this by setting
* the state of the collection with SetState() or SetState2() and reading
* the state of the collection with GetState() or GetState2().
*
* The classes themselves are simple because they rely on CControlItemCollection
* CControlItem, etc. for much of the functionality.  The guts of the conversion
* takes place in the SetItemState() and GetItemState() members of each of the
* control items.  Here, the methods use accessor functions provided by CControlItem
* and related classes to set or get the state to or from the appropriate member
* of the JOYINFOEX structure for that item.  For example, a buttons item would
* set or get data from dwButtons and dwButtonNumber using accessors on CButtonsItem.
******************************************************************************/

#include "stdhdrs.h"
#include "joyinfoexcollection.h"
#include <math.h>

/***********************************************************************************
**
**	HRESULT ControlItemJoyInfoExFactory
**
**	@func	Factory for JoyInfoEx collection
**
**	@rdesc	S_OK if successful, S_FALSE if not supported, E_FAIL for any failure.
**
************************************************************************************/
HRESULT ControlItemJoyInfoExFactory
(
	USHORT usType,									//@parm [in] Type of object to create
	const CONTROL_ITEM_DESC* cpControlItemDesc,		//@parm [in] Item descriptor data
	CJoyInfoExControlItem		**ppJoyInfoExControlItem	//@parm [out] CJoyInfoExControlItem we created
)
{
	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExAxesItem(cpControlItemDesc);
			break;
		case ControlItemConst::usDPAD:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPropDPAD:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExPropDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usWheel:
			*ppJoyInfoExControlItem= new WDM_NON_PAGED_POOL CJoyInfoExWheelItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPOV:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExPOVItem(cpControlItemDesc);
			break;
		case ControlItemConst::usThrottle:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExThrottleItem(cpControlItemDesc);
			break;
		case ControlItemConst::usRudder:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExRudderItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPedal:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExPedalItem(cpControlItemDesc);
			break;
		case ControlItemConst::usButton:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExButtonsItem(cpControlItemDesc);
			break;
		case ControlItemConst::usProfileSelectors:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExProfileSelectorsItem(cpControlItemDesc);
			break;
		case ControlItemConst::usDualZoneIndicator:
			*ppJoyInfoExControlItem = new WDM_NON_PAGED_POOL CJoyInfoExDualZoneIndicatorItem(cpControlItemDesc);
			break;
		default:
			*ppJoyInfoExControlItem = NULL;
			return S_FALSE;
	}
	if(!*ppJoyInfoExControlItem)
	{
		return E_FAIL;
	}
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CControlItemJoyInfoExCollection::CControlItemJoyInfoExCollection
// 
// @mfunc The constructor tells the base class what the VidPid and factory
// are for this device and collection.
//
// @rdesc	None
//
CControlItemJoyInfoExCollection::CControlItemJoyInfoExCollection(ULONG ulVidPid) :
	CControlItemCollection<CJoyInfoExControlItem>(ulVidPid, &ControlItemJoyInfoExFactory)
{
}

/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::GetState2
**
**	@mfunc	Gets the JOYINFOEX representation of the state of each item in the 
** collection and returns it in the caller.
**
**	@rvalue	S_OK	| Success
**	@rvalue	E_OUTOFMEMORY	|	Buffer is not large enough
**	@rvalue	E_INVALIDARG	|	Bad argument
**
*************************************************************************************/
HRESULT CControlItemJoyInfoExCollection::GetState2
(
	JOYINFOEX* pjix
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	pjix->dwSize = sizeof(JOYINFOEX);
	pjix->dwFlags = 0;
	pjix->dwXpos = 0;
	pjix->dwYpos = 0;
	pjix->dwZpos = 0;
	pjix->dwRpos = 0;
	pjix->dwUpos = 0;
	pjix->dwVpos = 0;
	pjix->dwButtons = 0;
	pjix->dwButtonNumber = 0;
	pjix->dwPOV = (DWORD)-1;

	ULONG ulCookie = 0;
	CJoyInfoExControlItem *pControlItem;
	
	hr = GetNext(&pControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem->GetItemState(pjix);
		hr = GetNext(&pControlItem, ulCookie);
	}
	return hr;	
}

/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::SetState2
**
**	@mfunc	Sets the state of each item in the collection from a JOYINFOEX representation.
**
**	@rvalue	S_OK	| Success
**	@rvalue	E_OUTOFMEMORY	|	Buffer is not large enough
**	@rvalue	E_INVALIDARG	|	Bad argument
**
*************************************************************************************/
HRESULT CControlItemJoyInfoExCollection::SetState2
(
	JOYINFOEX* pjix
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	ULONG ulCookie = 0;
	//PVOID pvControlItem = NULL;
	CJoyInfoExControlItem *pControlItem;
	
	hr = GetNext(&pControlItem, ulCookie);
	while(S_OK == hr)
	{
		hr = pControlItem->SetItemState(pjix);
		_ASSERTE(SUCCEEDED(hr));
		hr = GetNext(&pControlItem, ulCookie);
	}
	return hr;	
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExControlItem::CJoyInfoExControlItem
// 
// @mfunc Constructor does nothing
//
// @rdesc	None
//
CJoyInfoExControlItem::CJoyInfoExControlItem()
{
}


const int cnMaxJoyInfoExAxis = 65535;
const int cnMaxJoyInfoExPOV = 35900;


////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExControlItem::CJoyInfoExControlItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExAxesItem::CJoyInfoExAxesItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CAxesItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExAxesItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExAxesItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// get the raw axes data
	LONG lX = 0;
	LONG lY = 0;
	GetXY(lX, lY);

	// scale the data to joyinfoex range
	lX = MulDiv(cnMaxJoyInfoExAxis, lX-lMinX, lMaxX-lMinX);
	lY = MulDiv(cnMaxJoyInfoExAxis, lY-lMinY, lMaxY-lMinY);

	// put result in joyinfoex structure
	pjix->dwXpos = lX;
	pjix->dwYpos = lY;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExAxesItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExAxesItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// scale the data to correct range
	LONG lX = lMinX + MulDiv(lMaxX-lMinX, pjix->dwXpos, cnMaxJoyInfoExAxis);
	LONG lY = lMinY + MulDiv(lMaxY-lMinY, pjix->dwYpos, cnMaxJoyInfoExAxis);

	// set the item data
	SetXY(lX, lY);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDPADItem::CJoyInfoExDPADItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExDPADItem::CJoyInfoExDPADItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CDPADItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDPADItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDPADItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// TODO talk to mitch about what the range should be

	// get the raw POV data
	LONG lDirection;
	GetDirection(lDirection);

	// put result in joyinfoex structure
	pjix->dwPOV = lDirection;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDPADItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDPADItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// TODO talk to mitch about what the range should be
	// put result in joyinfoex structure
	LONG lDirection = pjix->dwPOV;

	// set the raw POV data
	SetDirection(lDirection);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPropDPADItem::CJoyInfoExPropDPADItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExPropDPADItem::CJoyInfoExPropDPADItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CPropDPADItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPropDPADItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPropDPADItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// get the raw axes data
	LONG lX = 0;
	LONG lY = 0;
	GetXY(lX, lY);

	// scale the data to joyinfoex range
	lX = MulDiv(cnMaxJoyInfoExAxis, lX-lMinX, lMaxX-lMinX);
	lY = MulDiv(cnMaxJoyInfoExAxis, lY-lMinY, lMaxY-lMinY);

	// put result in joyinfoex structure
	pjix->dwXpos = lX;
	pjix->dwYpos = lY;

	// get the raw POV data
	LONG lDirection;
	GetDirection(lDirection);

	// put result in joyinfoex structure
	pjix->dwPOV = lDirection;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPropDPADItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPropDPADItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// argument checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axes range
	LONG lMinX = 0;
	LONG lMaxX = 0;
	LONG lMinY = 0;
	LONG lMaxY = 0;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);

	// scale the data to correct range
	LONG lX = lMinX + MulDiv(lMaxX-lMinX, pjix->dwXpos, cnMaxJoyInfoExAxis);
	LONG lY = lMinY + MulDiv(lMaxY-lMinY, pjix->dwYpos, cnMaxJoyInfoExAxis);

	// set the item data
	SetXY(lX, lY);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExButtonsItem::CJoyInfoExButtonsItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExButtonsItem::CJoyInfoExButtonsItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CButtonsItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExButtonsItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExButtonsItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the minimum and maximum button numbers
	USHORT usButtonMin = GetButtonMin();
	USHORT usButtonMax = GetButtonMax();

	// get the button number and bit array
	USHORT usButtonNumber = 0;
	ULONG ulButtonBitArray = 0;
	GetButtons(usButtonNumber, ulButtonBitArray);

	// shift the bit array by bias amount
	ulButtonBitArray = ulButtonBitArray << (usButtonMin-1);

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=usButtonMin; usButtonIndex<=usButtonMax; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// handle special case of detecting shift button because
	// shift button is not reflected in the bit array
	ULONG ulShiftButtonBitArray = 0;
	ULONG ulRawShiftButtonBitArray = 0;
	ULONG ulShiftButtonMask = 0;
	GetShiftButtons(ulRawShiftButtonBitArray);
	UINT uShiftButtonCount = GetNumShiftButtons();
	if(uShiftButtonCount > 1)
	{
		for(UINT uShiftButtonIndex=0; uShiftButtonIndex<uShiftButtonCount; uShiftButtonIndex++)
		{
			USHORT usShiftButtonUsage = GetShiftButtonUsage(uShiftButtonIndex);
			if(usShiftButtonUsage != 0)
				ulShiftButtonBitArray |= ((ulRawShiftButtonBitArray >> uShiftButtonIndex) & 0x01) << (usShiftButtonUsage - 1);
		}

		// create a bitmask for this range of shift buttons
		for(uShiftButtonIndex=0; uShiftButtonIndex<uShiftButtonCount; uShiftButtonIndex++)
		{
			USHORT usShiftButtonUsage = GetShiftButtonUsage(uShiftButtonIndex);
			if(usShiftButtonUsage != 0)
				ulShiftButtonMask |= 1 << (usShiftButtonUsage - 1);
		}
	}
	else if(uShiftButtonCount == 1)
	{
		ulShiftButtonMask = 0x00200;
		if(ulRawShiftButtonBitArray != NULL)
			ulShiftButtonBitArray = ulShiftButtonMask;
	}

	// set this section of the bit array into the joyinfoex structure
	ULONG ulMask = ulButtonMask | ulShiftButtonMask;
	pjix->dwButtons |= (pjix->dwButtons & ~ulMask) | ulButtonBitArray | ulShiftButtonBitArray;

	// set the button number of the joyinfoex structure, if set
	pjix->dwButtonNumber = usButtonNumber;

	// TODO: remove this hack when driver is fixed
	if(usButtonNumber != 0)
		pjix->dwButtons |= 1<<(usButtonNumber-1);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExButtonsItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExButtonsItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the minimum and maximum button numbers
	USHORT usButtonMin = GetButtonMin();
	USHORT usButtonMax = GetButtonMax();

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=usButtonMin; usButtonIndex<=usButtonMax; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// get the buttons
	ULONG ulButtonBitArray = pjix->dwButtons & ulButtonMask;
	ulButtonBitArray = ulButtonBitArray >> (usButtonMin-1);

	// get the shift buttons
	ULONG ulShiftButtonBitArray = 0;
	UINT uShiftButtonCount = GetNumShiftButtons();
	if(uShiftButtonCount > 1)
	{
		for(UINT uShiftButtonIndex=0; uShiftButtonIndex<uShiftButtonCount; uShiftButtonIndex++)
		{
			USHORT usShiftButtonUsage = GetShiftButtonUsage(uShiftButtonIndex);
			if(usShiftButtonUsage != 0)
				ulShiftButtonBitArray |= ((pjix->dwButtons >> (usShiftButtonUsage - 1)) & 0x01) << uShiftButtonIndex;
		}
	}
	else if(uShiftButtonCount == 1)
	{
		if(pjix->dwButtons & 0x00200)
			ulShiftButtonBitArray = 1;
	}

	// set the shift button data
	SetShiftButtons(ulShiftButtonBitArray);

	// set the button data
	USHORT usButtonNumber = (USHORT)pjix->dwButtonNumber;
	SetButtons(usButtonNumber, ulButtonBitArray);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExProfileSelectorsItem::CJoyInfoExProfileSelectorsItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExProfileSelectorsItem::CJoyInfoExProfileSelectorsItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc	// @parm Description of item
) :
	CProfileSelector(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExProfileSelectorsItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExProfileSelectorsItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the min and max button numbers
	UINT uFirstProfileSelectorButton = GetProfileSelectorMin();
	UINT uLastProfileSelectorButton = GetProfileSelectorMax();
	int iProfileSelectorButtonCount = uLastProfileSelectorButton - uFirstProfileSelectorButton + 1;
	// _ASSERTE(iProfileSelectorButtonCount > 0);

	// get the profile that is selected
	UCHAR ucSelectedProfile;
	GetSelectedProfile(ucSelectedProfile);

	// create a bit array corresponding to this 
	ULONG ulButtonBitArray = 1 << (iProfileSelectorButtonCount - ucSelectedProfile - 1);

	// shift the bit array by bias amount
	ulButtonBitArray = ulButtonBitArray << (uFirstProfileSelectorButton-1);

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=uFirstProfileSelectorButton; usButtonIndex<=uLastProfileSelectorButton; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// set this section of the bit array into the joyinfoex structure
	pjix->dwButtons = (pjix->dwButtons & ~ulButtonMask) | ulButtonBitArray;

	// set the button number of the joyinfoex structure, if it has not already been set
	if(pjix->dwButtonNumber == 0)
		pjix->dwButtonNumber = ucSelectedProfile + uFirstProfileSelectorButton;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExProfileSelectorsItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExProfileSelectorsItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the min and max button numbers
	UINT uFirstProfileSelectorButton = GetProfileSelectorMin();
	UINT uLastProfileSelectorButton = GetProfileSelectorMax();
	int iProfileSelectorButtonCount = uLastProfileSelectorButton - uFirstProfileSelectorButton + 1;
	// _ASSERTE(iProfileSelectorButtonCount > 0);

	// create a bitmask for this range of buttons
	ULONG ulButtonMask = 0;
	for(USHORT usButtonIndex=uFirstProfileSelectorButton; usButtonIndex<=uLastProfileSelectorButton; usButtonIndex++)
		ulButtonMask |= 1 << (usButtonIndex-1);

	// get the buttons
	ULONG ulButtonBitArray = pjix->dwButtons & ulButtonMask;
	ulButtonBitArray = ulButtonBitArray >> (uFirstProfileSelectorButton-1);

	// convert this to an index
	UCHAR ucIndex = 0;
	for(ucIndex=0; ucIndex<=uLastProfileSelectorButton-uFirstProfileSelectorButton; ucIndex++)
	{
		// if low order bit is one, we have found our index
		if((ulButtonBitArray >> ucIndex) & 0x01)
			break;
	}

	// set the shift button data
	UCHAR ucSelectedProfile = iProfileSelectorButtonCount - ucIndex - 1;
	SetSelectedProfile(ucSelectedProfile);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPOVItem::CJoyInfoExPOVItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExPOVItem::CJoyInfoExPOVItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CPOVItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPOVItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPOVItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the POV range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	if(lVal >= lMin && lVal <= lMax)
		lVal = MulDiv(cnMaxJoyInfoExPOV, lVal-lMin, lMax-lMin);
	else
		lVal = -1;

	// put result in joyinfoex structure
	pjix->dwPOV = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPOVItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPOVItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the POV range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	LONG lVal = 0;
	if(pjix->dwPOV >= 0)
		lVal = lMin + MulDiv(lMax-lMin, pjix->dwPOV, cnMaxJoyInfoExPOV);
	else
		lVal = -1;

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExThrottleItem::CJoyInfoExThrottleItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExThrottleItem::CJoyInfoExThrottleItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CThrottleItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExThrottleItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExThrottleItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	pjix->dwZpos = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExThrottleItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExThrottleItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to correct range
	LONG lVal = lMin + MulDiv(lMax-lMin, pjix->dwZpos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExRudderItem::CJoyInfoExRudderItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExRudderItem::CJoyInfoExRudderItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CRudderItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExRudderItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExRudderItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	pjix->dwRpos = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExRudderItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExRudderItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	LONG lVal = lMin + MulDiv(lMax-lMin, pjix->dwRpos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExWheelItem::CJoyInfoExWheelItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExWheelItem::CJoyInfoExWheelItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CWheelItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExWheelItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExWheelItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	pjix->dwXpos = lVal;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExWheelItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExWheelItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	LONG lVal = lMin + MulDiv(lMax-lMin, pjix->dwXpos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPedalItem::CJoyInfoExPedalItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExPedalItem::CJoyInfoExPedalItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CPedalItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPedalItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPedalItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// get the raw POV data
	LONG lVal = 0;
	GetValue(lVal);

	// scale the data to joyinfoex range
	lVal = MulDiv(cnMaxJoyInfoExAxis, lVal-lMin, lMax-lMin);

	// put result in joyinfoex structure
	if(IsYAxis())
	{
		pjix->dwYpos = lVal;
	}
	else
	{
		pjix->dwRpos = lVal;
	}

	// mark the JOYINFOEX packet if the pedals are not there
	if(!ArePedalsPresent())
		pjix->dwFlags |= JOY_FLAGS_PEDALS_NOT_PRESENT;

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExPedalItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExPedalItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// get the axis range
	LONG lMin = 0;
	LONG lMax = 0;
	GetRange(lMin, lMax);

	// scale the data to joyinfoex range
	DWORD dwPos = 0;
	if(IsYAxis())
	{
		dwPos = pjix->dwYpos;
	}
	else
	{
		dwPos = pjix->dwRpos;
	}
	LONG lVal = lMin + MulDiv(lMax-lMin, dwPos, cnMaxJoyInfoExAxis);

	// set the raw POV data
	SetValue(lVal);

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDualZoneIndicatorItem::CJoyInfoExDualZoneIndicatorItem
// 
// @mfunc Constructor gives CONTROL_ITEM_DESC to base class
//
// @rdesc	None
//
CJoyInfoExDualZoneIndicatorItem::CJoyInfoExDualZoneIndicatorItem
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		// @parm Description of item
) :
	CDualZoneIndicatorItem(cpControlItemDesc)
{
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDualZoneIndicatorItem::GetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDualZoneIndicatorItem::GetItemState
(
	JOYINFOEX* pjix		// @parm Receives state of item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	// convert to axes
	UINT uMin = 0;
	UINT uMax = cnMaxJoyInfoExAxis;
	UINT uMid = uMax/2;
	if(IsXYIndicator())
	{
		LONG lActiveZone = GetActiveZone();
		/*
		if ((m_ItemState.DualZoneIndicators.rglVal[0] != 0) || (m_ItemState.DualZoneIndicators.rglVal[1] != 0))
		{
			TCHAR tszDebug[1024];
			wsprintf(tszDebug, "\tlActiveZone = %d\n", lActiveZone);
			OutputDebugString("*****************************************\n");
			OutputDebugString(tszDebug);
		}
		*/
		switch(lActiveZone)
		{
			case 0:
				pjix->dwXpos = uMid;
				pjix->dwYpos = uMid;
				break;
			case 1:
				pjix->dwXpos = uMin;
				pjix->dwYpos = uMax;
				break;
			case 2:
				pjix->dwXpos = uMid;
				pjix->dwYpos = uMax;
				break;
			case 3:
				pjix->dwXpos = uMax;
				pjix->dwYpos = uMax;
				break;
			case 4:
				pjix->dwXpos = uMax;
				pjix->dwYpos = uMid;
				break;
			case 5:
				pjix->dwXpos = uMax;
				pjix->dwYpos = uMin;
				break;
			case 6:
				pjix->dwXpos = uMid;
				pjix->dwYpos = uMin;
				break;
			case 7:
				pjix->dwXpos = uMin;
				pjix->dwYpos = uMin;
				break;
			case 8:
				pjix->dwXpos = uMin;
				pjix->dwYpos = uMid;
				break;
			default:
				_ASSERTE(FALSE);
		}
	}
	else if(IsRzIndicator())
	{
		LONG lActiveZone = GetActiveZone();
		switch(lActiveZone)
		{
			case 0:
				pjix->dwRpos = uMid;
				break;
			case 1:
				pjix->dwRpos = uMin;
				break;
			case 2:
				pjix->dwRpos = uMax;
				break;
			default:
				_ASSERTE(FALSE);
		}
	}
	else
	{
		_ASSERTE(FALSE);
		return E_UNEXPECTED;
	}

	//_RPT0(_CRT_WARN, "*********CJoyInfoExDualZoneIndicatorItem::GetItemState()****************\n");
	//_RPT1(_CRT_WARN, "\tlZone = %d\n", GetActiveZone());
	//_RPT1(_CRT_WARN, "\t====> dwXpos = %d\n", pjix->dwXpos);
	//_RPT1(_CRT_WARN, "\t====> dwYpos = %d\n", pjix->dwYpos);
	//_RPT0(_CRT_WARN, "************************************************************************\n");

	// success
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// CJoyInfoExDualZoneIndicatorItem::SetItemState
// 
// @mfunc Converts from native format to JOYINFOEX format.
//
//	@rvalue	S_OK	| Success
//	@rvalue	E_INVALIDARG	|	Bad argument
//
HRESULT CJoyInfoExDualZoneIndicatorItem::SetItemState
(
	JOYINFOEX* pjix		// @parm Contains state to set into item
)
{
	_ASSERTE(pjix != NULL);
	_ASSERTE(pjix->dwSize == sizeof(JOYINFOEX));

	// parameter checking
	if(pjix == NULL || pjix->dwSize != sizeof(JOYINFOEX))
		return E_INVALIDARG;

	LONG lZone = 0;
	UINT uMin = 0;
	UINT uMax = cnMaxJoyInfoExAxis;
	UINT uMid = uMax/2;
	if(IsXYIndicator())
	{
		int iXPos = (int)pjix->dwXpos - uMid;
		int iYPos = (int)pjix->dwYpos - uMid;
		if((ULONGLONG)iXPos*iXPos + iYPos*iYPos > (ULONGLONG)(uMid*uMid/4))
		{
			double dAngle = atan2(iYPos, iXPos);
			dAngle = dAngle*180.0/3.14159;
			dAngle += 360.0;
			dAngle = fmod(dAngle, 360.0);

			if(dAngle < -1.0)
				_ASSERTE(FALSE);
			else if(dAngle < 22.5)
				lZone = 4;
			else if(dAngle < 67.5)
				lZone = 3;
			else if(dAngle < 112.5)
				lZone = 2;
			else if(dAngle < 157.5)
				lZone = 1;
			else if(dAngle < 202.5)
				lZone = 8;
			else if(dAngle < 247.5)
				lZone = 7;
			else if(dAngle < 292.5)
				lZone = 6;
			else if(dAngle < 337.5)
				lZone = 5;
			else if(dAngle <= 361.0)
				lZone = 4;
			else
				_ASSERTE(FALSE);
		}
	}
	else if(IsRzIndicator())
	{
		int iRPos = (int)pjix->dwRpos - uMid;
		if(iRPos > (int)uMid/2)
			lZone = 2;
		else if(iRPos < -(int)uMid/2)
			lZone = 1;
	}
	else
	{
		_ASSERTE(FALSE);
		return E_UNEXPECTED;
	}

	//_RPT0(_CRT_WARN, "*********CJoyInfoExDualZoneIndicatorItem::SetItemState()****************\n");
	//_RPT1(_CRT_WARN, "\tdwXpos = %d\n", pjix->dwXpos);
	//_RPT1(_CRT_WARN, "\tdwYpos = %d\n", pjix->dwYpos);
	//_RPT1(_CRT_WARN, "\t====> lZone = %d\n", lZone);
	//_RPT0(_CRT_WARN, "************************************************************************\n");

	// set the raw POV data
	SetActiveZone(lZone);

	// success
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dumpcommandblock.h ===
//When invoked from WDM makefile the debug condition is different
#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#if (DBG==1)
#undef _NDEBUG
#else
#define _NDEBUG
#endif
#endif

// If not debug the module just makes the three entry points no-ops
#ifdef _NDEBUG
#define CIC_DBG_DumpCommandBlock(_X_)
#define CIC_DBG_SetDumpFunc(_X_)
#define CIC_DBG_InitDumpModule(_X_)
#else
//This module only works in debug mode
#define CIC_DBG_DumpCommandBlock(_X_) DumpCommandBlock _X_
#define CIC_DBG_SetDumpFunc(_X_) SetDumpFunc _X_
#define CIC_DBG_InitDumpModule(_X_) InitDumpModule _X_

#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#define DCB_TRACE(_x_) DbgPrint(_x_)
#else
#define DCB_TRACE(_x_) OutputDebugString(_x_)
#endif

typedef void (*PFNSTRING_DUMP_FUNC)(LPSTR);
//
//	Interface of exported functions
//
void InitDumpModule(ULONG ulVidPid);
void SetDumpFunc(PFNSTRING_DUMP_FUNC pfnDumpFunc);
BOOLEAN DumpCommandBlock(PUCHAR pucBlock, ULONG rulSize);

//
//	Internals - for dumping info from small chuncks.
//
void DumpString(LPSTR lpszDumpString);
BOOLEAN DumpRecurse(PUCHAR pucBlock, ULONG ulSize, ULONG ulDepth);
BOOLEAN DumpDirectory(PUCHAR pucBlock, ULONG ulSize, ULONG ulDepth);
BOOLEAN DumpAssignmentTarget(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpTimedMacro(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpKeyString(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpMouseFxAxisMap(PUCHAR pucBlock, ULONG ulSize);
BOOLEAN DumpTimedEvent(PTIMED_EVENT pTimedEvent);
BOOLEAN DumpEvent(PEVENT pEvent);
BOOLEAN DumpTriggerXfer(PCONTROL_ITEM_XFER pControlItemXfer);
BOOLEAN DumpEventXfer(PCONTROL_ITEM_XFER pControlItemXfer);
BOOLEAN DumpKeyboardData(PCONTROL_ITEM_XFER pControlItemXfer);

//
//	Dumping Xfers it more complicated and requires a derivative of CControlItemCollection
//

class CDumpItem : public virtual CControlItem
{
	public:
		CDumpItem(){}

		virtual void DumpItemInfo(ULONG ulDumpFlags);

		//
		//	Static functions
		//
		static void SetDumpFunc(PFNSTRING_DUMP_FUNC pfnDumpFunc)
		{
			ms_pfnDumpFunc = pfnDumpFunc;
		}
		static void DumpString(LPSTR lpszDumpString)
		{
			if(NULL == ms_pfnDumpFunc)
			{
				DCB_TRACE(lpszDumpString);
			}
			else
			{
				ms_pfnDumpFunc(lpszDumpString);
			}
		}
	private:
		static PFNSTRING_DUMP_FUNC ms_pfnDumpFunc;
};

class CAxesDump : public CDumpItem, public CAxesItem
{
	public:
		CAxesDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CAxesItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CDPADDump : public CDumpItem, public CDPADItem
{
	public:
		CDPADDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CDPADItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
		
};

class CPropDPADDump : public CDumpItem, public CPropDPADItem
{
	public:
		CPropDPADDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPropDPADItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CButtonsDump : public CDumpItem, public CButtonsItem
{
	public:
		CButtonsDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CButtonsItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};
class CPOVDump : public CDumpItem, public CPOVItem
{
	public:
		CPOVDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPOVItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CThrottleDump : public CDumpItem, public CThrottleItem
{
	public:
		CThrottleDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CThrottleItem(cpControlItemDesc)
		{}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CRudderDump : public CDumpItem, public CRudderItem
{
	public:
		CRudderDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CRudderItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};


class CWheelDump : public CDumpItem, public CWheelItem
{
	public:
		CWheelDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CWheelItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CPedalDump : public CDumpItem, public CPedalItem
{
	public:
		CPedalDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPedalItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CZoneIndicatorDump : public CDumpItem, public CZoneIndicatorItem
{
	public:
		CZoneIndicatorDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CZoneIndicatorItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CDualZoneIndicatorDump : public CDumpItem, public CDualZoneIndicatorItem
{
	public:
		CDualZoneIndicatorDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CDualZoneIndicatorItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

class CForceMapDump : public CDumpItem, public CForceMapItem
{
	public:
		CForceMapDump(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CForceMapItem(cpControlItemDesc)
		{
		}
		virtual void DumpItemInfo(ULONG ulDumpFlags);
};

//NEWDEVICE
HRESULT	DumpItemFactory
(
	USHORT usType,	
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CDumpItem				**ppControlItem
);

#endif //NOT _NDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\ctrl_ioctl.c ===
//	@doc
/**********************************************************************
*
*	@module	CTRL_Ioctl.c	|
*
*	Implements basic IOCTL entry points and their handler functions
*	for control device objects.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	CTRL_Ioctl	|
*			Any IOCTL call to the Control Device Object gets
*			filtered through here.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_CTRL_IOCTL_C

#include <WDM.H>
#include <basetyps.h>
#include <initguid.h>
#include "GckShell.h"
#include "debug.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

//---------------------------------------------------------------------------
// Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, GCK_CTRL_Ioctl)
#pragma alloc_text (PAGE, GCK_FindDeviceObject)
#pragma alloc_text (PAGE, GCK_FindDeviceObject)
#endif

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_Ioctl (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@mfunc	Handles all IOCTL's to the control object
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_CTRL_Ioctl 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp	// @parm pointer to IRP
)
{
	NTSTATUS			NtStatus = STATUS_SUCCESS;
	PGCK_CONTROL_EXT	pControlExt;
	PIO_STACK_LOCATION	pIrpStack;
	PVOID				pvIoBuffer;
	ULONG				uInLength;
	ULONG				uOutLength;
	ULONG				uIoctl;
	PDEVICE_OBJECT		pFilterHandle;
	PULONG				puHandle;
	PGCK_FILTER_EXT		pFilterExt;
	PDEVICE_OBJECT		pCurDeviceObject;
	BOOLEAN				bCompleteRequest = TRUE;
	
	
	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Ioctl, pDeviceObject = 0x%0.8x, pIRP = 0x%0.8x\n", pDeviceObject, pIrp));

	//
	//	Get all the inputs we need
	//
	pControlExt = (PGCK_CONTROL_EXT) pDeviceObject->DeviceExtension;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
	uIoctl = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	uInLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	//
	// Assume we will succeed with no data, we will change if necessary
	// later
	//
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	
	if(IOCTL_GCK_GET_HANDLE == uIoctl)
	{
		//
		// Check buffer size
		//
		if( uOutLength < sizeof(PVOID) )
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
			NtStatus = STATUS_BUFFER_TOO_SMALL;
			goto complete_and_return;
		}
		
		//
		// Get handle (device extension) of requested device
		//
		pFilterHandle = GCK_FindDeviceObject( (LPWSTR)pvIoBuffer, uInLength );
		
		//
		// If we couldn't find the handle,
		// it must have been a bad path,
		// so return invalid parameter
		//
		if( NULL == pFilterHandle)
		{
			pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
			NtStatus = STATUS_INVALID_PARAMETER;
			goto complete_and_return;	
		}
		
		//
		// copy handle into user buffer
		//
		puHandle = (ULONG *)pvIoBuffer;
		*puHandle = (ULONG)pFilterHandle;
		GCK_DBG_TRACE_PRINT(("Returning 0x%0.8x as handle.\n", *puHandle));
		pIrp->IoStatus.Information = sizeof(ULONG);

		GCKF_ResetKeyboardQueue(pFilterHandle);

		goto complete_and_return;
	}	

//DEBUG only IOCTL to allow changing debug level
#if	(DBG==1)	
	if(IOCTL_GCK_SET_MODULE_DBG_LEVEL == uIoctl)
	{
		ASSERT(uInLength >= sizeof(ULONG)*2);
		//Reusing the name handle which is a misnomer
		puHandle = (ULONG *)pvIoBuffer;
		//first parameter is the module ID, the second is the flags
		SetDebugLevel(puHandle[0], puHandle[1]);
		goto complete_and_return;
	}
#endif
	

	//
	//	If the call is not IOCTL_GCK_GET_HANDLE, we expect the first byte to be the handle
	//
	
	//
	//	Check that the inlength is at least large enough
	//	for a handle PGCK_FILTER_EXT.
	//
	if( uInLength < sizeof(PGCK_FILTER_EXT) )
	{
		pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
		NtStatus = STATUS_INVALID_PARAMETER;
		goto complete_and_return;
	}
	
	//
	//	Get the extension, and the DeviceObject itself
	//
	pFilterHandle = *((PDEVICE_OBJECT *)pvIoBuffer);
	GCK_DBG_TRACE_PRINT(("Filter Handle = 0x%0.8x\n", pFilterHandle));
	
	//
	//	Make sure the device object is in our linked list
	//	*** Do not dereference it, until we know it is in the list ***
	//	*** If it is not in the list it may be garbage ***
	pCurDeviceObject = Globals.pFilterObjectList;
	while ( pCurDeviceObject )
	{
		if( pCurDeviceObject == pFilterHandle ) break;
		pCurDeviceObject = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
	}
	if(!pCurDeviceObject)
	{
		GCK_DBG_ERROR_PRINT(("Filter Handle, 0x%0.8x, is not valid\n", pFilterHandle));
		pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
		NtStatus = STATUS_INVALID_PARAMETER;
		goto complete_and_return;
	}
	
	//
	// Get the device extension
	//
	pFilterExt = pFilterHandle->DeviceExtension;
	ASSERT(GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
	if( 
		GCK_STATE_STARTED != pFilterExt->eDeviceState &&
		GCK_STATE_STOP_PENDING != pFilterExt->eDeviceState
	)
	{
		GCK_DBG_ERROR_PRINT(("Device is stopped or removed or \n"));
		pIrp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
		NtStatus = STATUS_DEVICE_NOT_CONNECTED;  //Causes ERROR_NOT_READY at Win32 level
		goto complete_and_return;
	}
	//
	// Determine which IOCTL and handle it
	//
	switch(uIoctl)
	{
		case IOCTL_GCK_SEND_COMMAND:
			NtStatus = GCKF_ProcessCommands
						(
							pFilterExt,
							((PCHAR)pvIoBuffer) + sizeof(PDEVICE_OBJECT),  //skip the handle
							uInLength-sizeof(PDEVICE_OBJECT),
							TRUE
						);
			pIrp->IoStatus.Status = NtStatus;
			break;
		case IOCTL_GCK_SET_INTERNAL_POLLING:
		{
			if( uInLength < sizeof(GCK_SET_INTERNAL_POLLING_DATA) )
			{
				NtStatus = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				GCK_IP_FullTimePoll(pFilterExt, ((PGCK_SET_INTERNAL_POLLING_DATA)pvIoBuffer)->fEnable);
			}
			break;		
		}
		case IOCTL_GCK_ENABLE_TEST_KEYBOARD:
		{
			if( uInLength < sizeof(GCK_ENABLE_TEST_KEYBOARD) )
			{
				NtStatus = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				NtStatus = GCKF_EnableTestKeyboard(pFilterExt, ((PGCK_ENABLE_TEST_KEYBOARD)pvIoBuffer)->fEnable, pIrpStack->FileObject);
			}
			break;		
		}
		case IOCTL_GCK_BEGIN_TEST_SCHEME:
			NtStatus = GCKF_BeginTestScheme
						(
							pFilterExt,
							((PCHAR)pvIoBuffer) + sizeof(PDEVICE_OBJECT),  //skip the handle
							uInLength-sizeof(PDEVICE_OBJECT),
							pIrpStack->FileObject
						);
			ASSERT(NT_SUCCESS(NtStatus));
			break;
		case IOCTL_GCK_UPDATE_TEST_SCHEME:
			NtStatus = GCKF_UpdateTestScheme
						(
							pFilterExt,
							((PCHAR)pvIoBuffer) + sizeof(PDEVICE_OBJECT),  //skip the handle
							uInLength-sizeof(PDEVICE_OBJECT),
							pIrpStack->FileObject
						);
			ASSERT(NT_SUCCESS(NtStatus));
			break;
		case IOCTL_GCK_END_TEST_SCHEME:
			NtStatus = GCKF_EndTestScheme(pFilterExt, pIrpStack->FileObject);
			ASSERT(NT_SUCCESS(NtStatus));
			break;
		case IOCTL_GCK_BACKDOOR_POLL:
			if( uInLength < sizeof(GCK_BACKDOOR_POLL_DATA) )
			{
				NtStatus = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				//Polling is asynchronous and the filter will deal with that,
				//It is extremely important that we just return the status returned by the backdoor poll routine,
				//and not complete the IRP
				NtStatus = GCKF_BackdoorPoll(pFilterExt, pIrp, ((PGCK_BACKDOOR_POLL_DATA)pvIoBuffer)->ePollingMode);
				
				//Make sure a poll is pending to the actual hardware
				GCK_IP_OneTimePoll(pFilterExt);
				ASSERT(NT_SUCCESS(NtStatus));
				return NtStatus;
			}
			break;
		case IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE:		// Queue up IOCTL
			NtStatus = GCKF_IncomingForceFeedbackChangeNotificationRequest(pFilterExt, pIrp);
			if (!NT_SUCCESS(NtStatus))
			{	// Failed, IOCTL is completed below
				pIrp->IoStatus.Status = NtStatus;
			}
			else
			{	// Success, IOCTL was queued - don't complete
				bCompleteRequest = FALSE;
			}
			break;
		case IOCTL_GCK_END_FF_NOTIFICATION:			// Complete the Queued FF Ioctls
			NtStatus = pIrp->IoStatus.Status = GCKF_ProcessForceFeedbackChangeNotificationRequests(pFilterExt);
			break;
		case IOCTL_GCK_GET_FF_SCHEME_DATA:
			NtStatus = GCKF_GetForceFeedbackData(pIrp, pFilterExt);
			break;
		case IOCTL_GCK_SET_WORKINGSET:
			NtStatus = GCKF_SetWorkingSet(pFilterExt, ((GCK_SET_WORKINGSET*)pvIoBuffer)->ucWorkingSet);
			break;
		case IOCTL_GCK_QUERY_PROFILESET:
			NtStatus = GCKF_QueryProfileSet(pIrp, pFilterExt);
			break;
		case IOCTL_GCK_LED_BEHAVIOUR:
			NtStatus = GCKF_SetLEDBehaviour(pIrp, pFilterExt);
			break;
		case IOCTL_GCK_TRIGGER:
			if ((uInLength < sizeof(GCK_TRIGGER_OUT)) || (uOutLength < sizeof(ULONG)))
			{
				NtStatus = pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
			}
			else
			{
				NtStatus = GCKF_TriggerRequest(pIrp, pFilterExt);
				if (!NT_SUCCESS(NtStatus))
				{	// Failed, IOCTL is completed below
					pIrp->IoStatus.Status = NtStatus;
				}
				else
				{	// Success, IOCTL was queued (or completed) - don't complete here
					bCompleteRequest = FALSE;
				}
			}
			break;
		case IOCTL_GCK_GET_CAPS:
		case IOCTL_GCK_ENABLE_DEVICE:
		default:
			pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
			NtStatus = STATUS_NOT_SUPPORTED;
			GCK_DBG_WARN_PRINT( ("Unknown IOCTL: 0x%0.8x\n", uIoctl) );
	}

complete_and_return:
	if (bCompleteRequest != FALSE)
	{
		// pIrp->IoStatus.Status = NtStatus;	-- This might be nice investigate
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_ControlIoctl(2), Status: 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	PDEVICE_OBJECT GCK_FindDeviceObject(IN PWSTR pwszInterfaceReq, IN ULONG uInLength)
**
**	@mfunc	Given a Win32 HID interface finds the corresponding PDO among the filter devices
**
**	@rdesc	pointer to the PDO on success, NULL if a match is not found
**
*************************************************************************************/
PDEVICE_OBJECT GCK_FindDeviceObject
(
	IN PWSTR pwszInterfaceReq,	// @parm pointer to Win32 interface name
	IN ULONG uInLength			// @parm length of interface string
)
{
	NTSTATUS NtStatus;
	PWSTR pInterfaces;
	ULONG uIndex;
	ULONG uStringLen;
	BOOLEAN fMatchFound;
	PDEVICE_OBJECT pCurDeviceObject;
	ULONG uInWideChars;
		
	PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_FindDeviceObject, pwszInterfaceReq = %ws, uInLength = %d\n", pwszInterfaceReq, uInLength));
	//
	//	Get length of string including NULL, but don't overrun uInLength
	//
	uIndex = 0;
	uStringLen = 0;
	uInWideChars = uInLength/2;		// uInLength is the number of BYTES not WideChars
	while( uIndex < uInWideChars )
	{
		if( 0 == pwszInterfaceReq[uIndex++]  ) 
		{
			uStringLen = uIndex;
			break;
		}
	}


	//
	//	if the string is not terminated or if it is a NULL string, return NULL for the device.
	//	plus every string starts with "\\.\" plus at least two or more chars
	//
	if( 6 > uStringLen ) return NULL; 
	
	//
	// Walk through all known devices
	//
	pCurDeviceObject = Globals.pFilterObjectList;
	while ( pCurDeviceObject )
	{
		//
		//	Get the interfaces for the PDO
		//
		NtStatus = IoGetDeviceInterfaces(
			(LPGUID)&GUID_CLASS_INPUT,
			FILTER_DEVICE_OBJECT_PDO(pCurDeviceObject),
			0,
			&pInterfaces
			);
		
		//
		//	If we have got the interfaces, then look for match
		//
		if( STATUS_SUCCESS == NtStatus )
		{
				fMatchFound=GCK_MatchReqPathtoInterfaces(pwszInterfaceReq, uStringLen, pInterfaces);
				ExFreePool(pInterfaces);
				if(fMatchFound)
				{
					GCK_DBG_EXIT_PRINT(("Exiting GCK_FindDeviceObject - match found returning 0x%0.8x\n", pCurDeviceObject));
					return pCurDeviceObject;
				}
		}
		
		//
		// Advance to next known device
		//
		pCurDeviceObject = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
	}

	//
	//	If we are here, there is no match
	//
	GCK_DBG_EXIT_PRINT(("Exiting GCK_FindDeviceObject - no match found returning NULL\n"));
	return NULL;
}

#define UPPERCASE(_x_) (((L'a'<=_x_) && (L'z'>=_x_)) ? ((_x_) - (L'a'-L'A')) : _x_)
/***********************************************************************************
**
**	BOOLEAN GCK_MatchReqPathtoInterfaces(IN PWSTR pwszPath, IN ULONG uStringLen, IN PWSTR pmwszInterfaces)
**
**	@mfunc	Determines if a Win32 Path matches any of the Interfaces.  This replaces a match between
**			String and a Multi-String.  The previous was not sufficient (even though the caller tried
**			to compensate.)  The new algorithm is to find the last '\\' in each string before comparing
**			them.  It is still a string against any of a multi-string though.
**
**	@rdesc	TRUE if a match is found, FALSE otherwise
**
*************************************************************************************/
BOOLEAN GCK_MatchReqPathtoInterfaces
(
	IN PWSTR pwszPath,	// @parm String to find match
	IN ULONG uStringLen,	// @parm length of string in WCHARs
	IN PWSTR pmwszInterfaces	// @parm MutliString
)
{
		PWSTR pwszCurInterface;
		PWSTR pwszPathInterface;
		ULONG uCharIndex;
		ULONG uCurIntefaceLen;
		ULONG uDiff;
		
		GCK_DBG_ENTRY_PRINT(("Entering GCK_MatchReqPathtoInterfaces, pwszPath = \'%ws\'\n, uStringLen = %d, pmwszStrings = \'%ws\'", pwszPath, uStringLen, pmwszInterfaces));

		//
		//	Find last '\\' in pwszPath and set pszPathInterface to the next character
		//
		pwszPathInterface = pwszPath;
		uCharIndex = 0;
		while( pwszPathInterface[uCharIndex] && (uCharIndex != uStringLen)) uCharIndex++;	//go to end
		while( uCharIndex && (L'\\' != pwszPathInterface[uCharIndex]) ) uCharIndex--;		//go to last '\\'
		ASSERT(uCharIndex < uStringLen);
		pwszPathInterface += uCharIndex+1;	//skip last '\\'
		
		GCK_DBG_TRACE_PRINT(("Path to compare is %ws\n", pwszPathInterface));

		//
		//	check if the szString matches any of the strings in mszStrings
		//
		pwszCurInterface = pmwszInterfaces;
		
		//
		//	Loop over all strings in pmwszStrings
		//
		do
		{
			//Find last '\\'
			uCharIndex = 0;
			while( pwszCurInterface[uCharIndex]) uCharIndex++;								//go to end
			uCurIntefaceLen = uCharIndex;													//save string length
			while( uCharIndex && (L'\\' != pwszCurInterface[uCharIndex]) ) uCharIndex--;	//go to last '\\'
			pwszCurInterface += uCharIndex+1;
			uCurIntefaceLen -= uCharIndex+1;	//length after we skip some stuff

			GCK_DBG_TRACE_PRINT(("Comparing path with %ws\n", pwszCurInterface));

			//
			// look for differences in each string.
			//
			uCharIndex = 0;
			uDiff = 0;
			do
			{
				//
				//	Check if characters match
				//
				if( UPPERCASE(pwszCurInterface[uCharIndex]) != UPPERCASE(pwszPathInterface[uCharIndex]) )
				{
					uDiff++;	//increment number of differences
					break;		//One difference is enough
				}
			} while( (pwszCurInterface[uCharIndex] != 0) && (pwszCurInterface[uCharIndex++] != '}') );

			//
			//	Check for match
			//
			if( 0 == uDiff )
			{
				GCK_DBG_EXIT_PRINT(("Exiting GCK_MatchReqPathtoInterfaces - match found returning TRUE\n"));
				return TRUE;
			}
						
			//
			// move to the next string in list
			//
			pwszCurInterface += uCurIntefaceLen;
		} while(pwszCurInterface[0] != 0);  //continue while there are more strings

 		//
		// if we fell out we didn't find a match
		//
		GCK_DBG_EXIT_PRINT(("Exiting GCK_MatchReqPathtoInterfaces - no match found returning FALSE\n"));
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dumpcommandblock.cpp ===
//When invoked from WDM makefile the debug condition is different
#ifdef COMPILE_FOR_WDM_KERNEL_MODE
#if (DBG==1)
#undef _NDEBUG
#else
#define _NDEBUG
#endif
#endif

//
//  This entire module is debug only
//
#ifndef _NDEBUG
#define __DEBUG_MODULE_IN_USE__ CIC_DUMPCOMMANDBLOCK_CPP
#include "stdhdrs.h"
#include <stdio.h>
#include "Actions.h"
#include "DumpCommandBlock.h"

//----------------------------------------------------
//  Global variables
//----------------------------------------------------
PFNSTRING_DUMP_FUNC CDumpItem::ms_pfnDumpFunc = NULL;
static PFNSTRING_DUMP_FUNC g_pfnDumpFunc = NULL;
CControlItemCollection<CDumpItem> *g_pDumpCollection = NULL;
static char GlobalTempBuffer[1024];

const	ULONG XDF_Trigger	= 1;
const	ULONG XDF_Event		= 2;

//-----------------------------------------------------------------------------------------
// Interface Functions - Implementation
//-----------------------------------------------------------------------------------------

BOOLEAN DumpCommandBlock(PUCHAR pucBlock, ULONG ulSize)
{
	BOOLEAN fRetVal = DumpRecurse(pucBlock, ulSize, 0);
	DumpString("///////////////End of Dump//////////////////\n");
	return fRetVal;
}

void SetDumpFunc(PFNSTRING_DUMP_FUNC pfnDumpFunc)
{
	g_pfnDumpFunc = pfnDumpFunc;
	CDumpItem::SetDumpFunc(pfnDumpFunc);
}

void InitDumpModule(ULONG ulVidPid)
{
	//Initializing to new VidPid - destroy the existing one
	if(g_pDumpCollection)
	{
		delete g_pDumpCollection;
	}
	g_pDumpCollection = new WDM_NON_PAGED_POOL CControlItemCollection<CDumpItem>(ulVidPid, &DumpItemFactory);
	if(!g_pDumpCollection)
	{
		DumpString("ERROR: Couldn't create Dump Collection, won't be able to give detailed Xfer info.\n");
	}
}

//-----------------------------------------------------------------------------------------
// Internal functions - Implementation
//-----------------------------------------------------------------------------------------
void DumpString(LPSTR lpszDumpString)
{
	if(g_pfnDumpFunc)
	{
		g_pfnDumpFunc(lpszDumpString);
	}
	else
	{
		DCB_TRACE(lpszDumpString);
	}
}


BOOLEAN DumpDirectory(PUCHAR pucBlock, ULONG ulSize)
{
	PCOMMAND_DIRECTORY pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pucBlock);
	
	//	Check the type
	if( eDirectory != pCommandDirectory->CommandHeader.eID )
	{
		sprintf(GlobalTempBuffer, "ERROR: Expecting eDirectory\n");
		DumpString(GlobalTempBuffer);
		return FALSE;
	}
	//	Check the size
	if ( ulSize < pCommandDirectory->ulEntireSize  )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation, %d bytes expected, %d allocated.\n", pCommandDirectory->ulEntireSize, ulSize);
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}
	// Dump the Directory information
	sprintf(GlobalTempBuffer, "///////eDirectory/////////////////////////////////////////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "    eID: %x\n",pCommandDirectory->CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "    ulByteSize: %d\n",pCommandDirectory->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulEntireSize: %d\n",pCommandDirectory->ulEntireSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "NumEntries: %d\n",pCommandDirectory->usNumEntries);
	DumpString(GlobalTempBuffer);
	return TRUE;
}


// Just What kind of command is this
BOOLEAN DumpAssignmentTarget(PUCHAR pucBlock, ULONG ulSize)
{
	
	PASSIGNMENT_TARGET pAssignmentTarget = reinterpret_cast<PASSIGNMENT_TARGET> (pucBlock);
	//	Check the size
	if ( ulSize < pAssignmentTarget->CommandHeader.ulByteSize )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation\n");
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}

	switch( pAssignmentTarget->CommandHeader.eID )
	{
		case eBehaviorAction:
			sprintf(GlobalTempBuffer, "////////////////////////eBehaviorAction////////\n");
			break;
		case eRecordableAction:
			sprintf(GlobalTempBuffer, "////////////////////////eRecordableAction////////\n");
			break;
		default:
			return FALSE;
	}

	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "    ulByteSize: %d\n",pAssignmentTarget->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	return DumpTriggerXfer(&pAssignmentTarget->cixAssignment);
}

BOOLEAN DumpTimedMacro(PUCHAR pucBlock, ULONG ulSize)
{
	PTIMED_MACRO pTimedMacro = reinterpret_cast<PTIMED_MACRO>(pucBlock);
	PASSIGNMENT_BLOCK pAssBlock = &pTimedMacro->AssignmentBlock ;
	ULONG ulCurrentEvent = 0;
	PTIMED_EVENT pCurrentEvent = NULL;
	sprintf(GlobalTempBuffer, "/////////////////////////////////Timed Macro////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pAssBlock->CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pAssBlock->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pAssBlock->ulVidPid);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulFlags: %x\n",pTimedMacro->ulFlags);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulEventCount: %x\n",pTimedMacro->ulEventCount);
	DumpString(GlobalTempBuffer);

	if ( ulSize < pAssBlock->CommandHeader.ulByteSize  )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation\n");
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}
	while ( pCurrentEvent = pTimedMacro->GetNextEvent(pCurrentEvent, ulCurrentEvent))
	{
		if (!DumpTimedEvent( pCurrentEvent))
			return FALSE;
	}
	return TRUE;
}

BOOLEAN DumpKeyString(PUCHAR pucBlock, ULONG ulSize)
{
	PKEYSTRING_MAP pKeyStringMap = reinterpret_cast<PKEYSTRING_MAP> (pucBlock) ;
	PASSIGNMENT_BLOCK pAssBlock = &pKeyStringMap->AssignmentBlock ;
	ULONG ulEvent = 0;
	PEVENT pEvent = NULL;
	sprintf(GlobalTempBuffer, "/////////////////////////////////Key String/////////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pAssBlock->CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pAssBlock->CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pAssBlock->ulVidPid);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulFlags: %x\n",pKeyStringMap->ulFlags);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulEventCount: %x\n",pKeyStringMap->ulEventCount);
	DumpString(GlobalTempBuffer);

	if ( ulSize < pKeyStringMap->AssignmentBlock.CommandHeader.ulByteSize  )
	{
		sprintf(GlobalTempBuffer, "ERROR: Buffer Size Allocation\n");
		DumpString(GlobalTempBuffer);
		return FALSE ;
	}
	while ( pEvent = pKeyStringMap->GetNextEvent(pEvent, ulEvent))
	{
		if (!DumpEvent( pEvent))
			return FALSE;
	}
	return TRUE;
}

BOOLEAN DumpMouseFxAxisMap(PUCHAR pucBlock, ULONG ulSize)
{
	PMOUSE_FX_AXIS_MAP pMouseFxAxisMap = (PMOUSE_FX_AXIS_MAP)pucBlock;
	ASSERT(ulSize == sizeof(MOUSE_FX_AXIS_MAP));
	
	sprintf(GlobalTempBuffer, "/////////////////////////////////MouseFxAxisMap////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pMouseFxAxisMap->AssignmentBlock.CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pMouseFxAxisMap->AssignmentBlock.CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pMouseFxAxisMap->AssignmentBlock.ulVidPid);
	DumpString(GlobalTempBuffer);
	if(pMouseFxAxisMap->fIsX)
	{
		DumpString("X Axis\n");
	}
	else
	{
		DumpString("Y Axis\n");
	}
	sprintf(GlobalTempBuffer, "Model Parameters:\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulAbsZoneSense    = %d\n", pMouseFxAxisMap->AxisModelParameters.ulAbsZoneSense);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulContZoneMaxRate = %d\n", pMouseFxAxisMap->AxisModelParameters.ulContZoneMaxRate);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulPulseWidth      = %d\n", pMouseFxAxisMap->AxisModelParameters.ulPulseWidth);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulPulsePeriod     = %d\n", pMouseFxAxisMap->AxisModelParameters.ulPulsePeriod);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulInertiaTime     = %d\n", pMouseFxAxisMap->AxisModelParameters.ulInertiaTime);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulAcceleration    = %d\n", pMouseFxAxisMap->AxisModelParameters.ulAcceleration);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "fAccelerate       = %s\n", ((pMouseFxAxisMap->AxisModelParameters.fPulse) ? "T" : "F"));
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "fPulse            = %s\n", ((pMouseFxAxisMap->AxisModelParameters.fPulse) ? "T" : "F"));
	DumpString(GlobalTempBuffer);
	return TRUE;
}

/*
typedef struct tagAXIS_MAP
{
	ASSIGNMENT_BLOCK	AssignmentBlock;	//eAxisMap is the type
	LONG				lCoefficient1024x;	//A mapping coeffiecient times 1024 (should be between -1024 and 1024)
	CONTROL_ITEM_XFER	cixDestinationAxis; //Axis to map to.
} AXIS_MAP, *PAXIS_MAP;
*/


BOOLEAN DumpAxisMap(PUCHAR pucBlock, ULONG ulSize)
{
	PAXIS_MAP pAxisMap = (PAXIS_MAP)pucBlock;
	ASSERT(ulSize == sizeof(AXIS_MAP));
	
	sprintf(GlobalTempBuffer, "/////////////////////////////////AxisMap////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pAxisMap->AssignmentBlock.CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pAxisMap->AssignmentBlock.CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n",pAxisMap->AssignmentBlock.ulVidPid);
	DumpString(GlobalTempBuffer);
	/*
	if(pMouseFxAxisMap->fIsX)
	{
		DumpString("X Axis\n");
	}
	else
	{
		DumpString("Y Axis\n");
	}
	*/
	sprintf(GlobalTempBuffer, "Model Parameters:\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "lCoefficient1024x    = %d\n", pAxisMap->lCoefficient1024x);
	DumpString(GlobalTempBuffer);

	if(!DumpEventXfer(&pAxisMap->cixDestinationAxis))
		return FALSE;

	return TRUE;
}

BOOLEAN DumpForceMap(PUCHAR pucBlock, ULONG ulSize)
{
	FORCE_BLOCK* pForceMap = (FORCE_BLOCK*)pucBlock;
	ASSERT(ulSize == sizeof(FORCE_BLOCK));
	
	sprintf(GlobalTempBuffer, "/////////////////////////////////ForceMap////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Assignment Block: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   Command Header: \n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      eID: %x\n",pForceMap->AssignmentBlock.CommandHeader.eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n",pForceMap->AssignmentBlock.CommandHeader.ulByteSize);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "   VidPid: %x\n", pForceMap->AssignmentBlock.ulVidPid);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Force Map Parameters:\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "bMapYToX    = %d\n", pForceMap->bMapYToX);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "usRTC    = %d\n", pForceMap->usRTC);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "usGain    = %d\n", pForceMap->usGain);
	DumpString(GlobalTempBuffer);

	return TRUE;
}

BOOLEAN DumpUnknown(PUCHAR pucBufferLocation, ULONG ulSize)
{
	COMMAND_HEADER* pHeader = (COMMAND_HEADER*)pucBufferLocation;
	sprintf(GlobalTempBuffer, "/////////////////////////////////Unknown Item////\n");
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "eID : 0x%X\n", pHeader->eID);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "      ulByteSize: %d\n", pHeader->ulByteSize);
	DumpString(GlobalTempBuffer);
	return TRUE;
}

BOOLEAN DumpTimedEvent(PTIMED_EVENT pTimedEvent)
{
	PEVENT pEvent = &pTimedEvent->Event;
	sprintf(GlobalTempBuffer,"ulDuration: %d\n",pTimedEvent->ulDuration);
	DumpString(GlobalTempBuffer);
	return DumpEvent(pEvent);
}

BOOLEAN DumpEvent(PEVENT pEvent)
{
	sprintf(GlobalTempBuffer,"ulNumXfers: %d\n",pEvent->ulNumXfers);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer,"Required bytes: %d\n",pEvent->RequiredByteSize( pEvent->ulNumXfers));
	DumpString(GlobalTempBuffer);
	
	ULONG ulXferIndex;
	for(ulXferIndex=0; ulXferIndex < pEvent->ulNumXfers; ulXferIndex++)
	{
		sprintf(GlobalTempBuffer, "Dumping Xfer #%d\n", ulXferIndex);
		DumpString(GlobalTempBuffer);
		if(!DumpEventXfer(&pEvent->rgXfers[ulXferIndex]))
			return FALSE;
	}
	return TRUE;
}

#define SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader)\
	(reinterpret_cast<PCOMMAND_HEADER>\
		( reinterpret_cast<PUCHAR>(pCommandHeader) +\
		reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize )\
	)

#define SKIP_TO_NEXT_COMMAND_DIRECTORY(pCommandDirectory)\
	(reinterpret_cast<PCOMMAND_DIRECTORY>\
		(reinterpret_cast<PUCHAR>(pCommandDirectory) +\
		pCommandDirectory->ulEntireSize)\
	)
	
#define COMMAND_BLOCK_FITS_IN_DIRECTORY(pCommandDirectory, pCommandHeader)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandDirectory) -	reinterpret_cast<PUCHAR>(pCommandHeader)) +\
					reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize\
				)\
		)
#define COMMAND_DIRECTORY_FITS_IN_DIRECTORY(pCommandDirectory, pCommandSubDirectory)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandDirectory) -	reinterpret_cast<PUCHAR>(pCommandHeader)) +\
					pCommandSubDirectory->ulEntireSize\
				)\
		)

BOOLEAN DumpRecurse(PUCHAR pucBlock, ULONG ulSize, ULONG ulDepth)
{
	PCOMMAND_DIRECTORY pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pucBlock);
	PCOMMAND_HEADER pCommandHeader;
	PUCHAR pucBufferLocation = pucBlock;

	//	Sanity Check
	if( eDirectory != pCommandDirectory->CommandHeader.eID )
	{
		sprintf(GlobalTempBuffer, "ERROR: Expecting eDirectory, recursion depth = %ld\n", ulDepth);
		DumpString(GlobalTempBuffer);
		return FALSE;
	}
	
	//Print out starting address of Directory
	sprintf(GlobalTempBuffer, "Next Directory starts at 0x%0.8x\n", pucBlock);
	DumpString(GlobalTempBuffer);

	//	Dump COMMAND_DIRECTORY info - this will inherently check the size
	if( !DumpDirectory(pucBlock, ulSize) )
		return FALSE;
	
	//	If there are no entries are done
	if( 0 == pCommandDirectory->usNumEntries)
	{
		sprintf(GlobalTempBuffer, "WARNING: Lowest level sub-directory with no blocks\n");
		DumpString(GlobalTempBuffer);
		return TRUE;
	}

	//	Skip Directory header to get to first block
	pCommandHeader = SKIP_TO_NEXT_COMMAND_BLOCK(pCommandDirectory);
	
	//Forget the allocate size (which we now by now is at least
	//as big as the entire size of the directory) and start using the directory size
	ulSize = pCommandDirectory->ulEntireSize;
	// Reduce the size by the size of the header
	ulSize -=  (PUCHAR)pCommandHeader - pucBufferLocation;
	pucBufferLocation = (PUCHAR)pCommandHeader;

	//Ensure that there is at least enough room for COMMAND_HEADER
	if( sizeof(COMMAND_HEADER) > ulSize)
	{
		DumpString("ERROR: Unexpected end of buffer\n");
		return FALSE;
	}
	
	//	If we have a sub-directory, call ourselves recursively, for each sub-directory
	if( eDirectory == pCommandHeader->eID)
	{
		PCOMMAND_DIRECTORY pCurDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pCommandHeader);
		USHORT usDirectoryNum = 1;
		while( usDirectoryNum <= pCommandDirectory->usNumEntries)
		{
			//Call ourselves recursively
			if( !DumpRecurse(pucBufferLocation, ulSize, ulDepth+1) )
				return FALSE;
			//Skip to next directory
			pCurDirectory = SKIP_TO_NEXT_COMMAND_DIRECTORY(pCurDirectory);

			// Reduce the size by the size of the directory just parsed
			ulSize -=  (PUCHAR)pCurDirectory - pucBufferLocation;
			pucBufferLocation = (PUCHAR)pCurDirectory;
			usDirectoryNum++;
		}
		//Nobody failed so return TRUE
		return TRUE;
	}

	//
	//	If we are here, we have reached the bottom of a directory,
	//	to a command we need to dump
	//
	USHORT usEntryNum = 1;
	while( usEntryNum  <= pCommandDirectory->usNumEntries)
	{
		//Ensure that there is at least enough room for COMMAND_HEADER
		if( sizeof(COMMAND_HEADER) > ulSize)
		{
			DumpString("ERROR: Unexpected end of buffer\n");
			return FALSE;
		}
		sprintf(GlobalTempBuffer, "Next Block starts at 0x%0.8x\n", pucBufferLocation);
		DumpString(GlobalTempBuffer);
		//Dump info about block
		switch( pCommandHeader->eID )
		{
			case eBehaviorAction:
			case eRecordableAction:
				if( !DumpAssignmentTarget(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eTimedMacro:
				if( !DumpTimedMacro(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eKeyString:
				if( !DumpKeyString(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eMouseFXAxisMap:
				if( !DumpMouseFxAxisMap(pucBufferLocation, ulSize) )
					return FALSE;
				break;
			case eAxisMap:
				if( !DumpAxisMap(pucBufferLocation, ulSize) )
					return FALSE;
				break;
#if 1
			case eForceMap:
				if( !DumpForceMap(pucBufferLocation, ulSize) )
					return FALSE;
				break;
#endif
			default:
				if ( !DumpUnknown(pucBufferLocation, ulSize) )
					return FALSE;
				break;

		}
		// skip to next block
		pCommandHeader = SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader);
		ulSize -=  (PUCHAR)pCommandHeader - pucBufferLocation;
		pucBufferLocation = (PUCHAR)pCommandHeader;
		usEntryNum++;
	}
	//we've reached the end of this directory
	return TRUE;
}

BOOLEAN DumpTriggerXfer(PCONTROL_ITEM_XFER pControlItemXfer)
{
	//Is Xfer for a keyboard
	if( NonGameDeviceXfer::IsKeyboardXfer(*pControlItemXfer) )
	{
		sprintf(GlobalTempBuffer, "ERROR: Invalid Trigger. Keyboard data encountered.\n");
		DumpString(GlobalTempBuffer);
		return FALSE;
	}
	if(g_pDumpCollection)
	{
		CDumpItem *pDumpItem;
		pDumpItem = g_pDumpCollection->GetFromControlItemXfer(*pControlItemXfer);
		if( !pDumpItem )
		{
			sprintf(GlobalTempBuffer, "ERROR: Xfer packet not supported for device.\n");
			DumpString(GlobalTempBuffer);
			return FALSE;
		}
		pDumpItem->SetItemState(*pControlItemXfer);
		pDumpItem->DumpItemInfo(XDF_Trigger);
	}
	else
	{
		sprintf(GlobalTempBuffer, "WARNING: Dump Module not initialized for device, detailed Xfer info not available.\n");
		DumpString(GlobalTempBuffer);
	}
	return TRUE;
}

BOOLEAN DumpEventXfer(PCONTROL_ITEM_XFER pControlItemXfer)
{
	//Is Xfer for a keyboard
	if( NonGameDeviceXfer::IsKeyboardXfer(*pControlItemXfer) )
	{
		DumpKeyboardData(pControlItemXfer);
		return TRUE;
	}
	if(g_pDumpCollection)
	{
		CDumpItem *pDumpItem;
		pDumpItem = g_pDumpCollection->GetFromControlItemXfer(*pControlItemXfer);
		if( !pDumpItem )
		{
			sprintf(GlobalTempBuffer, "ERROR: Xfer packet not supported for device.\n");
			DumpString(GlobalTempBuffer);
			return FALSE;
		}
		pDumpItem->SetItemState(*pControlItemXfer);
		pDumpItem->DumpItemInfo(XDF_Event);
	}
	else
	{
		sprintf(GlobalTempBuffer, "WARNING: Dump Module not initialized for device, detailed Xfer info not available.\n");
		DumpString(GlobalTempBuffer);
	}
	return TRUE;
}

void CDumpItem::DumpItemInfo(ULONG ulDumpFlags)
{
	DumpString("ERROR: Should never be called!\n");
}

void CAxesDump::DumpItemInfo(ULONG ulDumpFlags)
{
	// Read data
	LONG lValX, lValY;
	GetXY( lValX, lValY);

	if(XDF_Event == ulDumpFlags)
	{
		sprintf(GlobalTempBuffer, "AXES: X = %d, Y = %d\n", lValX, lValY);
	}
	else if(XDF_Trigger == ulDumpFlags)
	{
		if( lValX )
		{
			sprintf(GlobalTempBuffer, "AXES: Assign to X\n");
		}
		else if (lValY)
		{
			sprintf(GlobalTempBuffer, "AXES: Assign to Y\n");
		}
		else
		{
			sprintf(GlobalTempBuffer, "AXES: Invalid Assignment\n");
		}
	}
	DumpString(GlobalTempBuffer);
}

void CDPADDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lDirection;
	GetDirection(lDirection);

	sprintf(GlobalTempBuffer, "DPAD: Direction = %d\n", lDirection);
	DumpString(GlobalTempBuffer);
}

void CPropDPADDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lDirection;
	GetDirection(lDirection);

	sprintf(GlobalTempBuffer, "DPAD: Direction = %d\n", lDirection);
	DumpString(GlobalTempBuffer);
}

void CButtonsDump::DumpItemInfo(ULONG ulDumpFlags)
{
	USHORT	usButtonNum;
	ULONG	ulButtonBitArray;
	GetButtons( usButtonNum, ulButtonBitArray );
	if(XDF_Event == ulDumpFlags)
	{
		sprintf(GlobalTempBuffer, "BUTTONS: BitArray = 0x%0.8x, ButtonNum = %d\n", ulButtonBitArray, (ULONG)usButtonNum);
    }                                                                                                                     
	else if(XDF_Trigger == ulDumpFlags)
	{
		sprintf(GlobalTempBuffer, "BUTTONS: ButtonNum = %d MODIFIERS = %d\n", (ULONG)usButtonNum, GetNumModifiers());
	}
	DumpString(GlobalTempBuffer);
}

void CPOVDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lDirection;
	GetValue(lDirection);
	sprintf(GlobalTempBuffer, "POV: Direction = %d\n", lDirection);
	DumpString(GlobalTempBuffer);
}

void CThrottleDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "THROTTLE: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CRudderDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "RUDDER: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CWheelDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "WHEEL: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CPedalDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	LONG lVal;
	GetValue(lVal);
	sprintf(GlobalTempBuffer, "PEDAL: Value = %d\n", lVal);
	DumpString(GlobalTempBuffer);
}

void CZoneIndicatorDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
	if( GetXIndicator() )
	{
		DumpString("ZoneIndicator: X is set\n");
	}
	if( GetYIndicator() )
	{
		DumpString("ZoneIndicator: X is set\n");
	}
}

void CDualZoneIndicatorDump::DumpItemInfo(ULONG ulDumpFlags)
{
    UNREFERENCED_PARAMETER(ulDumpFlags);
    static char* s_pszXY = "XY";
    static char* s_pszRz = "Rz";
    char *psz;
    if( IsXYIndicator() )
    {
        psz = s_pszXY;        
    }
    else if( IsRzIndicator() )
    {
        psz = s_pszRz;
    }
    else
        psz = "Unknown Zone";
  	sprintf(GlobalTempBuffer, "DualZoneIndicator (XY:%d/%d)\n", GetActiveZone(), GetNumZones());
    DumpString (GlobalTempBuffer);
}

void CForceMapDump::DumpItemInfo(ULONG ulDumpFlags)
{
	UNREFERENCED_PARAMETER(ulDumpFlags);
    CHAR szBuf[0x100];

    sprintf (szBuf, "MapYToX: %s\n", GetMapYToX() ? "ON" : "OFF");
    DumpString (szBuf);

    sprintf (szBuf, "RTC:     %d\n", GetRTC());
    DumpString (szBuf);

    sprintf (szBuf, "Gain:    %d\n", GetGain());
    DumpString (szBuf);
}


HRESULT	DumpItemFactory
(
	USHORT usType,	
	const CONTROL_ITEM_DESC* cpControlItemDesc,
	CDumpItem				**ppControlItem
)
{
	HRESULT hr = S_OK;
	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppControlItem = new WDM_NON_PAGED_POOL CAxesDump(cpControlItemDesc);
			break;
		case ControlItemConst::usDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CDPADDump(cpControlItemDesc);
			break;
		case ControlItemConst::usPropDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CPropDPADDump(cpControlItemDesc);
			break;
		case ControlItemConst::usWheel:
			*ppControlItem= new WDM_NON_PAGED_POOL CWheelDump(cpControlItemDesc);
			break;
		case ControlItemConst::usPOV:
			*ppControlItem = new WDM_NON_PAGED_POOL CPOVDump(cpControlItemDesc);
			break;
		case ControlItemConst::usThrottle:
			*ppControlItem = new WDM_NON_PAGED_POOL CThrottleDump(cpControlItemDesc);
			break;
		case ControlItemConst::usRudder:
			*ppControlItem = new WDM_NON_PAGED_POOL CRudderDump(cpControlItemDesc);
			break;
		case ControlItemConst::usPedal:
			*ppControlItem = new WDM_NON_PAGED_POOL CPedalDump(cpControlItemDesc);
			break;
		case ControlItemConst::usButton:
			*ppControlItem = new WDM_NON_PAGED_POOL CButtonsDump(cpControlItemDesc);
			break;
		case ControlItemConst::usZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CZoneIndicatorDump(cpControlItemDesc);
			break;
		case ControlItemConst::usDualZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CDualZoneIndicatorDump(cpControlItemDesc);
			break;
		case ControlItemConst::usForceMap:
			*ppControlItem = new WDM_NON_PAGED_POOL CForceMapDump(cpControlItemDesc);
			break;
		default:
			*ppControlItem = NULL;
			return S_FALSE;
	}
	if(!*ppControlItem)
	{
		return E_FAIL;
	}
	return S_OK;
}

BOOLEAN DumpKeyboardData(PCONTROL_ITEM_XFER pControlItemXfer)
{
	sprintf(GlobalTempBuffer, "Keyboard.ucModifier = 0x%0.8x\n",  (ULONG)pControlItemXfer->Keyboard.ucModifierByte);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[0] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[0]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[1] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[1]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[2] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[2]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[3] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[3]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[4] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[4]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "Keyboard.rgucKeysDown[5] = 0x%0.8x\n", (ULONG)pControlItemXfer->Keyboard.rgucKeysDown[5]);
	DumpString(GlobalTempBuffer);
	sprintf(GlobalTempBuffer, "ulModifiers = 0x%0.8x\n", pControlItemXfer->ulModifiers);
	DumpString(GlobalTempBuffer);
	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\ctrl.c ===
//	@doc
/**********************************************************************
*
*	@module	CTRL.c	|
*
*	Entry points for handling IRPs to the "Control" device object.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	CTRL	|
*	The control device object is used for programming GcKernel.
*	The main module, GckShell, delegates IRPs aimed at the control device
*	here.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_CTRL_C

#include <wdm.h>
#include <gckshell.h>
#include "debug.h"

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, GCK_CTRL_DriverEntry)
#pragma alloc_text (PAGE, GCK_CTRL_Create)
#pragma alloc_text (PAGE, GCK_CTRL_Close)
#pragma alloc_text (PAGE, GCK_CTRL_Unload)
#endif

//	Allow debug output for this module, and set the intial level
DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL) );

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Initializing the portions of the driver related to the control device, actually
**			All of this was added to GCK_CTRL_AddDevice, which is called when the first filter
**			device is added.
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_CTRL_DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{
    UNREFERENCED_PARAMETER (puniRegistryPath);
	UNREFERENCED_PARAMETER (pDriverObject);
	
	PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_DriverEntry\n"));
    
	//
	//	Initialize Globals
	//
	GCK_DBG_TRACE_PRINT(("Initializing CTRL globals\n"));
	Globals.pControlObject = NULL;
	

	GCK_DBG_EXIT_PRINT (("Exiting GCK_CTRL_DriverEntry: STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_AddDevice( IN PDRIVER_OBJECT  pDriverObject )
**
**	@func	Adds a Control Device.  Called from GCK_FLTR_AddDevice when the first
**			Device is added.
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS
GCK_CTRL_AddDevice
(
	IN PDRIVER_OBJECT  pDriverObject
)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT      pDeviceObject;
	UNICODE_STRING      uniNtNameString;
    UNICODE_STRING      uniWin32NameString;
	PGCK_CONTROL_EXT	pControlExt;
        
    PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_AddDevice\n"));
    
	//
    // Create a controlling device object.  All control commands to the
    // filter driver come via IOCTL's to this device object.  It lives
    // for the lifetime of the filter driver.
    //
	RtlInitUnicodeString (&uniNtNameString, GCK_CONTROL_NTNAME);
    NtStatus = IoCreateDevice (
                 pDriverObject,
                 sizeof (GCK_CONTROL_EXT),
                 &uniNtNameString,
                 FILE_DEVICE_UNKNOWN,
                 0,                     // No standard device characteristics
                 FALSE,                 // This isn't an exclusive device
                 &pDeviceObject
                 );

	if(!NT_SUCCESS (NtStatus))
	{
        GCK_DBG_CRITICAL_PRINT (("Couldn't create the device. Status: 0x%0.8x\n", NtStatus));
        return NtStatus ;
    }

    //
    // Create W32 symbolic link name
    //
	GCK_DBG_TRACE_PRINT(("Creating symbolic link\n"));
    RtlInitUnicodeString (&uniWin32NameString, GCK_CONTROL_SYMNAME);
    NtStatus  = IoCreateSymbolicLink (&uniWin32NameString, &uniNtNameString);
    if (!NT_SUCCESS(NtStatus)) 
	{
        GCK_DBG_CRITICAL_PRINT (("Couldn't create the symbolic Status: 0x%0.8x\n", NtStatus));
        IoDeleteDevice (pDeviceObject);
        return NtStatus;
    }
	
	//
	//	Initialize Globals
	//
	GCK_DBG_TRACE_PRINT(("Initializing CTRL globals\n"));
	Globals.pControlObject = pDeviceObject;

	GCK_DBG_TRACE_PRINT(("Initializing Control Device\n"));
	pControlExt = pDeviceObject->DeviceExtension;
	pControlExt->ulGckDevObjType = GCK_DO_TYPE_CONTROL;	//Put our name on this, so we can speak for him later
	pControlExt->lOutstandingIO = 1;		// biassed to 1.  Transition to zero signals Remove event
	Globals.pControlObject->Flags |= DO_BUFFERED_IO;
	Globals.pControlObject->Flags &= ~DO_DEVICE_INITIALIZING;
	
	GCK_DBG_EXIT_PRINT (("Normal exit of GCK_CTRL_AddDevice: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	VOID GCK_CTRL_Remove()
**
**	@func	Removes the one and only Control Device.  Called from GCK_FLTR_Remove
**			when all of the Filter devices go away.  This was necessary, as
**			the PnP loader won't unload you if you still have devices around
**			even if they are legacy, and even if it started your driver.
**
**	@rdesc	None
**
*************************************************************************************/
VOID
GCK_CTRL_Remove()
{
	NTSTATUS NtStatus;
	PGCK_CONTROL_EXT	pControlExt;
	UNICODE_STRING      uniWin32NameString;
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Remove\n"));
	if( Globals.pControlObject)
	{
		GCK_DBG_TRACE_PRINT(("Removing Global Control Device\n"));
		
		//BUGBUG
		//BUGBUG  Should be counting outstanding IRPs and blocking here until they
		//BUGBUG  complete, before removing this.
		//BUGBUG

		//Kill the symbolic link we created on open
		RtlInitUnicodeString (&uniWin32NameString, GCK_CONTROL_SYMNAME);
		NtStatus = IoDeleteSymbolicLink(&uniWin32NameString);
		ASSERT( NT_SUCCESS(NtStatus) );
		if( NT_SUCCESS(NtStatus) )
		{
			//Delete the device
			IoDeleteDevice(Globals.pControlObject);
			Globals.pControlObject = NULL;
		}
	}
	GCK_DBG_EXIT_PRINT (("Exiting GCK_CTRL_Remove\n"));
	return;
}


/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_Create ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles the IRP_MJ_CREATE for the control device - Call generated by
**			Win32 API CreateFile or OpenFile.
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS GCK_CTRL_Create (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
	PGCK_CONTROL_EXT	pControlExt;
		
	PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Create\n"));

	//Cast device extension
	pControlExt = (PGCK_CONTROL_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_CONTROL == pControlExt->ulGckDevObjType);
    	
	//free access to control devices
	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	
	//Return
	GCK_DBG_EXIT_PRINT(("Exiting GCK_CTRL_Create\n"));	
	return STATUS_SUCCESS;
}	

/***********************************************************************************
**
**	NTSTATUS GCK_CTRL_Close ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles IRP_MJ_CLOSE for the control device - Call generated by Win32 API CloseFile
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_CTRL_Close (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
	PGCK_CONTROL_EXT	pControlExt;
	PGCK_FILTER_EXT		pFilterExt;
	PDEVICE_OBJECT		pFilterDeviceObject;
	PFILE_OBJECT		pFileObject;

	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CTRL_Close\n"));
	
	//Cast device extension
	pControlExt = (PGCK_CONTROL_EXT) pDeviceObject->DeviceExtension;
    
	//Get file object from IRP
	pFileObject = IoGetCurrentIrpStackLocation(pIrp)->FileObject;
	
	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_CONTROL == pControlExt->ulGckDevObjType);

	//Close Test Mode for any device it was opened for
	//- if it was open by this handle - if it wasn't open this is a no-op
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	pFilterDeviceObject = Globals.pFilterObjectList;
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);
	while(pFilterDeviceObject)
	{
		pFilterExt = (PGCK_FILTER_EXT)pFilterDeviceObject->DeviceExtension;
		GCKF_EndTestScheme(pFilterExt, pFileObject);
		ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
		pFilterDeviceObject = pFilterExt->pNextFilterObject;
		ExReleaseFastMutex(&Globals.FilterObjectListFMutex);
	}	

	//free access to control devices
	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	//Return
	GCK_DBG_EXIT_PRINT(("Exiting GCK_CTRL_Close.\n"));
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\stdhdrs.h ===
//	@doc
/**********************************************************************
*
*	@module	stdhdrs.h	|
*
*	Pulls in all the headers needed by most of the modules in the ControlItemCollection library.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*
**********************************************************************/
#ifdef COMPILE_FOR_WDM_KERNEL_MODE
extern "C"	
{
	#include <wdm.h>
	#include <winerror.h>
	#include <Hidpddi.h>
}
#else
#include <windows.h>
#include <crtdbg.h>
extern "C"
{
	#pragma warning( disable : 4201 ) 
	#include "Hidsdi.h"
	#pragma warning( default : 4201 ) 
}

#endif

#include "DualMode.h"

extern "C"
{
	#include "debug.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL) );
}

#include "ListAsArray.h"
#include "ControlItemCollection.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filter.cpp ===
//	@doc
/**********************************************************************
*
*	@module	filter.cpp	|
*
*	Implementation of CDeviceFilter and related classes, including
*	the CXXXInput class for the CControlItems dervied from CInputItem.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	filter	|
*	The CDeviceFilter class basically uses two CControlItemCollection
*	classes to implement the filter.  One is based off of CControlItems
*	derived from CInputItem which contains symantics for assigning and
*	playing actions, as well as implementing behaviors.
*	The output colleciton is a CControlItemDefaultCollection.
*	Additionally there is a CActionQueue for holding in-process macros.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FILTER_CPP

extern "C"
{
	#include <wdm.h>
	#include <winerror.h>
	#include <hidsdi.h>
	#include <hidusage.h>
	#include "debug.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}
#include "filter.h"
#include "filterhooks.h"

//------------------------------------------------------
// CAction constant static members that need to be initialized
//------------------------------------------------------
const	UCHAR CAction::DIGITAL_MAP		= 0x01;	
const	UCHAR CAction::PROPORTIONAL_MAP	= 0x02;	
const	UCHAR CAction::QUEUED_MACRO		= 0x03;	

// Force a bleed through, regardless of what other macro says (always also allows bleed through)
const ULONG ACTION_FLAG_FORCE_BLEED	= (0x00000008 | ACTION_FLAG_BLEED_THROUGH);

//-------------------------------------------------------------------
//	Implementation of CStandardBehavior
//-------------------------------------------------------------------
BOOLEAN CStandardBehavior::Init( PBEHAVIOR_CURVE pBehaviorCurve)
{
	GCK_DBG_ENTRY_PRINT(("Entering CBehavior::Init, pBehaviorCurve = 0x%0.8x\n", pBehaviorCurve));
	
	//	Allocate memory for Behavior Curve
	m_pBehaviorCurve = reinterpret_cast<PBEHAVIOR_CURVE>(new WDM_NON_PAGED_POOL PCHAR[pBehaviorCurve->AssignmentBlock.CommandHeader.ulByteSize]);
	if( !m_pBehaviorCurve)
	{
		GCK_DBG_ERROR_PRINT(("Exiting CStandardBehavior::Init - memory allocation failed.\n"));
		return FALSE;
	}

	//
	//	Copy over timed macro information to newly allocated buffer
	//
	RtlCopyMemory(m_pBehaviorCurve, pBehaviorCurve , pBehaviorCurve->AssignmentBlock.CommandHeader.ulByteSize);
	
	//
	// Set is digital flag of base class
	//
	m_fIsDigital = pBehaviorCurve->fDigital;
	
	return TRUE;
}

void CStandardBehavior::Calibrate(LONG lMin, LONG lMax)
{
	// Call base class
	CBehavior::Calibrate(lMin, lMax);
	long lValue;
	long lSourceRange = m_lMax - m_lMin;

	//Calibrate points in assignment
	for (int i = 0; i < m_pBehaviorCurve->usPointCount; i++)
	{
		//calibrate x
		lValue = m_pBehaviorCurve->rgPoints[i].sX;
		lValue = (lValue * lSourceRange)/(LONG)m_pBehaviorCurve->ulRange + lMin;
		m_pBehaviorCurve->rgPoints[i].sX = (short)lValue;

		//calibrate y
		lValue = m_pBehaviorCurve->rgPoints[i].sY;
		lValue = (lValue * lSourceRange)/(LONG)m_pBehaviorCurve->ulRange + lMin;
		m_pBehaviorCurve->rgPoints[i].sY = (short)lValue;
	}
}

#define FIXED_POINT_SHIFT 16
LONG CStandardBehavior::CalculateBehavior(LONG lValue)
{
	//	find node to use
	for (int i = 0; i < m_pBehaviorCurve->usPointCount; i++)
	{
		if (lValue < m_pBehaviorCurve->rgPoints[i].sX)  break;
	}

	//look for extremes
	//the sensitivity does not always start and end at min/max
	if(i==0)
	{ //min sensitivity
		return (long)m_pBehaviorCurve->rgPoints[i].sY;
	}
	if(i==m_pBehaviorCurve->usPointCount)
	{	//max sensitivity
		i--;
		return (long)m_pBehaviorCurve->rgPoints[i].sY;
	}

	//	Go back to previous curve node
	i--;

	// calculate the slope at this section
	long ldeltax = m_pBehaviorCurve->rgPoints[i+1].sX - m_pBehaviorCurve->rgPoints[i].sX;
	long lSlope = m_pBehaviorCurve->rgPoints[i+1].sY - m_pBehaviorCurve->rgPoints[i].sY;

	lSlope <<=	FIXED_POINT_SHIFT;
	ASSERT(ldeltax != 0);
	lSlope /= ldeltax;
	
	//Now normalize value to node
	lValue -= m_pBehaviorCurve->rgPoints[i].sX;

	//Slope value from node and normalize
	lValue *= lSlope;
	lValue >>= FIXED_POINT_SHIFT;

	//Transform curve value from node
	lValue += m_pBehaviorCurve->rgPoints[i].sY;

	//scale it back to the interface and send it back
	return lValue;
}
#undef FIXED_POINT_SHIFT

CURVE_POINT CStandardBehavior::GetBehaviorPoint(USHORT usPointIndex)
{
	if (usPointIndex < m_pBehaviorCurve->usPointCount)
	{
		return m_pBehaviorCurve->rgPoints[usPointIndex];
	}
	CURVE_POINT cp = { 0, 0 };
	return cp;
}

//------------------------------------------------------------------------------
//	Implementation of CTimedMacro
//------------------------------------------------------------------------------
const	UCHAR CTimedMacro::TIMED_MACRO_STARTED		= 0x01;
const	UCHAR CTimedMacro::TIMED_MACRO_RELEASED		= 0x02;
const	UCHAR CTimedMacro::TIMED_MACRO_RETRIGGERED	= 0x04;
const	UCHAR CTimedMacro::TIMED_MACRO_FIRST		= 0x08;
const	UCHAR CTimedMacro::TIMED_MACRO_COMPLETE		= 0x10;

BOOLEAN CTimedMacro::Init(PTIMED_MACRO pTimedMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer)
{
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::Init, pTimedMacroData = 0x%0.8x, pActionQueue = 0x%0.8x, pKeyMixer = 0x%0.8x\n",
						pTimedMacroData,
						pActionQueue,
						pKeyMixer));
	//
	//	Allocate memory for TimedMacroData
	//
	m_pTimedMacroData = reinterpret_cast<PTIMED_MACRO>(new WDM_NON_PAGED_POOL PCHAR[pTimedMacroData->AssignmentBlock.CommandHeader.ulByteSize]);
	if( !m_pTimedMacroData )
	{
		GCK_DBG_ERROR_PRINT(("Exiting CTimedMacro::Init - memory allocation failed.\n"));
		return FALSE;
	}

	//
	//	Copy over timed macro information to newly allocated buffer
	//
	RtlCopyMemory(m_pTimedMacroData, pTimedMacroData, pTimedMacroData->AssignmentBlock.CommandHeader.ulByteSize);

	//
	//	Walk events and ensure duration is less than limit
	//
	ULONG		 ulEventNumber=1;
	PTIMED_EVENT pCurEvent = m_pTimedMacroData->GetEvent(ulEventNumber);
	while(pCurEvent)
	{
		ASSERT(pCurEvent->ulDuration < 10000);  //UI has a limit of ten seconds, so assert if greater
		//Ensure that event will not last forever
		if( pCurEvent->ulDuration >= CActionQueue::MAXIMUM_JOG_DELAY-1)
		{
			pCurEvent->ulDuration = CActionQueue::MAXIMUM_JOG_DELAY-2;
		}
		pCurEvent = m_pTimedMacroData->GetNextEvent(pCurEvent, ulEventNumber);
	};


	//
	//	That was the only thing that could have failed so call our base class init function
	//	in confidence that we will succeed now
	//
	CQueuedAction::Init(pActionQueue);

	//
	//	Remember where the pKeyMixer is 
	//
	m_pKeyMixer = pKeyMixer;

	//
	//	Make sure we start from the beginning
	//
	m_ulCurrentEventNumber = 0;
	
	GCK_DBG_EXIT_PRINT(("Exiting CTimedMacro::Init - Success.\n"));
	return TRUE;
}

void CTimedMacro::TriggerReleased()
{
	GCK_DBG_RT_ENTRY_PRINT(("Entering CTimedMacro::TriggerReleased\n"));
	
	if(CTimedMacro::TIMED_MACRO_COMPLETE &	m_ucProcessFlags)
	{
		m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
	}
	else
	{
		m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_RELEASED;
	}
}
void CTimedMacro::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::MapToOutput, pOutputCollection\n", pOutputCollection));
	//
	//	If we are currently processing a macro (the macro even be complete, however it will be
	//	marked as started until the user lets up on the trigger (unless auto-repeat is set)
	//
	if(CTimedMacro::TIMED_MACRO_STARTED & m_ucProcessFlags)
	{
		//
		//	If this is a retrigger, than mark as such
		//
		if(CTimedMacro::TIMED_MACRO_RELEASED & m_ucProcessFlags)
		{
			// Clear release flag and set retriggered flag
			m_ucProcessFlags &= ~CTimedMacro::TIMED_MACRO_RELEASED;
			m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_RETRIGGERED;
		}
		//
		//	We are in the queue so there is nothing more to do
		//
		return;
	}
	
	
	//
	//	Place ourselvs in the queue (queue may refuse us)
	//
	if(m_pActionQueue->InsertItem(this))
	{

		//
		//	We are not processing, so we should start it, and queue it
		//
		m_ucProcessFlags = CTimedMacro::TIMED_MACRO_STARTED | CTimedMacro::TIMED_MACRO_FIRST;

		//
		//	Remember who our output is
		//
		m_pOutputCollection = pOutputCollection;
	}
	

	return;
}

void CTimedMacro::Jog( ULONG ulTimeStampMs )
{
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::Jog, ulTimeStampMs = 0x%0.8x\n", ulTimeStampMs));
	//
	//	If first check set the first time
	//
	if(CTimedMacro::TIMED_MACRO_FIRST & m_ucProcessFlags)
	{	
		m_ucProcessFlags &= ~CTimedMacro::TIMED_MACRO_FIRST;
		m_ulStartTimeMs = ulTimeStampMs;
		m_ulEventEndTimeMs = 0;
		m_ulCurrentEventNumber=0;
		m_pCurrentEvent=NULL;
	}

	//
	//	If macro is complete just return (the call to Released() will cleanup)
	//
	if(CTimedMacro::TIMED_MACRO_COMPLETE & m_ucProcessFlags)
	{
		return;
	}

	//
	// If it time to go one to next event
	//
	if( ulTimeStampMs >= m_ulEventEndTimeMs)
	{
		//
		//	If so then do it
		//
		m_pCurrentEvent = m_pTimedMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);

		//
		//	check to see if we are done
		//
		if(!m_pCurrentEvent)
		{
			//
			//	If the user has already released the trigger then pull ourselves out of queue and cleanup.
			//
			if(m_ucProcessFlags & CTimedMacro::TIMED_MACRO_RELEASED)
			{
				m_ucProcessFlags = 0;
				m_pActionQueue->RemoveItem(this);
				return;
			}

			//
			//	If the event is auto-repeat, then reset the event
			//
			if( ACTION_FLAG_AUTO_REPEAT & m_pTimedMacroData->ulFlags)
			{
				m_ucProcessFlags = TIMED_MACRO_STARTED;
				m_ulStartTimeMs = ulTimeStampMs;
				m_ulEventEndTimeMs = 0;
				m_ulCurrentEventNumber=0;
				m_pCurrentEvent=NULL;
				m_pCurrentEvent = m_pTimedMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
			}
			else
			{
				//
				//	Otherwise we mark the macro has complete, but leave it
				//	as started so that we won't retrigger until it released
				m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_COMPLETE;
				m_pActionQueue->RemoveItem(this);
				return;
			}
		}	//end of "if last event is over"
		
		//
		//	If we have successfully moved on to the next event,
		//  we need to figure out when this event should be up
		//
		m_ulEventEndTimeMs = ulTimeStampMs + m_pCurrentEvent->ulDuration;

	}	//end of "if need to advance to next event"

	// The following lines were there to prevent non-Macro info from
	// bleeding-through if ACTION_FLAG_BLEED_THROUGH is not set.
	// Turns out this is contrary to spec.
	//if( !(ACTION_FLAG_BLEED_THROUGH & GetActionFlags()))
	//{
	//	m_pOutputCollection->SetDefaultState();
	//}
	
	//
	//	Drive outputs with event.
	//
	m_pOutputCollection->SetState(m_pCurrentEvent->Event.ulNumXfers, m_pCurrentEvent->Event.rgXfers);
	

	//
	//	Find Keyboard Xfers in Event and overlay them
	//
	for(ULONG ulIndex = 0; ulIndex < m_pCurrentEvent->Event.ulNumXfers; ulIndex++)
	{
		if( NonGameDeviceXfer::IsKeyboardXfer(m_pCurrentEvent->Event.rgXfers[ulIndex]) )
		{
			m_pKeyMixer->OverlayState(m_pCurrentEvent->Event.rgXfers[ulIndex]);
			break;
		}
	}
	
	//
	//	Make a suggestion to the queue when to call us back.
	//
	if( m_ulEventEndTimeMs >= ulTimeStampMs )
	{
		m_pActionQueue->NextJog( m_ulEventEndTimeMs - ulTimeStampMs );
	}
	else
	{
		m_pActionQueue->NextJog( 0 ); //0 means minimum callback time
	}
	
	return;
}

void CTimedMacro::Terminate()
{
	GCK_DBG_ENTRY_PRINT(("Entering CTimedMacro::Terminate\n"));

	if(CTimedMacro::TIMED_MACRO_RELEASED & m_ucProcessFlags)
	{
		//
		//	Mark as ready to requeue
		//
		m_ucProcessFlags = 0;
	}
	else
	{
		//
		//	Mark as complete
		//
		m_ucProcessFlags |= CTimedMacro::TIMED_MACRO_COMPLETE;
	}

	//
	// We never remove ourselves from the queue after a terminate,
	// this happens automatically
	//
}

//------------------------------------------------------------------------------
//	Implementation of CKeyString
//------------------------------------------------------------------------------
const	UCHAR CKeyString::KEY_STRING_STARTED		= 0x01;
const	UCHAR CKeyString::KEY_STRING_RELEASED		= 0x02;
const	UCHAR CKeyString::KEY_STRING_RETRIGGERED	= 0x04;
const	UCHAR CKeyString::KEY_STRING_FIRST			= 0x08;
const	UCHAR CKeyString::KEY_STRING_COMPLETE		= 0x10;

BOOLEAN CKeyString::Init(PKEYSTRING_MAP pKeyStringData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer)
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::Init, pKeyStringData = 0x%0.8x, pActionQueue = 0x%0.8x, pKeyMixer = 0x%0.8x\n",
		pKeyStringData,
		pActionQueue,
		pKeyMixer));
	//
	//	Allocate memory for KeyStringData
	//
	m_pKeyStringData = reinterpret_cast<PKEYSTRING_MAP>(new WDM_NON_PAGED_POOL PCHAR[pKeyStringData->AssignmentBlock.CommandHeader.ulByteSize]);
	if( !m_pKeyStringData )
	{
		return FALSE;
	}

	//
	//	Copy over timed macro information to newly allocated buffer
	//
	RtlCopyMemory(m_pKeyStringData, pKeyStringData, pKeyStringData->AssignmentBlock.CommandHeader.ulByteSize);

	//
	//	That was the only thing that could have failed so call our base class init function
	//	in confidence that we will succeed now
	//
	CQueuedAction::Init(pActionQueue);

	//
	//	Remember where the pKeyMixer is 
	//
	m_pKeyMixer = pKeyMixer;

	//
	//	Make sure we start from the beginning
	//
	m_ulCurrentEventNumber = 0;

	return TRUE;
};

void CKeyString::TriggerReleased()
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::TriggerReleased\n"));
	if(CKeyString::KEY_STRING_COMPLETE & m_ucProcessFlags)
	{
		GCK_DBG_TRACE_PRINT(("Trigger released, resetting m_ucProcessFlags\n"));
		m_ucProcessFlags = 0;
	}
	else
	{
		m_ucProcessFlags |= CKeyString::KEY_STRING_RELEASED;
		GCK_DBG_TRACE_PRINT(("Trigger released, marking m_ucProcessFlags = 0x%0.8x\n", m_ucProcessFlags));
	}
}

void CKeyString::MapToOutput( CControlItemDefaultCollection *)
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::MapToOutput\n"));
	//
	//	If we are currently processing a macro (the macro even be complete, however it will be
	//	marked as started until the user lets up on the trigger (unless auto-repeat is set)
	//
	if(CKeyString::KEY_STRING_STARTED & m_ucProcessFlags)
	{
		//
		//	If this is a retrigger, than mark as such
		//
		if(CKeyString::KEY_STRING_RELEASED & m_ucProcessFlags)
		{
			GCK_DBG_TRACE_PRINT(("Retriggering keystring macro\n"));
			// Clear release flag and set retriggered flag
			m_ucProcessFlags &= ~CKeyString::KEY_STRING_RELEASED;
			m_ucProcessFlags |= CKeyString::KEY_STRING_RETRIGGERED;
		}
		//
		//	We are in the queue so there is nothing more to do
		//
		return;
	}
	
	
	//
	//	Place ourselves in the queue (queue may refuse us)
	//
	if(m_pActionQueue->InsertItem(this))
	{

		//
		//	We are not processing, so we should start it, and queue it
		//
		GCK_DBG_TRACE_PRINT(("Starting keystring macro\n"));
		m_ucProcessFlags = CKeyString::KEY_STRING_STARTED | CKeyString::KEY_STRING_FIRST;
	}

	return;
}

void CKeyString::Jog( ULONG )
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::Jog\n"));
	
	//BUG	We noticed some synchronization issues.
	//BUG	It is possible that we entered this routine.
	//BUG	The proper solution is a spin lock, but this
	//BUG	needs to be carefully considered.  If this
	//BUG	is still here in a month we are in trouble.
	if( !(CKeyString::KEY_STRING_STARTED &	m_ucProcessFlags) )
	{
		return;
	}
	
	//
	//	If first check set the first time
	//
	if(CKeyString::KEY_STRING_FIRST & m_ucProcessFlags)
	{	
		m_ucProcessFlags &= ~CKeyString::KEY_STRING_FIRST;
		m_ulCurrentEventNumber=0;
		m_pCurrentEvent=NULL;
		m_fKeysDown = FALSE;
		//Get first event
		m_pCurrentEvent = m_pKeyStringData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
		if(!m_pCurrentEvent)
		{
			//This really shouldn't happen
			ASSERT(FALSE);
			//Just get us out of the queue, if we have no events
			m_ucProcessFlags = 0;
			m_pActionQueue->RemoveItem(this);
		}
	}

	//
	//	If macro is complete just return (the call to Released() will cleanup)
	//
	if(CKeyString::KEY_STRING_COMPLETE & m_ucProcessFlags)
	{
		return;
	}

	// If keys are not down put them down
	if(!m_fKeysDown)
	{
		ASSERT(1 == m_pCurrentEvent->ulNumXfers);
		ASSERT( NonGameDeviceXfer::IsKeyboardXfer(m_pCurrentEvent->rgXfers[0]) );
		m_pKeyMixer->OverlayState(m_pCurrentEvent->rgXfers[0]);
		m_fKeysDown = TRUE; 
	}
	else
	//Bring Keys up and advance event
	{
		//Not mapping anything brings them up
		m_fKeysDown = FALSE;
		//Go on to next event
		m_pCurrentEvent = m_pKeyStringData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
		//Process macro end, if there are no more events
		if(!m_pCurrentEvent)
		{
			//
			//	If the user has already released the trigger then pull ourselves out of queue and cleanup.
			//
			if(m_ucProcessFlags & CKeyString::KEY_STRING_RELEASED)
			{
				GCK_DBG_TRACE_PRINT(("Macro complete, and user released button\n"));
				m_ucProcessFlags = 0;
				m_pActionQueue->RemoveItem(this);
				return;
			}

			//
			//	If the event is auto-repeat, then reset the event
			//
			if( ACTION_FLAG_AUTO_REPEAT & m_pKeyStringData->ulFlags)
			{
				GCK_DBG_TRACE_PRINT(("Auto repeat and user still holding button, restart it.\n"));
				m_ucProcessFlags = CKeyString::KEY_STRING_STARTED | CKeyString::KEY_STRING_FIRST;
				m_ulCurrentEventNumber=0;
				m_pCurrentEvent=NULL;
				m_pActionQueue->NextJog( 250 );
				return;
			}

			//
			//	Otherwise we mark the macro has complete, but leave it
			//	as started so that we won't retrigger until it released
			m_ucProcessFlags |= CKeyString::KEY_STRING_COMPLETE;
			GCK_DBG_TRACE_PRINT(("Should be started and complete, m_ucProcessFlags = 0x%0.8x.\n", m_ucProcessFlags));
			m_pActionQueue->RemoveItem(this);
			return;
		}	//end of "if last event is over"
	}

	//
	//	Suggestion to queue to call us back in 10 ms
	//
	m_pActionQueue->NextJog( 10 );
	return;
}

void CKeyString::Terminate()
{
	GCK_DBG_ENTRY_PRINT(("Entering CKeyString::Terminate\n"));	
	if(CKeyString::KEY_STRING_RELEASED & m_ucProcessFlags)
	{
		//
		//	Mark as ready to requeue
		//
		m_ucProcessFlags = 0;
	}
	else
	{
		//
		//	Mark as complete
		//
		m_ucProcessFlags |= CKeyString::KEY_STRING_COMPLETE;
	}

	//
	// We never remove ourselves from the queue after a terminate,
	// this happens automatically
	//
}

//------------------------------------------------------------------------------------
//  Implementation of CMultiMacro
//------------------------------------------------------------------------------------
const	UCHAR CMultiMacro::MULTIMACRO_STARTED		= 0x10;
const	UCHAR CMultiMacro::MULTIMACRO_RELEASED		= 0x20;
const	UCHAR CMultiMacro::MULTIMACRO_RETRIGGERED	= 0x40;
const	UCHAR CMultiMacro::MULTIMACRO_FIRST			= 0x80;

BOOLEAN CMultiMacro::Init(PMULTI_MACRO pMultiMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer)
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::Init, pMultiMacroData = 0x%0.8x, pActionQueue = 0x%0.8x, pKeyMixer = 0x%0.8x\n",
						pMultiMacroData,
						pActionQueue,
						pKeyMixer));

	//	Allocate memory for MultiMacroData
	m_pMultiMacroData = reinterpret_cast<PMULTI_MACRO>(new WDM_NON_PAGED_POOL PCHAR[pMultiMacroData->AssignmentBlock.CommandHeader.ulByteSize]);
	if(m_pMultiMacroData == NULL)
	{
		GCK_DBG_ERROR_PRINT(("Exiting CMultiMacro::Init - memory allocation failed.\n"));
		return FALSE;
	}

	//	Copy over multi macro information to newly allocated buffer
	RtlCopyMemory(m_pMultiMacroData, pMultiMacroData, pMultiMacroData->AssignmentBlock.CommandHeader.ulByteSize);

	//	That was the only thing that could have failed so call our base class init function
	//	in confidence that we will succeed now
	CQueuedAction::Init(pActionQueue);

	//	Remember where the pKeyMixer is 
	m_pKeyMixer = pKeyMixer;

	// Check the delay sizes (and adjust if nessacary)
	m_ulCurrentEventNumber = 0;
	m_pCurrentEvent = NULL;
	while ((m_pCurrentEvent = m_pMultiMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber)) != NULL)
	{	// Is there a delay xfer (always first)
		if (NonGameDeviceXfer::IsDelayXfer(m_pCurrentEvent->rgXfers[0]) == TRUE)
		{
			if (m_pCurrentEvent->rgXfers[0].Delay.dwValue > 5000)		// 5 seconds max (change if more required)
			{
				m_pCurrentEvent->rgXfers[0].Delay.dwValue = 5000;
				ASSERT(FALSE);		// Really should not get one out of range (it is not nice)
			}
		}
	}

	//	Make sure we start back from the beginning
	m_ulCurrentEventNumber = 0;
	m_pCurrentEvent = NULL;

	// No delays active yet
	m_ulStartTimeMs = 0;
	m_ulEndTimeMs = 0;

	// Nothing currently active
	m_fXferActive = FALSE;
	
	GCK_DBG_EXIT_PRINT(("Exiting CMultiMacro::Init - Success.\n"));
	return TRUE;
}

void CMultiMacro::ForceBleedThrough()
{
	m_ucProcessFlags |= ACTION_FLAG_FORCE_BLEED;
}

void CMultiMacro::SetCurrentKeysAndMouse()
{
	for (ULONG ulXFerIndex = 0; ulXFerIndex < m_pCurrentEvent->ulNumXfers; ulXFerIndex++)
	{
		if (NonGameDeviceXfer::IsKeyboardXfer(m_pCurrentEvent->rgXfers[ulXFerIndex]) == TRUE)
		{
			m_pKeyMixer->OverlayState(m_pCurrentEvent->rgXfers[ulXFerIndex]);
			m_fXferActive = TRUE;
		}
		else if (NonGameDeviceXfer::IsMouseXfer(m_pCurrentEvent->rgXfers[ulXFerIndex]) == TRUE)
		{
			if (m_pCurrentEvent->rgXfers[ulXFerIndex].MouseButtons.dwMouseButtons & 0x01)
			{
				m_pMouseModel->MouseButton(0);
			}
			if (m_pCurrentEvent->rgXfers[ulXFerIndex].MouseButtons.dwMouseButtons & 0x02)
			{
				m_pMouseModel->MouseButton(1);
			}
			if (m_pCurrentEvent->rgXfers[ulXFerIndex].MouseButtons.dwMouseButtons & 0x04)
			{
				m_pMouseModel->MouseButton(2);
			}
			m_fXferActive = TRUE;
		}
		else
		{
			ASSERT(FALSE);		// Unknown XFer Type (or embedded delay)
		}
	}
}

void CMultiMacro::Jog(ULONG ulTimeStampMs)
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::Jog\n"));
//	DbgPrint("Entering CMultiMacro::Jog: 0x%08X\n", this);

	// Have we even been started?
	if ((MULTIMACRO_STARTED & m_ucProcessFlags) == 0)
	{	// Nope, nothing to do
//		DbgPrint("Not started (ignore): 0x%08X\n", this);
		return;
	}
	
	// Is this the first time (just started or restarted)
	if (MULTIMACRO_FIRST & m_ucProcessFlags)
	{	
//		DbgPrint("MultiMacro (Re)started: 0x%08X\n", this);
		m_ucProcessFlags &= ~MULTIMACRO_FIRST;	// No longer the first time
		m_fXferActive = FALSE;	// Since we are fresh nothing has happened yet

		// Get the first event
		m_ulCurrentEventNumber = 0;
		m_pCurrentEvent = NULL;
		m_pCurrentEvent = m_pMultiMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);
		if (m_pCurrentEvent == NULL)
		{	// No events, pretty lame MultiMap (shouldn't happen - just finish quickly)
			ASSERT(FALSE);
			if ((m_ucProcessFlags & ACTION_FLAG_FORCE_BLEED) != 0)
			{
				m_ucProcessFlags = ACTION_FLAG_FORCE_BLEED;
			}
			else
			{
				m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
			}
			m_pActionQueue->RemoveItem(this);
		}
	}

	// We do not have an active Xfer (no mouse buttons down, no keys down, not in middle of delay)
	if (m_fXferActive == FALSE)
	{	// This code only assumes one XFER, keyboard, need to look at! (??)
		if (NonGameDeviceXfer::IsDelayXfer(m_pCurrentEvent->rgXfers[0]) == TRUE)
		{
			m_ulStartTimeMs = ulTimeStampMs;	// Now
			m_ulEndTimeMs = ulTimeStampMs + m_pCurrentEvent->rgXfers[0].Delay.dwValue;	// Later
			m_fXferActive =	TRUE;
		}
		else
		{
			SetCurrentKeysAndMouse();
		}
	}
	else	// Some sort of MultiMap xfer is active
	{
		BOOLEAN fFinishedDelay = FALSE;
		// Check for an active delay
		if (m_ulStartTimeMs != 0)
		{	// There is an active delay
			if (m_ulEndTimeMs <= ulTimeStampMs)
			{	// And it timed out
				m_fXferActive = FALSE;
				m_ulStartTimeMs = 0;
				m_ulEndTimeMs = 0;
				fFinishedDelay = TRUE;
//				DbgPrint("fFinishedDelay = TRUE: 0x%08X\n", this);
			}
		}
		else	// No delay is active (keys and mouse will be redowned)
		{
			m_fXferActive = FALSE;
		}

		// Do we need to look at the next xfer (did we finish up the previous)
		if (m_fXferActive == FALSE)
		{
			// Go on to next event
			EVENT* pPreviousEvent = m_pCurrentEvent;
			ULONG ulLastEventNumber = m_ulCurrentEventNumber;
			m_pCurrentEvent = m_pMultiMacroData->GetNextEvent(m_pCurrentEvent, m_ulCurrentEventNumber);

			// We want to repeat the last event if the macro wasn't released (and it wasn't a delay)
			if ((m_pCurrentEvent == NULL) && ((m_ucProcessFlags & MULTIMACRO_RELEASED) == 0) && (fFinishedDelay == FALSE))
			{	// Go back to the last event (and update based on it)
				m_pCurrentEvent = pPreviousEvent;
				m_ulCurrentEventNumber = ulLastEventNumber;
				SetCurrentKeysAndMouse();	// Want to play the last event again (avoid keyup/mouseup during switchback)
			}
			else if (m_pCurrentEvent == NULL)
			{	// Process macro end (the button has been released and we are out of events, or last was delay)
				//	Pull ourselves out of queue and cleanup.
				GCK_DBG_TRACE_PRINT(("Macro complete, and user released button (or last item was delay)\n"));
//				DbgPrint("Macro complete, and user released button : 0x%08X\n", this);
				if ((m_ucProcessFlags & ACTION_FLAG_FORCE_BLEED) != 0)
				{
					m_ucProcessFlags = ACTION_FLAG_FORCE_BLEED;
				}
				else
				{
					m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
				}
				m_pActionQueue->RemoveItem(this);
				return;
			}	// endif - Out of events and button released (or last was a delay)
		}	// endif - Current event was finished
	}	// endif - keys down

	//	Suggestion to queue to call us back in 10 ms
	m_pActionQueue->NextJog(10);
	return;
}

void CMultiMacro::Terminate()
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::Terminate\n"));

	ASSERT(FALSE);			// These are all prevent interrupt (or allow bleed through)!
}

void CMultiMacro::MapToOutput(CControlItemDefaultCollection*)
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::MapToOutput\n"));

	//	Is it started? This is true till user released trigger.
	if(MULTIMACRO_STARTED & m_ucProcessFlags)
	{
		// Are we really queued
		if (m_bActionQueued == FALSE)
		{	// Liar we are not started (someone forgot to take us off the queue, hey it happens, deal with it)
			m_ucProcessFlags &= ~MULTIMACRO_STARTED;
		}
		else
		{
			//	Retrigger? - Meaning are still in queue and button is repressed.
			if (MULTIMACRO_RELEASED & m_ucProcessFlags)
			{	// Clear release flag and set retriggered flag (we are already in queue, don't readd)
				GCK_DBG_TRACE_PRINT(("(Re)triggering multi-macro\n"));
				m_ucProcessFlags &= ~MULTIMACRO_RELEASED;
				m_ucProcessFlags |= MULTIMACRO_RETRIGGERED;
			}
			return;
		}
	}
	
	
	//	Place ourselves in the queue (queue may refuse us)
	if (m_pActionQueue->InsertItem(this))
	{	//	We are not processing, so we should start it, and queue it
		GCK_DBG_TRACE_PRINT(("Starting multi-macro\n"));
		if ((m_ucProcessFlags & ACTION_FLAG_FORCE_BLEED) != 0)
		{
			m_ucProcessFlags = ACTION_FLAG_FORCE_BLEED;
		}
		else
		{
			m_ucProcessFlags = ACTION_FLAG_PREVENT_INTERRUPT;
		}
		m_ucProcessFlags |= MULTIMACRO_STARTED | MULTIMACRO_FIRST;
	}

	return;
}

void CMultiMacro::TriggerReleased()
{
	GCK_DBG_ENTRY_PRINT(("Entering CMultiMacro::TriggerReleased\n"));

	m_ucProcessFlags |= MULTIMACRO_RELEASED;
	GCK_DBG_TRACE_PRINT(("CMultiMacro Trigger released, marking m_ucProcessFlags = 0x%0.8x\n", m_ucProcessFlags));
}


//------------------------------------------------------------------------------------
//  Implementation of CMapping
//------------------------------------------------------------------------------------
CMapping::~CMapping()
{
	delete m_pEvent;
}

BOOLEAN CMapping::Init(PEVENT pEvent, CKeyMixer *pKeyMixer)
{
	//Initialize Event
	ULONG ulEventSize = EVENT::RequiredByteSize(pEvent->ulNumXfers);
	m_pEvent = (PEVENT) new WDM_NON_PAGED_POOL UCHAR[ulEventSize];
	if(!m_pEvent)
		return FALSE;
	memcpy((PVOID)m_pEvent, (PVOID)pEvent, ulEventSize);

	//Initialize pointer to key mixer
	m_pKeyMixer = pKeyMixer;

	return TRUE;
}
		
void CMapping::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{

	//
	//	Drive outputs with event  (this is not quite right as we need to overlay items)
	//  Two suggestions, one add a flag to SetItemState or create a new function
	//
	pOutputCollection->SetState(m_pEvent->ulNumXfers, m_pEvent->rgXfers);

	//
	//	Find Keyboard Xfers in Event and overlay them
	//
	for(ULONG ulIndex = 0; ulIndex < m_pEvent->ulNumXfers; ulIndex++)
	{
		if( NonGameDeviceXfer::IsKeyboardXfer(m_pEvent->rgXfers[ulIndex]) )
		{
			m_pKeyMixer->OverlayState(m_pEvent->rgXfers[ulIndex]);
			break;
		}
	}
}
//------------------------------------------------------------------------------------
//  Implementation of Proportional Map
//------------------------------------------------------------------------------------
LONG CProportionalMap::GetScaledValue(LONG lDestinationMax, LONG lDestinationMin)
{
	//Below comments explain these asserts, which check that values fit in 16-bits
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|lDestinationMax)) || (0xFFFF8000 == (0xFFFF8000&lDestinationMax)) );
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|lDestinationMin)) || (0xFFFF8000 == (0xFFFF8000&lDestinationMin)) );
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|m_lSourceMax)) || (0xFFFF8000 == (0xFFFF8000&m_lSourceMax)) );
	ASSERT( (0x0000FFFFF == (0x0000FFFFF|m_lSourceMin)) || (0xFFFF8000 == (0xFFFF8000&m_lSourceMin)) );
	
	/*
	*	This code is probably overkill for the application, as existing devices
	*	have a maximum precision of 10 bits, and the mouse processing code uses 16
	*	so 32 bit intermediates are safe.  The code commented out will handle the general case,
	*	which requires 64 bit intermediates, but will run slower.
	*	Below this code, there is an uncommented version with 32-bit intermeidates assuming the ranges
	*	fit in 16 bit. It should run much more quickly on 32-bit platforms.
	*
	*
	*
	*	// If either the source or destination ranges uses nearly all of the
	*	// capacity of a 32-bit number, we will not be able to do this
	*	// transformation with 32-bit intermediates. Therefore we use
	*	// 64-bit intermediates throughout and cast back before returning.
	*	__int64 i64SourceRange = static_cast<__int64>(m_lSourceMax) - static_cast<__int64>(lSourceMin);
	*	__int64 i64DestinationRange = static_cast<__int64>(lDestinationMax) - static_cast<__int64>(lDestinationMin);
	*	__int64 i64Result;
	*	
	*	i64Result = static_cast<__int64>(m_lValue) - static_cast<__int64>(lSourceMin);
	*	i64Result = (i64Result * i64DestinationRange)/i64SourceRange;
	*	i64Result += static_cast<__int64>(lDestinationMin);
		
	*	//Now that the data is safely within the destination range (which is 32-bit),
	*	//we can cast back to 32-bit and return
	*	return static_cast<LONG>(i64Result);
	*/

	//32 bit intermediate version of scaling - assume that all the ranges are 16-bit
	LONG lSourceRange = m_lSourceMax - m_lSourceMin;                                                                                                                                               
	LONG lDestinationRange = lDestinationMax-lDestinationMin;
	return ((m_lValue - m_lSourceMin) * lDestinationRange)/lSourceRange + lDestinationMin;
}

//------------------------------------------------------------------------------------
// Implementation of CAxisMap
//------------------------------------------------------------------------------------
/***********************************************************************************
**
**	void CAxisMap::Init(LONG lCoeff, CControlItemDefaultCollection *pOutputCollection)
**
**	@mfunc	CAxisMap Initializes scaling information.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
**	@comm Called by the CDeviceFilter::ActionFactory, Stores info we need to process
**			 later, Calculations are completed on SetSourceRange which is called by
**			 by the assignee immediately upon assignment.
**
*************************************************************************************/
void CAxisMap::Init(const AXIS_MAP& AxisMapInfo)
{
	//Store the coefdicient unadulterated for now
	m_lCoeff = AxisMapInfo.lCoefficient1024x;
	//Copy the destination axis CIX
	m_TargetXfer = AxisMapInfo.cixDestinationAxis;
}
void CAxisMap::SetSourceRange(LONG lSourceMax, LONG lSourceMin)
{
	//Call base class
	CProportionalMap::SetSourceRange(lSourceMax, lSourceMin);

	if(m_lCoeff > 0)
	{
		m_lOffset = -m_lCoeff*lSourceMin/1024;	
	}
	else
	{
		m_lOffset = -(m_lCoeff*lSourceMax - 1023)/1024;
	}
}
void CAxisMap::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	CControlItem *pOutputItem = pOutputCollection->GetFromControlItemXfer(m_TargetXfer);
	ASSERT(pOutputItem);
	if(pOutputItem)
	{
		CONTROL_ITEM_XFER cixOutputState;
		pOutputItem->GetItemState(cixOutputState);
		cixOutputState.Generic.lVal += ((m_lValue * m_lCoeff) / 1024) + m_lOffset;
		pOutputItem->SetItemState(cixOutputState);
	}
	return;
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseAxisAssignment
//------------------------------------------------------------------------------------
void CMouseAxisAssignment::MapToOutput(CControlItemDefaultCollection *)
{
	ULONG ulValue = static_cast<ULONG>(GetScaledValue(0, 1023));
	if(m_fXAxis)
	{
		m_pMouseModel->SetX(ulValue);
	}
	else
	{
		m_pMouseModel->SetY(ulValue);
	}
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseButton
//------------------------------------------------------------------------------------
void CMouseButton::MapToOutput(CControlItemDefaultCollection *)
{
	m_pMouseModel->MouseButton(m_ucButtonNumber);
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseClutch
//------------------------------------------------------------------------------------
void CMouseClutch::MapToOutput(CControlItemDefaultCollection *)
{
	m_pMouseModel->Clutch();
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseDamper
//------------------------------------------------------------------------------------
void CMouseDamper::MapToOutput(CControlItemDefaultCollection *)
{
	m_pMouseModel->Dampen();
}

//------------------------------------------------------------------------------------
//  Implementation of CMouseZoneIndicator
//------------------------------------------------------------------------------------
void CMouseZoneIndicator::MapToOutput(CControlItemDefaultCollection *)
{
	if(0==m_ucAxis)	m_pMouseModel->XZone();
	if(1==m_ucAxis)	m_pMouseModel->YZone();
}

//------------------------------------------------------------------------------------
//  Implementation of Input Items
//------------------------------------------------------------------------------------

HRESULT InputItemFactory(
				USHORT	usType,
				const CONTROL_ITEM_DESC* cpControlItemDesc,
				CInputItem **ppInputItem
				)
{
	GCK_DBG_ENTRY_PRINT(("Entering InputItemFactory(0x%0.4x, 0x%0.8x, 0x%0.8x\n",
						usType,
						cpControlItemDesc,
						ppInputItem));
	
	HRESULT hr = S_OK;

	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppInputItem = new WDM_NON_PAGED_POOL CAxesInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CAxesInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usDPAD:
			*ppInputItem = new WDM_NON_PAGED_POOL CDPADInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CDPADInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usPropDPAD:
			*ppInputItem = new WDM_NON_PAGED_POOL CPropDPADInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CPropDPADInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usWheel:
			*ppInputItem= new WDM_NON_PAGED_POOL CWheelInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CWheelInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usPOV:
			*ppInputItem = new WDM_NON_PAGED_POOL CPOVInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CPOVInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usThrottle:
			*ppInputItem = new WDM_NON_PAGED_POOL CThrottleInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CThrottleInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usRudder:
			*ppInputItem = new WDM_NON_PAGED_POOL CRudderInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CRudderInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usPedal:
			*ppInputItem = new WDM_NON_PAGED_POOL CPedalInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CPedalInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usButton:
			*ppInputItem = new WDM_NON_PAGED_POOL CButtonsInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CButtonsInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usDualZoneIndicator:
			*ppInputItem = new WDM_NON_PAGED_POOL CDualZoneIndicatorInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CDualZoneIndicatorInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usZoneIndicator:
			*ppInputItem = new WDM_NON_PAGED_POOL CZoneIndicatorInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CZoneIndicatorInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usProfileSelectors:
			*ppInputItem = new WDM_NON_PAGED_POOL CProfileSelectorInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CProfileSelectorInput = 0x%0.8x\n", *ppInputItem));
			break;
		case ControlItemConst::usButtonLED:
		{
			*ppInputItem = new WDM_NON_PAGED_POOL CButtonLEDInput(cpControlItemDesc);
			GCK_DBG_TRACE_PRINT(("Created CButtonLEDInput = 0x%0.8x\n", *ppInputItem));
			break;
		}
		default:
			*ppInputItem = NULL;
	}
	if(!*ppInputItem)
	{
		GCK_DBG_WARN_PRINT(("Did not create an item\n"));
		return E_FAIL;
	}
	GCK_DBG_EXIT_PRINT(("Exiting InputItemFactory with S_OK"));
	return S_OK;
}

//------------------------------------------------------------------------------
//	Implementation of CActionQueue
//------------------------------------------------------------------------------
//const UCHAR CActionQueue::OVERLAY_MACROS = 0x01;
//const UCHAR CActionQueue::SEQUENCE_MACROS = 0x02;
const ULONG CActionQueue::MAXIMUM_JOG_DELAY = 1000001; //over one million is infinite

void CActionQueue::Jog()
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::Jog\n"));
	//
	//	Initialize next jog time
	//
	m_ulNextJogMs = CActionQueue::MAXIMUM_JOG_DELAY;

	//
	//	Get CurrentTimeStamp
	//
	ULONG ulCurrentTimeMs = m_pFilterClientServices->GetTimeMs();

	CQueuedAction *pNextAction = m_pHeadOfQueue;
	while(pNextAction)
	{	
		pNextAction->Jog(ulCurrentTimeMs);
		/* NOT SUPPORTED AT THIS TIME
		if(CActionQueue::SEQUENCE_MACROS&m_ucFlags)
		{
			//
			//	If the macros are seuquenced we only process the first one
			//
			break;
		}*/
		pNextAction = pNextAction->m_pNextQueuedAction;
	}

	//
	//	SetTimer to call us back
	//
	GCK_DBG_TRACE_PRINT(("SettingNextJog for %d milliseconds.\n", m_ulNextJogMs));
	m_pFilterClientServices->SetNextJog(m_ulNextJogMs);
}

BOOLEAN CActionQueue::InsertItem(CQueuedAction *pActionToEnqueue)
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::InsertItem, pActionToEnqueue = 0x%0.8x\n", pActionToEnqueue));
	
	//
	ULONG ulIncomingFlags = pActionToEnqueue->GetActionFlags();
	BOOLEAN fRefuseIncoming = FALSE;
	CQueuedAction *pCurrentItem;
	CQueuedAction *pPreviousItem;

	// Walk through the queue to see if this item is allowed (unless it forces itself!)
	if ((m_pHeadOfQueue) && ((ulIncomingFlags & ACTION_FLAG_FORCE_BLEED) == 0))
	{
		pPreviousItem = NULL;
		pCurrentItem = m_pHeadOfQueue;
		while(pCurrentItem)
		{
			ULONG ulCurrentFlags = pCurrentItem->GetActionFlags();

			// If the current forces bleed-through, the incoming has no choice
			if ((ulCurrentFlags & ACTION_FLAG_FORCE_BLEED) == 0)
			{	// Not a forced bleed through - check
				//If they don't both allow bleed-through, then bump or refuse
				if(!(ulIncomingFlags & ulCurrentFlags & ACTION_FLAG_BLEED_THROUGH))
				{
					//if current Item is ACTION_FLAG_PREVENT_INTERRUPT, then refuse
					if(ulCurrentFlags & ACTION_FLAG_PREVENT_INTERRUPT)
					{
						fRefuseIncoming = TRUE;
					}
					else
					//Bump the one that is in there
					{
						if(pPreviousItem)
						{
							pPreviousItem->m_pNextQueuedAction = pCurrentItem->m_pNextQueuedAction;
						}
						else
						{
							m_pHeadOfQueue = pCurrentItem->m_pNextQueuedAction;
						}
						//terminate current item
						pCurrentItem->Terminate();
						pCurrentItem->DecRef();
						//reset for next iteration
						pCurrentItem = pCurrentItem->m_pNextQueuedAction;
						continue;
					}
				}
			}
			//set for next iteration
			pPreviousItem = pCurrentItem;
			pCurrentItem = pCurrentItem->m_pNextQueuedAction;
		}
	}

	//If any of the matches refused the item (provided they had a choice), refuse it.
	if (fRefuseIncoming)
	{
		return FALSE;
	}
	
	//Prepare action for enqeueing at end.
	pActionToEnqueue->IncRef();
	pActionToEnqueue->m_bActionQueued = TRUE;
	pActionToEnqueue->m_pNextQueuedAction=NULL;

	// If the queue is empty then make new item the head
	if(NULL == m_pHeadOfQueue)
	{
		m_pHeadOfQueue = pActionToEnqueue;
	}
	else
	//	walk until end of queue and insert there
	{
		CQueuedAction *pNextAction = m_pHeadOfQueue;
		while(pNextAction->m_pNextQueuedAction)
		{
			pNextAction = pNextAction->m_pNextQueuedAction;
		}
		//	Insert at end
		pNextAction->m_pNextQueuedAction = pActionToEnqueue;
	}
	return TRUE;
}


void CActionQueue::RemoveItem(CQueuedAction *pActionToDequeue)
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::RemoveItem, pActionToDequeue = 0x%0.8x\n", pActionToDequeue));
	//
	//	until we find the item
	//
	CQueuedAction *pPrevAction = NULL;
	CQueuedAction *pNextAction = m_pHeadOfQueue;
	while(pNextAction != pActionToDequeue)
	{
		pPrevAction = pNextAction;
		pNextAction = pNextAction->m_pNextQueuedAction;
	}
	//
	//	Found it now remove it
	//
	if( !pPrevAction )
	{
		m_pHeadOfQueue=pNextAction->m_pNextQueuedAction;
	}
	else
	{
		pPrevAction->m_pNextQueuedAction = pNextAction->m_pNextQueuedAction;
	}
	//
	//	Dereference it
	//
	pActionToDequeue->m_bActionQueued = FALSE;
	pActionToDequeue->DecRef();
}

void CActionQueue::NextJog(ULONG ulNextJogDelayMs)
{
	GCK_DBG_ENTRY_PRINT(("Entering CActionQueue::NextJog, ulNextJogDelayMs = %d\n", ulNextJogDelayMs));
	if(ulNextJogDelayMs < m_ulNextJogMs) m_ulNextJogMs = ulNextJogDelayMs;
}

void CActionQueue::ReleaseTriggers()
{
	CQueuedAction* pNextQueuedAction = m_pHeadOfQueue;
	while (pNextQueuedAction != NULL)
	{
		pNextQueuedAction->TriggerReleased();
		pNextQueuedAction = pNextQueuedAction->m_pNextQueuedAction;
	}
}

//------------------------------------------------------------------------------
//	Implementation of CAxesInput
//------------------------------------------------------------------------------
void CAxesInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	GCK_DBG_ENTRY_PRINT(("Entering CAxesInput::MapToOutput, pOutputCollection = 0x%0.8x\n", pOutputCollection));

	LONG lMungedVal;
	
	//
	//	Get the item we need to set
	//
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	CONTROL_ITEM_XFER OutputState;

	if(m_pXAssignment)
	{
		m_pXAssignment->SetValue(m_ItemState.Axes.lValX);
		m_pXAssignment->MapToOutput(pOutputCollection);
	}
	else if( pControlItem )
	{
		pControlItem->GetItemState(OutputState);
		if(m_pXBehavior)
		{
			lMungedVal = m_pXBehavior->CalculateBehavior(m_ItemState.Axes.lValX);
		}
		else
		{
			lMungedVal = m_ItemState.Axes.lValX;
		}
		OutputState.Axes.lValX = lMungedVal;
		pControlItem->SetItemState(OutputState);
	}
	if(m_pYAssignment)
	{	
		m_pYAssignment->SetValue(m_ItemState.Axes.lValY);
		m_pYAssignment->MapToOutput(pOutputCollection);
	}
	else if( pControlItem )
	{
		pControlItem->GetItemState(OutputState);
		if(m_pYBehavior)
		{
			lMungedVal = m_pYBehavior->CalculateBehavior(m_ItemState.Axes.lValY);
		}
		else
		{
			lMungedVal = m_ItemState.Axes.lValY;
		}
		OutputState.Axes.lValY = lMungedVal;
		pControlItem->SetItemState(OutputState);
	}
	return;
}

HRESULT CAxesInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	//
	//	Look at the action type
	//
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::PROPORTIONAL_MAP == pAction->GetActionClass())
	)
	{
		LONG lXMax, lYMax, lXMin, lYMin;
		GetXYRange(lXMin, lXMax, lYMin, lYMax);
		//
		//	Assign to proper axis
		//
		if(pTrigger->Axes.lValX)
		{
			if(m_pXAssignment)
			{
				m_pXAssignment->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
				pAction->SetSourceRange(lXMax, lXMin);
			}
			m_pXAssignment = pAction;
			
			hr = S_OK;
		}
		else if(pTrigger->Axes.lValY)
		{
			if(m_pYAssignment)
			{
				m_pYAssignment->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
				pAction->SetSourceRange(lYMax, lYMin);
			}
			m_pYAssignment = pAction;
			hr = S_OK;
		}
	}
	return hr;
}

HRESULT CAxesInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	HRESULT hr = E_INVALIDARG;
	LONG lMinX, lMaxX, lMinY, lMaxY;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);
	
	//
	//	Assign to proper axis
	//
	if(pTrigger->Axes.lValX)
	{
		if(m_pXBehavior)
		{
			m_pXBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinX,lMaxX);
		}
		m_pXBehavior = pBehavior;
		hr = S_OK;
	}
	else if(pTrigger->Axes.lValY)
	{
		if(m_pYBehavior)
		{
			m_pYBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinY,lMaxY);
		}
		m_pYBehavior = pBehavior;
		hr = S_OK;
	}
	return hr;
}

void CAxesInput::ClearAssignments()
{
	if(m_pXAssignment)
	{
		m_pXAssignment->DecRef();
		m_pXAssignment = NULL;
	}
	if(m_pYAssignment)
	{
		m_pYAssignment->DecRef();
		m_pYAssignment = NULL;
	}
	if(m_pXBehavior)
	{
		m_pXBehavior->DecRef();
		m_pXBehavior = NULL;
	}
	if(m_pYBehavior)
	{
		m_pYBehavior->DecRef();
		m_pYBehavior = NULL;
	}
}

void CAxesInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CAxesInput* pAxesInput = (CAxesInput*)(&rInputItem);
		if(m_pXAssignment)
		{
			m_pXAssignment->IncRef();
			pAxesInput->m_pXAssignment = m_pXAssignment;
		}
		if(m_pYAssignment)
		{
			m_pYAssignment->IncRef();
			pAxesInput->m_pYAssignment = m_pYAssignment;
		}
		if(m_pXBehavior)
		{
			m_pXBehavior->IncRef();
			pAxesInput->m_pXBehavior = m_pXBehavior;
		}
		if(m_pYBehavior)
		{
			m_pYBehavior->IncRef();
			pAxesInput->m_pYBehavior = m_pYBehavior;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CDPADInput
//------------------------------------------------------------------------------
void CDPADInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	LONG lDirection;
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;

	GetDirection(lDirection);

	if( m_lLastDirection != lDirection && (m_lLastDirection != -1) && m_pDirectionalAssignment[m_lLastDirection] )
	{
		m_pDirectionalAssignment[m_lLastDirection]->TriggerReleased();
	}
	m_lLastDirection = lDirection;

	if( (lDirection != -1) && m_pDirectionalAssignment[lDirection] )
	{
		m_pDirectionalAssignment[lDirection]->MapToOutput(pOutputCollection);
	}
	
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}

	//restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CDPADInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	CONTROL_ITEM_XFER CurrentState;
	
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		// Extract Direction from pTrigger
		CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		LONG lDirection;
		GetDirection(lDirection);
		m_ItemState = CurrentState;

		//Make sure we have a valid direction
		if(-1 == lDirection)
		{
			return E_INVALIDARG;
		}
		//
		//	Release old assignment if any
		//
		if(m_pDirectionalAssignment[lDirection])
		{
			m_pDirectionalAssignment[lDirection]->DecRef();
		}
		if(pAction)
		{
			pAction->IncRef();
		}
		m_pDirectionalAssignment[lDirection] = pAction;
		hr = S_OK;
	}

	return hr;
}

void CDPADInput::ClearAssignments()
{
	//
	//	8 is the number of directions
	//
	for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		if(m_pDirectionalAssignment[ulIndex])
		{
			m_pDirectionalAssignment[ulIndex]->DecRef();
		}
		m_pDirectionalAssignment[ulIndex]=NULL;
	}
}

void CDPADInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());

	if (rInputItem.GetType() == GetType())
	{
		CDPADInput* pDPADInput = (CDPADInput*)(&rInputItem);
		for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
		{
			if (m_pDirectionalAssignment[ulIndex])
			{
				m_pDirectionalAssignment[ulIndex]->IncRef();
				pDPADInput->m_pDirectionalAssignment[ulIndex] = m_pDirectionalAssignment[ulIndex];
			}
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CPropDPADInput
//------------------------------------------------------------------------------
void CPropDPADInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;
	
	if( IsDigitalMode() )
	{
		LONG lDirection;
		GetDirection(lDirection);

		if( m_lLastDirection != lDirection && (m_lLastDirection != -1) && m_pDirectionalAssignment[m_lLastDirection] )
		{
			m_pDirectionalAssignment[m_lLastDirection]->TriggerReleased();
		}
		m_lLastDirection = lDirection;

		if( (lDirection != -1) && m_pDirectionalAssignment[lDirection] )
		{
			SetDirection(-1); //Center - the macro will overide this
			m_pDirectionalAssignment[lDirection]->MapToOutput(pOutputCollection);
		}
	}
	else
	{
		LONG lMungedVal;
		if(m_pXBehavior)
		{
			m_ItemState.Axes.lValX = m_pXBehavior->CalculateBehavior(m_ItemState.Axes.lValX);
		}
		if(m_pYBehavior)
		{
			m_ItemState.Axes.lValY = m_pYBehavior->CalculateBehavior(m_ItemState.Axes.lValY);
		}
	}
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}
	//restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CPropDPADInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	CONTROL_ITEM_XFER CurrentState;
	
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		// Extract Direction from pTrigger
		CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		LONG lDirection;
		GetDirection(lDirection);
		m_ItemState = CurrentState;

		//Make sure we have a valid direction
		if(-1 == lDirection)
		{
			return E_INVALIDARG;
		}

		//	Release old assignment if any
		if(m_pDirectionalAssignment[lDirection])
		{
			m_pDirectionalAssignment[lDirection]->DecRef();
		}
		
		//Increment ref count on new assignment (unless it is an unassign)
		if(pAction)
		{
			pAction->IncRef();
		}
		m_pDirectionalAssignment[lDirection] = pAction;
		hr = S_OK;
	}
	return hr;
}

HRESULT CPropDPADInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	HRESULT hr = E_INVALIDARG;
	LONG lMinX, lMaxX, lMinY, lMaxY;
	GetXYRange(lMinX, lMaxX, lMinY, lMaxY);
	
	if(NULL == pBehavior)
	{
		m_fIsDigital = FALSE;
	}
	else {
		//
		//	Check if the assignment is to set it digital
		//	if so the rest of the assignment is garbage
		//	and we will throw it away
		//
		m_fIsDigital = pBehavior->IsDigital();
		if(m_fIsDigital)
		{
			//Don't worry, no need to DecRef, we would have to IncRef if we wanted to keep it.
			pBehavior=NULL;
		}
	}

	//
	//	Assign to proper axis
	//
	if(pTrigger->PropDPAD.lValX)
	{
		if(m_pXBehavior)
		{
			m_pXBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinX,lMaxX);
		}
		m_pXBehavior = pBehavior;
		hr = S_OK;
	}
	else if(pTrigger->PropDPAD.lValY)
	{
		if(m_pYBehavior)
		{
			m_pYBehavior->DecRef();
		}
		if(pBehavior)
		{
			pBehavior->IncRef();
			pBehavior->Calibrate(lMinY,lMaxY);
		}
		m_pYBehavior = pBehavior;
		hr = S_OK;
	}
	return hr;
}

void CPropDPADInput::SwitchPropDPADMode()
{
	//
	//	Feature two switch the mode is always two bytes long,
	//	one for ReportId, the other for the data which is just a bit
	//
	UCHAR rgucReport[2];
	if( GetModeSwitchFeaturePacket(m_fIsDigital, rgucReport, m_pClientServices->GetHidPreparsedData()) )
	{
		m_pClientServices->DeviceSetFeature(rgucReport, 2);
	}
}

void CPropDPADInput::ClearAssignments()
{
	//
	//	8 is the number of directions
	//
	for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		if(m_pDirectionalAssignment[ulIndex])
		{
			m_pDirectionalAssignment[ulIndex]->DecRef();
		}
		
		m_pDirectionalAssignment[ulIndex]=NULL;
	}
	
	//
	//	Now clear behaviors
	//
	if(m_pXBehavior)
	{
		m_pXBehavior->DecRef();
		m_pXBehavior = NULL;
	}
	if(m_pYBehavior)
	{
		m_pYBehavior->DecRef();
		m_pYBehavior = NULL;
	}
}

void CPropDPADInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());

	if (rInputItem.GetType() == GetType())
	{
		CPropDPADInput* pPropDPADInput = (CPropDPADInput*)(&rInputItem);
		for (ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
		{
			if (m_pDirectionalAssignment[ulIndex])
			{
				m_pDirectionalAssignment[ulIndex]->IncRef();
				pPropDPADInput->m_pDirectionalAssignment[ulIndex] = m_pDirectionalAssignment[ulIndex];
			}
		}
		if (m_pXBehavior)
		{
			m_pXBehavior->IncRef();
			pPropDPADInput->m_pXBehavior = m_pXBehavior;
		}
		if (m_pYBehavior)
		{
			m_pYBehavior->IncRef();
			pPropDPADInput->m_pYBehavior = m_pYBehavior;
		}
		
		pPropDPADInput->m_fIsDigital = m_fIsDigital;
	}
}


//------------------------------------------------------------------------------
//	Implementation of CButtonsInput
//------------------------------------------------------------------------------

void CButtonsInput::GetLowestShiftButton(USHORT& rusLowestShiftButton) const
{
	if (m_cpControlItemDesc->pModifierDescTable == NULL)
	{
		rusLowestShiftButton = 0;
		return;
	}

	ULONG ulMask =  (1 << m_cpControlItemDesc->pModifierDescTable->ulShiftButtonCount)-1;
	ULONG ulShiftStates = m_ItemState.ulModifiers & ulMask;
	rusLowestShiftButton = 0;
	while (ulShiftStates != 0)
	{
		rusLowestShiftButton++;
		if (ulShiftStates & 0x00000001)
		{
			break;
		}
		ulShiftStates >>= 1;
	}
}

void CButtonsInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	ULONG ulNumButtons = (GetButtonMax()-GetButtonMin())+1;
	ULONG ulButtonBits;
	USHORT usLowestShift;
	USHORT usButtonNum;
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;

	GetLowestShiftButton(usLowestShift);
	
	GetButtons(usButtonNum, ulButtonBits);
/*	if ((ulButtonBits == 0) && (usLowestShift != 0) && (usLowestShift == m_usLastShift))
	{
		ulButtonBits = m_ulLastButtons;
	}
	else if ((usLowestShift == 0) && (ulButtonBits != 0) && (ulButtonBits == m_ulLastButtons))
*/	if ((usLowestShift == 0) && (ulButtonBits != 0) && (ulButtonBits == m_ulLastButtons))
	{
		usLowestShift = m_usLastShift;
	}

	ULONG ulBaseIndex = usLowestShift * ulNumButtons;
	ULONG ulLastBaseIndex = m_usLastShift * ulNumButtons;
	m_ulLastButtons = ulButtonBits;
	
	ULONG ulMask = 1;
	for( ULONG ulButtonsIndex = 0; ulButtonsIndex < ulNumButtons; ulButtonsIndex++)
	{
		
		// Release assignments that are not down in this shift-state
		if ((m_usLastShift != usLowestShift) || ((ulMask & ulButtonBits) == 0))
		{
			ASSERT((ulLastBaseIndex + ulButtonsIndex) < m_ulNumAssignments);
//			DbgPrint("Releasing(%d)\n", ulLastBaseIndex + ulButtonsIndex);
			if (m_ppAssignments[ulLastBaseIndex + ulButtonsIndex])
			{
				m_ppAssignments[ulLastBaseIndex + ulButtonsIndex]->TriggerReleased();
			}
		}

		//	Drive outputs that are down
		if (ulMask & ulButtonBits)
		{
			ASSERT((ulBaseIndex + ulButtonsIndex) < m_ulNumAssignments);
//			DbgPrint("Playing(%d)\n", ulBaseIndex + ulButtonsIndex);
			if (m_ppAssignments[ulBaseIndex + ulButtonsIndex])	// Only if there is an assignment in this shift-state
			{
				
				GCK_DBG_TRACE_PRINT(("About to trigger macro on index %d group.\n", ulBaseIndex+ulButtonsIndex));
				m_ppAssignments[ulBaseIndex + ulButtonsIndex]->MapToOutput(pOutputCollection);
				ulButtonBits = ulButtonBits & (~ulMask);	// Assigned buttons are cleared out of packet
				GCK_DBG_TRACE_PRINT(("Masking Trigger, ulMask = 0x%0.8x, ulButtonBits(new) = 0x%0.8x \n", ulMask, ulButtonBits));
			}
		}

		ulMask <<= 1;
	}
	
	m_usLastShift = usLowestShift;

	//
	//  Adjust bits based on assignments
	//
	SetButtons(0, ulButtonBits);

	//
	//	Set output
	//
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}
	//restore internal state
	m_ItemState = cixRememberState;
}
HRESULT CButtonsInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;

	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		//ensure that we initialized
		if(!m_ppAssignments)
		{
			return E_OUTOFMEMORY;
		}
		// Extract Shift State and Button number from trigger
		CONTROL_ITEM_XFER CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		USHORT	usButtonNumber;
		ULONG	ulBogus;
		USHORT	usLowestShift = 0;

		GetButtons(usButtonNumber, ulBogus);
		GetLowestShiftButton(usLowestShift);

		m_ItemState = CurrentState;

		//validate existance of specified button
		if(
			(usButtonNumber < GetButtonMin()) ||
			(usButtonNumber > GetButtonMax()) ||
			(usLowestShift >> GetNumShiftButtons())
		)
		{
			GCK_DBG_ERROR_PRINT(("usButtonNumber(%d) < GetButtonMin()(%d)\n", usButtonNumber, GetButtonMin()));
			GCK_DBG_ERROR_PRINT(("usButtonNumber(%d) > GetButtonMax()(%d)\n", usButtonNumber, GetButtonMax()));
			GCK_DBG_ERROR_PRINT(("usLowestShift(0x%0.8x) >> GetNumShiftButtons()(0x%0.8x) = 0x%0.8x\n",
				usLowestShift, GetNumShiftButtons(), (usLowestShift >> GetNumShiftButtons()) ));
			ASSERT(FALSE && "Faulty assignment was out of range.");
			return hr;
		}
		
		//	Code assumes shifts are used as combos
		ULONG ulAssignIndex = ((GetButtonMax()-GetButtonMin())+1)*usLowestShift + usButtonNumber - GetButtonMin();

		//If there was an assignment, unassign
		if( m_ppAssignments[ulAssignIndex] )
		{
			m_ppAssignments[ulAssignIndex]->DecRef();
		}
		
		//If there is really an assignment increment its ref count
		if(pAction)
		{
			pAction->IncRef();
		}
		GCK_DBG_TRACE_PRINT(("CButtonsInput::AssignAction, new assignment for index %d, pAction = 0x%0.8x\n", ulAssignIndex, pAction));
		m_ppAssignments[ulAssignIndex] = pAction;

		hr = S_OK;
	}
	return hr;
}

void CButtonsInput::ClearAssignments()
{
	if(m_ppAssignments)
	{
		for(ULONG ulIndex = 0; ulIndex < m_ulNumAssignments; ulIndex++)
		{
			if( m_ppAssignments[ulIndex] )
			{
				m_ppAssignments[ulIndex]->DecRef();
				m_ppAssignments[ulIndex] = NULL;
			}
		}
	}
}

void CButtonsInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());

	if (rInputItem.GetType() == GetType())
	{
		CButtonsInput* pButtonsInput = (CButtonsInput*)(&rInputItem);
		pButtonsInput->m_ulNumAssignments = m_ulNumAssignments;
		if (m_ppAssignments)
		{
			for (ULONG ulIndex = 0; ulIndex < m_ulNumAssignments; ulIndex++)
			{
				if (m_ppAssignments[ulIndex])
				{
					m_ppAssignments[ulIndex]->IncRef();
					pButtonsInput->m_ppAssignments[ulIndex] = m_ppAssignments[ulIndex];
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CThrottleInput
//------------------------------------------------------------------------------
void CThrottleInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		if( pControlItem )
		{
			pControlItem->SetItemState(m_ItemState);
		}
}
HRESULT CThrottleInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CThrottleInput::ClearAssignments()
{
}

void CThrottleInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CPOVInput
//------------------------------------------------------------------------------
void CPOVInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	LONG lDirection;
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;
	GetValue(lDirection);
	
	//Out of range values are centered as per HID spec.  We use -1 throughout.
	if( (7 < lDirection) || (0 > lDirection) )
	{
		lDirection = -1;
	}
	//If POV has changed direction (other than from center) release macro.
	if( m_lLastDirection != lDirection && (m_lLastDirection != -1) && m_pDirectionalAssignment[m_lLastDirection] )
	{
		m_pDirectionalAssignment[m_lLastDirection]->TriggerReleased();
	}
	m_lLastDirection = lDirection;

	//If direction is other than centered, and assigned, play assignment
	if( (lDirection != -1) && m_pDirectionalAssignment[lDirection] )
	{
		//Center POV (macro may override this.)
		SetValue(-1); 
		//PlayMacro -will put itself in queue
		m_pDirectionalAssignment[lDirection]->MapToOutput(pOutputCollection);
	}
	
	
	//	Copy state of POV over to output
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem )
	{
		pControlItem->SetItemState(m_ItemState);
	}
	//restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CPOVInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr = E_INVALIDARG;
	CONTROL_ITEM_XFER CurrentState;
	
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) ||
		(CAction::QUEUED_MACRO == pAction->GetActionClass())
	)	
	{
		// Extract Direction from pTrigger
		CurrentState = m_ItemState;
		m_ItemState = *pTrigger;
		LONG lDirection;
		GetValue(lDirection);
		m_ItemState = CurrentState;

		if( (7 < lDirection) || (0 > lDirection) )
		{
			ASSERT(FALSE && "Assignment was out of range!");
			return hr;
		}

		//
		//	Release old assignment if any
		//
		if(m_pDirectionalAssignment[lDirection])
		{
			m_pDirectionalAssignment[lDirection]->DecRef();
		}
		if(pAction)
		{
			pAction->IncRef();
		}
		m_pDirectionalAssignment[lDirection] = pAction;
		hr = S_OK;
	}

	return hr;
}

void CPOVInput::ClearAssignments()
{
	//
	//	8 is the number of directions
	//
	for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
	{
		if(m_pDirectionalAssignment[ulIndex])
		{
			m_pDirectionalAssignment[ulIndex]->DecRef();
		}
		m_pDirectionalAssignment[ulIndex]=NULL;
	}
}

void CPOVInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CPOVInput* pPOVInput = (CPOVInput*)(&rInputItem);
		for (ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
		{
			if (m_pDirectionalAssignment[ulIndex])
			{
				m_pDirectionalAssignment[ulIndex]->IncRef();
				pPOVInput->m_pDirectionalAssignment[ulIndex] = m_pDirectionalAssignment[ulIndex];
			}
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CWheelInput
//------------------------------------------------------------------------------
void CWheelInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		CONTROL_ITEM_XFER OutputState;
		//If there is an output, drive it
		if( pControlItem )
		{
			//Get the current state of the output.
			pControlItem->GetItemState(OutputState);
			//If we have a behavior use it
			if(m_pBehavior)
			{
				OutputState.Wheel.lVal = 
					m_pBehavior->CalculateBehavior(m_ItemState.Wheel.lVal);
			}
			//If no behavior do a straight map
			else
			{
				OutputState.Wheel.lVal = m_ItemState.Wheel.lVal;
			}
			//drive the output
			pControlItem->SetItemState(OutputState);
		}
}
HRESULT CWheelInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

HRESULT CWheelInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	//We do not care about the details of pTrigger
	UNREFERENCED_PARAMETER(pTrigger); 
	if(m_pBehavior)
	{
		m_pBehavior->DecRef();
	}
	if(pBehavior)
	{
		pBehavior->IncRef();
		LONG lMin,lMax;
		GetRange(lMin, lMax);
		pBehavior->Calibrate(lMin,lMax);
	}
	m_pBehavior = pBehavior;
	return S_OK;
}

void CWheelInput::ClearAssignments()
{
	if(m_pBehavior)
	{
		m_pBehavior->DecRef();
		m_pBehavior = NULL;
	}
}

void CWheelInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CWheelInput* pWheelInput = (CWheelInput*)(&rInputItem);
		if (m_pBehavior)
		{
			m_pBehavior->IncRef();
			pWheelInput->m_pBehavior = m_pBehavior;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CPedalInput
//------------------------------------------------------------------------------
void CPedalInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if( pControlItem != NULL )
	{
		if(m_pAssignment)
		{
			m_pAssignment->SetValue(m_ItemState.Pedal.lVal);
			m_pAssignment->MapToOutput(pOutputCollection);
		}
		else
		{
			pControlItem->SetItemState(m_ItemState);
		}
	}
}

HRESULT CPedalInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);

	HRESULT hr = E_INVALIDARG;
	//
	//	Look at the action type
	//
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::PROPORTIONAL_MAP == pAction->GetActionClass())
	)
	{
		LONG lMax, lMin;
		GetRange(lMin, lMax);
		
		if(m_pAssignment)
		{
			m_pAssignment->DecRef();
		}
		if(pAction)
		{
			pAction->IncRef();
			pAction->SetSourceRange(lMax, lMin);
		}
		m_pAssignment = pAction;
		hr = S_OK;
	}
	return hr;
}

void CPedalInput::ClearAssignments()
{
	if(m_pAssignment)
	{
		m_pAssignment->DecRef();
		m_pAssignment = NULL;
	}
}

void CPedalInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CPedalInput* pPedalInput = (CPedalInput*)(&pPedalInput);
		if (m_pAssignment)
		{
			m_pAssignment->IncRef();
			pPedalInput->m_pAssignment = m_pAssignment;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CRudderInput
//------------------------------------------------------------------------------
void CRudderInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		if( pControlItem != NULL )
		{
			pControlItem->SetItemState(m_ItemState);
		}
}
HRESULT CRudderInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CRudderInput::ClearAssignments()
{
}

void CRudderInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CZoneIndicatorInput
//------------------------------------------------------------------------------
void CZoneIndicatorInput::MapToOutput( CControlItemDefaultCollection *pOutputCollection )
{
		CControlItem *pControlItem;
		
		#if (DBG==1)
		if( GetXIndicator() )
		{
			GCK_DBG_TRACE_PRINT(("Zulu X axis in zone.\n"));
		}
		if( GetYIndicator() )
		{
			GCK_DBG_TRACE_PRINT(("Zulu Y axis in zone.\n"));
		}
		#endif

		if( m_pAssignmentX && GetXIndicator() )
		{
			m_pAssignmentX->MapToOutput(pOutputCollection);
		}
		if( m_pAssignmentY && GetYIndicator() )
		{
			m_pAssignmentY->MapToOutput(pOutputCollection);
		}


		pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
		if( pControlItem )
		{
			pControlItem->SetItemState(m_ItemState);
		}
}

HRESULT CZoneIndicatorInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	HRESULT hr=E_INVALIDARG;
	if(
		(NULL == pAction) ||	//This must be first!!! - NULL is valid it will just unassign
		(CAction::DIGITAL_MAP == pAction->GetActionClass()) 
	)
	{
		if(pTrigger->ZoneIndicators.ulZoneIndicatorBits & CZoneIndicatorItem::X_ZONE)
		{
			if(m_pAssignmentX)
			{
				m_pAssignmentX->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
			}
			m_pAssignmentX = pAction;
			hr=S_OK;
		}
		else if(pTrigger->ZoneIndicators.ulZoneIndicatorBits & CZoneIndicatorItem::Y_ZONE)
		{
			if(m_pAssignmentY)
			{
				m_pAssignmentY->DecRef();
			}
			if(pAction)
			{
				pAction->IncRef();
			}
			m_pAssignmentY = pAction;
			hr=S_OK;
		}
	}
	return hr;
}

void CZoneIndicatorInput::ClearAssignments()
{
	if(m_pAssignmentX)
	{
		m_pAssignmentX->DecRef();
		m_pAssignmentX = NULL;
	}
	if(m_pAssignmentY)
	{
		m_pAssignmentY->DecRef();
		m_pAssignmentY = NULL;
	}
}

void CZoneIndicatorInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CZoneIndicatorInput* pZoneIndicatorInput = (CZoneIndicatorInput*)&rInputItem;
		if (m_pAssignmentX)
		{
			m_pAssignmentX->IncRef();
			pZoneIndicatorInput->m_pAssignmentX = m_pAssignmentX;
		}
		if (m_pAssignmentY)
		{
			m_pAssignmentY->IncRef();
			pZoneIndicatorInput->m_pAssignmentY = m_pAssignmentY;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CDualZoneIndicatorInput
//------------------------------------------------------------------------------
CDualZoneIndicatorInput::CDualZoneIndicatorInput
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		//@parm [IN] Pointer to Item Description from table
) :	CDualZoneIndicatorItem(cpControlItemDesc),
	m_ppAssignments(NULL),
	m_pBehavior(NULL),
	m_lLastZone(-1)
{
	m_lNumAssignments = cpControlItemDesc->DualZoneIndicators.lNumberOfZones;
	m_ppAssignments = new WDM_NON_PAGED_POOL CAction *[m_lNumAssignments];
	if(!m_ppAssignments)
	{
		ASSERT(FALSE);
		return;
	}

	for (LONG lIndex = 0; lIndex < m_lNumAssignments; lIndex++)
	{
		m_ppAssignments[lIndex] = NULL;
	}
}

void CDualZoneIndicatorInput::MapToOutput(CControlItemDefaultCollection *pOutputCollection)
{
	CONTROL_ITEM_XFER cixRememberState = m_ItemState;

	// Find zone (use behaviour if appropriate)
	LONG lNewZone = LONG(-1);
	if (m_pBehavior != NULL)
	{
		CURVE_POINT curvePoint = ((CStandardBehavior*)m_pBehavior)->GetBehaviorPoint(0);
		if ((curvePoint.sX == 0) || (curvePoint.sY == 0))
		{
			lNewZone = GetActiveZone() - 1;		// Use defaults either one being 0 will get stuck
		}
		else
		{
	//		DbgPrint("curvePoint.sX (%d), curvePoint.sY (%d)\n", curvePoint.sX, curvePoint.sY);
			lNewZone = GetActiveZone(curvePoint.sX, curvePoint.sY) - 1;
		}
	}
	else
	{
		lNewZone = GetActiveZone() - 1;
	}
	
	//	Are we in a new zone?
	if (lNewZone != m_lLastZone)
	{
		// Start the new one (if valid)
		if ((lNewZone >= 0) && (lNewZone < m_lNumAssignments))
		{
			if (m_ppAssignments[lNewZone])
			{
				m_ppAssignments[lNewZone]->MapToOutput(pOutputCollection);
				GCK_DBG_TRACE_PRINT(("About to trigger macro on index %d.\n", lNewZone));
			}
		}

		// End the last one (if valid)
		if ((m_lLastZone >= 0) && (m_lLastZone < m_lNumAssignments))
		{
			if (m_ppAssignments[m_lLastZone])
			{
				m_ppAssignments[m_lLastZone]->TriggerReleased();
			}
		}

		// Update previous zone to current
		m_lLastZone = lNewZone;
	}

	
	//	Set output
	CControlItem *pControlItem;
	pControlItem = pOutputCollection->GetFromControlItemXfer(m_ItemState);
	if (pControlItem)
	{
		pControlItem->SetItemState(m_ItemState);
	}

	// Restore internal state
	m_ItemState = cixRememberState;
}

HRESULT CDualZoneIndicatorInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	// Ensure that we initialized
	if (!m_ppAssignments)
	{
		return E_OUTOFMEMORY;
	}

	// Extract Zone from trigger
	CONTROL_ITEM_XFER CurrentState = m_ItemState;
	m_ItemState = *pTrigger;
	LONG lZoneNumber = GetActiveZone() - 1;
	m_ItemState = CurrentState;

	//validate existance of specified button
	if (lZoneNumber < 0 || lZoneNumber >= m_lNumAssignments)
	{
		GCK_DBG_ERROR_PRINT(("lCurrentZone(%d) out of range (1 - %d\n", lZoneNumber+1, m_lNumAssignments));
		ASSERT(FALSE && "Faulty assignment was out of range.");
		return E_INVALIDARG;
	}
	
	// Was there an assignment
	if (m_ppAssignments[lZoneNumber])
	{	// Yes - Unassign old
		m_ppAssignments[lZoneNumber]->DecRef();
	}
	
	// Are we setting in a new assignment
	if (pAction)
	{	// Yes - increment ref count
		pAction->IncRef();
		if (pAction->GetActionClass() == CAction::QUEUED_MACRO)
		{
			CQueuedAction* pQueuedAction = (CQueuedAction*)pAction;
			pQueuedAction->ForceBleedThrough();
		}
	}
	GCK_DBG_TRACE_PRINT(("CDualZoneIndicatorInput::AssignAction, new assignment for index %d, pAction = 0x%0.8x\n", lZoneNumber, pAction));
	m_ppAssignments[lZoneNumber] = pAction;

	return S_OK;
}

HRESULT CDualZoneIndicatorInput::AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
{
	UNREFERENCED_PARAMETER(pTrigger);

	if (m_pBehavior != NULL)
	{
		m_pBehavior->DecRef();
	}
	if (pBehavior != NULL)
	{
		pBehavior->IncRef();
	}
	m_pBehavior = pBehavior;

	return S_OK;
}

void CDualZoneIndicatorInput::ClearAssignments()
{
	if (m_ppAssignments)
	{
		for (LONG lIndex = 0; lIndex < m_lNumAssignments; lIndex++)
		{
			if (m_ppAssignments[lIndex] )
			{
				m_ppAssignments[lIndex]->DecRef();
				m_ppAssignments[lIndex] = NULL;
			}
		}
	}
	if (m_pBehavior != NULL)
	{
		m_pBehavior->DecRef();
		m_pBehavior = NULL;
	}
}

void CDualZoneIndicatorInput::Duplicate(CInputItem& rInputItem)
{
	ASSERT(rInputItem.GetType() == GetType());
	if (rInputItem.GetType() == GetType())
	{
		CDualZoneIndicatorInput* pDualZoneIndicatorInput = (CDualZoneIndicatorInput*)&rInputItem;
		if (m_ppAssignments)
		{
			for (LONG lIndex = 0; lIndex < m_lNumAssignments; lIndex++)
			{
				if (m_ppAssignments[lIndex] )
				{
					m_ppAssignments[lIndex]->IncRef();
					pDualZoneIndicatorInput->m_ppAssignments[lIndex] = m_ppAssignments[lIndex];
				}
			}
		}
		if (m_pBehavior != NULL)
		{
			m_pBehavior->IncRef();
			pDualZoneIndicatorInput->m_pBehavior = m_pBehavior;
		}
	}
}

//------------------------------------------------------------------------------
//	Implementation of CProfileSelectorInput
//------------------------------------------------------------------------------
HRESULT CProfileSelectorInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CProfileSelectorInput::MapToOutput(CControlItemDefaultCollection *pOutputCollection)
{
	UNREFERENCED_PARAMETER(pOutputCollection);
	// Nothing to do, we don't want to report this data up.
}

void CProfileSelectorInput::ClearAssignments()
{
}

void CProfileSelectorInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CButtonLEDInput
//------------------------------------------------------------------------------
CButtonLEDInput::CButtonLEDInput
(
	const CONTROL_ITEM_DESC *cpControlItemDesc		//@parm [IN] Description for this item
) : CButtonLED(cpControlItemDesc),
	m_pCorrespondingButtonsItem(NULL),
	m_pLEDSettings(NULL),
	m_usNumberOfButtons(0)
{
	m_ucCorrespondingButtonItemIndex = cpControlItemDesc->ButtonLEDs.ucCorrespondingButtonItem;
}

CButtonLEDInput::~CButtonLEDInput()
{
	m_pCorrespondingButtonsItem = NULL;
	if (m_pLEDSettings != NULL)
	{
		delete[] m_pLEDSettings;
		m_pLEDSettings = NULL;
	}
	m_usNumberOfButtons = 0;
};

void CButtonLEDInput::Init(CInputItem* pCorrespondingButtons)
{
	m_pCorrespondingButtonsItem = (CButtonsInput*)pCorrespondingButtons;
	if (m_pCorrespondingButtonsItem != NULL)
	{
		ASSERT(m_pCorrespondingButtonsItem->GetType() == ControlItemConst::usButton);

//		m_usNumberOfButtons = m_pCorrespondingButtonsItem->GetButtonMax() - m_pCorrespondingButtonsItem->GetButtonMin() + 1;
		m_usNumberOfButtons = 0xC;
		ULONG ulNumShift = m_pCorrespondingButtonsItem->GetNumShiftButtons() + 1;
		ULONG ulNumBytes = ((m_usNumberOfButtons * ulNumShift * 2) + 7) / 8;
		m_pLEDSettings = new WDM_NON_PAGED_POOL UCHAR[ulNumBytes];
		if (m_pLEDSettings != NULL)
		{
			RtlZeroMemory(reinterpret_cast<PVOID>(m_pLEDSettings), ulNumBytes);	// Zero is default state
		}
	}
}

HRESULT CButtonLEDInput::AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)
{
	UNREFERENCED_PARAMETER(pTrigger);
	UNREFERENCED_PARAMETER(pAction);
	return E_NOTIMPL;
}

void CButtonLEDInput::MapToOutput(CControlItemDefaultCollection *pOutputCollection)
{
	UNREFERENCED_PARAMETER(pOutputCollection);
}

void CButtonLEDInput::SetLEDStates
(
	GCK_LED_BEHAVIOURS ucLEDBehaviour,	//@parm [IN] State change for affected LEDs
	ULONG ulLEDsAffected,				//@parm [IN] LEDs affected by change
	unsigned char ucShiftArray			//@parm [IN] Shift states to change
)
{
	if (m_pLEDSettings != NULL)
	{
		// Cycle through the shift states
		ULONG ulNumShift = m_pCorrespondingButtonsItem->GetNumShiftButtons() + 1;
		for (ULONG ulShiftIndex = 0; ulShiftIndex < ulNumShift; ulShiftIndex++)
		{
			// Are we interested in this shift state?
			if ((ucShiftArray & (1 << ulShiftIndex)) != 0)
			{
				USHORT usShiftBase = USHORT(ulShiftIndex * m_usNumberOfButtons);
				// Cycle through the buttons
				for (USHORT usButtonIndex = 0; usButtonIndex < m_usNumberOfButtons; usButtonIndex++)
				{
					USHORT usTrueIndex = usShiftBase + usButtonIndex;
					if ((ulLEDsAffected & (1 << usButtonIndex)) != 0)
					{
						USHORT usByte = usTrueIndex/4;
						USHORT usBitPos = (usTrueIndex % 4) * 2;
						m_pLEDSettings[usByte] &= ~(0x0003 << usBitPos);
						m_pLEDSettings[usByte] |= (ucLEDBehaviour & 0x0003) << usBitPos;
					}
				}
			}
		}
	}
}


void CButtonLEDInput::AssignmentsChanged()
{
	UCHAR featureData[3];
	featureData[0] = 1;		// Report ID;
	featureData[1] = 0;		// LEDs 4 - 1 off
	featureData[2] = 0;		// LEDs 7 - 5 off

	if (m_pCorrespondingButtonsItem != NULL)
	{
		USHORT usLowestShift = 0;
		m_pCorrespondingButtonsItem->GetLowestShiftButton(usLowestShift);
		USHORT usShiftBase = usLowestShift * m_usNumberOfButtons;

		for (USHORT usButtonIndex = 0; usButtonIndex < m_usNumberOfButtons; usButtonIndex++)
		{
			// Hack for Atilla
			if ((usButtonIndex > 5) && (usButtonIndex < 0xB))
			{
				continue;	// These buttons are not really there
			}

			USHORT usByte = (usButtonIndex + usShiftBase)/4;
			USHORT usBitPos = ((usButtonIndex + usShiftBase) % 4) * 2;
			UCHAR ucLEDBehaviour = (m_pLEDSettings[usByte] & (0x0003 << usBitPos)) >> usBitPos;

			// Value settings
			UCHAR ucValueSettings = 0;
			switch (ucLEDBehaviour)
			{
				case GCK_LED_BEHAVIOUR_DEFAULT:
				{
					if (usButtonIndex <= 0x05)	// Hack for Atilla
					{
						if (m_pCorrespondingButtonsItem->IsButtonAssigned(usButtonIndex + m_pCorrespondingButtonsItem->GetButtonMin(), usLowestShift))
						{
							ucValueSettings = 0x01;
						}
					}
					break;
				}
				case GCK_LED_BEHAVIOUR_ON:
				{
					ucValueSettings = 0x01;
					break;
				}
				case GCK_LED_BEHAVIOUR_OFF:
				{
					break;
				}
				case GCK_LED_BEHAVIOUR_BLINK:
				{
					ucValueSettings = 0x02;
					break;
				}
				
			}

			// Hack for Atilla
			if (usButtonIndex < 4)
			{
				featureData[1] |= (ucValueSettings << (usButtonIndex * 2));
			}
			else
			{
				USHORT usNewButton = usButtonIndex - 4;
				if (usNewButton > 5)
				{
					usNewButton -= 5;
				}
				featureData[2] |= (ucValueSettings << (usNewButton * 2));
			}
		}
	}

	NTSTATUS NtStatus = m_pClientServices->DeviceSetFeature(featureData, 3);
}

void CButtonLEDInput::ClearAssignments()
{
}

void CButtonLEDInput::Duplicate(CInputItem& rInputItem)
{
	UNREFERENCED_PARAMETER(rInputItem);
}

//------------------------------------------------------------------------------
//	Implementation of CKeyMixer
//------------------------------------------------------------------------------
#define KEYBOARD_NO_EVENT 0
#define KEYBOARD_ERROR_ROLLOVER 1
#define MAX_KEYSTROKES 6


CKeyMixer *CKeyMixer::ms_pHeadKeyMixer = NULL;
ULONG CKeyMixer::ms_rgulGlobalKeymap[5] = {0};
UCHAR CKeyMixer::ms_ucLastModifiers = 0;

CKeyMixer::CKeyMixer(CFilterClientServices *pFilterClientServices):
		  m_pFilterClientServices(pFilterClientServices), m_fEnabled(TRUE)
{
	//Ensure that we did not get passed a null pointer
	ASSERT(m_pFilterClientServices);
	m_pFilterClientServices->IncRef();
	//
	// Add this instance to head of linked list
	// Note that this works even if the list was empty.
	//
	pNextKeyMixer = ms_pHeadKeyMixer;
	ms_pHeadKeyMixer = this;
	
	//Mark All keys up
	ClearState();
}

CKeyMixer::~CKeyMixer()
{
	//check if we are the, easy to remove ourselves
	if(this == ms_pHeadKeyMixer)
	{
		ms_pHeadKeyMixer = pNextKeyMixer;
	}
	else
	//find us in list and remove ourselves
	{
		CKeyMixer *pPrevKeyMixer = ms_pHeadKeyMixer;
		while(pPrevKeyMixer->pNextKeyMixer)
		{
			if(this == pPrevKeyMixer->pNextKeyMixer)
			{
				pPrevKeyMixer->pNextKeyMixer = pNextKeyMixer;
				break;
			}
			pPrevKeyMixer = pPrevKeyMixer->pNextKeyMixer;
		}
	}
	m_pFilterClientServices->DecRef();
	m_pFilterClientServices=NULL;
}

void CKeyMixer::SetState(const CONTROL_ITEM_XFER& crcixNewLocalState)
{
//	if(!m_fEnabled) return;
	m_cixLocalState = crcixNewLocalState;
}

void CKeyMixer::OverlayState(const CONTROL_ITEM_XFER& crcixNewLocalState)
{
//	if(!m_fEnabled) return;
	//Mix New LocalState with existing local state
	CONTROL_ITEM_XFER cixTemp;
	MIX_ALGO_PARAM MixAlgoParam;
	
	//Save previous local state
	cixTemp = m_cixLocalState;
	
	//Init MixAlgoParam - and attach m_cixLocalState as the mix destination
	//This inherently wipes m_cixLocalState, which is why we saved its
	//previous state.
	InitMixAlgoParam(&MixAlgoParam, &m_cixLocalState);

	//Mix in Previous State
	MixAlgorithm(&MixAlgoParam, &cixTemp);

	//Mix in New Local State
	MixAlgorithm(&MixAlgoParam, &crcixNewLocalState);

	return;
}

void CKeyMixer::ClearState()
{
//	if(!m_fEnabled) return;
	//This does a little more than it needs to, but it saves code duplication
	MIX_ALGO_PARAM MixAlgoParam;
	InitMixAlgoParam(&MixAlgoParam, &m_cixLocalState);
}

void CKeyMixer::PlayGlobalState(BOOLEAN fPlayIfNoChange)
{
//	if(!m_fEnabled) return;
	CONTROL_ITEM_XFER cixNewGlobalState;
	MIX_ALGO_PARAM MixAlgoParam;
	
	//Init MixAlgoParam - and attach cixNewGlobalState as the mix destination
	InitMixAlgoParam(&MixAlgoParam, &cixNewGlobalState);
	
	//Walk list of all Local states and mix in to new global state
	CKeyMixer *pCurrentKeyMixer;
	for(pCurrentKeyMixer = ms_pHeadKeyMixer; NULL!=pCurrentKeyMixer; pCurrentKeyMixer = pCurrentKeyMixer->pNextKeyMixer)
	{
		MixAlgorithm(&MixAlgoParam, &pCurrentKeyMixer->m_cixLocalState);
	}

	//If global state has changed, or if fPlayIfNoChange is TRUE, play change
	if  (fPlayIfNoChange ||
		!CompareKeyMap(MixAlgoParam.rgulKeyMap, ms_rgulGlobalKeymap) ||
		ms_ucLastModifiers != cixNewGlobalState.Keyboard.ucModifierByte
	)
	{
		m_pFilterClientServices->PlayKeys(cixNewGlobalState, m_fEnabled);
	}
	
	//set Global State to New Global State
	CopyKeyMap(ms_rgulGlobalKeymap, MixAlgoParam.rgulKeyMap);
	ms_ucLastModifiers = cixNewGlobalState.Keyboard.ucModifierByte;
}

void CKeyMixer::Enable(BOOLEAN fEnable)
{
	//set enabled state
	m_fEnabled = fEnable;
	//if disabling, bring all keys up
	if(!m_fEnabled)
	{
		MIX_ALGO_PARAM MixAlgoParam;
		InitMixAlgoParam(&MixAlgoParam, &m_cixLocalState);
	}
}
void CKeyMixer::InitMixAlgoParam(CKeyMixer::MIX_ALGO_PARAM *pMixAlgParm, CONTROL_ITEM_XFER *pcixDest)
{
	//Mark no keys set
	pMixAlgParm->ulDestCount=0;
	//Clear KeyMap
	pMixAlgParm->rgulKeyMap[0]=0;
	pMixAlgParm->rgulKeyMap[1]=0;
	pMixAlgParm->rgulKeyMap[2]=0;
	pMixAlgParm->rgulKeyMap[3]=0;
	pMixAlgParm->rgulKeyMap[4]=0;

	//Init desitination as pristine
	pMixAlgParm->pcixDest = pcixDest;

	//Mark as keyboard Xfer
	pMixAlgParm->pcixDest->ulItemIndex = NonGameDeviceXfer::ulKeyboardIndex;
	//Clear Modifiers
	pMixAlgParm->pcixDest->Keyboard.ucModifierByte = 0;
	//Clear down keys
	for(ULONG ulIndex = 0; ulIndex < 6; ulIndex++)
	{
		pMixAlgParm->pcixDest->Keyboard.rgucKeysDown[ulIndex] = 0;
	}
}

void CKeyMixer::MixAlgorithm(CKeyMixer::MIX_ALGO_PARAM *pMixAlgParam, const CONTROL_ITEM_XFER *pcixSrc)
{
	UCHAR ucMapBit;
	UCHAR ucMapByte;

	//OR in modifier Bytes
	pMixAlgParam->pcixDest->Keyboard.ucModifierByte |= pcixSrc->Keyboard.ucModifierByte;
	
	//loop over all possible keys in source
	for(ULONG ulIndex=0; ulIndex < MAX_KEYSTROKES; ulIndex++)
	{
		//Skip non-entries
		if( KEYBOARD_NO_EVENT == pcixSrc->Keyboard.rgucKeysDown[ulIndex])
		{
			continue;
		}
		//Compute byte, bit, and mask for keymap
		ucMapByte = pcixSrc->Keyboard.rgucKeysDown[ulIndex]/32;
		ucMapBit = pcixSrc->Keyboard.rgucKeysDown[ulIndex]%32;
		//If not already in keymap add to destination
		if( !(pMixAlgParam->rgulKeyMap[ucMapByte]&(1<<ucMapBit)) )
		{
			//ensure we don't overflow
			if(pMixAlgParam->ulDestCount<MAX_KEYSTROKES)
			{
				pMixAlgParam->pcixDest->Keyboard.rgucKeysDown[pMixAlgParam->ulDestCount++] =
					pcixSrc->Keyboard.rgucKeysDown[ulIndex];
			}
		}
		//Add to key map
		pMixAlgParam->rgulKeyMap[ucMapByte] |= (1<<ucMapBit);
	}
}
#undef KEYBOARD_NO_EVENT //0
#undef KEYBOARD_ERROR_ROLLOVER //1


//------------------------------------------------------------------------------
//	Implementation of CMouseModel
//------------------------------------------------------------------------------
HRESULT CMouseModel::SetXModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters)
{
	//Set the model parameters
	if(pModelParameters)
	{
		ASSERT(m_pMouseModelData);
		if(!m_pMouseModelData)
		{
			return E_OUTOFMEMORY;
		}
		if(0==pModelParameters->ulInertiaTime)
		{
			//Help us avoid a divide by zero error later.
			pModelParameters->ulInertiaTime = 1;
		}
		m_pMouseModelData->XModelParameters = *pModelParameters;
		m_pMouseModelData->fXModelParametersValid = TRUE;
		GCK_DBG_TRACE_PRINT(("New X Model Parameters are:\n\
AbsZoneSense = %d,\nContZoneMaxRate = %d,\nfPulse = %s,\nPulseWidth = %d,\nPulsePeriod = %d,\nfAcceration = %s,\n\nulAcceleration = %d,\nInertiaTime = %d\n",
m_pMouseModelData->XModelParameters.ulAbsZoneSense,
m_pMouseModelData->XModelParameters.ulContZoneMaxRate,
(m_pMouseModelData->XModelParameters.fPulse ? "TRUE" : "FALSE"),	
m_pMouseModelData->XModelParameters.ulPulseWidth,
m_pMouseModelData->XModelParameters.ulPulsePeriod,		
(m_pMouseModelData->XModelParameters.fAccelerate ? "TRUE" : "FALSE"),
m_pMouseModelData->XModelParameters.ulAcceleration,
m_pMouseModelData->XModelParameters.ulInertiaTime));		
	}
	//Clear the model parameters
	else
	{
		ASSERT(FALSE); //should no longer happen
		m_pMouseModelData->fXModelParametersValid = FALSE;
	}
	return S_OK;
}

HRESULT CMouseModel::SetYModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters)
{
	//Set the model parameters
	if(pModelParameters)
	{
		ASSERT(m_pMouseModelData);
		if(!m_pMouseModelData)
		{
			return E_OUTOFMEMORY;
		}
		if(0==pModelParameters->ulInertiaTime)
		{
			//Help us avoid a divide by zero error later.
			pModelParameters->ulInertiaTime = 1;
		}
		m_pMouseModelData->YModelParameters = *pModelParameters;
		m_pMouseModelData->fYModelParametersValid = TRUE;
		GCK_DBG_TRACE_PRINT(("New Y Model Parameters are:\n\
AbsZoneSense = %d,\nContZoneMaxRate = %d,\nfPulse = %s,\nPulseWidth = %d,\nPulsePeriod = %d,\nfAcceration = %s,\n\nulAcceleration = %d,\nInertiaTime = %d\n",
m_pMouseModelData->YModelParameters.ulAbsZoneSense,
m_pMouseModelData->YModelParameters.ulContZoneMaxRate,
(m_pMouseModelData->YModelParameters.fPulse ? "TRUE" : "FALSE"),	
m_pMouseModelData->YModelParameters.ulPulseWidth,
m_pMouseModelData->YModelParameters.ulPulsePeriod,		
(m_pMouseModelData->YModelParameters.fAccelerate ? "TRUE" : "FALSE"),
m_pMouseModelData->YModelParameters.ulAcceleration,
m_pMouseModelData->YModelParameters.ulInertiaTime));		
	}
	//Clear the model parameters
	else
	{
		ASSERT(FALSE); //should no longer happen
		m_pMouseModelData->fYModelParametersValid = FALSE;
	}
	return S_OK;
}

HRESULT CMouseModel::CreateDynamicMouseObjects()
{
	//Create the mouse model data, if not exist
	if(!m_pMouseModelData)
	{
		m_pMouseModelData = new WDM_NON_PAGED_POOL MOUSE_MODEL_DATA;
		if(!m_pMouseModelData)
		{
			return E_OUTOFMEMORY;
		}
	}

	//Create the virutal mouse, (safe if it already exists)
	return m_pFilterClientServices->CreateMouse();
}

void CMouseModel::DestroyDynamicMouseObjects()
{
	//Destroy the mouse model data if exists
	if(m_pMouseModelData)
	{
		delete m_pMouseModelData;
		m_pMouseModelData = NULL;
	}

	//Destroy virtual mouse (safe if it doesn't exist)
	HRESULT hr = m_pFilterClientServices->CloseMouse();
	ASSERT( SUCCEEDED(hr) );
}
		
//called by device filters MapToOutput, to reset state for a new packet
void CMouseModel::NewPacket(ULONG ulCurrentTime)
{
	//This is called by CDeviceFilter, which doesn't know if there
	//are mouse assignments, in this case we ignore the call.
	if(!m_pMouseModelData) return;
	//set time of new poll
	m_pMouseModelData->ulLastTime = m_pMouseModelData->ulCurrentTime;
	m_pMouseModelData->ulCurrentTime=ulCurrentTime;
	//reset momentaries
	m_pMouseModelData->fClutchDown = FALSE;
	m_pMouseModelData->fDampenDown = FALSE;
	m_pMouseModelData->ucButtons = 0x00;
	m_pMouseModelData->StateX.fInZone = FALSE;
	m_pMouseModelData->StateY.fInZone = FALSE;
	//store last values for axes
	m_pMouseModelData->StateX.ulLastPos = m_pMouseModelData->StateX.ulPos;
	m_pMouseModelData->StateY.ulLastPos = m_pMouseModelData->StateY.ulPos;
}

//
//	called by device filters MapToOutput (at end), to send packet to output
//
void CMouseModel::SendMousePacket()
{
	//This is called by CDeviceFilter, which doesn't know if there
	//are mouse assignments, in this case we ignore the call.
	if(!m_pMouseModelData) return;

	UCHAR ucDeltaX = 0;
	UCHAR ucDeltaY = 0;
	
	//If there are mouse model parameters, and the clutch is not on
	//process the axes
	if(
		(m_pMouseModelData->fXModelParametersValid) &&
		(!m_pMouseModelData->fClutchDown)
		)
	{
		//Process X axis
		ucDeltaX = CalculateMickeys(
										&m_pMouseModelData->StateX,
										&m_pMouseModelData->XModelParameters
									);

		//Left and right are opposite on mouse and joysticl
		ucDeltaX = UCHAR(-(CHAR)ucDeltaX);

		//Process Y axis
		ucDeltaY = CalculateMickeys(
										&m_pMouseModelData->StateY,
										&m_pMouseModelData->YModelParameters
									);
	}

	// Do we really want to send
	if ((m_pMouseModelData->ucLastButtons != m_pMouseModelData->ucButtons) || (ucDeltaX != 0) || (ucDeltaY != 0))
	{
		ASSERT(m_pMouseModelData->ucButtons != UCHAR(-1));	// Someone forgot NewPacket call

		m_pFilterClientServices->SendMouseData(
									ucDeltaX,
									ucDeltaY,
									m_pMouseModelData->ucButtons,
									m_pMouseModelData->cWheel,
									m_pMouseModelData->fClutchDown,
									m_pMouseModelData->fDampenDown);

		m_pMouseModelData->ucLastButtons = m_pMouseModelData->ucButtons;
	}
}


UCHAR
CMouseModel::CalculateMickeys
(
	PMOUSE_AXIS_STATE pMouseAxisState,
	PMOUSE_MODEL_PARAMETERS pModelParameters
)
{
	//Calculate for continuous zone
	if(pMouseAxisState->fInZone)
	{
		//Set Jog
		m_pFilterClientServices->SetNextJog(10); //call back in 35 ms
			
		//Reset inertia, so when we leave zone it is max
		pMouseAxisState->fInertia = TRUE;
		pMouseAxisState->ulInertiaStopMs = m_pMouseModelData->ulCurrentTime + pModelParameters->ulInertiaTime;

		//If pulsing is on update gate info
		if(pModelParameters->fPulse)
		{
			//Update Pulse Start Time
			if( 
				(pMouseAxisState->ulPulseGateStartMs + pModelParameters->ulPulsePeriod) <
				m_pMouseModelData->ulCurrentTime
			)
			{
				pMouseAxisState->ulPulseGateStartMs = m_pMouseModelData->ulCurrentTime;
			}
			//Return 0 if in an off period
			if( 
				(pMouseAxisState->ulPulseGateStartMs + pModelParameters->ulPulseWidth) <
				m_pMouseModelData->ulCurrentTime
			)
			{
				return (UCHAR)0; //No movement the gate is off
			}
		}	//end of update zone information
		
		//Are we in high zone?
		//Yes, HighZone
		if(pMouseAxisState->ulPos > MOUSE_AXIS_CENTER_IN)
		{
			//Update Zone entry point
			if(pMouseAxisState->ulPos < pMouseAxisState->ulZoneEnterHigh)
			{
				 pMouseAxisState->ulZoneEnterHigh = pMouseAxisState->ulPos;
			}

			//Calculate Instantaneous Rate (Mickeys/1024 ms)
			ULONG ulRate = (
								(pMouseAxisState->ulPos - pMouseAxisState->ulZoneEnterHigh) * 
								pModelParameters->ulContZoneMaxRate
							) /	(MOUSE_AXIS_MAX_IN - pMouseAxisState->ulZoneEnterHigh);

			//Calculate Mickeys to send * 1024
			ULONG ulMickeys = ulRate * (m_pMouseModelData->ulCurrentTime - m_pMouseModelData->ulLastTime);
			ulMickeys += pMouseAxisState->ulMickeyFraction;

			//Save fraction in parts per 1024
			pMouseAxisState->ulMickeyFraction = ulMickeys & 0x000003FF;
			
			//Return number of mickeys to send now (divide by 1024)
			return (UCHAR)(ulMickeys >> 10);
		} else
		//No, Low Zone
		{
			//Update Zone entry point
			if(pMouseAxisState->ulPos > pMouseAxisState->ulZoneEnterLo)
			{
				 pMouseAxisState->ulZoneEnterLo = pMouseAxisState->ulPos;
			}

			//Calculate Instantaneous Rate (Mickeys/1024 ms)
			ULONG ulRate = (
								(pMouseAxisState->ulZoneEnterLo - pMouseAxisState->ulPos) * 
								pModelParameters->ulContZoneMaxRate
							) /	(pMouseAxisState->ulZoneEnterLo - MOUSE_AXIS_MIN_IN);

			//Calculate Mickeys to send * 1024
			ULONG ulMickeys = ulRate * (m_pMouseModelData->ulCurrentTime - m_pMouseModelData->ulLastTime);
			ulMickeys += pMouseAxisState->ulMickeyFraction;

			//Save fraction in parts per 1024
			pMouseAxisState->ulMickeyFraction = ulMickeys & 0x000003FF;
			
			//Return number of mickeys to send now (divide by 1024)
			return (UCHAR)(-(LONG)(ulMickeys >> 10));
		}
	}

	//If we are here, we are not in the continuous zone

	//Calculate Mickeys
	BOOLEAN fNegative = FALSE;
	ULONG ulMickeys;
	
	if( pMouseAxisState->ulPos > pMouseAxisState->ulLastPos)
	{
		ulMickeys = pMouseAxisState->ulPos - pMouseAxisState->ulLastPos;
	}
	else
	{
		fNegative = TRUE;
		ulMickeys = pMouseAxisState->ulLastPos - pMouseAxisState->ulPos;
	}
	
	ULONG ulEffSense = pModelParameters->ulAbsZoneSense; 
	//Apply damper
	if(m_pMouseModelData->fDampenDown)
	{
		ulEffSense >>= 2; //divide by four
	}

	//Apply Sensitivity (we divide by 1024, a sensitivity of one is really 1024)
	ulMickeys *= ulEffSense;

	//Apply Inertia
	if( pMouseAxisState->fInertia)
	{
		if(m_pMouseModelData->ulCurrentTime > pMouseAxisState->ulInertiaStopMs)
		{
			pMouseAxisState->fInertia = FALSE;
		}
		else
		{
			ULONG ulInertialBits = 
				(
					10*(pMouseAxisState->ulInertiaStopMs - m_pMouseModelData->ulCurrentTime)
				)/pModelParameters->ulInertiaTime;
			ulMickeys >>= ulInertialBits;
		}
	}

	//Apply Acceleration
	if(pModelParameters->fAccelerate)
	{
		//ulAcceleration is a number between 1 and 3
		ulMickeys += (ulMickeys*(LONG)pModelParameters->ulAcceleration)/3;
	}
	
	//Add in fractional mickeys
	ulMickeys += pMouseAxisState->ulMickeyFraction;

	//Save fraction in parts per 1024
	pMouseAxisState->ulMickeyFraction = ulMickeys & 0x000003FF;

	ulMickeys >>= 10;
	if(fNegative)
	{
		return (UCHAR)(-(LONG)ulMickeys);
	}
	else
		return (UCHAR)(ulMickeys);
}

//------------------------------------------------------------------------------
//	Implementation of CDeviceFilter
//------------------------------------------------------------------------------
CDeviceFilter::CDeviceFilter(CFilterClientServices *pFilterClientServices) :
	m_ucActiveInputCollection(0),
	m_ucWorkingInputCollection(0),
	m_ucNumberOfInputCollections(0),
	m_OutputCollection(pFilterClientServices->GetVidPid()),
	m_ActionQueue(pFilterClientServices),
	m_KeyMixer(pFilterClientServices),
	m_pMouseModel(NULL),
	m_pFilterClientServices(pFilterClientServices),
	m_pForceBlock(NULL),
	m_bFilterBlockChanged(FALSE),
	m_bNeedToUpdateLEDs(FALSE)
{
	GCK_DBG_ENTRY_PRINT(("CDeviceFilter::CDeviceFilter(pFilterClientServices(0x%0.8x)\n)",
						pFilterClientServices));
	m_pFilterClientServices->IncRef();

	short int collectionCount = 0;	// Get this actual number from the table

	// Walk through device control description list till vidpid found or 0
	USHORT usDeviceIndex = 0;
	ULONG ulVidPid = pFilterClientServices->GetVidPid();
	while ((DeviceControlsDescList[usDeviceIndex].ulVidPid != 0) &&
			(DeviceControlsDescList[usDeviceIndex].ulVidPid != ulVidPid))
	{
		usDeviceIndex++;
	}
	if (DeviceControlsDescList[usDeviceIndex].ulVidPid == ulVidPid)	// Device not found otherwise?
	{
		for (ULONG ulItemIndex = 0; ulItemIndex < DeviceControlsDescList[usDeviceIndex].ulControlItemCount; ulItemIndex++)
		{
			CONTROL_ITEM_DESC* pControlItemDesc = (CONTROL_ITEM_DESC*)(DeviceControlsDescList[usDeviceIndex].pControlItems + ulItemIndex);
			if (pControlItemDesc->usType == ControlItemConst::usProfileSelectors)
			{
				// This is purposly 1 off
				collectionCount = (pControlItemDesc->ProfileSelectors.UsageButtonMax - pControlItemDesc->ProfileSelectors.UsageButtonMin);
				ASSERT( (collectionCount > 0) && (collectionCount < 10) );	// Check table for errors!!
				break;		// We only support one group of selectors!
			}
		}
	}
	m_ucNumberOfInputCollections =  collectionCount + 1;		// Fix up by 1

	m_rgInputCollections = new WDM_NON_PAGED_POOL CControlItemCollection<CInputItem>[m_ucNumberOfInputCollections];

	// Init, then set the client services function in each input collection (init the LED collections)
	for (short int collectionIndex = 0; collectionIndex < m_ucNumberOfInputCollections; collectionIndex++)
	{
		m_rgInputCollections[collectionIndex].Init(pFilterClientServices->GetVidPid(), &InputItemFactory);

		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		while( S_OK == m_rgInputCollections[collectionIndex].GetNext(&pInputItem, ulCookie) )
		{
			pInputItem->SetClientServices(m_pFilterClientServices);
			if (pInputItem->GetType() == ControlItemConst::usButtonLED)
			{
				CButtonLEDInput* pButtonLEDInput = (CButtonLEDInput*)pInputItem;
				ULONG ulCorrespondingButtonIndex = pButtonLEDInput->GetCorrespondingButtonIndex();
				CInputItem* pCorrespondingButtons = NULL;
				m_rgInputCollections[collectionIndex].GetNext(&pCorrespondingButtons, ulCorrespondingButtonIndex);
				pButtonLEDInput->Init(pCorrespondingButtons);
			}
		}
	}

	m_OutputCollection.SetStateOverlayMode(TRUE);
}

CDeviceFilter::~CDeviceFilter()
{
	{	// Make sure all keys are up!
		CGckCritSection HoldCriticalSection(&m_MutexHandle);
		m_KeyMixer.ClearState();			// All keys up
		m_KeyMixer.PlayGlobalState();		// play it!
	}

	// Get rid of the florkin (thanks for the word Loyal) mouse model
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->DecRef();
		m_pMouseModel = NULL;
	}

	// Deallocate force block
	if (m_pForceBlock != NULL)
	{
		delete m_pForceBlock;
		m_pForceBlock = NULL;
	}
	m_pFilterClientServices->DecRef();

	// Deallocate input collections
	if (m_rgInputCollections != NULL)
	{
		delete[] m_rgInputCollections;
		m_rgInputCollections = NULL;
	}
}

/***********************************************************************************
**
**	BOOLEAN CDeviceFilter::EnsureMouseModelExists()
**
**	@func	We are required to have a mouse model
**
**
**	@rdesc	TRUE if we have one or were able to create one, FALSE if there is still no model
**
*************************************************************************************/
BOOLEAN CDeviceFilter::EnsureMouseModelExists()
{
	if (m_pMouseModel == NULL)
	{
		m_pMouseModel = new WDM_NON_PAGED_POOL CMouseModel(m_pFilterClientServices);
		if (m_pMouseModel == NULL)
		{
			return FALSE;
		}
	}

	return TRUE;
}

/***********************************************************************************
**
**	NTSTATUS CDeviceFilter::SetWorkingSet(UCHAR ucWorkingSet)
**
**	@func	Set the current set to work with (for IOCTL_GCK_SEND_COMMAND usage)
**
**
**	@rdesc	STATUS_SUCCESS or STATUS_INVALID_PARAMETER if working-set is out of range
**
*************************************************************************************/
NTSTATUS CDeviceFilter::SetWorkingSet(UCHAR ucWorkingSet)
{
	if (ucWorkingSet < m_ucNumberOfInputCollections)
	{
		m_ucWorkingInputCollection = ucWorkingSet;
		return STATUS_SUCCESS;
	}

	return STATUS_INVALID_PARAMETER;
}

void CDeviceFilter::CopyToTestFilter(CDeviceFilter& rDeviceFilter)
{
	ASSERT(rDeviceFilter.m_ucNumberOfInputCollections == m_ucNumberOfInputCollections);

	// Give it our mouse model (it's Macros will have it, so should it)
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->IncRef();
	}
	if (rDeviceFilter.m_pMouseModel != NULL)
	{
		rDeviceFilter.m_pMouseModel->DecRef();
	}
	rDeviceFilter.m_pMouseModel = m_pMouseModel;

	if (rDeviceFilter.m_ucNumberOfInputCollections == m_ucNumberOfInputCollections)
	{
		for (UCHAR ucCollection = 0; ucCollection < m_ucNumberOfInputCollections; ucCollection++)
		{
			ULONG ulCookie = 0;
			ULONG ulCookieTest = 0;
			CInputItem *pInputItem = NULL;
			CInputItem *pInputItemTest = NULL;
			while (S_OK == m_rgInputCollections[ucCollection].GetNext(&pInputItem, ulCookie))
			{
				rDeviceFilter.m_rgInputCollections[ucCollection].GetNext(&pInputItemTest, ulCookieTest);
				ASSERT(pInputItemTest != NULL);
				if (pInputItemTest != NULL)
				{
					pInputItem->Duplicate(*pInputItemTest);
				}
			}
		}
	}

	rDeviceFilter.m_ucActiveInputCollection = m_ucActiveInputCollection;
	rDeviceFilter.m_ucWorkingInputCollection = m_ucWorkingInputCollection;
}

NTSTATUS CDeviceFilter::SetLEDBehaviour(GCK_LED_BEHAVIOUR_OUT* pLEDBehaviourOut)
{
	if (pLEDBehaviourOut != NULL)
	{
		// Find the LED items
		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		while (S_OK == m_rgInputCollections[m_ucWorkingInputCollection].GetNext(&pInputItem, ulCookie))
		{
			if (pInputItem->GetType() == ControlItemConst::usButtonLED)
			{
				((CButtonLEDInput*)pInputItem)->SetLEDStates( pLEDBehaviourOut->ucLEDBehaviour,
															pLEDBehaviourOut->ulLEDsAffected,
															pLEDBehaviourOut->ucShiftArray);

				UpdateAssignmentBasedItems(FALSE);
				return STATUS_SUCCESS;
			}
		}

		return STATUS_INVALID_PARAMETER;	// Not a valid IOCTL for this device?
	}

	return STATUS_INVALID_PARAMETER;
}


// We use this for sending data down at PASSIVE IRQL
void CDeviceFilter::IncomingRequest()
{
	if (m_bNeedToUpdateLEDs)
	{
		m_bNeedToUpdateLEDs = FALSE;
		UpdateAssignmentBasedItems(TRUE);
	}
}

void CDeviceFilter::ProcessInput
(
	PCHAR pcReport,
	ULONG ulReportLength
)
{
	GCK_DBG_RT_ENTRY_PRINT(("CDeviceFilter::ProcessInput(0x%0.8x, 0x%0.8x\n)",
				pcReport,
				ulReportLength));

	//	This function is protected by a critical section.
	CGckCritSection HoldCriticalSection(&m_MutexHandle);

	// Get the old shift state before reading the new one it
	USHORT usOldLowShift = 0;
	ULONG ulModifiers = m_rgInputCollections[m_ucActiveInputCollection].GetModifiers();
	while (ulModifiers != 0)
	{
		usOldLowShift++;
		if (ulModifiers & 0x00000001)
		{
			break;
		}
		ulModifiers >>= 1;
	}

	//	Read the inputs
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::ProcessInput - reading report into inputs\n"));

	m_rgInputCollections[m_ucActiveInputCollection].ReadFromReport(
														m_pFilterClientServices->GetHidPreparsedData(),
														pcReport,
														ulReportLength
													);

	// Check the current buttons, has the shift state changed?
	USHORT usNewLowShift = 0;
	ulModifiers = m_rgInputCollections[m_ucActiveInputCollection].GetModifiers();
	while (ulModifiers != 0)
	{
		usNewLowShift++;
		if (ulModifiers & 0x00000001)
		{
			break;
		}
		ulModifiers >>= 1;
	}

	if (usNewLowShift != usOldLowShift)
	{
		m_bNeedToUpdateLEDs = TRUE;
	}

	// Should we even bother checking the data for a profile selector (right now this is also indicitive of usButtonLED
	if (m_ucNumberOfInputCollections > 1)
	{
		// Iterate through the items looking for profile selector
		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		CProfileSelectorInput* pProfileSelector = NULL;
		while((pProfileSelector == NULL) && (m_rgInputCollections[m_ucActiveInputCollection].GetNext(&pInputItem, ulCookie) == S_OK))
		{
			if (pInputItem->GetType() == ControlItemConst::usProfileSelectors)
			{
				pProfileSelector = (CProfileSelectorInput*)pInputItem;
			}
		}

		if (pProfileSelector != NULL)
		{
			UCHAR ucSelectedProfile = 0;
			pProfileSelector->GetSelectedProfile(ucSelectedProfile);
			if (ucSelectedProfile >= m_ucNumberOfInputCollections)
			{
				ASSERT(ucSelectedProfile >= m_ucNumberOfInputCollections);
			}
			else if (ucSelectedProfile != m_ucActiveInputCollection)
			{
				// Tell all items in the action Queue they are free (which was from the previous profile collection)
				m_ActionQueue.ReleaseTriggers();

				// Update to the new current
				m_ucActiveInputCollection = ucSelectedProfile;

				// Need to reparse the report
				m_rgInputCollections[m_ucActiveInputCollection].ReadFromReport(
																	m_pFilterClientServices->GetHidPreparsedData(),
																	pcReport,
																	ulReportLength
																);
				// Need to update the active-set items
				m_bNeedToUpdateLEDs = TRUE;
			}
		}
	}

	// Possibly Trigger triggered
	CheckTriggers(pcReport, ulReportLength);
	
	//	Call Jog Routine
	Jog(pcReport, ulReportLength);
	
	GCK_DBG_EXIT_PRINT(("Exiting CDeviceFilter::ProcessInput\n"));
}

void CDeviceFilter::CheckTriggers(PCHAR pcReport, ULONG ulReportLength)
{
	PGCK_FILTER_EXT pFilterExtension = ((CFilterGcKernelServices*)m_pFilterClientServices)->GetFilterExtension();
	if ((pFilterExtension != NULL) && (pFilterExtension->pvTriggerIoctlQueue != NULL))
	{
		CGuardedIrpQueue* pTriggerQueue = (CGuardedIrpQueue*)(pFilterExtension->pvTriggerIoctlQueue);
		CTempIrpQueue tempIrpQueue;
		pTriggerQueue->RemoveAll(&tempIrpQueue);

		USAGE pUsages[15];
		ULONG ulNumUsages = 15;
		NTSTATUS NtStatus = HidP_GetButtons(HidP_Input, HID_USAGE_PAGE_BUTTON, 0, pUsages, &ulNumUsages,
				m_pFilterClientServices->GetHidPreparsedData(), pcReport, ulReportLength);
		ASSERT(NtStatus != HIDP_STATUS_BUFFER_TOO_SMALL);	// 15 should be plenty

		// Set up a mask with values from array
		ULONG ulButtonBitArray = 0x0;
		for (ULONG ulIndex = 0; ulIndex < ulNumUsages; ulIndex++)
		{
			ulButtonBitArray |= (1 << (pUsages[ulIndex]-1));
		}

		PIRP pIrp;
		while((pIrp = tempIrpQueue.Remove()) != NULL)
		{
			// No need to check, irp fields are checked when item is placed on Queue
			PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
			GCK_TRIGGER_OUT* pTriggerOut = (GCK_TRIGGER_OUT*)(pIrp->AssociatedIrp.SystemBuffer);

			// No need to check the type for support, checked on entry

			// Check for requested down buttons (we only support button triggering right now)
			if (pTriggerOut->ucTriggerSubType == TRIGGER_ON_BUTTON_DOWN)
			{

				if ((ulButtonBitArray & pTriggerOut->ulTriggerInfo1) != 0)
				{	// One of the desired buttons has been pressed
					CompleteTriggerRequest(pIrp, ulButtonBitArray);
				}
				else
				{	// Button down wasn't triggered
					pTriggerQueue->Add(pIrp);
				}
			}
			else if ((ulButtonBitArray & pTriggerOut->ulTriggerInfo1) != pTriggerOut->ulTriggerInfo1)
			{	// One of the desired buttons is not down
				CompleteTriggerRequest(pIrp, ulButtonBitArray);
			}
			else
			{	// Item wasn't triggered, put back in queue
				pTriggerQueue->Add(pIrp);
			}
		}		
	}
}

void CDeviceFilter::JogActionQueue
(
	PCHAR pcReport,
	ULONG ulReportLength
)
{
	GCK_DBG_RT_ENTRY_PRINT(("CDeviceFilter::JogActionQueue(0x%0.8x, 0x%0.8x\n)",
				pcReport,
				ulReportLength));

	//	This function is protected by a critical section.
	CGckCritSection HoldCriticalSection(&m_MutexHandle);

	//	Call Jog Routine
	Jog(pcReport, ulReportLength);
	
	GCK_DBG_EXIT_PRINT(("Exiting CDeviceFilter::JogActionQueue\n"));
}

void CDeviceFilter::Jog(PCHAR pcReport, ULONG ulReportLength)
{
	//
	//  1.  Clear the outputs
	//
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::Jog - clearing outputs\n"));
	m_OutputCollection.SetDefaultState();

	//
	//	2. Clear KeyMixer
	//
	m_KeyMixer.ClearState();

	//
	//	3.	Clear Mouse Frame
	//
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->NewPacket( m_pFilterClientServices->GetTimeMs() );

	}

	//
	//	4.	Process inputs
	//
	ULONG ulCookie = 0;
	CInputItem *pInputItem = NULL;
	while( S_OK == m_rgInputCollections[m_ucActiveInputCollection].GetNext(&pInputItem, ulCookie) )
	{
		pInputItem->MapToOutput(&m_OutputCollection);
	}
	//Copy over the modifiers
	m_OutputCollection.SetModifiers(m_rgInputCollections[m_ucActiveInputCollection].GetModifiers());

	//
	//	5.	Process action queue
	//
	m_ActionQueue.Jog();

	//
	//	6.	Write outputs
	//
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::Jog - writing outputs\n"));
	RtlZeroMemory( reinterpret_cast<PVOID>(pcReport), ulReportLength);	//zero report first
	m_OutputCollection.WriteToReport(m_pFilterClientServices->GetHidPreparsedData(),
									pcReport,
									ulReportLength);
	//
	//	7.	Call hook to complete pending IRP_MJ_READ IRPs
	//
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::Jog - Sending out data\n"));
	m_pFilterClientServices->DeviceDataOut(pcReport, ulReportLength, S_OK);
	
	//
	//	8.	Play Keyboard state, if is has changed
	//
	m_KeyMixer.PlayGlobalState();

	//	9.	Play Mouse state, if it has changed
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->SendMousePacket();
	}

	GCK_DBG_EXIT_PRINT(("CDeviceFilter::Jog\n"));
}

/***********************************************************************************
**
**	NTSTATUS CDeviceFilter::OtherFilterBecomingActive()
**
**	@func	We are going in the background.
**			Make sure all Queued items are released (removed from Queue)
**
*************************************************************************************/
void CDeviceFilter::OtherFilterBecomingActive()
{
	//  1.  Clear the outputs
	GCK_DBG_RT_WARN_PRINT(("CDeviceFilter::OtherFilterBecomingActive - clearing outputs\n"));
//	DbgPrint("CDeviceFilter::OtherFilterBecomingActive - clearing outputs: 0x%08X\n", this);
	m_OutputCollection.SetDefaultState();

	//	2. Clear KeyMixer
	m_KeyMixer.ClearState();

	//	3.	Clear Mouse Frame
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->NewPacket(m_pFilterClientServices->GetTimeMs());
	}

	//	4. Clear out the Action Queue
	for (;;)
	{
		CQueuedAction* pQueuedAction = m_ActionQueue.GetHead();
		if (pQueuedAction == NULL)
		{
			break;
		}
		pQueuedAction->TriggerReleased();			// Is this needed?
		m_ActionQueue.RemoveItem(pQueuedAction);
	}

	//	5.	Play Keyboard state, if is has changed
	m_KeyMixer.PlayGlobalState();

	//	6.	Play Mouse state, if it has changed
	if (m_pMouseModel != NULL)
	{
		m_pMouseModel->SendMousePacket();
	}
}

#define SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader)\
	(reinterpret_cast<PCOMMAND_HEADER>\
		( reinterpret_cast<PUCHAR>(pCommandHeader) +\
		reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize )\
	)

#define SKIP_TO_NEXT_COMMAND_DIRECTORY(pCommandDirectory)\
	(reinterpret_cast<PCOMMAND_DIRECTORY>\
		(reinterpret_cast<PUCHAR>(pCommandDirectory) +\
		pCommandDirectory->ulEntireSize)\
	)
	
#define COMMAND_BLOCK_FITS_IN_DIRECTORY(pCommandDirectory, pCommandHeader)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandHeader) - reinterpret_cast<PUCHAR>(pCommandDirectory)) +\
					reinterpret_cast<PCOMMAND_HEADER>(pCommandHeader)->ulByteSize\
				)\
		)
#define COMMAND_DIRECTORY_FITS_IN_DIRECTORY(pCommandDirectory, pCommandSubDirectory)\
		(pCommandDirectory->ulEntireSize >=\
				(\
					(reinterpret_cast<PUCHAR>(pCommandSubDirectory) - reinterpret_cast<PUCHAR>(pCommandDirectory)) +\
					pCommandSubDirectory->ulEntireSize\
				)\
		)

NTSTATUS CDeviceFilter::ProcessCommands(const PCOMMAND_DIRECTORY cpCommandDirectory)
{
	HRESULT hr = S_OK;

	//
	//	DEBUG Sanity Checks
	//
	ASSERT( eDirectory == cpCommandDirectory->CommandHeader.eID );
	
	//
	//	IF there are no blocks in the directory this is a no-op,
	//	but probably not intended
	//
	ASSERT(	1 <= cpCommandDirectory->usNumEntries );
	if( 1 > cpCommandDirectory->usNumEntries )
	{
		return S_FALSE;		//We know that this is not NTSTATUS code,
							//But it won't fail anything, yet it is not quite success.
	}

	//
	//	Skip Directory header to get to first block
	//
	PCOMMAND_HEADER pCommandHeader = SKIP_TO_NEXT_COMMAND_BLOCK(cpCommandDirectory);
	
	//
	//	If we have a sub-directory, call ourselves recursively, for each sub-directory
	//
	if( eDirectory == pCommandHeader->eID)
	{
		PCOMMAND_DIRECTORY pCurDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pCommandHeader);
		NTSTATUS NtWorstCaseStatus = STATUS_SUCCESS;
		NTSTATUS NtStatus;
		USHORT usDirectoryNum = 1;
		while( usDirectoryNum <= cpCommandDirectory->usNumEntries)
		{
			//Sanity check that data structure is valid
			ASSERT( COMMAND_DIRECTORY_FITS_IN_DIRECTORY(cpCommandDirectory, pCurDirectory) );
			if( !COMMAND_DIRECTORY_FITS_IN_DIRECTORY(cpCommandDirectory, pCurDirectory) )
			{
				return STATUS_INVALID_PARAMETER;
			}
			//Call ourselves recursively
			NtStatus = CDeviceFilter::ProcessCommands(pCurDirectory);
			if( NT_ERROR(NtStatus) )
			{
				NtWorstCaseStatus = NtStatus;
			}
			//Skip to next directory
			pCurDirectory = SKIP_TO_NEXT_COMMAND_DIRECTORY(pCurDirectory);
			usDirectoryNum++;
		}
		//If one or more commands in the block failed, return an error.
		return NtWorstCaseStatus;
	}

	//
	//	If we are here, we have reached the bottom of a directory,
	//	to a command we need to process (or not if we don't support it)
	//
	switch( CommandType(pCommandHeader->eID) )
	{
		case COMMAND_TYPE_ASSIGNMENT_TARGET:
		{
			switch(pCommandHeader->eID)
			{
				case eRecordableAction:
				{
					//
					//	Get the input item that needs this assignment.
					//
					CInputItem *pInputItem;
					const PASSIGNMENT_TARGET pAssignmentTarget = reinterpret_cast<PASSIGNMENT_TARGET>(pCommandHeader);
					pInputItem = m_rgInputCollections[m_ucWorkingInputCollection].GetFromControlItemXfer(pAssignmentTarget->cixAssignment);
					
					if( pInputItem )
					{
						CAction *pAction = NULL;
						//
						//	If there is an assignment block, get the assignment
						//	otherwise the command was sent to kill an existing assignment.
						//
						if(cpCommandDirectory->usNumEntries > 1)
						{
							//
							//	Get Assignment block
							//
							PASSIGNMENT_BLOCK pAssignment = reinterpret_cast<PASSIGNMENT_BLOCK>(SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader));

							//
							//	Sanity Check Assignment block
							//
							ASSERT( COMMAND_BLOCK_FITS_IN_DIRECTORY(cpCommandDirectory, pAssignment) );
							
							//
							//	Make sure this really is an Assignment block
							//
							ASSERT( CommandType(pAssignment->CommandHeader.eID) & COMMAND_TYPE_FLAG_ASSIGNMENT );

							//

							//	Create Action
							//
							hr = ActionFactory(pAssignment, &pAction);
						}
						if( SUCCEEDED(hr) )
						{
							//This block needs protection by a critical section
							CGckCritSection HoldCriticalSection(&m_MutexHandle);
							//	Assign to trigger, pAction == NULL this is an unassignment
							hr = pInputItem->AssignAction(&pAssignmentTarget->cixAssignment, pAction);
							//We may not have an action
							if(pAction)
							{
								pAction->DecRef();
							}
						}
					}
					break;
				}
				case eBehaviorAction:
				{
					//
					//	Get the input item that needs this assignment.
					//
					CInputItem *pInputItem;
					const PASSIGNMENT_TARGET pAssignmentTarget = reinterpret_cast<PASSIGNMENT_TARGET>(pCommandHeader);
					pInputItem = m_rgInputCollections[m_ucWorkingInputCollection].GetFromControlItemXfer(pAssignmentTarget->cixAssignment);
					if( pInputItem )
					{
					
						CBehavior *pBehavior = NULL;
						//
						//	If there is an assignment block, get the assignment
						//	otherwise the command was sent to kill an existing assignment.
						//
						if(cpCommandDirectory->usNumEntries > 1)
						{
							//
							//	Get Assignment block
							//
							PASSIGNMENT_BLOCK pAssignment = reinterpret_cast<PASSIGNMENT_BLOCK>(SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader));

							//
							//	Sanity Check Assignment block
							//
							ASSERT( COMMAND_BLOCK_FITS_IN_DIRECTORY(cpCommandDirectory, pAssignment) );
								
							//
							//	Make sure this really is an Assignment block
							//
							ASSERT( CommandType(pAssignment->CommandHeader.eID) & COMMAND_TYPE_FLAG_ASSIGNMENT );

							//
							//	Create Behavior
							//
							hr = BehaviorFactory(pAssignment, &pBehavior);
						}
						if( SUCCEEDED(hr) )
						{
							//This block needs protection by a critical section
							CGckCritSection HoldCriticalSection(&m_MutexHandle);
							//	Assign to trigger, pAction == NULL this is an unassignment
							hr = pInputItem->AssignBehavior(&pAssignmentTarget->cixAssignment, pBehavior);
							//We may not have an action
							if(pBehavior)
							{
								pBehavior->DecRef();
							}
						}
						if( SUCCEEDED(hr) )
						{
							pInputItem->PostAssignmentProcessing();
						}
					}
					break;
				}
				case eFeedbackAction:
				{
					//
					//	Get Assignment block
					//
					PASSIGNMENT_BLOCK pAssignment = reinterpret_cast<PASSIGNMENT_BLOCK>(SKIP_TO_NEXT_COMMAND_BLOCK(pCommandHeader));

					//
					//	Sanity Check Assignment block
					//
					ASSERT( COMMAND_BLOCK_FITS_IN_DIRECTORY(cpCommandDirectory, pAssignment) );
						
					//
					//	Make sure this really is an Assignment block
					//
					ASSERT( CommandType(pAssignment->CommandHeader.eID) & COMMAND_TYPE_FLAG_ASSIGNMENT );

					//
					//	Create Behavior
					//

					if (pAssignment->CommandHeader.eID == eForceMap)
					{
						if (pAssignment->CommandHeader.ulByteSize != sizeof(FORCE_BLOCK))
						{
							ASSERT(FALSE);
							return E_INVALIDARG;
						}
						if (m_pForceBlock == NULL)
						{
							m_bFilterBlockChanged = TRUE;
						}
						else if (::RtlCompareMemory(m_pForceBlock, (const void*)pAssignment, sizeof(FORCE_BLOCK)) != sizeof(FORCE_BLOCK))
						{
							m_bFilterBlockChanged = TRUE;
							delete m_pForceBlock;
							m_pForceBlock = NULL;
						}
						if (m_bFilterBlockChanged)
						{
							m_pForceBlock = new WDM_NON_PAGED_POOL FORCE_BLOCK;
							::RtlCopyMemory((void*)m_pForceBlock, pAssignment, sizeof(FORCE_BLOCK));
						}
						hr = S_OK;
					}
					else
					{
						hr = E_NOTIMPL;
					}
					break;
				}
			}
			return hr;
		}

		case COMMAND_TYPE_FEEDBACK:
		{
			ASSERT(FALSE);
			return E_NOTIMPL;
		}

		case COMMAND_TYPE_QUEUE:
			return E_NOTIMPL;
		case COMMAND_TYPE_GENERAL:
			/*
			* Mouse parameters are no longer sent as a general command
			* because it was too difficult for the client
			switch(pCommandHeader->eID)
			{
				case eMouseFXModel:
				{
					//This block needs protection by a critical section
					CGckCritSection HoldCriticalSection(&m_MutexHandle);
					PMOUSE_FX_MODEL pMouseModelData = reinterpret_cast<PMOUSE_FX_MODEL>(pCommandHeader);
					if(pMouseModelData->fAssign)
					{
						m_MouseModel.SetModelParameters( &pMouseModelData->Parameters );
					}
					else
					{
						m_MouseModel.SetModelParameters( NULL );
					}
					return S_OK;
				}
			}
			*/
			return E_NOTIMPL;
	}
	return E_NOTIMPL;
}

void CDeviceFilter::UpdateAssignmentBasedItems(BOOLEAN bIgnoreWorking)
{
	// Right now the only assignment based items are the Button LEDs.
	// When this changes make the AssignmentsChanged item virtual and just call it for all

	// Only bother if the Working-Set is the Active set
	if ((bIgnoreWorking == TRUE) || (m_ucWorkingInputCollection == m_ucActiveInputCollection))
	{
		// Iterate through the items looking for usButtonLEDs
		ULONG ulCookie = 0;
		CInputItem *pInputItem = NULL;
		while(m_rgInputCollections[m_ucActiveInputCollection].GetNext(&pInputItem, ulCookie) == S_OK)
		{
			if (pInputItem->GetType() == ControlItemConst::usButtonLED)
			{
				((CButtonLEDInput*)pInputItem)->AssignmentsChanged();
			}
		}
	}
}

// Returns weather or not to Queue irp
BOOLEAN CDeviceFilter::TriggerRequest(IRP* pIrp)
{
	GCK_TRIGGER_OUT* pTriggerOut = (GCK_TRIGGER_OUT*)(pIrp->AssociatedIrp.SystemBuffer);

	// Check the type for support (we only support button right now)
	if (pTriggerOut->ucTriggerType != GCK_TRIGGER_BUTTON)
	{
		pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
		CompleteTriggerRequest(pIrp, 0);
		return FALSE;		// Do not queue
	}

	// Do they want the data back immediatly (this doesn't quite work!!!!!!!)
	if (pTriggerOut->ucTriggerSubType == TRIGGER_BUTTON_IMMEDIATE)
	{
		CompleteTriggerRequest(pIrp, 0);
		return FALSE;		// Not not queue
	}

	return TRUE;			// Queue the sucka
}

void CDeviceFilter::CompleteTriggerRequest(IRP* pIrp, ULONG ulButtonStates)
{
	void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;

	// Check all the pointers (just assume button request right now)
	if (pvUserData == NULL)
	{
		pIrp->IoStatus.Status = STATUS_NO_MEMORY;
	}
	else
	{	// Valid pointers all around, get button data
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		pIrp->IoStatus.Information = sizeof(ULONG);

		ULONG* puLong = PULONG(pvUserData);
		*puLong = ulButtonStates;
	}

	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

NTSTATUS CDeviceFilter::ProcessKeyboardIrp(IRP* pKeyboardIrp)
{
	if (m_pFilterClientServices == NULL)
	{
		return STATUS_PENDING;
	}
	return m_pFilterClientServices->PlayFromQueue(pKeyboardIrp);
}


HRESULT CDeviceFilter::ActionFactory(PASSIGNMENT_BLOCK pAssignment, CAction **ppAction)
{
	GCK_DBG_ENTRY_PRINT(("Entering CDeviceFilterActionFactory, pAssignment = 0x%0.8x\n", pAssignment));

	*ppAction = NULL;
	switch( pAssignment->CommandHeader.eID )
	{
		case	eTimedMacro:
		{
			CTimedMacro *pTimedMacro = new WDM_NON_PAGED_POOL CTimedMacro;
			if( pTimedMacro && pTimedMacro->Init(reinterpret_cast<PTIMED_MACRO>(pAssignment), &m_ActionQueue, &m_KeyMixer) )
			{
				*ppAction = pTimedMacro;
				GCK_DBG_TRACE_PRINT(("*ppAction = pTimedMacro(0x%0.8x)\n", pTimedMacro));
				return S_OK;
			}
			return E_OUTOFMEMORY;
		}
		case	eKeyString:
		{
			CKeyString *pKeyString = new WDM_NON_PAGED_POOL CKeyString;
			if( pKeyString && pKeyString->Init(reinterpret_cast<PKEYSTRING_MAP>(pAssignment), &m_ActionQueue, &m_KeyMixer) )
			{
				*ppAction = pKeyString;
				GCK_DBG_TRACE_PRINT(("*ppAction = pKeyString(0x%0.8x)\n", pKeyString));
				return S_OK;
			}
			//else
			delete pKeyString;
			return E_OUTOFMEMORY;
		}
		//Button map and key map have identical implementation using CMapping
		case	eButtonMap:
		case	eKeyMap:
		{
			CMapping *pMapping = new WDM_NON_PAGED_POOL CMapping;
			if( pMapping && pMapping->Init(&(reinterpret_cast<PKEY_MAP>(pAssignment)->Event), &m_KeyMixer) )
			{
				*ppAction = pMapping;
				GCK_DBG_TRACE_PRINT(("*ppAction = pMapping(0x%0.8x)\n", pMapping));
				return S_OK;
			}
			//else
			delete pMapping;
			return E_OUTOFMEMORY;
		}
		case	eCycleMap:
			return E_NOTIMPL;
		case	eAxisMap:
		{
			CAxisMap *pAxisMap = new WDM_NON_PAGED_POOL CAxisMap;
			if(pAxisMap)
			{
				pAxisMap->Init( *reinterpret_cast<PAXIS_MAP>(pAssignment));
				*ppAction = pAxisMap;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseButtonMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}
			UCHAR ucButtonNum = reinterpret_cast<PMOUSE_BUTTON_MAP>(pAssignment)->ucButtonNumber;
			CMouseButton *pMouseButton = new WDM_NON_PAGED_POOL CMouseButton(ucButtonNum, m_pMouseModel);
			if(pMouseButton)
			{
				*ppAction = pMouseButton;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXAxisMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			BOOLEAN fXAxis = reinterpret_cast<PMOUSE_FX_AXIS_MAP>(pAssignment)->fIsX;
			CMouseAxisAssignment *pMouseAxis;
			pMouseAxis= new WDM_NON_PAGED_POOL CMouseAxisAssignment(fXAxis, m_pMouseModel);
			if(pMouseAxis)
			{
				//Set Model parameters
				if(fXAxis)
				{
					m_pMouseModel->SetXModelParameters( &(reinterpret_cast<PMOUSE_FX_AXIS_MAP>(pAssignment)->AxisModelParameters));
				}
				else
				{
					m_pMouseModel->SetYModelParameters( &(reinterpret_cast<PMOUSE_FX_AXIS_MAP>(pAssignment)->AxisModelParameters));
				}
				*ppAction = pMouseAxis;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXClutchMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			CMouseClutch *pMouseClutch = new WDM_NON_PAGED_POOL CMouseClutch(m_pMouseModel);
			if(pMouseClutch)
			{
				*ppAction = pMouseClutch;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXDampenMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			CMouseDamper *pMouseDamper = new WDM_NON_PAGED_POOL CMouseDamper(m_pMouseModel);
			if(pMouseDamper)
			{
				*ppAction = pMouseDamper;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case	eMouseFXZoneIndicator:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			UCHAR ucAxis = reinterpret_cast<PMOUSE_FX_ZONE_INDICATOR>(pAssignment)->ucAxis;
			CMouseZoneIndicator *pMouseZone;
			pMouseZone	= new WDM_NON_PAGED_POOL CMouseZoneIndicator(ucAxis, m_pMouseModel);
			if(pMouseZone)
			{
				*ppAction = pMouseZone;
				return S_OK;
			}else
			{
				return E_OUTOFMEMORY;
			}
		}
		case eMultiMap:
		{
			if (EnsureMouseModelExists() == FALSE)
			{
				return E_OUTOFMEMORY;
			}

			CMultiMacro *pMultiMacro = new WDM_NON_PAGED_POOL CMultiMacro(m_pMouseModel);
			if (pMultiMacro  && pMultiMacro->Init(reinterpret_cast<PMULTI_MACRO>(pAssignment), &m_ActionQueue, &m_KeyMixer) )
			{
				*ppAction = pMultiMacro;
				GCK_DBG_TRACE_PRINT(("*ppAction = pMultiMacro(0x%0.8x)\n", pMultiMacro));
				return S_OK;
			}
			{
				return E_OUTOFMEMORY;
			}
		}
	}
	return E_NOTIMPL;
}


HRESULT CDeviceFilter::BehaviorFactory(PASSIGNMENT_BLOCK pAssignment, CBehavior **ppBehavior)
{
	GCK_DBG_ENTRY_PRINT(("Entering CDeviceFilterBehaviorFactory, pAssignment = 0x%0.8x\n", pAssignment));
	*ppBehavior = NULL;
	switch( pAssignment->CommandHeader.eID )
	{
		case eStandardBehaviorCurve:
		{
			CStandardBehavior *pStandardBehavior = new WDM_NON_PAGED_POOL CStandardBehavior;
			if( pStandardBehavior && pStandardBehavior->Init(reinterpret_cast<PBEHAVIOR_CURVE>(pAssignment)))
			{
				*ppBehavior = pStandardBehavior;
				GCK_DBG_TRACE_PRINT(("*ppBehavior = pStandardBehavior(0x%0.8x)\n", pStandardBehavior));
				return S_OK;
			}
			return E_OUTOFMEMORY;
		}
	}
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filter.h ===
#ifndef __Filter_h__
#define __Filter_h__
//	@doc
/**********************************************************************
*
*	@module	Filter.h	|
*
*	All the definitions needed for the CDeviceFilter object
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	Filter	|
*	This module contains:<nl>
*	<c CInputItem> - Base class for all CXXXXInput derived from the CXXXItems.<nl>
*	<c CAction>	- Base class for all actions.<nl>
*	<c CQueuedAction> - Base class for all actions which can be queued, derived from <c CAction><nl>
*	<c CKeyMixer> - Class which allows multiple devices to share one virtual keyboard.<nl>
*	<c CTimedMacro> - Class for timed macros, derived from <c CQueuedAction><nl>
*	<c CActionQueue> - Class for the action queue.<nl>
*	<c CDeviceFilter> - The class which incorporates the entire filter.<nl>
**********************************************************************/
#include <ControlItemCollection.h>
#include <Actions.h>
#include "GckCritSec.h"
#include "GCKShell.h"

//forward declration
class CKeyMixer;

class CFilterClientServices
{
	public:
		CFilterClientServices() : m_ulRefCount(1){}
		inline ULONG IncRef()
		{
			return m_ulRefCount++;
		}
		inline ULONG DecRef()
		{
			ULONG ulRetVal = --m_ulRefCount;
			if(!ulRetVal)
			{
				delete this;
			}
			return ulRetVal;
		}
		virtual ~CFilterClientServices()
		{
			ASSERT(!m_ulRefCount && "Somebody tried to delete this!  Call DecRef instead!");
		}
		
		//routine to get basic HID information on device
		virtual ULONG				 GetVidPid()=0;
		virtual PHIDP_PREPARSED_DATA GetHidPreparsedData()=0;
		
		//Routine to send device data to
		virtual void				 DeviceDataOut(PCHAR pcReport, ULONG ulByteCount, HRESULT hr)=0;
		virtual NTSTATUS			 DeviceSetFeature(PVOID pvBuffer, ULONG ulByteCount)=0;
		
		//Gets a time stamp in ms, expected to have ms precision as well.
		virtual ULONG				 GetTimeMs()=0;
				
		//	Routine that sets call back for 	
		virtual void				 SetNextJog(ULONG ulDelayMs)=0;
				
		//	Routines for sending keystrokes (a port for stuffing keyboards is assumed to exist)
		virtual void				PlayKeys(const CONTROL_ITEM_XFER& crcixState, BOOLEAN fEnabled)=0;
		virtual NTSTATUS			PlayFromQueue(IRP* pIrp) = 0;
				
		//	Routines for sending mouse data, must create first
		virtual HRESULT				 CreateMouse()=0;
		virtual HRESULT				 CloseMouse()=0;
		virtual HRESULT				 SendMouseData(UCHAR dx, UCHAR dy, UCHAR ucButtons, CHAR cWheel, BOOLEAN fClutch, BOOLEAN fDampen)=0;
	private:
		ULONG m_ulRefCount;
};

//*****************************************************************************************
//*****************************************************************************************
//************	What actions look like to the CDeviceFilter  ******************************
//*****************************************************************************************

class CAction
{
	public:
		CAction() : m_ucRef(1)
		{
			m_ucActionClass = CAction::DIGITAL_MAP;	//default is DIGITAL_MAP
		}
		virtual ~CAction(){};
		UCHAR GetActionClass() { return m_ucActionClass; }
		
		void IncRef(){ m_ucRef++; };
		void DecRef()
			{
				if(0 == --m_ucRef)
				{
					delete this;
				}
		}
			
		//Used by proportional map and derivatives
		//other types of actions, use do nothing
		virtual void SetValue(LONG /*lValue*/){}
		virtual void SetSourceRange(LONG /*lSourceMax*/, LONG /*lSourceMin*/){}

		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection ) = 0;
		virtual void TriggerReleased(){};
	
		//
		//	Classes of actions (some input items only some types) They also may have
		//	different semantics
		//
		static const UCHAR DIGITAL_MAP;			//cycle, button, key map fit this class
		static const UCHAR PROPORTIONAL_MAP;	//axis swap is this class
		static const UCHAR QUEUED_MACRO;		//timed macros and keystring fit this category
	protected:
		UCHAR m_ucActionClass;
	private:
		UCHAR m_ucRef;
};

class CBehavior
{
	public:
		CBehavior() : m_ucRef(1), m_lMin(-1), m_lMax(-1), m_fIsDigital(FALSE){}
		virtual ~CBehavior(){}
				
		void IncRef(){ m_ucRef++; };
		void DecRef()
			{
				if(0 == --m_ucRef)
				{
					delete this;
				}
		}
		virtual LONG CalculateBehavior(LONG lValue)
		{
			return lValue;
		}
		virtual void Calibrate(LONG lMin, LONG lMax)
		{
			m_lMin = lMin;
			m_lMax = lMax;
		}
		BOOLEAN IsDigital() {return m_fIsDigital;}
	protected:		
		LONG m_lMin;
		LONG m_lMax;
		BOOLEAN m_fIsDigital;
	private:
		UCHAR m_ucRef;

		
};

class CStandardBehavior : public CBehavior
{
	public:	
		CStandardBehavior() : m_pBehaviorCurve(NULL) {}
		~CStandardBehavior() { delete m_pBehaviorCurve;}
		BOOLEAN Init( PBEHAVIOR_CURVE pBehaviorCurve);
		virtual void Calibrate(LONG lMin, LONG lMax);
		virtual LONG CalculateBehavior(LONG lValue);

		CURVE_POINT GetBehaviorPoint(USHORT usPointIndex);
	private:
		PBEHAVIOR_CURVE m_pBehaviorCurve;
};



// forward declaration
class CQueuedAction;

class CActionQueue
{
	public:
		//static const UCHAR OVERLAY_MACROS;
		//static const UCHAR SEQUENCE_MACROS;
		static const ULONG MAXIMUM_JOG_DELAY;
	
		CActionQueue(CFilterClientServices *pFilterClientServices):
			m_pHeadOfQueue(NULL), m_ucFlags(0), m_ulItemsInQueue(0),
			m_pFilterClientServices(pFilterClientServices)
		{
				ASSERT(m_pFilterClientServices);
				m_pFilterClientServices->IncRef();
		}
		~CActionQueue()
		{
			m_pFilterClientServices->DecRef();
		}
		void	Jog();
		BOOLEAN InsertItem(CQueuedAction *pActionToEnqueue);
		void	RemoveItem(CQueuedAction *pActionToDequeue);
		void	NextJog(ULONG ulNextJogDelayMs);
		CQueuedAction* GetHead() const { return m_pHeadOfQueue; }

		void ReleaseTriggers();
	private:
		ULONG					m_ulItemsInQueue;
		ULONG					m_ulNextJogMs;
		CQueuedAction			*m_pHeadOfQueue;
		UCHAR					m_ucFlags;
		CFilterClientServices	*m_pFilterClientServices;
};

class CQueuedAction : public CAction
{
	friend CActionQueue;  //action queue need to be able to
						  //get to the linked list members
	
	public:
		CQueuedAction()
		{
			m_ucActionClass = CAction::QUEUED_MACRO;
		}
		void Init(CActionQueue *pActionQueue)
		{
			m_pActionQueue = pActionQueue;
			m_bActionQueued = FALSE;
		}
		virtual void Jog(ULONG ulTimeStampMs) = 0;
		virtual void Terminate() = 0;
		virtual ULONG GetActionFlags() = 0;
		virtual void ForceBleedThrough() {};		// This is used for axis always bleed through

	protected:
		CQueuedAction	*m_pNextQueuedAction;
		CActionQueue	*m_pActionQueue;
		BOOLEAN			m_bActionQueued;
};


class CTimedMacro : public CQueuedAction
{
	public:
		CTimedMacro() : m_ucProcessFlags(0), m_pKeyMixer(NULL)
		{}
		virtual ~CTimedMacro()
		{
			delete m_pTimedMacroData;
		}

		BOOLEAN Init(PTIMED_MACRO pTimedMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer);
		//
		//	Override of CAction
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		virtual void TriggerReleased();
		
		//
		//	Overrides of CQueuedAction
		//
		virtual void Jog(ULONG ulTimeStampMs);
		virtual void Terminate();
		virtual ULONG GetActionFlags()
		{
			return m_pTimedMacroData->ulFlags;
		}
	private:
		
		//
		//	Pointer to our dynamically allocated memory
		//
		UCHAR							m_ucProcessFlags;
		PTIMED_MACRO					m_pTimedMacroData;
		ULONG							m_ulCurrentEventNumber;
		PTIMED_EVENT					m_pCurrentEvent;
		CControlItemDefaultCollection	*m_pOutputCollection;
		ULONG							m_ulStartTimeMs;
		ULONG							m_ulEventEndTimeMs;
		CKeyMixer						*m_pKeyMixer;

		static const UCHAR TIMED_MACRO_STARTED;
		static const UCHAR TIMED_MACRO_RELEASED;
		static const UCHAR TIMED_MACRO_RETRIGGERED;
		static const UCHAR TIMED_MACRO_FIRST;
		static const UCHAR TIMED_MACRO_COMPLETE;
};

class CKeyString : public CQueuedAction
{
	public:
		CKeyString() : m_ucProcessFlags(0), m_pKeyMixer(NULL)
		{}
		virtual ~CKeyString()
		{
			delete m_pKeyStringData;
		}
		BOOLEAN Init(PKEYSTRING_MAP pKeyStringData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer);
		
		//
		//	Override of CAction
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		virtual void TriggerReleased();
		
		//
		//	Overrides of CQueuedAction
		//
		virtual void Jog(ULONG ulTimeStampMs);
		virtual void Terminate();
		virtual ULONG GetActionFlags()
		{
			return m_pKeyStringData->ulFlags;
		}

	private:
		
		//
		//	Pointer to our dynamically allocated memory
		//
		UCHAR							m_ucProcessFlags;
		PKEYSTRING_MAP					m_pKeyStringData;
		ULONG							m_ulCurrentEventNumber;
		PEVENT							m_pCurrentEvent;
		BOOLEAN							m_fKeysDown;
		CKeyMixer						*m_pKeyMixer;

		
		static const UCHAR KEY_STRING_STARTED;
		static const UCHAR KEY_STRING_RELEASED;
		static const UCHAR KEY_STRING_RETRIGGERED;
		static const UCHAR KEY_STRING_FIRST;
		static const UCHAR KEY_STRING_COMPLETE;
};

class CMapping : public CAction
{
	public:		
		CMapping() : m_pEvent(NULL), m_pKeyMixer(NULL){}
		~CMapping();
		BOOLEAN Init(PEVENT pEvent, CKeyMixer *pKeyMixer);
		
		//Overrides of CAction
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
	private:
		PEVENT		m_pEvent;
		CKeyMixer	*m_pKeyMixer;
};

class CProportionalMap	: public CAction
{
	public:
		CProportionalMap(): m_lValue(0)
		{
			m_ucActionClass = CAction::PROPORTIONAL_MAP;
		}
		virtual void SetValue(LONG lValue){ m_lValue = lValue;}
		virtual void SetSourceRange(LONG lSourceMax, LONG lSourceMin)
		{
			m_lSourceMax = lSourceMax;
			m_lSourceMin = lSourceMin;
			if(0==(m_lSourceMax-m_lSourceMin))
			{
				//We will divide by zero later if this is true
				//so increment m_SourceMax so as not to divide by zero.
				ASSERT(FALSE);
				m_lSourceMax++; 
			}
		}
	protected:
		LONG GetScaledValue(LONG lDestinationMax, LONG lDestinationMin);
		LONG m_lValue;
		LONG m_lSourceMin;
		LONG m_lSourceMax;
};

/*
*	BUGBUG The CAxisMap class in general should be assignable to any axis.
*	BUGBUG The current implementation has two serious limitations:
*	BUGBUG 1) The source and destination axes must have the same range.
*	BUGBUG 2) The source and destination axes must be derived from CGenericItem.
*	BUGBUG This code is suitable for the Pedals on ZepLite, but will break
*	BUGBUG for the Y-Z swap on any of the Joysticks.  The limitation is due to
*	BUGBUG an encapsulation problem.  The output control is a standard colleection  
*	BUGBUG and does not have a custom base class like the input colleciton.  Consequently,
*	BUGBUG there is no general mechanism to set the output of a proportional control.
*	BUGBUG The implementation assumes that the source and destination are of the same type.
*	BUGBUG This could be solved, by breaking the encapsulation in the implementation
*	BUGBUG in this class or by creating a custom output collection, that had appropriate
*	BUGBUG accessors.  Or perhaps a compromise:
*	BUGBUG ** Add a more generalized output set routine, that takes a ControlItemXfer,**
*	BUGBUG ** to identify the axis, and sets the axis based on it.					  **
*	BUGBUG For ZepLite it was not necessary and is therefore not done.
*/
class CAxisMap : public CProportionalMap
{
	public:
		CAxisMap() : m_lCoeff(0), m_lOffset(0){}
		void Init(const AXIS_MAP& AxisMapInfo);
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		virtual void SetSourceRange(LONG lSourceMax, LONG lSourceMin);
	private:
		LONG m_lCoeff;
		LONG m_lOffset;
		CONTROL_ITEM_XFER m_TargetXfer;
};
class CInputItem : public virtual CControlItem
{
	public:
		CInputItem() : m_pClientServices(NULL){}
		virtual ~CInputItem(){SetClientServices(NULL);}
		
		void SetClientServices(CFilterClientServices *pClientServices)
		{
			if(m_pClientServices == pClientServices) return;
			if(m_pClientServices)
			{
				m_pClientServices->DecRef();
			}
			if(pClientServices)
			{
				pClientServices->IncRef();
			}
			m_pClientServices = pClientServices;
		}

		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection )=0;
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction)=0;
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior)
		{
			UNREFERENCED_PARAMETER(pTrigger);
			UNREFERENCED_PARAMETER(pBehavior);
			return E_NOTIMPL;
		}
		virtual void ClearAssignments() = 0;

		virtual void PostAssignmentProcessing() {return;}
		virtual void Duplicate(CInputItem& rInputItem) = 0;
	protected:
		CFilterClientServices *m_pClientServices;
};

class CAxesInput : public CInputItem, public CAxesItem
{
	public:
		CAxesInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CAxesItem(cpControlItemDesc), m_pXAssignment(NULL), m_pYAssignment(NULL),
			m_pXBehavior(NULL), m_pYBehavior(NULL)
		{
		}
		~CAxesInput()
		{
			ClearAssignments();
		};
		
	
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		
		//
		//	Two assignments allowed one for X and one for Y
		//
		CAction *m_pXAssignment;
		CAction *m_pYAssignment;
		CBehavior *m_pXBehavior;
		CBehavior *m_pYBehavior;
};

class CDPADInput : public CInputItem, public CDPADItem
{
	public:
		CDPADInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CDPADItem(cpControlItemDesc), m_lLastDirection(-1)
		{
			for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
			{
				m_pDirectionalAssignment[ulIndex]=NULL;
			}
		}
		~CDPADInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
	
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		LONG	m_lLastDirection;
		CAction *m_pDirectionalAssignment[8];	//Eight Directions
};

class CPropDPADInput : public CInputItem, public CPropDPADItem
{
	public:
		CPropDPADInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPropDPADItem(cpControlItemDesc), m_lLastDirection(-1),
			m_pXBehavior(NULL), m_pYBehavior(NULL), m_fIsDigital(FALSE)
		{
			for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
			{
				m_pDirectionalAssignment[ulIndex]=NULL;
			}
		}
		~CPropDPADInput()
		{
			ClearAssignments();
		};
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void PostAssignmentProcessing() 
		{
			SwitchPropDPADMode();
		}
	
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		
		//Helper functions
		void SwitchPropDPADMode();

		LONG	m_lLastDirection;
		CAction *m_pDirectionalAssignment[8];	//Eight Directions
		CBehavior *m_pXBehavior;
		CBehavior *m_pYBehavior;
		BOOLEAN	m_fIsDigital;
};

class CButtonsInput : public CInputItem, public CButtonsItem
{
	public:
		CButtonsInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CButtonsItem(cpControlItemDesc), m_ulLastButtons(0), m_usLastShift(0)
		{
			m_ulNumAssignments = ( (GetButtonMax() - GetButtonMin()) + 1 ) * ( GetNumShiftButtons() + 1);
			m_ppAssignments = new WDM_NON_PAGED_POOL CAction *[m_ulNumAssignments];
			if(!m_ppAssignments)
			{
				ASSERT(FALSE);
				return;
			}
			for(ULONG ulIndex = 0; ulIndex < m_ulNumAssignments; ulIndex++)
			{
				m_ppAssignments[ulIndex] = NULL;
			}
		}
		~CButtonsInput()
		{
			ClearAssignments();
			if( m_ppAssignments)
			{
				delete m_ppAssignments;
			}
		};
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

		void GetLowestShiftButton(USHORT& rusLowestShiftButton) const;

		BOOLEAN IsButtonAssigned(ULONG ulButton, ULONG ulModifier) const
		{
			// Compute button
			ULONG ulAssignmentIndex = (ulModifier * (GetButtonMax() - GetButtonMin() + 1)) + (ulButton - GetButtonMin());

			if( (ulAssignmentIndex < m_ulNumAssignments) &&
				(m_ppAssignments != NULL) &&
				(m_ppAssignments[ulAssignmentIndex] != NULL))
			{
				return TRUE;
			}
			return FALSE;
		}
	private:
		ULONG m_ulLastButtons;
		ULONG m_ulNumAssignments;
		USHORT m_usLastShift;
		CAction **m_ppAssignments;
};
typedef CButtonsInput* CButtonsInputPtr;

class CPOVInput : public CInputItem, public CPOVItem
{
	public:
		CPOVInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPOVItem(cpControlItemDesc), m_lLastDirection(-1)
		{
			for(ULONG ulIndex = 0; ulIndex < 8; ulIndex++)
			{
				m_pDirectionalAssignment[ulIndex]=NULL;
			}
		}
		~CPOVInput()
		{
			ClearAssignments();
		};
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	
	private:		
		LONG	m_lLastDirection;
		CAction *m_pDirectionalAssignment[8];	//Eight Directions
};

class CThrottleInput : public CInputItem, public CThrottleItem
{
	public:
		CThrottleInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CThrottleItem(cpControlItemDesc)
		{}
		~CThrottleInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
};

class CRudderInput : public CInputItem, public CRudderItem
{
	public:
		CRudderInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CRudderItem(cpControlItemDesc)
		{
		}
		~CRudderInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
};


class CWheelInput : public CInputItem, public CWheelItem
{
	public:
		CWheelInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CWheelItem(cpControlItemDesc), m_pBehavior(NULL)
		{
		}
		~CWheelInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		CBehavior *m_pBehavior;
};

class CPedalInput : public CInputItem, public CPedalItem
{
	public:
		CPedalInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CPedalItem(cpControlItemDesc), m_pAssignment(NULL)
		{
		}
		~CPedalInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

	private:
		CAction *m_pAssignment;
};

class CZoneIndicatorInput : public CInputItem, public CZoneIndicatorItem
{
	public:
		CZoneIndicatorInput (const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CZoneIndicatorItem(cpControlItemDesc), m_pAssignmentX(NULL),
				m_pAssignmentY(NULL)
		{
		}
		~CZoneIndicatorInput()
		{
			ClearAssignments();
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

	private:
		CAction *m_pAssignmentX;			//Zone for X
		CAction *m_pAssignmentY;			//Zone for Y
		//CAction *m_pAssignmentZ;			//Zone for Z - not used
};

class CDualZoneIndicatorInput : public CInputItem, public CDualZoneIndicatorItem
{
	public:
		CDualZoneIndicatorInput(const CONTROL_ITEM_DESC *cpControlItemDesc);

		~CDualZoneIndicatorInput()
		{
			ClearAssignments();
			if (m_ppAssignments)
			{
				delete m_ppAssignments;
				m_ppAssignments = NULL;
			}
		};
		
		//  Filter execution (item maps itself to output)
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
		
		// Filter programmability
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual HRESULT AssignBehavior(CONTROL_ITEM_XFER *pTrigger, CBehavior *pBehavior);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
	private:
		CAction** m_ppAssignments;	// Assignment for each zone
		CBehavior* m_pBehavior;		// Behaviour (just dead zone stuff)
		LONG m_lNumAssignments;		// Number of assignable zones
		LONG m_lLastZone;			// Last zone we were in
};

class CProfileSelectorInput : public CInputItem, public CProfileSelector
{
	public:
		CProfileSelectorInput(const CONTROL_ITEM_DESC *cpControlItemDesc)
			: CProfileSelector(cpControlItemDesc)
		{
		}

		~CProfileSelectorInput()
		{
		};
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);
};

class CButtonLEDInput : public CInputItem, public CButtonLED
{
	public:
		CButtonLEDInput(const CONTROL_ITEM_DESC *cpControlItemDesc);
		~CButtonLEDInput();

		void Init(CInputItem* pCorrespondingButtons);
		
		//
		//  Filter execution (item maps itself to output)
		//
		virtual void MapToOutput( CControlItemDefaultCollection *pOutputCollection );
		
		//
		// Filter programmability
		//
		virtual HRESULT AssignAction(CONTROL_ITEM_XFER *pTrigger, CAction *pAction);
		virtual void ClearAssignments();
		virtual void Duplicate(CInputItem& rInputItem);

		void AssignmentsChanged();
		void SetLEDStates(GCK_LED_BEHAVIOURS ucLEDBehaviour, ULONG ulLEDsAffected, unsigned char ucShiftArray);
		USHORT GetCorrespondingButtonIndex() const { return m_ucCorrespondingButtonItemIndex; }
	private:
		CButtonsInput* m_pCorrespondingButtonsItem;
		UCHAR* m_pLEDSettings;
		USHORT m_usNumberOfButtons;
		UCHAR m_ucCorrespondingButtonItemIndex;
};

HRESULT	__stdcall InputItemFactory(
				USHORT	usType,
				const CONTROL_ITEM_DESC* cpControlItemDesc,
				PVOID *ppControlItem
			);

//
//	@class CKeyMixer | 
//			This class mixes input from multiple instances so that single virtual
//			keyboard can be used to stuff keys.  The theory is that each device filter
//			has a different instance of this class.  The class maintains a linked-list
//			of all its instances via a static variable.  The device filter may call
//			SetState, OverlayState or ClearState to update the keyboard state of the
//			that filter.  PlayGlobalState walks the linked list, mixes the states,
//			compares with the previous global state and if that state has changes (or
//			the fPlayIfNoChange flag is set) plays the new keys over the virtual keyboard.
//			The connection to the virutal keyboard is hooked via a function
//			of type PFNPLAYKEYS, which is passed in the constructor.  The first
//			call sets a global variable.  Subsequent calls assert that the hook is the
//			same.<nl>
//			To the CDeviceFilter object, this class is all it knows about keyboards.

class CKeyMixer
{
	public:	
		CKeyMixer(CFilterClientServices *pFilterClientServices);
		~CKeyMixer();
		void SetState(const CONTROL_ITEM_XFER& crcixNewLocalState);
		void OverlayState(const CONTROL_ITEM_XFER& crcixNewLocalState);
		void ClearState();
		void PlayGlobalState(BOOLEAN fPlayIfNoChange=FALSE);
		void Enable(BOOLEAN fEnable);
		
	private:
		CONTROL_ITEM_XFER	m_cixLocalState;
		BOOLEAN				m_fEnabled;
		//utility functions
		struct MIX_ALGO_PARAM
		{
			CONTROL_ITEM_XFER	*pcixDest;
			ULONG				ulDestCount;
			ULONG				rgulKeyMap[5];
		};
		void InitMixAlgoParam(MIX_ALGO_PARAM *pMixAlgParm, CONTROL_ITEM_XFER *pcixDest);
		void MixAlgorithm(CKeyMixer::MIX_ALGO_PARAM *pMixAlgParam, const CONTROL_ITEM_XFER *pcixSrc);
		inline void CopyKeyMap(ULONG *pulKeyMapDest, ULONG *pulKeyMapSrc)
		{
			for(ULONG ulIndex=0; ulIndex <5; ulIndex++)
			{
				pulKeyMapDest[ulIndex] = pulKeyMapSrc[ulIndex];
			}
		}
		inline BOOLEAN CompareKeyMap(ULONG *pulKeyMapDest, ULONG *pulKeyMapSrc)
		{
			for(ULONG ulIndex=0; ulIndex <5; ulIndex++)
			{
				if( pulKeyMapDest[ulIndex] != pulKeyMapSrc[ulIndex] ) return FALSE;
			}
			return TRUE;
		}
		
		CKeyMixer				*pNextKeyMixer;
		CFilterClientServices	*m_pFilterClientServices;
		static CKeyMixer		*ms_pHeadKeyMixer;
		static ULONG			ms_rgulGlobalKeymap[5];
		static UCHAR			ms_ucLastModifiers;
};

#define MOUSE_AXIS_MAX_IN 1024
#define MOUSE_AXIS_MIN_IN 0
#define MOUSE_AXIS_CENTER_IN 512
//
//	@class CMouseModel | 
//			This class embodies the model for combining various inputs from the
//			device into HID mouse packets.
//			The model must be initialized with a call to SetModelParameters.
//			If this is non-null the parameters are assigned.  If this is null
//			the mouse is returned to an unitialized state.
//
//			Controls may be assigned to the model at any time.  When an assignment
//			is created (or destroy) it should refcount the appropriate interface (Model
//			independent, or model dependent).
//
//			A virtual mouse is created and destroyed as needed based on the model parameters
//			and the ref counts.  A Model Independent refcount greater than zero or the combination
//			of valid model parameters and a model dependent refcount greater than zero requires
//			a virtual mouse.
//
class CMouseModel
{
	public:
		
		//**
		//**	Creation and destruction
		//**
		CMouseModel(CFilterClientServices *pFilterClientServices) : 
			m_pFilterClientServices(pFilterClientServices),
			m_ulRefCount(1), m_pMouseModelData(NULL)
		{
			ASSERT(m_pFilterClientServices);

			m_pFilterClientServices->IncRef();
			CreateDynamicMouseObjects();
		}

		~CMouseModel()
		{
			//Cleanup any dynamic stuff we created
			DestroyDynamicMouseObjects();
			m_pFilterClientServices->DecRef();
			m_pFilterClientServices = NULL;
		}

		//**
		//**  Programmability interface
		//**

		//Model parameters are set from a command
		HRESULT SetXModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters);
		HRESULT SetYModelParameters(PMOUSE_MODEL_PARAMETERS pModelParameters);
		
		//Reference counting
		inline ULONG IncRef()
		{
			m_ulRefCount++;
			return m_ulRefCount;
		}

		inline ULONG DecRef()
		{
			m_ulRefCount--;
			if (m_ulRefCount == 0)
			{
				delete this;
				return 0;
			}
			return m_ulRefCount;
		}

		//**
		//** Playback interface
		//**

		//called by device filters MapToOutput, to reset state for a new packet
		void NewPacket(ULONG ulCurrentTime);

		//called by the X and Y assignments one every map to set the current position
		inline void SetX(ULONG ulX) 
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateX.ulPos = ulX;
		}
		inline void SetY(ULONG ulY)
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateY.ulPos = ulY;
		}
		inline void	XZone()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateX.fInZone = TRUE;
		}
		
		inline void	YZone()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->StateY.fInZone = TRUE;
		}
		//called by appropriate assignments on a map only if activated.
		inline void Clutch()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->fClutchDown = TRUE;
		}
		inline void Dampen()
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->fDampenDown = TRUE;
		}
		inline void MouseButton(UCHAR ucButtonNumber)
		{
			ASSERT(m_pMouseModelData);
			if(!m_pMouseModelData) return;
			m_pMouseModelData->ucButtons |= (1 << ucButtonNumber);
		}
		
		//called by device filters MapToOutput (at end), to send packet to output
		void SendMousePacket();
	
	private:

		//
		//	Creates and destroys virtual mouse, as well as pMouseModelData
		//
		HRESULT	CreateDynamicMouseObjects();
		void	DestroyDynamicMouseObjects();

		//
		//	The following structure block of a data is needed only when the model is in
		//	use.  CMouseModel is instantiated for every device, regardless of whether
		//	an assignment uses the model.  For efficiency, we keep a reference count
		//	on the users that are actually using the mosue, when that becomes positive
		//	we instantiate this data.  When it goes to zero we delete.
		//
		typedef struct MOUSE_AXIS_STATE
		{
			//c'tor
			MOUSE_AXIS_STATE() :
				ulPos(512),
				ulLastPos(512),
				fInZone(FALSE),
				ulZoneEnterLo(MOUSE_AXIS_MIN_IN+1),
				ulZoneEnterHigh(MOUSE_AXIS_MAX_IN-1),
				fInertia(FALSE),
				ulInertiaStopMs(0),
				ulPulseGateStartMs(0) {}
			//Position Info
			ULONG	ulPos;
			ULONG	ulLastPos;
			BOOLEAN	fInZone;
			//HysteresisInfo
			ULONG	ulZoneEnterLo;
			ULONG	ulZoneEnterHigh;
			BOOLEAN	fInertia;
			ULONG	ulInertiaStopMs;
			ULONG	ulPulseGateStartMs;
			ULONG	ulMickeyFraction;		//Mickeys * 1024
		} *PMOUSE_AXIS_STATE;

		typedef struct MOUSE_MODEL_DATA
		{
			//Initdata
			MOUSE_MODEL_DATA() :
				fXModelParametersValid(FALSE),
				fYModelParametersValid(FALSE),
				ulCurrentTime(0),
				ulLastTime(0),
				fClutchDown(FALSE),
				fDampenDown(FALSE),
				ucButtons(UCHAR(-1)),
				ucLastButtons(UCHAR(-1)),
				cWheel(0)
				{}
			//
			//	Setable model parameters
			//
			BOOLEAN					fXModelParametersValid;
			MOUSE_MODEL_PARAMETERS	XModelParameters;
			BOOLEAN					fYModelParametersValid;
			MOUSE_MODEL_PARAMETERS	YModelParameters;
			
			//
			//	Latest state data of the inputs
			//
			ULONG	ulCurrentTime;
			ULONG	ulLastTime;
			BOOLEAN	fClutchDown;
			BOOLEAN	fDampenDown;
			UCHAR	ucButtons;
			CHAR	cWheel;

			// Last Mouse Button State (don't want to repeat for no reason)
			UCHAR	ucLastButtons;
			
			//
			//	Variables maintaining state of axes
			//
			MOUSE_AXIS_STATE StateX;
			MOUSE_AXIS_STATE StateY;

		} *PMOUSE_MODEL_DATA;
		
		//
		//	Data Related to Model State
		//	
		ULONG				m_ulRefCount;
		PMOUSE_MODEL_DATA	m_pMouseModelData;

		//Calculate Axis position
		UCHAR CalculateMickeys(PMOUSE_AXIS_STATE pMouseAxisState, PMOUSE_MODEL_PARAMETERS pModelParameters);

		//
		//	Data Related To Virtual Mouse
		//
		CFilterClientServices *m_pFilterClientServices;
};

class CMultiMacro : public CQueuedAction
{
	public:
		CMultiMacro(CMouseModel *pMouseModel) :
			m_ucProcessFlags(ACTION_FLAG_PREVENT_INTERRUPT),
			m_pKeyMixer(NULL),
			m_pMouseModel(pMouseModel)
			{
				ASSERT(pMouseModel != NULL);
				m_pMouseModel->IncRef();
			};
		~CMultiMacro()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel = NULL;
		};

		BOOLEAN Init(PMULTI_MACRO pMultiMacroData, CActionQueue *pActionQueue, CKeyMixer *pKeyMixer);

		//
		//	Override of CAction
		//
		virtual void MapToOutput(CControlItemDefaultCollection* pOutputCollection);
		virtual void TriggerReleased();
		
		//
		//	Overrides of CQueuedAction
		//
		void Jog(ULONG ulTimeStampMs);
		void Terminate();
		ULONG GetActionFlags() { return m_ucProcessFlags; }
		void ForceBleedThrough();

		void SetCurrentKeysAndMouse();
	private:
		UCHAR			m_ucProcessFlags;
		PMULTI_MACRO	m_pMultiMacroData;
		CKeyMixer*		m_pKeyMixer;
		CMouseModel*	m_pMouseModel;
		ULONG			m_ulCurrentEventNumber;
		EVENT*			m_pCurrentEvent;
		ULONG			m_ulStartTimeMs;
		ULONG			m_ulEndTimeMs;
		BOOLEAN			m_fXferActive;		// Keysdown or MousePressed or Delay Active

		static const UCHAR MULTIMACRO_STARTED;
		static const UCHAR MULTIMACRO_RELEASED;
		static const UCHAR MULTIMACRO_RETRIGGERED;
		static const UCHAR MULTIMACRO_FIRST;
};

class CMouseAxisAssignment : public CProportionalMap
{
	public:
		CMouseAxisAssignment(BOOLEAN fXAxis, CMouseModel *pMouseModel) :
		  m_fXAxis(fXAxis), m_pMouseModel(pMouseModel)
		{
			m_pMouseModel->IncRef();
		}
		~CMouseAxisAssignment()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel = NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		BOOLEAN		m_fXAxis;
		CMouseModel	*m_pMouseModel;
};

class CMouseButton : public CAction
{
	public:
		CMouseButton(UCHAR ucButtonNumber, CMouseModel *pMouseModel):
		  m_ucButtonNumber(ucButtonNumber), m_pMouseModel(pMouseModel)
		  {
			  m_pMouseModel->IncRef();
		  }
		  ~CMouseButton()
		  {
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		  }
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		UCHAR		m_ucButtonNumber;
		CMouseModel	*m_pMouseModel;
};

class CMouseClutch : public CAction
{
	public:
		CMouseClutch(CMouseModel *pMouseModel):
		  m_pMouseModel(pMouseModel)
		  {
			m_pMouseModel->IncRef();
		  }
		~CMouseClutch()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		CMouseModel	*m_pMouseModel;
};

class CMouseDamper : public CAction
{
	public:
		CMouseDamper(CMouseModel *pMouseModel):
		  m_pMouseModel(pMouseModel)
		  {
			m_pMouseModel->IncRef();
		  }
		~CMouseDamper()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		CMouseModel	*m_pMouseModel;
};

class CMouseZoneIndicator : public CAction
{
	public:
		CMouseZoneIndicator(UCHAR ucAxis, /* 0 = X, 1=Y, 2=Z,*/CMouseModel *pMouseModel):
		  m_pMouseModel(pMouseModel)
		  {
			m_pMouseModel->IncRef();
			m_ucAxis=ucAxis;
		  }
		~CMouseZoneIndicator()
		{
			m_pMouseModel->DecRef();
			m_pMouseModel=NULL;
		}
		virtual void MapToOutput(CControlItemDefaultCollection *pOutputCollection);
	private:
		CMouseModel	*m_pMouseModel;
		UCHAR		m_ucAxis;
};

class CDeviceFilter
{
	public:
		CDeviceFilter(CFilterClientServices *pFilterClientServices);
		~CDeviceFilter();
		
		//
		//	Entry point to filter which processes data.
		//	ProcessInput and JogActionQueue, both defer most action
		//	to the Jog routine.
		//
		void IncomingRequest();
		void ProcessInput(PCHAR pcReport, ULONG ulReportLength);
		void JogActionQueue(PCHAR pcReport, ULONG ulReportLength);
		void Jog(PCHAR pcReport, ULONG ulReportLength);
		void OtherFilterBecomingActive();

		//
		//	Program filter(entry point for programming filter)
		//
		HRESULT ActionFactory( PASSIGNMENT_BLOCK pAssignment, CAction **ppAction);
		HRESULT BehaviorFactory(PASSIGNMENT_BLOCK pAssignment, CBehavior **ppBehavior);
		NTSTATUS ProcessCommands(const PCOMMAND_DIRECTORY cpCommandDirectory);
		void UpdateAssignmentBasedItems(BOOLEAN bIgnoreWorking);

		NTSTATUS ProcessKeyboardIrp(IRP* pKeyboardIrp);
		inline void	EnableKeyboard(BOOLEAN fEnable)
		{
			m_KeyMixer.Enable(fEnable);
		}
		inline CFilterClientServices* GetFilterClientServices()
		{
			return m_pFilterClientServices;
		}

		// WorkingSet
		NTSTATUS SetWorkingSet(UCHAR ucWorkingSet);
		void SetActiveSet(UCHAR ucActiveSet) { m_ucActiveInputCollection = ucActiveSet; }
		UCHAR GetWorkingSet() const { return m_ucWorkingInputCollection; }
		UCHAR GetActiveSet() const { return m_ucActiveInputCollection; }
		void CopyToTestFilter(CDeviceFilter& rDeviceFilter);

		// LED functions
		NTSTATUS SetLEDBehaviour(GCK_LED_BEHAVIOUR_OUT* pLEDBehaviourOut);

		// Trigger Functions
		BOOLEAN TriggerRequest(IRP* pIrp);
		void CompleteTriggerRequest(IRP* pIrp, ULONG ulButtonStates);
		void CheckTriggers(PCHAR pcReport, ULONG ulReportLength);
		
		BOOLEAN DidFilterBlockChange() const { return m_bFilterBlockChanged; }
		void ResetFilterChange() { m_bFilterBlockChanged = FALSE; }
		FORCE_BLOCK* GetForceBlock() const { return m_pForceBlock; }
	private:
		BOOLEAN EnsureMouseModelExists();

		CControlItemCollection<CInputItem>* m_rgInputCollections;
		UCHAR m_ucActiveInputCollection;
		UCHAR m_ucWorkingInputCollection;
		UCHAR m_ucNumberOfInputCollections;
		CControlItemDefaultCollection m_OutputCollection;
		CFilterClientServices *m_pFilterClientServices;
		CActionQueue	m_ActionQueue;
		CKeyMixer		m_KeyMixer;
		CMouseModel*	m_pMouseModel;
		CGckMutexHandle m_MutexHandle;
		FORCE_BLOCK*	m_pForceBlock;
		BOOLEAN			m_bFilterBlockChanged;
		BOOLEAN			m_bNeedToUpdateLEDs;
};


#endif //__Filter_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\debug.h ===
//**************************************************************************
//
//		DEBUG.H -- X2 Gaming Project
//
//		Version 4.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@topic	DEBUG.H | Global definitions for debugging output
//**************************************************************************

#ifndef	DEBUG_H
#define	DEBUG_H

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

//
// DEBUG output types (NOT LEVELS)
//
#define DBG_ENTRY		0x00000001	//Traceout on entry to function
#define DBG_EXIT		0x00000002	//Traceout on exit from function
#define DBG_WARN		0x00000004	//Traceout signifying a warning (or informational)
#define DBG_TRACE		0x00000008	//Traceout signifying a warning (or informational)
#define DBG_ERROR		0x00000010	//Traceout signifying an error
#define DBG_CRITICAL	0x00000020	//Traceout signifying a critical error
#define DBG_RT_ENTRY	0x00000040	//Traceout on entry to function (TIME CRITICAL CODE)
#define DBG_RT_EXIT		0x00000080	//Traceout on exit from function (TIME CRITICAL CODE)
#define DBG_RT_WARN		0x00000100	//Traceout signifying a warning (or informational) (TIME CRITICAL CODE)


// Combos of above for setting warning levels easily
#define DBG_NOT_RT		0x0000003F	//Traceout all above except RT codes
#define DBG_RT			0x000001C0	//Traceout RT codes
#define DBG_WARN_ERROR	0x00000134	//Traceout warnings and errors including DBG_RT_WARN
#define DBG_ALL			0xFFFFFFFF	//Traceout all codes


#if	 (DBG==1)

//
//	Declaration for debug module
//


//
//	Must start file with a #define for the DEBUG module
//
//i.e. #define __DEBUG_MODULE_IN_USE__  GCKERNEL_DEBUG_MODULE
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)\
	ULONG __DEBUG_MODULE_IN_USE__ = __x__;
#define SET_MODULE_DEBUG_LEVEL(__x__)\
	__DEBUG_MODULE_IN_USE__ = __x__;


//
//	Conditional debug output procedures
//

#define GCK_DBG_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ENTRY)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_EXIT)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_WARN)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_TRACE_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_TRACE)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_ERROR_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_ERROR)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_CRITICAL_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_CRITICAL)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_RT_ENTRY_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_ENTRY)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_RT_EXIT_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_EXIT)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define GCK_DBG_RT_WARN_PRINT(__x__)\
	if(__DEBUG_MODULE_IN_USE__ & DBG_RT_WARN)\
	{\
		DbgPrint("GcKernel: ");\
		DbgPrint __x__;\
	}

#define	GCK_DBG_BREAK()	DbgBreakPoint()

#undef	PAGED_CODE
#define	PAGED_CODE() \
	if (KeGetCurrentIrql() > APC_LEVEL)	\
	{\
		GCK_DBG_CRITICAL_PRINT(("GcKernel: Pageable code called at IRQL %ld (file: %s, line:#%ld)\n", KeGetCurrentIrql(),__FILE__,__LINE__))\
   		ASSERT(FALSE);\
	}
	//External
	void SetDebugLevel(ULONG ulModuleId, ULONG ulDebugLevel);

#define USING_CASE_FALLTHROUGH_TRACE	ULONG macro_ulTraceoutSentAlready = FALSE;
#define	START_CASE_FALLTHROUGH_TRACE	macro_ulTraceoutSentAlready = FALSE;
#define TRACEOUT_THIS_CASE_ONLY			if(!macro_ulTraceoutSentAlready && (macro_ulTraceoutSentAlready=TRUE) )

#else		// DBG=0

#define	GCK_DBG_ENTRY_PRINT(__x__)
#define	GCK_DBG_EXIT_PRINT(__x__)
#define GCK_DBG_TRACE_PRINT(__x__)
#define	GCK_DBG_WARN_PRINT(__x__)
#define	GCK_DBG_ERROR_PRINT(__x__)
#define	GCK_DBG_CRITICAL_PRINT(__x__)
#define	GCK_DBG_RT_ENTRY_PRINT(__x__)
#define	GCK_DBG_RT_EXIT_PRINT(__x__)
#define	GCK_DBG_RT_WARN_PRINT(__x__)
#define	GCK_DBG_BREAK()
#undef	PAGED_CODE
#define	PAGED_CODE()
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)
#define SET_MODULE_DEBUG_LEVEL(__x__)
#define USING_CASE_FALLTHROUGH		
#define	START_CASE_FALLTHROUGH_TRACE
#define TRACEOUT_THIS_CASE_ONLY		

#endif	// DBG=?


//===========================================================================
//			End
//===========================================================================

#endif	// DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filterhooks.cpp ===
//	@doc
/**********************************************************************
*
*	@module	FilterHooks.cpp	|
*
*	Contains the hooks necessary to bridge the gap between the C driver
*	shell and the C++ filter module
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	FilterHooks	|
*	The filter.cpp module in principal can run in USER mode
*	and KERNEL mode.  It does require some system services
*	that are dependent on which mode it is running.  Additionally
*	a C module can call directly into C++ classes.  This module bridges
*	the gap.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FILTERHOOKS_CPP
#define __INCLUDES_FILTER_HOOKS_H__
extern "C"
{
	#include <wdm.h>
	#include "Debug.h"
	#include "GckShell.h"
	#include <winerror.h>
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}
#include "SWVKBD.h"
#include "swvmouse.h"
#include "Filter.h"
#include "FilterHooks.h"

#define GCK_HidP_GetReportID(__ReportPacket__) (*(PCHAR)(__ReportPacket__))
#define GCK_HidP_OutputReportLength 16
#define GCK_PIDReportID_SetEffect 1
#define GCK_PIDReportID_SetGain 13
#define GCK_PIDEffectID_Spring 1

#define GCK_Atilla_Default_FastBlinkTime_On 0x11	// (170 msec)
#define GCK_Atilla_Default_FastBlinkTime_Off 0x11	// (170 msec)

NTSTATUS _stdcall GCKF_InitFilterHooks(PGCK_FILTER_EXT pFilterExt)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_InitFilterHooks, pFilterExt = 0x%0.8x\n", pFilterExt));
	NTSTATUS NtStatus = STATUS_SUCCESS;
	GCK_FILTER_HOOKS_DATA *pFilterHooks;
	
	pFilterHooks = new WDM_NON_PAGED_POOL GCK_FILTER_HOOKS_DATA;
	if(!pFilterHooks)
	{
		pFilterExt->pFilterHooks=NULL;
		GCK_DBG_ERROR_PRINT(("Not enough memory to create GCK_FILTER_HOOKS_DATA.\n"));
		return STATUS_NO_MEMORY;
	}
	pFilterExt->pFilterHooks=pFilterHooks;

	//
	//	Ensure that a virtual keyboard exists
	//
    if( NULL == Globals.pVirtualKeyboardPdo)
	{
		NtStatus = GCK_VKBD_Create(&Globals.pVirtualKeyboardPdo);
		ASSERT( NT_SUCCESS(NtStatus) );
		if( NT_ERROR(NtStatus) )
		{
			return NtStatus;
		}
	}
	Globals.ulVirtualKeyboardRefCount++;

	//
	// Initialize Timer and DPC for jogging CDeviceFilter
	//
	KeInitializeTimer(&pFilterHooks->Timer);
	KeInitializeDpc(&pFilterHooks->DPC, &GCKF_TimerDPCHandler, reinterpret_cast<PVOID>(pFilterExt));

	//
	//	Create Filter for the primary filter
	//
	CFilterGcKernelServices *pFilterGcKernelServices;
	pFilterGcKernelServices = new WDM_NON_PAGED_POOL CFilterGcKernelServices(pFilterExt);
	if( NULL == pFilterGcKernelServices)
	{
		//Out of memory for pFilterGcKernelServices, don't even attempt a CDeviceFilter
		pFilterHooks->pFilterObject = NULL;
		GCK_DBG_ERROR_PRINT(("Not enough memory to create pFilterGcKernelServices.\n"));
		NtStatus = STATUS_NO_MEMORY;
	}	
	else
	{
		//Try creating a CDeviceFilter
		GCK_DBG_TRACE_PRINT(("Creating Filter Object\n"));
		pFilterHooks->pFilterObject  = new WDM_NON_PAGED_POOL CDeviceFilter(pFilterGcKernelServices);
		
		//succeed or fail, we are done with pFilterGcKernelServices
		pFilterGcKernelServices->DecRef();
		if( NULL == pFilterHooks->pFilterObject)
		{
			GCK_DBG_ERROR_PRINT(("Not enough memory to create filter object.\n"));
			NtStatus = STATUS_NO_MEMORY;
		}
	}
	
	// The device is currently NOT in test mode
	pFilterHooks->pTestFileObject = NULL;
	pFilterHooks->pSecondaryFilter=NULL;
		
	// Initialize IRP Queue
	pFilterHooks->IrpQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
								(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
								 &pFilterExt->RemoveLock
								);
	pFilterHooks->IrpTestQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	pFilterHooks->IrpRawQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	pFilterHooks->IrpMouseQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	pFilterHooks->IrpKeyboardQueue.Init( CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE,
									(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
									 &pFilterExt->RemoveLock
									);
	
	GCK_DBG_EXIT_PRINT(("Exiting GCKF_InitFilterHooks, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;	
}

void _stdcall GCKF_DestroyFilterHooks(PGCK_FILTER_EXT pFilterExt)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_DestroyFilterHooks, pFilterExt = 0x%0.8x\n", pFilterExt));
	
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	
	//
	//	Delete filters if there are some
	//
	volatile CDeviceFilter *pTempFilterPointer;
	if(pFilterHooks->pFilterObject)
	{
		pTempFilterPointer = pFilterHooks->pFilterObject;
		pFilterHooks->pFilterObject = NULL;
		delete pTempFilterPointer;
	}
	if(pFilterHooks->pSecondaryFilter)
	{
		pTempFilterPointer = pFilterHooks->pSecondaryFilter;
		pFilterHooks->pSecondaryFilter= NULL;
		delete pTempFilterPointer;
	}

	//
	//	Decrement refcount of Virtual Keyboard users, and close virtual keyboard if necessary
	//
	if( 0 == --Globals.ulVirtualKeyboardRefCount)
	{
		if( NT_SUCCESS( GCK_VKBD_Close( Globals.pVirtualKeyboardPdo ) ) )
		{
			Globals.pVirtualKeyboardPdo = 0;
		}
		else
		{
			ASSERT(FALSE);
		}
	}

	//Destroy IrpQueue (cancelling any Irps that may be in it).
	pFilterHooks->IrpQueue.Destroy();
	pFilterHooks->IrpTestQueue.Destroy();
	pFilterHooks->IrpRawQueue.Destroy();
	pFilterHooks->IrpMouseQueue.Destroy();
	pFilterHooks->IrpKeyboardQueue.Destroy();

	// delete the filter hooks itself
	delete pFilterExt->pFilterHooks;
	pFilterExt->pFilterHooks = NULL;

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_DestroyFilterHooks\n"));
}

NTSTATUS _stdcall GCKF_BeginTestScheme
(
	PGCK_FILTER_EXT pFilterExt,
	PCHAR pCommandBuffer,
	ULONG ulBufferSize,
	FILE_OBJECT *pFileObject
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	GCK_FILTER_HOOKS_DATA *pFilterHooks;

	pFilterHooks = pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_NOT_FOUND;
	}

	if(pFilterHooks->pTestFileObject)
	{
		ASSERT( pFilterHooks->pSecondaryFilter);
		//delete is safe even if NULL
		volatile CDeviceFilter *pTempFilter = pFilterHooks->pSecondaryFilter;
		pFilterHooks->pSecondaryFilter = NULL;
		pFilterHooks->pTestFileObject = NULL;
		delete pTempFilter;
	}

	CFilterGcKernelServices *pFilterGcKernelServices;
	pFilterGcKernelServices = new WDM_NON_PAGED_POOL CFilterGcKernelServices(pFilterExt, FALSE);
	if( NULL == pFilterGcKernelServices)
	{
		//Out of memory for pFilterGcKernelServices, don't even attempt a CDeviceFilter
		GCK_DBG_ERROR_PRINT(("Not enough memory to create pFilterGcKernelServices.\n"));
		NtStatus = STATUS_NO_MEMORY;
	}	
	else
	{
		//Try creating a CDeviceFilter
		GCK_DBG_TRACE_PRINT(("Creating Filter Object\n"));
		pFilterHooks->pSecondaryFilter  = new WDM_NON_PAGED_POOL CDeviceFilter(pFilterGcKernelServices);
		
		//succeed or fail, we are done with pFilterGcKernelServices
		pFilterGcKernelServices->DecRef();
		if (pFilterHooks->pSecondaryFilter == NULL)
		{
			GCK_DBG_ERROR_PRINT(("Not enough memory to create filter object.\n"));
			NtStatus = STATUS_NO_MEMORY;
		}
		else
		{
			// Keep track of the active set everytime we change filters
			if (pFilterHooks->pFilterObject)
			{
				pFilterHooks->pFilterObject->OtherFilterBecomingActive();
				pFilterHooks->pFilterObject->CopyToTestFilter(*(pFilterHooks->pSecondaryFilter));
			}
			pFilterHooks->pTestFileObject = pFileObject;
			NtStatus = GCKF_UpdateTestScheme(pFilterExt, pCommandBuffer, ulBufferSize, pFileObject);
		}
	}
	return NtStatus;
}

NTSTATUS _stdcall GCKF_UpdateTestScheme
(
	PGCK_FILTER_EXT pFilterExt,
	PCHAR pCommandBuffer,
	ULONG ulBufferSize,
	FILE_OBJECT *pFileObject
)
{
	GCK_FILTER_HOOKS_DATA *pFilterHooks;
	pFilterHooks = pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_NOT_FOUND;
	}
	
	//Only the last one to call GCKF_BeginTestScheme can update it.
	if( pFilterHooks->pTestFileObject != pFileObject )
	{
		return STATUS_ACCESS_DENIED;
	}
	
	ASSERT(pFilterHooks->pSecondaryFilter);

	NTSTATUS NtStatus = GCKF_ProcessCommands(pFilterExt, pCommandBuffer, ulBufferSize, FALSE);
	pFilterHooks->pSecondaryFilter->UpdateAssignmentBasedItems(TRUE);

	return NtStatus;
}

NTSTATUS _stdcall GCKF_EndTestScheme
(
	PGCK_FILTER_EXT pFilterExt,
	FILE_OBJECT *pFileObject
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	GCK_FILTER_HOOKS_DATA *pFilterHooks;

	pFilterHooks = pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_NOT_FOUND;
	}
	
	//Only the last one to call GCKF_BeginTestScheme can End it.
	if( pFilterHooks->pTestFileObject != pFileObject )
	{
		return STATUS_ACCESS_DENIED;
	}

//	volatile CDeviceFilter *pDeviceFilter = pFilterHooks->pSecondaryFilter;
	CDeviceFilter *pDeviceFilter = pFilterHooks->pSecondaryFilter;
	pFilterHooks->pSecondaryFilter = NULL;
	pFilterHooks->pTestFileObject = NULL;

	CDeviceFilter* pPrimaryFilter = pFilterHooks->pFilterObject;
	if (pDeviceFilter != NULL)
	{
		// Stop any partially playing items
		pDeviceFilter->OtherFilterBecomingActive();

		if (pPrimaryFilter != NULL)
		{
			// Keep track of the active set everytime we change filters
			pPrimaryFilter->SetActiveSet(pDeviceFilter->GetActiveSet());
			GCKF_OnForceFeedbackChangeNotification(pFilterExt, (void*)pPrimaryFilter->GetForceBlock());
			pPrimaryFilter->UpdateAssignmentBasedItems(TRUE);
		}
		delete pDeviceFilter;
	}
	
	return NtStatus;
}

NTSTATUS _stdcall GCKF_ProcessCommands( IN PGCK_FILTER_EXT pFilterExt, IN PCHAR pCommandBuffer, IN ULONG ulBufferSize, BOOLEAN fPrimaryFilter)
{

	NTSTATUS NtStatus = STATUS_SUCCESS;
	ULONG ulRemainingBuffer = ulBufferSize;
	COMMAND_DIRECTORY *pCommandDirectory;
	COMMAND_DIRECTORY *pNextCommandDirectory;
	ULONG ulDirectorySize;

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	if( !pFilterHooks || ! pFilterHooks->pFilterObject )
	{
		return STATUS_NOT_FOUND;
	}

	CDeviceFilter *pDeviceFilter;
	//If there is a secondary filter all commands go to it
	if(!fPrimaryFilter && pFilterHooks->pSecondaryFilter)
	{
		pDeviceFilter = pFilterHooks->pSecondaryFilter;
	}
	else
	{
		pDeviceFilter = pFilterHooks->pFilterObject;
	}

	pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(pCommandBuffer);
	
	//Verify that we are a directory
	ASSERT(eDirectory == pCommandDirectory->CommandHeader.eID);
	if(eDirectory != pCommandDirectory->CommandHeader.eID)
	{
		return STATUS_INVALID_PARAMETER;
	}
	
	//Verify that the total size is as big as input buffer
	ASSERT( ulBufferSize >= pCommandDirectory->ulEntireSize );
	if( ulBufferSize < pCommandDirectory->ulEntireSize )
	{
		return STATUS_INVALID_PARAMETER;
	}

	//
	//	Call the filters ProcessCommands
	//
	NtStatus = pDeviceFilter->ProcessCommands(pCommandDirectory);

	// Update any assignment based items (don't ignore working/active relationship)
	pDeviceFilter->UpdateAssignmentBasedItems(FALSE);

	if (pDeviceFilter->DidFilterBlockChange())	// Did the force block change
	{	// Yes - Reset the flag and Send a Change Notification
		pDeviceFilter->ResetFilterChange();
		if (pDeviceFilter->GetForceBlock() != NULL)
		{
			GCKF_OnForceFeedbackChangeNotification(pFilterExt, (void*)pDeviceFilter->GetForceBlock());
		}
	}

	//
	//	If internal polling is on, we may need to get the ball rolling
	//	I don't really care if this fails
	//
	GCK_IP_OneTimePoll(pFilterExt);

	return NtStatus;
}

unsigned char g_rgbCombinePedalsCmd[170] = {
    0x00, 0x00, 0x00, 0x00, // Dir
    0x0e, 0x00, 0x00, 0x00, // Bytes
    0x02, 0x00,             // Items
    0x9a, 0x00, 0x00, 0x00, // Total

        0x00, 0x00, 0x00, 0x00, // Dir
        0x0e, 0x00, 0x00, 0x00, 
        0x02, 0x00, 
        0x46, 0x00, 0x00, 0x00, 

            0x01, 0x00, 0x01, 0x00, // eRecordableAction
            0x18, 0x00, 0x00, 0x00, 
            0x02, 0x00, 0x00, 0x00, // Accel
            0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 

            0x0c, 0x00, 0x02, 0x80, // eAxisMap
            0x20, 0x00, 0x00, 0x00, // Bytes
            0xff, 0xff, 0xff, 0xff, // VIDPID
            0x00, 0x02, 0x00, 0x00, // lCoefficient1024x
            0x02, 0x00, 0x00, 0x00, // ulItemIndex - to Y
            0x01, 0x00, 0x00, 0x00, // lValX
            0x00, 0x00, 0x00, 0x00, // lValY
            0x00, 0x00, 0x00, 0x00, // ulModifiers

        0x00, 0x00, 0x00, 0x00, // Dir
        0x0e, 0x00, 0x00, 0x00, 
        0x02, 0x00, 
        0x46, 0x00, 0x00, 0x00, 

            0x01, 0x00, 0x01, 0x00, 
            0x18, 0x00, 0x00, 0x00, 
            0x03, 0x00, 0x00, 0x00, // Brake
            0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 

            0x0c, 0x00, 0x02, 0x80, // eAxisMap
            0x20, 0x00, 0x00, 0x00, // Bytes
            0xff, 0xff, 0xff, 0xff, // VIDPID
            0x00, 0xfe, 0xff, 0xff, // lCoefficient1024x
            0x02, 0x00, 0x00, 0x00, // ulItemIndex - to Y
            0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00 

};

void _stdcall GCKF_SetInitialMapping( IN PGCK_FILTER_EXT pFilterExt )
{
    if( ( pFilterExt->HidInfo.HidCollectionInfo.ProductID == 0x001A )
     || ( pFilterExt->HidInfo.HidCollectionInfo.ProductID == 0x0034 ) )
    {
	    GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	    if( pFilterHooks && pFilterHooks->pFilterObject )
	    {
    	    COMMAND_DIRECTORY *pCommandDirectory;
	        
            pCommandDirectory = reinterpret_cast<PCOMMAND_DIRECTORY>(g_rgbCombinePedalsCmd);
	        
	        //
	        //	Call the filters ProcessCommands
	        //
	        pFilterHooks->pFilterObject->ProcessCommands(pCommandDirectory);
	    }
    }
}

NTSTATUS _stdcall GCKF_IncomingReadRequests(PGCK_FILTER_EXT pFilterExt, PIRP pIrp)
{
	NTSTATUS NtStatus;
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_IncomingReadRequests, pFilterExt = 0x%0.8x, pIrp = 0x%0.8x\n", pFilterExt, pIrp));

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	if(pFilterHooks)
	{
		// Was this a real incoming request or result of one time poll?
		if (pIrp != NULL)
		{	// real incoming request
			NtStatus = pFilterHooks->IrpQueue.Add(pIrp);
		}

		//If there is a secondary filter all commands go to it
		CDeviceFilter *pDeviceFilter;
		if (pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterHooks->pFilterObject;
		}
		if (pDeviceFilter != NULL)
		{
			pDeviceFilter->IncomingRequest();
		}
	}
	else
	{
		STATUS_NO_MEMORY;
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCKF_IncomingReadRequests, Status =  0x%0.8x.\n", NtStatus));
	return NtStatus;
}

VOID __stdcall GCKF_KickDeviceForData(IN PGCK_FILTER_EXT pFilterExt)
{
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	if(pFilterHooks)
	{
		//If there is a secondary filter all commands go to it
		CDeviceFilter *pDeviceFilter = pFilterHooks->pFilterObject;
		// Do device based stuff here
		if ((pDeviceFilter != NULL) && (pDeviceFilter->GetFilterClientServices() != NULL))
		{
			// Kick the device for some data (DI should hopefully be loaded now)
			ULONG ulVidPid = pDeviceFilter->GetFilterClientServices()->GetVidPid();
			if (ulVidPid == 0x045E0033)		// Atilla (Strategic Commander, for you marketing types)
			{	// Need to send down a set blink rate feature
				UCHAR blinkRateFeatureData[] = {
					2,										// Report ID
					GCK_Atilla_Default_FastBlinkTime_On,	// Blink On
					GCK_Atilla_Default_FastBlinkTime_Off	// Blink off
				};
				pDeviceFilter->GetFilterClientServices()->DeviceSetFeature(blinkRateFeatureData, 3);
			}
		}
	}
}

NTSTATUS _stdcall GCKF_IncomingInputReports(PGCK_FILTER_EXT pFilterExt, PCHAR pcReport, IO_STATUS_BLOCK IoStatus)
{
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_IncomingInputReports, pFilterExt = 0x%0.8x, pcReport = 0x%0.8x, Information = 0x%0.8x, Status = 0x%0.8x\n",
							pFilterExt,
							pcReport,
							IoStatus.Information,
							IoStatus.Status));


	//
	// If there is an error, or there is no filter, or this is a PID report(>1) just short circuit to completing the IRPs
	//
	if( 
		NT_ERROR(IoStatus.Status) || 
		NULL==pFilterExt->pFilterHooks || 
		NULL==pFilterExt->pFilterHooks->pFilterObject ||
		GCK_HidP_GetReportID(pcReport) > 1
	)
	{
		GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_IncomingInputReports by calling GCKF_CompleteReadRequests and returning its value\n"));
		return GCKF_CompleteReadRequests(pFilterExt, pcReport, IoStatus);
	}

	//
	//	Honor requests for Raw Data
	//
	CTempIrpQueue TempIrpQueue;
	pFilterExt->pFilterHooks->IrpRawQueue.RemoveAll(&TempIrpQueue);
		
	PIRP pIrp;
	while(pIrp=TempIrpQueue.Remove())
	{
		//Copy Status
		pIrp->IoStatus = IoStatus;

		//
		//	If latest data is success, copy it to the user buffer
		//
		if( NT_SUCCESS(IoStatus.Status) )
		{
			//
			//	Make get pointer to buffer and make sure IRP has room for report
			//
			PCHAR pcIrpBuffer;
			ASSERT(pIrp->MdlAddress);
			pcIrpBuffer = (PCHAR)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
			if(pcIrpBuffer)
            {
			    ASSERT( pFilterExt->HidInfo.HidPCaps.InputReportByteLength <= MmGetMdlByteCount(pIrp->MdlAddress) );
				
			    //
			    //	Copy data to output buffer
			    //
			    RtlCopyMemory(pcIrpBuffer, (PVOID)pcReport, pIrp->IoStatus.Information);
            }
		}
		
		//
		//	Complete the IRP
		//
		GCK_DBG_RT_WARN_PRINT(("Completing read IRP(0x%0.8x).\n", pIrp));
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&pFilterExt->RemoveLock);
	}

	//
	// Send data to the filter
	//
	GCK_DBG_RT_WARN_PRINT(("Calling device filter.\n"));

	//If there is a secondary filter all commands go to it
	CDeviceFilter *pDeviceFilter;
	if(pFilterExt->pFilterHooks->pSecondaryFilter)
	{
		pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
	}
	else
	{
		pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
	}
	pDeviceFilter->ProcessInput(pcReport, IoStatus.Information);
	
	GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_IncomingInputReports STATUS_SUCCESS\n"));
	return STATUS_SUCCESS;
}

NTSTATUS _stdcall GCKF_CompleteReadRequests(PGCK_FILTER_EXT pFilterExt, PCHAR pcReport, IO_STATUS_BLOCK IoStatus)
{
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_CompleteReadRequests, pFilterExt = 0x%0.8x, pcReport = 0x%0.8x, Information = 0x%0.8x, Status = 0x%0.8x\n",
							pFilterExt,
							pcReport,
							IoStatus.Information,
							IoStatus.Status));

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	if(!pFilterHooks)
	{
		return STATUS_SUCCESS;
	}
	
	//Get all pending Irps out of the guarded queue and into a temporary one
	CTempIrpQueue TempIrpQueue;
	
	//If there is a secondary filter (test mode), we do not honor simple poll requests
	// -- but we do honor reports we don't care about (Report ID > 1)
	if (pFilterHooks->pSecondaryFilter == NULL || GCK_HidP_GetReportID(pcReport) > 1)
	{
		pFilterHooks->IrpQueue.RemoveAll(&TempIrpQueue);
	}

	//Always honor backdoor filter poll requests
	// -- unless we are getting a report we don't care about ( Report ID > 1)
	if (GCK_HidP_GetReportID(pcReport) <= 1)
	{
		pFilterHooks->IrpTestQueue.RemoveAll(&TempIrpQueue);
	}

	//walk temporary list and complete everything
	PIRP pIrp;
	while(pIrp=TempIrpQueue.Remove())
	{
		//Copy Status
		pIrp->IoStatus = IoStatus;

		//
		//	If latest data is success, copy it to the user buffer
		//
		if( NT_SUCCESS(IoStatus.Status) )
		{
			//
			//	Make get pointer to buffer and make sure IRP has room for report
			//
			PCHAR pcIrpBuffer;
			ASSERT(pIrp->MdlAddress);
			pcIrpBuffer = (PCHAR)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
			if(pcIrpBuffer)
            {
			    ASSERT( pFilterExt->HidInfo.HidPCaps.InputReportByteLength <= MmGetMdlByteCount(pIrp->MdlAddress) );
				    
			    //
			    //	Copy data to output buffer
			    //
			    RtlCopyMemory(pcIrpBuffer, (PVOID)pcReport, pIrp->IoStatus.Information);
            }
		}
		
		//
		//	Complete the IRP
		//
		GCK_DBG_RT_WARN_PRINT(("Completing read IRP(0x%0.8x).\n", pIrp));
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&pFilterExt->RemoveLock);
	}

	GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_CompleteReadRequests - STATUS_SUCCESS\n"));									
	return STATUS_SUCCESS;
}

void _stdcall GCKF_CompleteReadRequestsForFileObject(PGCK_FILTER_EXT pFilterExt, PFILE_OBJECT pFileObject)
{
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_CompleteReadRequestsForFileObject, pFilterExt = 0x%0.8x, pFileObject = 0x%0.8x\n",
							pFilterExt,
							pFileObject));

	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	ASSERT(pFilterHooks);
	
	//Cancel all the IRPs pending for the given file object
	pFilterHooks->IrpQueue.CancelByFileObject(pFileObject);

	GCK_DBG_RT_EXIT_PRINT(("Exiting GCKF_CompleteReadRequestsForFileObject\n"));
}

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_InternalWriteFileComplete(IN PGCK_FILTER_EXT pFilterExt, )
**
**	@func	Creates a Write IRP and sends to next driver
**
*************************************************************************************/
/*
NTSTATUS
GCKF_InternalWriteFileComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	IN PVOID pContext					// [NOTHING YET] Perhaps send an even for signaling
)
{
	UNREFERENCED_PARAMETER(pDeviceObject);

	DbgPrint("Calling Free IRP\n");
	IoFreeIrp(pIrp);
	DbgPrint("Deallocating Write Buffer (0x%08X)\n", pContext);
	if (pContext != NULL)
	{
		 ExFreePool(pContext);
	}

	DbgPrint("Returning Read Complete\n");

	return STATUS_MORE_PROCESSING_REQUIRED;
}
*/

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_InternalWriteFile(IN PGCK_FILTER_EXT pFilterExt, )
**
**	@func	Creates a Write IRP and sends to next driver
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_InternalWriteFile
(
	IN PGCK_FILTER_EXT pFilterExt,	//@parm [IN] Device Extension of Filter Device
	unsigned char* pWriteData,		//@parm [IN] Block of Data to write to device
	ULONG ulLength					//@parm [IN] Length of data block to write
)
{
	ASSERT((ulLength < 1024) && (ulLength > 0));	// Don't want to be allocating too much (or 0)

	NTSTATUS statusReturn = STATUS_INSUFFICIENT_RESOURCES;

	// Allocate non paged data for the IRP
	unsigned char* pNonPagedWriteData = (unsigned char*)EX_ALLOCATE_POOL(NonPagedPool, sizeof(unsigned char) * ulLength);
	if (pNonPagedWriteData != NULL)
	{
		::RtlCopyMemory((void*)pNonPagedWriteData, (const void*)pWriteData, ulLength);

		// Set up event for IRP
		KEVENT keventIrpComplete;
		::KeInitializeEvent(&keventIrpComplete, NotificationEvent, FALSE);

		// Build the IRP
		LARGE_INTEGER lgiBufferOffset;
		lgiBufferOffset.QuadPart = 0;
		IO_STATUS_BLOCK ioStatusBlock;
		IRP* pWriteIrp = IoBuildSynchronousFsdRequest(	IRP_MJ_WRITE, pFilterExt->pTopOfStack,
														pNonPagedWriteData, ulLength, &lgiBufferOffset,
														&keventIrpComplete, &ioStatusBlock);

		// Was the build succesfull
		if (pWriteIrp != NULL)
		{
			// Call the lower driver with the IRP
			statusReturn = IoCallDriver(pFilterExt->pTopOfStack, pWriteIrp);
			if (statusReturn == STATUS_PENDING)
			{
				KeWaitForSingleObject(&keventIrpComplete, Executive, KernelMode, FALSE, 0);
				statusReturn = ioStatusBlock.Status;
			}
		}
		ExFreePool(pNonPagedWriteData);
	}

	return statusReturn;
}

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_IncomingForceFeedbackChangeNotificationRequest(IN PGCK_FILTER_EXT pFilterExt, PIRP pIrp)
**
**	@func	Adds IOCTL to Force Feedback Notify On Change Queue
**			If the Queue does not exist it is created here (most devices do not need one)
**
**	@rdesc	STATUS_NO_MEMORY - If Queue could not be created
**			or return of IrpQueue->Add(...)
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_IncomingForceFeedbackChangeNotificationRequest
(
	IN PGCK_FILTER_EXT pFilterExt,		//@parm [IN] Device Extension of Filter Device
	IN PIRP pIrp						//@parm [IN] The IRP to be queued
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_IncomingForceFeedbackChangeNotificationRequest, pFilterExt = 0x%0.8x, pIrp = 0x%0.8x\n", pFilterExt, pIrp));

	// Get the FF IRP Queue for this device
	CGuardedIrpQueue* pFFNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvForceIoctlQueue);
	if(pFFNotificationQueue == NULL)	// Has it been created before
	{	// Wasn't created - Create it
		pFFNotificationQueue = new WDM_NON_PAGED_POOL CGuardedIrpQueue;
		if (pFFNotificationQueue == NULL)	// Able to create
		{	// Wasn't able to create, return low memory error
			GCK_DBG_ERROR_PRINT(("Unable to allocate Force-Feedback change notification Queue"));
			return STATUS_NO_MEMORY;
		}
		pFilterExt->pvForceIoctlQueue = (void*)pFFNotificationQueue;
		pFFNotificationQueue->Init(0, (CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock, &pFilterExt->RemoveLock);
	}

	// Add item to Queue
	NTSTATUS NtStatus = pFFNotificationQueue->Add(pIrp);

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_IncomingForceFeedbackChangeNotificationRequest, Status =  0x%0.8x.\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS _stdcall  GCKF_ProcessForceFeedbackChangeNotificationRequests(IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	Completes all IOCTLs on the Force-Feedback notification Queue
**			Doesn't delete the Queue (assumes it might be reused)
**
**	@rdesc	STATUS_SUCCESS (always)
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_ProcessForceFeedbackChangeNotificationRequests
(
	IN PGCK_FILTER_EXT pFilterExt		//@parm [IN] Device Extension of Filter Device
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_ProcessForceFeedbackChangeNotificationRequests, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Get the FF IRP Queue for this device
	CGuardedIrpQueue* pFFNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvForceIoctlQueue);
	if(pFFNotificationQueue != NULL)	// Is there even a Queue
	{	// Exists, complete the IOCTLs
		CTempIrpQueue tempIrpQueue;
		pFFNotificationQueue->RemoveAll(&tempIrpQueue);

		PIRP pIrp;
		while((pIrp = tempIrpQueue.Remove()) != NULL)
		{
			// Set status
			pIrp->IoStatus.Status = STATUS_SUCCESS;

			// Get memory location and NULL it
			void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;
			if (pvUserData != NULL)
			{
				pIrp->IoStatus.Information = sizeof(FORCE_BLOCK);
				RtlZeroMemory(pvUserData, sizeof(FORCE_BLOCK));
			}

			//	Complete the IRP
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		}
	}

	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	void _stdcall  GCKF_OnForceFeedbackChangeNotification(IN PGCK_FILTER_EXT pFilterExt, const IN FORCE_BLOCK* pForceBlock)
**
**	@func	Completes all IOCTLs on the Force-Feedback notification Queue
**			Doesn't delete the Queue (assumes it might be reused)
**
*************************************************************************************/
void _stdcall GCKF_OnForceFeedbackChangeNotification
(
	IN PGCK_FILTER_EXT pFilterExt,	//@parm [IN] Device Extension of Filter Device
	const void* pForceBlock			//@parm [IN] Block of Data to send back to device
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_ProcessForceFeedbackChangeNotificationRequests, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Did we get sent a valid force block
	if (pForceBlock == NULL)
	{
		return;
	}

	// Get the FF IRP Queue for this device
	CGuardedIrpQueue* pFFNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvForceIoctlQueue);
	if(pFFNotificationQueue != NULL)	// Is there even a Queue
	{	// Exists, complete the IOCTLs
		CTempIrpQueue tempIrpQueue;
		pFFNotificationQueue->RemoveAll(&tempIrpQueue);
			
		PIRP pIrp;
		while((pIrp = tempIrpQueue.Remove()) != NULL)
		{
			PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
			if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(FORCE_BLOCK))
			{
				void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;
				if (pvUserData != NULL)
				{
					pIrp->IoStatus.Status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = sizeof(FORCE_BLOCK);
					::RtlCopyMemory(pvUserData, pForceBlock, sizeof(FORCE_BLOCK));
				}
				else
				{
					pIrp->IoStatus.Status = STATUS_NO_MEMORY;
				}
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
			}

			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		}
	}


	// Send a modification of the spring to the wheel
	// 1. Allocate an array of max output size
	unsigned char pbOutReport[GCK_HidP_OutputReportLength];

	// 2. Zero out array
	RtlZeroMemory((void*)pbOutReport, GCK_HidP_OutputReportLength);

	// 3. Set the proper report ID
	pbOutReport[0] = GCK_PIDReportID_SetEffect;

	// 4. Cheat since we know what the firmware is expecting (Use usage Gunk where easy)
	pbOutReport[1] = GCK_PIDEffectID_Spring;		// Effect Block Index (ID)
	unsigned short usRTC = ((FORCE_BLOCK*)pForceBlock)->usRTC;		// 0 - 10K
	usRTC /= 100;									// 0 - 100
	usRTC *= 255;									// 0 - 25500
	usRTC /= 100;									// 0 - 255
	if (usRTC > 255)
	{
		usRTC = 255;
	}
	pbOutReport[9] = unsigned char(usRTC);		// Effect Gain - Only item the RTC Spring will look at

	// Now that the firmware has change for Godzilla it looks at bunches o stuff
	pbOutReport[7] = 1;  //sample period
	pbOutReport[11] =132;  //direction-axis + FW only force polar flag
	pbOutReport[13] = 255; //Y - direction

	// 5. Send the report down
	GCKF_InternalWriteFile(pFilterExt, pbOutReport, GCK_HidP_OutputReportLength);

	// Send the change for the gain

	// 1. Rezero the memory
	RtlZeroMemory((void*)pbOutReport, GCK_HidP_OutputReportLength);

	// 2. Set the proper report ID
	pbOutReport[0] = GCK_PIDReportID_SetGain;

	// 3. Figure and set the gain
	unsigned short usGain = ((FORCE_BLOCK*)pForceBlock)->usGain;	// 0 - 10K
	usGain /= 100;	// 0 - 100
	usGain *= 255;	// 0 - 25500
	usGain /= 100;	// 0 - 255
	if (usGain > 255)
	{
		usGain = 255;
	}
	pbOutReport[1] = unsigned char(usGain);

	// 4. Send the gain report down
	GCKF_InternalWriteFile(pFilterExt, pbOutReport, GCK_HidP_OutputReportLength);

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_ProcessForceFeedbackChangeNotificationRequests\n"));
}

/***********************************************************************************
**
**	NTSTAUS _stdcall  GCKF_GetForceFeedbackData(IN PIRP pIrp, IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	
**
**	@rdesc	STATUS_SUCCESS (always)
**
*************************************************************************************/
NTSTATUS _stdcall GCKF_GetForceFeedbackData
(
	IN PIRP pIrp,					//@parm [IN, OUT] The IRP (output block is stored in the IRP)
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Device Extension of Filter Device
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_GetForceFeedbackData, pFilterExt = 0x%0.8x\n", pFilterExt));

	GCK_FILTER_HOOKS_DATA* pFilterHooks=pFilterExt->pFilterHooks;

	// Find the proper device filter
	CDeviceFilter *pDeviceFilter = NULL;
	if (pFilterExt->pFilterHooks != NULL)
	{
		if (pFilterExt->pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
		}
	}

	// Get the Force Block from the filter and place it in the Proper place of the return IRP
	if (pDeviceFilter != NULL)
	{
		PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
		if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(FORCE_BLOCK))
		{
			void* pvUserData = pIrp->AssociatedIrp.SystemBuffer;
			if (pvUserData != NULL)
			{
				pIrp->IoStatus.Status = STATUS_SUCCESS;
				pIrp->IoStatus.Information = sizeof(FORCE_BLOCK);
				if (pDeviceFilter->GetForceBlock() != NULL)
				{
					::RtlCopyMemory(pvUserData, pDeviceFilter->GetForceBlock(), sizeof(FORCE_BLOCK));
				}
				else
				{
					::RtlZeroMemory(pvUserData, sizeof(FORCE_BLOCK));
				}
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_NO_MEMORY;
			}
		}
		else
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		}
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_GetForceFeedbackData, Status =  0x%0.8x.\n", pIrp->IoStatus.Status));
	return pIrp->IoStatus.Status;
}



VOID _stdcall
GCKF_TimerDPCHandler(
    IN PKDPC,
    IN PVOID DeferredContext,
    IN PVOID,
    IN PVOID
    )
{
	PGCK_FILTER_EXT pFilterExt = reinterpret_cast<PGCK_FILTER_EXT>(DeferredContext);
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	ASSERT(pFilterHooks);
	if( 
		(NULL == pFilterHooks) ||
		(NULL == pFilterHooks->pFilterObject)
	) return;
	
	//If there is a secondary filter all commands go to it
	CDeviceFilter *pDeviceFilter;
	if(pFilterExt->pFilterHooks->pSecondaryFilter)
	{
		pDeviceFilter = pFilterHooks->pSecondaryFilter;
	}
	else
	{
		pDeviceFilter = pFilterHooks->pFilterObject;
	}
	pDeviceFilter->JogActionQueue
				(
					reinterpret_cast<PCHAR>(pFilterExt->pucLastReport),
					pFilterExt->HidInfo.HidPCaps.InputReportByteLength
				);
}


NTSTATUS _stdcall	GCKF_EnableTestKeyboard
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fEnable,
	IN PFILE_OBJECT pFileObject
)
{
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;
	
	if(!pFilterHooks)
	{
		return STATUS_DELETE_PENDING;
	}

	//Only the last one to call GCKF_BeginTestScheme can update it.
	if( pFilterHooks->pTestFileObject != pFileObject )
	{
		return STATUS_ACCESS_DENIED;
	}

	CDeviceFilter *pDeviceFilter = pFilterHooks->pSecondaryFilter;
	if(pDeviceFilter)
	{
		pDeviceFilter->EnableKeyboard(fEnable);
		return STATUS_SUCCESS;
	}
	//really shouldn't get here
	ASSERT(FALSE);
	return STATUS_UNSUCCESSFUL;
}

NTSTATUS _stdcall GCKF_SetWorkingSet(
	IN PGCK_FILTER_EXT pFilterExt,	//@parm [IN] Pointer to device extention
	IN UCHAR ucWorkingSet			//@parm [IN] Working set to set to
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_SetWorkingSet, pFilterExt = 0x%0.8x  working set: %d\n", pFilterExt, ucWorkingSet));

	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

	// Find the active filter
	GCK_FILTER_HOOKS_DATA* pFilterHooks = pFilterExt->pFilterHooks;
	CDeviceFilter *pDeviceFilter = NULL;

	// Place the working set in both filters
	if (pFilterHooks != NULL)
	{
		if (pFilterHooks->pSecondaryFilter != NULL)
		{
			ntStatus = pFilterHooks->pSecondaryFilter->SetWorkingSet(ucWorkingSet);
		}
		if (pFilterHooks->pFilterObject != NULL)
		{
			ntStatus = pFilterHooks->pFilterObject->SetWorkingSet(ucWorkingSet);
		}
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_SetWorkingSet, Status =  0x%0.8x.\n", ntStatus));
	return ntStatus;
}

NTSTATUS _stdcall GCKF_QueryProfileSet
(
	IN PIRP pIrp,					//@parm [IN] Pointer to current IRP
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Pointer to device extension
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_QueryProfileSet, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Find the proper device filter
	CDeviceFilter *pDeviceFilter = NULL;
	GCK_FILTER_HOOKS_DATA* pFilterHooks = pFilterExt->pFilterHooks;
	if (pFilterHooks != NULL)
	{
		if (pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterHooks->pFilterObject;
		}
	}

	// Place data in the proper place of the return IRP
	if (pDeviceFilter != NULL)
	{
		PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
		if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(GCK_QUERY_PROFILESET))
		{
			GCK_QUERY_PROFILESET* pProfileSetData = (GCK_QUERY_PROFILESET*)(pIrp->AssociatedIrp.SystemBuffer);
			if (pProfileSetData != NULL)
			{
				pIrp->IoStatus.Status = STATUS_SUCCESS;
				pIrp->IoStatus.Information = sizeof(GCK_QUERY_PROFILESET);
				pProfileSetData->ucActiveProfile = pDeviceFilter->GetActiveSet();
//				DbgPrint("pProfileSetData->ucActiveProfile: %d\n", pProfileSetData->ucActiveProfile);
				pProfileSetData->ucWorkingSet = pDeviceFilter->GetWorkingSet();
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_NO_MEMORY;
			}
		}
		else
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		}
	}
	else
	{
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_QueryProfileSet, Status =  0x%0.8x.\n", (pIrp->IoStatus.Status)));
	return (pIrp->IoStatus.Status);
}

NTSTATUS _stdcall GCKF_SetLEDBehaviour
(
	IN PIRP pIrp,					//@parm [IN] Pointer to current IRP
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Pointer to device extension
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_SetLEDBehaviour, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Find the proper device filter
	CDeviceFilter *pDeviceFilter = NULL;
	GCK_FILTER_HOOKS_DATA* pFilterHooks = pFilterExt->pFilterHooks;
	if (pFilterHooks != NULL)
	{
		if (pFilterHooks->pSecondaryFilter)
		{
			pDeviceFilter = pFilterHooks->pSecondaryFilter;
		}
		else
		{
			pDeviceFilter = pFilterHooks->pFilterObject;
		}
	}

	if (pDeviceFilter != NULL)
	{
		// Send the Data to the device
		GCK_LED_BEHAVIOUR_OUT* pLEDBehaviour = (GCK_LED_BEHAVIOUR_OUT*)(pIrp->AssociatedIrp.SystemBuffer);
		pDeviceFilter->SetLEDBehaviour(pLEDBehaviour);

		// Retreive the information from the device
		PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
		if (pIrpStack && pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(GCK_LED_BEHAVIOUR_IN))
		{
			GCK_LED_BEHAVIOUR_IN* pLEDStates = (GCK_LED_BEHAVIOUR_IN*)(pIrp->AssociatedIrp.SystemBuffer);
			if (pLEDStates != NULL)
			{
				pIrp->IoStatus.Status = STATUS_SUCCESS;
				pIrp->IoStatus.Information = sizeof(GCK_QUERY_PROFILESET);
				pLEDStates->ulLEDsOn = 0x02;
				pLEDStates->ulLEDsBlinking = 0x01;
			}
			else
			{
				pIrp->IoStatus.Status = STATUS_NO_MEMORY;
			}
		}
		else
		{
			pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		}
	}
	else
	{
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_SetLEDBehaviour, Status =  0x%0.8x.\n", (pIrp->IoStatus.Status)));
	return (pIrp->IoStatus.Status);
}

NTSTATUS _stdcall GCKF_TriggerRequest
(
	IN PIRP pIrp,					//@parm [IN] Pointer to current IRP
	IN PGCK_FILTER_EXT pFilterExt	//@parm [IN] Pointer to device extension
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCKF_TriggerRequest, pFilterExt = 0x%0.8x\n", pFilterExt));

	// Find the proper active device filter
	CDeviceFilter *pDeviceFilter = NULL;
	if (pFilterExt != NULL)
	{
		if (pFilterExt->pFilterHooks != NULL)
		{
			if (pFilterExt->pFilterHooks->pSecondaryFilter)
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
			}
			else
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
			}
		}
	}
	if (pDeviceFilter != NULL)
	{
		if (pDeviceFilter->TriggerRequest(pIrp) == TRUE)	// We need to Queue it
		{
			CGuardedIrpQueue* pTriggerNotificationQueue = (CGuardedIrpQueue*)(pFilterExt->pvTriggerIoctlQueue);
			if (pTriggerNotificationQueue == NULL)		// Hasn't yet been created
			{	// So create it
				pTriggerNotificationQueue = new WDM_NON_PAGED_POOL CGuardedIrpQueue;
				if (pTriggerNotificationQueue == NULL)	// Were we able to create
				{	// Wasn't able to create, return low memory error
					GCK_DBG_ERROR_PRINT(("Unable to allocate Trigger notification Queue"));
					pIrp->IoStatus.Status = STATUS_NO_MEMORY;
				}
				else		// Successfully created, initialize
				{
					pFilterExt->pvTriggerIoctlQueue = (void*)pTriggerNotificationQueue;
					pTriggerNotificationQueue->Init(0, (CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock, &pFilterExt->RemoveLock);
				}
			}
			if (pTriggerNotificationQueue != NULL)
			{
				pIrp->IoStatus.Status = pTriggerNotificationQueue->Add(pIrp);
			}
		}
	}
	else
	{
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCKF_TriggerRequest, Status =  0x%0.8x.\n", (pIrp->IoStatus.Status)));
	return (pIrp->IoStatus.Status);
}

void _stdcall GCKF_ResetKeyboardQueue
(
	DEVICE_OBJECT* pFilterHandle	//@parm [IN] Pointer to Device Extension
)
{
	if (pFilterHandle == NULL)
	{
		return;
	}

	PGCK_FILTER_EXT pFilterExt = (PGCK_FILTER_EXT)(pFilterHandle->DeviceExtension);
	if (pFilterExt != NULL)
	{
		// Find the proper active device filter
		CDeviceFilter *pDeviceFilter = NULL;
		if (pFilterExt->pFilterHooks != NULL)
		{
			if (pFilterExt->pFilterHooks->pSecondaryFilter)
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pSecondaryFilter;
			}
			else
			{
				pDeviceFilter = pFilterExt->pFilterHooks->pFilterObject;
			}
		}
		if (pDeviceFilter != NULL)
		{
			((CFilterGcKernelServices*)pDeviceFilter->GetFilterClientServices())->KeyboardQueueClear();
		}
	}
}

CFilterGcKernelServices::~CFilterGcKernelServices()
{
	if(m_pMousePDO)
	{
		PDEVICE_OBJECT pTemp = m_pMousePDO;
		m_pMousePDO = NULL;
		GCK_VMOU_Close(pTemp);
	}
}

ULONG CFilterGcKernelServices::GetVidPid()
{
	//BUGBUG The fact that one can get the VendorID and ProductID
	//BUGBUG from the HIDP_COLLECTION_INFO structure is not documented in the
	//BUGBUG DDK, I found this out by reading hid.dll code!  I know of no
	//BUGBUG documented way to get this info in kernel mode, so I use it anyway.
	ULONG ulVidPid = m_pFilterExt->HidInfo.HidCollectionInfo.VendorID;
	ulVidPid = (ulVidPid << 16) +  m_pFilterExt->HidInfo.HidCollectionInfo.ProductID;
	return ulVidPid;
}

PHIDP_PREPARSED_DATA CFilterGcKernelServices::GetHidPreparsedData()
{
	return m_pFilterExt->HidInfo.pHIDPPreparsedData;
}

void CFilterGcKernelServices::DeviceDataOut(PCHAR pcReport, ULONG ulByteCount, HRESULT hr)
{
	IO_STATUS_BLOCK IoStatus;
	IoStatus.Information = ulByteCount;
	IoStatus.Status = hr & ~FACILITY_NT_BIT;  //This reverses HRESULT_FROM_NT()
	GCKF_CompleteReadRequests(m_pFilterExt, pcReport, IoStatus);
}

NTSTATUS DeviceSetFeatureComplete(PDEVICE_OBJECT pDeviceObject, PIRP pIrp, PVOID pvContext)
{
	UNREFERENCED_PARAMETER(pvContext);
	UNREFERENCED_PARAMETER(pDeviceObject);

	// We did it all, we clean it all up. Nothing to return, no one waits on this one
	delete[] pIrp->AssociatedIrp.SystemBuffer;
	pIrp->AssociatedIrp.SystemBuffer = NULL;
	delete[] pIrp->UserIosb;
	pIrp->UserIosb = NULL;
	IoFreeIrp(pIrp);

	// Important! Or else system will try to free it and remove it from lists where it is not!
	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS CFilterGcKernelServices::DeviceSetFeature(PVOID pvBuffer, ULONG ulByteCount)
{
	
	ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

	if ((m_pFilterExt == NULL) || (m_pFilterExt->InternalPoll.pInternalFileObject == NULL))
	{
		return STATUS_DEVICE_NOT_READY;		// Actually it is the driver that isn't ready
	}

	PIRP pIrp = IoAllocateIrp(m_pFilterExt->pPDO->StackSize, FALSE);
	if (pIrp == NULL)
	{
		return STATUS_NO_MEMORY;
	}


	pIrp->Flags = IRP_BUFFERED_IO;
	pIrp->RequestorMode = KernelMode;
	pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
	pIrp->AssociatedIrp.SystemBuffer = new WDM_NON_PAGED_POOL UCHAR[ulByteCount];
	if (pIrp->AssociatedIrp.SystemBuffer == NULL)
	{
		IoFreeIrp(pIrp);
		return STATUS_NO_MEMORY;
	}
	::RtlCopyMemory((void*)(pIrp->AssociatedIrp.SystemBuffer), pvBuffer, ulByteCount);
	pIrp->UserIosb = (IO_STATUS_BLOCK*)(new WDM_NON_PAGED_POOL UCHAR[sizeof(IO_STATUS_BLOCK)]);
	if (pIrp->UserIosb == NULL)
	{
		delete[] pIrp->AssociatedIrp.SystemBuffer;
		pIrp->AssociatedIrp.SystemBuffer = NULL;
		IoFreeIrp(pIrp);
		return STATUS_NO_MEMORY;
	}
	::RtlZeroMemory((void*)(pIrp->UserIosb), sizeof(IO_STATUS_BLOCK));

	PIO_STACK_LOCATION pIoStackLocation = IoGetNextIrpStackLocation(pIrp);
	pIoStackLocation->DeviceObject = NULL; // m_pFilterExt->pTopOfStack;
	pIoStackLocation->FileObject = m_pFilterExt->InternalPoll.pInternalFileObject;
	pIoStackLocation->MajorFunction = IRP_MJ_DEVICE_CONTROL;
	pIoStackLocation->MinorFunction = 0;
	pIoStackLocation->Flags = 0;
	pIoStackLocation->Parameters.DeviceIoControl.OutputBufferLength = 0;
	pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength = ulByteCount;
	pIoStackLocation->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_SET_FEATURE;
	pIoStackLocation->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

	IoSetCompletionRoutine(pIrp, DeviceSetFeatureComplete, 0, TRUE, TRUE, TRUE);

/*
	IO_STATUS_BLOCK	IoStatus;
	KEVENT			CompletionEvent;
	KeInitializeEvent(&CompletionEvent, NotificationEvent, FALSE);
	// Create IRP
	PIRP pIrp = IoBuildDeviceIoControlRequest(
				IOCTL_HID_SET_FEATURE,
				m_pFilterExt->pTopOfStack,
				pvBuffer,
				ulByteCount,
				NULL,
				0,
				FALSE,
				&CompletionEvent,
				&IoStatus
				);
	if(!pIrp)
	{
		return STATUS_NO_MEMORY;
	}

	//Stamp with Internal Poll's file object
	PIO_STACK_LOCATION pIrpStack = IoGetNextIrpStackLocation(pIrp);
	pIrpStack->FileObject = m_pFilterExt->InternalPoll.pInternalFileObject;
	if(!pIrpStack->FileObject)
	{
		return STATUS_UNSUCCESSFUL;
	}
*/

	NTSTATUS NtStatus = IoCallDriver(m_pFilterExt->pTopOfStack, pIrp);
/*
	if( STATUS_PENDING == NtStatus )
	{
		NtStatus = KeWaitForSingleObject( &CompletionEvent, Executive, KernelMode, FALSE, NULL);
		if(NT_SUCCESS(NtStatus))
		{
			NtStatus = IoStatus.Status;
		}
	}
*/

	return NtStatus;
}

ULONG CFilterGcKernelServices::GetTimeMs()
{
	LARGE_INTEGER lgiDelayTime;
	KeQuerySystemTime(&lgiDelayTime);
	lgiDelayTime.QuadPart /= 10*1000;	// Convert to milliseconds
	return lgiDelayTime.LowPart;		// Most significant part doesn't matter
}

void CFilterGcKernelServices::SetNextJog(ULONG ulDelayMs)
{
	if( ulDelayMs > 1000000) return;
	LARGE_INTEGER lgiDelayTime;
	lgiDelayTime.QuadPart=(__int64)-10000*(__int64)ulDelayMs;
	KeSetTimer(&m_pFilterExt->pFilterHooks->Timer, lgiDelayTime,& m_pFilterExt->pFilterHooks->DPC);
}

NTSTATUS CFilterGcKernelServices::PlayFromQueue(IRP* pIrp)
{
	// Get the output buffer
	ASSERT(pIrp->MdlAddress);
	CONTROL_ITEM_XFER* pKeyboardOutputBuffer = (CONTROL_ITEM_XFER*)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
	if(pKeyboardOutputBuffer)
    {

	    // Are there any items on the Queue
	    if (m_rgXfersWaiting[m_sKeyboardQueueHead].ulItemIndex != NonGameDeviceXfer::ulKeyboardIndex)
	    {
		    return STATUS_PENDING;	// No more waiting items
	    }
		    
	    // Copy the queued XFER into the out packet
	    ::RtlCopyMemory((void*)pKeyboardOutputBuffer, (const void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));

	    // Update the Queue
	    ::RtlZeroMemory((void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));
	    m_sKeyboardQueueHead++;
	    if (m_sKeyboardQueueHead >= 5)
	    {
		    m_sKeyboardQueueHead = 0;
	    }
    }

	// Complete the IRP
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = sizeof(CONTROL_ITEM_XFER);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	GCK_DecRemoveLock(&m_pFilterExt->RemoveLock);

	return TRUE;
}

void CFilterGcKernelServices::PlayKeys(const CONTROL_ITEM_XFER& crcixState, BOOLEAN fEnabled)
{
	NTSTATUS NtSuccess;

	// Add it to the queue of waiting XFers
	::RtlCopyMemory((void*)(m_rgXfersWaiting+m_sKeyboardQueueTail), (const void*)(&crcixState), sizeof(CONTROL_ITEM_XFER));
	m_sKeyboardQueueTail++;
	if (m_sKeyboardQueueTail >= 5)
	{
		m_sKeyboardQueueTail = 0;
	}

	// Complete any Queued keyboard IRPS
	CTempIrpQueue TempIrpQueue;
	PIRP pIrp;
	m_pFilterExt->pFilterHooks->IrpKeyboardQueue.RemoveAll(&TempIrpQueue);
	BOOLEAN wasSent = FALSE;
	while(pIrp = TempIrpQueue.Remove())
	{
		wasSent = TRUE;

		// Get the output buffer
		ASSERT(pIrp->MdlAddress);
		CONTROL_ITEM_XFER* pKeyboardOutputBuffer = (CONTROL_ITEM_XFER*)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
		if(pKeyboardOutputBuffer)
        {
		
		    // Copy the local report packet into the out packet
    //		::RtlCopyMemory((void*)pKeyboardOutputBuffer, (const void*)(&crcixState), sizeof(CONTROL_ITEM_XFER));
		    // Copy the queued XFER into the out packet
		    ::RtlCopyMemory((void*)pKeyboardOutputBuffer, (const void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));
        }

		// Complete the IRP
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		pIrp->IoStatus.Information = sizeof(CONTROL_ITEM_XFER);
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&m_pFilterExt->RemoveLock);

	}

	if (wasSent || fEnabled)
	{
		// Update the Queue
		::RtlZeroMemory((void*)(m_rgXfersWaiting+m_sKeyboardQueueHead), sizeof(CONTROL_ITEM_XFER));
		m_sKeyboardQueueHead++;
		if (m_sKeyboardQueueHead >= 5)
		{
			m_sKeyboardQueueHead = 0;
		}
	}

	// Don't bother going on if the keyboard is not enabled
	if (fEnabled == FALSE)
	{
		return;
	}

	//Don't try sending if we haven't got a virtual keyboard
	if(NULL == Globals.pVirtualKeyboardPdo)
	{
		ASSERT(FALSE);
		return;
	}
	
	//Copy info to a report packet
	GCK_VKBD_REPORT_PACKET ReportPacket;
	ReportPacket.ucModifierByte = crcixState.Keyboard.ucModifierByte;
	for(ULONG ulIndex=0; ulIndex < 6; ulIndex++)
	{
		ReportPacket.rgucUsageIndex[ulIndex] = crcixState.Keyboard.rgucKeysDown[ulIndex];
	}

	//Send the report packet
	NtSuccess = GCK_VKBD_SendReportPacket(Globals.pVirtualKeyboardPdo, &ReportPacket);
	ASSERT( NT_SUCCESS(NtSuccess) );
}

HRESULT	CFilterGcKernelServices::CreateMouse()
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	if(m_fHasVMouse && !m_pMousePDO)
	{
		NtStatus = GCK_VMOU_Create(&m_pMousePDO);
	}
	return HRESULT_FROM_NT(NtStatus);
}

HRESULT	CFilterGcKernelServices::CloseMouse()
{
	if(m_fHasVMouse && m_pMousePDO)
	{
		PDEVICE_OBJECT pTemp = m_pMousePDO;
		m_pMousePDO = NULL;
		GCK_VMOU_Close(pTemp);
	}
	return S_OK;
}

HRESULT	CFilterGcKernelServices::SendMouseData(UCHAR dx, UCHAR dy, UCHAR ucButtons, CHAR /*cWheel*/, BOOLEAN fClutch, BOOLEAN fDampen)
{
	
	//if there are backdoor requests pending for mouse data, satisfy them
	CTempIrpQueue TempIrpQueue;
	PIRP pIrp;
	m_pFilterExt->pFilterHooks->IrpMouseQueue.RemoveAll(&TempIrpQueue);
	while(pIrp = TempIrpQueue.Remove())
	{
		//
		//	Make get pointer to buffer and make sure IRP has room for report
		//
		PGCK_MOUSE_OUTPUT pMouseOutputBuffer;
		ASSERT(pIrp->MdlAddress);
		pMouseOutputBuffer = (PGCK_MOUSE_OUTPUT)GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
		if(pMouseOutputBuffer)
        {
		
		    //
		    //	Copy data to output buffer
		    //
		    pMouseOutputBuffer->cXMickeys = (char)dx;
		    pMouseOutputBuffer->cYMickeys = (char)dy;
		    pMouseOutputBuffer->cButtons = (char)ucButtons;
		    pMouseOutputBuffer->fDampen = fDampen;
		    pMouseOutputBuffer->fClutch = fClutch;
        }
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		pIrp->IoStatus.Information = sizeof(GCK_MOUSE_OUTPUT);
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		GCK_DecRemoveLock(&m_pFilterExt->RemoveLock);
	}
	
	if(!m_fHasVMouse)
	{
		return S_OK;
	}
	if(!m_pMousePDO)
	{
		ASSERT(FALSE && "No Virtual Mouse to send data to");
		return HRESULT_FROM_WIN32(ERROR_NOT_READY);
	}

	GCK_VMOU_REPORT_PACKET MouseReport;
	NTSTATUS NtStatus;
	MouseReport.ucButtons = ucButtons;
	MouseReport.ucDeltaX = dx;
	MouseReport.ucDeltaY = dy;
	
	//MouseReport.cWheel = cWheel;
	NtStatus = GCK_VMOU_SendReportPacket(m_pMousePDO, &MouseReport);

	return HRESULT_FROM_NT(NtStatus);
}

void CFilterGcKernelServices::KeyboardQueueClear()
{
	// Update the Queue
	::RtlZeroMemory((void*)(m_rgXfersWaiting), sizeof(CONTROL_ITEM_XFER) * 5);
	m_sKeyboardQueueHead = 0;
	m_sKeyboardQueueTail = 0;
}


NTSTATUS _stdcall
GCKF_BackdoorPoll(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp,
	IN GCK_POLLING_MODES ePollingMode
	)
{
	NTSTATUS NtStatus;
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCKF_BackdoorPoll(pFilterExt = 0x%0.8x, pIrp = 0x%0.8x, ePollingMode = %d\n", pFilterExt, pIrp, ePollingMode));
	GCK_FILTER_HOOKS_DATA *pFilterHooks=pFilterExt->pFilterHooks;

	// Count IRP
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);
	
	if(pFilterHooks)
	{
		ASSERT(pIrp->MdlAddress);
		if(pIrp->MdlAddress)
		{
			if ((ePollingMode == GCK_POLLING_MODE_RAW) || (ePollingMode == GCK_POLLING_MODE_FILTERED))
			{
				//If there is a secondary filter all commands go to it
				CDeviceFilter *pDeviceFilter;
				if (pFilterHooks->pSecondaryFilter)
				{
					pDeviceFilter = pFilterHooks->pSecondaryFilter;
				}
				else
				{
					pDeviceFilter = pFilterHooks->pFilterObject;
				}
				if (pDeviceFilter != NULL)
				{
					pDeviceFilter->IncomingRequest();
				}
			}

			if(GCK_POLLING_MODE_RAW == ePollingMode)
			{
				NtStatus = pFilterHooks->IrpRawQueue.Add(pIrp);

				GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(1), Status =  0x%0.8x.\n", NtStatus));
				return NtStatus;
			}
			else if(GCK_POLLING_MODE_MOUSE == ePollingMode)
			{
				if( sizeof(GCK_MOUSE_OUTPUT) > MmGetMdlByteCount(pIrp->MdlAddress) )
				{
					NtStatus = STATUS_BUFFER_TOO_SMALL;
				}
				else
				{
					NtStatus = pFilterHooks->IrpMouseQueue.Add(pIrp);
					GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(MOUSE), Status =  0x%0.8x.\n", NtStatus));
					return NtStatus;
				}
			}
			else if (GCK_POLLING_MODE_KEYBOARD == ePollingMode)
			{
				if( sizeof(CONTROL_ITEM_XFER) > MmGetMdlByteCount(pIrp->MdlAddress) )
				{
					NtStatus = STATUS_BUFFER_TOO_SMALL;
				}
				else
				{
					if (pFilterHooks->pSecondaryFilter)
					{
						NtStatus = (pFilterHooks->pSecondaryFilter->ProcessKeyboardIrp(pIrp));
						if (NtStatus != STATUS_PENDING)
						{
							return NtStatus;
						}
					}
					NtStatus = pFilterHooks->IrpKeyboardQueue.Add(pIrp);
					GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(KEYBOARD), Status =  0x%0.8x.\n", NtStatus));
					return NtStatus;
				}
			}
			else
			{
				NtStatus = pFilterHooks->IrpTestQueue.Add(pIrp);
				GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(OTHER), Status =  0x%0.8x.\n", NtStatus));
				return NtStatus;
			}
		}
		else
		{
			NtStatus = STATUS_BUFFER_TOO_SMALL;
		}
	}
	else
	{
		NtStatus = STATUS_UNSUCCESSFUL;
	}
	pIrp->IoStatus.Status = NtStatus;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_RT_ENTRY_PRINT(("Exiting GCKF_BackdoorPoll(2), Status =  0x%0.8x.\n", NtStatus));
	return NtStatus;
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckcritsec.h ===
//	@doc
/**********************************************************************
*
*	@module	GckCritSec	|
*
*	Implementation of CGckCritSection
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	filter	|
*	CGckCritSection	provides mutex/critical section support for CDeviceFilter
*	it is abstracted into this class for easier porting to USER mode.
*
*	CGckMutexHandle is used to hold the mutex that is held during a critical section.
*	The kernel mode version uses critical section.
*
**********************************************************************/
#ifndef __GckCritSec_h__
#define __GckCritSec_h__


#ifdef COMPILE_FOR_WDM_KERNEL_MODE
//
//	The kernel mode version of these classes
//
class CGckMutexHandle
{
	public:
		friend class CGckCritSection;
		friend class CGckMutex;
		CGckMutexHandle()
		{
			KeInitializeSpinLock(&m_SpinLock);
		}
	private:
		KSPIN_LOCK	m_SpinLock;
};

class CGckCritSection
{
	public:
		CGckCritSection(CGckMutexHandle *pMutexHandle):
			m_pMutexHandle(pMutexHandle)
		{
			KeAcquireSpinLock(&m_pMutexHandle->m_SpinLock, &m_OldIrql);
		}
		~CGckCritSection()
		{
			KeReleaseSpinLock(&m_pMutexHandle->m_SpinLock, m_OldIrql);
		}
	private:
		CGckMutexHandle *m_pMutexHandle;
		KIRQL m_OldIrql;
};
#endif

//
//	Place USER mode definitions here. (protecting with #ifdef of course).
//


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\filterhooks.h ===
#ifndef __filterhooks_h__
#define __filterhooks_h__

#include "IrpQueue.h"

struct GCK_FILTER_HOOKS_DATA
{
	CGuardedIrpQueue	IrpQueue;			// @field Queue for Read Irps
	CGuardedIrpQueue	IrpTestQueue;		// @field Queue for Unapplied Change polls
	CGuardedIrpQueue	IrpRawQueue;		// @field Queue for Raw Data polls
	CGuardedIrpQueue	IrpMouseQueue;		// @field Queue for Backdoor Mouse Data polls
	CGuardedIrpQueue	IrpKeyboardQueue;	// @field Queue for Backdoor Keyboard Data polls
	CDeviceFilter		*pFilterObject;		// @field Primary Filter
	CDeviceFilter		*pSecondaryFilter;	// @field Backdoor(unapplied changes) Filter
	FILE_OBJECT			*pTestFileObject;	// @field Pointer to file object which "owns" test mode.
	KTIMER				Timer;				// @field timer object for jogging CDeviceFilter
	KDPC				DPC;				// @field DPC for jogging CDeviceFilter
};
	
class CFilterGcKernelServices : public CFilterClientServices
{
	public:
		CFilterGcKernelServices(PGCK_FILTER_EXT pFilterExt, BOOLEAN fHasVMouse = TRUE) : 
		  m_pFilterExt(pFilterExt), m_pMousePDO(NULL), m_fHasVMouse(fHasVMouse),
		  m_sKeyboardQueueHead(0), m_sKeyboardQueueTail(0)
		  {
			  ::RtlZeroMemory(m_rgXfersWaiting, sizeof(CONTROL_ITEM_XFER) * 5);
		  }
		virtual ~CFilterGcKernelServices();
		virtual ULONG				 GetVidPid();
		virtual PHIDP_PREPARSED_DATA GetHidPreparsedData();
		virtual void				 DeviceDataOut(PCHAR pcReport, ULONG ulByteCount, HRESULT hr);
		virtual NTSTATUS			 DeviceSetFeature(PVOID pvBuffer, ULONG ulByteCount);
		virtual ULONG				 GetTimeMs();
		virtual void				 SetNextJog(ULONG ulDelayMs);
		virtual void				 PlayKeys(const CONTROL_ITEM_XFER& crcixState, BOOLEAN fEnabled);
		virtual NTSTATUS			 PlayFromQueue(IRP* pIrp);
		virtual HRESULT				 CreateMouse();
		virtual HRESULT				 CloseMouse();
		virtual HRESULT				 SendMouseData(UCHAR dx, UCHAR dy, UCHAR ucButtons, CHAR cWheel, BOOLEAN fClutch, BOOLEAN fDampen);

		void KeyboardQueueClear();

		PGCK_FILTER_EXT GetFilterExtension() const { return m_pFilterExt; }
	private:
		PGCK_FILTER_EXT m_pFilterExt;
		PDEVICE_OBJECT	m_pMousePDO;
		BOOLEAN			m_fHasVMouse;
		short int		m_sKeyboardQueueHead;
		short int		m_sKeyboardQueueTail;

		CONTROL_ITEM_XFER m_rgXfersWaiting[5];
};


#endif //__filterhooks_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\fltr_pnp.cpp ===
//	@doc
/**********************************************************************
*
*	@module	FLTR_PNP.C	|
*
*	Implementation of PnP and Power IRP handlers for Filter Device
*	Objects.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	PNP	|
*	Power, Start, Stop, Remove Handlers.  Shell like functionality
*	only.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FLTR_PNP_C
extern "C"
{
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	//DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL) );
	DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL) );
}
#include "SWVBENUM.h"




//---------------------------------------------------------------------------
// Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, GCK_FLTR_Power)
#pragma alloc_text (PAGE, GCK_FLTR_AddDevice)
#pragma alloc_text (PAGE, GCK_FLTR_PnP)
#pragma alloc_text (PAGE, GCK_FLTR_StartDevice)
#pragma alloc_text (PAGE, GCK_FLTR_StopDevice)
#pragma alloc_text (PAGE, GCK_GetHidInformation)
#pragma alloc_text (PAGE, GCK_CleanHidInformation)
#endif

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Power (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_POWER for Filter Device Objects
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;

    PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_Power. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	pFilterExt = (PGCK_FILTER_EXT)pDeviceObject->DeviceExtension;
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

    // If we have been removed we need to refuse this IRP
	if (GCK_STATE_REMOVED == pFilterExt->eDeviceState) {
        
		GCK_DBG_TRACE_PRINT(("GCK_Power called while delete pending\n"));
				
		//Fill in IO_STATUS_BLOCK with failure
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
		
		// Tell system that we are ready for another power IRP
		PoStartNextPowerIrp(pIrp);

		//Complete IRP with failure
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }
	else //Pass it down to next driver
	{
       
		GCK_DBG_TRACE_PRINT(("Sending Power IRP down to next driver\n"));
		
		//	Tell system we are ready for the next power IRP
        PoStartNextPowerIrp (pIrp);
		        
        // NOTE!!! PoCallDriver NOT IoCallDriver.
		IoSkipCurrentIrpStackLocation (pIrp);
        NtStatus =  PoCallDriver (pFilterExt->pTopOfStack, pIrp);
    }

	//	Decrement outstanding IRP count, and signal if it want to zero
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_Power. Status: 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPhysicalDeviceObject)
**
**	@func	Handles AddDevice calls from PnP system, create filter device and
**			attach to top of stack.  Note this is a direct entry, as control, and SWVB
**			have not this function and it is a good thing too, as we would have little
**			idea of what to Add.
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_AddDevice
(
	IN PDRIVER_OBJECT pDriverObject,			// @parm Driver object to create filter device for
	IN PDEVICE_OBJECT pPhysicalDeviceObject		// @parm PDO for device to create
)
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          pDeviceObject = NULL;
	PGCK_FILTER_EXT			pFilterExt = NULL;
    
    PAGED_CODE ();
    GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_AddDevice, pDriverObject = 0x%0.8x, pPDO = 0x%0.8x\n", pDriverObject, pPhysicalDeviceObject));

	//
	//	If there is not a Global Control Device create one
	//	(The global control object is for programming the filter.  When the
	//	first filter device is created, we create one.  When the last filter
	//	device is removed, we remove it.)
	//
	if(!Globals.pControlObject)
	{
		GCK_CTRL_AddDevice( pDriverObject );
	}

	    
	//
    // Create a filter device object.
    //
	GCK_DBG_TRACE_PRINT(("Creating Filter Device\n"));
    NtStatus = IoCreateDevice (pDriverObject,
                             sizeof (GCK_FILTER_EXT),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &pDeviceObject);

    if (!NT_SUCCESS (NtStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
		GCK_DBG_CRITICAL_PRINT(("Failed to create filter device object\n"));
		GCK_DBG_EXIT_PRINT(("Exiting AddDevice(1) Status: 0x%0.8x\n", NtStatus));
        return NtStatus;
    }

    //
    // Initialize the the device extension.
    //
	GCK_DBG_TRACE_PRINT(("Initializing Filter's Device Extension\n"));
	pFilterExt = (PGCK_FILTER_EXT)pDeviceObject->DeviceExtension; //Get pointer to extension
	pFilterExt->ulGckDevObjType = GCK_DO_TYPE_FILTER;	//Put our name on this, so we can speak for it later
	pFilterExt->eDeviceState = GCK_STATE_STOPPED;	//Device starts out stopped
	pFilterExt->pPDO	 = pPhysicalDeviceObject;	//Remember our PDO
	pFilterExt->pTopOfStack = NULL;					//We are not attached to stack yet
	GCK_InitRemoveLock(&pFilterExt->RemoveLock, "Filter PnP");	//Initialize Remove Lock
	pFilterExt->pvForceIoctlQueue = NULL;	// There is no Queue unless force requests come in
	pFilterExt->pvTriggerIoctlQueue = NULL;	// There is no Queue unless trigger requests come in

	// !!!!!! Need to clean up the above Queues

	//we use the same IO method as hidclass.sys, which DO_DIRECT_IO
	pDeviceObject->StackSize = pPhysicalDeviceObject->StackSize + 1;
	pDeviceObject->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    GCK_DBG_TRACE_PRINT(("FDO flags set to %x\n", pDeviceObject->Flags));
    

    //
	// Add new Device Object to List of Objects
	//
	GCK_DBG_TRACE_PRINT(("Adding new filter device object to global linked list\n"));
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	//Add item to head as it is fastest place to add
	pFilterExt->pNextFilterObject=Globals.pFilterObjectList;
	Globals.pFilterObjectList = pDeviceObject;	//Add the whole object not just the extension
	Globals.ulFilteredDeviceCount++;			//Increment count of filtered devices
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);

	//
	//	Make sure the internal POLL is ready for open and close
	//
	GCK_IP_AddDevice(pFilterExt);

	//
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
	GCK_DBG_TRACE_PRINT(("Attaching to top of device stack\n"));
    pFilterExt->pTopOfStack = IoAttachDeviceToDeviceStack (pDeviceObject, pPhysicalDeviceObject);
    
	//
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    //
    ASSERT (NULL != pFilterExt->pTopOfStack);
	GCK_DBG_TRACE_PRINT(( "pTopOfStack = 0x%0.8x", pFilterExt->pTopOfStack ));

	//
	//	Assure that the Virtual Bus has a Device Object to sit on.
	//	To fix bug 1018, which would also have other implications, this is moved to start device
	//	to start device
	//
	//if( !Globals.pSWVB_FilterExt )
	//{
	//	Globals.pSWVB_FilterExt = pFilterExt;
	//	NtStatus = GCK_SWVB_SetBusDOs(pDeviceObject, pPhysicalDeviceObject);
	//	//At this point GCK_SWVB_SetBusDOs only returns STATUS_SUCCESS, it should return void
	//	ASSERT( STATUS_SUCCESS == NtStatus); 
	//}

	GCK_DBG_EXIT_PRINT(("Exiting AddDevice(2) Status: STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_PnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PNP for Filter Devices, dispatchs
**			IRPs for Control Devices or Virtual Devices elsewhere.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		*ppPrevDeviceObjectPtr;
	PDEVICE_OBJECT		pCurDeviceObject;
	//PGCK_FILTER_EXT		pCurFilterExt;
	BOOLEAN				fRemovedFromList;
	BOOLEAN				fFoundOne;

    PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_PnP. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));	
	
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	// Just an extra sanity check - before accessing extension
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);

	//Increment Remove Lock while handling this IRP
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

    //
	// If we have been removed we need to refuse this IRP, this should
	// never happen with PnP IRPs
	//
	if (GCK_STATE_REMOVED == pFilterExt->eDeviceState) {
		GCK_DBG_TRACE_PRINT(("GCK_FLTR_PnP called while delete pending\n"));
		ASSERT(FALSE);
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }
	else // we need to handle it
	{
		
		switch (pIrpStack->MinorFunction) {

			case IRP_MN_CANCEL_STOP_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_STOP_DEVICE - Fall through to IRP_MN_START_DEVICE\n"));
				ASSERT(GCK_STATE_STOP_PENDING == pFilterExt->eDeviceState);
				pFilterExt->eDeviceState = GCK_STATE_STARTED;
			case IRP_MN_CANCEL_REMOVE_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_REMOVE_DEVICE - Fall through to IRP_MN_START_DEVICE\n"));
			case IRP_MN_START_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_START_DEVICE\n"));
				
				// The device is starting. Lower level drivers need to start first
				IoCopyCurrentIrpStackLocationToNext (pIrp);
				KeInitializeEvent(&pFilterExt->StartEvent, NotificationEvent, FALSE);
				
				//	Set Completion routine to signal when done
				IoSetCompletionRoutine (
					pIrp,
					GCK_FLTR_PnPComplete,
					pFilterExt,
					TRUE,
					TRUE,
					TRUE
					);

				//	Send down the IRP
				GCK_DBG_TRACE_PRINT(("Calling lower driver\n"));        
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

				//	Wait for it to complete
				if (STATUS_PENDING == NtStatus)
				{
					KeWaitForSingleObject(
						&pFilterExt->StartEvent,	// waiting for Completion of Start
						Executive,					// Waiting for reason of a driver
						KernelMode,					// Waiting in kernel mode
						FALSE,						// No alert
						NULL						// No timeout
						);
				}

				// Remember the status of the lower driver
				NtStatus = pIrp->IoStatus.Status;

				//In the case of a cancel stop, the lower driver may not support it.
				//we still need to restart
				if(NT_SUCCESS (NtStatus) || STATUS_NOT_SUPPORTED==NtStatus)
				{
					//
					// As we are successfully now back from lower driver
					// our start device can do work.
					//
					NtStatus = GCK_FLTR_StartDevice (pDeviceObject, pIrp);
				}

		        //
				// We must now complete the IRP, since we stopped it in the
				// completetion routine with MORE_PROCESSING_REQUIRED.
				//
				if (!NT_SUCCESS (NtStatus))
				{
					if (pIrpStack->MinorFunction == IRP_MN_CANCEL_REMOVE_DEVICE)
					{
						NtStatus = STATUS_SUCCESS;		// Not allow to fail this!
					}
				}
				pIrp->IoStatus.Status = NtStatus;
				pIrp->IoStatus.Information = 0;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				break;
			case IRP_MN_QUERY_STOP_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_STOP_DEVICE\n"));
				ASSERT( GCK_STATE_STARTED == pFilterExt->eDeviceState);
				pFilterExt->eDeviceState = GCK_STATE_STOP_PENDING;
				//Close Handle to driver beneath
				NtStatus = GCK_IP_CloseFileObject(pFilterExt);
                if( NT_SUCCESS (NtStatus) )
                {
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
				    IoSkipCurrentIrpStackLocation (pIrp);
				    NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
                }
                else
                {
                    pIrp->IoStatus.Status = NtStatus;
				    pIrp->IoStatus.Information = 0;
				    IoCompleteRequest (pIrp, IO_NO_INCREMENT);
                }
				break;
			case IRP_MN_QUERY_REMOVE_DEVICE:
				GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_REMOVE_DEVICE - Fall through to IRP_MN_STOP_DEVICE\n"));
			case IRP_MN_SURPRISE_REMOVAL:
				GCK_DBG_TRACE_PRINT(("IRP_MN_SURPRISE_REMOVAL - Fall through to IRP_MN_STOP_DEVICE\n"));
			case IRP_MN_STOP_DEVICE:
				
				GCK_DBG_TRACE_PRINT(("IRP_MN_STOP_DEVICE\n"));
				
				//	Do whatever processing is required
				GCK_FLTR_StopDevice (pFilterExt, TRUE);

				// We don't need a completion routine so fire and forget.
				GCK_DBG_TRACE_PRINT(("Calling lower driver\n"));
                pIrp->IoStatus.Status = STATUS_SUCCESS;
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
			
			case IRP_MN_REMOVE_DEVICE:

				GCK_DBG_TRACE_PRINT(("IRP_MN_REMOVE_DEVICE\n"));
				//@todo All the code in this case, should be moved to a separate function
				// Note! we might receive a remove WITHOUT first receiving a stop.
				if(
					GCK_STATE_STARTED == pFilterExt->eDeviceState ||
					GCK_STATE_STOP_PENDING  == pFilterExt->eDeviceState
				)
				{
					// Stop the device without touching the hardware.
					GCK_FLTR_StopDevice(pFilterExt, FALSE);
				}

				//
				// We will no longer receive requests for this device as it has been
				// removed.  (Note some code below, depends on this flag being updated.)
				//
				pFilterExt->eDeviceState = GCK_STATE_REMOVED;

				// Send on the remove IRP
                // Set the Status before sending the IRP onwards
                pIrp->IoStatus.Status = STATUS_SUCCESS;
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

				// Undo our increment upon entry to this routine
				GCK_DecRemoveLock(&pFilterExt->RemoveLock);
				
				// Undo the bias  Wait for count to go to zero, forever.
				GCK_DecRemoveLockAndWait(&pFilterExt->RemoveLock, NULL);

				//
				// Now that we are sure that outstanding IRPs are done,
				// we remove ourselves from the drivers global list of devices
				//
				GCK_DBG_TRACE_PRINT(("Removing from global linked list.\n"));
				
				//	Acquire mutext to touch global list
				ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
				
				//	Remove device from linked list of device that we handle
				ppPrevDeviceObjectPtr = &Globals.pFilterObjectList;
				pCurDeviceObject = Globals.pFilterObjectList;
				fRemovedFromList = FALSE;
				while( pCurDeviceObject )
				{
					if( pCurDeviceObject == pDeviceObject )
					{
						// Remove us from list
						*ppPrevDeviceObjectPtr = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
						fRemovedFromList = TRUE;
						break;
					}
					else
					{
						//skip to the next object
						ppPrevDeviceObjectPtr = PTR_NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
						pCurDeviceObject = NEXT_FILTER_DEVICE_OBJECT(pCurDeviceObject);
					}
				}
				ASSERT(fRemovedFromList);
				if(fRemovedFromList)
				{
					Globals.ulFilteredDeviceCount--;	//Decrement count of filtered devices
				}
				
				//Set fFoundOne TRUE if there are any device left
				fFoundOne = Globals.ulFilteredDeviceCount ? TRUE : FALSE;
				
				//	Release mutex to touch global list
				ExReleaseFastMutex(&Globals.FilterObjectListFMutex);
				
				//If there are no more devices left, cleanup Global Control Device
				//Verify that Virtual Bus has deleted any straggling Device Objects
				if(!fFoundOne)
				{
					GCK_CTRL_Remove();
				}

				GCK_DBG_TRACE_PRINT(("Detaching and Deleting DeviceObject.\n"));
				IoDetachDevice (pFilterExt->pTopOfStack);	//Detach from top of stack
				IoDeleteDevice (pDeviceObject);				//Delete ourselves

				// Must succeed this 
				GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_PnP(1) with status 0x%08x\n", NtStatus));
                ASSERT( NT_SUCCESS( NtStatus ) );
				return NtStatus;
			case IRP_MN_QUERY_DEVICE_RELATIONS:
				
				//
				//	We may be the platform for the virtual bus, if we are
				//	we need to call GCK_SWVB_BusRelations
				//
				GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_DEVICE_RELATIONS\n"));
				if(
					(BusRelations == pIrpStack->Parameters.QueryDeviceRelations.Type) &&
					(pFilterExt == Globals.pSWVB_FilterExt)
				)
				{
						NtStatus = GCK_SWVB_HandleBusRelations(&pIrp->IoStatus);
				
						//	If an error occured, stop it here and send it back;
						if( NT_ERROR(NtStatus) )
						{
							GCK_DBG_CRITICAL_PRINT(("GCK_SWVB_BusRelations returned 0x%0.8x, completing the IRP\n", NtStatus));
							IoCompleteRequest (pIrp, IO_NO_INCREMENT);
							break;
						}

				}
				//	Pass it along
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
			
			case IRP_MN_QUERY_INTERFACE:
			case IRP_MN_QUERY_CAPABILITIES:
			case IRP_MN_QUERY_RESOURCES:
			case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
			case IRP_MN_READ_CONFIG:
			case IRP_MN_WRITE_CONFIG:
			case IRP_MN_EJECT:
			case IRP_MN_SET_LOCK:
			case IRP_MN_QUERY_ID:
			case IRP_MN_QUERY_PNP_DEVICE_STATE:
			default:
				// All of these just pass on
				GCK_DBG_TRACE_PRINT(("Irp Minor Code 0x%0.8x: Calling lower driver.\n", pIrpStack->MinorFunction));
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
		}
	}
	
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_PnP(2) with Status, 0x%0.8x\n", NtStatus));        
    return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_PnPComplete (IN PDEVICE_OBJECT pDeviceObject,  IN PIRP pIrp, IN PVOID pContext)
**
**	@func	Completion for IRP_MJ_PNP\IR_MN_START_DEVICE for Filter Devices
**			Used mainly for start device.  Since it may be called at IRQL = LEVEL_DISPATCH
**			cannot be pageable!
**	@rdesc	STATUS_MORE_PROCESSING_REQUIRED
**
*************************************************************************************/
NTSTATUS GCK_FLTR_PnPComplete 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DeviceObject as our context
	IN PIRP pIrp,						// @parm IRP to complete
	IN PVOID pContext					// @parm Not used
)
{
    
    PGCK_FILTER_EXT		pFilterExt;
    NTSTATUS			NtStatus = STATUS_SUCCESS;

	//
	//	Current stack location is needed for DEBUG assertion only
	//
	#if (DBG==1)
	PIO_STACK_LOCATION	pIrpStack;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	#endif

	GCK_DBG_ENTRY_PRINT((
		"Entering GCK_FLTR_PnPComplete. pDO = 0x%0.8x, pIrp = 0x%0.8x, pContext = 0x%0.8x\n",
		pDeviceObject,
		pIrp,
		pContext
		));	

    UNREFERENCED_PARAMETER (pDeviceObject);

	if (pIrp->PendingReturned)
	{
        IoMarkIrpPending( pIrp );
    }

	
    pFilterExt = (PGCK_FILTER_EXT) pContext;
	KeSetEvent (&pFilterExt->StartEvent, 0, FALSE);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_PnPComplete with STATUS_MORE_PROCESSING_REQUIRED\n"));
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_StartDevice (IN PGCK_FILTER_EXT pFilterExt,  IN PIRP pIrp)
**
**	@func	On IRP_MN_START_DEVICE attaches filter module, creates
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_StartDevice 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to device object
	IN PIRP pIrp	// @parm IRP to handle
)
{
    NTSTATUS NtStatus;
	LARGE_INTEGER	lgiBufferOffset;
	UNREFERENCED_PARAMETER (pIrp);

	PAGED_CODE ();

	PGCK_FILTER_EXT		pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	GCK_DBG_ENTRY_PRINT((
		"Entering GCK_StartDevice. pFilterExt = 0x%0.8x, pIrp = 0x%0.8x\n",
		pFilterExt,
		pIrp
		));	

	//
	//	We shouldn't get a start on a removed device
	//
	ASSERT(GCK_STATE_REMOVED != pFilterExt->eDeviceState);
    
	//
	//	We shouldn't try to start a device that is already started
	//
    if (
		 GCK_STATE_STARTED == pFilterExt->eDeviceState || 
		 GCK_STATE_STOP_PENDING == pFilterExt->eDeviceState
	)
	{
		GCK_DBG_WARN_PRINT(( "Two IRP_MN_START_DEVICE recieved.\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_StartDevice(1) with STATUS_SUCCESS\n"));
        return STATUS_SUCCESS;
    }

	//
	//	Put the virtual bus on top of us if it is not already
	//
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	if( !Globals.pSWVB_FilterExt )
	{
		Globals.pSWVB_FilterExt = pFilterExt;
		NtStatus = GCK_SWVB_SetBusDOs(pDeviceObject, pFilterExt->pPDO);
		ASSERT( STATUS_SUCCESS == NtStatus); 
	}
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);

	//
	//	Collect basic info about the device
	//
	NtStatus = GCK_GetHidInformation(pFilterExt);

	//
	//	Initialize filter hooks
	//
	if( NT_SUCCESS(NtStatus) )
	{	// We can't initialize if we don't have hid info (vidpid!)
		GCKF_InitFilterHooks(pFilterExt);
	}
	
	//	Allocate a Buffer for last known poll of the device
	if( NT_SUCCESS(NtStatus) )
	{
			pFilterExt->pucLastReport = (PUCHAR)	EX_ALLOCATE_POOL
													( NonPagedPool,
													pFilterExt->HidInfo.HidPCaps.InputReportByteLength );
			if(!pFilterExt->pucLastReport)
			{
				GCK_DBG_CRITICAL_PRINT(("Failed to allocate Report Buffer for last known report\n"));
				NtStatus = STATUS_INSUFFICIENT_RESOURCES;
			}
	}

	// Initialize last known status for very first IRP
	if( NT_SUCCESS(NtStatus) )
	{
		pFilterExt->ioLastReportStatus.Information = (ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength;
		pFilterExt->ioLastReportStatus.Status =  STATUS_SUCCESS;
	}
	
	if ( NT_SUCCESS(NtStatus) )
	{	
		//Initialize InternalPoll module
		NtStatus = GCK_IP_Init(pFilterExt);
	}
	
	//	Mark device as Started
	if ( NT_SUCCESS(NtStatus) )
	{
		//mark for full time polling, but understand
		//that it won't start yet.
		GCK_IP_FullTimePoll(pFilterExt, TRUE);
		pFilterExt->eDeviceState = GCK_STATE_STARTED;

        //  Set device specific initial mapping in case 
        //  the value add is not running
        GCKF_SetInitialMapping( pFilterExt );
	}
	else //	we failed somewhere, clean up to mark as started
	{
		GCK_DBG_TRACE_PRINT(("Cleaning up in event of failure\n"));
	
		//Cleanup internal polling module
		GCK_IP_Cleanup(pFilterExt);

		//	No need to check if buffer was created, if it was we succeeded
		if(pFilterExt->pucLastReport)
		{
			ExFreePool(pFilterExt->pucLastReport);
			pFilterExt->pucLastReport = NULL;
		}
	
		//	Call CleanHidInformation to free anything allocated
		//	and zero it out
		GCK_CleanHidInformation( pFilterExt );
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_StartDevice(2) with Status: 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	VOID GCK_StopDevice (IN PGCK_FILTER_EXT	pFilterExt, IN BOOLEAN	fTouchTheHardware)
**
**	@func	Cancel outstanding IRPs and frees private Ping-Pong IRP
**
*************************************************************************************/
VOID GCK_FLTR_StopDevice 
(
	IN PGCK_FILTER_EXT	pFilterExt,	// @parm Device Extension
	IN BOOLEAN	fTouchTheHardware	// @parm TRUE if hardware can be touched
									//	- unused we never touch hardware
)
{
	BOOLEAN fCanceled;

	UNREFERENCED_PARAMETER(fTouchTheHardware);
	
	
	GCK_DBG_ENTRY_PRINT(("Entry GCK_FLTR_StopDevice, pFilterExt = 0x%0.8x\n", pFilterExt));
	
	PAGED_CODE ();
	
	ASSERT(GCK_STATE_STOPPED != pFilterExt->eDeviceState);
	if(GCK_STATE_STOPPED == pFilterExt->eDeviceState) return;

	//stop internal polling
	GCK_IP_FullTimePoll(pFilterExt, FALSE);

	//	Mark device as stopped
	pFilterExt->eDeviceState = GCK_STATE_STOPPED;

	//Cleanup internal polling module
	GCK_IP_Cleanup(pFilterExt);


		if (pFilterExt->pFilterHooks!=NULL) GCKF_DestroyFilterHooks(pFilterExt);

	//Acquire mutex to access list of filter objects
	ExAcquireFastMutex(&Globals.FilterObjectListFMutex);
	if( Globals.pSWVB_FilterExt == pFilterExt)
	{
		
		
		//Walk linked list of Filter Device Objects, looking for one that is not stopped
		BOOLEAN fFoundOne = FALSE;
		PDEVICE_OBJECT pCurDeviceObject = Globals.pFilterObjectList;
		PGCK_FILTER_EXT pCurFilterExt;
		NTSTATUS NtStatus;
		while( pCurDeviceObject )
		{
			pCurFilterExt = (PGCK_FILTER_EXT)pCurDeviceObject->DeviceExtension;
			if( 
				GCK_STATE_STARTED == pCurFilterExt->eDeviceState ||
				GCK_STATE_STOP_PENDING == pCurFilterExt->eDeviceState
			)
			{
				NtStatus = GCK_SWVB_SetBusDOs(pCurDeviceObject, pCurFilterExt->pPDO);
				ASSERT( NT_SUCCESS(NtStatus) );
				if( NT_SUCCESS(NtStatus) )
				{
					fFoundOne = TRUE;
					Globals.pSWVB_FilterExt = pCurFilterExt;
					break;
				}
			}
			//skip to the next object
			pCurDeviceObject = pCurFilterExt->pNextFilterObject;
		}
		if( !fFoundOne )
		{
			//Didn't find a place to hang the bus so move it nowhere
			NtStatus = GCK_SWVB_SetBusDOs(NULL, NULL);
			ASSERT( NT_SUCCESS(NtStatus) );
			Globals.pSWVB_FilterExt = NULL;	
		}
	}
	//Release mutex to access list of filter objects
	ExReleaseFastMutex(&Globals.FilterObjectListFMutex);


	//
	//	Free any structures relating to device (if needed)
	//	
	if(pFilterExt->pucLastReport)
	{
		ExFreePool(pFilterExt->pucLastReport);
		pFilterExt->pucLastReport = NULL;
	}
	GCK_CleanHidInformation( pFilterExt );
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_StopDevice\n"));
}


/***********************************************************************************
**
**	NTSTATUS GCK_GetHidInformation(IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	Does IOCTL_HID_GET_COLLECTION_INFORMATION to fill in
**			GCK_HID_DEVICE_INFO in DeviceExtension
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS GCK_GetHidInformation
(
	IN PGCK_FILTER_EXT	pFilterExt	// @parm Device Extension for filter
)
{

    NTSTATUS            NtStatus = STATUS_SUCCESS;
    KEVENT              HidCompletionEvent;
    PIRP				pHidIrp;
	IO_STATUS_BLOCK		ioStatus;

    PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT(( "Entering GCK_GetHidInformation. pFilterExt = 0x%0.8x\n",	pFilterExt));	

        
	//
    // Initialize Event for synchronous call to device
    //
    KeInitializeEvent(&HidCompletionEvent, NotificationEvent, FALSE);

    //**
    //**	IOCTL_HID_GET_COLLECTION_INFORMATION
    //**

	//
	//	Setup IRP
	//
    pHidIrp = 
		IoBuildDeviceIoControlRequest(
			IOCTL_HID_GET_COLLECTION_INFORMATION,
			pFilterExt->pTopOfStack,
			NULL,
			0,
			&pFilterExt->HidInfo.HidCollectionInfo,
			sizeof (HID_COLLECTION_INFORMATION),
			FALSE, /* EXTERNAL */
			&HidCompletionEvent,
			&ioStatus
			);
	if( NULL == pHidIrp)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate IRP for IOCTL_HID_GET_COLLECTION_INFORMATION\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(1) returning STATUS_INSUFFICIENT_RESOURCES\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//
	// Call Driver
	//
    NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pHidIrp);
	GCK_DBG_TRACE_PRINT(("IoCallDriver returned 0x%0.8x\n", NtStatus));
    
	//
	// Wait for IRP to complete
	//
	if (STATUS_PENDING == NtStatus)
	{
		GCK_DBG_TRACE_PRINT(("Waiting for IOCTL_HID_GET_COLLECTION_INFORMATION to complete\n"));
		NtStatus = KeWaitForSingleObject(
                       &HidCompletionEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       NULL
					   );
	}
	if( NT_ERROR( NtStatus) )
	{
		GCK_DBG_CRITICAL_PRINT(("Failed IRP for IOCTL_HID_GET_COLLECTION_INFORMATION\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(2) returning 0x%0.8x\n", NtStatus));
		return NtStatus;
	}
	//**
	//**	Get HID_PREPARSED_DATA
	//**
	
	//
	//	Allocate space for HIDP_PREPARSED_DATA, and zero memory
	//
	pFilterExt->HidInfo.pHIDPPreparsedData =
		(PHIDP_PREPARSED_DATA) 
		EX_ALLOCATE_POOL(
				NonPagedPool,
				pFilterExt->HidInfo.HidCollectionInfo.DescriptorSize
				);
	if( !pFilterExt->HidInfo.pHIDPPreparsedData )
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate IRP for IOCTL_HID_GET_COLLECTION_DESCRIPTOR\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(3) returning STATUS_INSUFFICIENT_RESOURCES\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlZeroMemory(
		pFilterExt->HidInfo.pHIDPPreparsedData,
		pFilterExt->HidInfo.HidCollectionInfo.DescriptorSize
		);

	//
	//	Clear Synchronization Event
	//
	KeClearEvent(&HidCompletionEvent);

	//
	//	Setup IRP
	//
	pHidIrp = 
		IoBuildDeviceIoControlRequest(
			IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
			pFilterExt->pTopOfStack,
			NULL,
			0,
			pFilterExt->HidInfo.pHIDPPreparsedData,
			pFilterExt->HidInfo.HidCollectionInfo.DescriptorSize,
			FALSE, /* EXTERNAL */
			&HidCompletionEvent,
			&ioStatus
			);
	if( NULL == pHidIrp)
	{
		ExFreePool( (PVOID)pFilterExt->HidInfo.pHIDPPreparsedData);
		pFilterExt->HidInfo.pHIDPPreparsedData = NULL;
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate IRP for IOCTL_HID_GET_COLLECTION_DESCRIPTOR\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(4) returning STATUS_INSUFFICIENT_RESOURCES\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	
    // Call Driver
	NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pHidIrp);
	GCK_DBG_TRACE_PRINT(("IoCallDriver returned 0x%0.8x\n", NtStatus));
    
	//
	// Wait for IRP to complete
	//
	if (STATUS_PENDING == NtStatus)
	{
		GCK_DBG_TRACE_PRINT(("Waiting for IOCTL_HID_GET_COLLECTION_DESCRIPTOR to complete\n"));
		NtStatus = KeWaitForSingleObject(
                       &HidCompletionEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       NULL
					   );
	}

	if( NT_ERROR( NtStatus) )
	{
		ExFreePool( (PVOID)pFilterExt->HidInfo.pHIDPPreparsedData);
		pFilterExt->HidInfo.pHIDPPreparsedData = NULL;
		GCK_DBG_CRITICAL_PRINT(("Failed IRP for IOCTL_HID_GET_COLLECTION_DESCRIPTOR\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(5) returning 0x%0.8x\n", NtStatus));
		return NtStatus;
	}
	
	//**
	//**	Get HIDP_CAPS structure
	//**

	NtStatus = HidP_GetCaps(pFilterExt->HidInfo.pHIDPPreparsedData, &pFilterExt->HidInfo.HidPCaps); 
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_GetHidInformation(6). Status = 0x%0.8x\n",	NtStatus));	
    return NtStatus;
}
		
/***********************************************************************************
**
**	VOID GCK_CleanHidInformation( IN PGCK_FILTER_EXT	pFilterExt)
**
**	@func Cleans up GCK_HID_INFORMATION in device extension
**
*************************************************************************************/
VOID GCK_CleanHidInformation(
	IN PGCK_FILTER_EXT	pFilterExt	// @parm Device Extension
)
{
	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_CleanHidInformation\n"));	

	//
	//	Free preparsed data, if necessary
	//
	if(pFilterExt->HidInfo.pHIDPPreparsedData)
	{
		GCK_DBG_TRACE_PRINT(("Freeing pHIDPPreparsedData\n"));	
		ExFreePool( (PVOID)pFilterExt->HidInfo.pHIDPPreparsedData);
		pFilterExt->HidInfo.pHIDPPreparsedData = NULL;
	}

	//
	//	Zero out all of the Hid Info
	//
	RtlZeroMemory(
		(PVOID)&pFilterExt->HidInfo,
		sizeof(GCK_HID_DEVICE_INFO)
	);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_CleanHidInformation\n"));
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckshell.c ===
//	@doc
/**********************************************************************
*
*	@module	GckShell.c	|
*
*	Basic driver entry points for GcKernel.sys
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	GckShell	|
*	Contains the most basic driver entry points (that any NT\WDM driver
*	would have) for GcKernel.sys.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_GCKSHELL_C

#include <wdm.h>
#include "Debug.h"
#include "GckShell.h"
#include "vmmid.h"

#ifdef BUILD_98
extern void* KeyBoardHook(void);
#endif

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, GCK_Create)
#pragma alloc_text (PAGE, GCK_Close)
#pragma alloc_text (PAGE, GCK_Unload)
#endif

//
//	Allow debug output for this moduel, and set the intial level
//
DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

//
//	Instance the global variables
//
GCK_GLOBALS Globals;
ULONG	ulWaitTime = 30;

#ifdef BUILD_98

#pragma data_seg("_LDATA", "LCODE")
LONG g_lHookRefCount = 0;
ULONG g_rgdwKeyEvents[50] = { 0 };
ULONG g_pPreviousKeyhook = 0;
UCHAR g_ucWriteIndex = 0;
UCHAR g_ucReadIndex = 0;
#pragma data_seg()

#pragma code_seg("_LTEXT", "LCODE")
#endif BUILD_98

void KeyHookC(ULONG dwScanCode)
{
#ifdef BUILD_98
	g_rgdwKeyEvents[g_ucWriteIndex++] = dwScanCode;
	if (g_ucWriteIndex >= 50)
	{
		g_ucWriteIndex = 0;
	}
#else !BUILD_98
    UNREFERENCED_PARAMETER (dwScanCode);
#endif BUILD_98
}

#ifdef BUILD_98
//-----------------------------------------------------------------------------
// InitHook - Sets up the keyboard hook
//-----------------------------------------------------------------------------
BOOLEAN HookKeyboard(void)
{
	volatile ULONG dwHook = (ULONG)KeyBoardHook;

	RtlZeroMemory((void*)g_rgdwKeyEvents, sizeof(ULONG) * 50);
	g_ucWriteIndex = 0;
	g_ucReadIndex = 0;
//	GetVxDServiceOrdinal eax, VKD_Filter_Keyboard_Input
	__asm mov eax, __VKD_Filter_Keyboard_Input

	__asm mov   esi, dwHook
	VxDCall(__Hook_Device_Service)
	__asm jc initfail
	__asm mov [g_pPreviousKeyhook], esi		// Since we are using C we can't use the funky callback
	return TRUE;
initfail:
	return FALSE;
};
#pragma code_seg()


void UnHookKeyboard()
{
	volatile ULONG dwHook = (ULONG)KeyBoardHook;

	// GetVxDServiceOrdinal eax, VKD_Filter_Keyboard_Input
	__asm mov eax, __VKD_Filter_Keyboard_Input
	__asm mov   esi, dwHook
	VxDCall(__Unhook_Device_Service)
	__asm clc
}
#endif BUILD_98

/***********************************************************************************
**
**	NTSTATUS DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Standard DriverEntry routine
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	int i;
                
    UNREFERENCED_PARAMETER (puniRegistryPath);
	
	PAGED_CODE();
	GCK_DBG_CRITICAL_PRINT(("Built %s at %s\n", __DATE__, __TIME__));    
	GCK_DBG_CRITICAL_PRINT(("Entering DriverEntry, pDriverObject = 0x%0.8x, puniRegistryPath = %s\n", pDriverObject, puniRegistryPath));
    
	//	Allow Control Device module to initialize itself
	NtStatus = GCK_CTRL_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Allow Filter Device module to initialize itself
	NtStatus = GCK_FLTR_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Allow SideWinder Virtual Bus module to initialize itself
	NtStatus = GCK_SWVB_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Allow SideWinder Virtual Keyboard module to initialize itself
	NtStatus = GCK_VKBD_DriverEntry(pDriverObject, puniRegistryPath);
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//	Hook all IRPs so we can pass them on.
	GCK_DBG_TRACE_PRINT(("Filling out entry point structure\n"));
	for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION;	i++)
	{
        pDriverObject->MajorFunction[i] = GCK_Pass;
    }

	// Initialize any shared global data
#ifdef BUILD_98
	g_lHookRefCount = 0;
#endif
	
	//	Define entries for IRPs we expect to handle
	pDriverObject->MajorFunction[IRP_MJ_CREATE]         = GCK_Create;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = GCK_Close;
    pDriverObject->MajorFunction[IRP_MJ_READ]           = GCK_Read;
    pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = 
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = GCK_Ioctl;
    pDriverObject->MajorFunction[IRP_MJ_PNP]            = GCK_PnP;
    pDriverObject->MajorFunction[IRP_MJ_POWER]          = GCK_Power;
    pDriverObject->DriverExtension->AddDevice           = GCK_FLTR_AddDevice;	//only the filter has an add device
    pDriverObject->DriverUnload                         = GCK_Unload;
	
	GCK_DBG_EXIT_PRINT (("Normal exit of DriverEntry: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	VOID GCK_Unload(IN PDRIVER_OBJECT pDriverObject )
**
**	@func	Called to unload driver, delete Control Device here
**
*************************************************************************************/
VOID GCK_Unload
(
	IN PDRIVER_OBJECT pDriverObject		// @parm Driver Object for our driver
)
{
    PAGED_CODE ();

    GCK_DBG_ENTRY_PRINT(("Entering GCK_Unload, pDriverObject = 0x%0.8x\n", pDriverObject));
	
	UNREFERENCED_PARAMETER(pDriverObject);

	GCK_SWVB_UnLoad();

	//
    // We should not be unloaded until all the PDOs have been removed from
    // our queue.  The control device object should be the only thing left.
    //
	ASSERT (NULL == pDriverObject->DeviceObject);
	ASSERT (NULL == Globals.pControlObject);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_Unload\n"));
	return;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Create ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles the IRP_MJ_CREATE - Generated by Win32 CreateFile or OpenFile
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS GCK_Create (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for context of IRP
	IN PIRP pIrp						// @parm pointer to IRP
)
{
    
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT (("GCK_Create, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	KdPrint(("GCK_Create, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				KdPrint((" -- GCK_DO_TYPE_CONTROL\n"));
				NtStatus = GCK_CTRL_Create(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_FILTER:
				KdPrint((" -- GCK_DO_TYPE_FILTER\n"));
				NtStatus = GCK_FLTR_Create(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				KdPrint((" -- GCK_DO_TYPE_SWVB\n"));
				NtStatus = GCK_SWVB_Create(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				NtStatus = STATUS_UNSUCCESSFUL;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Create. Status: 0x%0.8x\n", NtStatus));
    KdPrint(("Exiting GCK_Create. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Close ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles IRP_MJ_CLOSE - Generated by Win32 CloseFile
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_Close (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer DeviceObject for context
	IN PIRP pIrp						// @parm pointer to IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	
	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT (("GCK_Close, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
    
	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = GCK_CTRL_Close(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Close(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Close(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_Close. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Read (IN PDEVICE_OBJECT pDeviceObject,	IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_READ - Generated by Win32 ReadFile
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_Read 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object as our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_Read. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = STATUS_NOT_SUPPORTED;
				//Assert as we shouldn't get read on the control device
				ASSERT( NT_SUCCESS(NtStatus) );
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Read(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Read(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Read. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Power (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_POWER
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	GCK_DBG_ENTRY_PRINT(("Entering GCK_Power. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = STATUS_NOT_SUPPORTED;
				//Assert as we shouldn't get power on the control device
				ASSERT( NT_SUCCESS(NtStatus) );
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Power(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Power(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Power. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_PnP (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PnP
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
		
	GCK_DBG_ENTRY_PRINT(("Entering GCK_PnP. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = STATUS_NOT_SUPPORTED;
				//Assert as we shouldn't get PnP on the control device
				ASSERT( NT_SUCCESS(NtStatus) );
				pIrp->IoStatus.Status = NtStatus;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_PnP(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_PnP(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_PnP. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Ioctl (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_IOCTL and IRP_MJ_INTERNAL_IOCTL
**
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS GCK_Ioctl 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp						// @parm pointer to IRP
)
{
   	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
	ULONG		uIoctl;

	PIO_STACK_LOCATION	pIrpStack;

		
	GCK_DBG_ENTRY_PRINT(("Entering GCK_Ioctl. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);	
	uIoctl = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	if (uIoctl == IOCTL_GCK_ENABLE_KEYHOOK)
	{	// Special case IOCTL, device independant
#ifdef BUILD_WIN2K
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
#else !BUILD_WIN2K
		if (InterlockedIncrement(&g_lHookRefCount) == 1)
		{	// Not already hooked
			HookKeyboard();
		}
		pIrp->IoStatus.Status = STATUS_SUCCESS;
#endif BUILD_WIN2K
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return STATUS_SUCCESS;
	}
	if (uIoctl == IOCTL_GCK_DISABLE_KEYHOOK)
	{	// Special case also device independant
#ifdef BUILD_WIN2K
		pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
#else !BUILD_WIN2K
		if (InterlockedDecrement(&g_lHookRefCount) < 1)
		{	// Last hooker is going away
			UnHookKeyboard();
			g_lHookRefCount = 0;
		}
		pIrp->IoStatus.Status = STATUS_SUCCESS;
#endif BUILD_WIN2K
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return STATUS_SUCCESS;
	}
	if (uIoctl == IOCTL_GCK_GET_KEYHOOK_DATA)
	{
#ifdef BUILD_WIN2K
		NtStatus = STATUS_UNSUCCESSFUL;
#else !BUILD_WIN2K
		ULONG uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		if (uOutLength < sizeof(ULONG))
		{
			NtStatus = STATUS_BUFFER_TOO_SMALL;
		}
		else
		{
			ULONG* pulIoBuffer = (ULONG*)(pIrp->AssociatedIrp.SystemBuffer);
			*pulIoBuffer = 0;
			pIrp->IoStatus.Information = sizeof(ULONG);
			NtStatus = STATUS_SUCCESS;

			if (g_lHookRefCount > 0)
			{	// There is a hook
				if (g_ucWriteIndex != g_ucReadIndex)
				{	// We have data in the Queue
					*pulIoBuffer = g_rgdwKeyEvents[g_ucReadIndex++];
					if (g_ucReadIndex >= 50)
					{
						g_ucReadIndex = 0;
					}
				}
			}
		}
#endif BUILD_WIN2K
		pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return NtStatus;
	}

	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_CONTROL:
				NtStatus = GCK_CTRL_Ioctl(pDeviceObject, pIrp);	
				break;
		case	GCK_DO_TYPE_FILTER:
				NtStatus = GCK_FLTR_Ioctl(pDeviceObject, pIrp);
				break;
		case	GCK_DO_TYPE_SWVB:
				NtStatus = GCK_SWVB_Ioctl(pDeviceObject, pIrp);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				NtStatus = STATUS_UNSUCCESSFUL;
	}
	
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Ioctl. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_Pass (  IN PDEVICE_OBJECT pDeviceObject,  IN PIRP pIrp )
**
**	@func	Passes on unhandled IRPs to lower drivers DEBUG version trace out info
**			Cannot be pageable since we have no idea what IRPs we're getting.
**
**	@rdesc	STATUS_SUCCESS, various errors
**
*************************************************************************************/
NTSTATUS GCK_Pass ( 
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object as our context
	IN PIRP pIrp	// @parm IRP to pass on
)
{
	NTSTATUS	NtStatus;
	ULONG		ulGckDevObjType;
	PGCK_FILTER_EXT pFilterExt;

	//	Debug version want IRP stack for traceouts.
	#if	(DBG==1)	
	PIO_STACK_LOCATION	pIrpStack;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	#endif

	GCK_DBG_ENTRY_PRINT(("Entering GCK_Pass. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	GCK_DBG_TRACE_PRINT(
		(
			"GCK_Pass called with Irp MajorFunction = 0x%0.8x, MinorFunction = 0x%0.8x\n",
			pIrpStack->MajorFunction, pIrpStack->MinorFunction)
		);
	
	ulGckDevObjType = *(PULONG)pDeviceObject->DeviceExtension;
	switch(ulGckDevObjType)
	{
		case	GCK_DO_TYPE_FILTER:
				GCK_DBG_TRACE_PRINT(( "Passing IRP to lower driver\n"));
				pFilterExt = (PGCK_FILTER_EXT)pDeviceObject->DeviceExtension;
				IoSkipCurrentIrpStackLocation (pIrp);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				break;
		case	GCK_DO_TYPE_CONTROL:
		case	GCK_DO_TYPE_SWVB:
				//	No one to pass to, so return default status
				NtStatus = pIrp->IoStatus.Status;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				break;
		default:
				//
				//  If this assertion is hit, this Device Object was never properly initialized
				//	by GcKernel, or it has been trashed.
				//
				ASSERT(FALSE);
				NtStatus = STATUS_UNSUCCESSFUL;
				pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	};

	//return
    GCK_DBG_EXIT_PRINT(("Exiting GCK_Pass. Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\fltr.c ===
//	@doc
/**********************************************************************
*
*	@module	FLTR.c	|
*
*	Implementation of basic IRP handlers for Filter Device Objects
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	FLTR	|
*	The non-Power and PnP IRP handler routines are handled in this module
*	for all Device Objects created as filters for the raw HID-Pdos.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_FLTR_C

#include <wdm.h>
#include "Debug.h"
#include "GckShell.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, GCK_FLTR_DriverEntry)
#pragma alloc_text (PAGE, GCK_FLTR_Create)
#pragma alloc_text (PAGE, GCK_FLTR_Close)
#pragma alloc_text (PAGE, GCK_FLTR_Ioctl)
#pragma alloc_text (PAGE, GCK_FLTR_Unload)
#endif
/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Initializing the portions of the driver related to the filter devices.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS GCK_FLTR_DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{	
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(puniRegistryPath);
	//
	//	Initialize Globals related to filter devices
	//
	GCK_DBG_TRACE_PRINT(("Initializing globals\n"));
	Globals.ulFilteredDeviceCount = 0;
	Globals.pFilterObjectList = NULL;
	Globals.pSWVB_FilterExt=NULL;				// Nobody owns the virtual bus yet.
	Globals.pVirtualKeyboardPdo = NULL;		// No keyboard object
	Globals.ulVirtualKeyboardRefCount = 0;	// No keyboard users
	ExInitializeFastMutex(&Globals.FilterObjectListFMutex);
	return	STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Create ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles the IRP_MJ_CREATE for filter devices
**			- Called generated by Win32 API CreateFile or OpenFile
**
**	@rdesc	STATUS_SUCCESS, or various error codes
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Create (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
    
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;
	PDEVICE_OBJECT		pCurDeviceObject;
	PIO_STACK_LOCATION	pIrpStack;
	KEVENT				SyncEvent;
	USHORT				usShareAccess;
		
	PAGED_CODE ();

	GCK_DBG_ENTRY_PRINT (("Entering GCK_FLTR\n"));
	
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
    
	//
    // Increment IRP count, ASAP, note we couldn't do this until now, as we
    // knew not whether the device extension was really a GCK_FILTER_EXT
	//
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);
    
	//	Make sure we are not in the process of going away
	if( 
		GCK_STATE_STARTED != pFilterExt->eDeviceState &&
		GCK_STATE_STOP_PENDING != pFilterExt->eDeviceState
	)
	{
        GCK_DBG_WARN_PRINT(("Create while remove pending\n"));
		NtStatus = STATUS_DELETE_PENDING;
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
	} 
	else // process this
	{
        GCK_DBG_TRACE_PRINT(("GCK_Create calling lower driver\n"));
		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

		//
		//We lie to hidclass about the desired share access,
		//because it doesn't know not to count us.
		//Notice below that we restore this before passing to our
		//internal poll routines, so that we can track it there.
		//
		usShareAccess=pIrpStack->Parameters.Create.ShareAccess;
		pIrpStack->Parameters.Create.ShareAccess = FILE_READ_DATA|FILE_WRITE_DATA;

		//This is our internal poll trying to create a file object, just call down
		if(	pFilterExt->InternalPoll.InternalCreateThread == KeGetCurrentThread())
		{
			IoSkipCurrentIrpStackLocation(pIrp);
			NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
		}
		//This is a request from above, capture on the way up
		else
		{
			GCK_IP_AddFileObject(
				pFilterExt,
				pIrpStack->FileObject,
				pIrpStack->Parameters.Create.ShareAccess,
				pIrpStack->Parameters.Create.SecurityContext->DesiredAccess
				);

			GCKF_KickDeviceForData(pFilterExt);

			// Call create synchronously
			KeInitializeEvent(&SyncEvent, SynchronizationEvent,	FALSE);
       		IoCopyCurrentIrpStackLocationToNext(pIrp);
			IoSetCompletionRoutine(
				pIrp,
				GCK_FLTR_CreateComplete,
				(PVOID)&SyncEvent,
				TRUE,
				TRUE,
				TRUE
			);
			IoCallDriver (pFilterExt->pTopOfStack, pIrp);
			KeWaitForSingleObject(&SyncEvent, Executive, KernelMode, FALSE, NULL);
			NtStatus = pIrp->IoStatus.Status;
       		// If create succeeded, we need to remember the FileObject
			GCK_IP_ConfirmFileObject(pFilterExt, pIrpStack->FileObject, (BOOLEAN)(NT_SUCCESS(pIrp->IoStatus.Status) ? TRUE : FALSE) );
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// This was misssing!!!
		}
    }

    //
	//	We are done with this IRP, so decrement the outstanding count
	//	and signal remove if this was the last outstanding IRP
	//
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

    GCK_DBG_EXIT_PRINT(("Exiting GCK_Create(2). Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_CreateComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, IN PVOID pContext)
**
**	@mfunc	Completion Routine for IRP_MJ_CREATE
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_FLTR_CreateComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	IN PVOID pContext
)
{
	PKEVENT pSyncEvent;
	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(pIrp);

	// Cast context to device extension
	pSyncEvent = (PKEVENT) pContext;
	KeSetEvent(pSyncEvent, IO_NO_INCREMENT, FALSE);
		
	//Done with this IRP, never need to see it again
	return STATUS_MORE_PROCESSING_REQUIRED;
}


/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Close ( IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp )
**
**	@func	Handles IRP_MJ_CLOSE for filter device objects - Call generated by Win32 API CloseFile
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Close (
	IN PDEVICE_OBJECT pDeviceObject,	// @parm DO target for IRP
	IN PIRP pIrp						// @parm IRP
)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PGCK_FILTER_EXT		pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;

	PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT (("GCK_Close, pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
    
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
    
	//
    // Increment IRP count, ASAP, note we couldn't do this until now, as we
    // knew not whether the device extension was really a GCK_FILTER_EXT
	//
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	//cleanup pending IO and our tracking of the FileObject -
	//however not applicable if it is our internal polling open, that is being close
	if(pIrpStack->FileObject != pFilterExt->InternalPoll.pInternalFileObject)
	{
		//Complete pending I\O on FileObject
		if(
			GCK_STATE_STARTED == pFilterExt->eDeviceState ||
			GCK_STATE_STOP_PENDING == pFilterExt->eDeviceState
		)
		{
			//There is no pending I\O if the device is not started yet
			GCKF_CompleteReadRequestsForFileObject(pFilterExt, pIrpStack->FileObject);
		}
		//forget file object
		GCK_IP_RemoveFileObject(pFilterExt, pIrpStack->FileObject);
	}
	//send the Irp along
	IoSkipCurrentIrpStackLocation (pIrp);
	NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pIrp);

		
	// Decrement outstanding IO and signal if went to zero
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_Close(2). Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Read (IN PDEVICE_OBJECT pDeviceObject,	IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_READ for filter device objects - Generated by Win32 ReadFile
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Read 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Target of IRP
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS            NtStatus;
	LARGE_INTEGER       lgiWaitTime;
	PGCK_FILTER_EXT		pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;
	PIO_STACK_LOCATION	pPrivateIrpStack;
	PVOID				pvIrpBuffer;
	PFILE_OBJECT		pIrpsFileObject;
	static	int			iEnterCount=0;
	unsigned int i=0;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_Read. pDO = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));

    //cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);
	
	//	Increment IRP count while we handle this one
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);
    
	//	If we have been removed, we shouldn't be getting read IRPs
	if(
		GCK_STATE_STARTED != pFilterExt->eDeviceState &&
		GCK_STATE_STOP_PENDING  != pFilterExt->eDeviceState
	)
	{
		GCK_DBG_WARN_PRINT(( "GCK_Read called with delete pending\n"));
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		//	Decrement outstanding IRP count, and signal if it want to zero
		GCK_DecRemoveLock(&pFilterExt->RemoveLock);
	} 
	else 
	{
		//
		//	Send Reqeust to filter, the filterhooks module is responsible
		//	for all the necessary Asynchronous IRP handling steps, we just
		//	return status pending.
		//
		NtStatus = GCKF_IncomingReadRequests(pFilterExt, pIrp);

		//	Poll the lower driver, if one is not yet pending.
		GCK_IP_OneTimePoll(pFilterExt);
	}
	
	GCK_DBG_RT_EXIT_PRINT(("Exiting GCK_Read(2). Status: 0x%0.8x\n", NtStatus)); 
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_FLTR_Ioctl (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@mfunc	Handles all IOCTLs for the filter devices - this is just a straight pass through
**
**	@rdesc	STATUS_SUCCESS, various errors
**
*************************************************************************************/
NTSTATUS GCK_FLTR_Ioctl 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp						// @parm pointer to IRP
)
{
	PGCK_FILTER_EXT		pFilterExt;
	NTSTATUS			NtStatus;

	PAGED_CODE ();
	GCK_DBG_ENTRY_PRINT(("Entering GCK_FLTR_Ioctl, pDeviceObject = 0x%0.8x, pIRP = 0x%0.8x\n", pDeviceObject, pIrp));
	//cast device extension to proper type
	pFilterExt = (PGCK_FILTER_EXT) pDeviceObject->DeviceExtension;

    //
	// If we have been removed we need to refuse this IRP
	//
	if (GCK_STATE_REMOVED == pFilterExt->eDeviceState) {
		GCK_DBG_TRACE_PRINT(("GCK_FLTR_Ioctl called while delete pending\n"));
		ASSERT(FALSE);
		NtStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }
	else 
	{
	    // Send the IRP on unchanged.
	    IoSkipCurrentIrpStackLocation (pIrp);
        NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
    }

	GCK_DBG_EXIT_PRINT(("Exiting GCK_FLTR_Ioctl, Status: 0x%0.8x\n", NtStatus));
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckextrn.h ===
#ifndef __GckExtrn_h__
#define __GckExtrn_h__
//	@doc
/**********************************************************************
*
*	@module	GckExtrn.h	|
*
*	External Definitions needed to open and communicate with the driver.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	GckExtrn	|
*	IOCTL definitions and the name of the Control Object to be used in CreateFile.
*
**********************************************************************/

/********************************************
*	Driver (and Symbolic Link) Names		*
*********************************************/
#define GCK_CONTROL_NTNAME  L"\\Device\\MS_GCKERNEL"
#define GCK_CONTROL_SYMNAME L"\\DosDevices\\MS_GCKERNEL"
#define GCK_CONTROL_W32Name "\\\\.\\MS_GCKERNEL"

/****************************************
*		IOCTL definitions				*
*****************************************/
#define GCK_IOCTL_CODE(_x_) CTL_CODE(                         \
					        FILE_DEVICE_UNKNOWN,              \
						    (0x0800 | _x_),                   \
                            METHOD_BUFFERED,                  \
                            FILE_ANY_ACCESS                   \
                            )
#define GCK_IOCTL_DIRECT_CODE(_x_)	CTL_CODE(				\
									FILE_DEVICE_UNKNOWN,	\
									(0x0800 | _x_),			\
									METHOD_OUT_DIRECT,		\
									FILE_ANY_ACCESS			\
									)


#define IOCTL_GCK_GET_HANDLE					GCK_IOCTL_CODE(0x0001)
#define IOCTL_GCK_GET_CAPS						GCK_IOCTL_CODE(0x0002)
#define IOCTL_GCK_SEND_COMMAND					GCK_IOCTL_CODE(0x0003)
#define IOCTL_GCK_BACKDOOR_POLL					GCK_IOCTL_DIRECT_CODE(0x0004)
#define IOCTL_GCK_BEGIN_TEST_SCHEME				GCK_IOCTL_CODE(0x0005)
#define IOCTL_GCK_UPDATE_TEST_SCHEME			GCK_IOCTL_CODE(0x0006)
#define IOCTL_GCK_END_TEST_SCHEME				GCK_IOCTL_CODE(0x0007)
#define IOCTL_GCK_ENABLE_DEVICE					GCK_IOCTL_CODE(0x0008)
#define IOCTL_GCK_SET_INTERNAL_POLLING			GCK_IOCTL_CODE(0x0009)
#define IOCTL_GCK_ENABLE_TEST_KEYBOARD			GCK_IOCTL_CODE(0x000A)
#define IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE		GCK_IOCTL_CODE(0x000B)
#define IOCTL_GCK_END_FF_NOTIFICATION			GCK_IOCTL_CODE(0x000C)
#define IOCTL_GCK_GET_FF_SCHEME_DATA			GCK_IOCTL_CODE(0x000D)
#define IOCTL_GCK_SET_WORKINGSET				GCK_IOCTL_CODE(0x000E)
#define IOCTL_GCK_QUERY_PROFILESET				GCK_IOCTL_CODE(0x000F)
#define IOCTL_GCK_LED_BEHAVIOUR					GCK_IOCTL_CODE(0x0010)
#define IOCTL_GCK_TRIGGER						GCK_IOCTL_CODE(0x0011)
#define IOCTL_GCK_ENABLE_KEYHOOK				GCK_IOCTL_CODE(0x0012)
#define IOCTL_GCK_DISABLE_KEYHOOK				GCK_IOCTL_CODE(0x0013)
#define IOCTL_GCK_GET_KEYHOOK_DATA				GCK_IOCTL_CODE(0x0014)

/**********************************************************
*	Structures passed in IOCTLs							  *
**********************************************************/

typedef enum
{
	GCK_POLLING_MODE_RAW		= 0x00000001,
	GCK_POLLING_MODE_FILTERED	= 0x00000002,
	GCK_POLLING_MODE_MOUSE		= 0x00000004,
	GCK_POLLING_MODE_KEYBOARD	= 0x00000008,
} GCK_POLLING_MODES;

//
// @struct GCK_SET_INTERNAL_POLLING_DATA | Input structure for IOCTL_GCK_SET_INTERNAL_POLLING
//
typedef struct tagGCK_SET_INTERNAL_POLLING_DATA
{
	ULONG	ulHandle;	//@field Handle returned from IOCTL_GCK_GET_HANDLE
	BOOLEAN fEnable;	//@field TRUE to turn continous internal polling on, FALSE to turn it off
} GCK_SET_INTERNAL_POLLING_DATA, *PGCK_SET_INTERNAL_POLLING_DATA;

//
// @struct GCK_SET_INTERNAL_POLLING_DATA | Input structure for IOCTL_GCK_BACKDOOR_POLL
//
typedef struct tagGCK_BACKDOOR_POLL_DATA
{
	ULONG			  ulHandle;		//@field Handle returned from IOCTL_GCK_GET_HANDLE
	GCK_POLLING_MODES ePollingMode;	//@field TRUE for a raw poll, FALSE for filtered data (unapplied changes are active)
} GCK_BACKDOOR_POLL_DATA, *PGCK_BACKDOOR_POLL_DATA;

//
// @struct GCK_SET_INTERNAL_POLLING_DATA | Output structure for IOCTL_GCK_BACKDOOR_POLL
//										if the GCK_POLLING_MODE_MOUSE was used.
//
typedef struct tagGCK_MOUSE_OUTPUT
{
	char	cXMickeys;
	char	cYMickeys;
	char	cButtons;
	char	fDampen:1;
	char	fClutch:1;
} GCK_MOUSE_OUTPUT, *PGCK_MOUSE_OUTPUT;

typedef struct tagGCK_ENABLE_TEST_KEYBOARD
{
	ULONG	ulHandle;	//@field Handle returned from IOCTL_GCK_GET_HANDLE
	BOOLEAN fEnable;	//@field TRUE for a keyboard data, FALSE for none
} GCK_ENABLE_TEST_KEYBOARD, *PGCK_ENABLE_TEST_KEYBOARD;

//
// @struct GCK_SET_WORKINGSET | Output structure for IOCTL_GCK_SET_WORKINGSET
//
typedef struct tagGCK_SET_WORKINGSET
{
	ULONG			ulHandle;		//@field Handle returned from IOCTL_GCK_GET_HANDLE
	unsigned char	ucWorkingSet;	//@field 0 based working set for future IOCTLs
} GCK_SET_WORKINGSET, *PGCK_SET_WORKINGSET;

//
// @struct GCK_QUERY_PROFILESET | Input structure from IOCTL_GCK_QUERY_PROFILESET
//
typedef struct tagGCK_QUERY_PROFILESET
{
	unsigned char	ucActiveProfile;	//@field 0 active profile, determined by slider position
	unsigned char	ucWorkingSet;		//@field 0 based working profile from previous call to GCK_IOCTL_SETWORKINGSET
} GCK_QUERY_PROFILESET, *PGCK_QUERY_PROFILESET;


// LED behaviour enums (non combinable!)
typedef enum
{
	GCK_LED_BEHAVIOUR_DEFAULT	= 0x00,
	GCK_LED_BEHAVIOUR_ON		= 0x01,
	GCK_LED_BEHAVIOUR_OFF		= 0x02,
	GCK_LED_BEHAVIOUR_BLINK		= 0x03
} GCK_LED_BEHAVIOURS;

//
// @struct GCK_LED_BEHAVIOUR_OUT | Output structure to IOCTL_GCK_LED_BEHAVIOUR
//
typedef struct tagGCK_LED_BEHAVIOUR_OUT
{
	ULONG				ulHandle;		//@field Handle returned from IOCTL_GCK_GET_HANDLE
	GCK_LED_BEHAVIOURS	ucLEDBehaviour;	//@field New behaviour of the LEDs
	ULONG				ulLEDsAffected;	//@field Bit mask of effected LEDs
	unsigned char		ucShiftArray;	//@field Modifier state of affected LEDs
	unsigned char		ucBlinkRate;	//@field Blink rate of entire device (0 to leave unchanged)
} GCK_LED_BEHAVIOUR_OUT, *PGCK_LED_BEHAVIOUR_OUT;

//
// @struct GCK_LED_BEHAVIOUR_IN | Input structure from IOCTL_GCK_LED_BEHAVIOUR
//			This is a list of LEDs for the requested modifier state. If more than one modifier
//		is requested, only the lowest modifier state will report. Also not this is not the
//		actual state of the LEDs, but what would be the state if the requested modifier were pressed.
//
typedef struct tagGCK_LED_BEHAVIOUR_IN
{
	ULONG	ulLEDsOn;		//@field Bit mask LEDs in the on state (does not include blinking)
	ULONG	ulLEDsBlinking;	//@field Bit mask of LEDs that are blinking (not reported as on)
} GCK_LED_BEHAVIOUR_IN, *PGCK_LED_BEHAVIOUR_IN;


// Trigger Type enums (non combinable!)
typedef enum
{
	GCK_TRIGGER_BUTTON			= 0x00,
	GCK_TRIGGER_AXIS			= 0x01,		// Not currently availible
} GCK_TRIGGER_TYPES;

// Trigger SubType enums (non combinable!)
typedef enum
{
	TRIGGER_BUTTON_IMMEDIATE			= 0x00,
	TRIGGER_ON_BUTTON_DOWN				= 0x01,
	TRIGGER_ON_BUTTON_UP				= 0x02,
} GCK_TRIGGER_SUBTYPES;

//
// @struct GCK_TRIGGER_OUT | Output structure to IOCTL_GCK_TRIGGER
//			This IOCTL hangs untill the trigger happens (except for TRIGGER_IMMEDIATE)
//
typedef struct tagGCK_TRIGGER_OUT
{
	ULONG					ulHandle;			//@field Handle returned from IOCTL_GCK_GET_HANDLE
	GCK_TRIGGER_TYPES		ucTriggerType;		//@field Type of trigger
	GCK_TRIGGER_SUBTYPES	ucTriggerSubType;	//@field Subtype of trigger
	ULONG					ulTriggerInfo1;		//@field Information for triggering (type dependant)
	ULONG					ulTriggerInfo2;		//@field Secondary info for triggering (type dependant)
} GCK_TRIGGER_OUT, *PGCK_TRIGGER_OUT;


/********************************************************
*	IOCTL's available in debug builds of the driver		*
*********************************************************/
#define	IOCTL_GCK_SET_MODULE_DBG_LEVEL	GCK_IOCTL_CODE(0x1000)


/********************************************************
*	Module IDs for setting DEBUG levels					*
*********************************************************/
#define MODULE_GCK_CTRL_C			0x0001
#define MODULE_GCK_CTRL_IOCTL_C		0x0002
#define MODULE_GCK_FILTER_CPP		0x0004
#define MODULE_GCK_FILTERHOOKS_CPP	0x0005
#define MODULE_GCK_FLTR_C			0x0006
#define MODULE_GCK_FLTR_PNP_C		0x0007
#define MODULE_GCK_GCKSHELL_C		0x0008
#define MODULE_GCK_REMLOCK_C		0x0009
#define MODULE_GCK_SWVB_PNP_C		0x000A
#define MODULE_GCK_SWVBENUM_C		0x000B
#define MODULE_GCK_SWVKBD_C			0x000C

#define MODULE_CIC_ACTIONS_CPP					0x1000
#define MODULE_CIC_CONTROLITEMCOLLECTION_CPP	0x1001
#define MODULE_CIC_CONTROLITEM_CPP				0x1002
#define MODULE_CIC_DEVICEDESCRIPTIONS_CPP		0x1003
#define MODULE_CIC_DUALMODE_CPP					0x1004
//#define MODULE_CIC_DUMPCOMMANDBLOCK_CPP			0x1005
#define MODULE_CIC_LISTASARRAY_CPP				0x1006

#endif	//__GckExtrn_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\gckshell.h ===
#ifndef __GckShell_h__
#define __GckShell_h__
//	@doc
/**********************************************************************
*
*	@module	GckShell.h	|
*
*	Header file for GcKernel.sys WDM shell structure
*
*	History
*	----------------------------------------------------------------------
*	Mitchell S. Dernis	Original (Adopted from Hid2Gdp by Michael Hooning)
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	GckShell	|
*	Declaration of all structures, and functions in GcKernel that make up
*	the shell of the driver.  This excludes the Filter Module (and in the future)
*	any mixer modules.
**********************************************************************/

#include "GckExtrn.h"	//	Pull in any stuff that also needs to be available externally.
#include "RemLock.h"	//	Pull in header for RemoveLock utility functions

//	We use some structures from hidclass.h
#include <hidclass.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <hidusage.h>

//	A little more rigorous than our normal build
#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

//-----------------------------------------------------------------------------
//	The below constants distinguish between the three types of Device Objects
//	used throughout GcKernel. 0xABCD in the high word is used as a signature 
//	in DEBUG builds just to verify that the type was initialized.
//-----------------------------------------------------------------------------
#define GCK_DO_TYPE_CONTROL	0xABCD0001
#define GCK_DO_TYPE_FILTER	0xABCD0002
#define GCK_DO_TYPE_SWVB	0xABCD0003

//------------------------------------------------------------------------------
// Enumeration to keep track of device state, rather than fStarted and fRemoved
// flags
//------------------------------------------------------------------------------
typedef enum _tagGCK_DEVICE_STATE
{
	GCK_STATE_STARTED=0,
	//GCK_STATE_SURPRISE_REMOVED, //Currently not used, same as GCK_STATE_STOPPED
	GCK_STATE_STOP_PENDING,
	GCK_STATE_STOPPED,
	//GCK_STATE_REMOVE_PENDING,	//Currently not used, same as GCK_STATE_STOPPED
	GCK_STATE_REMOVED
} GCK_DEVICE_STATE;

//------------------------------------------------------------------------------
// Microsoft's vendor ID is fixed for all products.  The following constant
// is defined for use in GcKernel
//------------------------------------------------------------------------------
#define MICROSOFT_VENDOR_ID 0x045E
//------------------------------------------------------------------------------
// Declaration of Various structures
//------------------------------------------------------------------------------

//
//	@struct GCK_CONTROL_EXT	| Device Extension for our control device
//
typedef struct _tagGCK_CONTROL_EXT
{
	ULONG	ulGckDevObjType;	// @field Type of GcKernel device object.
    LONG	lOutstandingIO;		// @field 1 biased count of reasons why we shouldn't unload
} GCK_CONTROL_EXT, *PGCK_CONTROL_EXT;

//
//	@struct GCK_HID_Device_INFO | sub-structure that holds HID info about device
//
typedef struct _tagGCK_HID_DEVICE_INFO
{
	HID_COLLECTION_INFORMATION	HidCollectionInfo;	// @field HID_COLLECTION_INFO reported by device
	PHIDP_PREPARSED_DATA		pHIDPPreparsedData;	// @field pointer to HID_PREPARSED_DATA reported by device
	HIDP_CAPS					HidPCaps;			// @field HID_CAPS structure for device
} GCK_HID_DEVICE_INFO, *PGCK_HID_DEVICE_INFO;

//
//	@struct GCK_FILE_OPEN_ITEM | Status of open file handles.
//
typedef struct tagGCK_FILE_OPEN_ITEM
{
	BOOLEAN				fReadPending;					// @field TRUE if read is pending to driver
	BOOLEAN				fConfirmed;						// @field TRUE means that the lower driver has already completed the open
	ULONG				ulAccess;						// @field represents permissions this was opened with
	USHORT				usSharing;						// @field represents sharing under which this was opened
	FILE_OBJECT			*pFileObject;					// @field Pointer to file object which this status describes
	struct tagGCK_FILE_OPEN_ITEM	*pNextOpenItem;		// @field Next structure in Linked List
} GCK_FILE_OPEN_ITEM, *PGCK_FILE_OPEN_ITEM;

typedef struct _SHARE_STATUS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    //ULONG Deleters;	//We are driver without delete symantics
    ULONG SharedRead;
    ULONG SharedWrite;
    //ULONG SharedDelete; //We are driver without delete symantics
} SHARE_STATUS, *PSHARE_STATUS;

//
//	@struct GCK_INTERNAL_POLL | Information needed for the iternal polling routines
//
typedef struct tagGCK_INTERNAL_POLL
{
	KSPIN_LOCK			InternalPollLock;			// @field SpinLock to serialize access to this structue (not all items require it)
	FILE_OBJECT			*pInternalFileObject;		// @field Pointer to File Object that was created for internal polls
	PGCK_FILE_OPEN_ITEM	pFirstOpenItem;				// @field Head of linked list of GCK_FILE_OPEN_ITEMs for open files
	SHARE_STATUS		ShareStatus;				// @field Keeps track of file sharing.
//	BOOLEAN				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
	LONG				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
    PIRP				pPrivateIrp;				// @field IRP we reuse to send Read IRPs to lower driver
    PUCHAR				pucReportBuffer;			// @field Buffer for getting Report with pPrivateIrp
	ULONG				ulInternalPollRef;			// @field Reference to internal polls
	PKTHREAD			InternalCreateThread;		// @field Used to figure out if a create is for the internal file object
	BOOLEAN				fReady;
} GCK_INTERNAL_POLL, *PGCK_INTERNAL_POLL;

typedef struct _tagGCK_INTERLOCKED_QUEUE
{
	KSPIN_LOCK SpinLock;
	LIST_ENTRY ListHead;
} GCK_INTERLOCKED_QUEUE, *PGCK_INTERLOCKED_QUEUE;

// Declare structure for filterhooks stuff
struct GCK_FILTER_HOOKS_DATA;


//
//	@struct GCK_FILTER_EXT | Device Extension for device objects which act as filters
//
typedef struct _tagGCK_FILTER_EXT
{
	ULONG			ulGckDevObjType;	// @field Type of GcKernel device object.
	GCK_DEVICE_STATE eDeviceState;		// @field Keeps track of device state
    PDEVICE_OBJECT	pPDO;				// @field PDO to which this filter is attached
    PDEVICE_OBJECT	pTopOfStack;		// @field Top of the device stack just
										// beneath this filter device object
    KEVENT			StartEvent;			// @field Event to notify when lower driver completed start IRP.
    GCK_REMOVE_LOCK RemoveLock;			// @field Custom Remove Lock
	PUCHAR			pucLastReport;		// @field Last report read
	IO_STATUS_BLOCK	ioLastReportStatus;	// @field Status block for Last report read
	struct GCK_FILTER_HOOKS_DATA *pFilterHooks;// @field pointer to all the thinks needed in filter hooks
	PDEVICE_OBJECT	pNextFilterObject;	// @field point to next filter device object in global list
	GCK_HID_DEVICE_INFO HidInfo;		// @field sub-structure with pertinent HID info
	PVOID			pvFilterObject;		// @field pointer to CDeviceFilter, but this is C module so use PVOID
	PVOID			pvSecondaryFilter;	// @field pointer to CDeviceFilter, but this is C module so use PVOID
	PVOID			pvForceIoctlQueue;	// @field pointer to CGuardedIrpQueue for waiting IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE (use PVOID since C)
	PVOID			pvTriggerIoctlQueue;// @field pointer to CGuardedIrpQueue for waiting IOCTL_GCK_TRIGGER (use PVOID since C)
	GCK_INTERNAL_POLL InternalPoll;		// @field Structure for Internal Polling module.
} GCK_FILTER_EXT, *PGCK_FILTER_EXT;

//
//	@struct GCK_GLOBALS	| Hold a few global variables for the driver
//
typedef struct _tagGCK_GLOBALS
{
    PDEVICE_OBJECT  pControlObject;			//@field pointer to the one and only control object
	ULONG			ulFilteredDeviceCount;	//@field count of device objects for filtering devices
	PDEVICE_OBJECT	pFilterObjectList;		//@field head of linked list for all the devices we are filtering
	FAST_MUTEX		FilterObjectListFMutex;	//@field fast mutex for synchronizing access to filter object list
	PGCK_FILTER_EXT	pSWVB_FilterExt;		//@field Device Extension of Filter Device which acts as SideWinder Virtual Bus
	PDEVICE_OBJECT	pVirtualKeyboardPdo;	//@field PDO for virtual Keyboard
	ULONG			ulVirtualKeyboardRefCount;	//@field RefCount of virual Keyboard users
} GCK_GLOBALS;

//
// @devnote One instance of GCK_GLOBALS exists(in GckShell.c) and is called "Globals"
//
extern GCK_GLOBALS Globals;


/*****************************************************************************
** Declaration of Driver Entry Points
******************************************************************************/
//
// General Entry Points - In GckShell.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_Unload(
    IN PDRIVER_OBJECT pDriverObject
    );

NTSTATUS
GCK_Create (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_Close (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_Read (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_Power (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_PnP (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_Ioctl (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_Pass (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

//
//	For Control Devices - In CTRL.c
//
NTSTATUS
GCK_CTRL_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_CTRL_Unload(
    IN PDRIVER_OBJECT pDriverObject
    );

NTSTATUS
GCK_CTRL_AddDevice
(
	IN PDRIVER_OBJECT  pDriverObject
);

VOID
GCK_CTRL_Remove();

NTSTATUS
GCK_CTRL_Create (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_CTRL_Close (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

//
//	For Control Devices - In CTRL_Ioctl.c
//

NTSTATUS
GCK_CTRL_Ioctl (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

//
//	For Filter Devices - In FLTR.c
//
NTSTATUS
GCK_FLTR_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_FLTR_Unload(
    IN PDRIVER_OBJECT pDriverObject
    );

NTSTATUS
GCK_FLTR_Create (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_Close (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_Read
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_FLTR_Ioctl (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

//
//	In FLTR_PnP.c
//
NTSTATUS
GCK_FLTR_Power (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_PnP (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_AddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

//
//	In SWVBENUM.c
//
NTSTATUS
GCK_SWVB_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
GCK_SWVB_UnLoad();


NTSTATUS
GCK_SWVB_PnP
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Power
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Create
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Close
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Read
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

NTSTATUS
GCK_SWVB_Ioctl
(
	IN PDEVICE_OBJECT	pPdo,
	IN PIRP				pIrp
);

//
//	In SWVKBD.c
//
NTSTATUS
GCK_VKBD_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

/*****************************************************************************
** End of declaration of Driver Entry Points
******************************************************************************/

/*****************************************************************************
** Declaration of Non-Entry Driver routines
******************************************************************************/
//
// In FLTR.c
//

NTSTATUS
GCK_FLTR_CreateComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	IN PVOID pContext
);

//
// In PnP.c
//
NTSTATUS
GCK_FLTR_PnPComplete (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
GCK_FLTR_StartDevice (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP				pIrp
    );

VOID
GCK_FLTR_StopDevice (
    IN PGCK_FILTER_EXT	pFilterExt,
    IN BOOLEAN			fTouchTheHardware
    );

NTSTATUS
GCK_GetHidInformation
(
	IN PGCK_FILTER_EXT	pFilterExt
);

VOID 
GCK_CleanHidInformation(
	IN PGCK_FILTER_EXT	pFilterExt
);

//
// In IoCtl.c
//
NTSTATUS
GCK_CTRL_Ioctl (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
GCK_FLTR_Ioctl (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

PDEVICE_OBJECT
GCK_FindDeviceObject( 
	IN PWSTR pwszInterfaceReq,
	IN ULONG uInLength
	);

BOOLEAN GCK_MatchReqPathtoInterfaces
(
	IN PWSTR pwszPath,
	IN ULONG uStringLen,
	IN PWSTR pmwszInterfaces
);

//
// In FilterHooks.cpp
//


NTSTATUS _stdcall
GCKF_InitFilterHooks(
	IN PGCK_FILTER_EXT pFilterExt
	);

void _stdcall
GCKF_DestroyFilterHooks(
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall 
GCKF_ProcessCommands(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pCommandBuffer,
	IN ULONG ulBufferSize,
	IN BOOLEAN fPrimaryFilter
	);

void _stdcall 
GCKF_SetInitialMapping(
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_IncomingReadRequests(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp
	);

VOID __stdcall
GCKF_KickDeviceForData(
	IN PGCK_FILTER_EXT pFilterExt
	);

VOID _stdcall
GCKF_CancelPendingRead(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
	);

NTSTATUS _stdcall
GCKF_IncomingInputReports(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pcReport,
	IN IO_STATUS_BLOCK IoStatus
	);

NTSTATUS _stdcall
GCKF_CompleteReadRequests(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pcReport,
	IN IO_STATUS_BLOCK IoStatus
	);

void _stdcall
GCKF_CompleteReadRequestsForFileObject(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
	);

NTSTATUS _stdcall
GCKF_IncomingForceFeedbackChangeNotificationRequest(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp
	);

NTSTATUS _stdcall
GCKF_ProcessForceFeedbackChangeNotificationRequests(
	IN PGCK_FILTER_EXT pFilterExt
	);

void _stdcall
GCKF_OnForceFeedbackChangeNotification(
	IN PGCK_FILTER_EXT pFilterExt,
	const IN /*FORCE_BLOCK*/void* pForceBlock
	);
	
NTSTATUS _stdcall
GCKF_GetForceFeedbackData(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_SetWorkingSet(
	IN PGCK_FILTER_EXT pFilterExt,
	UCHAR ucWorkingSet
	);

NTSTATUS _stdcall
GCKF_QueryProfileSet(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_SetLEDBehaviour(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

NTSTATUS _stdcall
GCKF_TriggerRequest(
	IN PIRP pIrp,
	IN PGCK_FILTER_EXT pFilterExt
	);

void _stdcall
GCKF_SetNextJog(
	IN PVOID pvFilterContext,
	IN ULONG ulJogDelay
	);

ULONG _stdcall
GCKF_GetTimeStampMs();

VOID _stdcall
GCKF_TimerDPCHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS _stdcall
GCKF_EnableTestKeyboard(
	IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fEnable,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS _stdcall
GCKF_BeginTestScheme(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pCommandBuffer,
	IN ULONG ulBufferSize,
	IN FILE_OBJECT *pFileObject
	);

NTSTATUS _stdcall
GCKF_UpdateTestScheme(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PCHAR pCommandBuffer,
	IN ULONG ulBufferSize,
	IN FILE_OBJECT *pFileObject
	);

NTSTATUS _stdcall
GCKF_EndTestScheme(
	IN PGCK_FILTER_EXT pFilterExt,
	IN FILE_OBJECT *pFileObject
	);

NTSTATUS _stdcall
GCKF_BackdoorPoll(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP pIrp,
	IN GCK_POLLING_MODES ePollingMode
	);

void _stdcall
GCKF_ResetKeyboardQueue(
	DEVICE_OBJECT* pFilterHandle
	);

//
// In InternalPoll.c
//
NTSTATUS
GCK_IP_AddFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN USHORT		usDesiredShareAccess,
	IN ULONG		ulDesiredAccess
);

NTSTATUS
GCK_IP_RemoveFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS
GCK_IP_ConfirmFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN BOOLEAN	fConfirm
);

BOOLEAN
GCK_IP_CheckSharing
(
	IN SHARE_STATUS ShareStatus,
	IN USHORT usDesireShareAccess,
	IN ULONG ulDesiredAccess
);

BOOLEAN
GCK_IP_AddSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
);

BOOLEAN
GCK_IP_RemoveSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
);


NTSTATUS
GCK_IP_OneTimePoll
(
	IN PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_FullTimePoll
(
    IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fStart
);

NTSTATUS
GCK_IP_ReadComplete
(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
);

void
GCK_IP_AddDevice(PGCK_FILTER_EXT pFilterExt);

NTSTATUS
GCK_IP_Init
(
	IN PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_Cleanup
(
	IN OUT PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_CreateFileObject
(
	OUT PFILE_OBJECT	*ppFileObject,
	IN	PDEVICE_OBJECT	pPDO
);

NTSTATUS
GCK_IP_CloseFileObject
(
	IN OUT PGCK_FILTER_EXT pFilterExt
);
/*****************************************************************************
** End of declaration of Non-Entry Driver routines
******************************************************************************/

/*****************************************************************************
** Macros used internally  - to access filed from the device extension
**							directly from the pDeviceObject
******************************************************************************/
#define NEXT_FILTER_DEVICE_OBJECT(__pDO__)\
		( ((PGCK_FILTER_EXT)__pDO__->DeviceExtension)->pNextFilterObject )
#define PTR_NEXT_FILTER_DEVICE_OBJECT(__pDO__)\
		( &((PGCK_FILTER_EXT)__pDO__->DeviceExtension)->pNextFilterObject )
#define FILTER_DEVICE_OBJECT_PDO(__pDO__)\
		( ((PGCK_FILTER_EXT)__pDO__->DeviceExtension)->pPDO )
#define THREAD_SAFE_DEC_REF(__pFoo__, __TYPE__)\
	__TYPE__ *__pTempPointer__ = __pFoo__;\
	__pFoo__ = NULL;\
	__pTempPointer__->DecRef();

/*****************************************************************************
** End of macros used internally
******************************************************************************/

/*****************************************************************************
**	Macro for allocating memory - debug version uses ExAllocatePoolTag
******************************************************************************/
#if (DBG==1)


// For serious debugging
/*
#define EX_ALLOCATE_POOL(__PoolType__,__Size__)	MyAllocation(__PoolType__,__Size__, '_KCG', __FILE__, __LINE__)
PVOID MyAllocation(
       IN POOL_TYPE PoolType,
       IN ULONG NumberOfBytes,
       IN ULONG Tag,
	   IN LPSTR File,
	   IN ULONG Line
       )
{
	DbgPrint("GcKernel: ");
	DbgPrint("Memory allocation in %s, line %d\n", File, Line);
	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}
*/
//For lighter weight debugging
#define EX_ALLOCATE_POOL(__PoolType__,__Size__)	ExAllocatePoolWithTag(__PoolType__,__Size__,'_KCG')


#else
#define EX_ALLOCATE_POOL(__PoolType__,__Size__) ExAllocatePool(__PoolType__,__Size__)
#endif

#endif // __GckShell_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\internalpoll.c ===
//	@doc
/**********************************************************************
*
*	@module	InternalPolling.c	|
*
*	Implementation of routines for internal polling
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1999 Microsoft Corporation. All right reserved.
*
*	@topic	Internal Polling	|
*			All polling to get data is via this internal polling mechanism.
*			However, for security and access checks, the first poll from
*			a new file handle is sent straight down, and comes up via
*			different completion.  To keep track of this we keep a linked
*			list of GCK_FILE_OPEN_ITEMs representing each of the FILE_OBJECTS
*			that we need.<nl>
*			To Poll internally we need to have a valid FILE_OBJECT otherwise
*			hidclass.sys will reject the poll request.  This is done
*			via GCK_IP_CreateFileObject which internally calls IoGetDeviceObjectPointer.
*			Somewhat unfortunately, this takes circular path through, so is not
*			really distinguishable from opens done up top.  (Ken Ray tells me that
*			this is guaranteed to be synchronous, so we can compare thread IDs and
*			figure out that a given open is from our driver, but this code is written
*			assuming that we don't really need to distinguish.)
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_INTERNALPOLL_C

#include <wdm.h>
#include "Debug.h"
#include "GckShell.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_AddFileObject(IN PGCK_FILTER_EXT pFilterExt, IN PFILE_OBJECT pFileObject)
**
**	@func	Called to add a GCK_FILE_OPEN_ITEM entry corresponding to pFileObject to
**			our list of file handles that we know about.  Allocate and initializes the structure.
**
**	@rdesc	STATUS_SUCCESS, or STATUS_UNSUCCESSFUL if pFileObject is not found.
**
*************************************************************************************/
NTSTATUS
GCK_IP_AddFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN USHORT		usDesiredShareAccess,
	IN ULONG		ulDesiredAccess
)
{
	PGCK_FILE_OPEN_ITEM pNewFileOpenItem;
	KIRQL			 	OldIrql;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_IP_AddFileObject pFilterExt = 0x%0.8x, pFileObject = 0x%0.8x\n", pFilterExt, pFileObject));
	
	//We need a spin lock to access this list
	KeAcquireSpinLock(&pFilterExt->InternalPoll.InternalPollLock, &OldIrql);

	//Check for sharing violation
	if( !GCK_IP_CheckSharing(pFilterExt->InternalPoll.ShareStatus, usDesiredShareAccess, ulDesiredAccess) )
	{
		KeReleaseSpinLock(&pFilterExt->InternalPoll.InternalPollLock, OldIrql);
		GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_AddFileObject: Sharing Violation\n"));
		return STATUS_SHARING_VIOLATION;
	}

	//Allocate Space for NewFileOpenItem;
	pNewFileOpenItem = (PGCK_FILE_OPEN_ITEM)EX_ALLOCATE_POOL(NonPagedPool, sizeof(GCK_FILE_OPEN_ITEM));
	if(!pNewFileOpenItem)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate space for GCK_FILE_OPEN_ITEM\n"));
		GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_AddFileObject(1) STATUS_NO_MEMORY\n"));
		return STATUS_NO_MEMORY;
	}
	
	//Initialize FileOpenItem
	pNewFileOpenItem->fReadPending = FALSE;
	pNewFileOpenItem->pFileObject = pFileObject;
	pNewFileOpenItem->pNextOpenItem = NULL;
	pNewFileOpenItem->ulAccess = ulDesiredAccess;
	pNewFileOpenItem->usSharing = usDesiredShareAccess;
	pNewFileOpenItem->fConfirmed = FALSE;

	//Add New Item to head of list
	pNewFileOpenItem->pNextOpenItem = pFilterExt->InternalPoll.pFirstOpenItem;
	pFilterExt->InternalPoll.pFirstOpenItem = pNewFileOpenItem;
	
	//Update SHARE_ACCESS
	GCK_IP_AddSharing(&pFilterExt->InternalPoll.ShareStatus, usDesiredShareAccess, ulDesiredAccess);

	//Release Spinlock
	KeReleaseSpinLock(&pFilterExt->InternalPoll.InternalPollLock, OldIrql);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_AddFileObject(2) STATUS_SUCCESS\n"));
	return STATUS_SUCCESS;
}


/***********************************************************************************
**
**	NTSTATUS	GCK_IP_RemoveFileObject(IN PGCK_FILTER_EXT pFilterExt, IN PFILE_OBJECT pFileObject)
**
**	@func	Called to remove a GCK_FILE_OPEN_ITEM entry corresponding to pFileObject from
**			our list of file handles that we know about.  Deallocates structure.
**
**	@rdesc	STATUS_SUCCESS, or STATUS_UNSUCCESSFUL if pFileObject is not found.
**
*************************************************************************************/
NTSTATUS
GCK_IP_RemoveFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
)
{
	//Remove is just a negative confirmation
	return GCK_IP_ConfirmFileObject(pFilterExt, pFileObject, FALSE);
}

NTSTATUS
GCK_IP_ConfirmFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject,
	IN BOOLEAN	fConfirm
)
{
	//Find FileOpenItem and remove it.
	PGCK_FILE_OPEN_ITEM pCurrentFileItem = pFilterExt->InternalPoll.pFirstOpenItem; 
	PGCK_FILE_OPEN_ITEM pPreviousFileItem = NULL; 

	GCK_DBG_ENTRY_PRINT(("Entering GCK_IP_ConfirmFileObject pFilterExt = 0x%0.8x, pFileObject = 0x%0.8x, fConfirm = %d\n", pFilterExt, pFileObject, fConfirm));
	
	while(pCurrentFileItem)
	{
		//Check for File Object Match
		if(pCurrentFileItem->pFileObject == pFileObject)
		{
			//If this is a confirmation, flag
			if( fConfirm )
			{
				pCurrentFileItem->fConfirmed = TRUE;
			}
			//Otherwise, it is a negative confirmation, and we must remove it
			else
			{
				//Remove from list
				if( NULL == pPreviousFileItem)
				{
					pFilterExt->InternalPoll.pFirstOpenItem = pCurrentFileItem->pNextOpenItem;
				}
				else
				{
					pPreviousFileItem->pNextOpenItem = pCurrentFileItem->pNextOpenItem;
				}
				//Decrement number of open file objects
				GCK_IP_RemoveSharing(&pFilterExt->InternalPoll.ShareStatus, pCurrentFileItem->usSharing, pCurrentFileItem->ulAccess);

				//Free memory allocate for FileOpenItem
				ExFreePool(pCurrentFileItem);
			}
			//Return Successfully
			GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_RemoveFileObject(1) STATUS_SUCCESS\n"));
			return STATUS_SUCCESS;
		}
		pPreviousFileItem = pCurrentFileItem;
		pCurrentFileItem = pCurrentFileItem->pNextOpenItem;
	}
	//If we are here the file object is not in our list.  Either it was never added
	//or is was removed
	ASSERT(FALSE);
	GCK_DBG_EXIT_PRINT(("Exiting GCK_IP_ConfirmFileObject(2) STATUS_UNSUCCESSFUL\n"));
	return STATUS_UNSUCCESSFUL;
}

BOOLEAN
GCK_IP_CheckSharing
(
	IN SHARE_STATUS ShareStatus,
	IN USHORT usDesiredShareAccess,
	IN ULONG ulDesiredAccess
)
{
	//Check that no-one has exclusive access to the desire access
	if(
		( (ulDesiredAccess & FILE_WRITE_DATA) && (ShareStatus.SharedWrite < ShareStatus.OpenCount) ) ||
		( (ulDesiredAccess & FILE_READ_DATA) && (ShareStatus.SharedRead < ShareStatus.OpenCount) )
	)
	{
		return FALSE;
	}
	
	//Check that not requesting exclusive access, if already open
	if(
		( !(usDesiredShareAccess & FILE_SHARE_READ) && ShareStatus.Readers) ||
		( !(usDesiredShareAccess & FILE_SHARE_WRITE) && ShareStatus.Writers) ||
		(!usDesiredShareAccess && ShareStatus.OpenCount)
	)
	{
		return FALSE;
	}

	//This would be approved
	return TRUE;
}

BOOLEAN
GCK_IP_AddSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
)
{
	//We assume this was checked before requested
	ASSERT(GCK_IP_CheckSharing(*pShareStatus, usDesiredShareAccess, ulDesiredAccess));
	pShareStatus->OpenCount++;
	if(usDesiredShareAccess & FILE_SHARE_READ) pShareStatus->SharedRead++;
	if(usDesiredShareAccess & FILE_SHARE_WRITE) pShareStatus->SharedWrite++;
	if(ulDesiredAccess & FILE_WRITE_DATA) pShareStatus->Writers++;
	if(ulDesiredAccess & FILE_READ_DATA) pShareStatus->Readers++;
	return TRUE;
}

BOOLEAN
GCK_IP_RemoveSharing
(
	IN OUT	SHARE_STATUS *pShareStatus,
	IN		USHORT usDesiredShareAccess,
	IN		ULONG ulDesiredAccess
)
{
	pShareStatus->OpenCount--;
	if(usDesiredShareAccess & FILE_SHARE_READ) pShareStatus->SharedRead--;
	if(usDesiredShareAccess & FILE_SHARE_WRITE) pShareStatus->SharedWrite--;
	if(ulDesiredAccess & FILE_WRITE_DATA) pShareStatus->Writers--;
	if(ulDesiredAccess & FILE_READ_DATA) pShareStatus->Readers--;
	return TRUE;
}

typedef struct _GCK_INTERNEL_WorkItemExtension
{
	WORK_QUEUE_ITEM WorkItem;
	PGCK_FILTER_EXT pFilterExt;
} GCK_INTERNEL_WorkItemExtension;

VOID GCK_IP_WorkItem
(
	IN PVOID pvContext
)
{
	GCK_INTERNEL_WorkItemExtension* pWIExtension = (GCK_INTERNEL_WorkItemExtension*)pvContext;

 	if (pWIExtension != NULL)
	{
		GCKF_IncomingReadRequests(pWIExtension->pFilterExt, NULL);
		ExFreePool(pWIExtension);
	}
}

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_OneTimePoll(IN PGCK_FILTER_EXT pFilterExt)
**
**	@func	If a private poll is not pending, it forces one.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_OneTimePoll
(
	IN PGCK_FILTER_EXT pFilterExt 
)
{
	PIO_STACK_LOCATION pPrivateIrpStack;
	GCK_INTERNEL_WorkItemExtension* pWIExtension;
		
	//
	//	Create a polling FileObject if necessary
	//
	if(!pFilterExt->InternalPoll.fReady)
	{
		NTSTATUS NtStatus;
		if(GCK_STATE_STARTED == pFilterExt->eDeviceState)
		{
			pFilterExt->InternalPoll.InternalCreateThread=KeGetCurrentThread();
			NtStatus = GCK_IP_CreateFileObject( &pFilterExt->InternalPoll.pInternalFileObject, pFilterExt->pPDO);
			pFilterExt->InternalPoll.InternalCreateThread=NULL;
			if( NT_SUCCESS(NtStatus) )
			{
				pFilterExt->InternalPoll.fReady = TRUE;
			}
			else
			{
				return STATUS_DEVICE_NOT_CONNECTED;
			}
		}
		else
		{
			return STATUS_DEVICE_NOT_CONNECTED;
		}
	}

	//	If an read IRP is not pending, post one
/*	if( pFilterExt->InternalPoll.fReadPending )
	{
		//If an IRP is pending, we're done
		return STATUS_SUCCESS;
	}

  // Mark a read pending
	pFilterExt->InternalPoll.fReadPending = TRUE;
*/	if (InterlockedExchange(&pFilterExt->InternalPoll.fReadPending, TRUE) == TRUE)
	{
		return STATUS_SUCCESS;
	}


	//Otherwise Post an IRP
	GCK_DBG_RT_WARN_PRINT(("No IRP Pending, posting one.\n"));
	

	// Give a change for the LEDs to update (we fake an incoming request)
	pWIExtension = 	(GCK_INTERNEL_WorkItemExtension*)(EX_ALLOCATE_POOL(NonPagedPool, sizeof(GCK_INTERNEL_WorkItemExtension)));
	if (pWIExtension != NULL)
	{
		pWIExtension->pFilterExt = pFilterExt;
		ExInitializeWorkItem(&pWIExtension->WorkItem, GCK_IP_WorkItem, (void*)(pWIExtension));

		// Need to callback at IRQL PASSIVE_LEVEL
		ExQueueWorkItem(&pWIExtension->WorkItem, DelayedWorkQueue);
		pWIExtension = NULL;	// Will be deleted by the work item routine
	}
	
	//Setup the file object for out internal IRP
	GCK_DBG_RT_WARN_PRINT(("Copying File object.\n"));
	pPrivateIrpStack = IoGetNextIrpStackLocation(pFilterExt->InternalPoll.pPrivateIrp);
	pPrivateIrpStack->FileObject = pFilterExt->InternalPoll.pInternalFileObject;
	
	// Reset status
	pFilterExt->InternalPoll.pPrivateIrp->IoStatus.Information = 0;
	pFilterExt->InternalPoll.pPrivateIrp->IoStatus.Status = STATUS_SUCCESS;

	// Reset the ByteOffset, Length
	pPrivateIrpStack->Parameters.Read.ByteOffset.QuadPart = 0;
	pPrivateIrpStack->Parameters.Read.Key = 0;
	pPrivateIrpStack->Parameters.Read.Length =
	(ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength;

	// Set Completion routine to process poll after it is complete.
	GCK_DBG_RT_WARN_PRINT(("Setting completion routine.\n"));
	ASSERT(pFilterExt->InternalPoll.pPrivateIrp);

	IoSetCompletionRoutine(
		pFilterExt->InternalPoll.pPrivateIrp,
		GCK_IP_ReadComplete,
		(PVOID)pFilterExt,
		TRUE,
		TRUE,
		TRUE
	);
				
	// We are about to generate another IRP so increment outstanding IO count 
	GCK_IncRemoveLock(&pFilterExt->RemoveLock);

	// Send IRP down to driver
	GCK_DBG_RT_WARN_PRINT(("Calling down to next driver.\n"));
	return IoCallDriver (pFilterExt->pTopOfStack, pFilterExt->InternalPoll.pPrivateIrp);
}

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_FullTimePoll(IN PGCK_FILTER_EXT pFilterExt, IN BOOLEAN fStart)
**
**	@func	Turns FullTime internal polling on or off.  Actually changes a refcount.
**			When the refcount goes to zero, polling is off, otherwise it is on.  Calls
**			GCK_IP_OneTimePoll which may be necessary to get ball rolling.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_FullTimePoll
(
    IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fStart
)
{
	//Change number of requests for continuous background polling.
	if(fStart)
	{
		pFilterExt->InternalPoll.ulInternalPollRef++;
		ASSERT( 0!= pFilterExt->InternalPoll.ulInternalPollRef);
		//There is no thread, the completion routine recycles the IRP
		//and polls again if pFilterExt->InternalPoll.ulInternalPollRef > 0
		//we need to hit GCK_IP_OneTimePoll just to get the ball rolling though.
		if(GCK_STATE_STARTED == pFilterExt->eDeviceState )
		{
			return GCK_IP_OneTimePoll(pFilterExt);
		}
		return STATUS_SUCCESS;
	}
	
	//We need to decrment the refcount.
	ASSERT( 0 != pFilterExt->InternalPoll.ulInternalPollRef);
	if(0 != pFilterExt->InternalPoll.ulInternalPollRef)
	{
		pFilterExt->InternalPoll.ulInternalPollRef--;
	}
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS	GCK_IP_ReadComplete (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, IN PVOID pContext)
**
**	@func	When a Private IRP is completed handles processing the data.  Also
**			important is that it repolls internall if pFilterExt->InternalPoll.ulInternalPollRef
**			is greater than zero.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_ReadComplete (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
 )
{	
	PGCK_FILTER_EXT		pFilterExt;
	PVOID				pvReportBuffer;
	
	UNREFERENCED_PARAMETER(pDeviceObject);
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_ReadComplete. pDO = 0x%0.8x, pIrp = 0x%0.8x, pContext = 0x%0.8x\n", pDeviceObject, pIrp, pContext));

	// Cast context to device extension
	pFilterExt = (PGCK_FILTER_EXT) pContext;
	
	// Just an extra sanity check
	ASSERT(	GCK_DO_TYPE_FILTER == pFilterExt->ulGckDevObjType);

	//	Get Pointer to data
	ASSERT(pIrp);

	pvReportBuffer = GCK_GetSystemAddressForMdlSafe(pIrp->MdlAddress);
	if(pvReportBuffer)
    {
	    //	Tell filter we have new data
	    GCKF_IncomingInputReports(pFilterExt, pvReportBuffer, pIrp->IoStatus);
    }
	    
	//**
	//**	At this point we are done with the IRP
	//**	Need not complete it, it will be recycled.
	//**
	
	//	Decrement outstanding IRP count
	GCK_DecRemoveLock(&pFilterExt->RemoveLock);

	//	Read is no longer pending
	pFilterExt->InternalPoll.fReadPending = FALSE;
	
	//If the InternalPollRef is greater than zero,
	//we need to be polling ourselves continuously
    //but don't carry on if some catestrophic failure 
    //occured which lead to a MDL mapping failure
	if( pvReportBuffer
     && (pFilterExt->InternalPoll.ulInternalPollRef) )
	{
		GCK_IP_OneTimePoll(pFilterExt);
	}

	//We don't want any cleanup to happen
	return STATUS_MORE_PROCESSING_REQUIRED;
}

void GCK_IP_AddDevice(PGCK_FILTER_EXT pFilterExt)
{
	KeInitializeSpinLock(&pFilterExt->InternalPoll.InternalPollLock);
	pFilterExt->InternalPoll.ShareStatus.OpenCount = 0;
	pFilterExt->InternalPoll.ShareStatus.Readers = 0;
	pFilterExt->InternalPoll.ShareStatus.Writers = 0;
	pFilterExt->InternalPoll.ShareStatus.SharedRead = 0;
	pFilterExt->InternalPoll.ShareStatus.SharedWrite = 0;
	pFilterExt->InternalPoll.fReadPending = FALSE;
	pFilterExt->InternalPoll.ulInternalPollRef = 0;
	pFilterExt->InternalPoll.pFirstOpenItem = NULL;
	pFilterExt->InternalPoll.fReady = FALSE;
}
/***********************************************************************************
**
**	NTSTATUS GCK_IP_Init (IN OUT PGCK_FILTER_EXT pFilterExt);
**
**	@func	As part of the initialization that occurs at the end of Start device on
**			a filtered device, the filter must be prepared for internal polling.
**			All data polling is internal. (IRP_MJ_READ are sent down directly once
**			so that hidclass.sys can perform its security check, but the data from
**			that poll is discarded.)  Initialize InternalPoll Data in Device Extension
**			including creating a pInternalFileObject, a pPrivateIRP and an associtated
**			Buffer.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_Init
(
	IN OUT PGCK_FILTER_EXT pFilterExt
)
{
	//NTSTATUS NtStatus;
	LARGE_INTEGER lgiBufferOffset;

	//Initialize the Internal Poll Structure
	pFilterExt->InternalPoll.pInternalFileObject = NULL;
	pFilterExt->InternalPoll.pPrivateIrp = NULL;
	pFilterExt->InternalPoll.pucReportBuffer = NULL;

	//	Allocate a Buffer for the private IRP_MJ_READ
	pFilterExt->InternalPoll.pucReportBuffer = (PUCHAR)	EX_ALLOCATE_POOL
											( NonPagedPool,
											  pFilterExt->HidInfo.HidPCaps.InputReportByteLength );
	if(!pFilterExt->InternalPoll.pucReportBuffer)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate Report Buffer for private IRPs\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	
	//  Allocate private recyclable IRPs for internal polling
	lgiBufferOffset.QuadPart = 0;
	pFilterExt->InternalPoll.pPrivateIrp = 	IoBuildAsynchronousFsdRequest 
											(
												IRP_MJ_READ,
												pFilterExt->pTopOfStack,
												pFilterExt->InternalPoll.pucReportBuffer,
												(ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength,
												&lgiBufferOffset,
												NULL
											);

	if(!pFilterExt->InternalPoll.pPrivateIrp)
	{
		GCK_DBG_CRITICAL_PRINT(("Failed to allocate private Ping-Pong IRP\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
		
	// Initialize status for very first IRP
	pFilterExt->ioLastReportStatus.Information = (ULONG)pFilterExt->HidInfo.HidPCaps.InputReportByteLength;
	pFilterExt->ioLastReportStatus.Status =  STATUS_SUCCESS;

	/**
	**	Cannot do this here since build 2006 or so,
	**	so defer until the first time we need it.
	**
	**
	** //Open ourselves with a file object
	** pFilterExt->InternalPoll.InternalCreateThread=KeGetCurrentThread();
	** NtStatus = GCK_IP_CreateFileObject( &pFilterExt->InternalPoll.pInternalFileObject, pFilterExt->pTopOfStack);
	** pFilterExt->InternalPoll.InternalCreateThread=NULL;
	** if( NT_SUCCESS(NtStatus) )
	** {
	**	pFilterExt->InternalPoll.fReady = TRUE;
	** } 
	**/
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_IP_Cleanup (IN OUT PGCK_FILTER_EXT pFilterExt);
**
**	@func	Reverses Init, cancels outstanding internal polls, release pFileObject for
**			internal polls, release private IRP and buffer.  Does not release open file handles
**
**	@rdesc	STATUS_SUCCESS, STATUS_UNSUCCESSFUL if we could not cancel a pending poll
**
*************************************************************************************/
NTSTATUS
GCK_IP_Cleanup
(
	IN OUT PGCK_FILTER_EXT pFilterExt
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	if( pFilterExt->InternalPoll.fReady)
	{
		NtStatus = GCK_IP_CloseFileObject(pFilterExt);
	}
	if(NT_SUCCESS(NtStatus))
	{
		//Cleanup private IRP - and buffer, safely they may never had been allocated
		if(pFilterExt->InternalPoll.pPrivateIrp)
		{
			IoFreeIrp(pFilterExt->InternalPoll.pPrivateIrp);
			pFilterExt->InternalPoll.pPrivateIrp = NULL;
		}
		if(pFilterExt->InternalPoll.pucReportBuffer)
		{
			ExFreePool(pFilterExt->InternalPoll.pucReportBuffer);
			pFilterExt->InternalPoll.pucReportBuffer = NULL;
		}
	}	
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_IP_CreateFileObject (OUT PFILE_OBJECT *ppFileObject, IN PDEVICE_OBJECT pPDO);
**
**	@func	Calls IoGetDeviceObjectPointer, even though we already attached to the
**			and have a pointer to the device object, the caller wants to create a
**			new file object for internal calls down the stack that may require one.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS
GCK_IP_CreateFileObject
(
	OUT PFILE_OBJECT	*ppFileObject,
	IN	PDEVICE_OBJECT	pPDO
)
{
	NTSTATUS NtStatus;
	ULONG ulBufferLength = 0;
	PVOID pPDONameBuffer = NULL;
	UNICODE_STRING	uniPDOName;
	PDEVICE_OBJECT	pDeviceObject;

	//Get the size required for the PDO Name Buffer
	NtStatus = IoGetDeviceProperty(
					pPDO,
					DevicePropertyPhysicalDeviceObjectName,
					ulBufferLength,
					pPDONameBuffer,
					&ulBufferLength
					);
	ASSERT(STATUS_BUFFER_TOO_SMALL==NtStatus);

	//Allocate space
	pPDONameBuffer = EX_ALLOCATE_POOL(NonPagedPool, ulBufferLength);
	if(!pPDONameBuffer)
	{
		return STATUS_NO_MEMORY;
	}

	//Get PDO Name
	NtStatus = IoGetDeviceProperty(
					pPDO,
					DevicePropertyPhysicalDeviceObjectName,
					ulBufferLength,
					pPDONameBuffer,
					&ulBufferLength
					);
	ASSERT(NT_SUCCESS(NtStatus));
	if( NT_ERROR(NtStatus) )
	{
		return NtStatus;
	}

	//Make PDO Name into UNICODE string
	RtlInitUnicodeString(&uniPDOName, pPDONameBuffer);

	//Call IoGetDeviceObjectPointer to create a FILE_OBJECT
	NtStatus = IoGetDeviceObjectPointer(
					&uniPDOName,
					FILE_READ_DATA,
					ppFileObject,
					&pDeviceObject
					);
	ASSERT(NT_SUCCESS(NtStatus));

	//Release the space for Name
	ExFreePool(pPDONameBuffer);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_IP_CloseFileObject (OUT PFILE_OBJECT *ppFileObject, IN PDEVICE_OBJECT pPDO);
**
**	@func	Stops outstanding IO to hidclass.sys and closes handle
**	@rdesc	STATUS_SUCCESS, or STATUS_UNSUCCESSFUL
**
*************************************************************************************/
NTSTATUS
GCK_IP_CloseFileObject
(
	IN OUT PGCK_FILTER_EXT pFilterExt	
)
{
	NTSTATUS NtStatus;
	BOOLEAN fResult = TRUE;
	
	//Turn off internal polling
	pFilterExt->InternalPoll.fReady = FALSE;
	
	//Cancel pending internal polls
	if(pFilterExt->InternalPoll.fReadPending)
	{
		ASSERT(pFilterExt->InternalPoll.pPrivateIrp);
		fResult = IoCancelIrp(pFilterExt->InternalPoll.pPrivateIrp);
	}

	if(!fResult)
	{
		return STATUS_UNSUCCESSFUL;
	}
	
	//***
	//***If we are here, there are no pending polls, and there shall be no pending polls.
	//***

	//Release internal file object - if it had been created successfully
	if(pFilterExt->InternalPoll.pInternalFileObject)
	{
		ObDereferenceObject((PVOID)pFilterExt->InternalPoll.pInternalFileObject);
		pFilterExt->InternalPoll.pInternalFileObject=NULL;
	}

	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\purecall.c ===
//
//	purecall.c - required for using virtual functions in driver on win98.
//				 not required for NT5, but does no harm.
//				 basically this function must be defined.
#include <wdm.h>
#include "debug.h"
int _cdecl _purecall( void )
{
    ASSERT(FALSE && "Attempt to call pure virtual function!");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\remlock.c ===
//	@doc
/**********************************************************************
*
*	@module	RemLock.c	|
*
*	Implements Remove Lock utilities for keeping track of the driver.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	RemLock	|
*			This module was written to make the numerous increments and
*			and decrements of Outstanding IO easier to manage.
*			An increment and a decrment (even the final one), is reduced
*			to a one line function everywhere.  Furthermore, this module
*			can have traceouts turned on independently just for testing
*			this aspect of the driver.<nl>
*			This is similar to the IoAcquireRemoveLock, except that
*			to the best of my knowledge is not available on Win98.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_REMLOCK_C

#include <wdm.h>
#include "debug.h"
#include "RemLock.h"

DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
//DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL));

#if (DBG==1)
void GCK_InitRemoveLockChecked(PGCK_REMOVE_LOCK pRemoveLock, PCHAR pcInstanceID)
{
	pRemoveLock->pcInstanceID = pcInstanceID;
	GCK_DBG_TRACE_PRINT(("Initializing remove lock \'%s\' to one.\n", pRemoveLock->pcInstanceID));
	pRemoveLock->lRemoveLock = 1;
	KeInitializeEvent(&pRemoveLock->RemoveLockEvent, SynchronizationEvent, FALSE);
}
#else
void GCK_InitRemoveLockFree(PGCK_REMOVE_LOCK pRemoveLock)
{
	pRemoveLock->lRemoveLock = 1;
	KeInitializeEvent(&pRemoveLock->RemoveLockEvent, SynchronizationEvent, FALSE);
}
#endif

void GCK_IncRemoveLock(PGCK_REMOVE_LOCK pRemoveLock)
{
	LONG lNewCount = InterlockedIncrement(&pRemoveLock->lRemoveLock);
	GCK_DBG_TRACE_PRINT(("\'%s\', Incremented Remove Lock to %d.\n", pRemoveLock->pcInstanceID, lNewCount));
}

void GCK_DecRemoveLock(PGCK_REMOVE_LOCK pRemoveLock)
{
	LONG lNewCount = InterlockedDecrement(&pRemoveLock->lRemoveLock);
	if (0 >= lNewCount)
	{
		GCK_DBG_TRACE_PRINT(("\'%s\', Last IRP completed.\n", pRemoveLock->pcInstanceID));
		KeSetEvent (&pRemoveLock->RemoveLockEvent, IO_NO_INCREMENT, FALSE);
	}
	GCK_DBG_TRACE_PRINT(("\'%s\', Decremented Remove Lock to %d\n", pRemoveLock->pcInstanceID, lNewCount));

}

NTSTATUS GCK_DecRemoveLockAndWait(PGCK_REMOVE_LOCK pRemoveLock, PLARGE_INTEGER plgiWaitTime)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
	LONG lNewCount = InterlockedDecrement(&pRemoveLock->lRemoveLock);
	if (0 < lNewCount)
	{
		GCK_DBG_TRACE_PRINT(("\'%s\', Decremented Remove Lock to %d, waiting for final unlock.\n",
							 pRemoveLock->pcInstanceID,
							 lNewCount));
		NtStatus = KeWaitForSingleObject (
					&pRemoveLock->RemoveLockEvent,
					Executive,
					KernelMode,
					FALSE,
					plgiWaitTime
					);
	}

	#if (DBG==1)
	if(STATUS_SUCCESS == NtStatus)
	{
		GCK_DBG_EXIT_PRINT(("\'%s\', GCK_DecRemoveLockAndWait exiting - Remove Lock went to zero.\n", pRemoveLock->pcInstanceID));
	}
	else
	{
		GCK_DBG_CRITICAL_PRINT(("\'%s\', Remove Lock is still %d, should be zero.\n", pRemoveLock->lRemoveLock));
		GCK_DBG_EXIT_PRINT(("\'%s\', GCK_DecRemoveLockAndWait exiting - timed out.\n", pRemoveLock->pcInstanceID));
	}
	#endif
	return NtStatus;
}

/*
 *  Avoid bugchecks by requesting a failable mapping.
 *  Error check that was added to calling functions is limited to 
 *  only avoiding partying on a NULL pointer.  Correct functioning 
 *  is not expected.
 */
PVOID GCK_GetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= (~MDL_MAPPING_CAN_FAIL);
    }
    else {
		GCK_DBG_CRITICAL_PRINT(("MdlAddress passed into GetSystemAddress is NULL\n"));
    }
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\irpqueue.h ===
#ifndef __IrpQueue_h__
#define __IrpQueue_h__

extern "C"
{
	#include <wdm.h>
}

class CTempIrpQueue
{
		friend class CGuardedIrpQueue;
	public:
		CTempIrpQueue()
		{
			InitializeListHead(&m_QueueHead);
			m_fLIFO = FALSE;
		}
		~CTempIrpQueue()
		{
			ASSERT(IsListEmpty(&m_QueueHead));
		}
		PIRP Remove();
	
	private:
		LIST_ENTRY	m_QueueHead;
		BOOLEAN		m_fLIFO;
};

class CGuardedIrpQueue
{
	public:
		friend void _stdcall DriverCancel(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
		friend class CShareIrpQueueSpinLock;
		typedef void (_stdcall*PFN_DEC_IRP_COUNT)(PVOID pvContext);
		//c'tor's and d'tors are often not called in drivers, either
		//because the instance is global, or because they are a part of a
		//larger structure (such as a DeviceExtension) which is allocated as
		//an unstructured block of memory, so we insist that they do nothing.
		//call Init and Destroy instead. (A more systematic approach to C++
		//in a driver could solve this problem).
		CGuardedIrpQueue(){}
		~CGuardedIrpQueue(){}
		void Init(int iFlags, PFN_DEC_IRP_COUNT pfnDecIrpCount, PVOID pvContext);
		void Destroy(NTSTATUS NtStatus=STATUS_DELETE_PENDING);
		NTSTATUS Add(PIRP pIrp);
		PIRP Remove();
		PIRP RemoveByPointer(PIRP pIrp);
		ULONG RemoveByFileObject(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue);
		ULONG RemoveAll(CTempIrpQueue *pTempIrpQueue);
		void CancelIrp(PIRP pIrp);
		void CancelByFileObject(PFILE_OBJECT pFileObject);
		void CancelAll(NTSTATUS NtStatus = STATUS_CANCELLED);
		
		//Flags for constructor
		static const int CANCEL_IRPS_ON_DELETE;	//= 0x00000001;
		static const int PRESERVE_QUEUE_ORDER;	//= 0x00000002;
		static const int LIFO_QUEUE_ORDER;		//= 0x00000004;

	private:
		//The real cancel routine
		void CancelRoutine(PIRP pIrp);
		//Implementation sans spin locks
		NTSTATUS AddImpl(PIRP pIrp, KIRQL OldIrql);
		PIRP RemoveImpl();
		PIRP RemoveByPointerImpl(PIRP pIrp);
		ULONG RemoveByFileObjectImpl(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue);
		ULONG RemoveAllImpl(CTempIrpQueue *pTempIrpQueue);
		
		
		LIST_ENTRY			m_QueueHead;
		KSPIN_LOCK			m_QueueLock;
		int					m_iFlags;
		PFN_DEC_IRP_COUNT	m_pfnDecIrpCount;
		PVOID				m_pvContext;
};


//
//
//	@class CShareIrpQueueSpinLock | Allows sharing of SpinLock from CGuardedIrpQueue
//
//	@topic Using CShareIrpQueueSpinLock |
//			** Should only be instantiated on the stack.
//			** A single instance should be used by only one thread. i.e. no static instances
//			** Inside a single function, do not CGuardedIrpQueue's accessor, rather
//			** use the interface provided by CShareIrpQueueSpinLock
//
class CShareIrpQueueSpinLock
{
	public:
		CShareIrpQueueSpinLock(CGuardedIrpQueue *pIrpQueue) : 
			m_pIrpQueue(pIrpQueue),
			m_fIsHeld(FALSE)
			#if (DBG==1)
			,m_debug_ThreadContext(KeGetCurrentThread())
			#endif
			{}
		~CShareIrpQueueSpinLock()
		{
			ASSERT(!m_fIsHeld && "You must release (or AddAndRelease) the spin lock before this instance goes of scope!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack" );
		}
		//Functions to access mutex
		void Acquire()
		{
			ASSERT(!m_fIsHeld &&  "An attempt to acquire a spin lock twice in the same thread!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			m_fIsHeld = TRUE;
			KeAcquireSpinLock(&m_pIrpQueue->m_QueueLock, &m_OldIrql);
		}
		void Release()
		{
			ASSERT(m_fIsHeld &&  "An attempt to release a spin lock that had not been acquired, (reminder: AddAndRelease also Releases)!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			m_fIsHeld = FALSE;
			KeReleaseSpinLock(&m_pIrpQueue->m_QueueLock, m_OldIrql);
		}
		//Functions to access IrpQueue
		NTSTATUS AddAndRelease(PIRP pIrp)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			m_fIsHeld=FALSE;
			return m_pIrpQueue->AddImpl(pIrp, m_OldIrql);
		}
		PIRP Remove()
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveImpl();
		}
		PIRP RemoveByPointer(PIRP pIrp)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveByPointerImpl(pIrp);
		}
		ULONG RemoveByFileObject(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveByFileObjectImpl(pFileObject,pTempIrpQueue);
		}
		ULONG RemoveAll(CTempIrpQueue *pTempIrpQueue)
		{
			ASSERT(m_fIsHeld && "Use CGuardedIrpQueue if you do not need to share the SpinLock!");
			ASSERT(m_debug_ThreadContext==KeGetCurrentThread() && "class instance should be on local stack!");
			return m_pIrpQueue->RemoveAllImpl(pTempIrpQueue);
		}
	private:
		CGuardedIrpQueue *m_pIrpQueue;
		BOOLEAN			  m_fIsHeld;
		KIRQL			  m_OldIrql;
		#if (DBG==1)
		PKTHREAD		  m_debug_ThreadContext;
		#endif
};
#endif //__IrpQueue_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\irpqueue.cpp ===
#include <IrpQueue.h>
#include <winerror.h>	// For S_OK, S_FALSE, and E_UNEXPECTED

#pragma optimize("w",off)
#pragma optimize("a",off)
const int CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE	= 0x00000001;
const int CGuardedIrpQueue::PRESERVE_QUEUE_ORDER	= 0x00000002;
const int CGuardedIrpQueue::LIFO_QUEUE_ORDER		= 0x00000004;

PIRP CTempIrpQueue::Remove()
{
	
	PIRP pIrp = NULL;
	if(!IsListEmpty(&m_QueueHead))
	{
		PLIST_ENTRY pListEntry;
		if(m_fLIFO)
		{
			pListEntry = RemoveTailList(&m_QueueHead);
		}
		else
		{
			pListEntry = RemoveHeadList(&m_QueueHead);
		}
		
		//	Get the IRP from the ListEntry in the IRP
		pIrp = (PIRP)CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
	}
	return pIrp;
}

void _stdcall DriverCancel(PDEVICE_OBJECT, PIRP pIrp)
{
	CGuardedIrpQueue *pGuardedIrpQueue;
	pGuardedIrpQueue = reinterpret_cast<CGuardedIrpQueue *>(pIrp->Tail.Overlay.DriverContext[3]);
	pGuardedIrpQueue->CancelIrp(pIrp);
}

void CGuardedIrpQueue::Init(int iFlags, PFN_DEC_IRP_COUNT pfnDecIrpCount, PVOID pvContext)
{
	m_iFlags = iFlags;
	m_pfnDecIrpCount = pfnDecIrpCount;
	m_pvContext = pvContext;
	InitializeListHead(&m_QueueHead);
	KeInitializeSpinLock(&m_QueueLock);
}

void CGuardedIrpQueue::Destroy(NTSTATUS NtStatus)
{
	if(m_iFlags & CANCEL_IRPS_ON_DELETE)
	{
		CancelAll(NtStatus);
	}
	ASSERT(IsListEmpty(&m_QueueHead));
}

NTSTATUS CGuardedIrpQueue::Add(PIRP pIrp)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	return AddImpl(pIrp, OldIrql);
}
PIRP CGuardedIrpQueue::Remove()
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	PIRP pIrp = RemoveImpl();
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return pIrp;
}
PIRP CGuardedIrpQueue::RemoveByPointer(PIRP pIrp)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	pIrp = RemoveByPointerImpl(pIrp);
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return pIrp;
}
ULONG CGuardedIrpQueue::RemoveByFileObject(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	ULONG ulReturn = RemoveByFileObjectImpl(pFileObject, pTempIrpQueue);
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return ulReturn;
}
ULONG CGuardedIrpQueue::RemoveAll(CTempIrpQueue *pTempIrpQueue)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&m_QueueLock, &OldIrql);
	ULONG ulReturn = RemoveAllImpl(pTempIrpQueue);
	KeReleaseSpinLock(&m_QueueLock, OldIrql);
	return ulReturn;
}

NTSTATUS CGuardedIrpQueue::AddImpl(PIRP pIrp, KIRQL	OldIrql)
{
	
	BOOLEAN fCancelHere = FALSE;
	
	//	Mark incoming IRP pending
	IoMarkIrpPending(pIrp);

	//  mark IRP in DriverContext so that we can find this instance of the queue
	//	in the cancel routine
	pIrp->Tail.Overlay.DriverContext[3] = reinterpret_cast<PVOID>(this);

	//	Set our cancel routine
	IoSetCancelRoutine(pIrp, DriverCancel);

	//If the IRP was cancelled before it got to us, don't queue it, mark
	//it to cancel after we release the lock (a few lines down)
	if(pIrp->Cancel)
	{
		IoSetCancelRoutine(pIrp, NULL);
		fCancelHere = TRUE;
	}
	else
	//Queue IRP unless it was marked to cancel
	{
		//	Insert Item in Queue (items always added at the tail)
		InsertTailList(&m_QueueHead, &pIrp->Tail.Overlay.ListEntry);
	}
	
	//Release spin lock
	KeReleaseSpinLock(&m_QueueLock, OldIrql);

	//If it had been marked for cancel, do it here
	if(fCancelHere)
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_CANCELLED;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
		return STATUS_CANCELLED;
	}
	
	//	return Pending as we have queued the IRP
	return STATUS_PENDING;
}

PIRP CGuardedIrpQueue::RemoveImpl()
{
	KIRQL		OldIrql;
	PIRP		pReturnIrp = NULL;
	PLIST_ENTRY	pListEntry;

	//	Skip getting the IRP and all, if queue is empty
	if(!IsListEmpty(&m_QueueHead))
	{
		//Remove head or tail depending on LIFO or FIFO (we always add to the tail)
		if(m_iFlags & LIFO_QUEUE_ORDER)
		{
			pListEntry = RemoveTailList(&m_QueueHead);
		}
		else
		{
			pListEntry = RemoveHeadList(&m_QueueHead);
		}
		
		//	Get the IRP from the ListEntry in the IRP
		pReturnIrp = (PIRP)CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

		// Unset the cancel routine
		IoSetCancelRoutine(pReturnIrp, NULL);
	}

	//	Return the IRP, or NULL if there weren't any
	return pReturnIrp;
}

PIRP CGuardedIrpQueue::RemoveByPointerImpl(PIRP pIrp)
{

	PIRP		pFoundIrp = NULL;
	PIRP		pCurrentIrp;
	PLIST_ENTRY	pCurrentListEntry;
	PLIST_ENTRY	pQueueFirstItem = NULL;

	//	Pop IRPs off the queue and put them back until we find it
	if( !IsListEmpty(&m_QueueHead) )
	{
		pCurrentListEntry = RemoveHeadList(&m_QueueHead);
		pQueueFirstItem = pCurrentListEntry;
		do{
			//Get the IRP from the entry
			pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
			
			//Check for match
			if(pCurrentIrp == pIrp)
			{
				
				ASSERT(!pFoundIrp); //serious error, means IRP was in queue twice
				pFoundIrp = pCurrentIrp;

				//clear the cancel routine (do it here, as we still have the spin lock)
				IoSetCancelRoutine(pFoundIrp, NULL);
						
				// If we need to preserve the queue order,
				// keep removing and adding until we are through the list once
				if( m_iFlags & PRESERVE_QUEUE_ORDER )
				{
					//If the list is now empty we are done
					if(IsListEmpty(&m_QueueHead))
					{
						break;
					}
					
					//	The found entry is not going, back in the list
					//	so if it was first, it no longer is.
					if(pQueueFirstItem == pCurrentListEntry)
					{
						pQueueFirstItem = NULL;
					}

					//Get the next IRP
					pCurrentListEntry = RemoveHeadList(&m_QueueHead);
					pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
					ASSERT(pFoundIrp != pCurrentIrp); //serious error, means IRP was in queue twice
				
					//If the first item is NULL (four line up), this new entry is it
					if(!pQueueFirstItem)
					{
						pQueueFirstItem = pCurrentListEntry;
					}
				}
				//If the order does not need to be preserved, we are done
				else
				{
					break;
				}
			}
			
			//This next item cannot be a match, if it was we
			//have moved on to the next one already

			//	Put the IRP back in the queue
			InsertTailList(&m_QueueHead, pCurrentListEntry);
			
			//	Get the next item (no need to check if list is empty,
			//	we just put an item in
			pCurrentListEntry = RemoveHeadList(&m_QueueHead);

			//check if done
			if (pCurrentListEntry == pQueueFirstItem)
			{
				//put it back, if we are done.
				InsertHeadList(&m_QueueHead, pCurrentListEntry);
				//Mark as NULL, so that we do not iterate again
				pCurrentListEntry = NULL;
			}
			
		} while (pCurrentListEntry);
	}

	//Return the IRP we found, or NULL if it was not in the Queue
	return pFoundIrp;
}

ULONG CGuardedIrpQueue::RemoveByFileObjectImpl(PFILE_OBJECT pFileObject, CTempIrpQueue *pTempIrpQueue)
{

	PIRP				pCurrentIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PLIST_ENTRY			pCurrentListEntry;
	PLIST_ENTRY			pQueueFirstItem = NULL;
	PLIST_ENTRY			pTempQueueListEntry;
	ULONG				ulMatchCount=0;
	
	//Get the list entry from the temp queue
	pTempQueueListEntry = &pTempIrpQueue->m_QueueHead;
	pTempIrpQueue->m_fLIFO = m_iFlags & LIFO_QUEUE_ORDER;

	//	Pop IRPs off the queue and put them back until we find it
	if( !IsListEmpty(&m_QueueHead) )
	{
		pCurrentListEntry = RemoveHeadList(&m_QueueHead);
		pQueueFirstItem = pCurrentListEntry;
		do{

			//Get the IRP from the entry
			pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
			
			//Get the Stack Location
			pIrpStack = IoGetCurrentIrpStackLocation(pCurrentIrp);
	
			//Check for matching file object
			if(pIrpStack->FileObject == pFileObject)
			{
				//Increment match count
				ulMatchCount++;

				//clear the cancel routine
				IoSetCancelRoutine(pCurrentIrp, NULL);
				
				//Move it over to the simple queue
				InsertTailList(pTempQueueListEntry, pCurrentListEntry);
				
				//If the list is empty we are done
				if( IsListEmpty(&m_QueueHead) )
				{
					break;
				}
				//If it was the first item in the list, it is no longer
				if(pQueueFirstItem == pCurrentListEntry)
				{
					pQueueFirstItem = NULL;
				}
	
				//setup for next iteration
				pCurrentListEntry = RemoveHeadList(&m_QueueHead);
								
				//If it was the first item in the list, it is no longer
				if(!pQueueFirstItem)
				{
					pQueueFirstItem = pCurrentListEntry;
				}
			}
			else
			{
				//	Put the IRP back in the queue
				InsertTailList(&m_QueueHead, pCurrentListEntry);
				
				//	Get the next item (no need to check if list is empty,
				//	we just put an item in)
				pCurrentListEntry = RemoveHeadList(&m_QueueHead);

				//check if done
				if (pCurrentListEntry == pQueueFirstItem)
				{
					//put it back, if we are done.
					InsertHeadList(&m_QueueHead, pCurrentListEntry);
					//Mark as NULL, so that we do not iterate again
					pCurrentListEntry = NULL;
				}
			}
		} while (pCurrentListEntry);
	}

	//Return the IRP we found, or NULL if it was not in the Queue
	return ulMatchCount;
}

ULONG CGuardedIrpQueue::RemoveAllImpl(CTempIrpQueue *pTempIrpQueue)
{
	PLIST_ENTRY			pCurrentListEntry;
	PIRP				pCurrentIrp;
	PLIST_ENTRY			pTempQueueListEntry;
	ULONG				ulCount=0;
	
	//Get a pointer to the simple queue's list entry
	pTempQueueListEntry = &pTempIrpQueue->m_QueueHead;
	pTempIrpQueue->m_fLIFO = m_iFlags & LIFO_QUEUE_ORDER;
	
	//Move all the items
	while(!IsListEmpty(&m_QueueHead))
	{
		ulCount++;
		//Get next IRP
		pCurrentListEntry = RemoveHeadList(&m_QueueHead);
		pCurrentIrp = CONTAINING_RECORD(pCurrentListEntry, IRP, Tail.Overlay.ListEntry);
		
		//Clear the cancel routine
		IoSetCancelRoutine(pCurrentIrp, NULL);

		//Move to other list
		InsertTailList(pTempQueueListEntry, pCurrentListEntry);
	}

	//return count
	return ulCount;
}

void CGuardedIrpQueue::CancelIrp(PIRP pIrp)
{
	PIRP pFoundIrp = RemoveByPointer(pIrp);
	
	//Release the cancel lock
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

	//If the IRP was found cancel it and decrement IRP count
	if(pFoundIrp)
	{
		pFoundIrp->IoStatus.Information = 0;
		pFoundIrp->IoStatus.Status = STATUS_CANCELLED;
		IoCompleteRequest(pFoundIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
	}
}

void CGuardedIrpQueue::CancelByFileObject(PFILE_OBJECT pFileObject)
{
	
	CTempIrpQueue TempIrpQueue;
	PIRP pFoundIrp;

	//Get all the IRP's to cancel
	RemoveByFileObject(pFileObject, &TempIrpQueue);
			
	//If the IRP was found cancel it and decrement IRP count
	while(pFoundIrp = TempIrpQueue.Remove())
	{
		pFoundIrp->IoStatus.Information = 0;
		pFoundIrp->IoStatus.Status = STATUS_CANCELLED;
		IoCompleteRequest(pFoundIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
	}
}

void CGuardedIrpQueue::CancelAll(NTSTATUS NtStatus)
{
	CTempIrpQueue TempIrpQueue;
	PIRP pFoundIrp;

	//Get all the IRP's to cancel
	RemoveAll(&TempIrpQueue);
			
	//If the IRP was found cancel it and decrement IRP count
	while(pFoundIrp = TempIrpQueue.Remove())
	{
		pFoundIrp->IoStatus.Information = 0;
		pFoundIrp->IoStatus.Status = NtStatus;
		IoCompleteRequest(pFoundIrp, IO_NO_INCREMENT);
		m_pfnDecIrpCount(m_pvContext);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\remlock.h ===
#ifndef __REMLOCK_H__
#define __REMLOCK_H__
//	@doc
/**********************************************************************
*
*	@module	RemLock.h	|
*
*	Definitions for managing GCK_REMOVE_LOCKs
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	RemLock	|
*			The structure and four functions greatly
*			simplify keep track of outstanding IO. 
*	@xref	Remlock.cpp
*
**********************************************************************/
typedef struct tagGCK_REMOVE_LOCK
{
	LONG	lRemoveLock;
	KEVENT	RemoveLockEvent;
	PCHAR	pcInstanceID;
} GCK_REMOVE_LOCK, *PGCK_REMOVE_LOCK;

#if (DBG==1)
#define GCK_InitRemoveLock(__x__, __y__) GCK_InitRemoveLockChecked(__x__,__y__)
void GCK_InitRemoveLockChecked(PGCK_REMOVE_LOCK pRemoveLock, PCHAR pcInstanceID);
#else
#define GCK_InitRemoveLock(__x__, __y__) GCK_InitRemoveLockFree(__x__)
void GCK_InitRemoveLockFree(PGCK_REMOVE_LOCK pRemoveLock);
#endif




void GCK_IncRemoveLock(PGCK_REMOVE_LOCK pRemoveLock);
void GCK_DecRemoveLock(PGCK_REMOVE_LOCK pRemoveLock);
NTSTATUS GCK_DecRemoveLockAndWait(PGCK_REMOVE_LOCK pRemoveLock, PLARGE_INTEGER plgiTimeOut);
PVOID GCK_GetSystemAddressForMdlSafe(PMDL MdlAddress);

#endif //__REMLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GcKernel.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\internalpoll.h ===
//
//	@struct GCK_FILE_OPEN_ITEM | Status of open file handles.
//
typedef struct tagGCK_FILE_OPEN_ITEM
{
	BOOLEAN				fReadPending;					// @field TRUE if read is pending to driver
	BOOLEAN				fConfirmed;						// @field TRUE means that the lower driver has already completed the open
	ULONG				ulAccess;						// @field represents permissions this was opened with
	USHORT				usSharing;						// @field represents sharing under which this was opened
	FILE_OBJECT			*pFileObject;					// @field Pointer to file object which this status describes
	struct tagGCK_FILE_OPEN_ITEM	*pNextOpenItem;		// @field Next structure in Linked List
} GCK_FILE_OPEN_ITEM, *PGCK_FILE_OPEN_ITEM;

typedef struct _SHARE_STATUS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    //ULONG Deleters;	//We are driver without delete symantics
    ULONG SharedRead;
    ULONG SharedWrite;
    //ULONG SharedDelete; //We are driver without delete symantics
} SHARE_STATUS, *PSHARE_STATUS;

//
//	@struct GCK_INTERNAL_POLL | Information needed for the iternal polling routines
//
typedef struct tagGCK_INTERNAL_POLL
{
	KSPIN_LOCK			InternalPollLock;			// @field SpinLock to serialize access to this structue (not all items require it)
	FILE_OBJECT			*pInternalFileObject;		// @field Pointer to File Object that was created for internal polls
	PGCK_FILE_OPEN_ITEM	pFirstOpenItem;				// @field Head of linked list of GCK_FILE_OPEN_ITEMs for open files
	SHARE_STATUS		ShareStatus;				// @field Keeps track of file sharing.
//	BOOLEAN				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
	LONG				fReadPending;				// @field TRUE if Read IRP to lower driver is pending
    PIRP				pPrivateIrp;				// @field IRP we reuse to send Read IRPs to lower driver
    PUCHAR				pucReportBuffer;			// @field Buffer for getting Report with pPrivateIrp
	ULONG				ulInternalPollRef;			// @field Reference to internal polls
	PKTHREAD			InternalCreateThread;		// @field Used to figure out if a create is for the internal file object
	BOOLEAN				fReady;						// @field TRUE whenever the internal polling module is good to go.
} GCK_INTERNAL_POLL, *PGCK_INTERNAL_POLL;


NTSTATUS
GCK_IP_AddFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS
GCK_IP_RemoveFileObject
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PFILE_OBJECT pFileObject
);

NTSTATUS
GCK_IP_ApproveReadIrp
(
	IN PGCK_FILTER_EXT pFilterExt,
	IN PIRP
);

NTSTAUTS
GCK_IP_ReadApprovalComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    );
);

NTSTATUS
GCK_IP_OneTimePoll
(
	IN PGCK_FILTER_EXT pFilterExt, 
);

NTSTATUS
GCK_IP_FullTimePoll
(
    IN PGCK_FILTER_EXT pFilterExt,
	IN BOOLEAN fStart
);

NTSTATUS
GCK_IP_ReadComplete (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    );


NTSTATUS
GCK_IP_Init
(
	IN PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_Cleanup
(
	IN OUT PGCK_FILTER_EXT pFilterExt
);

NTSTATUS
GCK_IP_CreateFileObject
(
	OUT PFILE_OBJECT	*ppFileObject,
	IN	PDEVICE_OBJECT	pPDO
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\setdebuglevel.c ===
#include <wdm.h>
#include "gckshell.h"
#include "debug.h"

#if (DBG==1)

extern ULONG GCK_CTRL_C;
extern ULONG GCK_CTRL_IOCTL_C;
extern ULONG GCK_FILTER_CPP;
extern ULONG GCK_FILTERHOOKS_CPP;
extern ULONG GCK_FLTR_C;
extern ULONG GCK_FLTR_PNP_C;
extern ULONG GCK_GCKSHELL_C;
extern ULONG GCK_REMLOCK_C;
extern ULONG GCK_SWVB_PNP_C;
extern ULONG GCK_SWVBENUM_C;
extern ULONG GCK_SWVKBD_C;
extern ULONG CIC_ACTIONS_CPP;
extern ULONG CIC_CONTROLITEMCOLLECTION_CPP;
extern ULONG CIC_CONTROLITEM_CPP;
extern ULONG CIC_DEVICEDESCRIPTIONS_CPP;
extern ULONG CIC_DUALMODE_CPP;
//extern ULONG CIC_DUMPCOMMANDBLOCK_CPP;
extern ULONG CIC_LISTASARRAY_CPP;


void SetDebugLevel(ULONG ulModuleId, ULONG ulDebugLevel)
{
	switch(ulModuleId)
	{
		case MODULE_GCK_CTRL_C:
			GCK_CTRL_C = ulDebugLevel;
			break;
		case MODULE_GCK_CTRL_IOCTL_C:
			GCK_CTRL_IOCTL_C = ulDebugLevel;
			break;
		case MODULE_GCK_FILTER_CPP:
			GCK_FILTER_CPP = ulDebugLevel;
			break;
		case MODULE_GCK_FILTERHOOKS_CPP:
			GCK_FILTERHOOKS_CPP = ulDebugLevel;
			break;
		case MODULE_GCK_FLTR_C:
			GCK_FLTR_C = ulDebugLevel;
			break;
		case MODULE_GCK_FLTR_PNP_C:
			GCK_FLTR_PNP_C = ulDebugLevel;
			break;
		case MODULE_GCK_GCKSHELL_C:
			GCK_GCKSHELL_C = ulDebugLevel;
			break;
		case MODULE_GCK_REMLOCK_C:
			GCK_REMLOCK_C = ulDebugLevel;
			break;
		case MODULE_GCK_SWVB_PNP_C:
			GCK_SWVB_PNP_C = ulDebugLevel;
			break;
		case MODULE_GCK_SWVBENUM_C:
			GCK_SWVBENUM_C = ulDebugLevel;
			break;
		case MODULE_GCK_SWVKBD_C:
			GCK_SWVKBD_C = ulDebugLevel;
			break;
		case MODULE_CIC_ACTIONS_CPP:
			CIC_ACTIONS_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_CONTROLITEMCOLLECTION_CPP:
			CIC_CONTROLITEMCOLLECTION_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_CONTROLITEM_CPP:
			CIC_CONTROLITEM_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_DEVICEDESCRIPTIONS_CPP:
			CIC_DEVICEDESCRIPTIONS_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_DUALMODE_CPP:
			CIC_DUALMODE_CPP = ulDebugLevel;
			break;
//		case MODULE_CIC_DUMPCOMMANDBLOCK_CPP:
//			CIC_DUMPCOMMANDBLOCK_CPP = ulDebugLevel;
			break;
		case MODULE_CIC_LISTASARRAY_CPP:
			CIC_LISTASARRAY_CPP = ulDebugLevel;
			break;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvbenum.cpp ===
//	@doc
/**********************************************************************
*
*	@module	SWVBENUM.cpp |
*
*	SideWinder Virtual Bus Enumerator
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*	@index SideWinder Virtual Bus | SWVBENUM
*
*	@topic	SWVBENUM |
*	This module implements the SideWinder Virtual Bus.
*	The bus is nothing more than attaching this code on top of
*	a FilterDO of a raw HID PDO, for the purpose of adding DevNodes
*	for a virtual keyboard, virtual mouse, and the future virtual
*	mixed devices.  All of these devices are expected to be HID
*	devices.<nl>
*
*	The function driver for these devices the SWVBHID.sys (SideWinder
*	Virtual Bus - HID).  This driver is a HID mini-driver, however
*	all IRPs are simply passed down to their PDO's, i.e. this
*	code.<nl>
*	
*	The code in this module is independent of the functionality
*	of the virtual devices.  Basically all Power and PnP IRPs
*	are handled here.  All IRP_MJ_READ, IRP_MJ_WRITE,
*	IRP_MJ_INTERNAL_IOCTL, and IRP_MJ_IOCTL entries are delegated
*	via service table provided in the expose call to this module
*	and stored in the device extension to a code module
*	in this driver representing the device.<nl>
*	
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVBENUM_C

extern "C"
{
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	#include <stdio.h>
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
	//DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL));
}
#include "SWVBENUM.h"

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, GCK_SWVB_DriverEntry)
#endif

// @globalv	Globals for SWVB module
SWVB_GLOBALS	SwvbGlobals;

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_DriverEntry
**
**	@func	Initializes SWVB module.  In particular the globals.
**
**	@rdesc	Returns STATUS_SUCCESS always.
**
**	@comm	Called by DriverEntry of main filter.
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm DriverObject for module
	IN PUNICODE_STRING puniRegistryPath	// @parm Registry Path
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_DriverEntry\n"));
	
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(puniRegistryPath);
	SwvbGlobals.pBusFdo=NULL;
	SwvbGlobals.pBusPdo=NULL;
	SwvbGlobals.pDeviceRelations=NULL;
	SwvbGlobals.ulDeviceRelationsAllocCount=0;
	SwvbGlobals.ulDeviceNumber=0;
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_DriverEntry\n"));
	return STATUS_SUCCESS;
}

VOID
GCK_SWVB_UnLoad()
{
	if(SwvbGlobals.pDeviceRelations)
	{
		ExFreePool(SwvbGlobals.pDeviceRelations);
		SwvbGlobals.pDeviceRelations = NULL;
	}
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_SetBusDOs
**
**	@func	Sets the Device Object (PDO and FDO), to use as the base of the
**			SideWinder Virtual Bus.
**
**	@rdesc	S_OK on success
**
**	@comm	A real device is needed on the system in order to
**			support the	virtual device.  When the first such device is detected,
**			this function is called to set the filter device object of that
**			device to be the Fdo of the SWVB, and its Pdo to be the Pdo of the bus.
**			If that device object is removed, this function can be called to move
**			the SWVB unto another physical device, or it can be called with NULL
**			for both arguments to remove the SWVB.
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_SetBusDOs
(
	IN PDEVICE_OBJECT pBusFdo,	// @parm [in] Pointer to Fdo (Filter Device Object - actually)
	IN PDEVICE_OBJECT pBusPdo	// @parm [in] Pointer to Pdo
)
{
	PDEVICE_OBJECT pOldBusFdo;
	PDEVICE_OBJECT pOldBusPdo;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_SetBusDOs\n"));
	
	// Save old Bus DO info
	pOldBusFdo = SwvbGlobals.pBusFdo;
	pOldBusPdo = SwvbGlobals.pBusPdo;

	// Update Bus DO info
	SwvbGlobals.pBusFdo = pBusFdo;
	SwvbGlobals.pBusPdo = pBusPdo;

	// Invalidate the old and the new pBusPdo's - iff
	// (they exist && there is at least one device on the bus)
	// This will fire up the PnP system and cause it to re-detect
	// everything.

	if(SwvbGlobals.pDeviceRelations && SwvbGlobals.pDeviceRelations->Count)
	{
		if(pOldBusPdo)
		{
			IoInvalidateDeviceRelations(pOldBusPdo, BusRelations);
		}
		if(SwvbGlobals.pBusPdo)
		{
			IoInvalidateDeviceRelations(SwvbGlobals.pBusPdo, BusRelations);
		}
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_SetBusDOs\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_HandleBusRelations
**
**	@func	Handles queries for the BusRelations on behalf of the filter device object,
**			which the SWVB is sitting on.  Basically all we need do is copy over
**			over our device relations, being cognizant that someone may layer on top
**			of us and possibly has added stuff already.
**	@rdesc	Same as in the IoStatus and appropriate to return.
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_HandleBusRelations
(
	IN OUT PIO_STATUS_BLOCK	pIoStatus // @parm [out] IoStatus block is filled out by this routine. 
)
{
	ULONG				ulTotalCount;
	PDEVICE_RELATIONS	pExistingRelations;
	PDEVICE_RELATIONS	pDeviceRelations;
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_HandleBusRelations. pIoStatus = 0x%0.8x\n", pIoStatus));	

	// Copy the count of what we know about
	ulTotalCount = SwvbGlobals.pDeviceRelations->Count;

	GCK_DBG_TRACE_PRINT(("We have %d PDOs\n", ulTotalCount));
	
	// Read existing relations
	pExistingRelations = (PDEVICE_RELATIONS)pIoStatus->Information;
	
	// Add the count that someone on top of us may have added.
	if( NULL != pExistingRelations)
	{
		GCK_DBG_TRACE_PRINT(("There were %d existing bus relations.\n", pExistingRelations->Count));
		ulTotalCount += pExistingRelations->Count;
	}
		
	//	Allocate new relations structure
	pDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(NonPagedPool, (sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT) * (ulTotalCount-1)) );
		
	//	Abort if allocation failed
	if(!pDeviceRelations)
	{
		pIoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
		GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_BusRelations(1): STATUS_INSUFFICIENT_RESOURCES\n"));
		return	STATUS_INSUFFICIENT_RESOURCES;
	}

	pDeviceRelations->Count = 0;
		
	//	Copy pExistingRelations (from above us perhaps) if there are any.
	if( pExistingRelations )
	{
		for( pDeviceRelations->Count = 0; pDeviceRelations->Count < pExistingRelations->Count; pDeviceRelations->Count++)
		{	
			GCK_DBG_TRACE_PRINT(("Exiting relation (PDO = 0x%0.8x)\n", pExistingRelations->Objects[pDeviceRelations->Count]));
			pDeviceRelations->Objects[pDeviceRelations->Count] = pExistingRelations->Objects[pDeviceRelations->Count];
		}
		ExFreePool(pExistingRelations);
	}

	//	Add the relations that we know about	
	if(SwvbGlobals.pDeviceRelations)
	{
		ULONG ulIndex;
		for(ulIndex=0; ulIndex < SwvbGlobals.pDeviceRelations->Count; ulIndex++, pDeviceRelations->Count++)
		{	
			GCK_DBG_TRACE_PRINT(("Our relation (PDO = 0x%0.8x)\n", SwvbGlobals.pDeviceRelations->Objects[ulIndex]));
			pDeviceRelations->Objects[pDeviceRelations->Count] = SwvbGlobals.pDeviceRelations->Objects[ulIndex];
			// Reference these guys as you add them
			ObReferenceObject(pDeviceRelations->Objects[pDeviceRelations->Count]);
		}
		//minor sanity check
		ASSERT(pDeviceRelations->Count == ulTotalCount);
	}

	// Fill out the IoStatus block
	pIoStatus->Information = (ULONG)pDeviceRelations;
	pIoStatus->Status = STATUS_SUCCESS;

	//Get outta here
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_BusRelations(2): STATUS_SUCCESS\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Expose
**
**	@func	Exposes a new virtual device
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@comm	Expose is called to add a new virtual device to the system.<nl>
**			The new device object is not returned, rather the InitDevice function
**			passed in pSwvbExposeData is called when it is time to initialize the
**			new device, the caller also must cache the device during that call
**			so that it can remove it later.
**
**	@xref	SWVB_EXPOSE_DATA
*************************************************************************************/
NTSTATUS
GCK_SWVB_Expose
(
	IN PSWVB_EXPOSE_DATA pSwvbExposeData // @parm all the data needed to expose a PDO
)
{
	NTSTATUS			NtStatus;
	UNICODE_STRING		uniPdoNameString;
	PWCHAR				pcwPdoName;
	PDEVICE_OBJECT		pVdPdo;
	PSWVB_PDO_EXT		pSwvbPdoExt;
	ULONG				ulTotalExtensionSize;
	ULONG				ulHardwareIDLength;
		
	PAGED_CODE();

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Expose. pSwvbExposeData = 0x%0.8x\n", pSwvbExposeData));

	//Calculate the needed extension size
	ulTotalExtensionSize = sizeof(SWVB_PDO_EXT) + pSwvbExposeData->ulDeviceExtensionSize;

	//	Create a name for the Pdo
	pcwPdoName = (PWCHAR)EX_ALLOCATE_POOL(PagedPool, sizeof(SWVB_DEVICE_NAME_BASE));
	if( !pcwPdoName )
	{
		GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(1) ERROR:Failed to allocate PDO Name\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	swprintf(pcwPdoName, SWVB_DEVICE_NAME_TMPLT, SwvbGlobals.ulDeviceNumber++);
	RtlInitUnicodeString(&uniPdoNameString, pcwPdoName);
	
	//	Create the PDO
	NtStatus = IoCreateDevice(
		SwvbGlobals.pBusFdo->DriverObject,
		ulTotalExtensionSize,
		&uniPdoNameString,
		FILE_DEVICE_UNKNOWN,
		0,
		FALSE,
		&pVdPdo 
		);

	//Done with the name
	ExFreePool(pcwPdoName);
	if( !NT_SUCCESS(NtStatus) )
	{
		GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(2) ERROR:Failed to Create PDO, NtStatus = 0x%0.8x\n", NtStatus));
		return NtStatus;
	}
	
	//	Ensure that we will be able to remember this new Pdo.
	if(!SwvbGlobals.pDeviceRelations)
	{
		//
		// Three PDO's is pretty cheap and will suffice most of the time, avoiding reallocation.
		// We hard code this here, as this is not really a parameter that you need to change.
		// If we run over 3 than it will reallocate as needed anyway. - The device relations
		// already as room for 1 device object so we just need to add the size of 2 pointers
		// to get to three.
		//
		ULONG ulSize = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT)*2;
		SwvbGlobals.pDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(NonPagedPool, ulSize);
		if(!SwvbGlobals.pDeviceRelations)
		{
			IoDeleteDevice(pVdPdo);  //guess we won't be needing this afterall
			GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(3): Failed to allocate SwvbGlobals.pDeviceRelations\n"));
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		SwvbGlobals.pDeviceRelations->Count = 0;
		SwvbGlobals.ulDeviceRelationsAllocCount = 3;  //we made space for three
	}
	
	// If the DEVICE_RELATIONS structure is not large enough, grow it.
	if(SwvbGlobals.pDeviceRelations->Count == SwvbGlobals.ulDeviceRelationsAllocCount)
	{
		ULONG ulNewAllocCount;
		ULONG ulNewAllocSize;
		ULONG ulOldAllocSize;
		PDEVICE_RELATIONS pTempDeviceRelations;
		ulNewAllocCount = SwvbGlobals.ulDeviceRelationsAllocCount*2;
		ulNewAllocSize = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT)*(ulNewAllocCount-1);
		ulOldAllocSize = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT)*(SwvbGlobals.ulDeviceRelationsAllocCount-1);
		pTempDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(NonPagedPool, ulNewAllocSize);
		//Make sure that allocation worked
		if(!pTempDeviceRelations)
		{
			IoDeleteDevice(pVdPdo);  //guess we won't be needing this afterall
			GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(4): Failed to grow SwvbGlobals.pDeviceRelations\n"));
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		//Copy all data
		RtlCopyMemory(pTempDeviceRelations, SwvbGlobals.pDeviceRelations, ulOldAllocSize);
		//Update info
		SwvbGlobals.ulDeviceRelationsAllocCount = ulNewAllocCount;
		SwvbGlobals.pDeviceRelations = pTempDeviceRelations;
		/*
		*	BUGBUG: Memory Leak.  After RC replace above line with the following
		*
		*	PDEVICE_RELATIONS pTemp2 = SwvbGlobals.pDeviceRelations;
		*	SwvbGlobals.pDeviceRelations = pTempDeviceRelations;
		*	ExFreePool(pTemp2);
		*
		*/
	}
	
	// Reference the newly created pdo
	ObReferenceObject(pVdPdo);

	// Initialize the device extention
	pSwvbPdoExt = (PSWVB_PDO_EXT)pVdPdo->DeviceExtension;
	pSwvbPdoExt->ulGckDevObjType = GCK_DO_TYPE_SWVB;
	pSwvbPdoExt->fAttached=TRUE;
	pSwvbPdoExt->fStarted=FALSE;
	pSwvbPdoExt->fRemoved = FALSE;
	pSwvbPdoExt->pServiceTable = pSwvbExposeData->pServiceTable;
	pSwvbPdoExt->ulInstanceNumber = pSwvbExposeData->ulInstanceNumber;
	pSwvbPdoExt->ulOpenCount = 0;
	GCK_InitRemoveLock(&pSwvbPdoExt->RemoveLock, "Virtual Device");

	// Copy the HardwareID
	ulHardwareIDLength = MultiSzWByteLength(pSwvbExposeData->pmwszDeviceId);
	pSwvbPdoExt->pmwszHardwareID = (PWCHAR)EX_ALLOCATE_POOL( NonPagedPool, ulHardwareIDLength);
	if(!pSwvbPdoExt->pmwszHardwareID)
	{
		ObDereferenceObject(pVdPdo);
		IoDeleteDevice(pVdPdo);  //guess we won't be needing this afterall
		GCK_DBG_ERROR_PRINT(("Exiting GCK_SWVB_Expose(5): Failed to allocate space for HardwareId\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyMemory( pSwvbPdoExt->pmwszHardwareID, pSwvbExposeData->pmwszDeviceId, ulHardwareIDLength);


		
	//** CAVEAT From here to end of function must succeed! We
	//** CAVEAT	have no way of telling the virtual device 
	//** CAVEAT that afterall, we decided not to expose that PDO it
	//** CAVEAT it has already initialized!
	// Allow virtual device code to init its part of the extension
	pSwvbExposeData->pfnInitDevice(pVdPdo, pSwvbExposeData->ulInitContext);
	
	//mark end of initialization in the device object
	pVdPdo->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
    pVdPdo->Flags &= ~DO_DEVICE_INITIALIZING;

	//Sanity check of code a few steps ago.
	ASSERT(SwvbGlobals.pDeviceRelations->Count < SwvbGlobals.ulDeviceRelationsAllocCount);
	
	//Add our Pdo to the list
	SwvbGlobals.pDeviceRelations->Objects[SwvbGlobals.pDeviceRelations->Count++] = pVdPdo;

	//
	//	Invalidate Device Relations - will pique some interest in what we have done here
	//	Verify that we have a bus if not we are OK, when the bus is set everything will work,
	//	but we assert becuase we really want to force the client code to add the bus before the device.
	//
	ASSERT(	SwvbGlobals.pBusFdo );
	ASSERT(	SwvbGlobals.pBusPdo );
	if( SwvbGlobals.pBusFdo && SwvbGlobals.pBusPdo)
	{
		IoInvalidateDeviceRelations(SwvbGlobals.pBusPdo, BusRelations);
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Expose(5): Success\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Remove
**	
**	@func	Removes a virtual device from the system.  Actually we just mark it
**			for removal and tell PnP to reenumerate.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@comm	The Pdo should be one that was sent to pfnInitDevice when <f GCK_SWVB_Expose>
**			was called.<nl>
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Remove
(
	IN PDEVICE_OBJECT	pPdo	// @parm Pdo to remove
)
{
	ULONG ulMatchIndex = 0xFFFFFFFF;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Remove: pPdo = 0x%0.8x\n", pPdo));
	
	// Find and Remove Pdo from SwvbGlobals.pDeviceRelations
	if(SwvbGlobals.pDeviceRelations)
	{
		ULONG ulIndex;
		for(ulIndex = 0; ulIndex < SwvbGlobals.pDeviceRelations->Count; ulIndex++)
		{
			if(SwvbGlobals.pDeviceRelations->Objects[ulIndex] == pPdo)
			{
				ulMatchIndex = ulIndex;
				break;
			}
		}
	}

	//if we found a match remove it from it
	if(0xFFFFFFFF == ulMatchIndex)
	{
		//No one should ever try to remove a device that is not in the list
		ASSERT(FALSE);
		GCK_DBG_EXIT_PRINT(("Error GCK_SWVB_Remove: Attempt to remove non-existant device!\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//Copy last PDO over this one and dec count, works even if we are last
	SwvbGlobals.pDeviceRelations->Objects[ulMatchIndex]
		= SwvbGlobals.pDeviceRelations->Objects[--(SwvbGlobals.pDeviceRelations->Count)];
	
	//
	// Mark device as unattached so when PnP says to remove it, we
	// do remove it and clean up everything, rather than hanging on
	// to it and waiting for more querying IRPs
	((PSWVB_PDO_EXT)pPdo->DeviceExtension)->fAttached =FALSE;

	//
	//	If it has been removed already, we need to delete, because the PnP system already
	//	doesn't know about, and we just detattached, so once we leave this routine, we don't
	//	know about it.  So Delete now, or it sticks to us.  Then we go to remove ourselves
	//	we will notice that we still have some Device Objects in our pockets(pDriverObject device object list),
	//	and we will wonder where they came from, and what type they are?  So delete them now!
	//
	if(TRUE == ((PSWVB_PDO_EXT)pPdo->DeviceExtension)->fRemoved)
	{
		PSWVB_PDO_EXT pPdoExt = (PSWVB_PDO_EXT)pPdo->DeviceExtension;
		NTSTATUS NtStatus = 0;
		// Give virtual device a chance at the IRP
		if(pPdoExt->pServiceTable->pfnRemove)
		{
			NtStatus = pPdoExt->pServiceTable->pfnRemove(pPdo, NULL);
		}

		// failure to succeed is pretty darn serious
		if(!NT_SUCCESS(NtStatus))
		{
			ASSERT(FALSE);
			GCK_DBG_CRITICAL_PRINT(("Virtual Device had the gall to fail remove!\n"));
		}
		
		// free memory for storing the HardwareID
		ASSERT(pPdoExt->pmwszHardwareID);
		ExFreePool(pPdoExt->pmwszHardwareID);

		GCK_DBG_TRACE_PRINT(("Detattached device has already been removed by PnP, so clean it up.\n"));
		if( 0 == ((PSWVB_PDO_EXT)pPdo->DeviceExtension)->ulOpenCount )
		{
			ObDereferenceObject(pPdo);
			IoDeleteDevice(pPdo);
		}
	}

	// Invalidate the BUS relations so that PnP will renumerate the bus.
	// Of course since we rely on others, it is possible that we temporarily
	// don't have a Bus, in which case we skip this step.
	//
	// If we don't have DO for the Bus we shouldn't lose any sleep on two accounts:
	// 1. It is possible that all the real devices have been yanked from the system, in which case
	//		PnP will start removing everyone below the node that was yanked, starting at the bottom.
	//		That means virtual devices have been removed as far as PnP is concerned and our remove
	//		routine for those devices has been called.  However, until all the underlying real devices
	//		get removed by PnP (which is later), they don't relealize it is time to tell us to get rid of the
	//		virtual devices.  No big woop.  We will delete the devices when they tell us.  If the virtual
	//		device is shared among real devices (like a virtual keyboard), they will tell us when the last
	//		one is removed.  This scenario is infact the normal way things happen when the last device is pulled,
	//		or when the system is powered down.
	// 2. It is possible that the filter drivers have temporarily decided to pull our bus.  In this case,
	//		everything will be fine and dandy when we get a new bus to sit on, as we will Invalidate Bus relations
	//		at that time.
	if(SwvbGlobals.pBusPdo)
	{
		IoInvalidateDeviceRelations(SwvbGlobals.pBusPdo, BusRelations);
	}
	
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Remove: Success\n"));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	ULONG MultiSzWByteLength(PWCHAR pmwszBuffer);
**
**	@func	Calculates the length in bytes of a Wide Multi String,
**			including terminating characters.  Multi-sz is terminated by two NULLs
**			in a row.
**
**	@rdesc	Size in characters, including terminating characters.
**
*************************************************************************************/
ULONG
MultiSzWByteLength
(
	PWCHAR pmwszBuffer	// @parm Pointer to UNICODE multi-string
)
{
	PWCHAR pmwszStart = pmwszBuffer;
	do
	{
		while(*pmwszBuffer++);
	}while(*pmwszBuffer++);
	return (ULONG)((PCHAR)pmwszBuffer -(PCHAR)pmwszStart);
}


/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Create
**	
**	@func	Handles IRP_MJ_CREATE for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Create
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Create\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnCreate(pDeviceObject, pIrp);
	if( NT_SUCCESS(NtStatus) )
	{
		pPdoExt->ulOpenCount++;
	}
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Create, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Close
**	
**	@func	Handles IRP_MJ_CLOSE for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Close
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Close\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnClose(pDeviceObject, pIrp);
	//if successfully closed, decrement count
	if( NT_SUCCESS(NtStatus) )
	{
		if(0==--pPdoExt->ulOpenCount)
		{
			//if the device is removed, we need to delete it.
			if(pPdoExt->fRemoved)
			{
				ObDereferenceObject(pDeviceObject);
				IoDeleteDevice(pDeviceObject);
			}
		}
	}

	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Close, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Read
**	
**	@func	Handles IRP_MJ_READ for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Read
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Reade\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnRead(pDeviceObject, pIrp);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Read, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Ioctl
**	
**	@func	Handles IRP_MJ_IOCTL and IRP_MJ_INTERNAL_IOCTL for virtual devices.
**			delegates using their service table.
**
**	@rdesc	STATUS_SUCCESS on success, various errors
**
**	@todo	Add basic checks to make sure device is valid before delegating
**
*************************************************************************************/
NTSTATUS
GCK_SWVB_Ioctl
(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PIRP				pIrp
)
{
	NTSTATUS NtStatus;
	PSWVB_PDO_EXT pPdoExt;

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Ioctl\n"));

	// Cast device extension
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	
	// Just an extra sanity check
	ASSERT(GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);

	//if device is stopped, complete here, less work for virtual devices
	if(	
		(pPdoExt->fRemoved) ||
		(!pPdoExt->fStarted)
		)
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_DELETE_PENDING;
	}

	//Delegate
	NtStatus = pPdoExt->pServiceTable->pfnIoctl(pDeviceObject, pIrp);

	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_Ioctl, Status = 0x%0.8x\n", NtStatus));
	return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvbenum.h ===
//	@doc
/**********************************************************************
*
*	@module	SWVBENUM.h	|
*
*	Header file for SideWinde Virtual Bus Enumerator
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@xref SWBENUM.C
*
**********************************************************************/

//---------------------------------------------------------------------
//	Structures required for Virtual Bus
//---------------------------------------------------------------------

//
//	@struct SWVB_GLOBALS |
//	Global variables belonging to the Virtual Bus
//	Basic info, such as the PDO and FDO of the bus itself,
//	which is really a HID PDO, and a filter (not function) Device 
//	Object which is letting us use it also as a Bus FDO.
//
typedef struct tagSWVB_GLOBALS
{
	PDEVICE_OBJECT		pBusFdo;						//@field Pointer to Fdo to use as BUS
	PDEVICE_OBJECT		pBusPdo;						//@field Pointer to Pdo to use as BUS
	ULONG				ulDeviceRelationsAllocCount;	//@field Allocated count for device relations
	PDEVICE_RELATIONS	pDeviceRelations;				//@field Device Relations holds PDOs on bus
	ULONG				ulDeviceNumber;					//@field Used to name devices
}	SWVB_GLOBALS, *PSWVB_GLOBALS;

//
//	@struct SWVB_DEVICE_SERVICE_TABLE |
//	Service table that Virtual Device Module
//	gives to Virtual Bus on the <f SWVB_Expose>
//	call.  The PnP entries are only if the Virtual
//	Device needs additional processing for these.  Particularly,
//	remove if anything in the Virtual Device part of the extension
//	is dynamically allocated.  The usual malarkey is handled by the
//	SWVBENUM code.
//
typedef struct tagSWVB_DEVICE_SERVICE_TABLE
{
	PDRIVER_DISPATCH pfnCreate;		//@field Entry point IRP_MJ_CREATE
	PDRIVER_DISPATCH pfnClose;		//@field Entry point IRP_MJ_CLOSE
	PDRIVER_DISPATCH pfnRead;		//@field Entry point IRP_MJ_READ
	PDRIVER_DISPATCH pfnWrite;		//@field Entry point IRP_MJ_WRITE
	PDRIVER_DISPATCH pfnIoctl;		//@field Entry point IRP_MJ_IOCTL
	PDRIVER_DISPATCH pfnStart;		//@field Entry point IRP_MJ_PNP\IRP_MN_START
	PDRIVER_DISPATCH pfnStop;		//@field Entry point IRP_MJ_PNP\IRP_MN_STOP
	PDRIVER_DISPATCH pfnRemove;		//@field Entry point IRP_MJ_PNP\IRP_MN_REMOVE
}	SWVB_DEVICE_SERVICE_TABLE, *PSWVB_DEVICE_SERVICE_TABLE;

typedef NTSTATUS (*PFN_GCK_INIT_DEVICE)(PDEVICE_OBJECT pDeviceObject, ULONG ulInitContext);

//
//	@struct SWVB_EXPOSE_DATA |
//	Data that must be passed on calls to <f GCK_SWVB_Expose>
//
typedef struct tagSWVB_EXPOSE_DATA
{
	ULONG						ulDeviceExtensionSize;	// @field [in] Size of extension needed by virtual device
	PSWVB_DEVICE_SERVICE_TABLE	pServiceTable;			// @field [in] Pointer to service table of virtual device
	PWCHAR						pmwszDeviceId;			// @field [in] HardwareID for new device, without enumerator name
	PFN_GCK_INIT_DEVICE			pfnInitDevice;			// @field [in] Callback to initialize new Device Object
	ULONG						ulInitContext;			// @field [in] COntext for pfnInitDevice
	ULONG						ulInstanceNumber;		// @field [in] Instance Number of new device
} SWVB_EXPOSE_DATA, *PSWVB_EXPOSE_DATA;

//
//	@struct SWVB_PDO_EXT |
//	Device Extensions for PDOs created by the SWVB
//	Appended to this extension is the device extension
//	size requested by the virtual device module
//	in the <f SWVB_Expose> call.
typedef struct tagSWVB_PDO_EXT
{
	ULONG	ulGckDevObjType;					// @field Type of GcKernel device object.
	BOOLEAN fStarted;							// @field Marks that Virtual Device is started
	BOOLEAN	fRemoved;							// @field Marks that Virtual Device is removed
	BOOLEAN	fAttached;							// @field The device is attached as long as we say it is.
	PSWVB_DEVICE_SERVICE_TABLE	pServiceTable;	// @field Service Table for virtual device
	GCK_REMOVE_LOCK RemoveLock;					// @field Custom Remove Lock
	PWCHAR	pmwszHardwareID;					// @field HardwareID of device
	ULONG	ulInstanceNumber;					// @field Instance number
	ULONG	ulOpenCount;						// @field Count of open handles
}SWVB_PDO_EXT,	*PSWVB_PDO_EXT;

//
//	Accessor for instance number of PSWVB_PDO_EXT
//
inline ULONG GCK_SWVB_GetInstanceNumber(PDEVICE_OBJECT pDeviceObject)
{
	PSWVB_PDO_EXT pPdoExt = (PSWVB_PDO_EXT)pDeviceObject->DeviceExtension;
	ASSERT(GCK_DO_TYPE_SWVB ==	pPdoExt->ulGckDevObjType);
	return pPdoExt->ulInstanceNumber;
}

//---------------------------------------------------------------------------
// Error Codes specific to SWVB
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//	Macros
//---------------------------------------------------------------------------

//
//	@func PVOID | SWVB_GetVirtualDeviceExtension |
//		  Accesses Device Extension of PDO exposed on the SWVB.
//	@rdesc Returns pointer to Virtual Device Part of DeviceExtension	  
//	@parm PDEVICE_OBJECT | [in] pDeviceObject |
//		  Pointer to DeviceObject to get extension from.
//	@comm Implemented as MACRO.
//		   		
#define GCK_SWVB_GetVirtualDeviceExtension(__pDeviceObject__) \
		(\
			(PVOID)\
			(\
				(PCHAR)\
				( (__pDeviceObject__)->DeviceExtension )\
				+ sizeof(SWVB_PDO_EXT)\
			)\
		)

//---------------------------------------------------------------------------
//	#define strings
//---------------------------------------------------------------------------
#define SWVB_DEVICE_NAME_BASE	L"\\Device\\SideWinderVirtualDevicePdo_000"
#define SWVB_DEVICE_NAME_TMPLT	L"\\Device\\SideWinderVirtualDevicePdo_%0.3x"
#define SWVB_BUS_ID				L"SWVBENUM\\"
#define SWVB_HARDWARE_ID_TMPLT	L"SWVBENUM\\%s"
#define SWVB_INSTANCE_EXT		L"_000"
#define SWVB_INSTANCE_ID_TMPLT	L"%s_%0.3d"

//---------------------------------------------------------------------------
//  General entry points defined in GckShell.h
//---------------------------------------------------------------------------
#ifndef __gckshell_h__
#include "gckshell.h"
#endif

//---------------------------------------------------------------------------
// Function declarations - autodoc comments in .c file
//---------------------------------------------------------------------------
extern "C"
{
NTSTATUS
GCK_SWVB_SetBusDOs
(
	IN PDEVICE_OBJECT pBusFdo,
	IN PDEVICE_OBJECT pBusPdo
);

NTSTATUS
GCK_SWVB_HandleBusRelations
(
	IN OUT PIO_STATUS_BLOCK		pIoStatus
);
		
NTSTATUS
GCK_SWVB_Expose
(
	IN PSWVB_EXPOSE_DATA pSwvbExposeData
);

NTSTATUS
GCK_SWVB_Remove
(
	IN PDEVICE_OBJECT	pPdo
);

ULONG
MultiSzWByteLength
(
	PWCHAR pmwszBuffer
);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvkbd.h ===
//	@doc
/**********************************************************************
*
*	@module	SWVKBD.h	|
*
*	Declarations related to SideWinder Virtual Keyboard.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVKBD	|
*	The SideWinder Virtual Keyboard is designed to sit atop the SideWinder
*	Virtual Bus.  It is a HID device, and relies on the loading of a dummy
*	HID driver.<nl>
*
**********************************************************************/

#include "irpqueue.h"

//----------------------------------------------------------------------------------
// Virtual Keyboard structures
//----------------------------------------------------------------------------------
#define GCK_VKBD_MAX_KEYSTROKES 0x06 //HID spec. says this can be six at most.
									 //Comments in HIDPARSE code suggest that the OS
									 //supports up to fourteen.
#define GCK_VKBD_STATE_BUFFER_SIZE 0x20 //Size of circular buffer for holding on to
										//key presses.

//----------------------------------------------------------------------------------
// Device States - an alternative to five different flags
//----------------------------------------------------------------------------------
#define VKBD_STATE_STARTED			0x01
#define VKBD_STATE_STOPPED			0x02
#define VKBD_STATE_REMOVED			0x03

//
// @struct GCK_VKBD_REPORT_PACKET | 
//	The report format of the virtual keyboard. Any changes here must be
//	reflected in the report descriptor and vice-versa.		
typedef struct tagGCK_VKBD_REPORT_PACKET
{
	UCHAR	ucModifierByte;								//@field Modifier Byte
	UCHAR	rgucUsageIndex[GCK_VKBD_MAX_KEYSTROKES];	//@field List of keys that down
} GCK_VKBD_REPORT_PACKET, *PGCK_VKBD_REPORT_PACKET;

//
// @struct GCK_VKBD_EXT	|	
//	
typedef struct tagGCK_VKBD_EXT
{
	UCHAR					ucDeviceState;								//@field State of device(Started, Stopped, Removed)
	USHORT					usReportBufferCount;						//@field Count of packets in buffer
	USHORT					usReportBufferPos;							//@field Next Packet in buffer
	GCK_VKBD_REPORT_PACKET	rgReportBuffer[GCK_VKBD_STATE_BUFFER_SIZE]; //@field Buffer of pendind reports
	CGuardedIrpQueue		IrpQueue;									//@field Irp queue;
	GCK_REMOVE_LOCK			RemoveLock;									//@field RemoveLock for Outstanding IO
} GCK_VKBD_EXT, *PGCK_VKBD_EXT;

//----------------------------------------------------------------------------------
//	API for using the Virtual Keyboard
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VKBD_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject
);

NTSTATUS
GCK_VKBD_Close
(
	IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS
GCK_VKBD_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VKBD_REPORT_PACKET pReportPacket
);


//----------------------------------------------------------------------------------
// Driver Initialization
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
// Device Initialization
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VKBD_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
);

//----------------------------------------------------------------------------------
//	Entry points to handle IRPs from the Virtual Bus
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VKBD_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 PIRP pIrp
);

NTSTATUS
GCK_VKBD_CreateProc
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS
GCK_VKBD_IoctlProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_ReadProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_StartProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_StopProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 IN PIRP pIrp
);

NTSTATUS
GCK_VKBD_WriteProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

//------------------------------------------------------------------
// Ioctl sub-function handlers
//------------------------------------------------------------------
NTSTATUS
GCK_VKBD_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VKBD_GetReportDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VKBD_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VKBD_ReadReport
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VKBD_WriteToFakeLEDs
(
	IN PIRP pIrp	
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvmouse.cpp ===
//	@doc
/*******************************************************************
*
*	@module	SWVMOUSE.cpp	|
*
*	Implementation of the SideWinder Virtual Mouse
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1999 Microsoft Corporation. All right reserved.
*
*	@topic	SWVKBD	|
*	This module implements the SideWinder Virtual Mouse
*	which is used to report Joystick Axes as mouse axes.
*	Also is used for stuffing mouse clicks.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVMOUSE_C

extern "C" {
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	#include "hidtoken.h"
	#include "hidusage.h"
	#include "hidport.h"
	#include "remlock.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}

#include "SWVBENUM.h"
#include "SWVMOUSE.h"
#include <stdio.h>

//PDRIVER_OBJECT	g_pDriverObject;

//
//	These keep track of the next instance number
//	g_ulInstanceBits is a bit field.  A device holds an instance number
//	by setting a bit, and clearing when it is destroyed.  This only works
//	for the first 32 devices (i.e. 99.99% of the time).  The 33rd device
//	goes into the overflow.  Instance numbers in the overflow are not recovered.
//	With 33 devices plugged in, plugging and unplugging the 33rd device will cause
//	the instances of devices in the registry to profilerate.  No real harm is done,
//	it is just ugly, but this is a highly unlikely scenario.
//
static ULONG g_ulInstanceBits;
static ULONG g_ulInstanceOverflow;
//---------------------------------------------------------------------
// Tables that define device characteristics and/or entry points
//---------------------------------------------------------------------

// Service table used by Virtual Bus Module to call into Virtual Mouse
SWVB_DEVICE_SERVICE_TABLE	VMouServiceTable =
							{
								GCK_VMOU_CreateProc,
								GCK_VMOU_CloseProc,
								GCK_VMOU_ReadProc,
								GCK_VMOU_WriteProc,
								GCK_VMOU_IoctlProc,
								GCK_VMOU_StartProc,
								GCK_VMOU_StopProc,
								GCK_VMOU_RemoveProc
							};

// Constants describing device
#define	VMOU_VERSION			0x0100
#define	VMOU_COUNTRY			0x0000
#define	VMOU_DESCRIPTOR_COUNT	0x0001
#define VMOU_PRODUCT_ID			0x00FB	//BUGBUGBUG I made this up, I need to request through Rob Walker
										//BUGBUGBUG to permanently allocate one for this purpose.
	
//
//	This is pretty much copied from the HID spec Version 1 (Need to change if adding wheel support)
//
static UCHAR VMOU_ReportDescriptor[] =
				{
					0x05,0x01, //Usage Page (Generic Desktop)
					0x09,0x02, //Usage (Mouse)
					0xA1,0x01, //Collection (Application)
					0x09,0x01, //	Usage (Pointer)
					0xA1,0x00, //	Collection (Physical)
					0x05,0x09, //		Usage Page (Buttons)
					0x19,0x01, //		Usage Minimum (01)
					0x29,0x03, //		Usage Maximum (03)
					0x15,0x00, //		Logical Minimum (0)
					0x25,0x01, //		Logical Maximum (1)
					0x95,0x03, //		Report Count (3)
					0x75,0x01, //		Report Size (1)
					0x81,0x02, //		Input (Data, Variable, Absolute) - 3 button bits
					0x95,0x01, //		Report Count(1)
					0x75,0x05, //		Report Size (5)
					0x81,0x01, //		Input (Const) - 5 bit padding
					0x05,0x01, //		Usage Page (Generic Desktop)
					0x09,0x30, //		Usage(X)
					0x09,0x31, //		Usage(Y)
					0x15,0x81, //		Logical Minimum (-127)
					0x25,0x7F, //		Logical Maximum (127)
					0x75,0x08, //		Report Size (8)
					0x95,0x02, //		Report Count (2)
					0x81,0x06, //		Input (Data, Variable, Relative) - 2 Positions (X & Y)
					0xC0,	   //	End Collection
					0xC0	   //End Collection
				};

				
static	HID_DESCRIPTOR	VMOU_DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							VMOU_VERSION,
							VMOU_COUNTRY,
							VMOU_DESCRIPTOR_COUNT,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(VMOU_ReportDescriptor)}
							};


/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_DriverEntry(IN PDRIVER_OBJECT  pDriverObject, IN PUNICODE_STRING pRegistryPath)
**
**	@func	Stows the Driver Object for later
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,	//@parm Driver Object
    IN PUNICODE_STRING pRegistryPath	//@parm Registry path for this driver
    )
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_DriverEntry\n"));
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pRegistryPath);
//	g_pDriverObject = pDriverObject;
	g_ulInstanceBits = 0x0;
	g_ulInstanceOverflow = 32; //For 33 and more devices
	return STATUS_SUCCESS;
}
	
/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_Create(OUT PDEVICE_OBJECT *ppDeviceObject)
**
**	@func	Creates a new Virtual Mouse
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject //@parm [out] Device Object of new virtual keyboard
)
{	
	NTSTATUS	NtStatus;
	SWVB_EXPOSE_DATA	SwvbExposeData;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_Create *ppDeviceObject = 0x%0.8x\n", *ppDeviceObject));
	
	//Fill out SWVB_EXPOSE_DATA structure
	SwvbExposeData.pmwszDeviceId=L"SideWinderVirtualMouse\0\0";
	SwvbExposeData.pServiceTable = &VMouServiceTable ;
	SwvbExposeData.ulDeviceExtensionSize = sizeof(GCK_VMOU_EXT);
	SwvbExposeData.ulInitContext = (ULONG)ppDeviceObject;
	SwvbExposeData.pfnInitDevice = &GCK_VMOU_Init;

	//Get the instance ID
	ULONG ulBitMask;
	ULONG ulIndex;
	for(ulIndex = 0, ulBitMask = 1; ulIndex < 32; ulBitMask <<= 1, ulIndex++)
	{
		if(ulBitMask & ~g_ulInstanceBits)
		{
			g_ulInstanceBits |= ulBitMask;
			SwvbExposeData.ulInstanceNumber	= ulIndex;
			break;
		}
	}
	if(32 == ulIndex) 
	{
		SwvbExposeData.ulInstanceNumber = g_ulInstanceOverflow++;
	}
		
	//Call virtual bus to expose virtual mouse
	NtStatus=GCK_SWVB_Expose(&SwvbExposeData);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_Init(	IN PDEVICE_OBJECT pDeviceObject, IN ULONG ulInitContext)
**
**	@func	Callback for Initializing new device object.  The ulInitContext
**			is a pointer to a pointer to a device object, so that we can pass
**			the pointer to the device object back to the caller of create.
**	@rdesc	STATUS_SUCCESS.
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
)
{
	PGCK_VMOU_EXT pDevExt;
	PDEVICE_OBJECT *ppSaveDeviceObject;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_Init pDeviceObject = 0x%0.8x\n", pDeviceObject));

	//Create sent us a pointer to a PDEVICE_OBJECT in which to return the new device object
	ppSaveDeviceObject = (PDEVICE_OBJECT *)ulInitContext;
	*ppSaveDeviceObject = pDeviceObject;
	
	//Get out part of the device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	//Mark device as stopped
	pDevExt->ucDeviceState= VMOU_STATE_STOPPED;
	
	//Mark the circular buffer as empty
	pDevExt->usReportBufferPos=0;
	pDevExt->usReportBufferCount=0;
	
	//Initialize locks
	GCK_InitRemoveLock(&pDevExt->RemoveLock, "SWVMOU_LOCK");

	//Initialize IrpQueue
	pDevExt->IrpQueue.Init(	CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE |
							CGuardedIrpQueue::PRESERVE_QUEUE_ORDER,
							(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
							&pDevExt->RemoveLock);

	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VMOU_Close(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Closes the virtual mouse (removes it!)
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_Close
(
	IN PDEVICE_OBJECT pDeviceObject
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_Close pDeviceObject = 0x%0.8x\n", pDeviceObject));
	
	//Tell the virtual bus to kill us
	return GCK_SWVB_Remove(pDeviceObject);
}

/***********************************************************************************
*
**	NTSTATUS GCK_VMOU_SendReportPacket(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Stuff a report into the circular buffer, and completes
**			an IRP if one is pending.
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VMOU_REPORT_PACKET pReportPacket
)
{
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VMOU_SendReportPacket pDeviceObject = 0x%0.8x, pReportPacket = 0x%0.8x\n", pDeviceObject, pReportPacket));

	USHORT usBufferIndex;
	PGCK_VMOU_EXT pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	//
	//	Step 1. Stuff new packet into buffer
	//

	// Acquire Lock to work with buffer 
	IrpQueueWithSharedSpinLock.Acquire();
		

	//Find position in buffer to stuff at
	usBufferIndex = (pDevExt->usReportBufferPos + pDevExt->usReportBufferCount)%GCK_VMOU_STATE_BUFFER_SIZE;

	//Copy data
	pDevExt->rgReportBuffer[usBufferIndex] = *pReportPacket;
	
	//increment buffer count
	if(pDevExt->usReportBufferCount < GCK_VMOU_STATE_BUFFER_SIZE)
	{
		pDevExt->usReportBufferCount++;
	}
	else
	{
		//This assertion means buffer overflow
		GCK_DBG_TRACE_PRINT(("Virtual Mouse buffer overflow\n"));
		pDevExt->usReportBufferPos++;
	}
	
	
	//
	//	Step 2. Get Irp if there is one
	//
	PIRP pPendingIrp = IrpQueueWithSharedSpinLock.Remove();

	if(pPendingIrp)
	{
		//	Copy the data
		RtlCopyMemory(
			pPendingIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VMOU_REPORT_PACKET)
			);
	
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VMOU_STATE_BUFFER_SIZE;
		}
	}
	
	//We are done with the buffer spin lock
	IrpQueueWithSharedSpinLock.Release();
	
	if(pPendingIrp)
	{
		//  Fill out IRP status
		pPendingIrp->IoStatus.Information = sizeof(GCK_VMOU_REPORT_PACKET);
		pPendingIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pPendingIrp, IO_NO_INCREMENT);
		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}

	//All done
	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VMOU_ReadReport(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	If there is data in the mouse buffer, completes the IRP
**			Otherwise, queues it, and set the idle timer.
**
**	@rdesc	STATUS_SUCCESS if read, STATUS_PENDING if waiting.
**
*************************************************************************************/
NTSTATUS 
GCK_VMOU_ReadReport
(
 IN PDEVICE_OBJECT pDeviceObject, 
 IN PIRP pIrp
)
{
	PGCK_VMOU_EXT pDevExt;
	PIO_STACK_LOCATION pIrpStack;
	KIRQL OldIrql;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VMOU_ReadReport pDeviceObject = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	
	//
	// Validate buffer size, because we do this the first time we see the IRP
	// we never need to worry about checking it again.
	//
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(GCK_VMOU_REPORT_PACKET))
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_BUFFER_TOO_SMALL;
	}

	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	//Make an IRP queue accessor to share spin lock
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	// Count the IRP we are working on
	GCK_IncRemoveLock(&pDevExt->RemoveLock);
	
	// Acquire Lock to work with mouse buffer and Irp Queue
	IrpQueueWithSharedSpinLock.Acquire();

	// If there is data, complete the IRP
	if( pDevExt->usReportBufferCount)
	{
		//	Copy the data
		RtlCopyMemory(
			pIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VMOU_REPORT_PACKET)
			);
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VMOU_STATE_BUFFER_SIZE;
		}
		
		//We are done with the buffer spin lock
		IrpQueueWithSharedSpinLock.Release();

		//  Fill out IRP status
		pIrp->IoStatus.Information = sizeof(GCK_VMOU_REPORT_PACKET);
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}
	else 
	// There is no data, so queue the IRP.
	{
		return IrpQueueWithSharedSpinLock.AddAndRelease(pIrp);
	}

	//We completed the IRP and all is fine
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_CloseProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CLOSE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	//We don't control open and close, so just succeed
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_CloseProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_CreateProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CREATE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_CreateProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_CreateProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_IoctlProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_INTERNAL_IOCTL and IRP_MJ_IOCTL requests sent from SWVB.
**			Trivial IRPs are handle here, others are delegated.
**
**	@rdesc	STATUS_SUCCESS, and various errors
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_IoctlProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	NTSTATUS NtStatus;
	PIO_STACK_LOCATION pIrpStack;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VMOU_IoctlProc\n"));
	
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrpStack->Parameters.DeviceIoControl.IoControlCode;
		
	// We complete everything, so the various cases
	// fill out status and information, and we complete
	// the IRP at the bottom.
	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_GET_PHYSICAL_DESCRIPTOR:
			pIrp->IoStatus.Information = 0;
			NtStatus =STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_ACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_DEACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
			NtStatus = GCK_VMOU_GetDeviceAttributes(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
			NtStatus = GCK_VMOU_GetDeviceDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		case IOCTL_HID_GET_REPORT_DESCRIPTOR:
			NtStatus = GCK_VMOU_GetReportDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_STRING:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;  //Should we support this?
			break;
		case IOCTL_HID_READ_REPORT:
			//	Read report will complete the IRP, or queue as it sees fit, just delegate
			return GCK_VMOU_ReadReport(pDeviceObject, pIrp);
		case IOCTL_HID_SET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_WRITE_REPORT:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
			break;
		default:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
	}
	pIrp->IoStatus.Status = NtStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_ReadProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_READ request sent from SWVB.  We don't support this.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_ReadProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_ReadProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}


/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_StartProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_START_DEVICE request sent from SWVB.
**			Just mark that we are started.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_StartProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	
	PGCK_VMOU_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_StartProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as started
	pDevExt->ucDeviceState = VMOU_STATE_STARTED;

	// PnP IRPs are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_StopProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_STOP_DEVICE request sent from SWVB.
**			Just mark that we are stopped.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_StopProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VMOU_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_StopProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as stopped
	pDevExt->ucDeviceState = VMOU_STATE_STOPPED;

	// Cancel all I\O
	pDevExt->IrpQueue.CancelAll(STATUS_DELETE_PENDING);


	// PnP IRP are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_RemoveProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE request sent from SWVB.
**			Wait for all outstanding IO to complete before succeeding.  We don't
**			delete our device object that is up to SWVB.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VMOU_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_RemoveProc\n"));

	// Get device extension
	pDevExt = (PGCK_VMOU_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	// Mark as Removed
	pDevExt->ucDeviceState = VMOU_STATE_REMOVED;

	//Destroy Irp Queue
	pDevExt->IrpQueue.Destroy();


	//Clear Instance Bits
	ULONG ulInstance = GCK_SWVB_GetInstanceNumber(pDeviceObject);
	if(ulInstance < 32)
	{
		g_ulInstanceBits &= ~(1 << ulInstance);
	}

	// Remove the BIAS on the RemoveLock and wait for it to go to zero (forever)
	return GCK_DecRemoveLockAndWait(&pDevExt->RemoveLock, NULL);
	
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_WriteProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_WRITE, which we don't support.  With HIDSWVD.SYS
**			as the functional driver this should never get called.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_WriteProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_WriteProc\n"));
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_GetDeviceDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Device Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Device Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_GetDeviceDescriptor\n"));
	// Check buffer size
	if(ulBufferLength < sizeof(VMOU_DeviceDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VMOU_DeviceDescriptor, sizeof(VMOU_DeviceDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VMOU_DeviceDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_GetReportDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_REPORT_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_GetReportDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Report Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Report Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_GetReportDescriptor\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(VMOU_ReportDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VMOU_ReportDescriptor, sizeof(VMOU_ReportDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VMOU_ReportDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VMOU_GetDeviceAttributes(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_ATTRIBUTES. The data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VMOU_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Attributes
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Attributes Copied
)
{
	PHID_DEVICE_ATTRIBUTES	pDeviceAttributes = (PHID_DEVICE_ATTRIBUTES)pvUserBuffer;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VMOU_GetDeviceAttributes\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(HID_DEVICE_ATTRIBUTES))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Fill out attributes structures
	pDeviceAttributes->Size = sizeof(HID_DEVICE_ATTRIBUTES);
	pDeviceAttributes->VendorID = MICROSOFT_VENDOR_ID;
	pDeviceAttributes->ProductID = VMOU_PRODUCT_ID;
	pDeviceAttributes->VersionNumber = VMOU_VERSION;
	// Record number of bytes copied
	*pulBytesCopied = sizeof(HID_DEVICE_ATTRIBUTES);
	// Return Success
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvb_pnp.cpp ===
//	@doc
/**********************************************************************
*
*	@module	SWVB_PnP.cpp	|
*
*	Power and PnP handlers for SWVB Virtual Devices
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVB_PnP	|
*			Power and PnP IRPs are handled here as if for a PDO
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVB_PNP_C

extern "C"
{
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
	//DECLARE_MODULE_DEBUG_LEVEL((DBG_ALL));
}
#include "SWVBENUM.h"
#include <stdio.h>



/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_PnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PNP for Virtual Devices.
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS GCK_SWVB_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS				NtStatus;
	PIO_STACK_LOCATION		pIrpStack;
	PSWVB_PDO_EXT			pPdoExt;
	PDEVICE_CAPABILITIES	pDeviceCapabilities;

    PAGED_CODE ();
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_PnP\n"));	
	
	//
	//	By default we will not change the status
	//
	NtStatus = pIrp->IoStatus.Status;

	//
	//	PDO Device Extension
	//
	pPdoExt = (PSWVB_PDO_EXT) pDeviceObject->DeviceExtension;
	ASSERT( GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	GCK_IncRemoveLock(&pPdoExt->RemoveLock);

    //
	//	Handle by Minor IRP code
	//
	switch (pIrpStack->MinorFunction) {

		case IRP_MN_START_DEVICE:

			GCK_DBG_TRACE_PRINT(("IRP_MN_START_DEVICE\n"));
		    
			pPdoExt->fStarted = TRUE;
			pPdoExt->fRemoved = FALSE;
			
			//Give virtual device a chance at the IRP
			if(pPdoExt->pServiceTable->pfnStart)
			{
				NtStatus = pPdoExt->pServiceTable->pfnStart(pDeviceObject, pIrp);
			}
			else
			{
				NtStatus = STATUS_SUCCESS;
			}
			break;

		case IRP_MN_STOP_DEVICE:
			
			GCK_DBG_TRACE_PRINT(("IRP_MN_STOP_DEVICE\n"));
			pPdoExt->fStarted = FALSE;
			
			//Give virtual device a chance at the IRP
			if(pPdoExt->pServiceTable->pfnStop)
			{
				NtStatus = pPdoExt->pServiceTable->pfnStop(pDeviceObject, pIrp);
			}
			else
			{
				NtStatus = STATUS_SUCCESS;
			}
			break;

		case IRP_MN_REMOVE_DEVICE:

			GCK_DBG_TRACE_PRINT(("IRP_MN_REMOVE_DEVICE\n"));
			
			//We are not setup to handle remove twice.
			if(pPdoExt->fRemoved)
			{
				pIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
				IoCompleteRequest (pIrp, IO_NO_INCREMENT);
				GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_PnP STATUS_NO_SUCH_DEVICE on remove\n"));
				return STATUS_NO_SUCH_DEVICE;
			}
			

			//Sometimes we get a remove without a stop, so do the stop stuff if necessary
			if(pPdoExt->fStarted)
			{
				pPdoExt->fStarted = FALSE;
				//Give virtual device a chance at the IRP
				if(pPdoExt->pServiceTable->pfnStop)
				{
					NtStatus = pPdoExt->pServiceTable->pfnStop(pDeviceObject, pIrp);
				}
			}

			// We will no longer receive requests for this device as it has been removed.
			pPdoExt->fRemoved = TRUE;

			// Undo our increment upon entry to this routine
			GCK_DecRemoveLock(&pPdoExt->RemoveLock);

			//We may have ordered this removal, or the PnP system
			//may just be rearranging things for us.  If we ordered it,
			//we need to cleanup, and give the virtual device a chance
			//to cleanup.  If the PnP system is rearranging things we nod
			//back, sure it is removed, and pretty much ignore it.
			if(!pPdoExt->fAttached)
			{
				// Give virtual device a chance at the IRP
				if(pPdoExt->pServiceTable->pfnRemove)
				{
					NtStatus = pPdoExt->pServiceTable->pfnRemove(pDeviceObject, pIrp);
				}
				// failure to succeed is pretty darn serious
				if(!NT_SUCCESS(NtStatus))
				{
					ASSERT(FALSE);				/** ?? **/
					GCK_DBG_CRITICAL_PRINT(("Virtual Device had the gall to fail remove!\n"));
					return NtStatus;
				}
				
				// free memory for storing the HardwareID
				ASSERT(pPdoExt->pmwszHardwareID);
				ExFreePool(pPdoExt->pmwszHardwareID);

				//
				// Undo the bias Irp count so it can go to zero
				// if this does not take it to zero, we have to wait
				// until it goes to zero, forever.
				//
        		GCK_DecRemoveLockAndWait(&pPdoExt->RemoveLock, NULL);
				
				// Delete this device, if the open count is zero
				if( 0 == pPdoExt->ulOpenCount )
				{
					ObDereferenceObject(pDeviceObject);
					IoDeleteDevice(pDeviceObject);
				}
			}
			
			// Must succeed this 
		    pIrp->IoStatus.Status = STATUS_SUCCESS;
		    IoCompleteRequest (pIrp, IO_NO_INCREMENT);
			GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_PnP succeeding remove\n"));
			return STATUS_SUCCESS;

		case IRP_MN_QUERY_DEVICE_RELATIONS:

			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_DEVICE_RELATIONS: Type = %d\n",
				pIrpStack->Parameters.QueryDeviceRelations.Type));
			
			//	TargetDeviceRelation just wants to know who the PDO is, and it
			//	is us so we handle it.
			if (TargetDeviceRelation == pIrpStack->Parameters.QueryDeviceRelations.Type)
			{
				PDEVICE_RELATIONS pDeviceRelations;
				GCK_DBG_TRACE_PRINT(("TargetDeviceRelations\n"));
				pDeviceRelations = (PDEVICE_RELATIONS) pIrp->IoStatus.Information; 
				if (!pDeviceRelations)
				{
					pDeviceRelations = (PDEVICE_RELATIONS)EX_ALLOCATE_POOL(PagedPool, sizeof(DEVICE_RELATIONS));
					if (!pDeviceRelations) {
						GCK_DBG_ERROR_PRINT(("Couldn' allocate DEVICE_RELATIONS for TargetDevice!!\n"));
						NtStatus = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}
				}
			    else if (pDeviceRelations->Count != 0)
				{
					ULONG	uIndex;
					
					// Nobody but the PDO should be setting this value!
					ASSERT(pDeviceRelations->Count == 0);
					
					//
					// Deref any objects that were previously in the list
					// This code copied out of some system code (gameenum perhaps)
					// Seems like this code should not be necessary, but what the
					// hell? It does no harm.
					for( uIndex= 0; uIndex< pDeviceRelations->Count; uIndex++)
					{
						ObDereferenceObject(pDeviceRelations->Objects[uIndex]);
						pDeviceRelations->Objects[uIndex] = NULL;
					}
				}
				pDeviceRelations->Count = 1;
				pDeviceRelations->Objects[0] = pDeviceObject;
				ObReferenceObject(pDeviceObject);
				NtStatus = STATUS_SUCCESS;
				pIrp->IoStatus.Information = (ULONG) pDeviceRelations;
				break;
			}
			//
			//	Fall through
			//
			NtStatus = pIrp->IoStatus.Status;
			break;
		case IRP_MN_QUERY_CAPABILITIES:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_CAPABILITIES\n"));
			
			// Get the packet.
			 pDeviceCapabilities=pIrpStack->Parameters.DeviceCapabilities.Capabilities;

			// Set the capabilities.
			pDeviceCapabilities->Version = 1;
			pDeviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

			// BUG	If we get a virtual keystroke it would be nice
			// BUG	to shut off the screen saver.  Not sure if this
			// BUG  is related or not.
			pDeviceCapabilities->SystemWake = PowerSystemUnspecified;
			pDeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

			// We have no latencies
			pDeviceCapabilities->D1Latency = 0;
			pDeviceCapabilities->D2Latency = 0;
			pDeviceCapabilities->D3Latency = 0;

			// No locking or ejection
			pDeviceCapabilities->LockSupported = FALSE;
			pDeviceCapabilities->EjectSupported = FALSE;

			// Device can be physically removed.
			// Technically there is no physical device to remove, but this bus
			// driver can yank the PDO from the PlugPlay system, whenever
			// the last joystick goes away.
			pDeviceCapabilities->Removable = TRUE;
			pDeviceCapabilities->SurpriseRemovalOK = TRUE;
			
			//This will force HIDSwvd.sys to be loaded
			pDeviceCapabilities->RawDeviceOK = FALSE;
			
			//Should surpress most UI
			pDeviceCapabilities->SilentInstall = TRUE;
			

			// not Docking device
			pDeviceCapabilities->DockDevice = FALSE;

			//We want to avoid having PnP attach some extra info.
			//So impose that only one bus can be on the system at a time.
			pDeviceCapabilities->UniqueID = TRUE;

			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_QUERY_ID:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_ID\n"));
			//
			//	Handle by type of ID requested
			//
			switch (pIrpStack->Parameters.QueryId.IdType)
			{
				case BusQueryDeviceID:
					// this can be the same as the hardware ids (which requires a multi
					// sz) ... we are just allocating more than enough memory
				case BusQueryHardwareIDs:
				{
					ULONG ulLength;
					ULONG ulTotalLength;
					PWCHAR	pmwszBuffer;
					// return a multi WCHAR (null terminated) string (null terminated)
					// array for use in matching hardare ids in inf files;
					ulLength = MultiSzWByteLength(pPdoExt->pmwszHardwareID);
					ulTotalLength = ulLength + sizeof(SWVB_BUS_ID);
					
					pmwszBuffer = (PWCHAR)EX_ALLOCATE_POOL(PagedPool, ulTotalLength);
					if (pmwszBuffer)
					{
						RtlCopyMemory (pmwszBuffer, SWVB_BUS_ID, sizeof(SWVB_BUS_ID));
						//The sizeof(WCHAR) is so that we chomp over the terminating UNICODE_NULL.
						RtlCopyMemory ( (PCHAR)pmwszBuffer + sizeof(SWVB_BUS_ID) - sizeof(WCHAR), pPdoExt->pmwszHardwareID, ulLength);
                		NtStatus = STATUS_SUCCESS;
					}
					else
					{
							NtStatus = STATUS_INSUFFICIENT_RESOURCES;
					}
					GCK_DBG_TRACE_PRINT(("First HardwareIDs is %ws\n", pmwszBuffer));
					pIrp->IoStatus.Information = (ULONG) pmwszBuffer;
					break;
				}
				case BusQueryInstanceID:
				{
					//
					ULONG ulLength;
					PWCHAR	pmwszBuffer;
					
					ulLength = MultiSzWByteLength(pPdoExt->pmwszHardwareID) + sizeof(SWVB_INSTANCE_EXT);

					pmwszBuffer = (PWCHAR)EX_ALLOCATE_POOL (PagedPool, ulLength);
					if (pmwszBuffer)
					{
						swprintf(pmwszBuffer, SWVB_INSTANCE_ID_TMPLT, pPdoExt->pmwszHardwareID, pPdoExt->ulInstanceNumber);
                		NtStatus = STATUS_SUCCESS;
					}
					else
					{
						NtStatus = STATUS_INSUFFICIENT_RESOURCES;
					}
					GCK_DBG_TRACE_PRINT(("Instance ID is %ws\n", pmwszBuffer));
					pIrp->IoStatus.Information = (ULONG) pmwszBuffer;

					break;
				}
				case BusQueryCompatibleIDs:
					pIrp->IoStatus.Information = 0;
					NtStatus = STATUS_NOT_SUPPORTED;
					break;
			}
			break;
		case IRP_MN_QUERY_PNP_DEVICE_STATE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_PNP_DEVICE_STATE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_SURPRISE_REMOVAL:
			GCK_DBG_TRACE_PRINT(("IRP_MN_SURPRISE_REMOVAL\n"));
			// BUGBUG we may need to know that this happened in the future
			NtStatus = STATUS_SUCCESS;
			break;
		//
		//	These are just completed with success
		//
		case IRP_MN_QUERY_REMOVE_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_REMOVE_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_CANCEL_REMOVE_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_REMOVE_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_QUERY_STOP_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_STOP_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		case IRP_MN_CANCEL_STOP_DEVICE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_CANCEL_STOP_DEVICE\n"));
			NtStatus = STATUS_SUCCESS;
			break;
		//
		//	These are just completed with their default status.
		//
		case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));
			break;
		case IRP_MN_READ_CONFIG:
			GCK_DBG_TRACE_PRINT(("IRP_MN_READ_CONFIG\n"));
			break;
		case IRP_MN_WRITE_CONFIG:
			GCK_DBG_TRACE_PRINT(("IRP_MN_WRITE_CONFIG\n"));
			break;
		case IRP_MN_EJECT:
			GCK_DBG_TRACE_PRINT(("IRP_MN_EJECT\n"));
			break;
		case IRP_MN_SET_LOCK:
			GCK_DBG_TRACE_PRINT(("IRP_MN_SET_LOCK\n"));
			break;
		case IRP_MN_QUERY_INTERFACE:
			GCK_DBG_TRACE_PRINT(("IRP_MN_QUERY_INTERFACE\n"));
			break;
		default:
			GCK_DBG_TRACE_PRINT(("Unknown IRP_MJ_PNP minor function = 0x%x\n", pIrpStack->MinorFunction));
	}
	
	//
	//	We are a PDO, there is no-one beneath us, we cannot send IRP's down.
	//	So we complete with the status set in the above switch/case,
	//	if not change there, the default is to preserve the status as
	//	NtStatus = pIrp->IoStatus.Status is done prior to entering the
	//	switch/case
	//
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	GCK_DecRemoveLock(&pPdoExt->RemoveLock);
	GCK_DBG_EXIT_PRINT(("Exiting GCK_SWVB_PnP with Status, 0x%0.8x\n", NtStatus));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_SWVB_Power(IN PDEVICE_OBJECT pDeviceObject, IN OUT PIRP pIrp)
**
**	@func	Handles Power IRPs for Virtual Devices.  We only have virtual
**			devices so we support any power IRP.  Just succeed, sure we handle
**			that power level.  In the future, we may wish to keep track of what
**			state we are in, so we can wake the system, etc.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS GCK_SWVB_Power
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object IRP is sent to
	IN OUT PIRP pIrp					// @parm IRP to process
)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION pIrpStack;
	PSWVB_PDO_EXT pPdoExt = (PSWVB_PDO_EXT)pDeviceObject->DeviceExtension;
	ASSERT( GCK_DO_TYPE_SWVB == pPdoExt->ulGckDevObjType);	

	GCK_DBG_ENTRY_PRINT(("Entering GCK_SWVB_Power\n"));	
   
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	GCK_IncRemoveLock(&pPdoExt->RemoveLock);

    switch (pIrpStack->MinorFunction){
		case IRP_MN_SET_POWER:
			switch (pIrpStack->Parameters.Power.Type) {
				case SystemPowerState:
					NtStatus = STATUS_SUCCESS;
					break;
				case DevicePowerState:
					NtStatus = STATUS_SUCCESS;
					break;
				default:
					NtStatus = pIrp->IoStatus.Status;
			}
			break;
        case IRP_MN_WAIT_WAKE:
			//We just return STATUS_NOT_SUPPORTED as we do not support
			//waking the system.
			NtStatus = STATUS_NOT_SUPPORTED;
            break;
		case IRP_MN_POWER_SEQUENCE:
			ASSERT(FALSE);  //Shouldn't happen
			NtStatus = pIrp->IoStatus.Status;
			break;
		case IRP_MN_QUERY_POWER:
			NtStatus = STATUS_SUCCESS;
			break;
		default:
			NtStatus = pIrp->IoStatus.Status;
			break;
	}

	//we are done so signal that we are ready for next one
	PoStartNextPowerIrp(pIrp);
	ASSERT(NtStatus != STATUS_UNSUCCESSFUL);
	pIrp->IoStatus.Status = NtStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	
	GCK_DecRemoveLock(&pPdoExt->RemoveLock);
	GCK_DBG_EXIT_PRINT(("Exiting GCK_Power with Status, 0x%0.8x\n", NtStatus));
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvmouse.h ===
#ifndef __swvmouse_h__
#define __swvmouse_h__
//	@doc
/**********************************************************************
*
*	@module	SWVMOUSE.H |
*
*	Declarations related to SideWinder Virtual Keyboard.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVMOUSE	|
*	The SideWinder Virtual Mouse is designed to sit atop the SideWinder
*	Virtual Bus.  It is a HID device, and relies on the loading of a dummy
*	HID driver.<nl>
*
**********************************************************************/

#include "irpqueue.h"

//----------------------------------------------------------------------------------
// Virtual Mouse structures
//----------------------------------------------------------------------------------
#define GCK_VMOU_MAX_KEYSTROKES 0x06 //HID spec. says this can be six at most.
									 //Comments in HIDPARSE code suggest that the OS
									 //supports up to fourteen.
#define GCK_VMOU_STATE_BUFFER_SIZE 0x20 //Size of circular buffer for holding on to
										//key presses.

//----------------------------------------------------------------------------------
// Device States - an alternative to five different flags
//----------------------------------------------------------------------------------
#define VMOU_STATE_STARTED			0x01
#define VMOU_STATE_STOPPED			0x02
#define VMOU_STATE_REMOVED			0x03

//
// @struct GCK_VMOU_REPORT_PACKET | 
//	The report format of the virtual keyboard. Any changes here must be
//	reflected in the report descriptor and vice-versa.		
typedef struct tagGCK_VMOU_REPORT_PACKET
{
	UCHAR	ucButtons;	//@field Button Byte (3 lsb are used)
	UCHAR	ucDeltaX;	//@field Delta X
	UCHAR	ucDeltaY;	//@field Delta Y
} GCK_VMOU_REPORT_PACKET, *PGCK_VMOU_REPORT_PACKET;

//
// @struct GCK_VMOU_EXT	|	
//	
typedef struct tagGCK_VMOU_EXT
{
	UCHAR					ucDeviceState;								//@field State of device(Started, Stopped, Removed)
	USHORT					usReportBufferCount;						//@field Count of packets in buffer
	USHORT					usReportBufferPos;							//@field Next Packet in buffer
	GCK_VMOU_REPORT_PACKET	rgReportBuffer[GCK_VMOU_STATE_BUFFER_SIZE]; //@field Buffer of pendind reports
	CGuardedIrpQueue		IrpQueue;									//@field Irp queue;
	GCK_REMOVE_LOCK			RemoveLock;									//@field Custom Remove Lock
} GCK_VMOU_EXT, *PGCK_VMOU_EXT;

//----------------------------------------------------------------------------------
//	API for using the Virtual Keyboard
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VMOU_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject
);

NTSTATUS
GCK_VMOU_Close
(
	IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS
GCK_VMOU_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VMOU_REPORT_PACKET pReportPacket
);


//----------------------------------------------------------------------------------
// Driver Initialization
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
// Device Initialization
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VMOU_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
);

//----------------------------------------------------------------------------------
//	Entry points to handle IRPs from the Virtual Bus
//----------------------------------------------------------------------------------
NTSTATUS
GCK_VMOU_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 PIRP pIrp
);

NTSTATUS
GCK_VMOU_CreateProc
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS
GCK_VMOU_IoctlProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_ReadProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_StartProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_StopProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

NTSTATUS
GCK_VMOU_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,
 IN PIRP pIrp
);

NTSTATUS
GCK_VMOU_WriteProc
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

//------------------------------------------------------------------
// Ioctl sub-function handlers
//------------------------------------------------------------------
NTSTATUS
GCK_VMOU_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VMOU_GetReportDescriptor
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VMOU_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,
	OUT PVOID	pvUserBuffer,
	OUT PULONG	pulBytesCopied
);

NTSTATUS
GCK_VMOU_ReadReport
(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
);

VOID
GCK_VMOU_CancelReadReportIrp
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

#endif //__swvmouse_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\swvkbd.cpp ===
//	@doc
/*******************************************************************
*
*	@module	SWVKBD.cpp	|
*
*	Implementation of the SideWinder Virtual Keyboard
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SWVKBD	|
*	This module implements the SideWinder Virtual Keyboard
*	which is used to stuff keystrokes from Kernel Mode.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ GCK_SWVKBD_C

//#pragma message (DDK_LIB_PATH)
extern "C" {
	#include <WDM.H>
	#include "GckShell.h"
	#include "debug.h"
	#include "hidtoken.h"
	#include "hidusage.h"
	#include "hidport.h"
	#include "remlock.h"
	DECLARE_MODULE_DEBUG_LEVEL((DBG_WARN|DBG_ERROR|DBG_CRITICAL));
}

#include "SWVBENUM.h"
#include "SWVKBD.h"
#include <stdio.h>


// PDRIVER_OBJECT g_pDriverObject;

//
//	These keep track of the next instance number
//	g_ulInstanceBits is a bit field.  A device holds an instance number
//	by setting a bit, and clearing when it is destroyed.  This only works
//	for the first 32 devices (i.e. 99.99% of the time).  The 33rd device
//	goes into the overflow.  Instance numbers in the overflow are not recovered.
//	With 33 devices plugged in, plugging and unplugging the 33rd device will cause
//	the instances of devices in the registry to profilerate.  No real harm is done,
//	it is just ugly, but this is a highly unlikely scenario.
//
static ULONG			g_ulInstanceBits;
static ULONG			g_ulInstanceOverflow;

//---------------------------------------------------------------------
// Tables that define device characteristics and/or entry points
//---------------------------------------------------------------------

// Service table used by Virtual Bus Module to call into Virtual Keyboard
SWVB_DEVICE_SERVICE_TABLE	VKbdServiceTable =
							{
								&GCK_VKBD_CreateProc,
								&GCK_VKBD_CloseProc,
								&GCK_VKBD_ReadProc,
								&GCK_VKBD_WriteProc,
								&GCK_VKBD_IoctlProc,
								&GCK_VKBD_StartProc,
								&GCK_VKBD_StopProc,
								&GCK_VKBD_RemoveProc
							};
// Constants describing device
#define	VKBD_VERSION			0x0100
#define	VKBD_COUNTRY			0x0000
#define	VKBD_DESCRIPTOR_COUNT	0x0001
#define VKBD_PRODUCT_ID			0x00FA	//BUGBUGBUG I made this up, I need to request through Rob Walker
										//BUGBUGBUG to permanently allocate one for this purpose.
	
//
//	This is more or less copied from the HID spec Version 1 - Final, except that
//	we left off the reserved byte and the LED's , why should a virtual keyboard
//  need to have virtual LED's.  I can conceive of a real one without them.
//
static UCHAR VKBD_ReportDescriptor[] =
				{
					0x05,0x01, //Usage Page (Generic Desktop)
					0x09,0x06, //Usage (Keyboard)
					0xA1,0x01, //Collection (Application)
					0x05,0x07, //Usage Page (Key Codes)
					0x19,0xE0, //Usage Minimum (224) - from Left Control
					0x29,0xE7, //Usage Maximum (231) - to Right GUI
					0x15,0x00, //Logical Minimum (0)
					0x25,0x01, //Logical Maximum (1)
					0x75,0x01, //Report Size (1)
					0x95,0x08, //Report Count (8)
					0x81,0x02, //Input (Data, Variable, Absolute) - Modifier Byte
					0x95,0x05, //Report Count(5)
					0x75,0x01, //Report Size (1)
					0x05,0x08, //Usage Page (LEDs)
					0x19,0x01, //Usage Minimum (1)
					0x29,0x05, //Usage Maximum (5)
					0x91,0x02, //Output (Data, Vartiable, Absolute) - LED Indicator lights
					0x95,0x01, //Report Count(1)
					0x75,0x03, //Report Size (3)
					0x91,0x01, //Output (Constant) - Padding for LED output report, to bring it up to a byte.
					0x75,0x08, //Report Size (8)
					0x95, GCK_VKBD_MAX_KEYSTROKES, //Report Count (GCK_VKBD_MAX_KEYSTROKES) 
					0x15,0x00, //Logical Minimum (0)
					0x25,0xFF, //Logical Maximum (1)
					0x05,0x07, //Usage Page (Key Codes)
					0x19,0x00, //Usage Minimum (0) - from '1'				   ???
					0x29,0xFF, //Usage Maximum (255) -  ???
					0x81,0x00, //Input (Data, Array) - Key arrays
					0xC0	   //End Collection
				};

				
static	HID_DESCRIPTOR	VKBD_DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							VKBD_VERSION,
							VKBD_COUNTRY,
							VKBD_DESCRIPTOR_COUNT,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(VKBD_ReportDescriptor)}
							};

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_DriverEntry(IN PDRIVER_OBJECT  pDriverObject, IN PUNICODE_STRING pRegistryPath)
**
**	@func	Stows the Driver Object for later
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,	//@parm Driver Object
    IN PUNICODE_STRING pRegistryPath	//@parm Registry path for this driver
    )
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_DriverEntry\n"));
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pRegistryPath);
//	g_pDriverObject = pDriverObject;
	g_ulInstanceBits = 0x0;
	g_ulInstanceOverflow = 32; //For 33 and more devices
	return STATUS_SUCCESS;
}
	
/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_Create(OUT PDEVICE_OBJECT *ppDeviceObject)
**
**	@func	Creates a new Virtual Keyboard
**
**	@rdesc	STATUS_SUCCESS if it opens.
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_Create
(
	OUT PDEVICE_OBJECT *ppDeviceObject //@parm [out] Device Object of new virtual keyboard
)
{
	
	NTSTATUS	NtStatus;
	SWVB_EXPOSE_DATA	SwvbExposeData;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_Create *ppDeviceObject = 0x%0.8x\n", *ppDeviceObject));
	
	//Fill out SWVB_EXPOSE_DATA structure
	SwvbExposeData.pmwszDeviceId=L"SideWinderVirtualKeyboard\0\0";
	SwvbExposeData.pServiceTable = &VKbdServiceTable;
	SwvbExposeData.ulDeviceExtensionSize = sizeof(GCK_VKBD_EXT);
	SwvbExposeData.ulInitContext = (ULONG)ppDeviceObject;
	SwvbExposeData.pfnInitDevice = &GCK_VKBD_Init;
	
	//Get the instance ID
	ULONG ulBitMask;
	ULONG ulIndex;
	for(ulIndex = 0, ulBitMask = 1; ulIndex < 32; ulBitMask <<= 1, ulIndex++)
	{
		if(ulBitMask & ~g_ulInstanceBits)
		{
			g_ulInstanceBits |= ulBitMask;
			SwvbExposeData.ulInstanceNumber	= ulIndex;
			break;
		}
	}
	if(32 == ulIndex)
	{
		SwvbExposeData.ulInstanceNumber = g_ulInstanceOverflow++;
	}

	//Call virtual bus to expose virtual keyboard
	NtStatus=GCK_SWVB_Expose(&SwvbExposeData);
	
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_Init(	IN PDEVICE_OBJECT pDeviceObject, IN ULONG ulInitContext)
**
**	@func	Callback for Initializing new device object.  The ulInitContext
**			is a pointer to a pointer to a device object, so that we can pass
**			the pointer to the device object back to the caller of create.
**	@rdesc	STATUS_SUCCESS.
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_Init
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN ULONG ulInitContext
)
{
	PGCK_VKBD_EXT pDevExt;
	PDEVICE_OBJECT *ppSaveDeviceObject;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_Init pDeviceObject = 0x%0.8x\n", pDeviceObject));

	//Create sent us a pointer to a PDEVICE_OBJECT in which to return the new device object
	ppSaveDeviceObject = (PDEVICE_OBJECT *)ulInitContext;
	*ppSaveDeviceObject = pDeviceObject;
	
	//Get out part of the device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	//Mark device as stopped
	pDevExt->ucDeviceState= VKBD_STATE_STOPPED;
	
	//Mark the circular buffer as empty
	pDevExt->usReportBufferPos=0;
	pDevExt->usReportBufferCount=0;

	//Initialize locks
	GCK_InitRemoveLock(&pDevExt->RemoveLock, "SWVKBD_LOCK");

	//Initialize IrpQueue
	pDevExt->IrpQueue.Init(	CGuardedIrpQueue::CANCEL_IRPS_ON_DELETE |
							CGuardedIrpQueue::PRESERVE_QUEUE_ORDER,
							(CGuardedIrpQueue::PFN_DEC_IRP_COUNT)GCK_DecRemoveLock,
							&pDevExt->RemoveLock);


	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_Close(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Closes the virtual keyboard (removes it!)
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_Close
(
	IN PDEVICE_OBJECT pDeviceObject
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_Close pDeviceObject = 0x%0.8x\n", pDeviceObject));
	//Tell the virtual bus to kill us
	return GCK_SWVB_Remove(pDeviceObject);
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_SendReportPacket(IN PDEVICE_OBJECT pDeviceObject)
**
**	@func	Stuff a report into the circular buffer, and completes
**			an IRP if one is pending.
**
**	@rdesc	STATUS_SUCCESS on success
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_SendReportPacket
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PGCK_VKBD_REPORT_PACKET pReportPacket
)
{
	
	
	USHORT usBufferIndex;
	PGCK_VKBD_EXT pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	//
	//	Step 1. Stuff new packet into buffer
	//

	// Acquire Lock to work with buffer 
	IrpQueueWithSharedSpinLock.Acquire();
		

	//Find position in buffer to stuff at
	usBufferIndex = (pDevExt->usReportBufferPos + pDevExt->usReportBufferCount)%GCK_VKBD_STATE_BUFFER_SIZE;

	//Copy data
	pDevExt->rgReportBuffer[usBufferIndex] = *pReportPacket;
	
	//increment buffer count
	if(pDevExt->usReportBufferCount < GCK_VKBD_STATE_BUFFER_SIZE)
	{
		pDevExt->usReportBufferCount++;
	}
	else
	{
		//This assertion means buffer overflow
		ASSERT(FALSE);
		pDevExt->usReportBufferPos++;
	}
	
	
	//
	//	Step 2. Get Irp if there is one
	//
	PIRP pPendingIrp = IrpQueueWithSharedSpinLock.Remove();

	if(pPendingIrp)
	{
		//	Copy the data
		RtlCopyMemory(
			pPendingIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VKBD_REPORT_PACKET)
			);
	
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VKBD_STATE_BUFFER_SIZE;
		}
	}
	
	//We are done with the buffer spin lock
	IrpQueueWithSharedSpinLock.Release();
	
	if(pPendingIrp)
	{
		//  Fill out IRP status
		pPendingIrp->IoStatus.Information = sizeof(GCK_VKBD_REPORT_PACKET);
		pPendingIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pPendingIrp, IO_NO_INCREMENT);
		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}

	//All done
	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_ReadReport(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	If there is data in the keyboard buffer, completes the IRP
**			Otherwise, queues it, and set the idle timer.
**
**	@rdesc	STATUS_SUCCESS if read, STATUS_PENDING if waiting.
**
*************************************************************************************/
NTSTATUS 
GCK_VKBD_ReadReport
(
 IN PDEVICE_OBJECT pDeviceObject, 
 IN PIRP pIrp
)
{

	PGCK_VKBD_EXT pDevExt;
	PIO_STACK_LOCATION pIrpStack;
	KIRQL OldIrql;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VKBD_ReadReport pDeviceObject = 0x%0.8x, pIrp = 0x%0.8x\n", pDeviceObject, pIrp));
	
	//
	// Validate buffer size, because we do this the first time we see the IRP
	// we never need to worry about checking it again.
	//
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(GCK_VKBD_REPORT_PACKET))
	{
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_BUFFER_TOO_SMALL;
	}

	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	//Make an IRP queue accessor to share spin lock
	CShareIrpQueueSpinLock IrpQueueWithSharedSpinLock(&pDevExt->IrpQueue);
	
	// Count the IRP we are working on
	GCK_IncRemoveLock(&pDevExt->RemoveLock);
	
	// Acquire Lock to work with mouse buffer and Irp Queue
	IrpQueueWithSharedSpinLock.Acquire();

	// If there is data, complete the IRP
	if( pDevExt->usReportBufferCount)
	{
		//	Copy the data
		RtlCopyMemory(
			pIrp->UserBuffer, 
			&pDevExt->rgReportBuffer[pDevExt->usReportBufferPos],
			sizeof(GCK_VKBD_REPORT_PACKET)
			);
		
		//	Adjust buffer pos and count
		pDevExt->usReportBufferCount--;
		if(pDevExt->usReportBufferCount)
		{
			pDevExt->usReportBufferPos = (pDevExt->usReportBufferPos++)%GCK_VKBD_STATE_BUFFER_SIZE;
		}
		
		//We are done with the buffer spin lock
		IrpQueueWithSharedSpinLock.Release();

		//  Fill out IRP status
		pIrp->IoStatus.Information = sizeof(GCK_VKBD_REPORT_PACKET);
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		//We just completed an IRP decrement the count
		GCK_DecRemoveLock(&pDevExt->RemoveLock);
	}
	else 
	// There is no data, so queue the IRP.
	{
		return IrpQueueWithSharedSpinLock.AddAndRelease(pIrp);
	}

	//We completed the IRP and all is fine
	return STATUS_SUCCESS;
}

/***********************************************************************************
*
**	NTSTATUS GCK_VKBD_WriteToFakeLEDs(IN PIRP pIrp)
**
**	@func	In the context of any device object (hence not input parameter),
**			this function handle IOCTL_HID_WRITE_REPORT.  The only output
**			that virtual keyboards support is report ID 0 (the LED indicators)
**			and one byte of data is expected.	We verify this set the
**			IoStatus.Information and return the correct error code.  The IOCTL
**			dispatch set IoStatus.Status and completes the IRP.
**
**	@rdesc	STATUS_SUCCESS if OK, STATUS_INVALID_DEVICE_REQUEST if not Report ID 0
**			STATUS_INVALID_PARAMETER if the buffer is the wrong size.
**
*************************************************************************************/
NTSTATUS GCK_VKBD_WriteToFakeLEDs
(
	IN PIRP pIrp	// @parm [in/out] IRP for IOCTL_HID_WRITE_REPORT
)
{
	HID_XFER_PACKET	*pHidXferPacket;

	//We haven't copied anything yet
	pIrp->IoStatus.Information = 0;

	//	Cast UserBuffer to an XferPacket (this is what it is supposed to be.
	//	We don't verify the IOCTL code, because a good and trusted friend (GCK_VKBD_Ioctl)
	//	sent this IRP here, and is inefficient, not to mention painful, to check again.
	pHidXferPacket = (PHID_XFER_PACKET)pIrp->UserBuffer;

	//Verify Report ID
	if(0 /* Report ID of LED report */ != pHidXferPacket->reportId)
	{
		return STATUS_INVALID_DEVICE_REQUEST;
	}
	
	//Verify Repot Buffer Length
	if(1 /*1 byte - size of LED report*/ != pHidXferPacket->reportBufferLen)
	{
		return STATUS_INVALID_PARAMETER;
	}
	
	//Report that we received the one byte and set the virtual LED's accordingly
	pIrp->IoStatus.Information = 1;
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_CloseProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CLOSE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_CloseProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	//We don't control open and close, so just succeed
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_CloseProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_CreateProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_CREATE request sent from SWVB.  We don't
**			need to control anything, so we just succeed.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_CreateProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_CreateProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_IoctlProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_INTERNAL_IOCTL and IRP_MJ_IOCTL requests sent from SWVB.
**			Trivial IRPs are handle here, others are delegated.
**
**	@rdesc	STATUS_SUCCESS, and various errors
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_IoctlProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	NTSTATUS NtStatus;
	PIO_STACK_LOCATION pIrpStack;
	
	GCK_DBG_RT_ENTRY_PRINT(("Entering GCK_VKBD_IoctlProc\n"));
	
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrpStack->Parameters.DeviceIoControl.IoControlCode;
		
	// We complete everything, so the various cases
	// fill out status and information, and we complete
	// the IRP at the bottom.
	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_GET_PHYSICAL_DESCRIPTOR:
			pIrp->IoStatus.Information = 0;
			NtStatus =STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_ACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_DEACTIVATE_DEVICE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_SUCCESS;
			break;
		case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
			NtStatus = GCK_VKBD_GetDeviceAttributes(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
			NtStatus = GCK_VKBD_GetDeviceDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		case IOCTL_HID_GET_REPORT_DESCRIPTOR:
			NtStatus = GCK_VKBD_GetReportDescriptor(
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						pIrp->UserBuffer,
						&pIrp->IoStatus.Information
						);
			break;
		case IOCTL_HID_GET_STRING:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;  //Should we support this?
			break;
		case IOCTL_HID_READ_REPORT:
			//	Read report will complete the IRP, or queue as it sees fit, just delegate
			return GCK_VKBD_ReadReport(pDeviceObject, pIrp);
		case IOCTL_HID_SET_FEATURE:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
			break;
		case IOCTL_HID_WRITE_REPORT:
			//
			//	Fake LED's are the only output we support.  The routine verifies that
			//	this is what is being written to, and that the buffer size is correct
			//	If this is true, the routine will mark IoStatus.Information to say that
			//	got the new state and return STATUS_SUCCESS.  Otherwise, it will return
			//	STATUS_INVALID_DEVICE_REQUEST
			//
			NtStatus = GCK_VKBD_WriteToFakeLEDs(pIrp);
			break;
		default:
			pIrp->IoStatus.Information = 0;
			NtStatus = STATUS_NOT_SUPPORTED;
	}
	pIrp->IoStatus.Status = NtStatus;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_ReadProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_READ request sent from SWVB.  We don't support this.
**
**	@devnote This should never actually be called with the HIDSWVD.SYS mini-driver
**			 in the chain.  Good question for the review is if we need this.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_ReadProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_ReadProc\n"));
	UNREFERENCED_PARAMETER(pDeviceObject);
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}


/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_StartProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_START_DEVICE request sent from SWVB.
**			Just mark that we are started.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_StartProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	
	PGCK_VKBD_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_StartProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as started
	pDevExt->ucDeviceState = VKBD_STATE_STARTED;

	// PnP IRPs are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_StopProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_STOP_DEVICE request sent from SWVB.
**			Just mark that we are stopped.
**
**	@rdesc	STATUS_SUCCESS
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_StopProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VKBD_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);

	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_StopProc\n"));
	
	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);

	// Mark as stopped
	pDevExt->ucDeviceState = VKBD_STATE_STOPPED;
	
	// Cancel all I\O
	pDevExt->IrpQueue.CancelAll(STATUS_DELETE_PENDING);

	// PnP IRP are completed by SWVB
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_RemoveProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE request sent from SWVB.
**			Wait for all outstanding IO to complete before succeeding.  We don't
**			delete our device object that is up to SWVB.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_RemoveProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	PGCK_VKBD_EXT pDevExt;
	UNREFERENCED_PARAMETER(pIrp);
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_RemoveProc\n"));

	// Get device extension
	pDevExt = (PGCK_VKBD_EXT)GCK_SWVB_GetVirtualDeviceExtension(pDeviceObject);
	
	// Mark as Removed
	pDevExt->ucDeviceState = VKBD_STATE_REMOVED;
	
	//Clear Instance Bits
	ULONG ulInstance = GCK_SWVB_GetInstanceNumber(pDeviceObject);
	if(ulInstance < 32)
	{
		g_ulInstanceBits &= ~(1 << ulInstance);
	}

	// Remove the BIAS on the RemoveLock and wait for it to go to zero (forever)
	return GCK_DecRemoveLockAndWait(&pDevExt->RemoveLock, NULL);
	
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_WriteProc(IN PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
**
**	@func	Handles the the IRP_MJ_WRITE, which we don't support.  With HIDSWVD.SYS
**			as the functional driver this should never get called.
**
**	@rdesc	STATUS_NOT_SUPPORTED
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_WriteProc
(
 IN PDEVICE_OBJECT pDeviceObject,	//@parm [in] Device Object to handle request
 IN PIRP pIrp						//@parm [in\out] IRP to handle
)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_WriteProc\n"));
	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_NOT_SUPPORTED;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_GetDeviceDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_GetDeviceDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Device Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Device Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_GetDeviceDescriptor\n"));
	// Check buffer size
	if(ulBufferLength < sizeof(VKBD_DeviceDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VKBD_DeviceDescriptor, sizeof(VKBD_DeviceDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VKBD_DeviceDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_GetReportDescriptor(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_REPORT_DESCRIPTOR the data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_GetReportDescriptor
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Report Descriptor
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Report Descriptor Copied
)
{
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_GetReportDescriptor\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(VKBD_ReportDescriptor))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Copy bytes
	RtlCopyMemory(pvUserBuffer, &VKBD_ReportDescriptor, sizeof(VKBD_ReportDescriptor));
	// Record number of bytes copied
	*pulBytesCopied = sizeof(VKBD_ReportDescriptor);
	// Return Success
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS GCK_VKBD_GetDeviceAttributes(IN ULONG ulBufferLength, OUT PVOID pvUserBuffer,
**										  OUT PULONG pulBytesCopied)
**
**	@func	Helps handles IOCTL_HID_GET_DEVICE_ATTRIBUTES. The data is statically
**			declared at the top of this file.
**
**	@rdesc STATUS_SUCCESS
**	@rdesc STATUS_BUFFER_TOO_SMALL
**
*************************************************************************************/
NTSTATUS
GCK_VKBD_GetDeviceAttributes
(
	IN ULONG	ulBufferLength,	//@parm [in] Length of User Buffer
	OUT PVOID	pvUserBuffer,	//@parm [out] User Buffer which accepts Attributes
	OUT PULONG	pulBytesCopied	//@parm [out] Size of Attributes Copied
)
{
	PHID_DEVICE_ATTRIBUTES	pDeviceAttributes = (PHID_DEVICE_ATTRIBUTES)pvUserBuffer;
	
	GCK_DBG_ENTRY_PRINT(("Entering GCK_VKBD_GetDeviceAttributes\n"));

	// Check buffer size
	if(ulBufferLength < sizeof(HID_DEVICE_ATTRIBUTES))
	{
		*pulBytesCopied = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	// Fill out attributes structures
	pDeviceAttributes->Size = sizeof(HID_DEVICE_ATTRIBUTES);
	pDeviceAttributes->VendorID = MICROSOFT_VENDOR_ID;
	pDeviceAttributes->ProductID = VKBD_PRODUCT_ID;
	pDeviceAttributes->VersionNumber = VKBD_VERSION;
	// Record number of bytes copied
	*pulBytesCopied = sizeof(HID_DEVICE_ATTRIBUTES);
	// Return Success
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\gckernel.sys\vmmid.h ===
#ifndef	__VMMID_H__
#define	__VMMID_H__

// VMM Items we are interested in, the whole table is just to big to define
#define	__Hook_Device_Service 0x00010090
#define	__Unhook_Device_Service 0x0001011C

// Define the VKD service table (not so big, whole thing)
#define VKD_DEVICE_ID	    0x0000D
enum VKD_SERVICES {
    VKD_dummy = (VKD_DEVICE_ID << 16) - 1,
	__VKD_Get_Version,
	__VKD_Define_Hot_Key,
	__VKD_Remove_Hot_Key,
	__VKD_Local_Enable_Hot_Key,
	__VKD_Local_Disable_Hot_Key,
	__VKD_Reflect_Hot_Key,
	__VKD_Cancel_Hot_Key_State,
	__VKD_Force_Keys,
	__VKD_Get_Kbd_Owner,
	__VKD_Define_Paste_Mode,
	__VKD_Start_Paste,
	__VKD_Cancel_Paste,
	__VKD_Get_Msg_Key,
	__VKD_Peek_Msg_Key,
	__VKD_Flush_Msg_Key_Queue,
	//
	// The following services are new for Windows 4.0.
	//
	__VKD_Enable_Keyboard,
	__VKD_Disable_Keyboard,
	__VKD_Get_Shift_State,
	__VKD_Filter_Keyboard_Input,
	__VKD_Put_Byte,
	__VKD_Set_Shift_State,
	//
	// New for Windows 98 (VKD version 0300h)
	//
	__VKD_Send_Data,
	__VKD_Set_LEDs,
	__VKD_Set_Key_Rate,
	//VKD_Service VKD_Get_Key_Rate
    Num_VKD_Services
};

#define VxDCall(service)	\
	__asm _emit 0xcd \
	__asm _emit 0x20 \
	__asm _emit ((service) & 0xff) \
	__asm _emit (((service) >> 8) & 0xff) \
	__asm _emit (((service) >> 16) & 0xff) \
	__asm _emit (((service) >> 24) & 0xff)

#endif	__VMMID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\hidswvd.sys\hidswvd.c ===
//	@doc
/**********************************************************************
*
*	@module	HIDSWVD.c	|
*
*	Implementation of the SideWinder Virtual Device Hid Mini-Driver
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	An overview is provided in HIDSWVD.H
*
*	@xref HIDSWVD
*
**********************************************************************/
#include <WDM.H>
#include <HIDPORT.H>
#include "HIDSWVD.H"

//---------------------------------------------------------------------------
// Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, HIDSWVD_Power)
#pragma alloc_text (PAGE, HIDSWVD_AddDevice)
#pragma alloc_text (PAGE, HIDSWVD_Unload)
#endif

/***********************************************************************************
**
**	NTSTATUS DriverEntry(IN PDRIVER_OBJECT  pDriverObject, IN PUNICODE_STRING puniRegistryPath)
**
**	@func	Initializes driver, by setting up serivces and registering with HIDCLASS.SYS
**
**	@rdesc	Returns value from HidRegisterMinidriver call.
**
*************************************************************************************/
NTSTATUS
DriverEntry
(
    IN PDRIVER_OBJECT  pDriverObject, 	// @parm Driver Object from Loader
	IN PUNICODE_STRING puniRegistryPath	// @parm Registry Path for this Driver
)
{
	NTSTATUS NtStatus = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION HidMinidriverRegistration;
	
	PAGED_CODE();
	
	//This suffice as out entry trace out for DriverEntry, and tell everyone when we were built
	HIDSWVD_DBG_PRINT(("Built %s at %s\n", __DATE__, __TIME__));    
	
    //Setup Entry Table
	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HIDSWVD_PassThrough;
    pDriverObject->MajorFunction[IRP_MJ_PNP]                     = HIDSWVD_PassThrough;
	pDriverObject->MajorFunction[IRP_MJ_POWER]                   = HIDSWVD_Power;
	pDriverObject->DriverExtension->AddDevice                    = HIDSWVD_AddDevice;
    pDriverObject->DriverUnload                                  = HIDSWVD_Unload;

    
    // Setup registration structure for HIDCLASS.SYS module
    HidMinidriverRegistration.Revision              = HID_REVISION;
    HidMinidriverRegistration.DriverObject          = pDriverObject;
    HidMinidriverRegistration.RegistryPath          = puniRegistryPath;
    HidMinidriverRegistration.DeviceExtensionSize   = sizeof(HIDSWVB_EXTENSION);

    // SideWinder Virtual Devices are not polled.
    HidMinidriverRegistration.DevicesArePolled      = FALSE;

    //Register with HIDCLASS.SYS
	NtStatus = HidRegisterMinidriver(&HidMinidriverRegistration);

	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS HIDSWVD_PassThrough(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Passes IRPs down to SWVB module in GcKernel.
**
**	@rdesc	Value returned by IoCallDriver to GcKernel
**
*************************************************************************************/
NTSTATUS
HIDSWVD_PassThrough(
    IN PDEVICE_OBJECT pDeviceObject,	//@parm Device Object to pass down
    IN PIRP pIrp						//@parm IRP to pass down
    )
{
	//***
	//***	NO TRACEOUT HERE IT WOULD GET CALLED TOO FREQUENTLY
	//***

	//Get the top of stack from the HIDCLASS part of the device extension (this is documented).
	PDEVICE_OBJECT pTopOfStack = ((PHID_DEVICE_EXTENSION)pDeviceObject->DeviceExtension)->NextDeviceObject;
	//Call down to SWVB in GcKernel
	IoSkipCurrentIrpStackLocation (pIrp);
    return IoCallDriver (pTopOfStack, pIrp);
}

/***********************************************************************************
**
**	HIDSWVD_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pDeviceObject)		
**
**	@func	Does nothing, we need to have an AddDevice to be PnP compliant, but we have nothing
**			to do.
**	@rdesc	Returnes STATUS_SUCCESS.
**
*************************************************************************************/
NTSTATUS
HIDSWVD_AddDevice(
    IN PDRIVER_OBJECT pDriverObject,	//@parm Driver Object (for our reference)
    IN PDEVICE_OBJECT pDeviceObject		//@parm Device Object (already created by HIDCLASS.SYS)
    )
{
	PAGED_CODE();
    UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pDeviceObject);
	HIDSWVD_DBG_PRINT(("Device Object 0x%0.8x was added to pDriverObject 0x%0.8x\n", pDeviceObject, pDriverObject));
	return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	NTSTATUS HIDSWVD_Power (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_POWER
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS HIDSWVD_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
	PDEVICE_OBJECT pTopOfStack = ((PHID_DEVICE_EXTENSION)pDeviceObject->DeviceExtension)->NextDeviceObject;

	PAGED_CODE ();

	//	Tell system we are ready for the next power IRP
    PoStartNextPowerIrp (pIrp);		        
    
	// NOTE!!! PoCallDriver NOT IoCallDriver.
	//Get the top of stack from the HIDCLASS part of the device extension (this is documented).
		
	IoSkipCurrentIrpStackLocation (pIrp);
    return  PoCallDriver (pTopOfStack, pIrp);
}

/***********************************************************************************
**
**	HIDSWVD_Unload(IN PDRIVER_OBJECT pDriverObject)
**
**	@func	Does nothing, but we will never be unloaded if we don't
**			return something.
**	@rdesc	None
**
*************************************************************************************/
VOID
HIDSWVD_Unload(
    IN PDRIVER_OBJECT pDriverObject	//@parm DriverObject - in case we store some globals in there.
    )
{
	UNREFERENCED_PARAMETER(pDriverObject);
	
	PAGED_CODE();

	HIDSWVD_DBG_PRINT(("Unloading\n"));    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\hidswvd.sys\hidswvd.h ===
//	@doc
/**********************************************************************
*
*	@module	HIDSWVD.h	|
*
*	Definitions and Declarations for Dummy Hid-Mini driver for virtual devices
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	HIDSWVD	|
*	The SideWinder Virtual Bus (SWVB) that is created by GcKernel needs a dummy
*	driver in order to expose HID devices.  The difficulty is that HIDCLASS
*	really does require a separate layer for these device objects.
*	This driver fits the bill.  It does absolutely nothing, except pass IRPs down
*	to the SWVB module in GcKernel which handles everything.
**********************************************************************/


// @struct HIDSWVB_EXTENSION | Minimum HID device extension.
typedef struct tagHIDSWVB_EXTENSION
{
	ULONG ulReserved;		// @field a Placeholder as extension needs non-zero size
} HIDSWVB_EXTENSION, *PHIDSWVB_EXTENSION;


//---------------------------------------------------------------------------
// Function prototypes
//---------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS
HIDSWVD_PassThrough(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
HIDSWVD_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );
NTSTATUS
HIDSWVD_Power 
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
	);

VOID
HIDSWVD_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

//-------------------------------------------------------------------------------
// Debug macros
//-------------------------------------------------------------------------------
#if (DBG==1)
#define HIDSWVD_DBG_PRINT(__x__)\
	{\
		DbgPrint("HIDSWVD: ");\
		DbgPrint __x__;\
	}
#else
#define HIDSWVD_DBG_PRINT(__x__)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\inc\ieevents.h ===
#ifndef __IEEVENTS_H_
#define __IEEVENTS_H_

#define	IE_KEY_MAXSTROKES				3

typedef	struct
{
	WORD				wVirtKey;
	WORD				wScanCode;
	BYTE				bFlags;	
}	IE_KEYSTROKE, *PIE_KEYSTROKE;

typedef	struct
{
	UINT				uCount;
	IE_KEYSTROKE	KeyStrokes[IE_KEY_MAXSTROKES];
}	IE_KEYEVENT,  *PIE_KEYEVENT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\inc\gckernel.h ===
//**************************************************************************
//
//		GCKERNEL.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		Global includes and definitions for GcKernel driver interface
//
//**************************************************************************

#ifndef	_GCKERNEL_H
#define	_GCKERNEL_H

#ifndef	RC_INVOKED
#include	<profile.h>
#endif

//---------------------------------------------------------------------------
//			Version Information
//---------------------------------------------------------------------------

#define	GCKERNEL_Major				0x03
#define	GCKERNEL_Minor				0x00
#define	GCKERNEL_Build				0x00
#define	GCKERNEL_Version_Rc		GCKERNEL_Major,GCKERNEL_Minor,0,GCKERNEL_Build
#define	GCKERNEL_Version_Int		((GCKERNEL_Build << 16)+(GCKERNEL_Major << 8)+(GCKERNEL_Minor))
#define	GCKERNEL_Company_Str		"Microsoft Corporation\0"
#define	GCKERNEL_Version_Str		"3.00.00\0"
#define	GCKERNEL_Product_Str		"Game Device Profiler Kernel Driver\0"
#define	GCKERNEL_Copyright_Str	"Copyright  Microsoft Corporation, 1998\0"
#ifdef	_NTDDK_
#define	GCKERNEL_Filename_Str	"Gckernel.Sys\0"
#else
#define	GCKERNEL_Filename_Str	"Gckernel.Vxd\0"
#endif

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

#define	GCKERNEL_DEVICE_ID			0xE1
#define	MAX_ACTIVE_DEVICES 			4						// maximum active devices
#define	MAX_ACTIVE_PROFILES			4						// maximum active profiles

#define GCKNOTIFY_MACROINPROGRESS	1
#define GCKNOTIFY_IDLE				2

#ifdef	WIN_NT
#define	GCKERNEL_DEVICE_NAME			TEXT("\\Device\\GcKernel")
#define	GCKERNEL_DEVICE_NAME_U			 L"\\Device\\GcKernel"
#define	GCKERNEL_SYMBOLIC_NAME		TEXT("\\DosDevices\\GcKernel")
#define	GCKERNEL_SYMBOLIC_NAME_U		 L"\\DosDevices\\GcKernel"
#endif	// WIN_NT

#endif	// _GCKERNEL_H

//===========================================================================
//			End
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\inc\profile.h ===
/****************************************************************************
*
*	File				:	PROFILE.H
*
*	Description		:	GDP Profile definition file.
*
*	Author			:	Jeffrey A. Davis. et. al.
*
*	Creation Date	:	You name it.
*
*	(c) 1986-1997 Microsoft Corporation.	All rights reserved.
*
****************************************************************************/

#ifndef _PROFILE_H
#define _PROFILE_H

#pragma pack(push, default_alignment)
#pragma pack(1)

#ifndef DWORD
#define DWORD unsigned long
#endif
#ifndef WORD
#define WORD unsigned short
#endif

#ifndef UINT
#define UINT unsigned int
#endif

#ifndef MAX_PATH
#define MAX_PATH (260)
#endif

#define ATLAS_DATAFORMAT_MAJ_VERSION	148
#define ATLAS_DATAFORMAT_MIN_VERSION	4
#define DATAFORMAT_MAJ_VERSION		3
#define DATAFORMAT_MIN_VERSION		0
#define DATAFORMAT_SIGNATURE			("SideWinder")
#define DATAFORMAT_SIGNATURE_LENGTH	10

#define GDP_REGSTR "SOFTWARE\\Microsoft\\Gaming Input Devices\\Game Device Profiler"
#define PROPPAGE_REGSTR "SOFTWARE\\Microsoft\\Gaming Input Devices\\Game Device Profiler\\Devices\\"
#define PROFILES_REGSTR "SOFTWARE\\Microsoft\\Gaming Input Devices\\Game Device Profiler\\Profiles"
#define DEVICES_REGSTR PROPPAGE_REGSTR

// Device IDs
#define GDP_DEVNUM_JOLT						1
#define GDP_DEVNUM_FLASH					2
#define GDP_DEVNUM_JUNO						3
#define GDP_DEVNUM_MIDAS					4
#define GDP_DEVNUM_SHAZAM					5
#define GDP_DEVNUM_CLEO  					6

// GCKERNEL.VXD IOCTLs
#define	IOCTL_SET_PROFILE_ACTIVE		1
#define	IOCTL_SET_PROFILE_INACTIVE		2
#define	IOCTL_SUSPEND_PROFILE			3
#define	IOCTL_RESUME_PROFILE				4
#define	IOCTL_GETRAWPACKET				10		// debug only test hook
#define	IOCTL_SET_SENSE_CURVES			11		// debug only test hook

// OLD GDP 1.0 devive id definitions
#define SWGAMEPAD_PROFILER_BASE_ID		1
#define SW3DPRO_PROFILER_BASE_ID			5

typedef enum	{NO_DEVICE=-1, GAMEPAD=0, JOYSTICK, MOUSE, KEYBOARD}	DEVICETYPE;

#define MAX_PROPERTY_PAGES					04
#define MAX_PROFILE_NAME					MAX_PATH
#define MAX_DEVICE_NAME						64
#define MAX_MACRO_NAME						64
#define MAX_MACRO_EVENTS					32
#define MAX_BUTTON_MACROS					20
#define MAX_POV_MACROS						8
#define MAX_DPAD_MACROS						8
#define MAX_MACROS							(MAX_BUTTON_MACROS + MAX_POV_MACROS + MAX_DPAD_MACROS)
#define MAX_SCANCODES						03
#define MAX_ATLAS_MACROS					20

// Atlas SETTINGS Individual Flags
#define ATLAS_SETTINGS_EMULATE_CHPRO			0x01
#define ATLAS_SETTINGS_EMULATE_THRUSTMASTER	0x02
#define ATLAS_SETTINGS_SENSE_HIGH				0x04
#define ATLAS_SETTINGS_SENSE_MEDIUM				0x08
#define ATLAS_SETTINGS_SENSE_LOW					0x10
#define ATLAS_SETTINGS_AXISSWAP_TWIST			0x20
#define ATLAS_SETTINGS_AXISSWAP_LEFTRIGHT		0x40

// SETTINGS Group Flags
#define	ATLAS_SETTINGS_EMULATE_GROUP	(ATLAS_SETTINGS_EMULATE_CHPRO|ATLAS_SETTINGS_EMULATE_THRUSTMASTER)
#define	ATLAS_SETTINGS_SENSE_GROUP		(ATLAS_SETTINGS_SENSE_HIGH|ATLAS_SETTINGS_SENSE_MEDIUM|ATLAS_SETTINGS_SENSE_LOW)
#define	ATLAS_SETTINGS_AXISSWAP_GROUP	(ATLAS_SETTINGS_AXISSWAP_TWIST|ATLAS_SETTINGS_AXISSWAP_LEFTRIGHT)

// Xena SETTINGS flags
#define SETTINGS_EMULATION_GROUP		0x00000003
#define SETTINGS_EMULATION_CHPRO		0x00000001
#define SETTINGS_EMULATION_THRUSTMASTER	0x00000002
#define SETTINGS_AXIS_SWAP_GROUP		0x0000000C
#define SETTINGS_AXIS_SWAP_TWIST		0x00000004
#define SETTINGS_AXIS_SWAP_LEFT_RIGHT		0x00000008
#define SETTINGS_PEDAL_GROUP			0x00000030
#define SETTINGS_PEDAL_COMBINED		0x00000010
#define SETTINGS_PEDAL_SEPARATE		0x00000020
#define SETTINGS_X_DEAD_ZONE			0x00000040
#define SETTINGS_X_RANGE_OF_MOTION		0x00000080
#define SETTINGS_Y_DEAD_ZONE			0x00000100
#define SETTINGS_Y_RANGE_OF_MOTION		0x00000200
#define SETTINGS_Z_DEAD_ZONE			0x00000400
#define SETTINGS_Z_RANGE_OF_MOTION		0x00000800
#define SETTINGS_R_DEAD_ZONE			0x00001000
#define SETTINGS_R_RANGE_OF_MOTION		0x00002000
#define SETTINGS_U_DEAD_ZONE			0x00004000
#define SETTINGS_U_RANGE_OF_MOTION		0x00008000
#define SETTINGS_V_DEAD_ZONE			0x00010000
#define SETTINGS_V_RANGE_OF_MOTION		0x00020000

// MACRO types
#define BUTTON_MACRO	0
#define	POV_MACRO		1
#define DPAD_MACRO		2

// MACROEVENT Flags
#define MACROFLAG_KEYSONLY			0x00000001
#define MACROFLAG_HASDPADDATA		0x00000002

// PROFILE FLAGS
#define PROFILEFLAG_HAS_SETTINGS	0x00000001	
#define PROFILEFLAG_HAS_POVMACROS	0x00000002
#define PROFILEFLAG_HAS_DPADMACROS	0x00000004

typedef struct tagPROFENTRY
{
	char	szName[MAX_PROFILE_NAME];	// full path name.
	GUID	DevCLSID;						// device clsid.
	int	iActive;							// Bit field Active state
												// where: LSB = Device inst. 1
												//			 MSB = Device inst. 32	
}PROFENTRY;

typedef struct tagATLASPROFENTRY
{
	char	szName[MAX_PROFILE_NAME];	// full path name.
	int	iDevNumber;						// device number (GDP_DEVNUM_XXXX)
	int	iActive;							// Bit field Active state
												// where: LSB = Device inst. 1
												//			 MSB = Device inst. 32	
}ATLASPROFENTRY;


typedef struct tagSETTING
{
	DWORD	dwSettingsFlag;
	DWORD	dwXDeadZone;			// 0 to 1023
	DWORD	dwXRangeOfMotion;		// 0 to 1023
	DWORD	dwYDeadZone;			// 0 to 1023
	DWORD	dwYRangeOfMotion;		// 0 to 1023
	DWORD	dwZDeadZone;			// 0 to 1023
	DWORD	dwZRangeOfMotion;		// 0 to 1023
	DWORD	dwRDeadZone;			// 0 to 1023
	DWORD	dwRRangeOfMotion;		// 0 to 1023
	DWORD	dwUDeadZone;			// 0 to 1023
	DWORD	dwURangeOfMotion;		// 0 to 1023
	DWORD	dwVDeadZone;			// 0 to 1023
	DWORD	dwVRangeOfMotion;		// 0 to 1023
} SETTING, *PSETTING;

typedef struct tagATLAS_SETTING
{
	DWORD	dwSettingsFlag;
} ATLAS_SETTING, *PATLAS_SETTING;

typedef struct tagDEVICE_DATA
{
	WORD		wX;
	WORD		wY;
	WORD		wButtons;
	WORD		wPOV;
}	DEVICE_DATA,*PDEVICE_DATA;

typedef struct tagMACROEVENT
{
	DWORD			dwDuration;
	char			nKeyCodes;
	WORD			scanCode[MAX_SCANCODES];
	DEVICE_DATA		deviceData;
}	MACROEVENT,	*PMACROEVENT;

typedef struct tagATLAS_DEVICE_DATA
{
	WORD		wX;
	WORD		wY;
	WORD		wButtons;
}	ATLAS_DEVICE_DATA,*PATLAS_DEVICE_DATA;

typedef struct tagATLAS_MACROEVENT
{
	DWORD	dwDuration;
	char	nKeyCodes;
	WORD	scanCode[MAX_SCANCODES];
	ATLAS_DEVICE_DATA	deviceData;
}	ATLAS_MACROEVENT,	*PATLAS_MACROEVENT;

typedef struct tagMACRO
{
	char	name[MAX_MACRO_NAME];
	DWORD	macroTrigger;
	int		nEvents;
	DWORD	flags;
	MACROEVENT	event[MAX_MACRO_EVENTS];
}	MACRO,		*PMACRO;

typedef struct tagATLAS_MACRO
{
	char	name[MAX_MACRO_NAME];
	DWORD	macroTrigger;
	int		nEvents;
	DWORD	flags;
	ATLAS_MACROEVENT	event[MAX_MACRO_EVENTS];
}	ATLAS_MACRO,	*PATLAS_MACRO;


typedef struct tagPROFILEVERINFO
{
   DWORD dwMajorVersion;	// Data format major version.	     
	DWORD dwMinorVersion;   // Data format minor version.	       
	char	szSignature[10];	// "SideWinder"
} PROFILEVERINFO; 

typedef struct tagPROFILE_HEADER
{
	int				iSize;		// size of PROFILE
	PROFILEVERINFO	vi;				
	GUID				clsid;
}	PROFILE_HEADER;



typedef struct _VERSIONINFO
{
	DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion;     
	DWORD dwMinorVersion;     
	DWORD dwBuildNumber; 
    DWORD dwPlatformId;     
	char  szCSDVersion[128]; 
} VERSIONINFO; 

typedef struct tagATLAS_PROFILE_HEADER
{
	int				iSize;		// size of PROFILE
	VERSIONINFO		vi;				
	GUID				clsid;
}	ATLAS_PROFILE_HEADER;

//#ifdef _XENA

typedef struct tagPROFILE	
{
	PROFILE_HEADER header;
	DWORD	dwFlags;							
	SETTING	Settings;								
	DWORD	dwReserved1;						
	DWORD	dwReserved2;
	UINT	nMacros;

	UINT	nButtonMacros;								
	DWORD	dwButtonUsageArray;	
//	union tagBtn
//	{
		UINT	iButtonMacros;
//		MACRO*  aButtonMacro;
//	};

	UINT	nPOVMacros;								
	DWORD	dwPOVUsageArray;					
//	union tagPOV
//	{
		UINT	iPOVMacros;
//		MACRO*	aPOVMacro;
//	};

	UINT	nDPadMacros;
	DWORD	dwDPadUsageArray;
//	union tagDpad
//	{
		UINT	iDPadMacros;
//		MACRO*	aDPadMacro;
//	};

	MACRO macro[1];
}	PROFILE,	*PPROFILE;

typedef	struct tagACTIVE_PROFILE
{
	int		nUnitId;								
	PROFILE	Profile;								
	MACRO		btnMacros[MAX_BUTTON_MACROS-1];
	MACRO		povMacros[MAX_POV_MACROS];
	MACRO		dpadMacros[MAX_DPAD_MACROS];
}	ACTIVE_PROFILE, *PACTIVE_PROFILE;

typedef struct	tagATLAS_PROFILE
{
	UINT		uDeviceNumber;					//	see GDP_DEVNUM 
	DWORD		dwFlags;							// see PROFILE FLags
	int			nMacros;							// number of MACROs
	DWORD		dwMacroUsageArray;			// Macro Usage Bit Array.
	ATLAS_MACRO		Macros[MAX_ATLAS_MACROS];	// List of MACROs
	ATLAS_SETTING	Settings;						// SETTINGS
	DWORD		dwReserved1;					// future expansion
	DWORD		dwReserved2;
}	ATLAS_PROFILE,	*PATLAS_PROFILE;

typedef	struct tagACTIVE_ATLAS_PROFILE
{
	int		 nUnitId;								// instance of device
	ATLAS_PROFILE	Profile;						// profile for instance
}	ACTIVE_ATLAS_PROFILE, *PACTIVE_ATLAS_PROFILE;


//#endif // _XENA

#pragma pack(pop, default_alignment)

#endif	//	_PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\inc\gckernel.inc ===
;**************************************************************************
;
;	GCKERNEL.H -- Xena Gaming Project
;
;	Version 3.XX
;
;	Copyright (c) 1998 Microsoft Corporation. All rights reserved.
;
;	Global includes and definitions for GcKernel driver interface
;
;**************************************************************************

GCKERNEL_DEVICE_ID 	EQU 0E1h	; make sure this is same as GCKERNEL.H

Begin_Service_Table	GCKERNEL
End_Service_Table	GCKERNEL

GCKernel_GetVersion 	EQU 70000001h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\debug.c ===
//**************************************************************************
//
//		DEBUG.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	DEBUG.C | Supports debugging output (DBG builds only)
//**************************************************************************

#if (DBG==1)														// skip rest of file

//---------------------------------------------------------------------------
//			Include Files
//---------------------------------------------------------------------------

#include	"msgame.h"
#include	<stdio.h>
#include	<stdarg.h>

//---------------------------------------------------------------------------
//			Private Data
//---------------------------------------------------------------------------

DBG_LEVEL	DebugLevel = DBG_DEFAULT;

//---------------------------------------------------------------------------
// @func		Set conditional debug level
// @parm		DBG_LEVEL | uLevel | New debug output priority
// @rdesc	Old debug output priority
//	@comm		Public function available on DBG builds only
//---------------------------------------------------------------------------

DBG_LEVEL	DEBUG_Level (DBG_LEVEL uLevel)
{
	EXCHANGE(uLevel, DebugLevel);
	return (uLevel);
};

//---------------------------------------------------------------------------
// @func		Writes conditional debug output
// @parm		DBG_LEVEL | uLevel | Debug output priority
// @parm		PCSZ | szMessage | Formating string
// @parmvar	One or more variable arguments
// @rdesc	None
//	@comm		Public function available on DBG builds only
//---------------------------------------------------------------------------

VOID	DEBUG_Print (DBG_LEVEL uLevel, PCSZ szMessage, ...)
{
	va_list	ap;
	va_start (ap, szMessage);

	if (uLevel <= DebugLevel)
		{
		CHAR	szBuffer[256];

		_vsnprintf (szBuffer, sizeof (szBuffer), szMessage, ap);
		DbgPrint (szBuffer);
		}

	va_end (ap);
}

//===========================================================================
//			End
//===========================================================================
#endif	//	DBG=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\inc\msgamio.h ===
//**************************************************************************
//
//		MSGAMIO.H -- Xena Gaming Project
//
//		Version 2.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	MSGAMIO.H | Global includes and definitions for gameport driver interface
//**************************************************************************

#ifndef	__MSGAMIO_H__
#define	__MSGAMIO_H__

#ifdef	SAITEK
#define	MSGAMIO_NAME				"SAIIO"
#else
#define	MSGAMIO_NAME				"MSGAMIO"
#endif

//---------------------------------------------------------------------------
//			Version Information
//---------------------------------------------------------------------------

#define	MSGAMIO_Major				0x02
#define	MSGAMIO_Minor				0x00
#define	MSGAMIO_Build				0x00
#define	MSGAMIO_Version_Rc		MSGAMIO_Major,MSGAMIO_Minor,0,MSGAMIO_Build
#define	MSGAMIO_Version_Int		((MSGAMIO_Build << 16)+(MSGAMIO_Major << 8)+(MSGAMIO_Minor))
#define	MSGAMIO_Version_Str		"2.00.00\0"
#define	MSGAMIO_Copyright_Str	"Copyright  Microsoft Corporation, 1998\0"

#ifdef	SAITEK
#define	MSGAMIO_Company_Str		"SaiTek Corporation\0"
#define	MSGAMIO_Product_Str		"SaiTek Gameport Driver Interface\0"
#ifdef	WIN_NT
#define	MSGAMIO_Filename_Str		"Saiio.Sys\0"
#else
#define	MSGAMIO_Filename_Str		"Saiio.Vxd\0"
#endif
#else
#define	MSGAMIO_Company_Str		"Microsoft Corporation\0"
#define	MSGAMIO_Product_Str		"SideWinder Gameport Driver Interface\0"
#ifdef	WIN_NT
#define	MSGAMIO_Filename_Str		"Msgamio.Sys\0"
#else
#define	MSGAMIO_Filename_Str		"Msgamio.Vxd\0"
#endif
#endif

//**************************************************************************
#ifndef	RC_INVOKED												// Skip Rest of File
//**************************************************************************

//---------------------------------------------------------------------------
//			Global Limits
//---------------------------------------------------------------------------

#define	MAX_MSGAMIO_SERVERS			4
#define	MAX_MSGAMIO_CLIENTS			16

//---------------------------------------------------------------------------
//			Transaction Types
//---------------------------------------------------------------------------

typedef enum
{												// @enum MSGAMIO_TRANSACTIONS | Device transaction types
	MSGAMIO_TRANSACT_NONE,				// @emem No transaction type
	MSGAMIO_TRANSACT_RESET,				// @emem Reset transaction type
	MSGAMIO_TRANSACT_DATA,				// @emem Data transaction type
	MSGAMIO_TRANSACT_ID,	  				// @emem Id transaction type
	MSGAMIO_TRANSACT_STATUS,			// @emem Status transaction type
	MSGAMIO_TRANSACT_SPEED,				// @emem Speed transaction type
	MSGAMIO_TRANSACT_GODIGITAL,		// @emem GoDigital transaction type
	MSGAMIO_TRANSACT_GOANALOG			// @emem GoAnalog transaction type
} 	MSGAMIO_TRANSACTION;

//---------------------------------------------------------------------------
//			Types
//---------------------------------------------------------------------------

#ifndef	STDCALL
#define	STDCALL		_stdcall
#endif

//---------------------------------------------------------------------------
//			GUIDs
//---------------------------------------------------------------------------


#ifndef	GUID_DEFINED
#define	GUID_DEFINED

typedef struct
{
#pragma pack (1)
	unsigned	long	Data1;
	unsigned	short	Data2;
	unsigned	short	Data3;
	unsigned	char	Data4[8];
#pragma pack()
}	GUID, *PGUID;

#else

typedef	GUID	*PGUID;

#endif	//	GUID_DEFINED

__inline BOOLEAN STDCALL IsGUIDEqual (PGUID pGuid1, PGUID pGuid2)
{
	ULONG		i	=	sizeof(GUID);
	PUCHAR	p1 =	(PUCHAR)pGuid1;
	PUCHAR	p2 =	(PUCHAR)pGuid2;

	while (i--)
		if (*p1++ != *p2++)
			return (FALSE);
	return (TRUE);
}

//---------------------------------------------------------------------------
//			Server GUIDs
//---------------------------------------------------------------------------

#ifdef	SAITEK
#define	MSGAMIO_MSGAME_GUID		\
			{0xcaca0c60,0xe40a,0x11d1,0x99,0x6f,0x44,0x45,0x53,0x54,0x00,0x01}
#define	MSGAMIO_GCKERNEL_GUID	\
			{0xcaca0c61,0xe40a,0x11d1,0x99,0x6f,0x44,0x45,0x53,0x54,0x00,0x01}
#else
#define	MSGAMIO_MSGAME_GUID		\
			{0xb9292380,0x628a,0x11d1,0xaa,0xa5,0x04,0x76,0xa6,0x00,0x00,0x00}
#define	MSGAMIO_GCKERNEL_GUID	\
			{0x95e69580,0x97d5,0x11d1,0x99,0x6f,0x00,0xa0,0x24,0xbe,0xbf,0xf5}
#endif

//---------------------------------------------------------------------------
//			Client GUIDs
//---------------------------------------------------------------------------

#define	MSGAMIO_MIDAS_GUID	\
			{0x12D41A36,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_JUNO_GUID		\
			{0xC948CE81,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_JOLT_GUID		\
			{0xC948CE82,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_SHAZAM_GUID	\
			{0xC948CE83,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_FLASH_GUID	\
			{0xC948CE84,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_TILT_GUID		\
			{0xC948CE86,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_TILTUSB_GUID		\
			{0xC948CE89,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#define	MSGAMIO_APOLLO_GUID	\
			{0xC948CE88,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}

#ifdef	SAITEK
#define	MSGAMIO_LEDZEP_GUID	\
			{0xcaca0c62,0xe40a,0x11d1,0x99,0x6f,0x44,0x45,0x53,0x54,0x00,0x01}
#else
#define	MSGAMIO_LEDZEP_GUID	\
			{0xC948CE87,0x9026,0x11d0,0x9F,0xFE,0x00,0xA0,0xC9,0x11,0xF5,0xAF}
#endif

//---------------------------------------------------------------------------
//			Macros
//---------------------------------------------------------------------------

#ifndef	STILL_TO_DO
#define	STD0(txt)			#txt
#define	STD1(txt)			STD0(txt)
#define	STILL_TO_DO(txt)	message("\nSTILL TO DO: "__FILE__"("STD1(__LINE__)"): "#txt"\n")
#endif

//---------------------------------------------------------------------------
//			Control Codes
//---------------------------------------------------------------------------

#define	IOCTL_INTERNAL_MSGAMIO_BASE	0xB00

#define	IOCTL_INTERNAL_MSGAMIO_UNLOAD \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+0,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_CONNECT_SERVER \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+1,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_DISCONNECT_SERVER \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+2,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_CONNECT_CLIENT \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+3,METHOD_NEITHER,FILE_ANY_ACCESS)

#define	IOCTL_INTERNAL_MSGAMIO_DISCONNECT_CLIENT \
			CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_INTERNAL_MSGAMIO_BASE+4,METHOD_NEITHER,FILE_ANY_ACCESS)

//---------------------------------------------------------------------------
//			Structures
//---------------------------------------------------------------------------

typedef	struct
{	// @struct DRIVERSERVICES | Device services table

	// @field ULONG | Size | Size of structure
	ULONG	Size;

	// @field GUID | Server | Server GUID
	GUID	Server;

	// @field VOID (*Connect)(ConnectInfo) | ConnectInfo | Connection service procedure
	VOID	(STDCALL *Connect)(PVOID ConnectInfo);

	// @field VOID (*Disconnect)(ConnectInfo) | ConnectInfo | Disconnection service procedure
	VOID	(STDCALL *Disconnect)(PVOID ConnectInfo);

	// @field VOID (*Transact)(PacketInfo) | PacketInfo | Transaction hook procedure
	VOID	(STDCALL *Transact)(PVOID PacketInfo);

	// @field VOID (*Packet)(PacketData) | PacketData | Packet hook procedure
	VOID	(STDCALL *Packet)(PVOID PacketData);

	// @field NTSTATUS (*ForceReset)(VOID) | None | Reset force feedback device
	NTSTATUS	(STDCALL *ForceReset)(VOID);

	// @field NTSTATUS (*ForceId)(IdString) | IdString | Gets force feedback id string
	NTSTATUS	(STDCALL *ForceId)(PVOID IdString);

	// @field NTSTATUS (*ForceStatus)(Status) | Status | Gets raw force feedback status
	NTSTATUS	(STDCALL *ForceStatus)(PVOID Status);
	
	// @field NTSTATUS (*ForceAckNak)(AckNak) | AckNak | Gets force feedback ack nak
	NTSTATUS	(STDCALL *ForceAckNak)(PUCHAR AckNak);

	// @field NTSTATUS (*ForceNakAck)(NakAck) | NakAck | Gets force feedback nak ack
	NTSTATUS	(STDCALL *ForceNakAck)(PUCHAR NakAck);

	// @field NTSTATUS (*ForceSync)(Sync) | Sync | Reads byte from gameport to sync
	NTSTATUS	(STDCALL *ForceSync)(PUCHAR Sync);

	// @field ULONG (*Register)(Device, UnitId) | Device, UnitId | Registers device with Gckernel
	ULONG	(STDCALL *Register)(PGUID Device, ULONG UnitId);

	// @field VOID	(*Unregister) (Handle) | Handle | Unregisters device with Gckernel
	VOID	(STDCALL *Unregister) (ULONG Handle);

	// @field VOID	(*Notify) (Handle, DevInfo, PollData) | Handle, DevInfo, PollData | Sends packet for Gckernel processing
	VOID	(STDCALL *Notify) (ULONG Handle, PVOID DevInfo, PVOID PollData);

}	MSGAMIO_CONNECTION, *PMSGAMIO_CONNECTION;

//---------------------------------------------------------------------------
//		Global Procedures
//---------------------------------------------------------------------------

// @func		NTSTATUS | MSGAMIO_DoConnection | Calls MSGAMIO internal control interface
//	@parm		ULONG						|	ControlCode	|	IO control code
//	@parm		PMSGAMIO_CONNECTION	|	ConnectInfo	|	Connection structure
// @rdesc	Returns NT status code
//	@comm		Inline function

//---------------------------------------------------------------------------
//		Private Procedures
//---------------------------------------------------------------------------

NTSTATUS	STDCALL MSGAMIO_DoConnection (ULONG ControlCode, PMSGAMIO_CONNECTION InputBuffer);

//===========================================================================
//			WDM Interface
//===========================================================================

#ifdef	_NTDDK_

#ifdef	SAITEK
#define	MSGAMIO_DEVICE_NAME			TEXT("\\Device\\Saiio")
#define	MSGAMIO_DEVICE_NAME_U			 L"\\Device\\Saiio"
#define	MSGAMIO_SYMBOLIC_NAME		TEXT("\\DosDevices\\Saiio")
#define	MSGAMIO_SYMBOLIC_NAME_U			 L"\\DosDevices\\Saiio"
#else
#define	MSGAMIO_DEVICE_NAME			TEXT("\\Device\\MsGamio")
#define	MSGAMIO_DEVICE_NAME_U			 L"\\Device\\MsGamio"
#define	MSGAMIO_SYMBOLIC_NAME		TEXT("\\DosDevices\\MsGamio")
#define	MSGAMIO_SYMBOLIC_NAME_U			 L"\\DosDevices\\MsGamio"
#endif

//---------------------------------------------------------------------------
__inline NTSTATUS STDCALL MSGAMIO_Connection (ULONG ControlCode, PMSGAMIO_CONNECTION ConnectInfo)
//---------------------------------------------------------------------------
	{
	NTSTATUS				ntStatus;
	PIRP					pIrp;
	KEVENT				Event;
	PFILE_OBJECT		FileObject;
	PDEVICE_OBJECT		DeviceObject;
	UNICODE_STRING		ObjectName;
	IO_STATUS_BLOCK	IoStatus;

	//
	//	Validate parameters
	//

	ASSERT (ConnectInfo);
	ASSERT (KeGetCurrentIrql()<=DISPATCH_LEVEL);

	//
	//	Retrieve the driver device object
	//

	RtlInitUnicodeString (&ObjectName, MSGAMIO_DEVICE_NAME_U);
	ntStatus = IoGetDeviceObjectPointer (&ObjectName, FILE_ALL_ACCESS, &FileObject, &DeviceObject);
	if (!NT_SUCCESS(ntStatus))
		{
		KdPrint (("%s_Connection: IoGetDeviceObjectPointer (%ws) failed, status = 0x%X", MSGAMIO_NAME, ObjectName.Buffer, ntStatus));
		return (ntStatus);
		}
	
	//
	//	Initialize the completion event
	//

	KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

	//
	//	Allocate internal I/O IRP
	//

	pIrp = IoBuildDeviceIoControlRequest (ControlCode, DeviceObject, ConnectInfo, sizeof (MSGAMIO_CONNECTION), NULL, 0, TRUE, &Event, &IoStatus);
					
	//
	//	Call MsGamIo synchronously
	//

	KdPrint (("%s_Connection: Calling %s (%lu)\n", MSGAMIO_NAME, MSGAMIO_NAME, ControlCode));
	ntStatus = IoCallDriver (DeviceObject, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&Event, Suspended, KernelMode, FALSE, NULL);

	//
	//	Check asynchronous status
	//

	if (!NT_SUCCESS (ntStatus))
		KdPrint (("%s_Connection: %s (%lu) failed, Status = %X\n", MSGAMIO_NAME, MSGAMIO_NAME, ControlCode, ntStatus));

	//
	//	Free file object associated with device
	//

	ObDereferenceObject (FileObject);

	//
	//	Return status
	//

	return (ntStatus);
	}

#endif

//===========================================================================
//			VXD Definitions
//===========================================================================

#ifndef	_NTDDK_

#ifdef	SAITEK
#define 	MSGAMIO_DEVICE_ID				0x11EF
#else
#define 	MSGAMIO_DEVICE_ID				0x1EF
#endif

#pragma	warning (disable:4003)
			Begin_Service_Table			(MSGAMIO)
			Declare_Service				(MSGAMIO_Service, LOCAL)
			End_Service_Table				(MSGAMIO)
#pragma	warning (default:4003)

//---------------------------------------------------------------------------
__inline NTSTATUS STDCALL MSGAMIO_Connection (ULONG ControlCode, PMSGAMIO_CONNECTION ConnectInfo)
//---------------------------------------------------------------------------
	{
	NTSTATUS	ntStatus = STATUS_INVALID_DEVICE_REQUEST;

	//
	//	First check if Vxd present
	//

	if (ConnectInfo)
		{
		_asm	stc
		_asm	xor	eax, eax
		_asm	xor	ebx, ebx
		VxDCall (MSGAMIO_Service);
		_asm	{
				jc		Failure
				_asm	mov [ntStatus], eax
				Failure:
				}
		}

	if (!NT_SUCCESS(ntStatus))
		KdPrint (("%s_Connection Failed to Find %s", MSGAMIO_NAME, MSGAMIO_Filename_Str));

	//
	//	Then call for service
	//

	if (NT_SUCCESS(ntStatus))
		{
		_asm	mov	eax, ControlCode
		_asm	mov	ebx, ConnectInfo
		VxDCall (MSGAMIO_Service);
		_asm	mov [ntStatus], eax
		if (!NT_SUCCESS(ntStatus))
			KdPrint (("%s_Connection Failed Service Call %ld", MSGAMIO_NAME, ControlCode));
		}

	//
	//	Return status
	//

	return (ntStatus);
	}

#endif	// _NTDDK_

//**************************************************************************
#endif	//	RC_INVOKED											// Skip Rest of File
//**************************************************************************

#endif	// __MSGAMIO_H__

//===========================================================================
//			End
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\inc\swforce.h ===
//**************************************************************************
//
//		SWFORCE.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	SWFORCE.H | Global includes and definitions for force feedback driver interface
//**************************************************************************

#ifndef	__SWFORCE_H__
#define	__SWFORCE_H__

#ifdef	SAITEK
#define	SWFORCE_NAME				"SAIFORCE"
#else
#define	SWFORCE_NAME				"SWFORCE"
#endif

//---------------------------------------------------------------------------
//			Types
//---------------------------------------------------------------------------

typedef	struct
{
#pragma pack(1)
	ULONG	cBytes;
	LONG	dwXVel;
	LONG	dwYVel;
	LONG	dwXAccel;
	LONG	dwYAccel;
	ULONG	dwEffect;
	ULONG	dwDeviceStatus;
#pragma pack()
}	JOYCHANNELSTATUS,	*PJOYCHANNELSTATUS;

typedef struct
{
#pragma pack(1)
	ULONG	cBytes;	
	ULONG	dwProductID;
	ULONG	dwFWVersion;
#pragma pack()
} PRODUCT_ID, *PPRODUCT_ID;

//---------------------------------------------------------------------------
//			IOCTLs
//---------------------------------------------------------------------------

#define IOCTL_GET_VERSION	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_GET_VERSION
// lpvInBuffer			= NULL
// cbInBuffer			= 0
// lpvOutBuffer		= PULONG (HIWORD = Ver. high, LoWord - Ver. Low)
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETSTATUS	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETSTATUS
// lpvInBuffer			= PJOYCHANNELSTATUS
// cbInBuffer			= sizeof(JOYCHANNELSTATUS)
// lpvOutBuffer		= PJOYCHANNELSTATUS
// cbOutBuffer			= sizeof(JOYCHANNELSTATUS)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETID	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETID
// lpvInBuffer			= PPRODUCT_ID
// cbInBuffer			= sizeof(PRODUCT_ID)
// lpvOutBuffer		= PPRODUCT_ID
// cbOutBuffer			= sizeof(PRODUCT_ID)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETACKNACK	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETACKNAK
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETSYNC	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETSYNC
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_GETNACKACK	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_GETNACKACK
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_SETPORT		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_SETPORT
// lpvInBuffer			= PULONG
// cbInBuffer			= sizeof(ULONG)
// lpvOutBuffer		= PULONG
// cbOutBuffer			= sizeof(ULONG)
// lpcbBytesReturned	= Bytes returned based on result

#define IOCTL_SWFORCE_SENDDATA	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_SENDDATA
// lpvInBuffer			= PUCHAR
// cbInBuffer			= Bytes to send
// lpvOutBuffer		= PUCHAR
// cbOutBuffer			= Bytes to send
// lpcbBytesReturned	= Bytes sent

#define IOCTL_SWFORCE_RESET	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)

// dwIoControlCode	= IOCTL_SWFORCE_RESET
// lpvInBuffer			= NULL
// cbInBuffer			= 0
// lpvOutBuffer		= LPDWORD
// cbOutBuffer			= sizeof(DWORD)
// lpcbBytesReturned	= Bytes returned based on result

#endif	//__SWFORCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\device.c ===
//**************************************************************************
//
//		DEVICE.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	DEVICE.C | Routines to support device class calls
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, DEVICE_DriverEntry)
#endif

//---------------------------------------------------------------------------
//			Device Delcarations
//---------------------------------------------------------------------------

			#ifndef	SAITEK
			DECLARE_DEVICE(Midas);
			DECLARE_DEVICE(Juno);
			DECLARE_DEVICE(Jolt);
			DECLARE_DEVICE(GamePad);
			DECLARE_DEVICE(Tilt);
			#endif
			DECLARE_DEVICE(LedZep);

static	PDEVICEINFO		MiniDrivers[]	=	{
														#ifndef	SAITEK
														INSTANCE_DEVICE(Midas), //default
														INSTANCE_DEVICE(Juno),
														INSTANCE_DEVICE(Jolt),
														INSTANCE_DEVICE(GamePad),
														INSTANCE_DEVICE(Tilt),
														#endif
														INSTANCE_DEVICE(LedZep)
											};

//---------------------------------------------------------------------------
//			Private	Data
//---------------------------------------------------------------------------

static	BOOLEAN		DeviceDetected								=	FALSE;
static	ULONG			DetectAttempts								=	0;
static	ULONG			LastDetectTime								=	0;
static	KIRQL			SpinLockIrql								=	PASSIVE_LEVEL;
static	KSPIN_LOCK	DevSpinLock									=	{0};
static	ULONG			SuccessPackets[MAX_DEVICE_UNITS]		=	{0,0,0,0};
static	ULONG			PollingAttempts[MAX_DEVICE_UNITS]	=	{0,0,0,0};

//---------------------------------------------------------------------------
//			Public Data
//---------------------------------------------------------------------------

public	ULONG			POV_Values[]		=	{
														JOY_POVCENTERED,
														JOY_POVFORWARD,
														JOY_POVFORWARD+4500,
														JOY_POVRIGHT,
														JOY_POVRIGHT+4500,
														JOY_POVBACKWARD,
														JOY_POVBACKWARD+4500,
														JOY_POVLEFT,
														JOY_POVLEFT+4500
														};

public	ULONG			PollingInterval	=	POLLING_INTERVAL;

//---------------------------------------------------------------------------
//			Private	Procedures
//---------------------------------------------------------------------------

static	VOID		DEVICE_AcquireDevice (VOID);
static	VOID		DEVICE_ReleaseDevice (VOID);
static	NTSTATUS	DEVICE_HotPlugDevice (PGAMEPORT PortInfo);
static	NTSTATUS	DEVICE_RemoveSiblings (PGAMEPORT PortInfo);
static	BOOLEAN	DEVICE_DetectClocks (PGAMEPORT PortInfo, ULONG TimeOut);
static	BOOLEAN	DEVICE_QuickDetect (PGAMEPORT PortInfo);
static	NTSTATUS	DEVICE_DetectDevices (PGAMEPORT PortInfo);

//---------------------------------------------------------------------------
// @func		Acquires exclusive access to gameport (mutex)
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	DEVICE_AcquireDevice (VOID)
{
	KeAcquireSpinLock (&DevSpinLock, &SpinLockIrql);
}

//---------------------------------------------------------------------------
// @func		Releases exclusive access to gameport (mutex)
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	DEVICE_ReleaseDevice (VOID)
{
	KeReleaseSpinLock (&DevSpinLock, SpinLockIrql);
}

//---------------------------------------------------------------------------
// @func		Detects hot-plugging of gamepad devices
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns one of the following values:
//	@flag		STATUS_DEVICE_NOT_CONNECTED	| An error occurred
//	@flag		STATUS_SIBLING_REMOVED			| An device has been removed
//	@flag		STATUS_SIBLING_ADDED				| An device has been added
//	@flag		STATUS_SUCCESS						| Everything is fine
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_HotPlugDevice (PGAMEPORT PortInfo)
{
	ULONG			UnitId;
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_HotPlugDevice Enter\n"));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo || !DevInfo->NumDevices)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_HotPlugDevice Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Get UnitId for tracking by device
	//

	UnitId = GET_DEVICE_UNIT(PortInfo);

	//
	//	Check if number devices has changed
	//

   if (((DevInfo->DeviceCount+DevInfo->DevicePending) != DevInfo->NumDevices) && (SuccessPackets[UnitId]++ > HOT_PLUG_PACKETS))
	   {
      SuccessPackets[UnitId] = 0;
		if ((DevInfo->DeviceCount+DevInfo->DevicePending) > DevInfo->NumDevices)
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_HotPlugDevice Removing Sibling\n", MSGAME_NAME));
			//
			//	Decrement pending count to avoid removing twice
			//
			InterlockedDecrement (&DevInfo->DevicePending);
			return (STATUS_SIBLING_REMOVED);
			}
		else
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_HotPlugDevice Adding Sibling\n", MSGAME_NAME));
			//
			//	Increment pending count to avoid adding twice
			//
			InterlockedIncrement (&DevInfo->DevicePending);
			return (STATUS_SIBLING_ADDED);
			}
   	}

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_HotPlugDevice Exit\n", MSGAME_NAME));
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Removes sibling lists if possible
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns one of the following values:
//	@flag		STATUS_DEVICE_NOT_CONNECTED	| An error occurred
//	@flag		STATUS_SIBLING_REMOVED			| An device has been removed
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_RemoveSiblings (PGAMEPORT PortInfo)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_RemoveSiblings Enter\n"));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_RemoveSiblings Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Zero number of devices
	//

	DevInfo->NumDevices = 1;

	//
	//	Check if more than one device
	//

   if ((DevInfo->DeviceCount+DevInfo->DevicePending) > 1)
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_RemoveSiblings Removing Sibling\n", MSGAME_NAME));
		//
		//	Decrement pending count to avoid removing twice
		//
		InterlockedDecrement (&DevInfo->DevicePending);
		return (STATUS_SIBLING_REMOVED);
		}

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_RemoveSiblings Exit\n", MSGAME_NAME));
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Detect digital gameport clocks
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | TimeOut | Loops to try for clocks
// @rdesc	Returns true if clocks detected, false otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN  DEVICE_DetectClocks (PGAMEPORT PortInfo, ULONG TimeOut)
{
	BOOLEAN	Result = FALSE;

	_asm
		{
		;StartLoop:
			xor	ebx, ebx
			mov	edx, PortInfo
			mov	ecx, TimeOut

			push	0								; write byte to gameport
			push	edx
			call	PORTIO_Write

			push	edx							; read byte from gameport
			call	PORTIO_Read
			mov	ah, al

		ClockLoop:
			push	edx							; read byte from gameport
			call	PORTIO_Read
			xor	al, ah
			test	al, CLOCK_BIT_MASK
			je		NextLoop

		;FoundClock:
			inc	ebx
			cmp	ebx, QUICK_DETECT_CLOCKS
			jb		NextLoop
			mov	Result, TRUE
			jmp	ExitLoop

		NextLoop:
			loop	ClockLoop

		ExitLoop:
			nop
		}

	return (Result);
}
	
//---------------------------------------------------------------------------
// @func		Detects whether digital device is connected
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns true if clocks detected, false otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN  DEVICE_QuickDetect (PGAMEPORT PortInfo)
{
	ULONG				i;
	ULONG				TimeOut;
	DETECT_ORDER	DetectOrder;

	TimeOut = TIMER_CalibratePort (PortInfo, QUICK_DETECT_TIME);

	if (DEVICE_DetectClocks (PortInfo, TimeOut))
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_QuickDetect Found Digital Clocks!\n", MSGAME_NAME));
		return (TRUE);
		}

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_QuickDetect Trying Analog Devices\n", MSGAME_NAME));
	for (DetectOrder = DETECT_FIRST; DetectOrder <= DETECT_LAST; DetectOrder++)
   	for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
			if (MiniDrivers[i]->DetectOrder == DetectOrder)
				if (MiniDrivers[i]->IsAnalog)
   		   	if (MiniDrivers[i]->Services->ConnectDevice (PortInfo) == STATUS_SUCCESS)
						{
						MsGamePrint ((DBG_CONTROL, "%s: DEVICE_QuickDetect Found Analog Device!\n", MSGAME_NAME));
						return (TRUE);
						}

	MsGamePrint ((DBG_SEVERE, "%s: DEVICE_QuickDetect Failed to Find Digital Device!\n", MSGAME_NAME));
	return (FALSE);	
}

//---------------------------------------------------------------------------
// @func		Detects which device type is connected
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns one of the following values:
//	@flag		STATUS_DEVICE_NOT_CONNECTED	| An error occurred
//	@flag		STATUS_DEVICE_CHANGED			| The device has changed
//	@flag		STATUS_SUCCESS						| Everything is fine
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_DetectDevices (PGAMEPORT PortInfo)
{
	ULONG				i, j;
	PDEVICEINFO		DevInfo;
	DETECT_ORDER	DetectOrder;

	//
	//	This an initial redetect or system startup device
	//

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_DetectDevices Enter\n", MSGAME_NAME));

	//
	//	Skip if we've already detected a new device removed this one
	//

	if (GET_DEVICE_DETECTED (PortInfo))
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Device Already Detected!\n", MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if we're trying too hard
	//

   if (DetectAttempts++ > MAX_DETECT_ATTEMPTS)
   	{
		if (TIMER_GetTickCount () < (LastDetectTime + MAX_DETECT_INTERVAL))
   	 	return (STATUS_DEVICE_NOT_CONNECTED);
		LastDetectTime = TIMER_GetTickCount();
   	}

	//
	//	Calibrate timer each try
	//

   TIMER_Calibrate ();

	//
	//	Calibrate port timeouts
	//

	PORTIO_CalibrateTimeOut (PortInfo);

	//
	//	Perform quick detection in case none attached
	//

	if (DEVICE_QuickDetect (PortInfo))
		{
		for (DetectOrder = DETECT_FIRST; DetectOrder <= DETECT_LAST; DetectOrder++)
   		for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
				if (MiniDrivers[i]->DetectOrder == DetectOrder)
   		   	if (MiniDrivers[i]->Services->ConnectDevice (PortInfo) == STATUS_SUCCESS)
						{
						MsGamePrint ((DBG_CONTROL, "%s: %s Connected OK\n", MSGAME_NAME, MiniDrivers[i]->DeviceName));
						DeviceDetected			= TRUE;
						DetectAttempts			= 0;
						PollingAttempts[0]	= 0;
						if (!DevInfo)
							{
							//
							//	Assign device type
							//
							SET_DEVICE_INFO (PortInfo, MiniDrivers[i]);
							MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Setting Device\n", MSGAME_NAME));
							return (STATUS_SUCCESS);
							}
						else if (DevInfo != MiniDrivers[i])
							{
							//
							//	Change device type
							//
							SET_DEVICE_DETECTED (PortInfo, MiniDrivers[i]);
							MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Changing Device\n", MSGAME_NAME));
							return (STATUS_DEVICE_CHANGED);
							}
						else
							{
							//
							//	Same device found
							//
							MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Same Device Found\n", MSGAME_NAME));
							return (STATUS_SUCCESS);
							}
						}
		}

	//
	//	Mark device not detected
	//

	DeviceDetected = FALSE;

	//
	//	Return status
	//

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_DetectDevices Failed\n", MSGAME_NAME));
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Calcuates and returns is data is odd parity
//	@parm		PVOID | Data | Pointer to raw data
//	@parm		ULONG | Size | Size of raw data buffer
// @rdesc	True if oded parity, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	DEVICE_IsOddParity (PVOID Data, ULONG Count)
{
	LONG	Result =	ERROR_SUCCESS;
	LONG	Parity;

	__asm
		{
			push	edi
			push	esi

			mov	esi, Data
			mov	ecx, Count
			xor	eax, eax
			
		IsOddLoop:

			xor	al, [esi]
			inc	esi
			loop	IsOddLoop

			xor	al, ah
			jpo	IsOddComplete

			mov	Parity, eax
			mov	Result, ERROR_PARITYBITS

		IsOddComplete:

			pop	esi
			pop	edi
		}

	if (Result == ERROR_PARITYBITS)
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_IsOddParity - Parity bits failed %ld\n", MSGAME_NAME, Parity));

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device layer
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_DriverEntry (VOID)
{
	ULONG		i;
	NTSTATUS	ntStatus;

	KeInitializeSpinLock (&DevSpinLock);

  	for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
		{
		//
		//	Call Mini-DriverEntry
		//
		ntStatus = MiniDrivers[i]->Services->DriverEntry ();
		if (NT_ERROR(ntStatus))
			{
			//
			//	Abort driver loading
			//
			MsGamePrint ((DBG_SEVERE, "%s: DEVICE_DriverEntry: %s Failed Driver Entry\n", MSGAME_NAME, MiniDrivers[i]->DeviceName));
			break;
			}
		}

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Detects gameport IO collisions
//	@parm		PPACKETINFO | DataPacket | Device packet info struct
// @rdesc	Returns True for collision, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	DEVICE_IsCollision (PPACKETINFO DataPacket)
{
	if ((DataPacket->TimeStamp + PollingInterval) > TIMER_GetTickCount ())
		return (TRUE);

	return (PORTIO_IsClockActive (&DataPacket->PortInfo, DataPacket->ClockDutyCycle));
}

//---------------------------------------------------------------------------
// @func		Copies and returns HID device descriptor for a device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Descriptor | Output buffer for descriptor
//	@parm		ULONG | MaxSize | Size of buffer for descriptor
//	@parm		PULONG | Copied | Bytes copied to buffer for descriptor
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_GetDeviceDescriptor (PGAMEPORT PortInfo, PUCHAR Descriptor, ULONG MaxSize, PULONG Copied)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetDeviceDescriptor Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Zero returned size first
	//
	
	*Copied = 0;

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetDeviceDescriptor Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Check output buffer size
	//

	if (MaxSize < sizeof (HID_DESCRIPTOR))
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetDeviceDescriptor - Buffer too small = %lu\n", MSGAME_NAME, MaxSize));
		return (STATUS_BUFFER_TOO_SMALL);
		}

	//
	//	Copy descriptor to output buffer
	//

	memcpy (Descriptor, DevInfo->DevDescriptor, sizeof (HID_DESCRIPTOR));

	//
	//	Return number bytes copied
	//

	*Copied = sizeof (HID_DESCRIPTOR);

	//
	//	Return status
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Copies and returns HID report descriptor for a device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Descriptor | Output buffer for descriptor
//	@parm		ULONG | MaxSize | Size of buffer for descriptor
//	@parm		PULONG | Copied | Bytes copied to buffer for descriptor
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_GetReportDescriptor (PGAMEPORT PortInfo, PUCHAR Descriptor, ULONG MaxSize, PULONG Copied)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetReportDescriptor Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Zero returned size first
	//
	
	*Copied = 0;

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetReportDescriptor Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Check output buffer size
	//

	if (MaxSize < DevInfo->RptDescSize)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetReportDescriptor Buffer too small = %lu\n", MSGAME_NAME, MaxSize));
		return (STATUS_BUFFER_TOO_SMALL);
		}

	//
	//	Copy descriptor to output buffer
	//

	memcpy (Descriptor, DevInfo->RptDescriptor, DevInfo->RptDescSize);

	//
	//	Return number bytes copied
	//

	*Copied = DevInfo->RptDescSize;

	//
	//	Return status
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_StartDevice (PGAMEPORT PortInfo, PWCHAR HardwareId)
{
	ULONG			i, UnitId, Default = 0;
	PGAMEPORT	p, *Device;
	PDEVICEINFO	DevInfo = NULL;

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StartDevice Called For %ws\n", MSGAME_NAME, HardwareId));

	//
	//	Try requested device based on HardwareId
	//

	for (i = 0; i < ARRAY_SIZE(MiniDrivers); i++)
		if (MSGAME_CompareHardwareIds (HardwareId, MiniDrivers[i]->HardwareId))
			{
			Default = i;
	   	if (NT_SUCCESS(MiniDrivers[i]->Services->ConnectDevice (PortInfo)))
				DevInfo = MiniDrivers[i];
			break;
			}

	//
	//	If requested device fails, do a detect
	//

	if (!DevInfo)
		{
		DEVICE_DetectDevices (PortInfo);
		DevInfo = GET_DEVICE_INFO (PortInfo);
		}

	//
	//	If	detect fails, force the requested device
	//

	if (!DevInfo)
		{
		DevInfo = MiniDrivers[Default];
	   DevInfo->NumDevices++;
		}

	//
	//	Make sure these are set at this point
	//

	ASSERT(DevInfo);
	SET_DEVICE_INFO(PortInfo, DevInfo);

	//
	//	Add device and allocate unit id
	//

	DEVICE_AcquireDevice ();
	UnitId = 0;
	Device = &DevInfo->Siblings;
	while (p = *Device)
		{
		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StartDevice Reassigning UnitId From %lu to %lu\n", MSGAME_NAME, GET_DEVICE_UNIT(p), UnitId));
		SET_DEVICE_UNIT(p, UnitId++);
		Device = &GET_DEVICE_SIBLING(p);
		}
	*Device = PortInfo;
	SET_DEVICE_UNIT(PortInfo, UnitId);
	SET_DEVICE_SIBLING(PortInfo, NULL);
	SET_DEVICE_ID(PortInfo, DevInfo->DeviceId);
	DEVICE_ReleaseDevice ();

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StartDevice Assigned UnitId = %lu\n", MSGAME_NAME, UnitId));

	//
	//	Increment device count
	//

   InterlockedIncrement (&DevInfo->DeviceCount);
	if (DevInfo->DevicePending)
		InterlockedDecrement (&DevInfo->DevicePending);

	//
	//	Call the mini-driver to process
	//

	DevInfo->Services->StartDevice (PortInfo);

	//
	//	Return success always
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Read Report IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Public function <en->
//				Performs hot-plugging on success or does device detection if no
//				device selected or error.
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_ReadReport (PGAMEPORT PortInfo, PUCHAR Report, ULONG MaxSize, PULONG Copied)
{
	NTSTATUS			ntStatus;
	PDEVICEINFO		DevInfo;
	DEVICE_PACKET	Packet;

	MsGamePrint ((DBG_VERBOSE, "%s: DEVICE_ReadReport Enter\n", MSGAME_NAME));

	//
	//	Initialize packet members
	//

	memset (&Packet, 0, sizeof (Packet));
	Packet.id = GET_DEVICE_UNIT (PortInfo);

	//
	//	Check output buffer
	//

	if (MaxSize < sizeof (DEVICE_PACKET))
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_ReadReport Bad Buffer Size = %lu\n", MSGAME_NAME, MaxSize));
		return (STATUS_BUFFER_TOO_SMALL);
		}

	//
	//	Skip if device changed
	//

	if (GET_DEVICE_DETECTED (PortInfo))
		{
		MsGamePrint ((DBG_INFORM, "%s: DEVICE_ReadReport Device In Process of Being Changed!\n", MSGAME_NAME));
		ntStatus = STATUS_DEVICE_BUSY;
		goto DEVICE_ReadReport_Exit;
		}

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo || !DeviceDetected)
	{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_ReadReport Called With No Device!\n", MSGAME_NAME));
		SuccessPackets[0] = 0;
		ntStatus = DEVICE_DetectDevices (PortInfo);
		if (!NT_SUCCESS (ntStatus))
			goto DEVICE_ReadReport_Exit;

		//
		//	Get pointer to new device
		//
		DevInfo = GET_DEVICE_INFO(PortInfo);

		goto DEVICE_ReadReport_Exit;
	}

	//
	//	Call the mini-driver to process
	//

	ntStatus = DevInfo->Services->ReadReport (PortInfo, &Packet);

	//
	//	Process returned status
	//

	if (NT_SUCCESS (ntStatus))
		{
		//
		//	Check for hot-plugging
		//

		ntStatus = DEVICE_HotPlugDevice (PortInfo);
		PollingAttempts[Packet.id] = 0;
		goto DEVICE_ReadReport_Exit;
		}
	else if (ntStatus == STATUS_DEVICE_BUSY)
		{
		//
		//	Access to port denied
		//

		MsGamePrint ((DBG_CONTROL, "%s: DEVICE_ReadReport Device Busy\n", MSGAME_NAME));
        goto DEVICE_ReadReport_Exit;
		}
	else
		{
		//
		//	Force success if just transitory
		//

		if	((++PollingAttempts[Packet.id] <= MAX_POLLING_ATTEMPTS) && DeviceDetected)
			{
			MsGamePrint ((DBG_CRITICAL, "%s: DEVICE_ReadReport Force Success\n", MSGAME_NAME));
			ntStatus = STATUS_SUCCESS;
			}
		else if ((PollingAttempts[Packet.id] % MAX_POLLING_ATTEMPTS) == 0)
			{
			MsGamePrint ((DBG_CRITICAL, "%s: DEVICE_ReadReport Failed %lu In a Row\n", MSGAME_NAME, PollingAttempts[Packet.id]));

			//
			//	Try and see what's out there
			//

			ntStatus = DEVICE_DetectDevices (PortInfo);

			//
			//	If nothing found, destroy any siblings
			//

			if (NT_ERROR(ntStatus))
				ntStatus = DEVICE_RemoveSiblings (PortInfo);
			}
		else
			{
			//
			//	Just bounce this request
			//

			ntStatus = STATUS_DEVICE_NOT_CONNECTED;
			}

		//
		//	Clear sucessful packet counts
		//

		SuccessPackets[Packet.id] = 0;
		}

	//---------------------
	DEVICE_ReadReport_Exit:
	//---------------------

    if( ntStatus == STATUS_DEVICE_BUSY) 
    {
        ntStatus = STATUS_SUCCESS;
    }

	//
	//	Return packet data always
	//

	memcpy (Report, &Packet, sizeof (Packet));
	if (NT_SUCCESS(ntStatus))
	{
		*Copied += sizeof (Packet);
	}
	else
		*Copied = 0x0;
	//
	//	Return status code
	//

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	ULONG			UnitId;
	PGAMEPORT	p, *Device;
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_StopDevice Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_StopDevice Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Received for %s[%lu]\n", MSGAME_NAME, DevInfo->DeviceName, GET_DEVICE_UNIT(PortInfo)));

	//
	//	Remove sibling and reallocate unit ids
	//

	DEVICE_AcquireDevice ();
	UnitId = 0;
	Device = &DevInfo->Siblings;
	while (p = *Device)
		{
		if (p == PortInfo)
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Unlinking UnitId = %lu\n", MSGAME_NAME, GET_DEVICE_UNIT(p)));
			*Device = GET_DEVICE_SIBLING(p);
			}
		else
			{
			MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Reassigning UnitId From %lu to %lu\n", MSGAME_NAME, GET_DEVICE_UNIT(p), UnitId));
			SET_DEVICE_UNIT(p, UnitId++);
			}
		Device = &GET_DEVICE_SIBLING(p);
		}
	DEVICE_ReleaseDevice ();

	MsGamePrint ((DBG_CONTROL, "%s: DEVICE_StopDevice Released UnitId = %lu\n", MSGAME_NAME, GET_DEVICE_UNIT (PortInfo)));

	//
	//	Decrement device count
	//

   InterlockedDecrement (&DevInfo->DeviceCount);
	if (DevInfo->DevicePending)
		InterlockedIncrement (&DevInfo->DevicePending);

	//
	//	Call the mini-driver to process
	//

	return (DevInfo->Services->StopDevice (PortInfo, TouchHardware));
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Get Feature IRP
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		HID_REPORT_ID | ReportId | HID feature report id
//	@parm		PUCHAR | ReportBuffer | Output buffer for report
//	@parm		ULONG | ReportSize | Size of buffer for report
//	@parm		PULONG | Returned | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	DEVICE_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned)
{
	PDEVICEINFO	DevInfo;

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetFeature Enter\n", MSGAME_NAME));

	//
	//	Get pointer to this device
	//

	DevInfo = GET_DEVICE_INFO(PortInfo);

	//
	//	Skip if no device detected
	//

	if (!DevInfo)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetFeature Called With No Device!\n", MSGAME_NAME));
		return (STATUS_DEVICE_NOT_CONNECTED);
		}

	//
	//	Skip if features not supported
	//

	if (!DevInfo->Services->GetFeature)
		{
		MsGamePrint ((DBG_SEVERE, "%s: DEVICE_GetFeature Called With No Mini-Driver Support!\n", MSGAME_NAME));
		return (STATUS_INVALID_DEVICE_REQUEST);
		}

	//
	//	Call the mini-driver to process
	//

	MsGamePrint ((DBG_INFORM, "%s: DEVICE_GetFeature For ReportId = %lu\n", MSGAME_NAME, (ULONG)ReportId));
	return (DevInfo->Services->GetFeature (PortInfo, ReportId, ReportBuffer, ReportSize, Returned));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\makefile.inc ===
!IFDEF	SAITEK
saigame.dbg: $(CPU)\$(DDKBUILDENV)\saigame.sys
   rebase -b 0x10000 -x $(CPU)\$(DDKBUILDENV) $(CPU)\$(DDKBUILDENV)\saigame.sys
!ELSE
msgame.dbg: $(CPU)\$(DDKBUILDENV)\msgame.sys
   rebase -b 0x10000 -x $(CPU)\$(DDKBUILDENV) $(CPU)\$(DDKBUILDENV)\msgame.sys
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\debug.h ===
//**************************************************************************
//
//		DEBUG.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	DEBUG.H | Global includes and definitions for debugging output
//**************************************************************************

#ifndef	DEBUG_H
#define	DEBUG_H

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

typedef enum
{												// @enum DBG_LEVEL | Debug verbosity levels
	DBG_CRITICAL,							// @emem Critical debug output
	DBG_SEVERE,								// @emem Severe debug output
	DBG_CONTROL,							// @emem Control debug output (default)
	DBG_INFORM,								// @emem Inform debug output
	DBG_VERBOSE								// @emem Verbose debug output
}	DBG_LEVEL;

//
//	Default output verbosity level
//

#define	DBG_DEFAULT				DBG_CONTROL

//
//	Conditional debug output procedures
//

// jacklin - Windows bug 321472. Disabling debug output even for chk build
#if		(DBG==1 && defined(I_WANT_DEBUG_OUTPUT_AND_BREAK_BVT))

#define	MsGameLevel(x)				DEBUG_Level (x)
#define	MsGamePrint(x)				DEBUG_Print x
#define	MsGameBreak()				DbgBreakPoint ()
#undef	PAGED_CODE
#define	PAGED_CODE() \
    		if (KeGetCurrentIrql() > APC_LEVEL)	\
				{\
         	MsGamePrint((DBG_CRITICAL,"%s: Pageable code called at IRQL %ld (file: %s, line:#%ld)\n",MSGAME_NAME,KeGetCurrentIrql(),__FILE__,__LINE__));\
				ASSERT(FALSE); \
				}

#else		// DBG=0

#define	MsGameLevel(x)
#define	MsGamePrint(x)
#define	MsGameBreak()
#undef	PAGED_CODE
#define	PAGED_CODE()

#endif	// DBG=?

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

DBG_LEVEL
DEBUG_Level (
	IN		DBG_LEVEL uLevel
	);

VOID
DEBUG_Print (
	IN		DBG_LEVEL uLevel,
	IN		PCSZ szMessage,
	IN		...
	);

//===========================================================================
//			End
//===========================================================================

#endif	// DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\device.h ===
//**************************************************************************
//
//		DEVICE.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	DEVICE.H | Global includes and definitions for device interface
//**************************************************************************

#ifndef	__DEVICE_H__
#define	__DEVICE_H__

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

#define	MAX_DEVICE_UNITS				4

#define	MAX_DETECT_ATTEMPTS			5
#define	MAX_POLLING_ATTEMPTS			5
#define	MAX_CONNECT_ATTEMPTS			2
#define	MAX_DEVICE_NAME				64
#define	HOT_PLUG_PACKETS				2
#define	MAX_DETECT_INTERVAL			2000

#define	QUICK_DETECT_TIME				1000
#define	QUICK_DETECT_CLOCKS			8

#define	IMODE_DIGITAL_STD     		0
#define	IMODE_DIGITAL_ENH     		4
#define	IMODE_ANALOG          		8
#define	IMODE_NONE             		-1

#define	FLAG_WAIT_FOR_CLOCK			1
#define	FLAG_START_CLOCK_LOW			2
#define	FLAG_START_CLOCK_HIGH		4

#define	INTERRUPT_AFTER_PACKET		1
#define	INTERRUPT_DURING_PACKET		2

#define	TIMEOUT              		300
#define	MAX_XA_TIMEOUT					1600
#define	POLLING_INTERVAL				10

#define	INTXA_BIT_MASK          	0x01
#define	CLOCK_BIT_MASK          	0x10
#define	DATA0_BIT_MASK          	0x20
#define	DATA1_BIT_MASK          	0x40
#define	DATA2_BIT_MASK          	0x80
#define	AXIS_ONLY_BIT_MASK      	0x0f
#define	XA_BIT_MASK             	0x01
#define	YA_BIT_MASK             	0x02
#define	XB_BIT_MASK             	0x04
#define	YB_BIT_MASK             	0x08
#define	XAXIS_BIT_MASK          	0x01
#define	YAXIS_BIT_MASK          	0x02

#define	STATUS_GATE_MASK				0x90

//
//	Packet Speed Masks
//

#define	GAME_SPEED_66K					0
#define	GAME_SPEED_83K					1
#define	GAME_SPEED_100K				2
#define	GAME_SPEED_125K				3

#define	GAME_SPEED_RANGE				4
#define	GAME_SPEED_BITS				3

//
//	Wheel Speed Masks
//

#define	WHEEL_SPEED_48K				0
#define	WHEEL_SPEED_66K				1
#define	WHEEL_SPEED_98K				2

#define	WHEEL_SPEED_RANGE				3
#define	WHEEL_SPEED_BITS				3

//
//	Internal error codes
//

#define	ERROR_SUCCESS					 0
#define	ERROR_HANDSHAKING				-1
#define	ERROR_LOWCLOCKSTART			-2
#define	ERROR_HIGHCLOCKSTART			-3
#define	ERROR_CLOCKFALLING			-4
#define	ERROR_CLOCKRISING				-5
#define	ERROR_ERRORBITS				-6
#define	ERROR_PARITYBITS				-7
#define	ERROR_EXTRACLOCKS				-8
#define	ERROR_PHASEBITS				-9
#define	ERROR_CHECKSUM					-10
#define	ERROR_XA_TIMEOUT				-11
#define	ERROR_CLOCKOVERFLOW			-12

//
//	Packet status codes
//

#define	STATUS_SIBLING_ADDED			((NTSTATUS)0x40050001L)
#define	STATUS_SIBLING_REMOVED		((NTSTATUS)0x40050002L)
#define	STATUS_DEVICE_CHANGED		((NTSTATUS)0x40050003L)

//
//	GAMEENUM_OEM_DATA Constants
//

#define	OEM_DEVICE_INFO				0
#define	OEM_DEVICE_UNIT				1
#define	OEM_DEVICE_SIBLING			2
#define	OEM_DEVICE_ID					3
#define	OEM_DEVICE_DETECTED			4
#define	OEM_DEVICE_OBJECT				5

//
//	Device Packet Constants
//

#define	JOY_RETURNX						0x00000001
#define	JOY_RETURNY						0x00000002
#define	JOY_RETURNZ						0x00000004
#define	JOY_RETURNR						0x00000008
#define	JOY_RETURNU						0x00000010
#define	JOY_RETURNV						0x00000020
#define	JOY_RETURNPOV					0x00000040
#define	JOY_RETURNBUTTONS				0x00000080
#define	JOY_RETURNRAWDATA				0x00000100
#define	JOY_RETURNPOVCTS				0x00000200
#define	JOY_RETURNCENTERED			0x00000400
#define	JOY_USEDEADZONE				0x00000800
#define	JOY_RETURNALL					(JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
												 JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
												 JOY_RETURNPOV | JOY_RETURNBUTTONS)

#define	JOY_POVCENTERED				(USHORT)-1
#define	JOY_POVFORWARD					0
#define	JOY_POVRIGHT					9000
#define	JOY_POVBACKWARD				18000
#define	JOY_POVLEFT						27000

//
//	HID Force Feature Identifiers
//

#define	HIDP_REPORT_ID_1				0x85

#define	MSGAME_INPUT_JOYINFOEX		0x01
#define	MSGAME_FEATURE_GETID			0x02
#define	MSGAME_FEATURE_GETSTATUS	0x03
#define	MSGAME_FEATURE_GETACKNAK	0x04
#define	MSGAME_FEATURE_GETNAKACK	0x05
#define	MSGAME_FEATURE_GETSYNC		0x06
#define	MSGAME_FEATURE_RESET			0x07
#define	MSGAME_FEATURE_GETVERSION	0x08

//---------------------------------------------------------------------------
//			Types
//---------------------------------------------------------------------------

typedef enum
{													// @enum DETECT_ORDER | Device detection order
	DETECT_FIRST,								// @emem Highest priority devices
	DETECT_NORMAL,								// @emem Default priority devices
	DETECT_LAST									// @emem Lowest priority devices
} 	DETECT_ORDER;

//---------------------------------------------------------------------------
//			Structures
//---------------------------------------------------------------------------

typedef struct
{													// @struct DEVICE_PACKET | Game device packet
	ULONG       id;							// @field Device unit id
	ULONG       do_other;					//	@field Packet flags
	ULONG       dwX;							// @field X position
	ULONG       dwY;							// @field Y position
	ULONG       dwZ;							// @field Z position
	ULONG       dwR;							// @field Rudder position
	ULONG       dwU;							// @field U position
	ULONG       dwV;							// @field Z position
	ULONG       dwPOV;						// @field Point of view state
	ULONG       dwButtons;					// @field Button states
	ULONG       dwButtonNumber;			// @field Current button number pressed
}	DEVICE_PACKET, *PDEVICE_PACKET;

typedef struct
{														// @struct PACKETINFO | Packet acquistion data
	ULONG						Size;					// @field Size of structure
	PCHAR						DeviceName;			// @field Device name string
	MSGAME_TRANSACTION	Transaction;		// @field Transaction type
	ULONG						Mode;					// @field Digital mode indicator
	LONG						Speed;				// @field Transmission speed indicator
	LONG						LastError;			// @field Last internal error result
	GAMEPORT					PortInfo;			// @field Gameport parameters
	ULONG						Acquisition;		// @field Packet acquisition mode
	ULONG						NumPackets;			// @field Number packets received
	ULONG 					TimeStamp;			// @field Last packet time in milliseconds
	ULONG 					ClocksSampled;		// @field Number of clocks encountered
	ULONG						B4Transitions;		// @field Number of Button 4 transitions
	ULONG						StartTimeout;		// @field Packet start timeout, calibrated
	ULONG						HighLowTimeout;	// @field Packet high-low timeout, calibrated
	ULONG 					LowHighTimeout;	// @field Packet low-high timeout, calibrated
	ULONG						InterruptDelay;	// @field Packet interruptdelay, calibrated
	ULONG 					ClockDutyCycle;	// @field Packet clock duty cycle, calibrated
	ULONG 					Attempts;			// @field Packet attempt count
	ULONG 					Failures;			// @field Packet failure count
	ULONG						DataSize;			// @field Size of packet data buffer
	PVOID						Data;					// @field Packet data buffer pointer
}	PACKETINFO, *PPACKETINFO;

typedef struct
{													// @struct DEVICE_VALUES | Device registry data
	ULONG			PacketStartTimeout;		// @field Packet start timeout in microseconds
	ULONG 		PacketHighLowTimeout;	// Packet high-low timeout in microseconds
	ULONG 		PacketLowHighTimeout;	// @field Packet low-high timeout in microseconds
	ULONG			IdStartTimeout;			// @field IDstring start timeout in microseconds
	ULONG 		IdHighLowTimeout;			// @field IDstring high-low timeout in microseconds
	ULONG 		IdLowHighTimeout;			// @field IDstring low-high timeout in microseconds
	ULONG			InterruptDelay;			// @field Interrupt delay timeout in microseconds
	ULONG			MaxClockDutyCycle;		// @field Clock duty cycle timeout in microseconds
	ULONG			StatusStartTimeout;		// @field Status start timeout in microseconds
	ULONG 		StatusHighLowTimeout;	// @field Status high-low timeout in microseconds
	ULONG 		StatusLowHighTimeout;	// @field Status low-high timeout in microseconds
	ULONG 		StatusGateTimeout;		// @field Status gate timeout in microseconds
}	DEVICE_VALUES, *PDEVICE_VALUES;

typedef struct
{	// @struct DRIVERSERVICES | Device services table
	// @field NTSTATUS (*DriverEntry)(VOID) | ConnectDevice | ConnectDevice service procedure
	NTSTATUS (*DriverEntry)(VOID);
	// @field NTSTATUS (*ConnectDevice)(PortInfo) | ConnectDevice | ConnectDevice service procedure
	NTSTATUS (*ConnectDevice)(PGAMEPORT PortInfo);
	// @field NTSTATUS (*StartDevice)(PortInfo) | StartDevice | StartDevice service procedure
	NTSTATUS (*StartDevice)(PGAMEPORT PortInfo);
	// @field NTSTATUS (*ReadReport)(PortInfo, Report) | ReadReport | ReadReport service procedure
	NTSTATUS (*ReadReport)(PGAMEPORT PortInfo, PDEVICE_PACKET Report);
	// @field NTSTATUS (*StopDevice)(PGAMEPORT PortInfo) | StopDevice | StopDevice service procedure
	NTSTATUS (*StopDevice)(PGAMEPORT PortInfo, BOOLEAN TouchHardware);
	// @field NTSTATUS (*GetFeature)(PGAMEPORT PortInfo ...) | GetFeature | GetFeature service procedure
	NTSTATUS (*GetFeature)(PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned);
}	DRIVERSERVICES, *PDRIVERSERVICES;

typedef struct
{													// @struct DEVICEINFO | Game device object
	PDRIVERSERVICES	Services;			// @field Pointer to service table
	PGAMEPORT			Siblings;			// @field Sibling device list
	PHID_DESCRIPTOR	DevDescriptor;		// @field Pointer to device descriptor
	PUCHAR				RptDescriptor;		// @field Pointer to report descriptor
	ULONG					RptDescSize;		// @field Size of report descriptor
	ULONG					NumDevices;			// @field Number of devices detected
	ULONG					DeviceCount;		// @field Number of devices started
	LONG					DevicePending;		//	@field Number devices pending
	PCHAR					DeviceName;			// @field Device name string
	DETECT_ORDER		DetectOrder;		// @field Detection priority
	BOOLEAN				IsAnalog;			// @field Analog device flag
	USHORT				DeviceId;			//	@field Hid device identifier
	PWCHAR				HardwareId;			// @field Pnp hardware identifier
}	DEVICEINFO, *PDEVICEINFO;

//---------------------------------------------------------------------------
//			Macros
//---------------------------------------------------------------------------

#define	DECLARE_DEVICE(x)				extern DEVICEINFO	x##Info
#define	INSTANCE_DEVICE(x)			&x##Info

#define	GET_DEVICE_INFO(p)			((PDEVICEINFO)((p)->OemData[OEM_DEVICE_INFO]))
#define	SET_DEVICE_INFO(p,x)			((p)->OemData[OEM_DEVICE_INFO]=(ULONG)x)

#define	GET_DEVICE_UNIT(p)			((ULONG)((p)->OemData[OEM_DEVICE_UNIT]))
#define	SET_DEVICE_UNIT(p,x)			((p)->OemData[OEM_DEVICE_UNIT]=(ULONG)x)

#define	GET_DEVICE_SIBLING(p)  		((PGAMEPORT)((p)->OemData[OEM_DEVICE_SIBLING]))
#define	SET_DEVICE_SIBLING(p,x)		((p)->OemData[OEM_DEVICE_SIBLING]=(ULONG)x)

#define	GET_DEVICE_ID(p)				((USHORT)((p)->OemData[OEM_DEVICE_ID]))
#define	SET_DEVICE_ID(p,x)			((p)->OemData[OEM_DEVICE_ID]=(USHORT)x)

#define	GET_DEVICE_DETECTED(p)  	((PDEVICEINFO)((p)->OemData[OEM_DEVICE_DETECTED]))
#define	SET_DEVICE_DETECTED(p,x)	((p)->OemData[OEM_DEVICE_DETECTED]=(ULONG)x)

#define	GET_DEVICE_OBJECT(p)  		((PDEVICE_OBJECT)((p)->OemData[OEM_DEVICE_OBJECT]))
#define	SET_DEVICE_OBJECT(p,x)		((p)->OemData[OEM_DEVICE_OBJECT]=(ULONG)x)

//---------------------------------------------------------------------------
//			Public Data
//---------------------------------------------------------------------------

extern	ULONG		POV_Values[];
extern	ULONG		PollingInterval;

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

BOOLEAN
DEVICE_IsOddParity (
	IN		PVOID			Data,
	IN		ULONG			Count
	);

BOOLEAN
DEVICE_IsCollision (
	IN		PPACKETINFO	DataPacket
	);

NTSTATUS
DEVICE_DriverEntry (VOID);

NTSTATUS
DEVICE_GetDeviceDescriptor (
	IN		PGAMEPORT	PortInfo,
	OUT	PUCHAR		Descriptor,
	IN		ULONG			MaxSize,
	OUT	PULONG		Copied
	);

NTSTATUS
DEVICE_GetReportDescriptor (
	IN		PGAMEPORT	PortInfo,
	OUT	PUCHAR		Descriptor,
	IN		ULONG			MaxSize,
	OUT	PULONG		Copied
	);

NTSTATUS
DEVICE_StartDevice (
	IN		PGAMEPORT	PortInfo,
	IN		PWCHAR		HardwareId
	);

NTSTATUS
DEVICE_ReadReport (
	IN		PGAMEPORT	PortInfo,
	OUT	PUCHAR		Report,
	IN		ULONG			MaxSize,
	OUT	PULONG		Copied
	);

NTSTATUS
DEVICE_StopDevice (
	IN		PGAMEPORT	PortInfo,
	IN		BOOLEAN		TouchHardware
	);

NTSTATUS
DEVICE_GetFeature (
	IN		PGAMEPORT		PortInfo,
	IN		HID_REPORT_ID	ReportId,
	OUT	PVOID				ReportBuffer,
	IN		ULONG				ReportSize,
	OUT	PULONG			Returned
	);

//===========================================================================
//			End
//===========================================================================
#endif	__DEVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\ioctl.c ===
//**************************************************************************
//
//		IOCTL.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	IOCTL.C | Routines to support internal ioctl queries
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (PAGE, MSGAME_GetDeviceDescriptor)
#pragma	alloc_text (PAGE, MSGAME_GetReportDescriptor)
#pragma	alloc_text (PAGE, MSGAME_GetAttributes)
#endif

//---------------------------------------------------------------------------
// @func		Process the Control IRPs sent to this device
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_Internal_Ioctl (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;

	MsGamePrint ((DBG_VERBOSE, "%s: %s_Internal_Ioctl Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get pointer to current location in pIrp
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	// Get a pointer to the device extension
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Increment IRP count to hold driver removes
	//

	InterlockedIncrement (&pDevExt->IrpCount);

	//
	//	Check if we've been removed and bounce request
	//

	if (pDevExt->Removed)
		{
		//
		// Someone sent us another IRP after removed
		//

		MsGamePrint ((DBG_SEVERE, "%s: internal Irp after device removed\n", MSGAME_NAME));
		ASSERT (FALSE);

		if (!InterlockedDecrement (&pDevExt->IrpCount))
			KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Process HID internal IO request
	//

	switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
		{
		case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_DEVICE_DESCRIPTOR\n", MSGAME_NAME));
			ntStatus = MSGAME_GetDeviceDescriptor (DeviceObject, pIrp);
			break;

		case IOCTL_HID_GET_REPORT_DESCRIPTOR:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_REPORT_DESCRIPTOR\n", MSGAME_NAME));
			ntStatus = MSGAME_GetReportDescriptor (DeviceObject, pIrp);
			break;

		case IOCTL_HID_READ_REPORT:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_READ_REPORT\n", MSGAME_NAME));
			ntStatus = MSGAME_ReadReport (DeviceObject, pIrp);
			break;

		case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_DEVICE_ATTRIBUTES\n", MSGAME_NAME));
			ntStatus = MSGAME_GetAttributes (DeviceObject, pIrp);
			break;

		case IOCTL_HID_ACTIVATE_DEVICE:
		case IOCTL_HID_DEACTIVATE_DEVICE:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_(DE)ACTIVATE_DEVICE\n", MSGAME_NAME));
			ntStatus = STATUS_SUCCESS;
			break;

		case	IOCTL_HID_GET_FEATURE:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_GET_FEATURE\n", MSGAME_NAME));
			ntStatus = MSGAME_GetFeature (DeviceObject, pIrp);
			break;

		case	IOCTL_HID_SET_FEATURE:
			MsGamePrint ((DBG_VERBOSE, "%s: IOCTL_HID_SET_FEATURE\n", MSGAME_NAME));
			ntStatus = STATUS_NOT_SUPPORTED;
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "%s: Unknown or unsupported IOCTL (%x)\n", MSGAME_NAME,
							 pIrpStack->Parameters.DeviceIoControl.IoControlCode));
			ntStatus = STATUS_NOT_SUPPORTED;
			break;
		}

	//
	// Set real return status in pIrp
	//

	pIrp->IoStatus.Status = ntStatus;

	//
	// Complete Irp
	//

	IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	//
	//	Decrement IRP count for device removes
	//

	if (!InterlockedDecrement (&pDevExt->IrpCount))
		KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: %s_Internal_Ioctl Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Processes the HID getdevice descriptor IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetDeviceDescriptor (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetDeviceDescriptor Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	// Get a pointer to the device extension
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// Get device descriptor into HIDCLASS buffer
	//

	ntStatus	=	DEVICE_GetDeviceDescriptor (
						&pDevExt->PortInfo,
						pIrp->UserBuffer,
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						&pIrp->IoStatus.Information);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetDeviceDescriptor Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID get report descriptor IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetReportDescriptor (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;
	NTSTATUS					ntStatus;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetReportDescriptor Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	// Get a pointer to the device extension
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// Get report descriptor into HIDCLASS buffer
	//

	ntStatus	=	DEVICE_GetReportDescriptor (
						&pDevExt->PortInfo,
						pIrp->UserBuffer,
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						&pIrp->IoStatus.Information);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetReportDescriptor Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID get attributes IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetAttributes (PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS						ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION			pDevExt;
	PIO_STACK_LOCATION		irpStack;
	PHID_DEVICE_ATTRIBUTES	pDevAtt;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetAttributes Entry\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	irpStack = IoGetCurrentIrpStackLocation (Irp);

	//
	// Get a pointer to the device extension
	//

	pDevExt 	= GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
	pDevAtt	= (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

	ASSERT(sizeof(HID_DEVICE_ATTRIBUTES) == irpStack->Parameters.DeviceIoControl.OutputBufferLength);

	//
	//	Fill in HID device attributes
	//

	pDevAtt->Size				= sizeof (HID_DEVICE_ATTRIBUTES);
	pDevAtt->VendorID			= MSGAME_VENDOR_ID;
	pDevAtt->ProductID		= GET_DEVICE_ID(&pDevExt->PortInfo);
	pDevAtt->VersionNumber	= MSGAME_VERSION_NUMBER;

	//
	// Report how many bytes were copied
	//

	Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetAttributes Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID get device features IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetFeature (PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	irpStack;
	PHID_XFER_PACKET		Packet;
	PUCHAR					Report;

	MsGamePrint ((DBG_INFORM, "%s: %s_GetFeature Entry\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the current location in the Irp
	//

	irpStack = IoGetCurrentIrpStackLocation (Irp);

	//
	// Get a pointer to the device extension
	//

	pDevExt 	= GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

	//
	//	Get pointer to feature packet
	//

	Packet = (PHID_XFER_PACKET)Irp->UserBuffer;

	//
	//	Test packet size in case version error
	//

	ASSERT (irpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(HID_XFER_PACKET));

	//
	//	Setup return values (return HidReportId even on errors)
	//

	Report = Packet->reportBuffer;
	*(PHID_REPORT_ID)Report++ = (HID_REPORT_ID)Packet->reportId;
	Irp->IoStatus.Information = sizeof (HID_REPORT_ID);

	//
	//	Check if device has been removed
	//

	if (pDevExt->Removed || pDevExt->Surprised)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetFeature On Removed Device!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Check if device being removed
	//
	
	if (pDevExt->Removing)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetFeature On Device Pending Removal!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Call mini-driver to process
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetFeature Report Id = %lu\n", MSGAME_NAME, MSGAME_NAME, Packet->reportId));
	ntStatus = DEVICE_GetFeature (&pDevExt->PortInfo,
											Packet->reportId,
											Report,
											Packet->reportBufferLen,
											&Irp->IoStatus.Information);

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetFeature Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Processes the HID read report IRP
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_ReadReport (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_PENDING;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;
	PIO_STACK_LOCATION	nextStack;
	KIRQL						OldIrql;
	PUCHAR 					Report;

	MsGamePrint ((DBG_VERBOSE, "%s: %s_ReadReport Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get a pointer to the device extension.
	//

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// Get stack location
	//

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	//
	//	Setup return values (return HidReportId even on errors)
	//

	Report = pIrp->UserBuffer;
	if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength > sizeof (DEVICE_PACKET))
		{
		*(PHID_REPORT_ID)Report++ = (HID_REPORT_ID)MSGAME_INPUT_JOYINFOEX;
		pIrp->IoStatus.Information = sizeof (HID_REPORT_ID);
		}
	else pIrp->IoStatus.Information = 0;

	//
	//	Check if device has been removed
	//

	if (pDevExt->Removed || pDevExt->Surprised)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_ReadReport On Removed Device!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Check if device being removed
	//
	
	if (pDevExt->Removing)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_ReadReport On Device Pending Removal!\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Poll the device layer
	//

	ntStatus	=	DEVICE_ReadReport (
						&pDevExt->PortInfo,
						Report,
						pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
						&pIrp->IoStatus.Information);

	//
	//	Check status for device changes
	//

	switch (ntStatus)
		{
		case	STATUS_SIBLING_ADDED:
			//
			//	Tell GameEnum to Create a Device
			//
			ntStatus = MSGAME_CreateDevice (DeviceObject);
			break;

		case	STATUS_SIBLING_REMOVED:
			//
			//	Tell GameEnum to Remove a Device
			//
			ntStatus = MSGAME_RemoveDevice (DeviceObject);
			break;

		case	STATUS_DEVICE_CHANGED:
			//
			//	Tell GameEnum to Create a New Device
			//
			ntStatus = MSGAME_ChangeDevice (DeviceObject);
			break;
		}

	//
	//	Return status
	//

	MsGamePrint ((DBG_VERBOSE, "%s: %s_ReadReport Exit = 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
	return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\msgame.h ===
//**************************************************************************
//
//      MSGAME.H -- Xena Gaming Project
//
//      Version 3.XX
//
//      Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//      @doc
//      @header MSGAME.H | Global includes and definitions for gameport driver.
//**************************************************************************

#ifndef __MSGAME_H__
#define __MSGAME_H__

#ifdef  SAITEK
#define MSGAME_NAME     "SAIGAME"
#else
#define MSGAME_NAME     "MSGAME"
#endif

//---------------------------------------------------------------------------
//          Public Include Files
//---------------------------------------------------------------------------

#include    <wdm.h>
#include    <hidclass.h>
#include    <hidusage.h>
#include    <hidtoken.h>
#include    <hidport.h>
#include    <gameport.h>

//---------------------------------------------------------------------------
//          Types
//---------------------------------------------------------------------------

//  @type GAMEPORT | Retyped to avoid long function declarations
typedef GAMEENUM_PORT_PARAMETERS      GAMEPORT;
typedef GAMEENUM_PORT_PARAMETERS    *PGAMEPORT;

typedef struct
{                                               // @struct GAME_WORK_ITEM | Game change structure
    WORK_QUEUE_ITEM QueueItem;      // @field Work queue item for passive callback
    PDEVICE_OBJECT      DeviceObject;   // @field Device object for subsequent change
    GAMEPORT                PortInfo;       // @field Game port parameters
}   GAME_WORK_ITEM, *PGAME_WORK_ITEM;

//  @type HID_REPORT_ID | Retyped for portability and readability
typedef UCHAR                                 HID_REPORT_ID;    
typedef UCHAR                               *PHID_REPORT_ID;    

//---------------------------------------------------------------------------
//          Transaction Types
//---------------------------------------------------------------------------

typedef enum
{                                           // @enum MSGAME_TRANSACTION | Device transaction types
    MSGAME_TRANSACT_NONE,           // @emem No transaction type
    MSGAME_TRANSACT_RESET,          // @emem Reset transaction type
    MSGAME_TRANSACT_DATA,           // @emem Data transaction type
    MSGAME_TRANSACT_ID,             // @emem Id transaction type
    MSGAME_TRANSACT_STATUS,         // @emem Status transaction type
    MSGAME_TRANSACT_SPEED,          // @emem Speed transaction type
    MSGAME_TRANSACT_GODIGITAL,      // @emem GoDigital transaction type
    MSGAME_TRANSACT_GOANALOG        // @emem GoAnalog transaction type
}   MSGAME_TRANSACTION;

//---------------------------------------------------------------------------
//          Local Include Files
//---------------------------------------------------------------------------

#include    "debug.h"
#include    "device.h"
#include    "timer.h"
#include    "portio.h"

#define public

//---------------------------------------------------------------------------
//          Definitions
//---------------------------------------------------------------------------

#ifdef  SAITEK
#define MSGAME_VENDOR_ID                ((USHORT)'SA')
#else
#define MSGAME_VENDOR_ID                ((USHORT)0x045E)
#endif

#define MSGAME_VERSION_NUMBER       ((USHORT)3)

#define MSGAME_HID_VERSION          0x0100
#define MSGAME_HID_COUNTRY          0x0000
#define MSGAME_HID_DESCRIPTORS      0x0001

#define MSGAME_AUTODETECT_ID            L"Gameport\\SideWinderGameController\0\0"

//---------------------------------------------------------------------------
//          Structures
//---------------------------------------------------------------------------

typedef struct
{                                           // @struct DEVICE_EXTENSION | Device extension data
    PDRIVER_OBJECT Driver;          // @field A back pointer to the actual DriverObject
    PDEVICE_OBJECT  Self;               // @field A back pointer to the actual DeviceObject
    LONG                IrpCount;       // @field 1 biased count of why object sticks around
    BOOLEAN         Started;            // @field This device has been started
    BOOLEAN         Removed;            // @field This device has been removed
    BOOLEAN        Surprised;       // @field This device has been surprise removed
    BOOLEAN        Removing;        // @field This device is being removed
    PDEVICE_OBJECT  TopOfStack;     // @field The top of the device stack beneath this device
    GAMEPORT            PortInfo;       // @field Game resource info structure filled by GameEnumerator
    KEVENT          StartEvent;     // @field An event to sync the start IRP.
    KEVENT          RemoveEvent;    // @field An event to synch outstandIO to zero
}   DEVICE_EXTENSION,   *PDEVICE_EXTENSION;

//---------------------------------------------------------------------------
//          Macros
//---------------------------------------------------------------------------

#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) \
    ((PDEVICE_EXTENSION)(((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_NEXT_DEVICE_OBJECT(DO) \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

#define STD0(txt)           #txt
#define STD1(txt)           STD0(txt)
#define STILL_TO_DO(txt)    message("\nSTILL TO DO: "__FILE__"("STD1(__LINE__)"): "#txt"\n")

#define ARRAY_SIZE(a)       (sizeof(a)/sizeof(a[0]))

#define EXCHANGE(x,y)       ((x)^=(y)^=(x)^=(y))

#define TOUPPER(x)          ((x>='a'&&x<='z')?x-'a'+'A':x)

//---------------------------------------------------------------------------
//          Procedures
//---------------------------------------------------------------------------

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING     registryPath
    );

NTSTATUS
MSGAME_CreateClose (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_SystemControl (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_AddDevice (
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject
    );

VOID
MSGAME_Unload (
    IN  PDRIVER_OBJECT          DriverObject
    );

VOID
MSGAME_ReadRegistry (
    PCHAR                           DeviceName,
    PDEVICE_VALUES              DeviceValues
    );

NTSTATUS
MSGAME_Internal_Ioctl (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetDeviceDescriptor (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetReportDescriptor (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetAttributes (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        Irp
    );

NTSTATUS
MSGAME_GetFeature (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        Irp
    );

NTSTATUS
MSGAME_ReadReport (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

PWCHAR
MSGAME_GetHardwareId (
    IN  PDEVICE_OBJECT          DeviceObject
    );

BOOLEAN
MSGAME_CompareHardwareIds (
    IN  PWCHAR                  HardwareId,
    IN  PWCHAR                  DeviceId
    );

VOID
MSGAME_FreeHardwareId (
    IN  PWCHAR                  HardwareId
    );

NTSTATUS
MSGAME_PnP (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_PnPComplete (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp,
    IN  PVOID                       Context
    );

NTSTATUS
MSGAME_StartDevice (
    IN  PDEVICE_EXTENSION       pDevExt,
    IN  PIRP                        pIrp
    );

VOID
MSGAME_StopDevice (
    IN  PDEVICE_EXTENSION       pDevExt,
    IN  BOOLEAN                 TouchTheHardware
    );

NTSTATUS
MSGAME_Power (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetResources (
    IN  PDEVICE_EXTENSION       pDevExt,
    IN  PIRP                        pIrp
    );

NTSTATUS
MSGAME_GetResourcesComplete (
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                        pIrp,
    IN  PVOID                       Context
    );

VOID 
MSGAME_PostTransaction (
    IN      PPACKETINFO         PacketInfo
    );

NTSTATUS
MSGAME_CreateDevice (
    IN      PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
MSGAME_RemoveDevice (
    IN      PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
MSGAME_ChangeDevice (
    IN      PDEVICE_OBJECT  DeviceObject
    );

//===========================================================================
//          End
//===========================================================================
#endif  // __MSGAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\msgame.c ===
//**************************************************************************
//
//      MSGAME.C -- Xena Gaming Project
//
//      Version 3.XX
//
//      Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//      @doc
//      @module MSGAME.C | Human Input Device (HID) gameport driver
//**************************************************************************

#include    "msgame.h"

//---------------------------------------------------------------------------
//  Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef  ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (INIT, MSGAME_ReadRegistry)
#pragma alloc_text (PAGE, MSGAME_CreateClose)
#pragma alloc_text (PAGE, MSGAME_SystemControl)
#pragma alloc_text (PAGE, MSGAME_AddDevice)
#endif

//---------------------------------------------------------------------------
//      Private Data
//---------------------------------------------------------------------------

static  UNICODE_STRING      RegistryPath;

//---------------------------------------------------------------------------
// @func        Main driver entry point
//  @parm       PDRIVER_OBJECT | DriverObject | Pointer to driver object
//  @parm       PUNICODE_STRING | registryPath | Registry path for this device
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    DriverEntry (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath)
{
    NTSTATUS                                ntStatus;
    RTL_QUERY_REGISTRY_TABLE        Parameters[2];
    HID_MINIDRIVER_REGISTRATION HidMinidriverRegistration;

    MsGamePrint ((DBG_CRITICAL, "%s: Built %s at %s\n", MSGAME_NAME, __DATE__, __TIME__));
    MsGamePrint ((DBG_INFORM,   "%s: DriverEntry Enter\n", MSGAME_NAME));

    //
    //  Fill in driver dispatch table
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                      =   MSGAME_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                       =   MSGAME_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]     =   MSGAME_Internal_Ioctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                         =   MSGAME_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                       =   MSGAME_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]              =   MSGAME_SystemControl;
    DriverObject->DriverUnload                                      =   MSGAME_Unload;
    DriverObject->DriverExtension->AddDevice                        =   MSGAME_AddDevice;

    //
    // Register driver with Hid.Sys
    //

    HidMinidriverRegistration.Revision                  = HID_REVISION;
    HidMinidriverRegistration.DriverObject              = DriverObject;
    HidMinidriverRegistration.RegistryPath              = registryPath;
    HidMinidriverRegistration.DeviceExtensionSize   = sizeof (DEVICE_EXTENSION);
    HidMinidriverRegistration.DevicesArePolled      = TRUE;
    MsGamePrint ((DBG_CONTROL, "%s: Registering with HID.SYS\n", MSGAME_NAME));
    ntStatus = HidRegisterMinidriver (&HidMinidriverRegistration);
    
    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //

    if (NT_SUCCESS(ntStatus))
        {
        RtlInitUnicodeString (&RegistryPath, NULL);
        RegistryPath.Length = registryPath->Length + sizeof(UNICODE_NULL);
        RegistryPath.MaximumLength = RegistryPath.Length;
        RegistryPath.Buffer = ExAllocatePool (PagedPool, RegistryPath.Length);
        RtlZeroMemory (RegistryPath.Buffer, RegistryPath.Length);
        RtlMoveMemory (RegistryPath.Buffer, registryPath->Buffer, registryPath->Length);
        }

    //
    //  Read any driver specific registry values
    //

    if (NT_SUCCESS(ntStatus))
        {
        RtlZeroMemory (Parameters, sizeof(Parameters));
        Parameters[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
        Parameters[0].Name              = L"PollingInterval";
        Parameters[0].EntryContext  = &PollingInterval;
        Parameters[0].DefaultType       = REG_DWORD;
        Parameters[0].DefaultData       = &PollingInterval;
        Parameters[0].DefaultLength = sizeof(ULONG);
        if (!NT_SUCCESS(RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE, RegistryPath.Buffer, Parameters, NULL, NULL)))
            {
            MsGamePrint((DBG_INFORM,"%s: %s_DriverEntry RtlQueryRegistryValues failed\n", MSGAME_NAME, MSGAME_NAME));
            RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, RegistryPath.Buffer, L"PollingInterval", REG_DWORD, &PollingInterval, sizeof (ULONG));
            }
        MsGamePrint((DBG_CONTROL,"%s: Polling interval will be %lu milliseconds\n", MSGAME_NAME, PollingInterval));
        }

    //
    //  Initialize portio layer on entry
    //

    if (NT_SUCCESS(ntStatus))
        ntStatus = PORTIO_DriverEntry ();

    //
    //  Initialize device layer on entry
    //

    if (NT_SUCCESS(ntStatus))
        ntStatus = DEVICE_DriverEntry ();

    // 
    // Return driver status
    //

    MsGamePrint ((DBG_INFORM, "%s: DriverEntry Exit = %x\n", MSGAME_NAME, ntStatus));
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Process the Create and Close IRPs
//  @parm       PDEVICE_OBJECT | DeviceObject | Pointer to device object
//  @parm       PIRP | pIrp | Pointer to IO request packet
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    MSGAME_CreateClose (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    PAGED_CODE ();

    MsGamePrint ((DBG_INFORM, "%s: %s_CreateClose Enter\n", MSGAME_NAME, MSGAME_NAME));

    //
    // Get pointer to current location in Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Process Create or Close function call
    //

    switch (IrpStack->MajorFunction)
        {
        case IRP_MJ_CREATE:
            MsGamePrint ((DBG_VERBOSE, "%s: IRP_MJ_CREATE\n", MSGAME_NAME));
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            MsGamePrint ((DBG_VERBOSE, "%s: IRP_MJ_CLOSE\n", MSGAME_NAME));
            Irp->IoStatus.Information = 0;
            break;

        default:
            MsGamePrint ((DBG_SEVERE, "%s:  Invalid CreateClose Parameter\n", MSGAME_NAME));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
        }

    //
    // Save Status for return and complete Irp
    //

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    MsGamePrint ((DBG_INFORM, "%s:  %s_CreateClose Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Process the WMI system control IRPs
//  @parm       PDEVICE_OBJECT | DeviceObject | Pointer to device object
//  @parm       PIRP | pIrp | Pointer to IO request packet
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    MSGAME_SystemControl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE ();

    MsGamePrint ((DBG_INFORM, "%s: %s_SystemControl Enter\n", MSGAME_NAME, MSGAME_NAME));

    IoSkipCurrentIrpStackLocation (Irp);

    ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
    
    MsGamePrint ((DBG_INFORM, "%s:  %s_SystemControl Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
    
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Processes the Pnp Add Device call
//  @parm       PDRIVER_OBJECT | DriverObject | Pointer to driver object
//  @parm       PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

NTSTATUS    MSGAME_AddDevice (IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS                ntStatus    = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;

    PAGED_CODE ();

    MsGamePrint ((DBG_INFORM, "%s: %s_AddDevice Entry\n", MSGAME_NAME, MSGAME_NAME));

    //
    // Initialize the device extension
    //

    pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);
    memset(pDevExt, 0, sizeof(DEVICE_EXTENSION));

    pDevExt->Driver     =   DriverObject;
    pDevExt->Self           =   DeviceObject;
    pDevExt->IrpCount   =   1;
    pDevExt->Started        =   FALSE;
    pDevExt->Removed        =   FALSE;
    pDevExt->Surprised  =   FALSE;
    pDevExt->Removing       =   FALSE;
    pDevExt->TopOfStack =   NULL;
    KeInitializeEvent (&pDevExt->StartEvent, NotificationEvent, FALSE);
    KeInitializeEvent (&pDevExt->RemoveEvent, SynchronizationEvent, FALSE);

    //
    //  Clear device initialization flags
    //
    
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Attach our functional driver to the device stack. The return value of
    // IoAttachDeviceToDeviceStack is the top of the attachment chain. This
    // is where all the IRPs should be routed.
    //

    pDevExt->TopOfStack = GET_NEXT_DEVICE_OBJECT(DeviceObject);

    //
    // If this attachment fails then top of stack will be null. Failure
    // for attachment is an indication of a broken plug play system.
    //

    ASSERT (pDevExt->TopOfStack);

    //
    //  Return status
    //

    MsGamePrint ((DBG_INFORM, "%s: %s_AddDevice Exit = %x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
    return (ntStatus);
}

//---------------------------------------------------------------------------
// @func        Processes the driver unload call
//  @parm       PDRIVER_OBJECT | DriverObject | Pointer to driver object
// @rdesc   Returns NT status code
//  @comm       Public function
//---------------------------------------------------------------------------

VOID    MSGAME_Unload (IN PDRIVER_OBJECT DriverObject)
{
    PAGED_CODE();

    MsGamePrint ((DBG_INFORM, "%s: %s_Unload Enter\n", MSGAME_NAME, MSGAME_NAME));

    //
    // All the device objects should be gone
    //

    ASSERT (!DriverObject->DeviceObject);

    //
    // Free the unicode strings.
    //

    ExFreePool (RegistryPath.Buffer);

    MsGamePrint ((DBG_CONTROL, "%s: %s_Unload Exit\n", MSGAME_NAME, MSGAME_NAME));
}

//---------------------------------------------------------------------------
// @func        Reads registry data for a named device
//  @parm       PCHAR | DeviceName | Device name string
//  @parm       PDEVICE_VALUES | DeviceValues | Device values structure to fill
// @rdesc   Returns nothing
//  @comm       Public function
//---------------------------------------------------------------------------

VOID    MSGAME_ReadRegistry (PCHAR DeviceName, PDEVICE_VALUES DeviceValues)
{
    #define PARAMS_PLUS_ONE 13

    NTSTATUS                            ntStatus;
    ANSI_STRING                     AnsiName;
    UNICODE_STRING                  UnicodeName;
    UNICODE_STRING                  ParametersPath;
    PRTL_QUERY_REGISTRY_TABLE   Parameters;

    MsGamePrint((DBG_INFORM,"%s: %s_ReadRegistry Enter\n", MSGAME_NAME, MSGAME_NAME));

    //
    //  Initialize local variables
    //

    RtlInitAnsiString       (&AnsiName, DeviceName);
    RtlInitUnicodeString    (&UnicodeName, NULL);
    RtlInitUnicodeString    (&ParametersPath, NULL);

    Parameters = ExAllocatePool (PagedPool, sizeof(RTL_QUERY_REGISTRY_TABLE) * PARAMS_PLUS_ONE);

    if (!Parameters)
        {
        MsGamePrint((DBG_CRITICAL, "%s: %s_ReadRegistry couldn't allocate Rtl query table for %ws\n", MSGAME_NAME, MSGAME_NAME, RegistryPath.Buffer));
        goto ReadRegistryExit;
        }

    RtlZeroMemory (Parameters, sizeof(RTL_QUERY_REGISTRY_TABLE) * PARAMS_PLUS_ONE);

    //
    // Form a path to this driver's Parameters subkey.
    //

    ParametersPath.MaximumLength    = RegistryPath.Length + MAX_DEVICE_NAME;
    ParametersPath.Buffer           = ExAllocatePool (PagedPool, ParametersPath.MaximumLength);

    if (!ParametersPath.Buffer)
        {
        MsGamePrint((DBG_CRITICAL, "%s: %s_ReadRegistry couldn't allocate path string for %ws\n", MSGAME_NAME, MSGAME_NAME, RegistryPath.Buffer));
        goto ReadRegistryExit;
        }

    //
    // Form the Parameters path.
    //

    RtlZeroMemory (ParametersPath.Buffer, ParametersPath.MaximumLength);
    RtlAppendUnicodeToString (&ParametersPath, RegistryPath.Buffer);
    RtlAppendUnicodeToString (&ParametersPath, L"\\");

    RtlAnsiStringToUnicodeString (&UnicodeName, &AnsiName, TRUE);
    RtlAppendUnicodeStringToString (&ParametersPath, &UnicodeName);
    RtlFreeUnicodeString (&UnicodeName);

    MsGamePrint((DBG_VERBOSE, "%s: %s_ReadRegistry path is %ws\n", MSGAME_NAME, MSGAME_NAME, ParametersPath.Buffer));

    //
    // Gather all device information from the registry.
    //

    Parameters[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[0].Name              = L"PacketStartTimeout";
    Parameters[0].EntryContext  = &DeviceValues->PacketStartTimeout;
    Parameters[0].DefaultType       = REG_DWORD;
    Parameters[0].DefaultData       = &DeviceValues->PacketStartTimeout;
    Parameters[0].DefaultLength = sizeof(ULONG);
 
    Parameters[1].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[1].Name              = L"PacketLowHighTimeout";
    Parameters[1].EntryContext  = &DeviceValues->PacketLowHighTimeout;
    Parameters[1].DefaultType       = REG_DWORD;
    Parameters[1].DefaultData       = &DeviceValues->PacketLowHighTimeout;
    Parameters[1].DefaultLength = sizeof(ULONG);

    Parameters[2].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[2].Name              = L"PacketHighLowTimeout";
    Parameters[2].EntryContext  = &DeviceValues->PacketHighLowTimeout;
    Parameters[2].DefaultType       = REG_DWORD;
    Parameters[2].DefaultData       = &DeviceValues->PacketHighLowTimeout;
    Parameters[2].DefaultLength = sizeof(ULONG);

    Parameters[3].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[3].Name              = L"IdStartTimeout";
    Parameters[3].EntryContext  = &DeviceValues->IdStartTimeout;
    Parameters[3].DefaultType       = REG_DWORD;
    Parameters[3].DefaultData       = &DeviceValues->IdStartTimeout;
    Parameters[3].DefaultLength = sizeof(ULONG);

    Parameters[4].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[4].Name              = L"IdLowHighTimeout";
    Parameters[4].EntryContext  = &DeviceValues->IdLowHighTimeout;
    Parameters[4].DefaultType       = REG_DWORD;
    Parameters[4].DefaultData       = &DeviceValues->IdLowHighTimeout;
    Parameters[4].DefaultLength = sizeof(ULONG);

    Parameters[5].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[5].Name              = L"IdHighLowTimeout";
    Parameters[5].EntryContext  = &DeviceValues->IdHighLowTimeout;
    Parameters[5].DefaultType       = REG_DWORD;
    Parameters[5].DefaultData       = &DeviceValues->IdHighLowTimeout;
    Parameters[5].DefaultLength = sizeof(ULONG);

    Parameters[6].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[6].Name              = L"InterruptDelay";
    Parameters[6].EntryContext  = &DeviceValues->InterruptDelay;
    Parameters[6].DefaultType       = REG_DWORD;
    Parameters[6].DefaultData       = &DeviceValues->InterruptDelay;
    Parameters[6].DefaultLength = sizeof(ULONG);

    Parameters[7].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[7].Name              = L"MaxClockDutyCycle";
    Parameters[7].EntryContext  = &DeviceValues->MaxClockDutyCycle;
    Parameters[7].DefaultType       = REG_DWORD;
    Parameters[7].DefaultData       = &DeviceValues->MaxClockDutyCycle;
    Parameters[7].DefaultLength = sizeof(ULONG);

    Parameters[8].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[8].Name              = L"StatusStartTimeout";
    Parameters[8].EntryContext  = &DeviceValues->StatusStartTimeout;
    Parameters[8].DefaultType       = REG_DWORD;
    Parameters[8].DefaultData       = &DeviceValues->StatusStartTimeout;
    Parameters[8].DefaultLength = sizeof(ULONG);

    Parameters[9].Flags             = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[9].Name              = L"StatusLowHighTimeout";
    Parameters[9].EntryContext  = &DeviceValues->StatusLowHighTimeout;
    Parameters[9].DefaultType       = REG_DWORD;
    Parameters[9].DefaultData       = &DeviceValues->StatusLowHighTimeout;
    Parameters[9].DefaultLength = sizeof(ULONG);

    Parameters[10].Flags                = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[10].Name             = L"StatusHighLowTimeout";
    Parameters[10].EntryContext     = &DeviceValues->StatusHighLowTimeout;
    Parameters[10].DefaultType      = REG_DWORD;
    Parameters[10].DefaultData      = &DeviceValues->StatusHighLowTimeout;
    Parameters[10].DefaultLength    = sizeof(ULONG);

    Parameters[11].Flags                = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[11].Name             = L"StatusGateTimeout";
    Parameters[11].EntryContext     = &DeviceValues->StatusGateTimeout;
    Parameters[11].DefaultType      = REG_DWORD;
    Parameters[11].DefaultData      = &DeviceValues->StatusGateTimeout;
    Parameters[11].DefaultLength    = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, Parameters, NULL, NULL);

    if (!NT_SUCCESS(ntStatus))
        {
        MsGamePrint((DBG_INFORM,"%s: %s_ReadRegistry RtlQueryRegistryValues failed with 0x%x\n", MSGAME_NAME, MSGAME_NAME, ntStatus));
        //
        //  Create registry entries as needed
        //
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"PacketStartTimeout", REG_DWORD, &DeviceValues->PacketStartTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"PacketLowHighTimeout", REG_DWORD, &DeviceValues->PacketLowHighTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"PacketHighLowTimeout", REG_DWORD, &DeviceValues->PacketHighLowTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"IdStartTimeout", REG_DWORD, &DeviceValues->IdStartTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"IdLowHighTimeout", REG_DWORD, &DeviceValues->IdLowHighTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"IdHighLowTimeout", REG_DWORD, &DeviceValues->IdHighLowTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"InterruptDelay", REG_DWORD, &DeviceValues->InterruptDelay, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"MaxClockDutyCycle", REG_DWORD, &DeviceValues->MaxClockDutyCycle, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusStartTimeout", REG_DWORD, &DeviceValues->StatusStartTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusLowHighTimeout", REG_DWORD, &DeviceValues->StatusLowHighTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusHighLowTimeout", REG_DWORD, &DeviceValues->StatusHighLowTimeout, sizeof (ULONG));
        RtlWriteRegistryValue (RTL_REGISTRY_ABSOLUTE, ParametersPath.Buffer, L"StatusGateTimeout", REG_DWORD, &DeviceValues->StatusGateTimeout, sizeof (ULONG));
        }

    //  -----------------
        ReadRegistryExit:
    //  -----------------

    if (ParametersPath.Buffer)
        ExFreePool(ParametersPath.Buffer);

    if (Parameters)
        ExFreePool(Parameters);

    #undef  PARAMS_PLUS_ONE
}

//---------------------------------------------------------------------------
// @func        Posts a transaction to hooking driver
//  @parm       PPACKETINFO | PacketInfo | Device packet info struct
// @rdesc   None
//  @comm       Public function
//---------------------------------------------------------------------------

VOID  MSGAME_PostTransaction (PPACKETINFO PacketInfo)
{
    //
    //  Not Implemented
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\hotplug.c ===
//**************************************************************************
//
//		HOTPLUG.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	HOTPLUG.C | Routines to support GameEnum hot-plugging
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//			Private	Procedures
//---------------------------------------------------------------------------

static	VOID	MSGAME_CreateDeviceItem (PGAME_WORK_ITEM WorkItem);
static	VOID	MSGAME_RemoveDeviceItem (PGAME_WORK_ITEM WorkItem);

//---------------------------------------------------------------------------
// @func		Calls GameEnum to add a new device to the chain
//	@parm		PGAME_WORK_ITEM | WorkItem | Pointer to add work item
// @rdesc	None
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	MSGAME_CreateDeviceItem (PGAME_WORK_ITEM	WorkItem)
{
	PIRP								pIrp;
	KEVENT							Event;
	NTSTATUS							ntStatus;
	PDEVICEINFO						DevInfo;
	PDEVICE_EXTENSION				DevExt;
	IO_STATUS_BLOCK				IoStatus;
	GAMEENUM_EXPOSE_SIBLING		ExposeSibling;

	MsGamePrint ((DBG_INFORM, "%s: %s_ExposeSiblingItem Enter\n", MSGAME_NAME, MSGAME_NAME));
	
	//
	// Get a pointer to the device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (WorkItem->DeviceObject);

	//
	//	Initialize expose sibling structure
	//

	memset (&ExposeSibling, 0, sizeof (ExposeSibling));
	ExposeSibling.Size = sizeof (GAMEENUM_EXPOSE_SIBLING);

	//
	//	Are we changing device or adding a sibling?
	//

	DevInfo = GET_DEVICE_DETECTED(&WorkItem->PortInfo);
	if (!DevInfo)
		DevInfo = GET_DEVICE_INFO(&WorkItem->PortInfo);
	else ExposeSibling.HardwareIDs = DevInfo->HardwareId;

	//
	//	Initialize the completion event
	//

	KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

	//
	//	Allocate Internal I/O IRP
	//

	pIrp = IoBuildDeviceIoControlRequest (
					IOCTL_GAMEENUM_EXPOSE_SIBLING,
					DevExt->TopOfStack,
					&ExposeSibling,
					sizeof (GAMEENUM_EXPOSE_SIBLING),
					&ExposeSibling,
					sizeof (GAMEENUM_EXPOSE_SIBLING),
					TRUE,
					&Event,
					&IoStatus);
					
	//
	//	Call GameEnum synchronously
	//

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Expose Device at IRQL=%lu\n", MSGAME_NAME, KeGetCurrentIrql()));
	ntStatus = IoCallDriver (DevExt->TopOfStack, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&Event, Suspended, KernelMode, FALSE, NULL);

	if (!NT_SUCCESS (ntStatus))
		MsGamePrint ((DBG_SEVERE, "%s: GameEnum Failed to Expose Device, Status = %X\n", MSGAME_NAME, ntStatus));

	//
	//	Free work item memory
	//

	ExFreePool (WorkItem);

	//
	//	Decrement IRP count holding driver in memory
	//

	if (!InterlockedDecrement (&DevExt->IrpCount))
		KeSetEvent (&DevExt->RemoveEvent, 0, FALSE);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to remove a device from the chain
//	@parm		PGAME_WORK_ITEM | WorkItem | Pointer to add work item
// @rdesc	None
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	MSGAME_RemoveDeviceItem (PGAME_WORK_ITEM WorkItem)
{
	PIRP								pIrp;
	KEVENT							Event;
	NTSTATUS							ntStatus;
	PDEVICE_EXTENSION				DevExt;
	IO_STATUS_BLOCK				IoStatus;

	MsGamePrint ((DBG_INFORM, "%s: %s_RemoveDeviceItem Enter\n", MSGAME_NAME, MSGAME_NAME));
	
	//
	// Get a pointer to the device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (WorkItem->DeviceObject);

	//
	//	Initialize the completion event
	//

	KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

	//
	//	Allocate Internal I/O IRP
	//

	pIrp = IoBuildDeviceIoControlRequest (
					IOCTL_GAMEENUM_REMOVE_SELF,
					DevExt->TopOfStack,
					NULL,
					0,
					NULL,
					0,
					TRUE,
					&Event,
					&IoStatus);

	//
	//	Call GameEnum synchronously
	//

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Remove Self at IRQL=%lu\n", MSGAME_NAME, KeGetCurrentIrql()));
	ntStatus = IoCallDriver (DevExt->TopOfStack, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&Event, Suspended, KernelMode, FALSE, NULL);

	if (!NT_SUCCESS (ntStatus))
		MsGamePrint ((DBG_SEVERE, "%s: GameEnum Failed to Remove Self, Status = %X\n", MSGAME_NAME, ntStatus));

	//
	//	Free work item memory
	//

	ExFreePool (WorkItem);

	//
	//	Decrement IRP count holding driver in memory
	//

	if (!InterlockedDecrement (&DevExt->IrpCount))
		KeSetEvent (&DevExt->RemoveEvent, 0, FALSE);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to add a new device to the chain
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_CreateDevice (PDEVICE_OBJECT DeviceObject)
{
	PGAME_WORK_ITEM	WorkItem;
	PDEVICE_EXTENSION	DevExt;

	MsGamePrint ((DBG_INFORM, "%s: %s_ExposeSibling Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get pointer to device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Allocate work item memory
	//

	WorkItem = ExAllocatePool (NonPagedPool, sizeof (GAME_WORK_ITEM));
	if (!WorkItem)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_ExposeSibling Failed to Allocate Work Item\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_INSUFFICIENT_RESOURCES);
		}

	//
	//	Increment IRP count to hold driver in memory
	//

	InterlockedIncrement (&DevExt->IrpCount);

	//
	//	Initialize work item memory
	//

	ExInitializeWorkItem (&WorkItem->QueueItem, (PWORKER_THREAD_ROUTINE)MSGAME_CreateDeviceItem, WorkItem);
	WorkItem->DeviceObject	= DeviceObject;
	WorkItem->PortInfo		= DevExt->PortInfo;

	//
	//	Queue the work item
	//

	MsGamePrint ((DBG_CONTROL, "%s: %s_ExposeSibling Queueing %s_ExposeSiblingItem\n", MSGAME_NAME, MSGAME_NAME, MSGAME_NAME));
	ExQueueWorkItem (&WorkItem->QueueItem, DelayedWorkQueue);

	//
	//	Return status
	//

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to remove a device from the chain
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_RemoveDevice (PDEVICE_OBJECT DeviceObject)
{
	PDEVICEINFO			DevInfo;
	PGAME_WORK_ITEM	WorkItem;
	PDEVICE_EXTENSION	DevExt;

	MsGamePrint ((DBG_INFORM, "%s: %s_RemoveDevice Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Get pointer to device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Get device information
	//

	DevInfo = GET_DEVICE_INFO(&DevExt->PortInfo);

	//
	//	Skip if device already removed
	//

	if (DevExt->Removing || DevExt->Surprised || DevExt->Removed)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_RemoveDevice attempted to destroy removed device\n", MSGAME_NAME, MSGAME_NAME));
		InterlockedIncrement (&DevInfo->DevicePending);
		return (STATUS_DELETE_PENDING);
		}

	//
	//	Allocate work item memory
	//

	WorkItem = ExAllocatePool (NonPagedPool, sizeof (GAME_WORK_ITEM));
	if (!WorkItem)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_RemoveDevice Failed to Allocate Work Item\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_INSUFFICIENT_RESOURCES);
		}

	//
	//	Increment IRP count to hold driver in memory
	//

	InterlockedIncrement (&DevExt->IrpCount);

	//
	//	Mark device as being removed
	//

	DevExt->Removing = TRUE;

	//
	//	Initialize work item memory
	//

	ExInitializeWorkItem (&WorkItem->QueueItem, (PWORKER_THREAD_ROUTINE)MSGAME_RemoveDeviceItem, WorkItem);
	WorkItem->DeviceObject	= DevExt->Self;
	WorkItem->PortInfo		= DevExt->PortInfo;

	//
	//	Queue the work item
	//

	MsGamePrint ((DBG_CONTROL, "%s: %s_RemoveDevice Queueing %s_RemoveDeviceItem\n", MSGAME_NAME, MSGAME_NAME, MSGAME_NAME));
	ExQueueWorkItem (&WorkItem->QueueItem, DelayedWorkQueue);

	//
	//	Return status
	//

	return (STATUS_DEVICE_NOT_READY);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to add a new device to the chain
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_ChangeDevice (PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_EXTENSION	DevExt;

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Change Device\n", MSGAME_NAME));

	//
	// Get pointer to device extension.
	//

	DevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	//	Increment IRP count to hold driver in memory
	//

	// InterlockedIncrement (&DevExt->IrpCount);

	//
	//	Remove old device first
	//

	MSGAME_RemoveDevice (DeviceObject);

	//
	//	Create new device second
	//

	MSGAME_CreateDevice (DeviceObject);

	//
	//	Return status
	//

	return (STATUS_DEVICE_NOT_READY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dff.c ===
//**************************************************************************
//
//		SW3DFF.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DFF.C | Gameport mini-driver for Sidewinder Pro Force Feedback
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"
#include	"swforce.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DFF"
#define	DEVICE_PID					0x0006
#define	HARDWARE_ID					L"Gameport\\SideWinderForceFeedbackPro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			6
#define	GAME_PACKET_BUTTONS		(9+1)
#define	GAME_PACKET_AXIS			4

#define	GAME_B0_B7_BYTE			0					// Packet[0] bits
#define	GAME_B0_B7_BITS			0xff

#define	GAME_B8_BYTE				1					// Packet[1] bits
#define	GAME_B8_BITS				0x01
#define	GAME_X0_X6_BYTE			1
#define	GAME_X0_X6_BITS			0xfe

#define	GAME_X7_X9_BYTE			2					// Packet[2] bits
#define	GAME_X7_X9_BITS			0x07
#define	GAME_Y0_Y4_BYTE			2
#define	GAME_Y0_Y4_BITS			0xf8

#define	GAME_Y5_Y9_BYTE			3					// Packet[3] bits
#define	GAME_Y5_Y9_BITS			0x1f
#define	GAME_T0_T2_BYTE			3
#define	GAME_T0_T2_BITS			0xe0

#define	GAME_T3_T6_BYTE			4					// Packet[4] bits
#define	GAME_T3_T6_BITS			0x0f
#define	GAME_R0_R3_BYTE			4
#define	GAME_R0_R3_BITS			0xf0

#define	GAME_R4_R5_BYTE			5					// Packet[5] bits
#define	GAME_R4_R5_BITS			0x3
#define	GAME_H0_H3_BYTE			5
#define	GAME_H0_H3_BITS			0x3c
#define	GAME_ERR_BYTE				5
#define	GAME_ERR_BITS				0x40
#define	GAME_PPO_BYTE				5
#define	GAME_PPO_BITS				0x80

#define	ENH_CLOCK_MIDPACKET		0x0400
#define	ENH_CLOCK_COMPLETE		0x8000

//
//	ID Constants
//

#define	GAME_PRODUCT_ID			6
#define	GAME_ID_CLOCKS				8

//
//	Status Constants
//

#define	STATUS_CLOCK_COMPLETE	0x2000

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50
#define	STATUS_START_TIMEOUT		500
#define	STATUS_LOWHIGH_TIMEOUT	75
#define	STATUS_HIGHLOW_TIMEOUT	150
#define	STATUS_GATE_TIMEOUT		3000

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0x3ff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0x7f
#define	EXTENTS_R_MIN				0
#define	EXTENTS_R_MAX				0x3f

//
//	Throttle Smoothing
//

#define THROTTLE_JITTER_TIMEOUT	100				// in milliseconds
#define THROTTLE_QUEUE_SIZE		4

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DFF_ID | Sidwinder Pro FF Id String
#pragma pack(1)
	ULONG		ProductId:16;			// @field Device identifier
	ULONG		Version:7;				// @field Firmware version
	ULONG		OddParity:1;			// @field Packet parity
	ULONG		Unused:8;				// @field Unused
#pragma pack()
}	SW3DFF_ID, *PSW3DFF_ID;

typedef	struct
{											// @struct SW3DFF_STATUS | Sidwinder Pro FF Status
#pragma pack(1)
	UCHAR		xVelocity;				// @field X axis velocity
	UCHAR		yVelocity;				// @field Y axis velocity
	UCHAR		xAccel;					// @field X axis acceleration
	UCHAR		yAccel;					// @field Y axis acceleration
	USHORT	Status;					// @field Status word (bit fields)
#pragma pack()
}	SW3DFF_STATUS, *PSW3DFF_STATUS;

typedef struct
{											// @struct THROTTLE_QUEUE | Sidwinder Pro FF Throttle
   ULONG		dwZ;						// @field Z axis position
   ULONG		TimeStamp;				// @field timestamp for entry
}	THROTTLE_QUEUE, *PTHROTTLE_QUEUE;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DFF_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DFF_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DFF_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DFF_GetId (PPACKETINFO IdPacket);

static	BOOLEAN	SW3DFF_ReadStatus (PPACKETINFO StatusPacket);
static	BOOLEAN	SW3DFF_GetStatus (PPACKETINFO StatusPacket);

static	NTSTATUS	SW3DFF_ReadData (PPACKETINFO DataPacket);
static	VOID		SW3DFF_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SW3DFF_AdjustThrottle (PDEVICE_PACKET Report);

static	NTSTATUS	SW3DFF_ForceReset (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DFF_ForceId (PGAMEPORT PortInfo, PVOID IdString);
static	NTSTATUS	SW3DFF_ForceStatus (PGAMEPORT PortInfo, PVOID Status);
static	NTSTATUS	SW3DFF_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak);
static	NTSTATUS	SW3DFF_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck);
static	NTSTATUS	SW3DFF_ForceSync (PGAMEPORT PortInfo, PULONG Sync);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DFF_DriverEntry (VOID);
static	NTSTATUS	SW3DFF_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DFF_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DFF_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DFF_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);
static	NTSTATUS	SW3DFF_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DFF_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	
	//---------------------------------------------------------------------------
	// JOYINFOEX
	//---------------------------------------------------------------------------

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	HIDP_REPORT_ID_1,				MSGAME_INPUT_JOYINFOEX,

	//	id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (Y)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//	dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (127)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (127)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//	dwR
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_RUDDER,	//	USAGE (Rudder)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//	dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)
	
	//	dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,									//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//	dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//---------------------------------------------------------------------------
	// GetID
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETID,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x00,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwProductID
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x01,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwFWVersion
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x02,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetStatus
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSTATUS,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x03,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwXVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x04,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x05,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwXAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x06,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x07,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwEffect
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x08,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwDeviceStatus
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x09,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetAckNak
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETACKNAK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0A,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	//	GetNakAck
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETNAKACK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0B,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetSync
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSYNC,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0C,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//---------------------------------------------------------------------------
	// DoReset
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_RESET,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0D,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x03,									//	FEATURE (Cnst,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetVersion
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETVERSION,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0E,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	HIDP_MAIN_ENDCOLLECTION												//	END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{
							0,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};
//
//	Raw Id Buffer
//

static	SW3DFF_ID	RawId	=
							{
							0
							};

//
//	Raw Status Buffer
//

static	SW3DFF_STATUS	RawStatus =
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							STATUS_START_TIMEOUT,
							STATUS_HIGHLOW_TIMEOUT,
							STATUS_LOWHIGH_TIMEOUT,
							STATUS_GATE_TIMEOUT
							};

static	ULONG			StatusGateTimeout;

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							GAME_SPEED_66K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							GAME_SPEED_66K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Status Packet Info
//

static	PACKETINFO	StatusInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							GAME_SPEED_66K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawStatus),		// Size of raw status buffer
							&RawStatus					// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DFF_DriverEntry,		// DriverEntry
							SW3DFF_ConnectDevice,  	// ConnectDevice
							SW3DFF_StartDevice,	  	//	StartDevice
							SW3DFF_ReadReport,		// ReadReport
							SW3DFF_StopDevice,		// StopDevice
							SW3DFF_GetFeature			// GetFeature
							};

//
//	Last Valid Data
//
static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{
							GAME_B0_B7_BITS,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS|GAME_B8_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};

//
//	Rotation Filter Table
//

static	UCHAR			RotationFilter[EXTENTS_R_MAX+1] =
							{
						    0, 1, 3, 4, 5, 6, 8, 9,10,12,13,14,15,17,18,19,
						   20,22,23,24,26,27,28,29,31,32,32,32,32,32,32,32,
						   32,32,32,32,32,32,32,33,34,36,37,38,39,41,42,43,
						   44,46,47,48,49,50,52,53,54,55,57,58,59,60,62,63
							};

//
//	Throttle Queue
//

static	THROTTLE_QUEUE	ThrottleQueue [THROTTLE_QUEUE_SIZE] =
							{
   						{0x40,0},
   						{0x40,0},
   						{0x40,0},
   						{0x40,0}
							};

//
//	Reset Flag
//

static	BOOLEAN		ResetComplete = FALSE;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	JoltInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_FIRST,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DFF_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DFF: SW3DFF_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DFF: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DFF: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
	StatusInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.ClockDutyCycle = %ld\n", StatusInfo.ClockDutyCycle));
	StatusInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.StartTimeout = %ld\n", StatusInfo.StartTimeout));
	StatusInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.LowHighTimeout=%ld\n", StatusInfo.LowHighTimeout));
	StatusInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusInfo.HighLowTimeout=%ld\n", StatusInfo.HighLowTimeout));
	StatusGateTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusGateTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DFF: StatusGateTimeout=%ld\n", StatusGateTimeout));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SW3DFF_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (PORTIO_PulseAndWaitForIdleHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		{
		PORTIO_Write (PortInfo, 0);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "SW3DFF_ResetDevice - PulseAndWaitForHandshake failed\n"));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (!Result)
		MsGamePrint ((DBG_SEVERE, "SW3DFF_ResetDevice - PulseAndWaitForIdleHandshake failed\n"));

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_ReadId (PPACKETINFO IdPacket)
{
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DFF_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, IdInfo.ClockDutyCycle, 2))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; BL = # of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:

			mov	ah, al
			shr	al, 5
			shrd	esi, eax,3
			dec	ebx
			jne	ID_ClockCheck
			shr	esi, 8						; only 24 bits

		; ID_Success:

			mov	IdInfo.B4Transitions, edi
			mov	eax, ERROR_SUCCESS
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DFF_ReadId - SUCCEEDED, Data=%ld\n", Data));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@LowClockStart, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@HighClockStart, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@ClockFalling, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadId - TimeOut@ClockRising, Data=%ld,Clk=%ld\n", Data,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN		Result;
	PSW3DFF_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "SW3DFF_GetId enter\n"));

	IdPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SW3DFF_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSW3DFF_ID)IdPacket->Data;
		if ((Pnp->ProductId != GAME_PRODUCT_ID) || !DEVICE_IsOddParity (Pnp, sizeof(SW3DFF_ID)))
			{
			MsGamePrint ((DBG_SEVERE, "SW3DFF_GetId - Id did not match or parity error\n"));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ReadData (PPACKETINFO DataPacket)
{
	LONG			Result;
	LONG			Clks		= 1L;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo					; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.
			
			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 16
			mov	word ptr [esi+4], di

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockLow

			push	DataInfo.ClockDutyCycle
			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_IsClockActive

			or  	al, al
			mov	eax, ERROR_SUCCESS
			je		Enh_Complete

			mov	eax, ERROR_EXTRACLOCKS		; probably gamepads

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->TimeStamp	=	TIMER_GetTickCount ();
	DataPacket->LastError	=	Result;
	DataPacket->Transaction	=	MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_EXTRACLOCKS:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadData - Extra Clocks, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (DataPacket);

	if (Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DFF_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X7_X9_BYTE] & GAME_X7_X9_BITS;
	Report->dwX <<= 7;
	Report->dwX  |= (Data[GAME_X0_X6_BYTE] & GAME_X0_X6_BITS) >> 1;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y5_Y9_BYTE] & GAME_Y5_Y9_BITS;
	Report->dwY <<= 5;
	Report->dwY  |= (Data[GAME_Y0_Y4_BYTE] & GAME_Y0_Y4_BITS) >> 3;

	//
	//	Process R Axis
	//

	Report->dwR   = Data[GAME_R4_R5_BYTE] & GAME_R4_R5_BITS;
	Report->dwR <<= 4;
	Report->dwR  |= (Data[GAME_R0_R3_BYTE] & GAME_R0_R3_BITS) >> 4;
	// Rotation filter
	Report->dwR = RotationFilter[Report->dwR];

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T3_T6_BYTE] & GAME_T3_T6_BITS;
	Report->dwZ <<= 3;
	Report->dwZ  |= (Data[GAME_T0_T2_BYTE] & GAME_T0_T2_BITS) >> 5;

	//
	//	Process Buttons
	//

	B1 = ~Data[GAME_B0_B7_BYTE] & GAME_B0_B7_BITS;
	B2 = ~Data[GAME_B8_BYTE] & GAME_B8_BITS;
	B2 <<= 9;	// Move button nine to ten (shift key)
	Report->dwButtons = (B2 | B1) & ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV = POV_Values[(Data[GAME_H0_H3_BYTE] & GAME_H0_H3_BITS)>>2];
}

//---------------------------------------------------------------------------
// @func		Filters throttle packet information
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DFF_AdjustThrottle (PDEVICE_PACKET Report)
{
   ULONG	i;
   ULONG	TimeStamp;
   ULONG	zTotal;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_AdjustThrottle enter\n"));

	zTotal		=	0;
   TimeStamp	=	TIMER_GetTickCount ();
	
	//
   // If current sample past que window then repopulate queue with current sample and time stamp
	//

	if ((ThrottleQueue[THROTTLE_QUEUE_SIZE-1].TimeStamp+THROTTLE_JITTER_TIMEOUT) < TimeStamp)
	   {
      for (i = 0; i < THROTTLE_QUEUE_SIZE; i++)
   	   {
         ThrottleQueue[i].dwZ		= Report->dwZ;
         ThrottleQueue[i].TimeStamp	= TimeStamp;
      	}
      return;
   	}

	//
   // Move the whole queue down by one
	//

   memcpy (ThrottleQueue, &ThrottleQueue[1], sizeof(THROTTLE_QUEUE)*(THROTTLE_QUEUE_SIZE-1));

	//
   // Place new que member into last position
	//

   ThrottleQueue[THROTTLE_QUEUE_SIZE-1].dwZ			= Report->dwZ;
   ThrottleQueue[THROTTLE_QUEUE_SIZE-1].TimeStamp	= TimeStamp;

	//
   // Now average all que positions
	//

   for (i = 0; i < THROTTLE_QUEUE_SIZE; i++)
      zTotal += ThrottleQueue[i].dwZ;

 	Report->dwZ = zTotal / THROTTLE_QUEUE_SIZE;
}

//---------------------------------------------------------------------------
// @func		Reads and validates device status
//	@parm		PPACKETINFO | StatusPacket | Status Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_GetStatus (PPACKETINFO StatusPacket)
{
	BOOLEAN			Result;
	PSW3DFF_STATUS	Status;

	MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus Enter\n"));

	StatusPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SW3DFF_ReadStatus (StatusPacket);

	if (Result)
		{
		Status = (PSW3DFF_STATUS)StatusPacket->Data;
		if (!DEVICE_IsOddParity (Status, sizeof(SW3DFF_STATUS)))
			{
			MsGamePrint ((DBG_SEVERE, "SW3DFF_GetStatus - Parity error\n"));
			Result = FALSE;
			}
		else
			{
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - X Velocity = %ld\n", (long)Status->xVelocity));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - Y Velocity = %ld\n", (long)Status->yVelocity));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - X Accel = %ld\n", 	 (long)Status->xAccel));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - Y Accel = %ld\n", 	 (long)Status->xAccel));
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetStatus - Status = 0x%X\n", 	 (long)Status->Status));
			}
		}

	if (!Result)
		StatusPacket->Failures++;

	if (PORTIO_IsClockActive (&StatusPacket->PortInfo, StatusInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads status packet from gameport
//	@parm		PPACKETINFO | StatusPacket| Status packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DFF_ReadStatus (PPACKETINFO StatusPacket)
{
	USHORT		Status[3];
	LONG			Clks		=	1L;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &StatusPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadStatus enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	StatusPacket->ClocksSampled = 0;
	StatusPacket->B4Transitions = 0;

	if (!PORTIO_WaitDataLow (PortInfo))
		goto ReadStatusExit;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, StatusInfo.ClockDutyCycle, 1))
		goto ReadStatusExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo					; load gameport adddress

			mov	esi, StatusInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, StatusInfo.StartTimeout

		Stat_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Stat_ClockStartState_1		; N: jump
			loop	Stat_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Stat_CollectData				; Y: jump
			loop	Stat_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Stat_ClockStartRise

		;Stat_ClockStartFall:

			mov	ecx, StatusInfo.HighLowTimeout

		Stat_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Stat_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartRise:

			mov	ecx, StatusInfo.LowHighTimeout

		Stat_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Stat_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Stat_Complete					; Time out error.

		Stat_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Stat_MidPacket					; Y: jump.
			test	ebx, STATUS_CLOCK_COMPLETE	; Q: is packet complete ?
			jnz	Stat_Success					; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Stat_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Stat_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Stat_CheckClkState

		Stat_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 22
			and	edi, 3ffh
			mov	word ptr [esi+4], di

			mov	ax, [esi]
			mov	Status, ax
			mov	ax, [esi+2]
			mov	Status+2, ax
			mov	ax, [esi+4]
			mov	Status+4, ax
			mov	eax, ERROR_SUCCESS

		Stat_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadStatusExit:
	//	----------------

	for (StatusPacket->ClocksSampled = 0; Clks >> (StatusPacket->ClocksSampled+1); StatusPacket->ClocksSampled++);
	StatusPacket->TimeStamp 	=	TIMER_GetTickCount ();
	StatusPacket->LastError 	=	Result;
	StatusPacket->LastError		=	Result;
	StatusPacket->Transaction	=	MSGAME_TRANSACT_STATUS;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadStatus - SUCCEEDED, Data=0x%X%X%X,Clk=%ld\n", (ULONG)Status[2],(ULONG)Status[1],(ULONG)Status[0],Clks));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@LowClockStart\n"));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@HighClockStart\n"));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadStatus - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;
		}
	#endif

	MSGAME_PostTransaction (StatusPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Force feedback reset service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceReset (PGAMEPORT PortInfo)
{
	if (!SW3DFF_ResetDevice (PortInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Id | Id output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceId (PGAMEPORT PortInfo, PVOID Id)
{
	PPRODUCT_ID pProduct	= (PPRODUCT_ID)Id;
	PSW3DFF_ID	pSw3dff	= (PSW3DFF_ID)&RawId;

	if (!SW3DFF_ReadId (&IdInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pProduct->cBytes			=	sizeof (PRODUCT_ID);
	pProduct->dwProductID	=	pSw3dff->ProductId;
	pProduct->dwFWVersion	=	pSw3dff->Version;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Status | Status output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceStatus (PGAMEPORT PortInfo, PVOID Status)
{
	PJOYCHANNELSTATUS	pChannel	= (PJOYCHANNELSTATUS)Status;
	PSW3DFF_STATUS		pSw3dff	= (PSW3DFF_STATUS)&RawStatus;

	if (!SW3DFF_ReadStatus (&StatusInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pChannel->cBytes				=	sizeof (JOYCHANNELSTATUS);
	pChannel->dwXVel				=	pSw3dff->xVelocity;
	pChannel->dwYVel				=	pSw3dff->yVelocity;
	pChannel->dwXAccel			=	pSw3dff->xAccel;
	pChannel->dwYAccel			=	pSw3dff->yAccel;
	pChannel->dwEffect			=	0;
	pChannel->dwDeviceStatus	=	pSw3dff->Status & 0x3ff;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback acknak service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | AckNak | AckNak
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak)
{
	if (!PORTIO_GetAckNak (PortInfo, StatusGateTimeout, (PUCHAR)AckNak))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback NakAck service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck)
{
	if (!PORTIO_GetNakAck (PortInfo, StatusGateTimeout, (PUCHAR)NakAck))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback sync service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ForceSync (PGAMEPORT PortInfo, PULONG Sync)
{
	*Sync = PORTIO_Read (PortInfo);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DFF: SW3DFF_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DFF_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = StatusInfo.PortInfo = *PortInfo; 

	//
	//	Convert registry timing values
	//

  	SW3DFF_Calibrate (PortInfo);

	//
	// SW3DFF Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 2. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DFF: DeviceConnectProc getting ID string\n"));
		if (!SW3DFF_GetId (&IdInfo))
			continue;

		//
		// 3. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		
		//
		// 4. Reset device (tri-state midi so we don't get unintended forces)
		//

		if (!ResetComplete)
			{
			MsGamePrint ((DBG_CONTROL, "SW3DFF_ConnectDevice - resetting device\n"));
			if (!SW3DFF_ResetDevice (&DataInfo.PortInfo))
				continue;
			}

		//
		// 5. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 6. Mark device found and return
		//

		JoltInfo.NumDevices	=	1;
		ResetComplete			=	TRUE;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	JoltInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DFF_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "SW3DFF_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DFF_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && DEVICE_IsOddParity (DataInfo.Data, GAME_PACKET_SIZE))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DFF_ReadReport - Invalid packet or parity error\n"));
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DFF_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DFF_ProcessData (ValidData, Report);

	//
	//	Adjust Throttle jitter
	//

	if (NT_SUCCESS(ntStatus))
		SW3DFF_AdjustThrottle (Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DFF_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DFF_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Get Feature requests
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		HID_REPORT_ID | ReportId | HID Feature Id
//	@parm		PVOID | ReportBuffer | Output buffer pointer
//	@parm		ULONG | ReportSize | Output buffer size
//	@parm		PULONG | Returned | Bytes returned pointer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DFF_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned)
{
	NTSTATUS	ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature enter\n"));

	//
	//	Handle feature codes
	//

	switch (ReportId)
		{
		case	MSGAME_INPUT_JOYINFOEX:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature JoyInfoEx\n"));
			if (ReportSize < sizeof (DEVICE_PACKET)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature JoyInfoEx Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ReadReport (PortInfo, ReportBuffer);
				*Returned += sizeof (DEVICE_PACKET);
				}
			break;

		case	MSGAME_FEATURE_GETID:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetId\n"));
			if (ReportSize < sizeof(PRODUCT_ID)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetId Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceId (PortInfo, ReportBuffer);
				*Returned += sizeof(PRODUCT_ID);
				}
			break;

		case	MSGAME_FEATURE_GETSTATUS:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetStatus\n"));
			if	(ReportSize < sizeof(JOYCHANNELSTATUS)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetStatus Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceStatus (PortInfo, ReportBuffer);
				*Returned += sizeof(JOYCHANNELSTATUS);
				}
			break;

		case	MSGAME_FEATURE_GETACKNAK:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetAckNak\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetAckNak Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceAckNak (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETNAKACK:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetNakAck\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetNakAck Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceNakAck (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETSYNC:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetSync\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetSync Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceSync (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_RESET:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature Reset\n"));
			if	(ReportSize < sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature Reset Bad Buffer Size = %lu\n", ReportSize));
				}
			else
				{
				ntStatus = SW3DFF_ForceReset (PortInfo);
				}
			break;

		case	MSGAME_FEATURE_GETVERSION:
			MsGamePrint ((DBG_INFORM, "SW3DFF_GetFeature GetVersion\n"));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature GetVersion Bad Buffer Size = %lu\n", ReportSize));
				}
         else
	         {
            *((PULONG)ReportBuffer)	= 0x20000;
			   *Returned += sizeof(ULONG);
   	      }
         break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DFF_GetFeature Invalid ReportId = %lu\n", ReportId));
			ntStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}

	return (ntStatus);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\portio.h ===
//**************************************************************************
//
//		PORTIO.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	PORTIO.H | Global includes and definitions for port I/O functions
//**************************************************************************

#ifndef	__PORTIO_H__
#define	__PORTIO_H__

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

NTSTATUS
PORTIO_DriverEntry (VOID);

VOID
PORTIO_MaskInterrupts (VOID);

VOID
PORTIO_UnMaskInterrupts (VOID);

BOOLEAN
PORTIO_AcquirePort (
	IN		PGAMEPORT 	PortInfo
	);

VOID
PORTIO_ReleasePort (
	IN		PGAMEPORT 	PortInfo
	);

VOID
PORTIO_CalibrateTimeOut (
	IN		PGAMEPORT	PortInfo
	);

UCHAR
PORTIO_Read (
	IN		PGAMEPORT 	PortInfo
	);

VOID
PORTIO_Write (
	IN		PGAMEPORT	PortInfo,
	IN		UCHAR 		Value
	);

BOOLEAN
PORTIO_GetAckNak (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			Timeout,
	OUT	PUCHAR		AckNak
	);

BOOLEAN
PORTIO_GetNakAck (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			Timeout,
	OUT	PUCHAR		NakAck
	);

BOOLEAN
PORTIO_IsClockActive (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_WaitClockInActive (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_WaitClockLow (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitClockHigh (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitDataLow (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitXA_HighLow (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitForIdle (
	IN		PGAMEPORT	PortInfo
	);

BOOLEAN
PORTIO_WaitForStatusGate (
	IN		PGAMEPORT	PortInfo,
	IN		UCHAR			Mask,
	IN		ULONG			Timeout
	);

BOOLEAN
PORTIO_WaitForHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_WaitForIdleHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle
	);

BOOLEAN
PORTIO_PulseAndWaitForHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle,
	IN		ULONG			Pulses
	);

BOOLEAN
PORTIO_PulseAndWaitForIdleHandshake (
	IN		PGAMEPORT	PortInfo,
	IN		ULONG			DutyCycle,
	IN		ULONG			Pulses
	);

//===========================================================================
//			End
//===========================================================================
#endif	__PORTIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\swgampad.c ===
//**************************************************************************
//
//		SWGAMPAD.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SWGAMPAD.C | Gameport mini-driver for GamePads
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SWGAMPAD"
#define	DEVICE_PID					0x0003
#define	HARDWARE_ID					L"Gameport\\SideWindergamepad\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			32
#define	GAME_PACKET_BUTTONS		10

#define	GAME_Y_UP_BIT				0x01
#define	GAME_Y_DOWN_BIT			0x02
#define	GAME_Y_BITS					(GAME_Y_UP_BIT|GAME_Y_DOWN_BIT)
#define	GAME_X_LEFT_BIT			0x04
#define	GAME_X_RIGHT_BIT			0x08
#define	GAME_X_BITS					(GAME_X_LEFT_BIT|GAME_X_RIGHT_BIT)
#define	GAME_BUTTON_BITS			0x3ff0

//
//	Id Definitions
//

#define	GAME_ID_STRING				"H0003"

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	 75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	PACKET_INTERRUPT_DELAY	 45
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		 75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		 50

#define	MAX_STD_SCLKS				150

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				1
#define	EXTENTS_X_MID				0x80
#define	EXTENTS_X_MAX				0xff
#define	EXTENTS_Y_MIN				1
#define	EXTENTS_Y_MID				0x80
#define	EXTENTS_Y_MAX				0xff

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SWGAMPAD_ID | GamePad Id String
#pragma pack(1)
	UCHAR		OpenParen;				// @field Open parentheses
	UCHAR		EisaId[5];				// @field Eisa bus Id
	USHORT	Version[3];				// @field Firmware version
	UCHAR		CloseParen;				// @field Close parentheses
	UCHAR		Reserved[22];			// @field Reserved
#pragma pack()
}	SWGAMPAD_ID, *PSWGAMPAD_ID;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SWGAMPAD_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SWGAMPAD_GoAnalog (PPACKETINFO Packet1, PPACKETINFO Packet2);

static	BOOLEAN	SWGAMPAD_ReadId (PPACKETINFO DataPacket, PPACKETINFO IdPacket);
static	BOOLEAN	SWGAMPAD_GetId (PPACKETINFO IdPacket);

static	NTSTATUS	SWGAMPAD_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SWGAMPAD_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SWGAMPAD_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SWGAMPAD_ValidateData (PPACKETINFO DataPacket);
static	VOID		SWGAMPAD_ProcessData (ULONG UnitId, USHORT Data[], PDEVICE_PACKET Report);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SWGAMPAD_DriverEntry (VOID);
static	NTSTATUS	SWGAMPAD_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWGAMPAD_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWGAMPAD_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SWGAMPAD_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SWGAMPAD_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,		//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,	//	COLLECTION (Application)
	
	//id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,	//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x01,								//	LOGICAL_MINIMUM (1)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x00, 0x00, 0x00,		//	LOGICAL_MAXIMUM (255)
	HIDP_GLOBAL_PHY_MIN_1,		0x01,								//	PHYSICAL_MINIMUM (1)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x00, 0x00, 0x00,		//	PHYSICAL_MAXIMUM (255)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,						//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,			//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,								//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,			//	USAGE (Y)
	HIDP_MAIN_INPUT_1,			0x02,								//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,										//	END_COLLECTION
	
	//dwZ
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//dwR
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//dwPOV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (32)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)

	//dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,		//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,								//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,								//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,								//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,								//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,								//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,								//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,						//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,								//	REPORT_SIZE (1)
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,								//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,								//	INPUT (Data,Var,Abs)

	//dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,								//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,								//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,								//	INPUT (Cnst,Ary,Abs)
	
	//END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION											//	END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	USHORT		RawData[GAME_PACKET_SIZE/sizeof(USHORT)] =
							{
							0
							};
//
//	Raw Id Buffer
//

static	SWGAMPAD_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							PACKET_INTERRUPT_DELAY,
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							FLAG_WAIT_FOR_CLOCK,		// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							FLAG_START_CLOCK_LOW,	// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SWGAMPAD_DriverEntry,	// DriverEntry
							SWGAMPAD_ConnectDevice,	// ConnectDevice
							SWGAMPAD_StartDevice,	//	StartDevice
							SWGAMPAD_ReadReport,		// ReadReport
							SWGAMPAD_StopDevice,		// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//

static	USHORT		ValidData[GAME_PACKET_SIZE/sizeof(USHORT)] =
							{
							  GAME_BUTTON_BITS,
							  GAME_BUTTON_BITS,
							  GAME_BUTTON_BITS,
							  GAME_BUTTON_BITS
							};

//
//	Interrupt Flags
//

static	UCHAR			InterruptFlags = 0;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	GamePadInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWGAMPAD_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SWGAMPAD: SWGAMPAD_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
	DataInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: DataInfo.InterruptDelay = %ld\n", DataInfo.InterruptDelay));
	IdInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SWGAMPAD: IdInfo.InterruptDelay = %ld\n", IdInfo.InterruptDelay));
}

//---------------------------------------------------------------------------
// @func		Puts Gamepads into analog mode
//	@parm		PPACKETINFO | Packet1 | Data packet
//	@parm		PPACKETINFO | Packet2 | Id packet
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_GoAnalog (PPACKETINFO Packet1, PPACKETINFO Packet2)
{
	LONG			Result	= ERROR_SUCCESS;
	PGAMEPORT	PortInfo = &Packet1->PortInfo;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	InterruptFlags = INTERRUPT_AFTER_PACKET;
	Packet1->B4Transitions	= 0;
	Packet1->ClocksSampled	= 0;

	PORTIO_Write (PortInfo, 0);

	if (!(PORTIO_Read (PortInfo) & XA_BIT_MASK))
		{
		Result = ERROR_XA_TIMEOUT;
		}
	else
		{
		if (Packet1->Mode == IMODE_DIGITAL_ENH)
			SWGAMPAD_Read3Wide (Packet1);
		else SWGAMPAD_Read1Wide (Packet1);
		Packet2->B4Transitions	= 0;
		Packet2->ClocksSampled	= 0;
		if (Packet2->Mode == IMODE_DIGITAL_ENH)
			{
			SWGAMPAD_Read3Wide (Packet2);
			Result = Packet2->LastError;
			}
		else SWGAMPAD_Read1Wide (Packet2);
		}

	Packet1->B4Transitions	= 0;
	Packet1->ClocksSampled	= 0;
	Packet2->B4Transitions	= 0;
	Packet2->ClocksSampled	= 0;
	InterruptFlags				= 0;

	DataInfo.LastError		= Result;
	DataInfo.Transaction		= MSGAME_TRANSACT_GOANALOG;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (Result == ERROR_SUCCESS)
		DataInfo.Mode = IdInfo.Mode = IMODE_ANALOG;
	else MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ResetDevice (GoAnalog) Failed\n"));

	MSGAME_PostTransaction (&DataInfo);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | DataPacket | Data packet parameters
//	@parm		PPACKETINFO | IdPacket | ID packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_ReadId (PPACKETINFO DataPacket, PPACKETINFO IdPacket)
{
	LONG			Result	= ERROR_SUCCESS;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	InterruptFlags = INTERRUPT_AFTER_PACKET;
	DataPacket->B4Transitions	= 0;
	DataPacket->ClocksSampled	= 0;

	PORTIO_Write (PortInfo, 0);

	if (!(PORTIO_Read (PortInfo) & XA_BIT_MASK))
		{
		Result = ERROR_XA_TIMEOUT;
		}
	else
		{
		if (DataPacket->Mode == IMODE_DIGITAL_ENH)
			SWGAMPAD_Read3Wide (DataPacket);
		else SWGAMPAD_Read1Wide (DataPacket);
		InterruptFlags = 0;
		IdPacket->B4Transitions	= 0;
		IdPacket->ClocksSampled	= 0;
		SWGAMPAD_Read1Wide (IdPacket);
		Result = IdPacket->LastError;
		}

	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (Result != ERROR_SUCCESS)
		MsGamePrint ((DBG_SEVERE, "SWGAMPAD_GetId Failed\n"));

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_GetId enter\n"));

	IdPacket->Attempts++;

	if (SWGAMPAD_ReadId (&DataInfo, IdPacket))
		{
		ULONG				i;
		PUSHORT			p;
		PSWGAMPAD_ID	pId;
		//
		//	Remove parity bit and convert to words
		//
		p = IdPacket->Data;
		for (i = 0; i < 5; i++, p++)
			*p = ((*p<<1) & 0x7f00) | (*p & 0x7f);
		//
		//	Check Id String
		//
		pId = (PSWGAMPAD_ID)IdPacket->Data;
      if (!strncmp (pId->EisaId, GAME_ID_STRING, strlen(GAME_ID_STRING)))
			{
			if (IdPacket->B4Transitions > 10)
				{
				DataInfo.Mode = IdInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				SWGAMPAD_GoAnalog (&DataInfo, &IdInfo);
				DataInfo.Mode = IdInfo.Mode = IMODE_DIGITAL_STD;
				}
			Result = TRUE;
			}
		else MsGamePrint ((DBG_SEVERE, "SWGAMPAD_GetId - Id string did not match = 0x%X\n", (ULONG)(*(PULONG)&pId->EisaId)));
		}

	if (!Result)
		IdPacket->Failures++;

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

BOOLEAN	SWGAMPAD_Read1Wide (PPACKETINFO DataPacket)
{
	LONG	Result;

	// MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_Read1Wide enter\n"));

	__asm
		{
			push	edi
			push	esi
			push	ebp

			mov	edi, DataPacket
			mov	esi, (PPACKETINFO [edi]).Data
			lea	edx, (PPACKETINFO [edi]).PortInfo
			mov	ebx, 10000h
			xor	ebp, ebp
			xor	eax, eax

			test	(PPACKETINFO [edi]).Acquisition, FLAG_START_CLOCK_LOW
			jnz	Std_StartClockLow

			; make sure clock is "high" before sampling clocks...

 			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Std_StartClockHigh:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: Start of Packet ?
			jz		Std_StartHighToLow				; Y: jump
			dec	ecx
			jnz	Std_StartClockHigh				; else keep looping

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketDone							; Time out error.

		Std_StartHighToLow:

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Std_StartHighToLow_1:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: clock = 0
			jz		Std_LowToHigh						; Y: jump.
			dec	ecx
			jnz	Std_StartHighToLow_1				; else see if we timed out

			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketDone							; Time out error.

		Std_StartClockLow:

			; wait for clock to transition to "high" (sample immediately)

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Std_StartClockLow_1:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK 				; Q: Clock went high ?
			jnz	CollectData							; Y: jump (sample data)
			dec	ecx
			jnz	Std_StartClockLow_1				; else keep looping

			mov	eax, ERROR_CLOCKRISING
			jmp	PacketDone							; Time out error.

		Std_CheckClkState:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_LowToHigh

		;Std_HighToLow:

			mov	ecx, (PPACKETINFO [edi]).HighLowTimeout

		Std_HighToLow_1:

			test	al, CLOCK_BIT_MASK				; Q: clock = 0
			jz		Std_LowToHigh						; Y: jump.

			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Std_HighToLow_1					; else see if we timed out

			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketDone							; Time out error.

		Std_LowToHigh:

			mov	ecx, (PPACKETINFO [edi]).LowHighTimeout

		Std_LowToHigh_1:

			test	al, CLOCK_BIT_MASK				; Q: clock high ?
			jnz	CollectData							; Y: jump. (get data)
			
			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx									; else see if we timed out
			jnz	Std_LowToHigh_1
			jmp	Std_TestInterrupt

		CollectData:

			inc	ebp
			cmp	ebp, MAX_STD_SCLKS
			jg		Std_BufferOverFlow
			xor	ah, al
			test	ah, DATA2_BIT_MASK				; Q: Data 2 is toggled ?
			jz		CollectData_1						; N: jump.
			inc	(PPACKETINFO [edi]).B4Transitions	; Y: increment Data 2 count.

		CollectData_1:
		
			mov	ah, al
			shr	al, 6									; put data into carry
			rcr	bx, 1									; and then in data counter
			add	ebx, 10000h							; inc mini packet clk counter
			test	ebx, 100000h						; Q: done mini packet ?
			jz		Std_CheckClkState					; N: jump.
			shr	bx, 1									; right align
			mov	word ptr [esi], bx				; move mini packet into buffer
			add	esi, 2								; advance data pointer
			mov	ebx, 10000h							; init mini-packet counter
			jmp	Std_CheckClkState					; go look for more clocks.

		Std_TestInterrupt:

			test	InterruptFlags, INTERRUPT_AFTER_PACKET; Q: Interrupt packet ?
			jnz	Std_IntPacket						; Y: jump.

			mov	eax, ERROR_SUCCESS
			jmp	PacketDone

		Std_IntPacket:

			mov	ecx, 700

		Std_IntPacket_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, INTXA_BIT_MASK
			jz		Std_IntPacket_2
			loop	Std_IntPacket_1
			mov	eax, ERROR_XA_TIMEOUT
			jmp	PacketDone

		Std_IntPacket_2:
		
			cmp	ecx, 700
			je		Std_IntOut
			mov	ecx, (PPACKETINFO [edi]).InterruptDelay

		Std_IntPacket_3:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, al
			xchg	al, ah
			dec	ecx
			jnz	Std_IntPacket_3

		Std_IntOut:

			push	0										; write byte to gameport
			push	edx
			call	PORTIO_Write

			mov	eax, ERROR_SUCCESS
			jmp	PacketDone

		Std_BufferOverFlow:

			mov	eax, ERROR_CLOCKOVERFLOW

		PacketDone:

			mov	(PPACKETINFO [edi]).ClocksSampled, ebp

			pop	ebp
			pop	esi
			pop	edi

			mov	Result, eax
		}

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Result;

	// MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_Read3Wide enter\n"));

	__asm
		{
			push	edi
			push	esi
			push	ebp

			mov	edi, DataPacket
			mov	esi, (PPACKETINFO [edi]).Data
			lea	edx, (PPACKETINFO [edi]).PortInfo

			xor	eax, eax
			xor	ebx, ebx
			xor	ebp, ebp

		;StartEnhancedMode:

			test	(PPACKETINFO [edi]).Acquisition, FLAG_START_CLOCK_LOW
			jnz	Enh_LowToHigh

			; make sure clock is "high" before sampling clocks...

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		StartEnhancedMode_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: Start of Packet ?
			jnz	Enh_StartHighToLow				; Y: jump
			dec	ecx
			jnz	StartEnhancedMode_1				; else keep looping

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_PacketDone						; Time out error.

		Enh_StartHighToLow:

			mov	ecx, (PPACKETINFO [edi]).StartTimeout

		Enh_StartHighToLow_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: clock = 0
			jz		Enh_LowToHigh						; Y: jump.
			dec	ecx
			jnz	Enh_StartHighToLow_1				; else see if we timed out

			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_PacketDone						; Time out error.

		;Enh_StartClockLow:

			; wait for clock to transition to "high" (sample immediately)

			mov		ecx, (PPACKETINFO [edi]).StartTimeout

		Enh_StartClockLow_1:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK				; Q: Clock went high ?
			jnz	Enh_CollectData					; Y: jump (sample data)
			dec	ecx
			jnz	Enh_StartClockLow_1				; else keep looping

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_PacketDone						; Time out error.

		Enh_CheckClkState:

			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_LowToHigh

			; Wait for clock to transition from high to low.

		;Enh_HighToLow:

			mov	ecx, (PPACKETINFO [edi]).HighLowTimeout

		Enh_HighToLow_1:

			test	al, CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_LowToHigh						; Y: jump.

			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Enh_HighToLow_1					; if !Timeout continue looping.

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_PacketDone						; Time out error.

			; Wait for clock to transition from low to high.

		Enh_LowToHigh:

			mov	ecx, (PPACKETINFO [edi]).LowHighTimeout

		Enh_LowToHigh_1:
		
			test	al, CLOCK_BIT_MASK				; Q: Clock = 1 ?
			jnz	Enh_CollectData					; Y: jump.

			push	edx									; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Enh_LowToHigh_1					; else continue looping.
			jmp	Enh_TestInterrupt

		Enh_CollectData:

			inc	ebp									; inc. total clocks sampled

			test	ebp, 40h
			jnz	Enh_BufferOverflow

			shr	al, 5									; move data to lower 3 bits
			shrd	ebx, eax, 3							; shift data into ebx.
			add	ebp, 10000h							; inc hiword of ebp
			mov	eax, ebp
			shr	eax, 16								; set ax = hiword of ebp
			cmp	al, 5									; Q: mini-packet done ?
			jne	Enh_CheckClkState					; N: jump.
			shr	ebx, 17
			mov	word ptr [esi],bx
			add	esi, 2
			and	ebp, 0ffffh							; zero out hiword of ebp
			jmp	Enh_CheckClkState


		Enh_TestInterrupt:

			test	InterruptFlags, INTERRUPT_AFTER_PACKET ; Q: Interrupt packet ?
			jz		Enh_PacketOK						; N: jump.

			; Wait for XA line to be cleared before we can fire interrupt.

			mov	ecx, 700

		Enh_Interrupt:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, INTXA_BIT_MASK
			jz		Enh_Interrupt_1
			loop	Enh_Interrupt

			mov	eax, ERROR_XA_TIMEOUT
			jmp	Enh_PacketDone

		Enh_Interrupt_1:
		
			mov		ecx, (PPACKETINFO [edi]).InterruptDelay

		Enh_Interrupt_2:
		
			push	edx									; read byte from gameport
			call	PORTIO_Read

			test	al, al
			dec	ecx
			jnz	Enh_Interrupt_2

			push	0										; write byte to gameport
			push	edx
			call	PORTIO_Write

		Enh_PacketOK:

			and	ebp, 0ffffh
			mov	(PPACKETINFO [edi]).ClocksSampled, ebp
			mov	eax, ERROR_SUCCESS
			jmp	Enh_PacketDone

		Enh_BufferOverflow:

			mov	eax, ERROR_CLOCKOVERFLOW

		Enh_PacketDone:

			pop	ebp
			pop	esi
			pop	edi

			mov	Result, eax
		}

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled	= 0;
	DataPacket->B4Transitions	= 0;
	InterruptFlags					= 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			PORTIO_Write (PortInfo, 0);
			Result = SWGAMPAD_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			PORTIO_Write (PortInfo, 0);
			Result = SWGAMPAD_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWGAMPAD_ValidateData (PPACKETINFO DataPacket)
{
	BOOLEAN	Result	=	FALSE;
	PVOID		Data		=	DataPacket->Data;
	ULONG		Packets	=	DataPacket->NumPackets;
	ULONG		Clocks	=	DataPacket->ClocksSampled;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ValidateData enter\n"));

	if ((Clocks % 5) || (Clocks > 20))
		{
		MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ValidateData - wrong number of clocks = %lu\n", Clocks));
		return (Result);
		}

	__asm
		{
			mov	esi, Data
			mov	ecx, Packets

		ValidateLoop:

			mov	ax, [esi]
			xor	al, ah
			jpo	ValidateDone
			add	esi, 2
			loop	ValidateLoop
			mov	Result, TRUE

		ValidateDone:
		}

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		ULONG | UnitId | UnitId for this device
//	@parm		USHORT[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWGAMPAD_ProcessData (ULONG UnitId, USHORT Data[], PDEVICE_PACKET Report)
{
	ULONG	B1;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	switch (Data[UnitId] & GAME_X_BITS)
		{
		case	GAME_X_LEFT_BIT:
			Report->dwX = EXTENTS_X_MIN;
			break;

		case	GAME_X_RIGHT_BIT:
			Report->dwX = EXTENTS_X_MAX;
			break;

		default:
			Report->dwX = EXTENTS_X_MID;
			break;
		}

	//
	//	Process Y Axis
	//

	switch (Data[UnitId] & GAME_Y_BITS)
		{
		case	GAME_Y_DOWN_BIT:
			Report->dwY = EXTENTS_Y_MIN;
			break;

		case	GAME_Y_UP_BIT:
			Report->dwY = EXTENTS_Y_MAX;
			break;

		default:
			Report->dwY = EXTENTS_Y_MID;
			break;
		}

	//
	//	Process Buttons
	//

	Report->dwButtons  = ~((Data[UnitId] & GAME_BUTTON_BITS) >> 4);
	Report->dwButtons &=  ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SWGAMPAD: SWGAMPAD_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SWGAMPAD_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo;

	//
	//	Convert registry timing values
	//

  	SWGAMPAD_Calibrate (PortInfo);

	//
	// Reset to "known" state
	//

	MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ConnectDevice - resetting device\n"));
	if (!SWGAMPAD_GoAnalog (&DataInfo, &IdInfo))
		MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ConnectDevice - unable to go Analog\n"));
	else do
		{
		//
		// SWGAMPAD Connection method (try these steps twice)
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ConnectDevice - getting ID string\n"));
		if (!SWGAMPAD_GetId (&IdInfo))
			continue;

		//
  	   // Mark device found and return
		//

		if (!GamePadInfo.NumDevices)
			GamePadInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	GamePadInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SWGAMPAD_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
	{
		MsGamePrint ((DBG_INFORM, "SWGAMPAD_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SWGAMPAD_ReadData (&DataInfo);
	if (!NT_SUCCESS(ntStatus))
		{
		if (ntStatus != STATUS_DEVICE_BUSY)
			{
			DataInfo.Failures++;
			ntStatus = STATUS_DEVICE_NOT_CONNECTED;
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ReadReport - invalid packet\n"));
			}
		else
			{
			MsGamePrint ((DBG_CONTROL, "SWGAMPAD_ReadReport - Port busy or in use\n"));
			}
		}
	else
		{
		if (DataInfo.Mode == IMODE_DIGITAL_ENH)
			DataInfo.NumPackets = DataInfo.ClocksSampled / 5;
		else DataInfo.NumPackets = DataInfo.ClocksSampled / 15;
		if (DataInfo.NumPackets == 0)
			DataInfo.NumPackets = 1;
		else if (DataInfo.NumPackets > 4)
			DataInfo.NumPackets = 4;
 		if (!SWGAMPAD_ValidateData (&DataInfo))
			{
			DataInfo.Failures++;
			ntStatus = STATUS_DEVICE_NOT_CONNECTED;
			MsGamePrint ((DBG_SEVERE, "SWGAMPAD_ReadReport - invalid packet\n"));
			}
		else memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
 		}

	//	---------------
		ReadReportExit:
	//	---------------

	if (NT_SUCCESS(ntStatus))
		GamePadInfo.NumDevices = DataInfo.NumPackets;

	if (GET_DEVICE_UNIT (PortInfo) < GamePadInfo.NumDevices)
		SWGAMPAD_ProcessData (GET_DEVICE_UNIT (PortInfo), ValidData, Report);
	else ntStatus = STATUS_DEVICE_NOT_CONNECTED;

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SWGAMPAD_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWGAMPAD_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SWGAMPAD_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\pnp.c ===
//**************************************************************************
//
//		PNP.C -- Xena Gaming Project
//
//		This module contains PnP Start, Stop, Remove, Power dispatch routines
//		and the IRP cancel routine.
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	PNP.C | Supports PnP Start, Stop, Remove, Power dispatch routines
//		and the IRP cancel routine.
//**************************************************************************

#include	<msgame.h>

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (PAGE, MSGAME_Power)
#pragma	alloc_text (PAGE, MSGAME_PnP)
#pragma	alloc_text (PAGE, MSGAME_StopDevice)
#pragma	alloc_text (PAGE, MSGAME_GetResources)
#endif

//---------------------------------------------------------------------------
//		Private Data
//---------------------------------------------------------------------------

static	PVOID		CurrentGameContext	=	NULL;

//---------------------------------------------------------------------------
// @func		The plug and play dispatch routines.
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	LONG						i;
	NTSTATUS					ntStatus;
	PDEVICE_EXTENSION		pDevExt;
	PIO_STACK_LOCATION	pIrpStack;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_PnP Enter\n", MSGAME_NAME, MSGAME_NAME));

	pDevExt	 = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);
	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	InterlockedIncrement (&pDevExt->IrpCount);

	if (pDevExt->Removed)
		{
		//
		// Someone sent us another plug and play IRP after removed
		//

		MsGamePrint ((DBG_SEVERE, "%s: PnP Irp after device removed\n", MSGAME_NAME));
		ASSERT (FALSE);

		if (!InterlockedDecrement (&pDevExt->IrpCount))
			KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		return (STATUS_DELETE_PENDING);
		}

	switch (pIrpStack->MinorFunction)
		{
		case IRP_MN_START_DEVICE:
			//
			// We cannot touch the device (send it any non-Pnp Irps) until a
			// start device has been passed down to the lower drivers.
			//

			IoCopyCurrentIrpStackLocationToNext (pIrp);
			IoSetCompletionRoutine (pIrp, MSGAME_PnPComplete, pDevExt, TRUE, TRUE, TRUE);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			if (ntStatus == STATUS_PENDING)
				KeWaitForSingleObject (
					&pDevExt->StartEvent,
					Executive, 	// Waiting for reason of a driver
					KernelMode, // Waiting in kernel mode
					FALSE,		// No allert
					NULL);		// No timeout

			if (NT_SUCCESS (ntStatus))
				{
				//
				// As we are now back from our start device we can do work.
				//
				ntStatus = MSGAME_StartDevice (pDevExt, pIrp);
				}

			//
			//	Return Status
			//

			pIrp->IoStatus.Information = 0;
			pIrp->IoStatus.Status = ntStatus;
			IoCompleteRequest (pIrp, IO_NO_INCREMENT);
			break;

		case IRP_MN_STOP_DEVICE:
			//
			// After the start IRP has been sent to the lower driver object, the bus may
			// NOT send any more IRPS down ``touch'' until another START has occured.
			// Whatever access is required must be done before Irp passed on.
			//

			MSGAME_StopDevice (pDevExt, TRUE);

			//
			// We don't need a completion routine so fire and forget.
			// Set the current stack location to the next stack location and
			// call the next device object.
			//

			IoSkipCurrentIrpStackLocation (pIrp);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			break;

		case IRP_MN_SURPRISE_REMOVAL:
			//
			//	We have been unexpectedly removed by the user. Stop the device,
			//	set status to SUCCESS and call next stack location with this IRP.
			//

			if (!pDevExt->Surprised && pDevExt->Started)
				MSGAME_StopDevice (pDevExt, TRUE);

			pDevExt->Surprised = TRUE;

			//
			// We don't want a completion routine so fire and forget.
			// Set the current stack location to the next location and
			// call the next device after setting status to success.
			//

			pIrp->IoStatus.Information	= 0;
			pIrp->IoStatus.Status		= STATUS_SUCCESS;
			IoSkipCurrentIrpStackLocation (pIrp);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			break;

		case IRP_MN_REMOVE_DEVICE:
			//
			// The PlugPlay system has dictacted the removal of this device. We
			// have no choice but to detach and delete the device object.
			// (If we wanted to express an interest in preventing this removal,
			// we should have filtered the query remove and query stop routines.)
			// Note: we might receive a remove WITHOUT first receiving a stop.

			if (pDevExt->Started)
				{
				//
				// Stop the device without touching the hardware.
				//
				MSGAME_StopDevice (pDevExt, FALSE);
				}

			pDevExt->Removed = TRUE;

			//
			// Send on the remove IRP
			//

			IoSkipCurrentIrpStackLocation (pIrp);
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);

			//
			//	Must double-decrement because we start at One
			//
						
			i = InterlockedDecrement (&pDevExt->IrpCount);
			ASSERT(i>0);

			if (InterlockedDecrement (&pDevExt->IrpCount) > 0)
				KeWaitForSingleObject (&pDevExt->RemoveEvent, Executive, KernelMode, FALSE, NULL);

			//
			//	Return success
			//

			return (STATUS_SUCCESS);

		default:
			//
			// Here the filter driver might modify the behavior of these IRPS
			// Please see PlugPlay documentation for use of these IRPs.
			//
			IoSkipCurrentIrpStackLocation (pIrp);
			MsGamePrint ((DBG_INFORM, "%s_PnP calling next driver with minor function %ld at IRQL %ld\n", MSGAME_NAME, pIrpStack->MinorFunction, KeGetCurrentIrql()));
			ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
			break;
		}

	if (!InterlockedDecrement (&pDevExt->IrpCount))
		KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

	MsGamePrint ((DBG_INFORM, "%s: %s_PnP exit\n", MSGAME_NAME, MSGAME_NAME));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Completion routine for Pnp start device
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
//	@parm		PVOID | Context | Pointer to device context
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_PnPComplete (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp, IN PVOID Context)
{
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_EXTENSION		pDevExt;
	NTSTATUS					ntStatus = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER (DeviceObject);

	MsGamePrint ((DBG_INFORM, "%s: %s_PnPComplete enter\n", MSGAME_NAME, MSGAME_NAME));

	pDevExt = (PDEVICE_EXTENSION) Context;
	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

	switch (pIrpStack->MajorFunction)
		{
		case IRP_MJ_PNP:
			switch (pIrpStack->MinorFunction)
				{
				case IRP_MN_START_DEVICE:
					KeSetEvent (&pDevExt->StartEvent, 0, FALSE);

					//
					// Take IRP back so we can continue using it during the IRP_MN_START_DEVICE
					// dispatch routine. We will have to call IoCompleteRequest there.
					//
					return (STATUS_MORE_PROCESSING_REQUIRED);

				default:
					break;
				}
			break;

		default:
			break;
		}

	MsGamePrint ((DBG_INFORM, "%s: %s_PnPComplete Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		PnP start device IRP handler
//	@parm		PDEVICE_EXTENSION | pDevExt | Pointer to device extenstion
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_StartDevice (IN PDEVICE_EXTENSION pDevExt, IN PIRP pIrp)
{
	PWCHAR			HardwareId;
	NTSTATUS			ntStatus;
	PDEVICEINFO		DevInfo;
	PDEVICE_OBJECT	RemoveObject;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_StartDevice Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// The PlugPlay system should not have started a removed device!
	//

	ASSERT (!pDevExt->Removed);

	if (pDevExt->Started)
		return (STATUS_SUCCESS);

	//
	// Acquire resources we need for this device
	//

	ntStatus = MSGAME_GetResources (pDevExt, pIrp);
	if (!NT_SUCCESS(ntStatus))
		return (ntStatus);

	//
	//	Dump debug OEM Data fields
	//

	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[0] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[0]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[1] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[1]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[2] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[2]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[3] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[3]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[4] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[4]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[5] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[5]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[6] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[6]));
	MsGamePrint ((DBG_CONTROL, "%s: %s_StartDevice Called With OEM_DATA[7] = 0x%X\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.OemData[7]));

	//
	//	Make sure we are only on one gameport
	//

	if (CurrentGameContext && (CurrentGameContext != pDevExt->PortInfo.GameContext))
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_StartDevice Cannot Load on Multiple Gameports: 0x%X and 0x%X\n",\
						 CurrentGameContext, pDevExt->PortInfo.GameContext, MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DEVICE_CONFIGURATION_ERROR);
		}
	CurrentGameContext = pDevExt->PortInfo.GameContext;

	//
	//	Get the HardwareId for this Start request
	//

	HardwareId = MSGAME_GetHardwareId (pDevExt->Self);
	if (!HardwareId)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetHardwareId Failed\n", MSGAME_NAME, MSGAME_NAME));
		return (STATUS_DEVICE_CONFIGURATION_ERROR);
		}

	//
	//	Initialize OEM Data
	//
	
	SET_DEVICE_OBJECT(&pDevExt->PortInfo, pDevExt->Self);

	//
	//	Now start the low level device
	//

	ntStatus = DEVICE_StartDevice (&pDevExt->PortInfo, HardwareId);
		
	//
	//	Free HardwareId right away
	//

	MSGAME_FreeHardwareId (HardwareId);

	//
	//	Check if low-level start device failed
	//

	if (NT_ERROR(ntStatus))
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_StartDevice Failed\n", MSGAME_NAME, MSGAME_NAME));
		return (ntStatus);
		}

	//
	// Everything is fine so let's say device has started
	//

	pDevExt->Started = TRUE;

	//
	//	Return status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_StartDevice Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		PnP start device IRP handler
//	@parm		PDEVICE_EXTENSION | pDevExt | Pointer to device extenstion
//	@parm		BOOLEAN | TouchTheHardware | Flag to send non PnP Irps to device
// @rdesc	Returns NT status code
//	@comm		Public function <en->
//				The PlugPlay system has dictacted the removal of this device.
//				We have no choise but to detach and delete the device object.
//				(If we wanted to express and interest in preventing this removal,
//				we should have filtered the query remove and query stop routines.)
//				Note! we might receive a remove WITHOUT first receiving a stop
//---------------------------------------------------------------------------

VOID	MSGAME_StopDevice (IN PDEVICE_EXTENSION pDevExt, IN BOOLEAN TouchTheHardware)
{
	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_StopDevice enter \n", MSGAME_NAME, MSGAME_NAME));

	//
	// The PlugPlay system should not have started a removed device!
	//

	ASSERT (!pDevExt->Removed);
	if (!pDevExt->Started)
		return;

	//
	//	Now stop the low level device
	//

	DEVICE_StopDevice (&pDevExt->PortInfo, TouchTheHardware);

	//
	// Everything is fine so let's say device has stopped
	//

	pDevExt->Started = FALSE;

	MsGamePrint ((DBG_INFORM, "%s: %s_StopDevice exit \n", MSGAME_NAME, MSGAME_NAME));
}

//---------------------------------------------------------------------------
// @func		Power dispatch routine.
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp)
{
	PDEVICE_EXTENSION	pDevExt;
	NTSTATUS				ntStatus;
	PIO_STACK_LOCATION pIrpStack;

	PAGED_CODE ();

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);
	MsGamePrint ((DBG_CONTROL, "%s: %s_Power Enter  MN_Function %x type %x State %x\n", MSGAME_NAME, MSGAME_NAME,pIrpStack->MinorFunction,pIrpStack->Parameters.Power.Type,pIrpStack->Parameters.Power.State));

	pDevExt = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

	//
	// This IRP was sent to the filter driver. Since we do not know what
	// to do with the IRP, we should pass it on along down the stack.
	//

	InterlockedIncrement (&pDevExt->IrpCount);

	if (pDevExt->Removed)
		{
		ntStatus = STATUS_DELETE_PENDING;
		pIrp->IoStatus.Information = 0;
		pIrp->IoStatus.Status = ntStatus;
		IoCompleteRequest (pIrp, IO_NO_INCREMENT);
		}
	else
		{
		//Is System trying to wake up device
		if ((2 == (pIrpStack->MinorFunction)) && (1 == (pIrpStack->Parameters.Power.Type)) &&( 1 == (pIrpStack->Parameters.Power.State.SystemState)))
		{
			// Clear DeviceDetected to force reset and redetect
			SET_DEVICE_INFO(&(pDevExt->PortInfo),0);
			MsGamePrint ((DBG_CONTROL, "%s: %s_Power Resetting Device Detected\n", MSGAME_NAME, MSGAME_NAME));


		}
		//
		// Power IRPS come synchronously; drivers must call
		// PoStartNextPowerIrp, when they are ready for the next power irp.
		// This can be called here, or in the completetion routine.
		//
		PoStartNextPowerIrp (pIrp);

		//
		// PoCallDriver NOT IoCallDriver.
		//
		IoSkipCurrentIrpStackLocation (pIrp);
		ntStatus =	PoCallDriver (pDevExt->TopOfStack, pIrp);
		}

	if (!InterlockedDecrement (&pDevExt->IrpCount))
		KeSetEvent (&pDevExt->RemoveEvent, 0, FALSE);

	MsGamePrint ((DBG_INFORM, "%s: %s_Power Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Calls GameEnum to request gameport parameters
//	@parm		PDEVICE_EXTENSION | pDevExt | Pointer to device extenstion
//	@parm		PIRP | pIrp | Pointer to IO request packet
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetResources (IN PDEVICE_EXTENSION pDevExt, IN PIRP pIrp)
{
	NTSTATUS					ntStatus = STATUS_SUCCESS;
	KEVENT					IoctlCompleteEvent;
	IO_STATUS_BLOCK		IoStatus;
	PIO_STACK_LOCATION	pIrpStack, nextStack;

	PAGED_CODE ();

	MsGamePrint ((DBG_INFORM, "%s: %s_GetResources Enter\n", MSGAME_NAME, MSGAME_NAME));

	//
	// Issue a synchronous request to get the resources info from GameEnum
	//

	KeInitializeEvent (&IoctlCompleteEvent, NotificationEvent, FALSE);

	pIrpStack = IoGetCurrentIrpStackLocation (pIrp);
	nextStack = IoGetNextIrpStackLocation (pIrp);
	ASSERT (nextStack);

	//
	// Pass the Portinfo buffer of the DeviceExtension
	//

	pDevExt->PortInfo.Size = sizeof (GAMEPORT);

	nextStack->MajorFunction											= IRP_MJ_INTERNAL_DEVICE_CONTROL;
	nextStack->Parameters.DeviceIoControl.IoControlCode		= IOCTL_GAMEENUM_PORT_PARAMETERS;
	nextStack->Parameters.DeviceIoControl.InputBufferLength	= sizeof (GAMEPORT);
	nextStack->Parameters.DeviceIoControl.OutputBufferLength	= sizeof (GAMEPORT);
	pIrp->UserBuffer														= &pDevExt->PortInfo;

	IoSetCompletionRoutine (pIrp, MSGAME_GetResourcesComplete, &IoctlCompleteEvent, TRUE, TRUE, TRUE);

	MsGamePrint ((DBG_CONTROL, "%s: Calling GameEnum to Get Resources at IRQL=%lu\n", MSGAME_NAME, KeGetCurrentIrql()));

	ntStatus = IoCallDriver (pDevExt->TopOfStack, pIrp);
	if (ntStatus == STATUS_PENDING)
		ntStatus = KeWaitForSingleObject (&IoctlCompleteEvent, Suspended, KernelMode, FALSE, NULL);

	if (NT_SUCCESS(ntStatus))
		MsGamePrint ((DBG_VERBOSE, "%s: %s_GetResources Port Obtained = 0x%lX\n", MSGAME_NAME, MSGAME_NAME, pDevExt->PortInfo.GameContext));
	else MsGamePrint ((DBG_SEVERE, "%s: GameEnum Failed to Provide Resources, Status = %X\n", MSGAME_NAME, ntStatus));

	//
	//	Return Status
	//

	MsGamePrint ((DBG_INFORM, "%s: %s_GetResources Exit\n", MSGAME_NAME, MSGAME_NAME));
	return (pIrp->IoStatus.Status);
}

//---------------------------------------------------------------------------
// @func		Completion routine for GameEnum get reosources driver call
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
//	@parm		PIRP | pIrp | Pointer to IO request packet
//	@parm		PVOID | Context | Pointer to device context
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	MSGAME_GetResourcesComplete (IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp, IN PVOID Context)
{
	UNREFERENCED_PARAMETER (DeviceObject);

	KeSetEvent ((PKEVENT)Context, 0, FALSE);

	if (pIrp->PendingReturned)
		IoMarkIrpPending (pIrp);

	return (STATUS_MORE_PROCESSING_REQUIRED);
}

//---------------------------------------------------------------------------
// @func		Gets HardwareId string for device object (assumes caller frees)
//	@parm		PDEVICE_OBJECT | DeviceObject | Pointer to device object
// @rdesc	Pointer to allocated memory containing string
//	@comm		Public function
//---------------------------------------------------------------------------

PWCHAR MSGAME_GetHardwareId (IN PDEVICE_OBJECT DeviceObject)
{
	LONG					BufferLength	=	0;
	PWCHAR 				Buffer			=	NULL;
	NTSTATUS				ntStatus;
	PDEVICE_OBJECT		pPDO;

	MsGamePrint ((DBG_INFORM, "%s: %s_GetHardwareId\n", MSGAME_NAME, MSGAME_NAME));

	//
	//	Walk to end of stack and get pointer to PDO
	//

	pPDO = DeviceObject;
	while (GET_NEXT_DEVICE_OBJECT(pPDO))
		pPDO = GET_NEXT_DEVICE_OBJECT(pPDO);

	//
	//	Get Buffer length
	//

	ntStatus = IoGetDeviceProperty(
						pPDO,
						DevicePropertyHardwareID,
						BufferLength,
						Buffer,
						&BufferLength);

	ASSERT(ntStatus==STATUS_BUFFER_TOO_SMALL);

	//
	//	Allocate room for HardwareID
	//

	Buffer = ExAllocatePool(PagedPool, BufferLength);
	if	(!Buffer)
		{
		//
		//	If we cannot get the memory to try this, then just say it is a no match
		//
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetHardwareId failed ExAllocate\n", MSGAME_NAME, MSGAME_NAME));
		return (NULL);
		}

	//
	//	Now get the data
	//

	ntStatus = IoGetDeviceProperty(
						pPDO,
						DevicePropertyHardwareID,
						BufferLength,
						Buffer,
						&BufferLength);

	//
	//	On error, free memory and return NULL
	//

	if (!NT_SUCCESS(ntStatus))
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_GetHardwareId couldn't get id from PDO\n", MSGAME_NAME, MSGAME_NAME));
		ExFreePool(Buffer);
		return (NULL);
		}

	//
	//	Return buffer containing hardware Id - must be freed by caller
	//

	return (Buffer);
}

//---------------------------------------------------------------------------
// @func		Compares HardwareId strings
//	@parm		PWCHAR | HardwareId | Pointer to object hardware id
//	@parm		PWCHAR | DeviceId | Pointer to device's hardware id
// @rdesc	True if strings are the same, false if different
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN MSGAME_CompareHardwareIds (IN PWCHAR HardwareId, IN PWCHAR DeviceId)
{
	MsGamePrint ((DBG_INFORM, "%s: %s_CompareHardwareIds\n", MSGAME_NAME, MSGAME_NAME));

	//
	//	Peform runtime parameter checks
	//

	if (!HardwareId || !DeviceId)
		{
		MsGamePrint ((DBG_SEVERE, "%s: %s_CompareHardwareIds - Bogus Strings\n", MSGAME_NAME, MSGAME_NAME));
		return (FALSE);
		}

	//
	//	Perform char-by-char string compare
	//

	while (*HardwareId && *DeviceId)
		{
		if (TOUPPER(*HardwareId) != TOUPPER(*DeviceId))
			return (FALSE);
		HardwareId++;
		DeviceId++;
		}

	//
	//	Return success
	//

	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Frees HardwareId allocated from MSGAME_GetHardwareId
//	@parm		PWCHAR | HardwareId | Pointer to hardware id to free
// @rdesc	None
//	@comm		Public function
//---------------------------------------------------------------------------

VOID MSGAME_FreeHardwareId (IN PWCHAR HardwareId)
{
	MsGamePrint ((DBG_INFORM, "%s: %s_FreeHardwareId\n", MSGAME_NAME, MSGAME_NAME));

	//
	//	Free memory pool
	//

	if (HardwareId)
		ExFreePool(HardwareId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\portio.c ===
//**************************************************************************
//
//		PORTIO.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	PORTIO.C | Gameport Input/Output Routines
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, PORTIO_DriverEntry)
#endif

//---------------------------------------------------------------------------
//		Private Data
//---------------------------------------------------------------------------

static	ULONG			PortTimeOut		=	ONE_MILLI_SEC;
static	KIRQL			MaskedIrql		=	PASSIVE_LEVEL;
static	KIRQL			SpinLockIrql	=	PASSIVE_LEVEL;
static	KSPIN_LOCK	IoSpinLock		=	{0};

//---------------------------------------------------------------------------
// @func		Driver entry point for portio layer
// @rdesc	Returns NT status code
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	PORTIO_DriverEntry (VOID)
{
	KeInitializeSpinLock (&IoSpinLock);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Masks system interrupts for access to gameport
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	PORTIO_MaskInterrupts (VOID)
{
	KeRaiseIrql (PROFILE_LEVEL, &MaskedIrql);
}

//---------------------------------------------------------------------------
// @func		Unmasks system interrupts for access to gameport
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	PORTIO_UnMaskInterrupts (VOID)
{
	KeLowerIrql (MaskedIrql);
}

//---------------------------------------------------------------------------
// @func		Acquires exclusive access to gameport (mutex)
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns true if successful
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_AcquirePort (PGAMEPORT PortInfo)
{
	if (PortInfo->AcquirePort (PortInfo->PortContext) != STATUS_SUCCESS)
		return (FALSE);
	KeAcquireSpinLock (&IoSpinLock, &SpinLockIrql);
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Releases exclusive access to gameport (mutex)
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	PORTIO_ReleasePort (PGAMEPORT PortInfo)
{
	KeReleaseSpinLock (&IoSpinLock, SpinLockIrql);
	PortInfo->ReleasePort (PortInfo->PortContext);
}

//---------------------------------------------------------------------------
// @func		Calculates port timeout value
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID PORTIO_CalibrateTimeOut (PGAMEPORT PortInfo)
{
	PortTimeOut = TIMER_CalibratePort (PortInfo, ONE_MILLI_SEC);
}

//---------------------------------------------------------------------------
// @func		Reads byte from IO port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns byte from port
//	@comm		Public function
//---------------------------------------------------------------------------
#if _MSC_FULL_VER <= 13008829
#pragma optimize("y", off)
#endif
UCHAR PORTIO_Read (PGAMEPORT PortInfo)
{
	UCHAR	Value;

	__asm	pushad
	Value = PortInfo->ReadAccessor (PortInfo->GameContext);
	__asm	popad
	return (Value);
}

//---------------------------------------------------------------------------
// @func		Write byte To IO port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		UCHAR | Value | Value to write
// @rdesc	Returns nothing
//	@comm		Public function
//---------------------------------------------------------------------------

VOID PORTIO_Write (PGAMEPORT PortInfo, UCHAR Value)
{
	__asm	pushad
	PortInfo->WriteAccessor (PortInfo->GameContext, Value);
	__asm	popad
}
#if _MSC_FULL_VER <= 13008829
#pragma optimize("", on)
#endif
//---------------------------------------------------------------------------
// @func		Get AckNak (buttons) from gameport
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Timeout | Calibrated status gate timeout
//	@parm		PUCHAR | AckNak | Pointer to AckNak buffer
// @rdesc	Returns True if active, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_GetAckNak (PGAMEPORT PortInfo, ULONG Timeout, PUCHAR AckNak)
{
	if (!PORTIO_WaitForStatusGate (PortInfo, CLOCK_BIT_MASK, Timeout))
		return (FALSE);

	TIMER_DelayMicroSecs (10);

	*AckNak = PORTIO_Read (PortInfo);
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Get NakAck (buttons) from gameport
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Timeout | Calibrated status gate timeout
//	@parm		PUCHAR | NakAck | Pointer to NakAck buffer
// @rdesc	Returns True if active, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_GetNakAck (PGAMEPORT PortInfo, ULONG Timeout, PUCHAR NakAck)
{
	if (!PORTIO_WaitForStatusGate (PortInfo, STATUS_GATE_MASK, Timeout))
		return (FALSE);

	TIMER_DelayMicroSecs (10);

	*NakAck = PORTIO_Read (PortInfo);
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Determines whether gameport clock is active
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True if active, False otherwise
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_IsClockActive (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	UCHAR	Value;

	Value = PORTIO_Read (PortInfo);
	do if ((PORTIO_Read (PortInfo) ^ Value) & CLOCK_BIT_MASK)
		return (TRUE);
	while (--DutyCycle);

	return (FALSE);
}
	
//---------------------------------------------------------------------------
// @func		Waits until gameport clock line goes inactive
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitClockInActive (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	ULONG	TimeOut = PortTimeOut;

	do	if (!PORTIO_IsClockActive (PortInfo, DutyCycle))
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitClockInActive)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport clock line goes low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitClockLow (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & CLOCK_BIT_MASK) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitClockLow)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport clock line goes high
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitClockHigh (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & CLOCK_BIT_MASK))
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitClockHigh)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport data2 line goes low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitDataLow (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & DATA2_BIT_MASK) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitDataLow)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport XA line goes high to low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitXA_HighLow (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	if ((PORTIO_Read (PortInfo) & INTXA_BIT_MASK) == 0)
		{
		MsGamePrint ((DBG_SEVERE, "PORTIO: Initial (WaitXA_HighLow) Was Low\n"));
		return (FALSE);
		}

	do	if ((PORTIO_Read (PortInfo) & INTXA_BIT_MASK) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitXALow)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport XA and clock lines go low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForIdle (PGAMEPORT PortInfo)
{
	ULONG	TimeOut = PortTimeOut;

	do	if ((PORTIO_Read (PortInfo) & (INTXA_BIT_MASK|CLOCK_BIT_MASK)) == 0)
		return (TRUE);
	while (--TimeOut);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitForIdle)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits until gameport XA and clock lines go low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @parm		UCHAR | Mask | Button mask to wait on
//	@parm		ULONG | Timeout | Calibrated status gate timeout
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForStatusGate (PGAMEPORT PortInfo, UCHAR Mask, ULONG Timeout)
{
	do	if ((PORTIO_Read (PortInfo) & STATUS_GATE_MASK) == Mask)
		return (TRUE);
	while (--Timeout);

	MsGamePrint ((DBG_SEVERE, "PORTIO: Timeout at (WaitForStatusGate)\n"));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Waits for gameport XA low, clock inactive and then clock low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForHandshake (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	return
		(
		PORTIO_WaitXA_HighLow (PortInfo) 					&&
		PORTIO_WaitClockInActive (PortInfo, DutyCycle)	&&
		PORTIO_WaitClockLow (PortInfo)
		);
}

//---------------------------------------------------------------------------
// @func		Waits for gameport XA low, clock inactive and then clock low
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
// @rdesc	Returns True is sucessful, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_WaitForIdleHandshake (PGAMEPORT PortInfo, ULONG DutyCycle)
{
	ULONG	TimeOut = PortTimeOut;

	if (!PORTIO_WaitClockHigh (PortInfo))
		return (FALSE);

	if (!PORTIO_WaitForIdle (PortInfo))
		return (FALSE);

	do	if (!PORTIO_IsClockActive (PortInfo, DutyCycle))
		return (TRUE);
	while (--TimeOut);

	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Pulses port and the waits for gameport handshake
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
//	@parm		ULONG | Pulses | Number of pulses to perform
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_PulseAndWaitForHandshake (PGAMEPORT PortInfo, ULONG DutyCycle, ULONG Pulses)
{
	while (Pulses--)
		{
		PORTIO_Write (PortInfo, 0);
		if (!PORTIO_WaitForHandshake (PortInfo, DutyCycle))
			return (FALSE);
		}
	return (TRUE);
}

//---------------------------------------------------------------------------
// @func		Pulses port and the waits for gameport idle handshake
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | DutyCycle | Calibrated maximum clock duty cycle
//	@parm		ULONG | Pulses | Number of pulses to perform
// @rdesc	Returns True is sucessfull, false on timeout
//	@comm		Public function
//---------------------------------------------------------------------------

BOOLEAN	PORTIO_PulseAndWaitForIdleHandshake (PGAMEPORT PortInfo, ULONG DutyCycle, ULONG Pulses)
{
	while (Pulses--)
		{
		PORTIO_Write (PortInfo, 0);
		if (!PORTIO_WaitForIdleHandshake (PortInfo, DutyCycle))
			return (FALSE);
		}
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dpro.c ===
//**************************************************************************
//
//		SW3DPRO.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DPRO.C | Gameport mini-driver for Sidewinder Pro
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DPRO"
#define	DEVICE_PID					0x0f1f
#define	HARDWARE_ID					L"Gameport\\SideWinder3DPro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			8
#define	GAME_PACKET_BUTTONS		8
#define	GAME_PACKET_AXIS			4

#define	GAME_PHASE_BYTE			0						// Packet[0] bits
#define	GAME_PHASE_BIT				0x80
#define	GAME_H3_BYTE				0
#define	GAME_H3_BITS				0x40
#define	GAME_X7_X9_BYTE			0
#define	GAME_X7_X9_BITS			0x38
#define	GAME_Y7_Y9_BYTE			0
#define	GAME_Y7_Y9_BITS			0x07

#define	GAME_B0_B6_BYTE			1						// Packet[1] bits
#define	GAME_B0_B6_BITS			0x7f

#define	GAME_X0_X6_BYTE			2						// Packet[2] bits
#define	GAME_X0_X6_BITS			0x7f

#define	GAME_Y0_Y6_BYTE			3						// Packet[3] bits
#define	GAME_Y0_Y6_BITS			0x7f

#define	GAME_B7_BYTE				4						// Packet[4] bits
#define	GAME_B7_BITS				0x40
#define	TM_MODE_BYTE				4
#define	TM_MODE_BITS				0x20
#define	GAME_R7_R8_BYTE			4
#define	GAME_R7_R8_BITS			0x18
#define	GAME_T7_T9_BYTE			4
#define	GAME_T7_T9_BITS			0x07

#define	GAME_R0_R6_BYTE			5						// Packet[5] bits
#define	GAME_R0_R6_BITS			0x7f

#define	GAME_T0_T6_BYTE			6						// Packet[6] bits
#define	GAME_T0_T6_BITS			0x7f

#define	GAME_H0_H2_BYTE			7						// Packet[7] bits
#define	GAME_H0_H2_BITS			0x70
#define	GAME_C0_C3_BYTE			7
#define	GAME_C0_C3_BITS			0x0f

#define	ENH_CLOCK_MIDPACKET		0x00000400
#define	ENH_CLOCK_COMPLETE		0x00200000

//
//	Id Definitions
//

#define	GAME_ID_CLOCKS				32
#define	GAME_ID_STRING				"(\1\x24P"

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	 75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	PACKET_INTERRUPT_DELAY	 30
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		 75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		 50

#define	GODIGITAL_ATTEMPTS		10
#define	RECALIBRATE_FAIL_COUNT	(GODIGITAL_ATTEMPTS/2)

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0xff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0xff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0xff
#define	EXTENTS_R_MIN				0
#define	EXTENTS_R_MAX				0x3f

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DPRO_ID | Sidwinder Pro Id String
#pragma pack(1)
	UCHAR		EnumId[3];				// @field Enumerated Id
	UCHAR		EisaId[8];				// @field Eisa bus Id
	UCHAR		Devices;					// @field Number of devices
	USHORT	Version[7];				// @field Firmware version
	UCHAR		EndOfStr;				// @field ID string terminator
#pragma pack()
}	SW3DPRO_ID, *PSW3DPRO_ID;

//---------------------------------------------------------------------------
//	Macros	
//---------------------------------------------------------------------------

#define	LOW_NIBBLE(c)		((c)&GAME_C0_C3_BITS)
#define	HIGH_NIBBLE(c)		(((c)&(GAME_C0_C3_BITS<<4))>>4)

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DPRO_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DPRO_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DPRO_GoDigital (PPACKETINFO IdPacket, ULONG Sequence[]);
static	LONG		SW3DPRO_InterruptPacket (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DPRO_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DPRO_GetId (PPACKETINFO IdPacket);

static	NTSTATUS	SW3DPRO_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO_ValidateData (PUCHAR Packet);
static	VOID		SW3DPRO_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DPRO_DriverEntry (VOID);
static	NTSTATUS	SW3DPRO_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DPRO_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DPRO_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	
	//id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//dwR
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_RUDDER,	//	USAGE (Rudder)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x01, 0x00, 0x00,			//	LOGICAL_MAXIMUM (511)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x01, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (511)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9f, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)

	//dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x08,									//	USAGE_MAXIMUM (Button 8)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION												// END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{	// no buttons; x, y, t and r centered
							GAME_PHASE_BIT|((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|((GAME_Y7_Y9_BITS>>1)&GAME_Y7_Y9_BITS),
							GAME_B0_B6_BITS,
							GAME_X0_X6_BITS,
							GAME_Y0_Y6_BITS,
							((GAME_R7_R8_BITS>>1)&GAME_R7_R8_BITS)|((GAME_T7_T9_BITS>>1)&GAME_T7_T9_BITS)|GAME_B7_BITS,
							GAME_R0_R6_BITS,
							GAME_T0_T6_BITS,
							0
							};
//
//	Raw Id Buffer
//

static	SW3DPRO_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							PACKET_INTERRUPT_DELAY,
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DPRO_DriverEntry,			// DriverEntry
							SW3DPRO_ConnectDevice,		// ConnectDevice
							SW3DPRO_StartDevice,			//	StartDevice
							SW3DPRO_ReadReport,			// ReadReport
							SW3DPRO_StopDevice,			// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//
static	UCHAR			ValidData[GAME_PACKET_SIZE] =
							{	// no buttons; x, y, t and r centered
							GAME_PHASE_BIT|((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|((GAME_Y7_Y9_BITS>>1)&GAME_Y7_Y9_BITS),
							GAME_B0_B6_BITS,
							GAME_X0_X6_BITS,
							GAME_Y0_Y6_BITS,
							((GAME_R7_R8_BITS>>1)&GAME_R7_R8_BITS)|((GAME_T7_T9_BITS>>1)&GAME_T7_T9_BITS)|GAME_B7_BITS,
							GAME_R0_R6_BITS,
							GAME_T0_T6_BITS,
							0
							};

//
//	Go Digital Timing Data
//

static	ULONG 		GoDigitalFastTiming[] =
							{
							T1+60,
							T2+60,
							T3+60
							};

static	ULONG 		GoDigitalMediumTiming[] =
							{
							T1,
							T2,
							T3
							};

static	ULONG 		GoDigitalSlowTiming[] =
							{
							T1-20,
							T2-20,
							T3-20
							};

static	ULONG			GoDigitalFails = 0;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	MidasInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							TRUE,								// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO: SW3DPRO_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
	DataInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: DataInfo.InterruptDelay = %ld\n", DataInfo.InterruptDelay));
	IdInfo.InterruptDelay = Delays.InterruptDelay;
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO: IdInfo.InterruptDelay = %ld\n", IdInfo.InterruptDelay));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_ResetDevice (PGAMEPORT PortInfo)
{
	LONG	Result;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Mode = IdInfo.Mode = IMODE_ANALOG;

	PORTIO_Write (PortInfo, 0);
	Result = SW3DPRO_InterruptPacket (PortInfo);
	if (Result == ERROR_SUCCESS)
		Result = SW3DPRO_InterruptPacket (PortInfo);

	if (Result != ERROR_SUCCESS)
		MsGamePrint ((DBG_SEVERE, "SW3DPRO_ResetDevice - InterruptPacket failed\n"));

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (&DataInfo);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Interrupts device during packet transfer
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Internal result
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SW3DPRO_InterruptPacket (PGAMEPORT PortInfo)
{
	LONG	Clks;
	LONG	Result;

	__asm
		{
			push	edi
			push	esi

			lea	edx, IdInfo.PortInfo		; load gameport adddress

			mov	ebx, 64						; Standard Mode = 64 clks.

		Int_CheckState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 0 ?
			jz		Int_ClockRise				; Y: jump

		;Int_ClockFall:

			mov	ecx, TIMEOUT

		Int_ClockFall_1:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Int_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	Int_ClockFall_1			; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	IntPacketComplete			; Time out error.

		Int_ClockRise:

			mov	ecx, TIMEOUT

		Int_ClockRise_1:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz 	Int_Transition				; Y: jump. (transition)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec 	ecx
			jnz 	Int_ClockRise_1			; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	IntPacketComplete			; Time out error.

		Int_Transition:

			cmp	bl, 14						; Q: 14 clocks left ?
			jne	Int_Transition_1			; N: jump.

			push	0								; write byte to gameport
			push	edx
			call	PORTIO_Write

		Int_Transition_1:

			dec	bl
			jnz	Int_CheckState

			mov eax, ERROR_SUCCESS

		IntPacketComplete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_InterruptPacket - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_InterruptPacket - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;
		}
	#endif

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Puts device into digital mode
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_GoDigital (PPACKETINFO IdPacket, ULONG Sequence[])
{
	LONG			i;
	ULONG			ThreeMilliSecs;
	ULONG			GoDigitalTiming[3];
	LONG			Result 		=	ERROR_SUCCESS;
	ULONG			Attempts		=	MAX_CONNECT_ATTEMPTS;
	PGAMEPORT	PortInfo 	= &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_GoDigital enter\n"));
   
	do
		{
		for (i = 0; i < 3; i++)
			GoDigitalTiming[i] = TIMER_GetDelay (Sequence[i]);
		ThreeMilliSecs = TIMER_GetDelay (THREE_MILLI_SECS);

		if (GoDigitalFails > RECALIBRATE_FAIL_COUNT)
			TIMER_Calibrate ();

		if (!PORTIO_AcquirePort (PortInfo))
			continue;
		PORTIO_MaskInterrupts ();

		PORTIO_Write (PortInfo, 0);

		__asm
			{
				push	edi
				push	esi

				mov	edx, PortInfo				; load gameport adddress

				mov	ecx, MAX_XA_TIMEOUT
				xor	ebx, ebx

			WaitXA:
			
				push	edx							; read byte from gameport
				call	PORTIO_Read

				test	al, INTXA_BIT_MASK		; Q: X axis low ?
				jz		XA_Done						; Y: jump. (complete)
				xor	bh, al						; Q: Clock transition ?
				test	bh, CLOCK_BIT_MASK
				jz		WaitXA_1						; N: jump.
				inc	bl								; inc. clock transition count.

			WaitXA_1:
			
				mov	bh, al
				dec	ecx
				jnz	WaitXA

				jmp	DigitalSwitchFail

			XA_Done:

				cmp	bl, 3							; Q: Already in Digital mode ?
				ja		DigitalSwitchDone			; Y: jump.

				xor	edi, edi
				mov	esi, edx

			DigitalSwitchLoop:

				push	GoDigitalTiming[edi]
				add	edi, 4						; inc loop counter & index
				call	TIMER_DelayMicroSecs
				mov	edx, esi

				push	0								; write byte to gameport
				push	edx
				call	PORTIO_Write

				push	edx
				call	PORTIO_WaitXA_HighLow	; Wait for XA to transition

				or		al, al
				je		DigitalSwitchFail			; if Timeout then fail.
				cmp	edi, 12
				jl		DigitalSwitchLoop
				push	ThreeMilliSecs
				call	TIMER_DelayMicroSecs		; Delay so Firmware can update
				jmp	DigitalSwitchDone

			DigitalSwitchFail:

				mov	Result, ERROR_XA_TIMEOUT

			DigitalSwitchDone:

				pop	esi
				pop	edi
			}

		IdPacket->TimeStamp		= TIMER_GetTickCount ();
		IdPacket->LastError		= Result;
		IdPacket->Transaction	= MSGAME_TRANSACT_GODIGITAL;

		PORTIO_UnMaskInterrupts ();
		PORTIO_ReleasePort (PortInfo);

		if (Result == ERROR_SUCCESS)
			{
			GoDigitalFails = 0;
			break;
			}
		else GoDigitalFails++;

		if (Result == ERROR_XA_TIMEOUT)
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_GoDigital - TimeOut@XAHighLow\n"));

		}	while(--Attempts);

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_ReadId (PPACKETINFO IdPacket)
{
	ULONG			B4			=	0L;
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_SUCCESS;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	PORTIO_Write (PortInfo, 0);
	Result = SW3DPRO_InterruptPacket (PortInfo);
	if (Result != ERROR_SUCCESS)
		goto ReadIdExit;

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; BL = no of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:
		
			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	esi, 1						; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	ID_ClockCheck				; if != 0 then loop

		; ID_Success:

			mov	eax, ERROR_SUCCESS
			mov	IdInfo.Mode, IMODE_DIGITAL_STD
			cmp	edi, 4
			jl		ID_Success_1
			mov	IdInfo.Mode, IMODE_DIGITAL_ENH

		ID_Success_1:
		
			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	B4, edi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DPRO_ReadId - SUCCEEDED, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadId - TimeOut@ClockFalling, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadId - TimeOut@ClockRising, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN	Result;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_GetId enter\n"));

	if(DataInfo.B4Transitions > 4)
		DataInfo.Mode = IMODE_DIGITAL_ENH;
	else DataInfo.Mode = IMODE_DIGITAL_STD;

	IdPacket->Attempts++;

	Result = SW3DPRO_ReadId (IdPacket);

	if (Result)
		{
      if (!strncmp (IdPacket->Data, GAME_ID_STRING, strlen(GAME_ID_STRING)))
			{
			//
			// Do AZTECH test here
			//
			if (IdPacket->B4Transitions > 3)
				{
				MsGamePrint ((DBG_CONTROL, "SW3DPRO_GetId - had B4 transitions\n"));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				//
				// An AZTECH card was detected OR this card didn't seem to support
				// Enhanced mode correctly. Lets reset by going Analog then going
				// digital this should place the device into Standard mode.
				//
				MsGamePrint ((DBG_CONTROL, "SW3DPRO_GetId - 1 Wide Only type card detected\n"));
				SW3DPRO_ResetDevice (&IdPacket->PortInfo);
				SW3DPRO_GoDigital (IdPacket, GoDigitalMediumTiming);
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_STD;		
				}
			}
		else
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_GetId - Id string did not match = 0x%X\n", (ULONG)(*(PULONG)IdPacket->Data)));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC+200));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_Read1Wide (PPACKETINFO DataPacket)
{
	ULONG	Clks	=	0x2002;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_Read1Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	esi, DataInfo.Data

			lea	edx, DataInfo.PortInfo	; load gameport adddress

			xor	edi, edi
			mov	ebx, 2002h
			xor	eax, eax

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Std_ClockStartState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	Std_ClockStartFall
			loop	Std_ClockStartState		; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_CheckClkState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_ClockStartRise

		Std_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Std_ClockFalling:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Std_ClockStartRise		; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockFalling			; else see if we timed out

			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketComplete				; Time out error.

		Std_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Std_ClockRising:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	CollectData					; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockRising			; else see if we timed out

			mov	eax, ERROR_CLOCKRISING
			jmp	PacketComplete				; Time out error.

		CollectData:

			xor	ah, al
			test	ah, DATA1_BIT_MASK		; Q: Data 1 is toggled ?
			jnz	CollectData_1				; N: jump.
			inc	edi							; Y: increment Data 1 count.

		CollectData_1:

			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	DWORD PTR [esi], 1		; and then in data counter
			dec	bh								; Q: 32 bits received ?
			jnz	Std_CheckClkState			; N: continue.
			dec	bl								; dec dword count.
			jz		PacketSuccess				; if dword count = 0 then exit.
			add	esi, 4						; else advance packet pointer
			mov	bh, 32						; set bit counter = 32+32=64.
			jmp	Std_CheckClkState			; stay in receive loop.

		PacketSuccess:

			mov	eax, ERROR_SUCCESS

		PacketComplete:

			mov	Result, eax
			mov	Clks, ebx
			mov	DataInfo.B4Transitions, edi

			pop	esi
			pop	edi
		}

	switch (Clks & 0xFF)
		{
		case	0:
			DataPacket->ClocksSampled = 64;
			break;

		case	1:
			DataPacket->ClocksSampled = 32 + (32-(Clks>>8));
			break;

		case	2:
			DataPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Clks = 1L;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_Read3Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	esi, DataInfo.Data

			lea	edx, DataInfo.PortInfo	; load gameport adddress

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout
			mov	ebx, 1

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_ClockStartFall			; Y: jump
			loop	Enh_ClockStartState			; else keep looping

			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al, CLOCK_BIT_MASK			; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 1						; shift data into edi.
			mov	[esi+4], edi
			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++)
		;
	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled = 0;
	DataPacket->B4Transitions = 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			Result = SW3DPRO_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			Result = SW3DPRO_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PUCHAR | RawData | Pointer to raw packet data
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO_ValidateData (PUCHAR RawData)
{
	LONG		i			= 0;
	LONG		Check		= 0;
	PULONG	Phase		= (PULONG)RawData;
	LONG		Result	= ERROR_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ValidateData enter\n"));

	if (((*Phase & 0x80808080L) != 0x80L) || (*(Phase+1) & 0x80808080L))
		{
		MsGamePrint ((DBG_SEVERE, "SW3DPRO_ValidateData - Phase bits non-zero: %X:%X\n", *(Phase+1), *Phase));
		Result = ERROR_PHASEBITS;
		}
	else
		{
		for (i = 0; i < GAME_PACKET_SIZE; i++)
			{
			Check += LOW_NIBBLE(RawData[i]);
			Check += HIGH_NIBBLE(RawData[i]);
			}
		if (LOW_NIBBLE(Check))
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO_ValidateData - Checksum failed: %X:%X\n", *(Phase+1), *Phase));
			Result = ERROR_CHECKSUM;
			}
		}

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X7_X9_BYTE] & GAME_X7_X9_BITS;
	Report->dwX <<= 4;
	Report->dwX  |= Data[GAME_X0_X6_BYTE] & GAME_X0_X6_BITS;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y7_Y9_BYTE] & GAME_Y7_Y9_BITS;
	Report->dwY <<= 7;
	Report->dwY  |= Data[GAME_Y0_Y6_BYTE] & GAME_Y0_Y6_BITS;

	//
	//	Process R Axis
	//

	Report->dwR   = Data[GAME_R7_R8_BYTE] & GAME_R7_R8_BITS;
	Report->dwR <<= 4;
	Report->dwR  |= Data[GAME_R0_R6_BYTE] & GAME_R0_R6_BITS;

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T7_T9_BYTE] & GAME_T7_T9_BITS;
	Report->dwZ <<= 7;
	Report->dwZ  |= Data[GAME_T0_T6_BYTE] & GAME_T0_T6_BITS;

	//
	//	Process Buttons
	//

	B1 = (~Data[GAME_B7_BYTE] & GAME_B7_BITS) << 1;
	B2 = ~Data[GAME_B0_B6_BYTE] & GAME_B0_B6_BITS;
	Report->dwButtons = (B2 | B1) & ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV	= (Data[GAME_H0_H2_BYTE] & GAME_H0_H2_BITS)>>4;
	Report->dwPOV |= (Data[GAME_H3_BYTE] & GAME_H3_BITS)>>3;
	Report->dwPOV  = POV_Values[Report->dwPOV];
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO: SW3DPRO_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DPRO_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo; 

	//
	//	Convert registry timing values
	//

  	SW3DPRO_Calibrate (PortInfo);

	//
	// SW3DPRO Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Reset to "known" state
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ConnectDevice - resetting device\n"));
		SW3DPRO_ResetDevice (&DataInfo.PortInfo);
		DataInfo.Mode = IdInfo.Mode = IMODE_DIGITAL_STD;

		//
		// 2. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		//	3. Put into digital mode
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ConnectDevice - going digital\n"));
		SW3DPRO_GoDigital (&DataInfo, GoDigitalMediumTiming);

		//
		// 4. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC+500));

		//
		// 5. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ConnectDevice - getting ID string\n"));

		if (!SW3DPRO_GetId (&IdInfo))
			{
			TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
			continue;
			}

		//
      // 6. Mark device found and return
		//

		MidasInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	MidasInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{

		MsGamePrint ((DBG_INFORM, "SW3DPRO_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DPRO_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && SW3DPRO_ValidateData (DataInfo.Data))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DPRO_ReadReport - Invalid packet\n"));
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DPRO_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO_StopDevice enter\n"));

	if (TouchHardware)
		SW3DPRO_ResetDevice (PortInfo);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dpro2.c ===
//**************************************************************************
//
//		SW3DPRO2.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DPRO2.C | Gameport mini-driver for Sidewinder Pro 2
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DPRO2"
#define	DEVICE_PID					0x0017
#define	HARDWARE_ID					L"Gameport\\SideWinderPrecisionPro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			6
#define	GAME_PACKET_BUTTONS		(9+1)
#define	GAME_PACKET_AXIS			4

#define	GAME_B0_B7_BYTE			0					// Packet[0] bits
#define	GAME_B0_B7_BITS			0xff

#define	GAME_B8_BYTE				1					// Packet[1] bits
#define	GAME_B8_BITS				0x01
#define	GAME_X0_X6_BYTE			1
#define	GAME_X0_X6_BITS			0xfe

#define	GAME_X7_X9_BYTE			2					// Packet[2] bits
#define	GAME_X7_X9_BITS			0x07
#define	GAME_Y0_Y4_BYTE			2
#define	GAME_Y0_Y4_BITS			0xf8

#define	GAME_Y5_Y9_BYTE			3					// Packet[3] bits
#define	GAME_Y5_Y9_BITS			0x1f
#define	GAME_T0_T2_BYTE			3
#define	GAME_T0_T2_BITS			0xe0

#define	GAME_T3_T6_BYTE			4					// Packet[4] bits
#define	GAME_T3_T6_BITS			0x0f
#define	GAME_R0_R3_BYTE			4
#define	GAME_R0_R3_BITS			0xf0

#define	GAME_R4_R5_BYTE			5					// Packet[5] bits
#define	GAME_R4_R5_BITS			0x3
#define	GAME_H0_H3_BYTE			5
#define	GAME_H0_H3_BITS			0x3c
#define	GAME_ERR_BYTE				5
#define	GAME_ERR_BITS				0x40
#define	GAME_PPO_BYTE				5
#define	GAME_PPO_BITS				0x80

#define	ENH_CLOCK_MIDPACKET		0x0400
#define	ENH_CLOCK_COMPLETE		0x8000

//
//	ID Constants
//

#define	GAME_ID_LOW					8
#define	GAME_ID_HIGH				0
#define	GAME_ID_CLOCKS				32

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0x3ff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0x7f
#define	EXTENTS_R_MIN				0
#define	EXTENTS_R_MAX				0x3f

//
//	Speed Data
//

#define	NUM_ERROR_SAMPLES			100
#define	MIN_ERROR_RATE				5
#define	MAX_ERROR_RATE				15

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DPRO2_ID | Sidwinder Pro2 Id String
#pragma pack(1)
	UCHAR		Status;					// @field Device status byte
	UCHAR		IdLow;					// @field Device identifier (low byte)
	UCHAR		IdHigh;					// @field Device identifier (high byte)
	USHORT	Version;					// @field Firmware version
#pragma pack()
}	SW3DPRO2_ID, *PSW3DPRO2_ID;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DPRO2_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DPRO2_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DPRO2_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DPRO2_GetId (PPACKETINFO IdPacket);

static	LONG		SW3DPRO2_DecrementDevice (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DPRO2_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed);

static	NTSTATUS	SW3DPRO2_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO2_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO2_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DPRO2_ValidateData (PUCHAR Packet);
static	VOID		SW3DPRO2_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SW3DPRO2_ProcessDataError (PGAMEPORT PortInfo, ULONG Error);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DPRO2_DriverEntry (VOID);
static	NTSTATUS	SW3DPRO2_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO2_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DPRO2_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DPRO2_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DPRO2_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	
	//id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	// dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (127)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x7F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (127)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwR
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_RUDDER,	//	USAGE (Rudder)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	// dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)

	// dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,									//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION												// END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{
							0,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};
//
//	Raw Id Buffer
//

static	SW3DPRO2_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DPRO2_DriverEntry,		// DriverEntry
							SW3DPRO2_ConnectDevice,		// ConnectDevice
							SW3DPRO2_StartDevice,		//	StartDevice
							SW3DPRO2_ReadReport,			// ReadReport
							SW3DPRO2_StopDevice,			// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//

static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{
							GAME_B0_B7_BITS,	// no buttons; x, y, t and r centered
							GAME_X0_X6_BITS|GAME_B8_BITS,
							((GAME_X7_X9_BITS>>1)&GAME_X7_X9_BITS)|GAME_Y0_Y4_BITS,
							((GAME_Y5_Y9_BITS>>1)&GAME_Y5_Y9_BITS)|GAME_T0_T2_BITS,
							((GAME_T3_T6_BITS>>1)&GAME_T3_T6_BITS)|GAME_R0_R3_BITS,
							((GAME_R4_R5_BITS>>1)&GAME_R4_R5_BITS)|GAME_PPO_BITS
							};

//
//	Speed Variables
//

static	ULONG			NextSample								=	0;
static	ULONG			NumberSamples							=	0;
static	ULONG			SampleAccumulator						=	0;
static	ULONG			SampleBuffer[NUM_ERROR_SAMPLES]	= {0};

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	JunoInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO2_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO2: SW3DPRO2_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DPRO2: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Mode  = IdInfo.Mode  = IMODE_DIGITAL_STD;
	DataInfo.Speed = IdInfo.Speed = GAME_SPEED_66K;

	if (PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		{
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ResetDevice - PulseAndWaitForHandshake failed\n"));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_ReadId (PPACKETINFO IdPacket)
{
	ULONG			B4			=	0L;
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, IdInfo.ClockDutyCycle, 1))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; BL = # of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:
		
			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	esi, 1						; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	ID_ClockCheck				; if != 0 then loop

		; ID_Success:

			mov	eax, ERROR_SUCCESS
			mov	IdInfo.Mode, IMODE_DIGITAL_STD
			cmp	edi, 3
			jl		ID_Success_1
			mov	IdInfo.Mode, IMODE_DIGITAL_ENH

		ID_Success_1:
		
			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	B4, edi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DPRO2_ReadId - SUCCEEDED, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@LowClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@HighClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@ClockFalling, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadId - TimeOut@ClockRising, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN			Result;
	PSW3DPRO2_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_GetId enter\n"));

	if(DataInfo.B4Transitions > 4)
		DataInfo.Mode = IMODE_DIGITAL_ENH;
	else DataInfo.Mode = IMODE_DIGITAL_STD;

	IdPacket->Attempts++;

	Result = SW3DPRO2_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSW3DPRO2_ID)IdPacket->Data;
		if ((Pnp->IdLow == GAME_ID_LOW) && (Pnp->IdHigh == GAME_ID_HIGH) && ((Pnp->Status&0x7F) == 0))
			{
			//
			// Do AZTECH test here
			//
			if(IdPacket->B4Transitions >= 3)
				{
				MsGamePrint ((DBG_CONTROL, "SW3DPRO2_GetId - had B4 transitions\n"));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				//
				// An AZTECH card was detected OR this card didn't seem to support
				// Enhanced mode correctly. Lets reset by going Analog then going
				// digital this should place the device into Standard mode.
				//
				MsGamePrint ((DBG_CONTROL, "SW3DPRO2_GetId - 1 Wide Only type card detected\n"));
				SW3DPRO2_ResetDevice (&IdPacket->PortInfo);
				TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_STD;		
				}
			}
		else
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_GetId - Id did not match or status error = %ld\n", (ULONG)(Pnp->Status&0x7F)));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Decrements device speed at port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns new device speed
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SW3DPRO2_DecrementDevice (PGAMEPORT PortInfo)
{
	LONG	Clks		=	0;
	LONG	Result	=	ERROR_HANDSHAKING;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_DecrementDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		goto DecrementDeviceExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			mov	ebx, 8						; BL = no of clocks to receive.
			xor	eax, eax						; data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		DD_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockStart_1			; N: jump
			loop	DD_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockStart_1:
		
			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	DD_Data						; Y: jump
			loop	DD_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockRise				; N: jump

		;DD_ClockFall:

			mov	ecx, DataInfo.HighLowTimeout

		DD_ClockFall_1:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		DD_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	DD_Complete					; Time out error.

		DD_ClockRise:

			mov	ecx, DataInfo.LowHighTimeout

		DD_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	DD_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	DD_Complete					; Time out error.

		DD_Data:

			shr	al, 6							; put data into carry
			rcr	ah, 1							; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	DD_ClockCheck				; if != 0 then loop

		;DD_Success:

			xchg	al, ah
			dec	al								; decrement returned speed
			and	eax, GAME_SPEED_BITS

			cmp	eax, GAME_SPEED_RANGE
			jb		DD_Complete
			dec	al

		DD_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	edi
			pop	esi
		}

	//	--------------------
		DecrementDeviceExit:
	//	--------------------

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_SPEED;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@LowClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@HighClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "SW3DPRO2_DecrementDevice - SUCCEEDED, Speed=%ld\n", Result));
			break;
		}
	#endif

	MSGAME_PostTransaction (&DataInfo);

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Sets new device speed
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Speed | Desired device speed
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed)
{
	LONG	Result;
	ULONG	Tries;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_SetDeviceSpeed enter\n"));

	//
	// Zero error processing counters
	//

	NextSample			=	0;
	NumberSamples		=	0;
	SampleAccumulator	=	0;
	for (Tries = 0; Tries < NUM_ERROR_SAMPLES; Tries++)
		SampleBuffer[Tries] = 0;

	//
	// Try changing speed only enough times as range
	//

	for (Tries = 0; Tries < GAME_SPEED_RANGE; Tries++)
		{
		if (DataInfo.Speed == Speed)
			return (TRUE);

		Result = SW3DPRO2_DecrementDevice (PortInfo);
		if (Result < 0)
			{
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_DecrementDevice failed on %ld attempt\n", (ULONG)Tries));
			return (FALSE);
			}

		DataInfo.Speed = IdInfo.Speed = Result;
		}

	MsGamePrint ((DBG_SEVERE, "SW3DPRO2_SetDeviceSpeed failed after %ld attempts\n", (ULONG)Tries));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_Read1Wide (PPACKETINFO DataPacket)
{
	ULONG	Clks	=	0x2002;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_Read1Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi


			lea	edx, DataInfo.PortInfo	; load gameport adddress

			mov	esi, DataInfo.Data
			xor	edi, edi
			mov	ebx, 2002h
			xor	eax, eax

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Std_ClockStartState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		Std_ClockStartState_1
			loop	Std_ClockStartState		; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_ClockStartState_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	CollectData					; Y: jump
			loop	Std_ClockStartState_1	; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_CheckClkState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_ClockStartRise

		;Std_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Std_ClockFalling:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Std_ClockStartRise		; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockFalling			; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketComplete				; Time out error.

		Std_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Std_ClockRising:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	CollectData					; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockRising			; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	PacketComplete				; Time out error.

		CollectData:

			xor	ah, al
			test	ah, DATA1_BIT_MASK		; Q: Data 1 is toggled ?
			jnz	CollectData_1				; N: jump.
			inc	edi							; Y: increment Data 1 count.

		CollectData_1:

			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	DWORD PTR [esi], 1		; and then in data counter
			dec	bh								; Q: 32 bits received ?
			jnz	Std_CheckClkState			; N: continue.
			dec	bl								; dec dword count.
			jz		PacketSuccess				; if dword count = 0 then exit.
			add	esi, 4						; else advance packet pointer
			mov	bh, 16						; set bit counter = 32+16=48.
			jmp	Std_CheckClkState			; stay in receive loop.

		PacketSuccess:

			mov	eax, ERROR_SUCCESS

		PacketComplete:

			mov	Result, eax
			mov	Clks, ebx
			mov	DataInfo.B4Transitions, edi

			pop	esi
			pop	edi
		}

	switch (Clks & 0xFF)
		{
		case	0:
			DataPacket->ClocksSampled = 48;
			break;

		case	1:
			DataPacket->ClocksSampled = 32 + (16-(Clks>>8));
			break;

		case	2:
			DataPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Clks = 1L;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_Read3Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			lea	edx, DataInfo.PortInfo		; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 16
			mov	word ptr [esi+4], di
			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled = 0;
	DataPacket->B4Transitions = 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			Result = SW3DPRO2_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			Result = SW3DPRO2_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PUCHAR | RawData | Pointer to raw packet data
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DPRO2_ValidateData (PUCHAR RawData)
{
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ValidateData enter\n"));

	if (RawData[GAME_ERR_BYTE] & GAME_ERR_BITS)
		Result = ERROR_ERRORBITS;
	else if (!DEVICE_IsOddParity (RawData, GAME_PACKET_SIZE))
		Result = ERROR_PARITYBITS;
	else Result = ERROR_SUCCESS;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_ERRORBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ValidateData - Error bits non-zero\n"));
			break;

		case	ERROR_PARITYBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ValidateData - Parity bits failed\n"));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO2_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X7_X9_BYTE] & GAME_X7_X9_BITS;
	Report->dwX <<= 7;
	Report->dwX  |= (Data[GAME_X0_X6_BYTE] & GAME_X0_X6_BITS) >> 1;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y5_Y9_BYTE] & GAME_Y5_Y9_BITS;
	Report->dwY <<= 5;
	Report->dwY  |= (Data[GAME_Y0_Y4_BYTE] & GAME_Y0_Y4_BITS) >> 3;

	//
	//	Process R Axis
	//

	Report->dwR   = Data[GAME_R4_R5_BYTE] & GAME_R4_R5_BITS;
	Report->dwR <<= 4;
	Report->dwR  |= (Data[GAME_R0_R3_BYTE] & GAME_R0_R3_BITS) >> 4;

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T3_T6_BYTE] & GAME_T3_T6_BITS;
	Report->dwZ <<= 3;
	Report->dwZ  |= (Data[GAME_T0_T2_BYTE] & GAME_T0_T2_BITS) >> 5;

	//
	//	Process Buttons
	//

	B1 = ~Data[GAME_B0_B7_BYTE] & GAME_B0_B7_BITS;
	B2 = ~Data[GAME_B8_BYTE] & GAME_B8_BITS;
	B2 <<= 9;	// Move button nine to ten (shift key)
	Report->dwButtons = (B2 | B1) & ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV = POV_Values[(Data[GAME_H0_H3_BYTE] & GAME_H0_H3_BITS)>>2];
}

//---------------------------------------------------------------------------
// @func		Processes packet results and changes device speed as neccessary
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Error | Error flag (true is error)
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DPRO2_ProcessDataError (PGAMEPORT PortInfo, ULONG Error)
{
	ULONG	Average;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ProcessDataError enter\n"));

	//
	// Update running accumulated errors
	//

	SampleAccumulator			-= SampleBuffer[NextSample];
	SampleBuffer[NextSample] = Error;
	SampleAccumulator			+= Error;

	//
	// Increment and wrap next error counter
	//

	if (++NextSample >= NUM_ERROR_SAMPLES)
		NextSample = 0;

	//
	// Increment number samples and exit if not full
	//

	if (NumberSamples < NUM_ERROR_SAMPLES)
		{
		NumberSamples++;
		return;
		}

	//
	// Calculate moving average
	//

	Average = (SampleAccumulator*100)/NumberSamples;

	//
	// Lower speed if too many errors
	//

	if ((Average > MAX_ERROR_RATE) && (DataInfo.Speed > GAME_SPEED_66K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ProcessDataError - average error = %ld\n", Average));
		SW3DPRO2_SetDeviceSpeed (PortInfo, DataInfo.Speed-1);
		}

	//
	// Raise speed if too few errors
	//

	else if ((Average < MIN_ERROR_RATE) && (DataInfo.Speed < GAME_SPEED_125K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ProcessDataError - average error = %ld\n", Average));
		SW3DPRO2_SetDeviceSpeed (PortInfo, DataInfo.Speed+1);
		}
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DPRO2: SW3DPRO2_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DPRO2_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo; 

	//
	//	Read and convert registry timing values
	//

  	SW3DPRO2_Calibrate (PortInfo);

	//
	// SW3DPRO2 Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Reset to "known" state
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ConnectDevice - resetting device\n"));
		SW3DPRO2_ResetDevice (&DataInfo.PortInfo);

		//
		// 2. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 3. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO2: DeviceConnectProc getting ID string\n"));

		if (!SW3DPRO2_GetId (&IdInfo))
			{
			TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
			continue;
			}

		//
		// 4. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 5. Copy mode from SW3DPRO2_GetId result
		//

		DataInfo.Mode = IdInfo.Mode;

		//
		// 6. Set speed to 125k for starters
		//

		MsGamePrint ((DBG_CONTROL, "SW3DPRO2: DeviceConnectProc setting device speed\n"));
		SW3DPRO2_SetDeviceSpeed (&DataInfo.PortInfo, GAME_SPEED_125K);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 7. Mark device found and return
		//

		JunoInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	JunoInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DPRO2_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "SW3DPRO2_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DPRO2_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && SW3DPRO2_ValidateData (DataInfo.Data))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		SW3DPRO2_ProcessDataError (&DataInfo.PortInfo, FALSE);
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DPRO2_ReadReport - Invalid packet\n"));
		SW3DPRO2_ProcessDataError (&DataInfo.PortInfo, TRUE);
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DPRO2_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DPRO2_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO2_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DPRO2_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DPRO2_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\sw3dtilt.c ===
//**************************************************************************
//
//		SW3DTILT.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SW3DTILT.C | Gameport mini-driver for Sidewinder Pro Tilt
//**************************************************************************

#ifndef	SAITEK
#include	"msgame.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#define	DEVICENAME					"SW3DTILT"
#define	DEVICE_PID					0x000d
#define	HARDWARE_ID					L"Gameport\\SideWinderFreestylePro\0\0"

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			6
#define	GAME_PACKET_BUTTONS		10
#define	GAME_PACKET_AXIS			3

#define	GAME_X0_X7_BYTE			0					// Packet[0] bits
#define	GAME_X0_X7_BITS			0xff

#define	GAME_X8_X9_BYTE			1					// Packet[1] bits
#define	GAME_X8_X9_BITS			0x03
#define	GAME_B0_B5_BYTE			1
#define	GAME_B0_B5_BITS			0xfc

#define	GAME_Y0_Y7_BYTE			2					// Packet[2] bits
#define	GAME_Y0_Y7_BITS			0xff

#define	GAME_Y8_Y9_BYTE			3					// Packet[3] bits
#define	GAME_Y8_Y9_BITS			0x03
#define	GAME_B6_B7_BYTE			3
#define	GAME_B6_B7_BITS			0x0c
#define	GAME_H0_H3_BYTE			3
#define	GAME_H0_H3_BITS			0xf0

#define	GAME_T0_T5_BYTE			4					// Packet[4] bits
#define	GAME_T0_T5_BITS			0x3f
#define	GAME_B8_B9_BYTE			4
#define	GAME_B8_B9_BITS			0xC0

#define	GAME_B10_BYTE				5					// Packet[5] bits
#define	GAME_B10_BITS				0x01
#define	GAME_ERR_BYTE				5
#define	GAME_ERR_BITS				0x02
#define	GAME_PPO_BYTE				5
#define	GAME_PPO_BITS				0x04

#define	ENH_CLOCK_MIDPACKET		0x0400
#define	ENH_CLOCK_COMPLETE		0x4000

//
//	ID Constants
//

#define	GAME_ID_LOW					0x0d
#define	GAME_ID_HIGH				0x00
#define	GAME_ID_CLOCKS				40

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_Y_MIN				0
#define	EXTENTS_Y_MAX				0x3ff
#define	EXTENTS_T_MIN				0
#define	EXTENTS_T_MAX				0x3f

//
//	Speed Data
//

#define	NUM_ERROR_SAMPLES			100
#define	MIN_ERROR_RATE				5
#define	MAX_ERROR_RATE				15

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{											// @struct SW3DTILT_ID | Sidwinder Pro Tilt Id String
#pragma pack(1)
	UCHAR		Status;					// @field Device status byte
	UCHAR		IdLow;					// @field Device identifier (low byte)
	UCHAR		IdHigh;					// @field Device identifier (high byte)
	USHORT	Version;					// @field Firmware version
#pragma pack()
}	SW3DTILT_ID, *PSW3DTILT_ID;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SW3DTILT_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DTILT_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SW3DTILT_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SW3DTILT_GetId (PPACKETINFO IdPacket);

static	LONG		SW3DTILT_DecrementDevice (PGAMEPORT PortInfo);
static	BOOLEAN	SW3DTILT_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed);

static	NTSTATUS	SW3DTILT_ReadData (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DTILT_Read1Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DTILT_Read3Wide (PPACKETINFO DataPacket);
static	BOOLEAN	SW3DTILT_ValidateData (PUCHAR Packet);
static	VOID		SW3DTILT_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SW3DTILT_ProcessDataError (PGAMEPORT PortInfo, ULONG Error);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SW3DTILT_DriverEntry (VOID);
static	NTSTATUS	SW3DTILT_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DTILT_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SW3DTILT_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SW3DTILT_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SW3DTILT_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	
	// id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// dwX / dwY
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_POINTER,		//	USAGE (Pointer)
	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Linked)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_X,				//	USAGE (X)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_Y,				//	USAGE (Y)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	// dwZ
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_SIMULATION_THROTTLE,//	USAGE (Throttle)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwR
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// dwPOV
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_HATSWITCH,	//	USAGE (Hat switch)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x9F, 0x8C, 0x00, 0x00,			//	LOGICAL_MAXIMUM (35999)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x9f, 0x8C, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (35999)
	HIDP_GLOBAL_UNIT_2,			0x14, 0x00,							//	Unit (English Rot:Angular Pos)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x42,									//	Input (Data,Var,Abs,Null)

	// dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x0A,									//	USAGE_MAXIMUM (Button 10)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	// dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	// END OF COLLECTION
	HIDP_MAIN_ENDCOLLECTION												// END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{		// no buttons; x, y and t centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS),
							GAME_Y0_Y7_BITS,
							((GAME_Y8_Y9_BITS>>1)&GAME_Y8_Y9_BITS),
							((GAME_T0_T5_BITS>>1)&GAME_T0_T5_BITS),
							0
							};
//
//	Raw Id Buffer
//

static	SW3DTILT_ID	RawId	=
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							0,0,0,0						// No status packet used
							};

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_STD,		// Interface mode
							GAME_SPEED_100K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SW3DTILT_DriverEntry,		// DriverEntry
							SW3DTILT_ConnectDevice,		// ConnectDevice
							SW3DTILT_StartDevice,		//	StartDevice
							SW3DTILT_ReadReport,			// ReadReport
							SW3DTILT_StopDevice,			// StopDevice
							NULL								// GetFeature
							};

//
//	Last Valid Data
//
static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{		// no buttons; x, y and r centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS) | GAME_B0_B5_BITS,
							GAME_Y0_Y7_BITS,
							((GAME_Y8_Y9_BITS>>1)&GAME_Y8_Y9_BITS) | GAME_B6_B7_BITS,
							((GAME_T0_T5_BITS>>1)&GAME_T0_T5_BITS) | GAME_B8_B9_BITS,
							GAME_B10_BITS
							};

//
//	Speed Variables
//

static	ULONG			NextSample								=	0;
static	ULONG			NumberSamples							=	0;
static	ULONG			SampleAccumulator						=	0;
static	ULONG			SampleBuffer[NUM_ERROR_SAMPLES]	= {0};

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//
//	Parity problem Fix
//

static	ULONG			LastGoodButtons	=	0;
static	ULONG			PreviousButtons	=	0;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	TiltInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_NORMAL,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DTILT_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"SW3DTILT: SW3DTILT_Calibrate Enter\n"));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.StartTimeout = %ld\n", DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.LowHighTimeout = %ld\n", DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.HighLowTimeout = %ld\n", DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.StartTimeout = %ld\n", IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.LowHighTimeout=%ld\n", IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.HighLowTimeout=%ld\n", IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DTILT: DataInfo.ClockDutyCycle = %ld\n", DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "SW3DTILT: IdInfo.ClockDutyCycle = %ld\n", IdInfo.ClockDutyCycle));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_ResetDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Mode  = IdInfo.Mode  = IMODE_DIGITAL_STD;
	DataInfo.Speed = IdInfo.Speed = GAME_SPEED_66K;

	if (PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		{
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "SW3DTILT_ResetDevice - PulseAndWaitForHandshake failed\n"));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_ReadId (PPACKETINFO IdPacket)
{
	ULONG			B4			=	0L;
	ULONG			Data		=	0L;
	ULONG			Clks		=	0x2002;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_ReadId enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, IdInfo.ClockDutyCycle, 1))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, Clks					; BH,BL = # of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:
		
			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	esi, 1						; and then in data counter
			dec	bh								; decrement clk counter.
			jnz	ID_ClockCheck				; if != 0 then loop
			dec 	bl
			je		ID_Success

			push	esi
			mov	esi, IdInfo.Data
			pop	dword ptr [esi]
			mov	bh, 8
			jmp	ID_ClockCheck

		ID_Success:

			mov	eax, ERROR_SUCCESS
			mov	IdInfo.Mode, IMODE_DIGITAL_STD
			cmp	edi, 3
			jl		ID_Success_1
			mov	IdInfo.Mode, IMODE_DIGITAL_ENH

		ID_Success_1:
		
			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			shr	esi, 24
			mov	ebx, esi
			mov	[edx+4], bl
			jmp	ID_Complete

		ID_Error:

			mov	IdInfo.B4Transitions, edi
			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0
			mov	[edx+4], byte ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	B4, edi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	switch (Clks & 0xFF)
		{
		case	0:
			IdPacket->ClocksSampled = 40;
			break;

		case	1:
			IdPacket->ClocksSampled = 32 + (8-(Clks>>8));
			break;

		case	2:
			IdPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "SW3DTILT_ReadId - SUCCEEDED, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@LowClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@HighClockStart, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@ClockFalling, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadId - TimeOut@ClockRising, Data=%ld,B4=%ld,Clk=%ld\n", Data,B4,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN			Result;
	PSW3DTILT_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_GetId enter\n"));

	if(DataInfo.B4Transitions > 4)
		DataInfo.Mode = IMODE_DIGITAL_ENH;
	else DataInfo.Mode = IMODE_DIGITAL_STD;

	IdPacket->Attempts++;

	Result = SW3DTILT_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSW3DTILT_ID)IdPacket->Data;
		if ((Pnp->IdLow == GAME_ID_LOW) && (Pnp->IdHigh == GAME_ID_HIGH) && ((Pnp->Status&0x7F) == 0))
			{
			//
			// Do AZTECH test here
			//
			if(IdPacket->B4Transitions >= 3)
				{
				MsGamePrint ((DBG_CONTROL, "SW3DTILT_GetId - had B4 transitions\n"));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_ENH;
				}
			else
				{
				//
				// An AZTECH card was detected OR this card didn't seem to support
				// Enhanced mode correctly. Lets reset by going Analog then going
				// digital this should place the device into Standard mode.
				//
				MsGamePrint ((DBG_CONTROL, "SW3DTILT_GetId - 1 Wide Only type card detected\n"));
				SW3DTILT_ResetDevice (&IdPacket->PortInfo);
				TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
				IdPacket->Mode = DataInfo.Mode = IMODE_DIGITAL_STD;		
				}
			}
		else
			{
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_GetId - Id did not match or status error = %ld\n", (ULONG)(Pnp->Status&0x7F)));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Decrements device speed at port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns new device speed
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SW3DTILT_DecrementDevice (PGAMEPORT PortInfo)
{
	LONG	Clks		=	0;
	LONG	Result	=	ERROR_HANDSHAKING;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_DecrementDevice enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		goto DecrementDeviceExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			mov	ebx, 8						; BL = # of clocks to receive.
			xor	eax, eax						; data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		DD_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockStart_1			; N: jump
			loop	DD_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockStart_1:
		
			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	DD_Data						; Y: jump
			loop	DD_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockRise				; N: jump

		;DD_ClockFall:

			mov	ecx, DataInfo.HighLowTimeout

		DD_ClockFall_1:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		DD_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	DD_Complete					; Time out error.

		DD_ClockRise:

			mov	ecx, DataInfo.LowHighTimeout

		DD_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	DD_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	DD_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	DD_Complete					; Time out error.

		DD_Data:

			shr	al, 6							; put data into carry
			rcr	ah, 1							; and then in data counter
			dec	bl								; decrement clk counter.
			jnz	DD_ClockCheck				; if != 0 then loop

		;DD_Success:

			xchg	al, ah
			dec	al								; decrement returned speed
			and	eax, GAME_SPEED_BITS

			cmp	eax, GAME_SPEED_RANGE
			jb		DD_Complete
			dec	al

		DD_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	edi
			pop	esi
		}

	//	--------------------
		DecrementDeviceExit:
	//	--------------------

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_SPEED;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@Handshaking\n"));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@LowClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@HighClockStart, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@ClockFalling, Clk=%ld\n", Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice - TimeOut@ClockRising, Clk=%ld\n", Clks));
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "SW3DTILT_DecrementDevice - SUCCEEDED, Speed=%ld\n", Result));
			break;
		}
	#endif

	MSGAME_PostTransaction (&DataInfo);

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Sets new device speed
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Speed | Desired device speed
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed)
{
	LONG	Result;
	ULONG	Tries;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_SetDeviceSpeed enter\n"));

	//
	// Zero error processing counters
	//

	NextSample			=	0;
	NumberSamples		=	0;
	SampleAccumulator	=	0;
	for (Tries = 0; Tries < NUM_ERROR_SAMPLES; Tries++)
		SampleBuffer[Tries] = 0;

	//
	// Try changing speed only enough times as range
	//

	for (Tries = 0; Tries < GAME_SPEED_RANGE; Tries++)
		{
		if (DataInfo.Speed == Speed)
			return (TRUE);

		Result = SW3DTILT_DecrementDevice (PortInfo);
		if (Result < 0)
			{
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_DecrementDevice failed on %ld attempt\n", (ULONG)Tries));
			return (FALSE);
			}

		DataInfo.Speed = IdInfo.Speed = Result;
		}

	MsGamePrint ((DBG_SEVERE, "SW3DTILT_SetDeviceSpeed failed after %ld attempts\n", (ULONG)Tries));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Reads 1 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_Read1Wide (PPACKETINFO DataPacket)
{
	ULONG	Clks	=	0x2002;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_Read1Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi


			lea	edx, DataInfo.PortInfo	; load gameport adddress

			mov	esi, DataInfo.Data
			xor	edi, edi
			mov	ebx, 2002h
			xor	eax, eax

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Std_ClockStartState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		Std_ClockStartState_1
			loop	Std_ClockStartState		; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_ClockStartState_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	CollectData					; Y: jump
			loop	Std_ClockStartState_1	; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	PacketComplete				; Time out error.

		Std_CheckClkState:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Std_ClockStartRise

		;Std_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Std_ClockFalling:

			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		Std_ClockStartRise		; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockFalling			; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	PacketComplete				; Time out error.

		Std_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Std_ClockRising:

			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	CollectData					; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			loop	Std_ClockRising			; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	PacketComplete				; Time out error.

		CollectData:

			xor	ah, al
			test	ah, DATA1_BIT_MASK		; Q: Data 1 is toggled ?
			jnz	CollectData_1				; N: jump.
			inc	edi							; Y: increment Data 1 count.

		CollectData_1:

			mov	ah, al
			shr	al, 6							; put data into carry
			rcr	DWORD PTR [esi], 1		; and then in data counter
			dec	bh								; Q: 32 bits received ?
			jnz	Std_CheckClkState			; N: continue.
			dec	bl								; dec dword count.
			jz		PacketSuccess				; if dword count = 0 then exit.
			add	esi, 4						; else advance packet pointer
			mov	bh, 11						; set bit counter = 32+11=43.
			jmp	Std_CheckClkState			; stay in receive loop.

		PacketSuccess:

			mov	eax, ERROR_SUCCESS

		PacketComplete:

			mov	Result, eax
			mov	Clks, ebx
			mov	DataInfo.B4Transitions, edi

			pop	esi
			pop	edi
		}

	switch (Clks & 0xFF)
		{
		case	0:
			DataPacket->ClocksSampled = 43;
			break;

		case	1:
			DataPacket->ClocksSampled = 32 + (11-(Clks>>8));
			break;

		case	2:
			DataPacket->ClocksSampled = 32 - (Clks>>8);
			break;
		} 

	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read1Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads 3 wide data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_Read3Wide (PPACKETINFO DataPacket)
{
	LONG	Clks = 1L;
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_Read3Wide enter\n"));

	PORTIO_Write (&DataInfo.PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			lea	edx, DataInfo.PortInfo		; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_MIDPACKET	; Q: in mid-packet ?
			jnz	Enh_MidPacket					; Y: jump.
			test	ebx, ENH_CLOCK_COMPLETE		; Q: is packet complete ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is	 ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_MidPacket:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			xor	edi, edi							; zero out edi.
			shr	al, 2								; move 3rd bit over.
			shrd	edi, eax, 1						; put 3rd bit in 2nd ULONG.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

		Enh_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 19
			mov	word ptr [esi+4], di
			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->LastError = Result;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@LowClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@HighClockStart, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@ClockFalling, Clk=%ld\n", DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_Read3Wide - TimeOut@ClockRising, Clk=%ld\n", DataPacket->ClocksSampled));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport depending on mode
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_ReadData (PPACKETINFO DataPacket)
{
	BOOLEAN		Result	= FALSE;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ReadData enter\n"));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	DataPacket->ClocksSampled = 0;
	DataPacket->B4Transitions = 0;

	switch (DataPacket->Mode)
		{
		case	IMODE_DIGITAL_STD:
			Result = SW3DTILT_Read1Wide (DataPacket);
			break;

		case	IMODE_DIGITAL_ENH:
			Result = SW3DTILT_Read3Wide (DataPacket);
			break;

		default:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadData - unknown interface\n"));
			break;
		}

	DataPacket->TimeStamp	= TIMER_GetTickCount ();
	DataPacket->Transaction	= MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	MSGAME_PostTransaction (DataPacket);

	if (!Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Validates raw packet information
//	@parm		PUCHAR | RawData | Pointer to raw packet data
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SW3DTILT_ValidateData (PUCHAR RawData)
{
	LONG	Result;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ValidateData enter\n"));

	if (RawData[GAME_ERR_BYTE] & GAME_ERR_BITS)
		Result = ERROR_ERRORBITS;
	else if ((RawId.Version >= 0x99) && !DEVICE_IsOddParity (RawData, GAME_PACKET_SIZE))
		Result = ERROR_PARITYBITS;
	else Result = ERROR_SUCCESS;

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_ERRORBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ValidateData - Error bits non-zero\n"));
			break;

		case	ERROR_PARITYBITS:
			MsGamePrint ((DBG_SEVERE, "SW3DTILT_ValidateData - Parity bits failed\n"));
			break;
		}
	#endif

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DTILT_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2, B3, B4;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ProcessData enter\n"));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X8_X9_BYTE] & GAME_X8_X9_BITS;
	Report->dwX <<= 8;
	Report->dwX  |= Data[GAME_X0_X7_BYTE] & GAME_X0_X7_BITS;

	//
	//	Process Y Axis
	//

	Report->dwY   = Data[GAME_Y8_Y9_BYTE] & GAME_Y8_Y9_BITS;
	Report->dwY <<= 8;
	Report->dwY  |= Data[GAME_Y0_Y7_BYTE] & GAME_Y0_Y7_BITS;

	//
	//	Process Z Axis
	//

	Report->dwZ   = Data[GAME_T0_T5_BYTE] & GAME_T0_T5_BITS;

	//
	//	Process Buttons
	//

	B1 = (~Data[GAME_B0_B5_BYTE] & GAME_B0_B5_BITS) >> 2;
	B2 = (~Data[GAME_B6_B7_BYTE] & GAME_B6_B7_BITS) >> 2;
	B3 = (~Data[GAME_B8_B9_BYTE] & GAME_B8_B9_BITS) >> 6;
	//	Swap Buttons 8 and 9
	B3 = ((B3&1)<<1)|((B3&2)>>1);
	B4 = (~Data[GAME_B10_BYTE] & GAME_B10_BITS);

	Report->dwButtons = (B1 | B2<<6 | B3<<8 | B4<<10) & ((1L << GAME_PACKET_BUTTONS) - 1);

	//
	//	Fix parity problem with consecutive buttons
	//

	if (Report->dwButtons != PreviousButtons)
		PreviousButtons = Report->dwButtons;
	else LastGoodButtons = Report->dwButtons;
	Report->dwButtons = LastGoodButtons;

	//
	//	Convert button states to number
	//

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}

	//
	//	Process Hatswitch
	//

	Report->dwPOV = POV_Values[(Data[GAME_H0_H3_BYTE] & GAME_H0_H3_BITS)>>4];
}

//---------------------------------------------------------------------------
// @func		Processes packet results and changes device speed as neccessary
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Error | Error flag (true is error)
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SW3DTILT_ProcessDataError (PGAMEPORT PortInfo, ULONG Error)
{
	ULONG	Average;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ProcessDataError enter\n"));

	//
	// Update running accumulated errors
	//

	SampleAccumulator			-= SampleBuffer[NextSample];
	SampleBuffer[NextSample] = Error;
	SampleAccumulator			+= Error;

	//
	// Increment and wrap next error counter
	//

	if (++NextSample >= NUM_ERROR_SAMPLES)
		NextSample = 0;

	//
	// Increment number samples and exit if not full
	//

	if (NumberSamples < NUM_ERROR_SAMPLES)
		{
		NumberSamples++;
		return;
		}

	//
	// Calculate moving average
	//

	Average = (SampleAccumulator*100)/NumberSamples;

	//
	// Lower speed if too many errors
	//

	if ((Average > MAX_ERROR_RATE) && (DataInfo.Speed > GAME_SPEED_66K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ProcessDataError - average error = %ld\n", Average));
		SW3DTILT_SetDeviceSpeed (PortInfo, DataInfo.Speed-1);
		}

	//
	// Raise speed if too few errors
	//

	else if ((Average < MIN_ERROR_RATE) && (DataInfo.Speed < GAME_SPEED_125K))
		{
		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ProcessDataError - average error = %ld\n", Average));
		SW3DTILT_SetDeviceSpeed (PortInfo, DataInfo.Speed+1);
		}
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"SW3DTILT: SW3DTILT_DriverEntry Enter\n"));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "SW3DTILT_ConnectDevice enter\n"));

	DataInfo.PortInfo = IdInfo.PortInfo = *PortInfo; 

	//
	//	Read and convert registry timing values
	//

  	SW3DTILT_Calibrate (PortInfo);

	//
	// SW3DTILT Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Reset to "known" state
		//

		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ConnectDevice - resetting device\n"));
		SW3DTILT_ResetDevice (&DataInfo.PortInfo);

		//
		// 2. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 3. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "SW3DTILT: DeviceConnectProc getting ID string\n"));

		if (!SW3DTILT_GetId (&IdInfo))
			{
			TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
			continue;
			}

		//
		// 4. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 5. Copy mode from SW3DTILT_GetId result
		//

		DataInfo.Mode = IdInfo.Mode;

		//
		// 6. Set speed to 125k for starters
		//

		MsGamePrint ((DBG_CONTROL, "SW3DTILT: DeviceConnectProc setting device speed\n"));
		SW3DTILT_SetDeviceSpeed (&DataInfo.PortInfo, GAME_SPEED_125K);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 7. Mark device found and return
		//

		TiltInfo.NumDevices = 1;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	TiltInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "SW3DTILT_ReadReport enter\n"));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "SW3DTILT_ReadReport - port collision\n"));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SW3DTILT_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && SW3DTILT_ValidateData (DataInfo.Data))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		SW3DTILT_ProcessDataError (&DataInfo.PortInfo, FALSE);
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "SW3DTILT_ReadReport - invalid packet\n"));
		SW3DTILT_ProcessDataError (&DataInfo.PortInfo, TRUE);
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SW3DTILT_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SW3DTILT_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "SW3DTILT_StartDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SW3DTILT_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "SW3DTILT_StopDevice enter\n"));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//**************************************************************************
#endif	// SAITEK
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\timer.c ===
//**************************************************************************
//
//		TIMER.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	TIMER.C | Timing routines to support device input/output
//**************************************************************************

#include	"msgame.h"

//---------------------------------------------------------------------------
//		Definitions
//---------------------------------------------------------------------------

#define	MILLI_SECONDS				1000L
#define	MICRO_SECONDS				1000000L
#define	TIMER_RESOLUTION			25L
#define	TIMER_CALIBRATE_TRIES	4L
#define	TIMER_CALIBRATE_TIMER	25000L
#define	TIMER_CALIBRATE_PORT		 2500L

//---------------------------------------------------------------------------
//		Private Data
//---------------------------------------------------------------------------

static	ULONG		PerformanceFrequency = 	0L;
static	ULONG		CalibratedResolution	=	0L;

//---------------------------------------------------------------------------
// @func		Converts system ticks into microseconds
//	@parm		ULONG	| Ticks | System ticks in system time
// @rdesc	Returns time in microseconds
//	@comm		Private function
//---------------------------------------------------------------------------

static	ULONG		TIMER_TimeInMicroseconds (ULONG	Ticks)
{
	ULONG				Remainder;
	LARGE_INTEGER	Microseconds;

	Microseconds = RtlEnlargedUnsignedMultiply (Ticks, MICRO_SECONDS);
	Microseconds = RtlExtendedLargeIntegerDivide (Microseconds, PerformanceFrequency, &Remainder);
	return (Microseconds.LowPart);
}

//---------------------------------------------------------------------------
// @func		Times a fixed delay loop of instructions
// @rdesc	Returns delay in microseconds
//	@comm		Private function
//---------------------------------------------------------------------------

static	ULONG		TIMER_CalibrateOnTimer (VOID)
{
	ULONG				Calibration;
	LARGE_INTEGER	StopTicks;
	LARGE_INTEGER	StartTicks;
		
	PORTIO_MaskInterrupts ();
	StartTicks	= KeQueryPerformanceCounter (NULL);
	
	__asm
		{
		mov	ecx, TIMER_CALIBRATE_TIMER
		CalibrationLoop:
		xchg	al, ah
		xchg	al, ah
		dec	ecx
		jne	CalibrationLoop
		}
	StopTicks = KeQueryPerformanceCounter (NULL);
	PORTIO_UnMaskInterrupts ();

	Calibration = TIMER_TimeInMicroseconds (StopTicks.LowPart-StartTicks.LowPart);

	MsGamePrint ((DBG_VERBOSE, "TIMER: TIMER_CalibrateOnTimer Returning %ld uSecs\n", Calibration));
	return (Calibration);
}

//---------------------------------------------------------------------------
// @func		Times a fixed delay loop of port I/O calls
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns delay in microseconds
//	@comm		Private function
//---------------------------------------------------------------------------

static	ULONG		TIMER_CalibrateOnPort (PGAMEPORT PortInfo)
{
	ULONG				Calibration;
	LARGE_INTEGER	StopTicks;
	LARGE_INTEGER	StartTicks;
	
	if (!PORTIO_AcquirePort (PortInfo))
		{
		MsGamePrint ((DBG_SEVERE, "TIMER: TIMER_CalibrateOnPort Could Not Acquire Port\n"));
		return (0);
		}

	PORTIO_MaskInterrupts ();
	StartTicks	= KeQueryPerformanceCounter (NULL);
	
	__asm
		{
		mov	ecx, TIMER_CALIBRATE_PORT
		mov	edx, PortInfo

		CalibrationLoop:

		push	edx
		call	PORTIO_Read

		test	al, al
		dec	ecx
		jne	CalibrationLoop
		}
	StopTicks = KeQueryPerformanceCounter (NULL);
	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	Calibration = TIMER_TimeInMicroseconds (StopTicks.LowPart-StartTicks.LowPart);

	MsGamePrint ((DBG_VERBOSE, "TIMER: TIMER_CalibrateOnPort Returning %ld uSecs\n", Calibration));
	return (Calibration);
}

//---------------------------------------------------------------------------
// @func		Retrieves current system time in milliseconds
// @rdesc	Returns current system time in milliseconds
//	@comm		Public function
//---------------------------------------------------------------------------

ULONG	TIMER_GetTickCount (VOID)
{
	ULONG				Remainder;
	LARGE_INTEGER	TickCount;

	TickCount = KeQueryPerformanceCounter (NULL);
	TickCount = RtlExtendedIntegerMultiply (TickCount, MILLI_SECONDS);
	TickCount = RtlExtendedLargeIntegerDivide (TickCount, PerformanceFrequency, &Remainder);
	return (TickCount.LowPart);
}

//---------------------------------------------------------------------------
// @func		Calibrates the system processor speed for timing delays
// @rdesc	Returns NT status code (Success always)
//	@comm		Public function
//---------------------------------------------------------------------------

NTSTATUS	TIMER_Calibrate (VOID)
{
	ULONG				Tries;
	ULONG				Rounding;
	ULONG				Accumulator;
	LARGE_INTEGER	Frequency;

	KeQueryPerformanceCounter (&Frequency);
	PerformanceFrequency = Frequency.LowPart;
	MsGamePrint ((DBG_VERBOSE, "TIMER: PerformanceFrequency is %ld hz\n", PerformanceFrequency));

	for (Accumulator = 0, Tries = 0; Tries < TIMER_CALIBRATE_TRIES; Tries++)
		Accumulator += TIMER_CalibrateOnTimer ();

	Rounding		= (Accumulator % TIMER_CALIBRATE_TRIES) >= (TIMER_CALIBRATE_TRIES/2) ? 1 : 0;
	Accumulator	= (Accumulator / TIMER_CALIBRATE_TRIES) + Rounding;
	MsGamePrint ((DBG_VERBOSE, "TIMER: Average Timer Calibration is %ld usecs\n", Accumulator));

	Rounding					= ((TIMER_RESOLUTION*TIMER_CALIBRATE_TIMER)/Accumulator) >= (Accumulator/2) ? 1 : 0;
	CalibratedResolution	= ((TIMER_RESOLUTION*TIMER_CALIBRATE_TIMER)/Accumulator) + Rounding;

	MsGamePrint ((DBG_VERBOSE, "TIMER: Calibrated Timer Resolution on %lu msecs is %ld loops\n", TIMER_RESOLUTION, CalibratedResolution));

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Calibrates delays for the system processor speed during port access
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Microseconds | Delay in microseconds to calibrate
// @rdesc	Returns delay in counts for microseconds during port access
//	@comm		Public function
//---------------------------------------------------------------------------

ULONG	TIMER_CalibratePort (PGAMEPORT PortInfo, ULONG Microseconds)
{
	ULONG				Tries;
	ULONG				Errors;
	ULONG				Calibration;
	ULONG				Rounding;
	ULONG				Accumulator;
	LARGE_INTEGER	Frequency;

	KeQueryPerformanceCounter (&Frequency);
	PerformanceFrequency = Frequency.LowPart;
	MsGamePrint ((DBG_VERBOSE, "TIMER: PerformanceFrequency is %ld hz\n", PerformanceFrequency));

	for (Accumulator = 0, Tries = 0, Errors = 0; Tries < TIMER_CALIBRATE_TRIES; Tries++)
		{
		Calibration = TIMER_CalibrateOnPort (PortInfo);
		if (!Calibration)
			Errors++;
		else Accumulator += Calibration;
		}

	Tries -= Errors;

	if (Tries)
		{
		Rounding		= (Accumulator % Tries) >= (Tries/2) ? 1 : 0;
		Accumulator	= (Accumulator / Tries) + Rounding;
		MsGamePrint ((DBG_VERBOSE, "TIMER: Average Port Calibration is %ld usecs\n", Accumulator));

		Rounding		= ((Microseconds*TIMER_CALIBRATE_PORT)/Accumulator) >= (CalibratedResolution/2) ? 1 : 0;
		Accumulator = ((Microseconds*TIMER_CALIBRATE_PORT)/Accumulator) + Rounding;
		MsGamePrint ((DBG_VERBOSE, "TIMER: Calibrated Port Resolution on %lu msecs is %ld loops\n", Microseconds, Accumulator));
		}
	else Accumulator++;

	return (Accumulator);
}

//---------------------------------------------------------------------------
// @func		Convert delays in microseconds to loop counts based on the system processor speed
//	@parm		ULONG | Microseconds | Delay in microseconds to calibrate
// @rdesc	Returns delay in loop counts
//	@comm		Public function
//---------------------------------------------------------------------------

ULONG	TIMER_GetDelay (ULONG Microseconds)
{
	ULONG	Delay;
	ULONG	Rounding;

	Rounding	= ((Microseconds*CalibratedResolution)%TIMER_RESOLUTION)>(TIMER_RESOLUTION/2) ? 1 : 0;
	Delay		= ((Microseconds*CalibratedResolution)/TIMER_RESOLUTION) + Rounding;
	return (Delay?Delay:1);
}

//---------------------------------------------------------------------------
// @func		Delays in loop counts based on the system processor speed
//	@parm		ULONG | Delay | Calibrated delay in loop counts
//	@comm		Public function
//---------------------------------------------------------------------------

VOID	TIMER_DelayMicroSecs (ULONG Delay)
{
	__asm
		{
		mov	ecx, Delay
		DelayLoop:
		xchg	al, ah
		xchg	al, ah
		dec	ecx
		jne	DelayLoop
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\timer.h ===
//**************************************************************************
//
//		TIMER.H -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@header	TIMER.H | Global includes and definitions for timing functions
//**************************************************************************

#ifndef	__TIMER_H__
#define	__TIMER_H__

//---------------------------------------------------------------------------
//			Definitions
//---------------------------------------------------------------------------

#define	T1								100
#define	T2								845
#define	T3								410

#define	ONE_MILLI_SEC				1000
#define	TWO_MILLI_SECS				2000
#define	THREE_MILLI_SECS			3000
#define	FOUR_MILLI_SECS			4000
#define	FIVE_MILLI_SECS			5000
#define	SIX_MILLI_SECS				6000
#define	SEVEN_MILLI_SECS			7000
#define	EIGHT_MILLI_SECS			8000
#define	NINE_MILLI_SECS			9000
#define	TEN_MILLI_SECS				10000

//---------------------------------------------------------------------------
//			Procedures
//---------------------------------------------------------------------------

ULONG
TIMER_GetTickCount (VOID);

NTSTATUS
TIMER_Calibrate (VOID);

ULONG
TIMER_CalibratePort (
	IN		PGAMEPORT	PortInfo,
	IN	 	ULONG			Microseconds
	);

ULONG
TIMER_GetDelay (
	IN		ULONG			Microseconds
	);

VOID	TIMER_DelayMicroSecs (
	IN		ULONG 		Delay
	);

//===========================================================================
//			End
//===========================================================================
#endif	__TIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriver.h ===
#ifndef	__IDirectInputEffectDriver_H__
#define	__IDirectInputEffectDriver_H__

#include <windows.h>
#include <unknwn.h>

#include <dinput.h>
#include "dinputd.h"
extern "C"
{
	#include <hidsdi.h>
}
#include <crtdbg.h>
#include "..\ControlItemCollection\Dualmode.h"
#include "..\ControlItemCollection\Actions.h"		// FORCE_BLOCK

// class IDirectInputEffectDriver;

//class CIDirectInputEffectDriver : public IUnknown
class CIDirectInputEffectDriver
{
	public:
		CIDirectInputEffectDriver(IDirectInputEffectDriver* pIPIDEffectDriver, IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriver();

		//IUnknown members
		virtual HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		virtual ULONG __stdcall AddRef();
		virtual ULONG __stdcall Release();

		//IDirectInputEffectDriver
		virtual HRESULT __stdcall DeviceID(DWORD dwDIVersion, DWORD dwExternalID, DWORD dwIsBegining,
									DWORD dwInternalID, void* pReserved);
		virtual HRESULT __stdcall GetVersions(DIDRIVERVERSIONS* pDriverVersions);
		virtual HRESULT __stdcall Escape(DWORD dwDeviceID, DWORD dwEffectID, DIEFFESCAPE* pEscape);
		virtual HRESULT __stdcall SetGain(DWORD dwDeviceID, DWORD dwGain);
		virtual HRESULT __stdcall SendForceFeedbackCommand(DWORD dwDeviceID, DWORD dwState);
		virtual HRESULT __stdcall GetForceFeedbackState(DWORD dwDeviceID, DIDEVICESTATE* pDeviceState);
		virtual HRESULT __stdcall DownloadEffect(DWORD dwDeviceID, DWORD dwInternalEffectType,
											DWORD* pdwDnloadID, DIEFFECT* pEffect, DWORD dwFlags);
		virtual HRESULT __stdcall DestroyEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall StartEffect(DWORD dwDeviceID, DWORD dwDnloadID, DWORD dwMode,  DWORD dwIterations);
		virtual HRESULT __stdcall StopEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall GetEffectStatus(DWORD dwDeviceID, DWORD dwDnloadID, DWORD* pdwStatusCode);

		void WaitForForceSchemeChange();
	private:
		void InitHidInformation(LPDIHIDFFINITINFO pHIDInitInfo);
		void SendSpringChange();

		DWORD m_dwDIVersion;
		DWORD m_dwExternalDeviceID;
		DWORD m_dwInternalDeviceID;

		ULONG m_ulReferenceCount;
		IDirectInputEffectDriver* m_pIPIDEffectDriver;
		IClassFactory* m_pIPIDClassFactory;
		HANDLE m_hKernelDeviceDriver;
		HANDLE m_hKernelDeviceDriverDuplicate;
		HANDLE m_hHidDeviceDriver;
		DWORD m_dwGcKernelDevice;
		HANDLE m_hForceSchemeChangeWaitThread;
		DWORD m_dwForceSchemeChangeThreadID;
		FORCE_BLOCK m_ForceMapping;
		PHIDP_PREPARSED_DATA m_pPreparsedData;
		HIDD_ATTRIBUTES m_HidAttributes;
		HIDP_CAPS m_HidCaps;
};

extern CIDirectInputEffectDriver* g_IEffectDriverObject;

#endif	__IDirectInputEffectDriver_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriverclassfactory.h ===
#ifndef	__IDirectInputEffectDriverClassFactory_H__
#define	__IDirectInputEffectDriverClassFactory_H__

#include <windows.h>
#include <unknwn.h>
//#include <dinputd.h>

class CIDirectInputEffectDriverClassFactory : public IClassFactory
{
	public:
		CIDirectInputEffectDriverClassFactory(IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriverClassFactory();

		//IUnknown members
		HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		ULONG __stdcall AddRef();
		ULONG __stdcall Release();

		//IClassFactory members
		HRESULT __stdcall CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		HRESULT __stdcall LockServer(BOOL fLock);

	private:
 		ULONG           m_ulLockCount;
		ULONG			m_ulReferenceCount;

		IClassFactory*	m_pIPIDClassFactory;
};

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

#endif	__IDirectInputEffectDriverClassFactory_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriver.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriver.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <WinIOCTL.h>		// For CTL_CODE definition
#include "..\\GCKernel.sys\\GckExtrn.h"
#include <crtdbg.h>
#include <objbase.h>		// For CoUninitialize
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>

const GUID IID_IDirectInputEffectDriver = {
	0x02538130,
	0x898F,
	0x11D0,
	{ 0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35 }
};

extern TCHAR CLSID_SWPIDDriver_String[];

LONG DllAddRef();
LONG DllRelease();

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter);
const DWORD c_dwShutdownWait = 500;		// (0.5 Seconds)

struct DIHIDFFINITINFO_STRUCT {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
};

// PID Defines for Effect Tyoes
#define PID_CONSTANT_FORCE	0x26
#define	PID_RAMP	 		0x27
#define	PID_SQUARE			0x30
#define PID_SINE			0x31
#define	PID_TRIANGLE		0x32
#define	PID_SAWTOOTHUP		0x33
#define	PID_SAWTOOTHDOWN	0x34
#define PID_SPRING			0x40
#define PID_DAMPER			0x41
#define PID_INTERTIA		0x42
#define PID_FRICTION		0x43


struct PercentageEntry
{
	DWORD dwAngle;
	DWORD dwPercentageX;
//	DWORD dwPercentageY; Y == 10000 - X
};

// Array of Fixed value data
const PercentageEntry g_PercentagesArray[] =
{
	// Angle,	Sin^2(Angle)
	{    0,	    0},	// 0 Degrees
	{ 1125,	  381},	// 11.25 Degrees
	{ 2250,	 1465},	// 22.5 Degrees
	{ 3375,	 3087},	// 33.75 Degrees
	{ 4500,	 5000},	// 45 Degrees
	{ 5625,	 6913},	// 56.25 Degrees
	{ 6750,	 8536},	// 67.50 Degrees
	{ 7875,	 9619},	// 78.75 Degrees
	{ 9000,	10000},	// 90 Degrees
};

const DWORD c_dwTableQuantization = g_PercentagesArray[1].dwAngle;
const LONG c_lContributionY = 2;		// (1/2 = 50%)

const BYTE c_bSideWinderPIDReportID_SetEffect = 1;

// Usage Pages (just PID)
const USAGE c_HidUsagePage_PID = 0x0F;

// Usages
const USAGE c_HidUsage_EffectType = 0x25;
const USAGE c_HidUsage_EffectType_Spring = 0x40;
const USAGE c_HidUsage_EffectBlock_Gain = 0x52;
const USAGE c_HidUsage_EffectBlock_Index = 0x22;	// This is the ID of the effect

// Preloaded Effects
const BYTE c_EffectID_RTCSpring = 1;

// Local Debugging Streaming Function that works in release
#undef UseMyDebugOut
void __cdecl myDebugOut (LPCSTR lpszFormat, ...)
{
#ifdef UseMyDebugOut
    //Stolen from inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...) in AtlBase.h
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[1024];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

#ifdef _NDEBUG
	OutputDebugStringA(szBuffer);
#else
    _RPTF0 (_CRT_WARN, szBuffer);
#endif

	va_end(args);
#else
    UNREFERENCED_PARAMETER (lpszFormat);
    return;
#endif
}

/******************** Class CIDirectInputEffectDriver ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriver::CIDirectInputEffectDriver
(
	IDirectInputEffectDriver* pIPIDEffectDriver,		//@parm [IN] Pointer to PID Effect Driver
	IClassFactory* pIPIDClassFactory					//@parm [IN] Pointer to PID Class Factory
) :

	m_ulReferenceCount(1),
	m_dwDIVersion(0xFFFFFFFF),
	m_dwExternalDeviceID(0xFFFFFFFF),
	m_dwInternalDeviceID(0xFFFFFFFF),
	m_pIPIDEffectDriver(pIPIDEffectDriver),
	m_pIPIDClassFactory(pIPIDClassFactory),
	m_hKernelDeviceDriver(NULL),
	m_hKernelDeviceDriverDuplicate(NULL),
	m_hHidDeviceDriver(NULL),
	m_dwGcKernelDevice(0),
	m_hForceSchemeChangeWaitThread(NULL),
	m_dwForceSchemeChangeThreadID(0),
	m_pPreparsedData(NULL)
{
    myDebugOut ("CIDirectInputEffectDriver::Constructor (pIPIDEffectDriver:0x%0p)\n", pIPIDEffectDriver);

	// Add to gobal object count
	DllAddRef();

	// Add references for objects we are holding
	m_pIPIDClassFactory->AddRef();
	m_pIPIDEffectDriver->AddRef();


	::memset((void*)&m_HidAttributes, 0, sizeof(m_HidAttributes));

	m_ForceMapping.AssignmentBlock.CommandHeader.eID = eForceMap;
	m_ForceMapping.AssignmentBlock.CommandHeader.ulByteSize = sizeof(m_ForceMapping);
	m_ForceMapping.AssignmentBlock.ulVidPid = 0;	// Irrelevant
    m_ForceMapping.bMapYToX = FALSE;
	m_ForceMapping.usRTC = 10000;
	m_ForceMapping.usGain = 10000;
}

/*****************************************************************************
**
** CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
{
	_ASSERTE(m_pIPIDEffectDriver == NULL);
	_ASSERTE(m_ulReferenceCount == 0);

	DllRelease();	// Remove our object from the global object count

    myDebugOut ("CIDirectInputEffectDriver::Destructor\n");
}


//IUnknown members
/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an IUnknown for a particular type. This causes reference count increase locally only.
**				If it is a type we don't know, should we give the PID driver a crack (the PID driver
**			might have a customized private interface, we don't want to ruin that). Currently not
**			going to pass on the Query because this could screwup Symmetry.
**
**	@rdesc	S_OK : all is well
**			E_INVALIDARG : if (ppvObject == NULL)
**			E_NOINTERFACE : If requested interface is unsupported
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
    myDebugOut ("CIDirectInputEffectDriver::QueryInterface (refiid:0x%0p, ppvObject:0x%0p)\n", refiid, ppvObject);

	HRESULT hrPidQuery = m_pIPIDEffectDriver->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		// Don't perform a real addref (PID.dll::QueryInterface will do its own)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
		*ppvObject = this;
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::AddRef()
**
**	@func	Bumps up the reference count
**				The PID driver reference count is left alone. We only decrement it when
**				this object is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::AddRef()
{
    myDebugOut ("CIDirectInputEffectDriver::AddRef (Early) 0x%0p\n", m_ulReferenceCount);
	m_pIPIDEffectDriver->AddRef();
	return (ULONG)(::InterlockedIncrement((LONG*)&m_ulReferenceCount));
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::Release()
**
**	@func	Decrements the reference count.
**				if the reference count becomes zero this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::Release()
{
    myDebugOut ("CIDirectInputEffectDriver::Release (Early) 0x%0p\n", m_ulReferenceCount);
	if (m_ulReferenceCount == 0)
	{
		return m_ulReferenceCount;
	}

	if ((::InterlockedDecrement((LONG*)&m_ulReferenceCount)) != 0)
	{
		m_pIPIDEffectDriver->Release();
		return m_ulReferenceCount;
	}


	// Tell the driver to complete outstanding IOCTLs to this device
	if (m_hKernelDeviceDriver == NULL)
	{	// Don't have a handle to PID driver, so open one
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
		}
	}
	if (m_hKernelDeviceDriver != NULL)	// Handle should be open, but check just incase
    {
        DWORD dwReturnDataSize;
        BOOL fSuccess = DeviceIoControl(m_hKernelDeviceDriver, 
            IOCTL_GCK_END_FF_NOTIFICATION,
            (void*)(&m_dwGcKernelDevice), sizeof(DWORD),	// In
            NULL, 0, &dwReturnDataSize,						// Out
            NULL);

        if (!fSuccess)
            myDebugOut ("CIDirectInputEffectDriver::Release : GCK IOCTL_GCK_END_FF_NOTIFICATION failed!\n");
    
        Sleep(c_dwShutdownWait);
        
        ::CloseHandle(m_hKernelDeviceDriver);
    }
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release : Could not Open GCK for IOCTL_GCK_END_FF_NOTIFICATION\n");
    }

	// Free up the preparsed data
	if (m_pPreparsedData != NULL)
	{
		::HidD_FreePreparsedData(m_pPreparsedData);
		m_pPreparsedData = NULL;
	}

	// Close the handle to the HID path of the driver
	::CloseHandle(m_hHidDeviceDriver);
	m_hHidDeviceDriver = NULL;

	// Close the thread handle (which should be done by now)
	if (m_hForceSchemeChangeWaitThread != NULL)
	{
		::CloseHandle(m_hForceSchemeChangeWaitThread);
		m_hForceSchemeChangeWaitThread = NULL;
		m_dwForceSchemeChangeThreadID = 0;
	}
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release() m_hForceSchemeCHangeWaitThread did not finish!\n");
    }

	// Release the low level pid driver and delete ourselves
	m_pIPIDEffectDriver->Release();
	m_pIPIDEffectDriver = NULL;

	// Release the low level factory (include extra release to fix bug in PID.dll)
	if (m_pIPIDClassFactory->Release() > 0)
	{
		m_pIPIDClassFactory->Release();
	}
	m_pIPIDClassFactory = NULL;

	delete this;
	return 0;
}

//IDirectInputEffectDriver members
HRESULT __stdcall CIDirectInputEffectDriver::DeviceID
(
	DWORD dwDIVersion,
	DWORD dwExternalID,
	DWORD dwIsBegining,
	DWORD dwInternalID,
	void* pReserved
)
{
    myDebugOut ("CIDirectInputEffectDriver::DeviceID (dwDIVersion:0x%08p dwExternalID:0x%08p dwIsBeginning:0x%08p dwInternalID:0x%08p pReserved:0x%08p)\n",
        dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Store off some data
	m_dwExternalDeviceID = dwExternalID;
	m_dwInternalDeviceID = dwInternalID;

	bool bPossiblyFirstTime = false;
	// Get a handle to the Kernel Device and activate the thread
	if (m_hKernelDeviceDriver == NULL)
	{
		bPossiblyFirstTime = true;
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
            myDebugOut ("CIDirectInputEffectDriver::DeviceID Create GCK File Failed!\n");
		}
		else
        {
			InitHidInformation((LPDIHIDFFINITINFO)pReserved);		// Set up the HID stuff (preparsed data et al)
            
            if (NULL == pReserved || 
                IsBadReadPtr ((const void*)pReserved, (UINT) sizeof (DIHIDFFINITINFO_STRUCT)) )
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID E_INVALIDARG (pReserved is NULL!)\n");
                return E_INVALIDARG;
                // Call the default guy
                //return m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);
            }
            
            //
			// get the handle for this device
			//
			WCHAR* pwcInstanceName = ((DIHIDFFINITINFO_STRUCT*)(pReserved))->pwszDeviceInterface;
			DWORD dwBytesReturned;
			BOOL fSuccess = ::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_HANDLE,
										pwcInstanceName, ::wcslen(pwcInstanceName)*sizeof(WCHAR),
										&m_dwGcKernelDevice, sizeof(m_dwGcKernelDevice), &dwBytesReturned,
										NULL);

			if (fSuccess != FALSE)
			{
				// Update the force block
				fSuccess =::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_FF_SCHEME_DATA,
										(void*)(&m_dwGcKernelDevice), sizeof(DWORD),
										(void*)(&m_ForceMapping), sizeof(m_ForceMapping), &dwBytesReturned,
										NULL);

				// Get the duplicate handle for the thread
				BOOL bDuplicated = ::DuplicateHandle(::GetCurrentProcess(), m_hKernelDeviceDriver, ::GetCurrentProcess(), &m_hKernelDeviceDriverDuplicate, 0, FALSE, DUPLICATE_SAME_ACCESS);
				if ((m_hKernelDeviceDriverDuplicate == INVALID_HANDLE_VALUE) || (bDuplicated == FALSE))
				{
					m_hKernelDeviceDriverDuplicate = NULL;
				}
				else
				{
					m_hForceSchemeChangeWaitThread = ::CreateThread(NULL, 0, DoWaitForForceSchemeChange, (void*)this, 0, &m_dwForceSchemeChangeThreadID);
				}
			}
            else
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID IOCTL_GCK_GET_HANDLE Failed!\n");
            }

			// Close since I need to reopen at the end (why is this happening?)
			::CloseHandle(m_hKernelDeviceDriver);
			m_hKernelDeviceDriver = NULL;
		}
	}

	// Hack to get PID.DLL to place keys in registry.
	// -- It won't place them if OEM-FF Key is already there
/*
	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			// Open key specific to the current device (VIDPID is in m_HidAttributes)
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			if (hkeyOEMForceFeedback != NULL)
			{
				// Check to see if the effects key is already there
				HKEY hkeyEffects = NULL;
				::RegOpenKeyEx(hkeyOEMForceFeedback, TEXT("Effects"), 0, KEY_READ, &hkeyEffects);
				::RegCloseKey(hkeyOEMForceFeedback);
				if (hkeyEffects != NULL)
				{
					// Effects key is there, this is not the first time we have run
					::RegCloseKey(hkeyEffects);
					bPossiblyFirstTime = false;
				}
				else	// Delete the whole OEM ForceFeedback key
				{
					::RegDeleteKey(hkeyOEM, rgtcDeviceName);
				}
			}
		}
		::RegCloseKey(hkeyOEM);
	}
*/
	// Call the drivers DeviceID (if we have removed the OEMFF Key it will repopulate)
	HRESULT hrPID = m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Do we need to put ourselves back as the DIEffectDriver?
/*	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			// Set the registry CLSID value to us
			if (hkeyOEMForceFeedback != NULL)
			{
				::RegSetValueEx(hkeyOEMForceFeedback, TEXT("CLSID"), 0, REG_SZ, (BYTE*)CLSID_SWPIDDriver_String, _tcslen(CLSID_SWPIDDriver_String) * sizeof(TCHAR));
				::RegCloseKey(hkeyOEMForceFeedback);
			}
			::RegCloseKey(hkeyOEM);
		}
	}
*/
	return hrPID;	// Value from the System PID driver
}

HRESULT __stdcall CIDirectInputEffectDriver::GetVersions
(
	DIDRIVERVERSIONS* pDriverVersions
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetVersions (pDriverVersions:0x%08p)\n", pDriverVersions);
 	return m_pIPIDEffectDriver->GetVersions(pDriverVersions);
}

HRESULT __stdcall CIDirectInputEffectDriver::Escape
(
	DWORD dwDeviceID,
	DWORD dwEffectID,
	DIEFFESCAPE* pEscape
)
{
    myDebugOut ("CIDirectInputEffectDriver::Escape (dwDeviceID:0x%08p, dwEffectID:0x%08p, pEscape:0x%08p)\n", dwDeviceID, dwEffectID, pEscape);
	return m_pIPIDEffectDriver->Escape(dwDeviceID, dwEffectID, pEscape);
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SetGain(DWORD dwDeviceID, DWORD dwGain)
**
**	@func	Modifies the user gain based on settings and sends it down to the lower PID driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SetGain
(
	DWORD dwDeviceID,		//@parm [IN] ID for device of interest
	DWORD dwGain			//@parm [IN] User selected gain
)
{
	dwGain *= m_ForceMapping.usGain/1000;	// 0 - 100K
	dwGain /= 10;							// 0 - 10K
    myDebugOut ("CIDirectInputEffectDriver::SetGain (dwDeviceID:%d, dwGain:%05d:)\n", dwDeviceID, dwGain);
	return m_pIPIDEffectDriver->SetGain(dwDeviceID, dwGain);
}


/***********************************************************************************
**
**	HRESULT CopyW2T(LPWSTR pswDest, UINT *puDestSize, LPTSTR ptszSrc)
**
**	@mfunc	Copies a WCHAR into a TCHAR while checking buffer length
**
**	@rdesc	S_OK on success, MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER)
**			if destination buffer is too small
**
*************************************************************************************/
HRESULT CopyW2T
(
	LPTSTR ptszDest,	// @parm pointer to WCHAR destination buffer
	UINT&  ruDestSize,	// @parm size of dest in WCHAR's
	LPCWSTR pwcszSrc	// @parm pointer to NULL terminated source string
)
{

	UINT uSizeRequired;
	HRESULT hr = S_OK;
	
	uSizeRequired = wcslen(pwcszSrc)+1; //the one is for a NULL character
	if(ruDestSize < uSizeRequired)
	{
		hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER);
	}
	else
	{
		//
		//	we always return wide, but TCHAR can be WCHAR or char
		//	this compile time so use preprocessor
		//
		#ifdef UNICODE 
			wcscpy(ptszDest, pwcszSrc);
		#else
			int iRetVal=WideCharToMultiByte
				(
					CP_ACP,
					0,
					pwcszSrc,
					-1,
					ptszDest,
					ruDestSize,
					NULL,
					NULL
				);
			if(0==iRetVal) 
					hr=GetLastError();
		#endif //UNICODE
	}
	//Copy size required, or chars copied (same thing)
	ruDestSize = uSizeRequired;
	return hr;
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::InitHidInformation(void* HidInformation)
**
**	@func	Open a hid path to the driver, and get preparsed data and hid caps.
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::InitHidInformation
(
	LPDIHIDFFINITINFO pHIDInitInfo	//@parm [IN] Pointer to structure containing the HID device name
)
{
    myDebugOut ("CIDirectInputEffectDriver::InitHidInformation (pHIDInitInfo: 0x%08p)\n", pHIDInitInfo);
	if (pHIDInitInfo != NULL)
	{
		TCHAR ptchHidDeviceName[MAX_PATH];
		unsigned int dwSize = MAX_PATH;
		::CopyW2T(ptchHidDeviceName, dwSize, pHIDInitInfo->pwszDeviceInterface);
		m_hHidDeviceDriver = ::CreateFile(ptchHidDeviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hHidDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hHidDeviceDriver = NULL;
			return;
		}
		if (m_pPreparsedData == NULL)
		{
			::HidD_GetPreparsedData(m_hHidDeviceDriver, &m_pPreparsedData);
			if (m_pPreparsedData == NULL)
			{
				return;
			}
		}
		::HidP_GetCaps(m_pPreparsedData, &m_HidCaps);

		// Find VID/PID the USB way!
		::HidD_GetAttributes(m_hHidDeviceDriver, &m_HidAttributes);
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendSpringChange()
**
**	@func	Sends a new Spring Modify report to the driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::SendSpringChange()
{
    myDebugOut ("CIDirectInputEffectDriver::SendSpringChange ()\n");
	if ((m_hHidDeviceDriver != NULL) && (m_pPreparsedData != NULL))
	{
		// Setup the spring report
		// 1. Allocate an array of max output size
		BYTE* pbOutReport = new BYTE[m_HidCaps.OutputReportByteLength];
		if (pbOutReport == NULL)
		{
			return;
		}
		// 2. Zero out array
		::memset(pbOutReport, 0, m_HidCaps.OutputReportByteLength);
		// 3. Set the proper report ID
		pbOutReport[0] = c_bSideWinderPIDReportID_SetEffect;
		// 4. Cheat since we know what the firmware is expecting (Use usage Gunk where easy)
		pbOutReport[1] = c_EffectID_RTCSpring;	// Effect Block Index (ID)
		unsigned short usRTC = m_ForceMapping.usRTC;	// 0 - 10K
		usRTC /= 100;									// 0 - 100
		usRTC *= 255;									// 0 - 25500
		usRTC /= 100;									// 0 - 255
		if (usRTC > 255)
		{
			usRTC = 255;
		}
		pbOutReport[9] = BYTE(usRTC);		// Effect Gain - Only item the RTC Spring will look at
		// Now that the firmware has change for Godzilla it looks at bunches o stuff
		pbOutReport[7] = 1;  //sample period
		pbOutReport[11] =132;  //direction-axis + FW only force polar flag
		pbOutReport[13] = 255; //Y - direction

        myDebugOut ("CIDirectInputEffectDriver::SendSpringChange -> usRTC:%03d\n", usRTC);

		// 5. Send the report down
		DWORD dwBytesWritten;
		::WriteFile(m_hHidDeviceDriver, pbOutReport, m_HidCaps.OutputReportByteLength, &dwBytesWritten, NULL);

		// 6. Deallocate report array
		delete[] pbOutReport;
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendForceFeedbackCommand()
**
**	@func	Intercepting this call gives us the chance to set the force level of the
**			RTC Spring after a reset
**
**	@rdesc	Result of SendForceFeedbackCommand (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SendForceFeedbackCommand
(
	DWORD dwDeviceID,		//@parm [IN] ID of device this is for
	DWORD dwState			//@parm [IN] The command (we are interested in reset)
)
{
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Enter (dwDeviceID:%x, dwState:0x%08p)\n", dwDeviceID, dwState);
	HRESULT hr = m_pIPIDEffectDriver->SendForceFeedbackCommand(dwDeviceID, dwState);
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Calling Base (hr:0x%08p)\n", hr);
	if (dwState == DISFFC_RESET)	// This is how they turn on the RTC Spring
	{
        myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand RESET sent!\n");
		SendSpringChange();
	}

	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::GetForceFeedbackState
(
	DWORD dwDeviceID,
	DIDEVICESTATE* pDeviceState
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState Begin (dwDeviceID:%d, pDeviceState:0x%08p)\n", dwDeviceID, pDeviceState);
	HRESULT hrPidDriver = S_OK;

	__try
	{
		hrPidDriver = m_pIPIDEffectDriver->GetForceFeedbackState(dwDeviceID, pDeviceState);
		//
		// Invert safety switch and user FF switch bits to compensate for PID/DI mismatch
		// which caused Fighter Ace II to ignore X/Y axes.
		// Note IF clause which will cause fix to be ignored if DI fixes it
		//
		if (pDeviceState->dwState & DIGFFS_USERFFSWITCHOFF)
			pDeviceState->dwState=pDeviceState->dwState^(DIGFFS_SAFETYSWITCHON|DIGFFS_SAFETYSWITCHOFF|DIGFFS_USERFFSWITCHON|DIGFFS_USERFFSWITCHOFF);

	}
	__except ((GetExceptionCode() == EXCEPTION_INT_DIVIDE_BY_ZERO) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		hrPidDriver = DIERR_INPUTLOST;
		_RPT0(_CRT_WARN, "!!! Caught EXCEPTION_INT_DIVIDE_BY_ZERO !!!\n");
	}

    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState End (dwDeviceID:%d, pDeviceState:0x%08p; hr: 0x%08x)\n", 
        dwDeviceID, pDeviceState, hrPidDriver);

	return hrPidDriver;
}

/***********************************************************************************
**
**	void PercentagesFromAngle()
**
**	@func	Extrapolate the percentages from the table. Makes use of the fact that
**			sin^2(angle) + cos^2(angle) = 1 and xPercentage + yPercentage = 1
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
void PercentagesFromAngle
(
	DWORD dwAngle,		//@parm [IN] Angle to convert to percentages
	LONG& lXPercent,	//@parm [OUT] Resultant X Percentage
	LONG& lYPercent		//@parm [OUT] Resultant Y Percentage
)
{
	// Get the angle mapping into the first quadrant
	DWORD dwMappingAngle = dwAngle;	// 0 - 9000
	bool bFlipSignX = false;	// X is negative in 3rd and 4th quadrants
	bool bFlipSignY = true;		// Y is negative in 1st and 4th quadrants
	if (dwAngle > 9000)
	{
		bFlipSignY = false;
		if (dwAngle > 18000)
		{
			bFlipSignX = true;
			if (dwAngle > 27000)	// 27000 - 36000
			{
				bFlipSignY = true;
				dwMappingAngle = 36000 - dwAngle;
			}
			else	// 18000 - 27000
			{
				dwMappingAngle = dwAngle - 18000;
			}
		}
		else	// 9000 - 18000
		{
			dwMappingAngle = 18000 - dwAngle;
		}
	}

	_ASSERTE(dwMappingAngle <= 9000);

	DWORD quantizedEntry = dwMappingAngle / c_dwTableQuantization;
	DWORD quantizedAngle = quantizedEntry * c_dwTableQuantization;
	if (dwMappingAngle == quantizedAngle)
	{
		lXPercent = g_PercentagesArray[quantizedEntry].dwPercentageX;
	}
	else
	{
		_ASSERTE(quantizedAngle < dwMappingAngle);
		_ASSERTE(dwMappingAngle < 9000);

		DWORD lValue = g_PercentagesArray[quantizedEntry].dwPercentageX;
		DWORD rValue = g_PercentagesArray[quantizedEntry + 1].dwPercentageX;
		long int lSlope = ((rValue - lValue) * 1000)/c_dwTableQuantization;
		lXPercent = lValue + lSlope * (dwMappingAngle - quantizedAngle);
	}

	lYPercent = 10000 - lXPercent;
	if (bFlipSignX == true)
	{
		lXPercent *= -1;
	}
	if (bFlipSignY == true)
	{
		lYPercent *= -1;
	}
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::DownloadEffect()
**
**	@func	Intercepting this call gives us the chance to map the Y forces to the X
**			axis. Switches off the type to determine if the mapping is done.
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::DownloadEffect
(
	DWORD dwDeviceID,				//@parm [IN] ID of device this is for
	DWORD dwInternalEffectType,		//@parm [IN] Type of effect (major, minor)
	DWORD* pdwDnloadID,				//@parm [IN, OUT] >0 - ID of effect to modify. 0 new effect ID returned
	DIEFFECT* pEffect,				//@parm [IN, OUT] Structure containing effect information
	DWORD dwFlags					//@parm [IN] Download flags
)
{
    myDebugOut ("CIDirectInputEffectDriver::DownloadEffect (<NOT DEBUGGED>)\n");

	if (pEffect == NULL)
	{
		return E_INVALIDARG;
	}

	WORD wType = WORD(dwInternalEffectType & 0x0000FFFF);
	bool bGainTruncation = false;

//	case EF_BEHAVIOR:		// We don't axis-map behaviour
//	case EF_USER_DEFINED:	// We don't axis-map user defined
//	case EF_RTC_SPRING:		// We don't axis-map RTC spring
//	case EF_VFX_EFFECT:		// Visual force VFX Effect!!! Danger Will Robinson!
	if ((m_ForceMapping.bMapYToX) && ((wType >= PID_CONSTANT_FORCE) && (wType <= PID_SAWTOOTHDOWN)))
	{
		// We don't support more than 2 axes (currently), and 0 is probably an error
		if ((pEffect->cAxes > 2) || (pEffect->cAxes == 0))
		{
			return E_NOTIMPL;
		}

		// We don't support sperical (3 axis force)
		if (pEffect->dwFlags & DIEFF_SPHERICAL)
		{
			return E_NOTIMPL;	 // .. since got by axis check, programmer goofed up anyway
		}

		// Are the axes reversed?
		bool bAxesReversed = (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1);

		LONG lPercentX = 0;
		LONG lPercentY = 0;

		// Polar, figure out percentage that is X and percentage that is Y
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			if (pEffect->cAxes == 1)	// Polar coordinate must have two axes of data (because DX says so)
			{
				_RPT0(_CRT_WARN, "POLAR effect that has only one AXIS\n");
//				return E_INVALIDARG;
			}
			long int lEffectAngle = pEffect->rglDirection[0];	// in [0] even if reversed
			if (bAxesReversed == true) {	// Indicates (-1, 0) as origin instead of (0, -1)
				lEffectAngle += 27000;
			}
			while (lEffectAngle < 0)	// Make it positive
			{
				lEffectAngle += 36000;
			}
			lEffectAngle %= 36000;	// Make it from 0 to 35900

			PercentagesFromAngle(DWORD(lEffectAngle), lPercentX, lPercentY);

			// Not going to bother reseting the angle, since PID.dll just sends it down and wheel ignores Y component
		}
		else if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			// Here I remove the Y component in case PID.dll maps this to an angle.
			if (bAxesReversed == true)
			{
				lPercentX = pEffect->rglDirection[1];
				lPercentY = pEffect->rglDirection[0];
				pEffect->rglDirection[0] = 0;
			}
			else
			{
				lPercentX = pEffect->rglDirection[0];
				lPercentY = pEffect->rglDirection[1];
				pEffect->rglDirection[1] = 0;
			}
			LONG lTotal = abs(lPercentX) + abs(lPercentY);
            // DIV ZERO Bug
            // If both of the percentages are zero then do nothing
            // Jen-Hung Ho
            if (lTotal)
            {
                lPercentX = (lPercentX * 10000)/lTotal;
				if ( lPercentY > 0 )
                	lPercentY = 10000 - abs(lPercentX);
				else
					lPercentY = abs(lPercentX) - 10000;
            }
		}
		else
		{
			_ASSERTE(FALSE);
			return E_NOTIMPL;	// Some new fangled coordinate system
		}
#if 0	// tempory remove by Jen-Hung Ho
		long int lContributionY = lPercentY/c_lContributionY;
		long int lTotal = lPercentX + lContributionY;
#else
		long int lTotal;
		long int lContributionY = lPercentY/c_lContributionY;
#endif

		// If POLAR set proper angle
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Keep as orginal code, add by Jen-Hung Ho
			lTotal = lPercentX + lContributionY;
			if (lTotal < 0)
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 0 : 27000;
			}
			else
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 18000 : 9000;
			}
		}
		else	// Cartesian
		{	 
			// use X axis force to determain direction, add by Jen-Hung Ho
			// Y axis force follow X axis direction
			if ( lPercentX > 0 )
				lTotal = lPercentX + abs(lContributionY);
			else if ( lPercentX < 0 )
				lTotal = lPercentX - abs(lContributionY);
			else
				lTotal = lContributionY;

			// Already removed Y above
			if (bAxesReversed == true)
			{
				pEffect->rglDirection[1] = lTotal;
			}
			else
			{
				pEffect->rglDirection[0] = lTotal;
			}
		}

		// Allmost all the time we are changing the angle (and pid always sends it anyways)
		dwFlags |= DIEP_DIRECTION;

		// We avoid causing truncation - what if there was truncation? Need to check and return
		if (pEffect->dwGain > 10000)
		{
			bGainTruncation = true;
		}

		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Modify the gain based on lPercentX and lPercentY
			pEffect->dwGain = pEffect->dwGain * abs(lTotal);
			pEffect->dwGain /= 10000;	// Put back in range 0 - 10000
		}

		// Make sure we don't go out of range and cause DI_TRUNCATED to be returned from below
		if (pEffect->dwGain > 10000)	
		{
			pEffect->dwGain = 10000;
		}
	}
	else	// We are not mapping fix cartesian pid bug
	{
		// Cartesian
		if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			short int xAxisIndex = 0;
			short int yAxisIndex = 1;

			// Are the axes reversed?
			if (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1)
			{
				xAxisIndex = 1;
				yAxisIndex = 0;
			}

			LONG lTotal = abs(pEffect->rglDirection[0]) + abs(pEffect->rglDirection[1]);

			// Fixup the X component so the total maginitude is base on 10K
            if (lTotal)
            {
				pEffect->rglDirection[xAxisIndex] = (10000 * pEffect->rglDirection[xAxisIndex])/lTotal;
            }

			// Remove the Y component to keep PID.dll from playing with it.
			pEffect->rglDirection[yAxisIndex] = 0;
		}
	}

	HRESULT hr = m_pIPIDEffectDriver->DownloadEffect(dwDeviceID, dwInternalEffectType, pdwDnloadID, pEffect, dwFlags);
	if ((hr == S_OK) && (bGainTruncation == true))
	{
		hr = DI_TRUNCATED;
	}
	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::DestroyEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Enter(dwDeviceID:%d, dwDnloadID:%d)\n", 
        dwDeviceID, dwDnloadID);

    HRESULT hr = m_pIPIDEffectDriver->DestroyEffect(dwDeviceID, dwDnloadID);
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Exit (hr:0x%08p)\n", hr); 
    return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::StartEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD dwMode,
	DWORD dwIterations
)
{
    myDebugOut ("CIDirectInputEffectDriver::StartEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StartEffect(dwDeviceID, dwDnloadID, dwMode, dwIterations);
}

HRESULT __stdcall CIDirectInputEffectDriver::StopEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::StopEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StopEffect(dwDeviceID, dwDnloadID);
}

HRESULT __stdcall CIDirectInputEffectDriver::GetEffectStatus
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD* pdwStatusCode
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetEffectStatus (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->GetEffectStatus(dwDeviceID, dwDnloadID, pdwStatusCode);
}

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter)
{
    myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange (pParameter: 0x%08p)\n", pParameter);

	CIDirectInputEffectDriver* pIDirectInputEffectDriver = (CIDirectInputEffectDriver*)pParameter;
    //TODO remove this it could be really slow!
    if (IsBadReadPtr ((const void*)pParameter, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange pParameter is not a valid read ptr!\n");
    }
	if (pIDirectInputEffectDriver != NULL)
	{
		pIDirectInputEffectDriver->WaitForForceSchemeChange();
	}

	return 0;
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::WaitForForceSchemeChange()
**
**	@func	Thread waits on the Event signal for force scheme change until the object goes away.
**			If event is signaled, WaitForForceSchemeChange() is called
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::WaitForForceSchemeChange()
{
	_ASSERTE(m_hKernelDeviceDriverDuplicate != NULL);
    if (IsBadReadPtr ((const void*)this, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver WaitForForceSchemeChange is not a valid read ptr!\n");
    }

	FORCE_BLOCK forceMap;
	DWORD dwReturnDataSize = 0;
	for (;m_ulReferenceCount != 0;)
	{
		// Set up the IOCTL
		BOOL bRet = ::DeviceIoControl(m_hKernelDeviceDriverDuplicate, IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE,
							(void*)(&m_dwGcKernelDevice), sizeof(DWORD),					// In
							(void*)(&forceMap), sizeof(forceMap), &dwReturnDataSize,		// Out
							NULL);
		_RPT0(_CRT_WARN, "Returned from Scheme Change!\n");
		if ((m_ulReferenceCount != 0) && (bRet != FALSE) && (dwReturnDataSize == sizeof(forceMap)))
		{
			// Need a mutext here
			m_ForceMapping = forceMap;
			SendSpringChange();
			SetGain(m_dwInternalDeviceID, 10000);
		}
		else
		{	// We are done
			::CloseHandle(m_hKernelDeviceDriverDuplicate);
			m_hKernelDeviceDriverDuplicate = NULL;
			ExitThread(2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\idirectinputeffectdriverclassfactory.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriverClassFactory.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <crtdbg.h>
#include <objbase.h>

LONG DllAddRef();
LONG DllRelease();

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

/******************** Class CIDirectInputEffectDriverClassFactory ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory
(
	IClassFactory* pIPIDClassFactory		//@parm [IN] Default PID Factory
) :
	m_ulLockCount(0),
	m_ulReferenceCount(1),
	m_pIPIDClassFactory(pIPIDClassFactory)
{
	// Increase global object count
	DllAddRef();

	// Add count to held object
	m_pIPIDClassFactory->AddRef();
}

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
{
	// Decrease Global object count
	DllRelease();

	_ASSERTE(m_pIPIDClassFactory == NULL);
	_ASSERTE(m_ulLockCount == 0);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an Unknown for a particular type. This causes increase locally only
**				If it is a type we don't know, should we give the PID factory a crack (PID factory
**			might have a customized private interface, we don't want to ruin that. Currently not
**			going to pass on the Query, because this could screwup Symmetry.
**
**	@rdesc	S_OK if all is well, E_INVALIDARG if ppvObject is NULL or E_NOINTERFACE
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
	HRESULT hrPidQuery = m_pIPIDClassFactory->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		*ppvObject = this;
		// Increase our reference count only (pid class fact would be incremented by AddRef call)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::AddRef()
**
**	@func	Bumps up the reference count
**				The PID Factory reference count is left alone. We only decrement it when
**				this factory is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::AddRef()
{
	m_pIPIDClassFactory->AddRef();
	return (ULONG)::InterlockedIncrement((LONG*)&m_ulReferenceCount);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::Release()
**
**	@func	Decrements the reference count.
**				If both the reference count and the lock count are zero the PID Factory is
**				released and this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::Release()
{
	m_pIPIDClassFactory->Release();

	if (::InterlockedDecrement((LONG*)&m_ulReferenceCount) != 0)
	{
		return m_ulReferenceCount;
	}

	m_pIPIDClassFactory = NULL;
	g_pClassFactoryObject = NULL;
	delete this;

	return 0;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void** ppvObject)
**
**	@func	Create an instance of the object
**				Also tells the PID factory to create an instance, this is stored in our instance.
**			
**
**	@rdesc	S_OK if intstance is created
**			E_INVALIDARG if (ppvObject == NULL)
**			CLASS_E_NOAGGREGATION  if aggrigation is attempted (pUnkOuter != NULL)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::CreateInstance
(
	IUnknown* pUnkOuter,	//@parm [IN] Aggregate class or NULL
	REFIID riid,			//@parm [IN] IID of Object to create
	void** ppvObject		//@parm [OUT] Address to place the requested object
)
{
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	if (ppvObject == NULL)
	{
		return E_INVALIDARG;
	}

	if (riid == IID_IDirectInputEffectDriver)
	{
		// Let the PID Factory Create its driver
		IDirectInputEffectDriver* pPIDDriver = NULL;
		HRESULT hrPID = m_pIPIDClassFactory->CreateInstance(pUnkOuter, riid, (void**)(&pPIDDriver));
		if (FAILED(hrPID) || (pPIDDriver == NULL))
		{
			return hrPID;
		}


		// Create our effect driver
		*ppvObject = new CIDirectInputEffectDriver(pPIDDriver, m_pIPIDClassFactory);

		pPIDDriver->Release();	// We no longer care about this (held in our CIDirectInputEffectDriver)

		if (*ppvObject == NULL)
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	return E_NOINTERFACE;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
**
**	@func	Lock this factory down (prevents Release from causing deletion)
**				If Unlocked compleatly (m_ulLockCount becomes 0) and reference count
**			is at 0 - this Factory is destroyed (and the PID factory is released)
**
**	@rdesc	S_OK : All is well
**			E_UNEXPECTED: Unlock on non-locked object
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::LockServer
(
	BOOL fLock		//@parm [IN] Is the server being locked or unlocked
)
{
	HRESULT hrPidLock = m_pIPIDClassFactory->LockServer(fLock);

	if (FAILED(hrPidLock))
	{
		return hrPidLock;
	}
	if (fLock != FALSE)
	{
		::InterlockedIncrement((LONG*)&m_ulLockCount);
		return S_OK;
	}

	if (m_ulLockCount == 0)
	{
		return E_UNEXPECTED;
	}

	::InterlockedDecrement((LONG*)&m_ulLockCount);

	return hrPidLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\msgame\swledzep.c ===
//**************************************************************************
//
//		SWLEDZEP.C -- Xena Gaming Project
//
//		Version 3.XX
//
//		Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//
//		@doc
//		@module	SWLEDZEP.C | Gameport mini-driver for Sidewinder LedZep Force Feedback
//**************************************************************************

#include	"msgame.h"
#include	"swforce.h"

//---------------------------------------------------------------------------
//	Definitions
//---------------------------------------------------------------------------

#ifdef	SAITEK
#define	DEVICENAME					"SAIWHEEL"
#define	DEVICE_PID					0x0016
#define	HARDWARE_ID					L"Gameport\\SaiTekForceFeedbackWheel\0\0"
#else
#define	DEVICENAME					"SWLEDZEP"
#define	DEVICE_PID					0x0015
#define	HARDWARE_ID					L"Gameport\\SideWinderForceFeedbackWheel\0\0"
#endif

//
//	Packet Constants
//

#define	GAME_PACKET_SIZE			5
#define	GAME_PACKET_BUTTONS		8
#define	GAME_PACKET_AXIS			4

#define	GAME_X0_X7_BYTE			0					// Packet[0] bits
#define	GAME_X0_X7_BITS			0xff

#define	GAME_X8_X9_BYTE			1					// Packet[1] bits
#define	GAME_X8_X9_BITS			0x03
#define	GAME_YA0_YA5_BYTE			1
#define	GAME_YA0_YA5_BITS			0xfc

#define	GAME_YB0_YB5_BYTE			2					// Packet[2] bits
#define	GAME_YB0_YB5_BITS			0x3f
#define	GAME_B0_B1_BYTE			2
#define	GAME_B0_B1_BITS			0xc0

#define	GAME_B2_B8_BYTE			3					// Packet[3] bits
#define	GAME_B2_B8_BITS			0x7f
#define	GAME_ERR_BYTE				3
#define	GAME_ERR_BITS				0x80

#define	GAME_PPO_BYTE				4					// Packet[4] bits
#define	GAME_PPO_BITS				0x01

#define	ENH_CLOCK_COMPLETE		0x0400

//
//	ID Constants
//

#define	GAME_ID_CLOCKS				8

//
//	Status Constants
//

#define	STATUS_CLOCK_COMPLETE	0x0040

//
//	Timing Constants
//

#define	PACKET_START_TIMEOUT		500
#define	PACKET_LOWHIGH_TIMEOUT	75
#define	PACKET_HIGHLOW_TIMEOUT	150
#define	ID_START_TIMEOUT			500
#define	ID_LOWHIGH_TIMEOUT		75
#define	ID_HIGHLOW_TIMEOUT		150
#define	MAX_CLOCK_DUTY_CYCLE		50
#define	STATUS_START_TIMEOUT		500
#define	STATUS_LOWHIGH_TIMEOUT	75
#define	STATUS_HIGHLOW_TIMEOUT	150
#define	STATUS_GATE_TIMEOUT		3000

//
//	Joystick Extents
//

#define	EXTENTS_X_MIN				0
#define	EXTENTS_X_MAX				0x3ff
#define	EXTENTS_YA_MIN				0
#define	EXTENTS_YA_MAX				0x3f
#define	EXTENTS_YB_MIN				0
#define	EXTENTS_YB_MAX				0x3f

//
//	Speed Data
//

#define	NUM_ERROR_SAMPLES			100
#define	MIN_ERROR_RATE				5
#define	MAX_ERROR_RATE				15

//---------------------------------------------------------------------------
//	Types
//---------------------------------------------------------------------------

typedef	struct
{
#pragma pack(1)
	ULONG		ProductId:12;			// @field Device identifier
	ULONG		Version:11;				// @field Firmware version
	ULONG		OddParityBit:1;		// @field Parity bit (odd)
	ULONG		Unused:8;				// @field unused
#pragma pack()
}	SWLEDZEP_ID, *PSWLEDZEP_ID;

typedef	struct
{											// @struct SWLEDZEP_STATUS | Sidwinder Wheel Status
#pragma pack(1)
	ULONG		Effect:7;				// @field Last effect
	ULONG		Status:13;				// @field Status flags
	ULONG		Parity:1;				// @field Parity bit (odd)
	ULONG		Unused:8;				// @field unused
#pragma pack()
}	SWLEDZEP_STATUS, *PSWLEDZEP_STATUS;

//---------------------------------------------------------------------------
//	Procedures
//---------------------------------------------------------------------------

static	VOID		SWLEDZEP_Calibrate (PGAMEPORT PortInfo);
static	BOOLEAN	SWLEDZEP_ResetDevice (PGAMEPORT PortInfo);

static	BOOLEAN	SWLEDZEP_ReadId (PPACKETINFO IdPacket);
static	BOOLEAN	SWLEDZEP_GetId (PPACKETINFO IdPacket);

static	BOOLEAN	SWLEDZEP_ReadStatus (PPACKETINFO StatusPacket);
static	BOOLEAN	SWLEDZEP_GetStatus (PPACKETINFO StatusPacket);

static	NTSTATUS	SWLEDZEP_ReadData (PPACKETINFO DataPacket);
static	VOID		SWLEDZEP_ProcessData (UCHAR Data[], PDEVICE_PACKET Report);
static	VOID		SWLEDZEP_ProcessDataError (PGAMEPORT PortInfo, ULONG Error);

static	LONG		SWLEDZEP_DecrementDevice (PGAMEPORT PortInfo);
static	BOOLEAN	SWLEDZEP_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed);

static	NTSTATUS	SWLEDZEP_ForceReset (PGAMEPORT PortInfo);
static	NTSTATUS	SWLEDZEP_ForceId (PGAMEPORT PortInfo, PVOID IdString);
static	NTSTATUS	SWLEDZEP_ForceStatus (PGAMEPORT PortInfo, PVOID Status);
static	NTSTATUS	SWLEDZEP_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak);
static	NTSTATUS	SWLEDZEP_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck);
static	NTSTATUS	SWLEDZEP_ForceSync (PGAMEPORT PortInfo, PULONG Sync);

//---------------------------------------------------------------------------
//	Services
//---------------------------------------------------------------------------

static	NTSTATUS	SWLEDZEP_DriverEntry (VOID);
static	NTSTATUS	SWLEDZEP_ConnectDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWLEDZEP_StartDevice (PGAMEPORT PortInfo);
static	NTSTATUS	SWLEDZEP_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report);
static	NTSTATUS	SWLEDZEP_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware);
static	NTSTATUS	SWLEDZEP_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned);

//---------------------------------------------------------------------------
//	Alloc_text pragma to specify routines that can be paged out.
//---------------------------------------------------------------------------

#ifdef	ALLOC_PRAGMA
#pragma	alloc_text (INIT, SWLEDZEP_DriverEntry)
#endif

//---------------------------------------------------------------------------
//	Private Data
//---------------------------------------------------------------------------

//
//	HID Descriptors
//

#define	HID_USAGE_VEHICLE_STEERING		((USAGE) 0xC8)
#define	HID_USAGE_VEHICLE_ACCELERATOR	((USAGE) 0xC4)
#define	HID_USAGE_VEHICLE_BRAKE			((USAGE) 0xC5)

static UCHAR ReportDescriptor[] =
{
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_GENERIC,			//	USAGE_PAGE (Generic Desktop)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	//---------------------------------------------------------------------------
	// JOYINFOEX
	//---------------------------------------------------------------------------

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_APP,		//	COLLECTION (Application)
	HIDP_REPORT_ID_1,				MSGAME_INPUT_JOYINFOEX,

	//	id
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	do_other
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	// dwX
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_VEHICLE_STEERING,	// USAGE (Steering)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	LOGICAL_MAXIMUM (1023)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0xFF, 0x03, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (1023)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	// dwY
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_VEHICLE_ACCELERATOR,//  USAGE (Accelerator)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (16)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//	dwZ
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	dwR
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_SIMULATION,		//	USAGE_PAGE (Simulation Controls)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_VEHICLE_BRAKE,		//  USAGE (Brake)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	LOGICAL_MAXIMUM (63)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_4,		0x3F, 0x00, 0x00, 0x00,			//	PHYSICAL_MAXIMUM (63)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (16)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)
	
	//	dwU
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//	dwPOV
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)

	//	dwButtons
	HIDP_GLOBAL_USAGE_PAGE_1,	HID_USAGE_PAGE_BUTTON,			//	USAGE_PAGE (Button)
	HIDP_LOCAL_USAGE_MIN_1,		0x01,									//	USAGE_MINIMUM (Button 1)
	HIDP_LOCAL_USAGE_MAX_1,		0x09,									//	USAGE_MAXIMUM (Button 9)
	HIDP_GLOBAL_LOG_MIN_1,		0x00,									//	LOGICAL_MINIMUM (0)
	HIDP_GLOBAL_LOG_MAX_1,		0x01,									//	LOGICAL_MAXIMUM (1)
	HIDP_GLOBAL_PHY_MIN_1,		0x00,									//	PHYSICAL_MINIMUM (0)
	HIDP_GLOBAL_PHY_MAX_1,		0x01,									//	PHYSICAL_MAXIMUM (1)
	HIDP_GLOBAL_UNIT_2,			0x00, 0x00,							//	UNIT (None)
	HIDP_GLOBAL_REPORT_SIZE,	0x01,									//	REPORT_SIZE (1) 
	HIDP_GLOBAL_REPORT_COUNT_1,0x20,									//	REPORT_COUNT (32)
	HIDP_MAIN_INPUT_1,			0x02,									//	INPUT (Data,Var,Abs)

	//	dwButtonNumber
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_MAIN_INPUT_1,			0x01,									//	INPUT (Cnst,Ary,Abs)
	
	//---------------------------------------------------------------------------
	// GetID
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETID,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x00,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwProductID
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x01,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwFWVersion
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x02,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetStatus
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSTATUS,

	// cBytes
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x03,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)
	
	// dwXVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x04,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYVel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x05,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwXAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x06,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwYAccel
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x07,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwEffect
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x08,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	// dwDeviceStatus
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x09,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetAckNak
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETACKNAK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0A,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	//	GetNakAck
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETNAKACK,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0B,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetSync
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETSYNC,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0C,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	
	//---------------------------------------------------------------------------
	// DoReset
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_RESET,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0D,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x03,									//	FEATURE (Cnst,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION

	//---------------------------------------------------------------------------
	// GetVersion
	//---------------------------------------------------------------------------

	HIDP_GLOBAL_USAGE_PAGE_2,	0x00, 0xff,							//	USAGE_PAGE (Vendor Specific)
	HIDP_LOCAL_USAGE_1,			HID_USAGE_GENERIC_JOYSTICK,	//	USAGE (Joystick)

	HIDP_MAIN_COLLECTION,		HIDP_MAIN_COLLECTION_LINK,		//	COLLECTION (Link)
	HIDP_REPORT_ID_1,				MSGAME_FEATURE_GETVERSION,

	// ULONG
	HIDP_GLOBAL_REPORT_SIZE,	0x20,									//	REPORT_SIZE (20)
	HIDP_GLOBAL_REPORT_COUNT_1,0x01,									//	REPORT_COUNT (1)
	HIDP_LOCAL_USAGE_1,			0x0E,									//	USAGE (Vendor Defined1)
	HIDP_MAIN_FEATURE_1,			0x02,									//	FEATURE (Data,Var,Abs)

	HIDP_MAIN_ENDCOLLECTION,											//	END_COLLECTION
	HIDP_MAIN_ENDCOLLECTION												//	END_COLLECTION
};

static	HID_DESCRIPTOR	DeviceDescriptor	=
							{
							sizeof (HID_DESCRIPTOR),
							HID_HID_DESCRIPTOR_TYPE,
							MSGAME_HID_VERSION,
							MSGAME_HID_COUNTRY,
							MSGAME_HID_DESCRIPTORS,
							{HID_REPORT_DESCRIPTOR_TYPE,
							sizeof(ReportDescriptor)}
							};

//
//	Raw Data Buffer
//

static	UCHAR			RawData[GAME_PACKET_SIZE] =
							{	// no buttons; x, ya, yb centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS)|((GAME_YA0_YA5_BITS>>1)&GAME_YA0_YA5_BITS),
							((GAME_YB0_YB5_BITS>>1)&GAME_YB0_YB5_BITS),
							0,
							GAME_PPO_BITS
							};
//
//	Raw Id Buffer
//

static	SWLEDZEP_ID	RawId	=
							{
							0
							};

//
//	Raw Status Buffer
//

static	SWLEDZEP_STATUS	RawStatus =
							{
							0
							};

//
//	Timing Variables
//

static	DEVICE_VALUES	Delays =
							{
							PACKET_START_TIMEOUT,
							PACKET_HIGHLOW_TIMEOUT,
							PACKET_LOWHIGH_TIMEOUT,
							ID_START_TIMEOUT,
							ID_HIGHLOW_TIMEOUT,
							ID_LOWHIGH_TIMEOUT,
							0,								// No interrupt delay used
							MAX_CLOCK_DUTY_CYCLE,
							STATUS_START_TIMEOUT,
							STATUS_HIGHLOW_TIMEOUT,
							STATUS_LOWHIGH_TIMEOUT,
							STATUS_GATE_TIMEOUT
							};

static	ULONG			StatusGateTimeout;

//
//	Data Packet Info
//

static	PACKETINFO 	DataInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							WHEEL_SPEED_48K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawData),			// Size of raw data buffer
							RawData						// Pointer to Raw data
							};

//
//	ID Packet Info
//

static	PACKETINFO	IdInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							WHEEL_SPEED_48K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawId),			// Size of raw id buffer
							&RawId						// Pointer to Raw data
							};

//
//	Status Packet Info
//

static	PACKETINFO	StatusInfo =
							{
							sizeof (PACKETINFO),		// Size of structure
							DEVICENAME,					// Name of device
							MSGAME_TRANSACT_NONE,	// Transaction type
							IMODE_DIGITAL_ENH,		// Interface mode
							WHEEL_SPEED_48K,			// Transmission speed
							ERROR_SUCCESS,				// Last internal error result
							{0},							// Game port info
							0,								// Packet acquisition mode
							1,								// Number of packets received
							0,								// Last valid acquisition time stamp
							0,								// Number of clocks sampled
							0,								// Number of B4 line transitions (std mode only)
							0,								// Start timeout period (in samples)
							0,								// Clock High to Low timeout period (in samples)
							0,								// Clock Low to High timeout period (in samples)
							0,								// Interrupt Timeout period
							0,								// Maximum clock duty cycle
							0,								// Number of Packet Failures
							0,								// Number of Packet Attempts
							sizeof (RawStatus),		// Size of raw status buffer
							&RawStatus					// Pointer to Raw data
							};

//
//	Services Table
//

static	DRIVERSERVICES	Services =
							{	
							SWLEDZEP_DriverEntry,		// DriverEntry
							SWLEDZEP_ConnectDevice,  	// ConnectDevice
							SWLEDZEP_StartDevice,	  	//	StartDevice
							SWLEDZEP_ReadReport,			// ReadReport
							SWLEDZEP_StopDevice,			// StopDevice
							SWLEDZEP_GetFeature			// GetFeature
							};

//
//	Last Valid Data
//

static	UCHAR			ValidData[GAME_PACKET_SIZE]	=
							{	// no buttons; x, ya, yb centered
							GAME_X0_X7_BITS,
							((GAME_X8_X9_BITS>>1)&GAME_X8_X9_BITS)|((GAME_YA0_YA5_BITS>>1)&GAME_YA0_YA5_BITS),
							((GAME_YB0_YB5_BITS>>1)&GAME_YB0_YB5_BITS) | GAME_B0_B1_BITS,
							GAME_B2_B8_BITS,
							GAME_PPO_BITS
							};

//
//	Speed Variables
//

static	ULONG			NextSample								=	0;
static	ULONG			NumberSamples							=	0;
static	ULONG			SampleAccumulator						=	0;
static	ULONG			SampleBuffer[NUM_ERROR_SAMPLES]	= {0};

//
//	Reset Flag
//

static	BOOLEAN		ResetComplete = FALSE;

//
//	Hardware ID String
//

static	WCHAR			HardwareId[] = HARDWARE_ID;

//---------------------------------------------------------------------------
//	Public Data
//---------------------------------------------------------------------------

public	DEVICEINFO	LedZepInfo =
							{
							&Services,						// Service table
							NULL,								// Sibling device list
							&DeviceDescriptor,			// Device descriptor data
							ReportDescriptor,				// Report descriptor data
							sizeof(ReportDescriptor),	// Report descriptor size
							0,									// Number of devices detected
							0,									// Number of devices started
							0,									// Number of devices pending
							DEVICENAME,						// Name of device
							DETECT_FIRST,					// Detection order
							FALSE,							// Analog device flag
							DEVICE_PID,						// Hid device identifier
							HardwareId						// PnP hardware identifier
							};

//---------------------------------------------------------------------------
// @func		Reads registry timing values and calibrates them
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWLEDZEP_Calibrate (PGAMEPORT PortInfo)
{
	MsGamePrint((DBG_INFORM,"%s: %s_Calibrate Enter\n", DEVICENAME, DEVICENAME));

	//
	//	Convert timing values to counts
	//

	DataInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketStartTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.StartTimeout = %ld\n", DEVICENAME, DataInfo.StartTimeout));
	DataInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.LowHighTimeout = %ld\n", DEVICENAME, DataInfo.LowHighTimeout));
	DataInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.PacketHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.HighLowTimeout = %ld\n", DEVICENAME, DataInfo.HighLowTimeout));
	IdInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.IdStartTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.StartTimeout = %ld\n", DEVICENAME, IdInfo.StartTimeout));
	IdInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.IdLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.LowHighTimeout=%ld\n", DEVICENAME, IdInfo.LowHighTimeout));
	IdInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.IdHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.HighLowTimeout=%ld\n", DEVICENAME, IdInfo.HighLowTimeout));
	DataInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "%s: DataInfo.ClockDutyCycle = %ld\n", DEVICENAME, DataInfo.ClockDutyCycle));
	IdInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "%s: IdInfo.ClockDutyCycle = %ld\n", DEVICENAME, IdInfo.ClockDutyCycle));
	StatusInfo.ClockDutyCycle = TIMER_CalibratePort (PortInfo, Delays.MaxClockDutyCycle);
 	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.ClockDutyCycle = %ld\n", DEVICENAME, StatusInfo.ClockDutyCycle));
	StatusInfo.StartTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusStartTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.StartTimeout = %ld\n", DEVICENAME, StatusInfo.StartTimeout));
	StatusInfo.LowHighTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusLowHighTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.LowHighTimeout=%ld\n", DEVICENAME, StatusInfo.LowHighTimeout));
	StatusInfo.HighLowTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusHighLowTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusInfo.HighLowTimeout=%ld\n", DEVICENAME, StatusInfo.HighLowTimeout));
	StatusGateTimeout = TIMER_CalibratePort (PortInfo, Delays.StatusGateTimeout);
	MsGamePrint((DBG_VERBOSE, "%s: StatusGateTimeout=%ld\n", DEVICENAME, StatusGateTimeout));
}

//---------------------------------------------------------------------------
// @func		Resets device to known state
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_ResetDevice (PGAMEPORT PortInfo)
{
	BOOLEAN	Result = FALSE;

	MsGamePrint ((DBG_INFORM, "%s_ResetDevice enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	DataInfo.Speed = IdInfo.Speed = StatusInfo.Speed = WHEEL_SPEED_48K;

	if (PORTIO_PulseAndWaitForIdleHandshake (PortInfo, DataInfo.ClockDutyCycle, 4))
		{
		PORTIO_Write (PortInfo, 0);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		DataInfo.LastError = ERROR_SUCCESS;
		Result = TRUE;
		}
	else
		{
		DataInfo.LastError = ERROR_HANDSHAKING;
		MsGamePrint ((DBG_SEVERE, "%s_ResetDevice - PulseAndWaitForHandshake failed\n", DEVICENAME));
		}

	DataInfo.Transaction = MSGAME_TRANSACT_RESET;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	if (!Result)
		MsGamePrint ((DBG_SEVERE, "%s_ResetDevice - PulseAndWaitForIdleHandshake failed\n", DEVICENAME));

	MSGAME_PostTransaction (&DataInfo);

	return (Result);		
}

//---------------------------------------------------------------------------
// @func		Reads device id string from port
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_ReadId (PPACKETINFO IdPacket)
{
	ULONG			Data		=	0L;
	ULONG			Clks		=	GAME_ID_CLOCKS;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &IdPacket->PortInfo;

	MsGamePrint ((DBG_INFORM, "%s_ReadId enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	IdPacket->B4Transitions	= 0;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, IdInfo.ClockDutyCycle, 2))
		goto ReadIdExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; edx = port address
			mov	ebx, GAME_ID_CLOCKS		; ebx = no of clocks to receive.
			xor	edi, edi						; clear B4 transition counter
			xor	esi, esi						; clear data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, IdInfo.StartTimeout

		ID_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockStart_1			; N: jump
			loop	ID_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockStart_1:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	ID_Data						; Y: jump
			loop	ID_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	ID_Error						; Time out error.

		ID_ClockCheck:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		ID_ClockRise				; N: jump

		; ID_ClockFall:

			mov	ecx, IdInfo.HighLowTimeout

		ID_ClockFall_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock = 0
			jz		ID_ClockRise				; Y: jump - look for rising edge

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockFall_1				; else see if we timed out
			mov	eax, ERROR_CLOCKFALLING
			jmp	ID_Error						; Time out error.

		ID_ClockRise:

			mov	ecx, IdInfo.LowHighTimeout

		ID_ClockRise_1:
		
			test	al, CLOCK_BIT_MASK		; Q: clock high ?
			jnz	ID_Data						; Y: jump. (get data)

			push	edx							; read byte from gameport
			call	PORTIO_Read

			dec	ecx
			jnz	ID_ClockRise_1				; else see if we timed out
			mov	eax, ERROR_CLOCKRISING
			jmp	ID_Error						; Time out error.

		ID_Data:

			xor	ah, al
			test	ah, DATA2_BIT_MASK
			jz		ID_Data_1
			inc	edi							; increment Data 1 counter

		ID_Data_1:

			mov	ah, al
			shr	al, 5
			shrd	esi, eax,3
			dec	ebx
			jne	ID_ClockCheck
			shr	esi, 8						; only 24 bits

		; ID_Success:

			mov	IdInfo.B4Transitions, edi
			mov	eax, ERROR_SUCCESS
			mov	edx, IdInfo.Data
			mov	[edx], esi
			jmp	ID_Complete

		ID_Error:

			mov	edx, IdInfo.Data
			mov	[edx], dword ptr 0

		ID_Complete:

	 		mov	Result, eax
	 		mov	Data, esi
	 		mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadIdExit:
	//	----------------

	IdPacket->TimeStamp		= TIMER_GetTickCount ();
	IdPacket->ClocksSampled	= GAME_ID_CLOCKS - Clks;
	IdPacket->LastError		= Result;
	IdPacket->Transaction	= MSGAME_TRANSACT_ID;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_INFORM, "%s_ReadId - SUCCEEDED, Data=%ld", DEVICENAME, Data));
			break;

		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@Handshaking\n", DEVICENAME));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@LowClockStart, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@HighClockStart, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@ClockFalling, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadId - TimeOut@ClockRising, Data=%ld,Clk=%ld\n", DEVICENAME, Data,IdPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (IdPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Reads and validates device id string
//	@parm		PPACKETINFO | IdPacket | ID Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_GetId (PPACKETINFO IdPacket)
{
	BOOLEAN		Result;
	PSWLEDZEP_ID	Pnp;

	MsGamePrint ((DBG_INFORM, "%s_GetId enter\n", DEVICENAME));

	IdPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SWLEDZEP_ReadId (IdPacket);
	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

	if (Result)
		{
		Pnp = (PSWLEDZEP_ID)IdPacket->Data;
		if ((Pnp->ProductId != DEVICE_PID) || !DEVICE_IsOddParity (Pnp, sizeof(SWLEDZEP_ID)))
			{
			MsGamePrint ((DBG_SEVERE, "%s_GetId - Id did not match or parity error\n", DEVICENAME));
			Result = FALSE;
			}
		}

	if (!Result)
		IdPacket->Failures++;

	if (PORTIO_IsClockActive (&IdPacket->PortInfo, IdInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads data packet from gameport
//	@parm		PPACKETINFO | DataPacket| Data packet parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ReadData (PPACKETINFO DataPacket)
{
	LONG			Result;
	LONG			Clks		= 1L;
	PGAMEPORT	PortInfo = &DataPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "%s_ReadData enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (STATUS_DEVICE_BUSY);
	PORTIO_MaskInterrupts ();

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			mov	esi, DataInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		Enh_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Enh_ClockStartState_1		; N: jump
			loop	Enh_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Enh_CollectData				; Y: jump
			loop	Enh_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Enh_Complete					; Time out error.

		Enh_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Enh_ClockStartRise

		;Enh_ClockStartFall:

			mov	ecx, DataInfo.HighLowTimeout

		Enh_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Enh_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Enh_Complete					; Time out error.

		Enh_ClockStartRise:

			mov	ecx, DataInfo.LowHighTimeout

		Enh_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Enh_CollectData				; Y: jump.
			
			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Enh_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Enh_Complete					; Time out error.

		Enh_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, ENH_CLOCK_COMPLETE		; Q: in end-packet ?
			jnz	Enh_Success						; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Enh_CheckClkState

			;---------------------------------------------------------------------;
			; This section of code compensates for when the clock cycle count is ;
			; on a ULONG boundary. This happens on the 11th clock cycle. Two bits ;
			; of data belong in the 1st ULONG and one bit belong in the 2nd ULONG ;
			;---------------------------------------------------------------------;

		Enh_Success:

			shrd	edi, eax, 2						; put 2 bits in 1st ULONG.
			mov	[esi], edi						; Save 1st ULONG in packet ptr.
			shr	al, 2								; move 3rd bit over.
			mov	byte ptr [esi+4], al

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockLow

			push	DataInfo.ClockDutyCycle
			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_IsClockActive

			or		al, al
			mov	eax, ERROR_EXTRACLOCKS		; probably gamepads
			jne	Enh_Complete

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockHigh

			mov	eax, ERROR_SUCCESS

		Enh_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	for (DataPacket->ClocksSampled = 0; Clks >> (DataPacket->ClocksSampled+1); DataPacket->ClocksSampled++);
	DataPacket->TimeStamp	=	TIMER_GetTickCount ();
	DataPacket->LastError	=	Result;
	DataPacket->Transaction	=	MSGAME_TRANSACT_DATA;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@LowClockStart, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@HighClockStart, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@ClockFalling, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - TimeOut@ClockRising, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;

		case	ERROR_EXTRACLOCKS:
			MsGamePrint ((DBG_SEVERE, "%s_ReadData - Extra Clocks, Clk=%ld\n", DEVICENAME, DataPacket->ClocksSampled));
			break;
		}
	#endif

	MSGAME_PostTransaction (DataPacket);

	if (Result)
		return (STATUS_DEVICE_NOT_CONNECTED);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Converts raw packet information to HID report
//	@parm		UCHAR[] | Data | Pointer to raw data buffer
//	@parm		PDEVICE_PACKET | Report | Pointer to device packet
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWLEDZEP_ProcessData (UCHAR Data[], PDEVICE_PACKET Report)
{
	ULONG	B1, B2;

	MsGamePrint ((DBG_VERBOSE, "%s_ProcessData enter\n", DEVICENAME));

	//
	//	Process X Axis
	//

	Report->dwX   = Data[GAME_X8_X9_BYTE] & GAME_X8_X9_BITS;
	Report->dwX <<= 8;
	Report->dwX  |= Data[GAME_X0_X7_BYTE] & GAME_X0_X7_BITS;

	//
	//	Process Y Axis
	//

	Report->dwY = (Data[GAME_YA0_YA5_BYTE] & GAME_YA0_YA5_BITS)>>2;

	//
	//	Process R Axis
	//

	Report->dwR = Data[GAME_YB0_YB5_BYTE] & GAME_YB0_YB5_BITS;

	//
	//	Process Buttons
	//

	B1 = (~Data[GAME_B0_B1_BYTE] & GAME_B0_B1_BITS)>>6;
	B2 = (~Data[GAME_B2_B8_BYTE] & GAME_B2_B8_BITS)<<2;
	Report->dwButtons  = (B2 | B1);
	// R,L,C,B,A,Z,Y,X Order
	Report->dwButtons  = (Report->dwButtons & 0x7) | ((Report->dwButtons & 0xf0)>>1) | ((Report->dwButtons & 0x8)<<4);
	Report->dwButtons &= ((1L << GAME_PACKET_BUTTONS) - 1);

	Report->dwButtonNumber = 0;
	for (B1 = 1; B1 <= GAME_PACKET_BUTTONS; B1++)
		if (Report->dwButtons & (1L << (B1-1)))
			{
			Report->dwButtonNumber = B1;
			break;
		  	}
}

//---------------------------------------------------------------------------
// @func		Decrements device speed at port
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns new device speed
//	@comm		Private function
//---------------------------------------------------------------------------

LONG	SWLEDZEP_DecrementDevice (PGAMEPORT PortInfo)
{
	LONG	Clks		=	0;
	LONG	Result	=	ERROR_HANDSHAKING;

	MsGamePrint ((DBG_INFORM, "%s_DecrementDevice enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	if (!PORTIO_PulseAndWaitForHandshake (PortInfo, DataInfo.ClockDutyCycle, 3))
		goto DecrementDeviceExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo				; load gameport adddress

			xor	eax, eax						; data accumulator

			; make sure clock is "high" before sampling clocks...

			mov	ecx, DataInfo.StartTimeout

		DD_ClockStart:

			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jz		DD_ClockStart_1			; N: jump
			loop	DD_ClockStart				; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_ClockStart_1:
		
			push	edx							; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK		; Q: Clock = 1
			jnz	DD_Success					; Y: jump
			loop	DD_ClockStart_1			; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	DD_Complete					; Time out error.

		DD_Success:

			shr	al, 5
			dec	al
			and	eax, WHEEL_SPEED_BITS
			cmp	eax, WHEEL_SPEED_RANGE
			jb		DD_Complete
			dec	al
			and	eax, WHEEL_SPEED_BITS

		DD_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	edi
			pop	esi
		}

	//	--------------------
		DecrementDeviceExit:
	//	--------------------

	DataInfo.LastError	= Result;
	DataInfo.Transaction	= MSGAME_TRANSACT_SPEED;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_HANDSHAKING:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@Handshaking\n", DEVICENAME));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@LowClockStart, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@HighClockStart, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@ClockFalling, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice - TimeOut@ClockRising, Clk=%ld\n", DEVICENAME, Clks));
			break;

		default:
			MsGamePrint ((DBG_CONTROL, "%s_DecrementDevice - SUCCEEDED, Speed=%ld\n", DEVICENAME, Result));
			break;
		}
	#endif

	MSGAME_PostTransaction (&DataInfo);

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Sets new device speed
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Speed | Desired device speed
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_SetDeviceSpeed (PGAMEPORT PortInfo, LONG Speed)
{
	LONG	Result;
	ULONG	Tries;

	MsGamePrint ((DBG_INFORM, "%s_SetDeviceSpeed enter\n", DEVICENAME));

	//
	// Zero error processing counters
	//

	NextSample			=	0;
	NumberSamples		=	0;
	SampleAccumulator	=	0;
	for (Tries = 0; Tries < NUM_ERROR_SAMPLES; Tries++)
		SampleBuffer[Tries] = 0;

	//
	// Try changing speed only enough times as range
	//

	for (Tries = 0; Tries < WHEEL_SPEED_RANGE; Tries++)
		{
		if (DataInfo.Speed == Speed)
			return (TRUE);

		Result = SWLEDZEP_DecrementDevice (PortInfo);
		if (Result < 0)
			{
			MsGamePrint ((DBG_SEVERE, "%s_DecrementDevice failed on %ld attempt\n", DEVICENAME, (ULONG)Tries));
			return (FALSE);
			}

		DataInfo.Speed = IdInfo.Speed = StatusInfo.Speed = Result;
		}

	MsGamePrint ((DBG_SEVERE, "%s_SetDeviceSpeed failed after %ld attempts\n", DEVICENAME, (ULONG)Tries));
	return (FALSE);
}

//---------------------------------------------------------------------------
// @func		Processes packet results and changes device speed as neccessary
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		ULONG | Error | Error flag (true is error)
// @rdesc	Returns nothing
//	@comm		Private function
//---------------------------------------------------------------------------

VOID	SWLEDZEP_ProcessDataError (PGAMEPORT PortInfo, ULONG Error)
{
	ULONG	Average;

	MsGamePrint ((DBG_VERBOSE, "%s_ProcessDataError enter\n", DEVICENAME));

	//
	// Update running accumulated errors
	//

	SampleAccumulator			-= SampleBuffer[NextSample];
	SampleBuffer[NextSample] = Error;
	SampleAccumulator			+= Error;

	//
	// Increment and wrap next error counter
	//

	if (++NextSample >= NUM_ERROR_SAMPLES)
		NextSample = 0;

	//
	// Increment number samples and exit if not full
	//

	if (NumberSamples < NUM_ERROR_SAMPLES)
		{
		NumberSamples++;
		return;
		}

	//
	// Calculate moving average
	//

	Average = (SampleAccumulator*100)/NumberSamples;

	//
	// Lower speed if too many errors
	//

	if ((Average > MAX_ERROR_RATE) && (DataInfo.Speed > WHEEL_SPEED_66K))
		{
		MsGamePrint ((DBG_CONTROL, "%s_ProcessDataError - average error = %ld\n", DEVICENAME, Average));
		SWLEDZEP_SetDeviceSpeed (PortInfo, DataInfo.Speed-1);
		}

	//
	// Raise speed if too few errors
	//

	else if ((Average < MIN_ERROR_RATE) && (DataInfo.Speed < WHEEL_SPEED_98K))
		{
		MsGamePrint ((DBG_CONTROL, "%s_ProcessDataError - average error = %ld\n", DEVICENAME, Average));
		SWLEDZEP_SetDeviceSpeed (PortInfo, DataInfo.Speed+1);
		}
}

//---------------------------------------------------------------------------
// @func		Reads and validates device status
//	@parm		PPACKETINFO | StatusPacket | Status Packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_GetStatus (PPACKETINFO StatusPacket)
{
	BOOLEAN				Result;
	PSWLEDZEP_STATUS	Status;

	MsGamePrint ((DBG_INFORM, "%s_GetStatus Enter\n", DEVICENAME));

	StatusPacket->Attempts++;

	TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
	Result = SWLEDZEP_ReadStatus (StatusPacket);

	if (Result)
		{
		Status = (PSWLEDZEP_STATUS)StatusPacket->Data;
		if (!DEVICE_IsOddParity (Status, sizeof(SWLEDZEP_STATUS)))
			{
			MsGamePrint ((DBG_SEVERE, "%s_GetStatus - Parity error\n", DEVICENAME));
			Result = FALSE;
			}
		else MsGamePrint ((DBG_INFORM, "%s_GetStatus - Status = 0x%X\n", DEVICENAME, 	(long)Status->Status));
		}

	if (!Result)
		StatusPacket->Failures++;

	if (PORTIO_IsClockActive (&StatusPacket->PortInfo, StatusInfo.ClockDutyCycle))
		TIMER_DelayMicroSecs (TIMER_GetDelay (ONE_MILLI_SEC));

	return (Result);
}

//---------------------------------------------------------------------------
// @func		Reads status packet from gameport
//	@parm		PPACKETINFO | StatusPacket| Status packet parameters
// @rdesc	True if successful, False otherwise
//	@comm		Private function
//---------------------------------------------------------------------------

BOOLEAN	SWLEDZEP_ReadStatus (PPACKETINFO StatusPacket)
{
	ULONG			Status;
	LONG			Clks		=	1L;
	LONG			Result	= 	ERROR_HANDSHAKING;
	PGAMEPORT	PortInfo = &StatusPacket->PortInfo;

	MsGamePrint ((DBG_VERBOSE, "%s_ReadStatus enter\n", DEVICENAME));

	if (!PORTIO_AcquirePort (PortInfo))
		return (FALSE);
	PORTIO_MaskInterrupts ();

	StatusPacket->ClocksSampled = 0;
	StatusPacket->B4Transitions = 0;

	if (!PORTIO_PulseAndWaitForIdleHandshake (PortInfo, StatusInfo.ClockDutyCycle, 1))
		goto ReadStatusExit;

	PORTIO_Write (PortInfo, 0);

	__asm
		{
			push	edi
			push	esi

			mov	edx, PortInfo					; load gameport adddress

			mov	esi, StatusInfo.Data
			mov	ebx, 1

			; make sure clock is "high" before sampling clocks...

			mov	ecx, StatusInfo.StartTimeout

		Stat_ClockStartState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jz		Stat_ClockStartState_1		; N: jump
			loop	Stat_ClockStartState			; else keep looping
			mov	eax, ERROR_LOWCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartState_1:
		
			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1
			jnz	Stat_CollectData				; Y: jump
			loop	Stat_ClockStartState_1		; else keep looping
			mov	eax, ERROR_HIGHCLOCKSTART
			jmp	Stat_Complete					; Time out error.

		Stat_CheckClkState:

			push	edx								; read byte from gameport
			call	PORTIO_Read

			test	al, CLOCK_BIT_MASK
			jz		Stat_ClockStartRise

		;Stat_ClockStartFall:

			mov	ecx, StatusInfo.HighLowTimeout

		Stat_ClockFalling:

			test	al,CLOCK_BIT_MASK				; Q: Clock Low ?
			jz		Stat_ClockStartRise			; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockFalling				; N: continue looping.

			mov	eax, ERROR_CLOCKFALLING
			jmp	Stat_Complete					; Time out error.

		Stat_ClockStartRise:

			mov	ecx, StatusInfo.LowHighTimeout

		Stat_ClockRising:

			test	al, CLOCK_BIT_MASK			; Q: Clock = 1 ?
			jnz	Stat_CollectData				; Y: jump.

			push	edx								; read byte from gameport
			call	PORTIO_Read

			dec	ecx								; Q: Timeout ?
			jnz	Stat_ClockRising				; N: continue looping.

			mov	eax, ERROR_CLOCKRISING
			jmp	Stat_Complete					; Time out error.

		Stat_CollectData:

			shr	al, 5								; move data to lower 3 bits
			test	ebx, STATUS_CLOCK_COMPLETE	; Q: is packet complete ?
			jnz	Stat_Success					; Y: jump.

			shrd	edi, eax, 3						; shift data into edi.
			shl	ebx, 1							; advance clock counter.
			jmp	Stat_CheckClkState

		Stat_Success:

			shrd	edi, eax, 3						; shift data into edi.
			shr	edi, 11
			mov	dword ptr [esi], edi
			mov	Status, edi

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockLow

			push	StatusInfo.ClockDutyCycle
			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_IsClockActive

			or		al, al
			mov	eax, ERROR_EXTRACLOCKS		; probably gamepads
			jne	Stat_Complete

			mov	eax, PortInfo					; wait for clock to settle
			push	eax
			call	PORTIO_WaitClockHigh

			mov	eax, ERROR_SUCCESS

		Stat_Complete:

			mov	Result, eax
			mov	Clks, ebx

			pop	esi
			pop	edi
		}

	//	----------------
		ReadStatusExit:
	//	----------------

	for (StatusPacket->ClocksSampled = 0; Clks >> (StatusPacket->ClocksSampled+1); StatusPacket->ClocksSampled++);
	StatusPacket->TimeStamp 	= TIMER_GetTickCount ();
	StatusPacket->LastError 	= Result;
	StatusPacket->LastError		=	Result;
	StatusPacket->Transaction	=	MSGAME_TRANSACT_STATUS;

	PORTIO_UnMaskInterrupts ();
	PORTIO_ReleasePort (PortInfo);

	#if (DBG==1)
	switch (Result)
		{
		case	ERROR_SUCCESS:
			MsGamePrint ((DBG_VERBOSE, "%s_ReadStatus - SUCCEEDED, Data=0x%X,Clk=%ld\n", DEVICENAME, (ULONG)Status,Clks));
			break;

		case	ERROR_LOWCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@LowClockStart\n", DEVICENAME));
			break;

		case	ERROR_HIGHCLOCKSTART:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@HighClockStart\n", DEVICENAME));
			break;

		case	ERROR_CLOCKFALLING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@ClockFalling, Clk=%ld\n", DEVICENAME, Clks));
			break;

		case	ERROR_CLOCKRISING:
			MsGamePrint ((DBG_SEVERE, "%s_ReadStatus - TimeOut@ClockRising, Clk=%ld\n", DEVICENAME, Clks));
			break;
		}
	#endif

	MSGAME_PostTransaction (StatusPacket);

	return (!Result);
}

//---------------------------------------------------------------------------
// @func		Force feedback reset service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceReset (PGAMEPORT PortInfo)
{
	if (!SWLEDZEP_ResetDevice (PortInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Id | Id output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceId (PGAMEPORT PortInfo, PVOID Id)
{
	PPRODUCT_ID 	pProduct	= (PPRODUCT_ID)Id;
	PSWLEDZEP_ID	pLedZep	= (PSWLEDZEP_ID)&RawId;

	if (!SWLEDZEP_ReadId (&IdInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pProduct->cBytes			=	sizeof (PRODUCT_ID);
	pProduct->dwProductID	=	pLedZep->ProductId;
	pProduct->dwFWVersion	=	pLedZep->Version;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback status service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PVOID | Status | Status output buffer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceStatus (PGAMEPORT PortInfo, PVOID Status)
{
	PJOYCHANNELSTATUS	pChannel	= (PJOYCHANNELSTATUS)Status;
	PSWLEDZEP_STATUS	pLedZep	= (PSWLEDZEP_STATUS)&RawStatus;

	if (!SWLEDZEP_ReadStatus (&StatusInfo))
		return (STATUS_DEVICE_NOT_CONNECTED);

	pChannel->cBytes				=	sizeof (JOYCHANNELSTATUS);
	pChannel->dwXVel				=	0;
	pChannel->dwYVel				=	0;
	pChannel->dwXAccel			=	0;
	pChannel->dwYAccel			=	0;
	pChannel->dwEffect			=	pLedZep->Effect;
	pChannel->dwDeviceStatus	=	pLedZep->Status;

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback acknak service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | AckNak | AckNak
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceAckNak (PGAMEPORT PortInfo, PULONG AckNak)
{
	if (!PORTIO_GetAckNak (PortInfo, StatusGateTimeout, (PUCHAR)AckNak))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback NakAck service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceNakAck (PGAMEPORT PortInfo, PULONG NakAck)
{
	if (!PORTIO_GetNakAck (PortInfo, StatusGateTimeout, (PUCHAR)NakAck))
		return (STATUS_DEVICE_NOT_CONNECTED);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Force feedback sync service
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PULONG | NakAck | NakAck
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ForceSync (PGAMEPORT PortInfo, PULONG Sync)
{
	*Sync = PORTIO_Read (PortInfo);
	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Driver entry point for device
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_DriverEntry (VOID)
{
	MsGamePrint((DBG_INFORM,"%s: %s_DriverEntry Enter\n", DEVICENAME, DEVICENAME));

	//
	//	Read timing values from registry
	//

	MSGAME_ReadRegistry (DEVICENAME, &Delays);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Establishes connection to device by detection
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT Status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ConnectDevice (PGAMEPORT PortInfo)
{
	NTSTATUS	ntStatus;
	ULONG		i = MAX_CONNECT_ATTEMPTS;

	MsGamePrint ((DBG_INFORM, "%s_ConnectDevice enter\n", DEVICENAME));

	DataInfo.PortInfo = IdInfo.PortInfo = StatusInfo.PortInfo = *PortInfo; 

	//
	//	Convert registry timing values
	//

  	SWLEDZEP_Calibrate (PortInfo);

	//
	// Connection method (try these steps twice)
	//

	do
		{
		//
		// 1. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 2. Get the ID string.
		//

		MsGamePrint ((DBG_CONTROL, "%s: DeviceConnectProc getting ID string\n", DEVICENAME));
		if (!SWLEDZEP_GetId (&IdInfo))
			continue;

		//
		// 3. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));
		
		//
		// 4. Reset device (tri-state midi so we don't get unintended forces)
		//

		if (!ResetComplete)
			{
			MsGamePrint ((DBG_CONTROL, "%s_ConnectDevice - resetting device\n", DEVICENAME));
			if (!SWLEDZEP_ResetDevice (&DataInfo.PortInfo))
				continue;
			}

		//
		// 5. Delay 1 millisecond.
		//

		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
		// 6. Set speed to 98K for starters
		//

		MsGamePrint ((DBG_CONTROL, "%s: DeviceConnectProc setting device speed\n", DEVICENAME));
		SWLEDZEP_SetDeviceSpeed (&DataInfo.PortInfo, WHEEL_SPEED_98K);
		TIMER_DelayMicroSecs (TIMER_GetDelay(ONE_MILLI_SEC));

		//
      // 7. Mark device found and return
		//

		LedZepInfo.NumDevices	=	1;
		ResetComplete				=	TRUE;
		return (STATUS_SUCCESS);

		} while (--i);

	//
	//	Return error
	//

	LedZepInfo.NumDevices = 0;
	return (STATUS_DEVICE_NOT_CONNECTED);
}

//---------------------------------------------------------------------------
// @func		Reads and converts HID packet for this device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		PUCHAR | Report | Output buffer for report
//	@parm		ULONG | MaxSize | Size of buffer for report
//	@parm		PULONG | Copied | Bytes copied to buffer for report
// @rdesc	Returns Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_ReadReport (PGAMEPORT PortInfo, PDEVICE_PACKET Report)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_VERBOSE, "%s_ReadReport enter\n", DEVICENAME));

	//
	// Log number of attempts
	//

	DataInfo.Attempts++;

	//
	// Set up default data to process
	//

	memcpy (DataInfo.Data, ValidData, sizeof (ValidData));

	//
	// Check for collision
	//

	if (DEVICE_IsCollision (&DataInfo))
		{
		MsGamePrint ((DBG_INFORM, "%s_ReadReport - port collision\n", DEVICENAME));
		ntStatus = STATUS_DEVICE_BUSY;
		goto ReadReportExit;
		}

	//
	// Get a packet and check for errors
	//

	ntStatus = SWLEDZEP_ReadData (&DataInfo);
	if (NT_SUCCESS(ntStatus) && DEVICE_IsOddParity (DataInfo.Data, GAME_PACKET_SIZE))
		{
		memcpy (ValidData, DataInfo.Data, sizeof (ValidData));
		SWLEDZEP_ProcessDataError (&DataInfo.PortInfo, FALSE);
		}
	else if (ntStatus != STATUS_DEVICE_BUSY)
		{
		DataInfo.Failures++;
		ntStatus = STATUS_DEVICE_NOT_CONNECTED;
		MsGamePrint ((DBG_SEVERE, "%s_ReadReport - Invalid packet or parity error\n", DEVICENAME));
		SWLEDZEP_ProcessDataError (&DataInfo.PortInfo, TRUE);
		}
	else
		{
		MsGamePrint ((DBG_CONTROL, "SWLEDZEP_ReadReport - Port busy or in use\n"));
		}

	//	---------------
		ReadReportExit:
	//	---------------

	SWLEDZEP_ProcessData (ValidData, Report);

	return (ntStatus);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Start Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_StartDevice (PGAMEPORT PortInfo)
{
	MsGamePrint ((DBG_INFORM, "%s_StartDevice enter\n", DEVICENAME));

	UNREFERENCED_PARAMETER (PortInfo);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for Pnp Stop Device
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_StopDevice (PGAMEPORT PortInfo, BOOLEAN TouchHardware)
{
	MsGamePrint ((DBG_INFORM, "%s_StopDevice enter\n", DEVICENAME));

	UNREFERENCED_PARAMETER (PortInfo);
	UNREFERENCED_PARAMETER (TouchHardware);

	return (STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
// @func		Device handler for HID Feature requests
//	@parm		PGAMEPORT | PortInfo | Gameport parameters
//	@parm		HID_REPORT_ID | ReportId | HID Feature Id
//	@parm		PVOID | ReportBuffer | Output buffer pointer
//	@parm		ULONG | ReportSize | Output buffer size
//	@parm		PULONG | Returned | Bytes returned pointer
// @rdesc	Returns NT status code
//	@comm		Private function
//---------------------------------------------------------------------------

NTSTATUS	SWLEDZEP_GetFeature (PGAMEPORT PortInfo, HID_REPORT_ID ReportId, PVOID ReportBuffer, ULONG ReportSize, PULONG Returned)
{
	NTSTATUS	ntStatus = STATUS_SUCCESS;

	MsGamePrint ((DBG_INFORM, "%s_GetFeature enter\n", DEVICENAME));

	//
	//	Handle feature codes
	//

	switch (ReportId)
		{
		case	MSGAME_INPUT_JOYINFOEX:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature JoyInfoEx\n", DEVICENAME));
			if (ReportSize < sizeof (DEVICE_PACKET)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature JoyInfoEx Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ReadReport (PortInfo, ReportBuffer);
				*Returned += sizeof (DEVICE_PACKET);
				}
			break;

		case	MSGAME_FEATURE_GETID:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetId\n", DEVICENAME));
			if (ReportSize < sizeof(PRODUCT_ID)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetId Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceId (PortInfo, ReportBuffer);
				*Returned += sizeof(PRODUCT_ID);
				}
			break;

		case	MSGAME_FEATURE_GETSTATUS:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetStatus\n", DEVICENAME));
			if	(ReportSize < sizeof(JOYCHANNELSTATUS)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetStatus Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceStatus (PortInfo, ReportBuffer);
				*Returned += sizeof(JOYCHANNELSTATUS);
				}
			break;

		case	MSGAME_FEATURE_GETACKNAK:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetAckNak\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetAckNak Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceAckNak (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETNAKACK:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetNakAck\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetNakAck Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceNakAck (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_GETSYNC:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetSync\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetSync Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
			else
				{
				ntStatus = SWLEDZEP_ForceSync (PortInfo, ReportBuffer);
				*Returned += sizeof(ULONG);
				}
			break;

		case	MSGAME_FEATURE_RESET:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature Reset\n", DEVICENAME));
			if	(ReportSize < sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetVersion Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
         else
				{
				ntStatus = SWLEDZEP_ForceReset (PortInfo);
				}
			break;

		case	MSGAME_FEATURE_GETVERSION:
			MsGamePrint ((DBG_INFORM, "%s_GetFeature GetVersion\n", DEVICENAME));
			if	(ReportSize < sizeof(ULONG)+sizeof(HID_REPORT_ID))
				{
				ntStatus = STATUS_INVALID_BUFFER_SIZE;
				MsGamePrint ((DBG_SEVERE, "%s_GetFeature GetVersion Bad Buffer Size = %lu\n", DEVICENAME, ReportSize));
				}
         else
	         {
            *((PULONG)ReportBuffer)	= 0x20000;
			   *Returned += sizeof(ULONG);
   	      }
         break;

		default:
			MsGamePrint ((DBG_SEVERE, "%s_GetFeature Invalid ReportId = %lu\n", DEVICENAME, ReportId));
			ntStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}

	return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriver.h ===
#ifndef	__IDirectInputEffectDriver_H__
#define	__IDirectInputEffectDriver_H__

#include <windows.h>
#include <unknwn.h>

#include <dinput.h>
#include "dinputd.h"
extern "C"
{
	#include <hidsdi.h>
}
#include <crtdbg.h>
#include "..\ControlItemCollection\Dualmode.h"
#include "..\ControlItemCollection\Actions.h"		// FORCE_BLOCK

// class IDirectInputEffectDriver;

//class CIDirectInputEffectDriver : public IUnknown
class CIDirectInputEffectDriver
{
	public:
		CIDirectInputEffectDriver(IDirectInputEffectDriver* pIPIDEffectDriver, IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriver();

		//IUnknown members
		virtual HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		virtual ULONG __stdcall AddRef();
		virtual ULONG __stdcall Release();

		//IDirectInputEffectDriver
		virtual HRESULT __stdcall DeviceID(DWORD dwDIVersion, DWORD dwExternalID, DWORD dwIsBegining,
									DWORD dwInternalID, void* pReserved);
		virtual HRESULT __stdcall GetVersions(DIDRIVERVERSIONS* pDriverVersions);
		virtual HRESULT __stdcall Escape(DWORD dwDeviceID, DWORD dwEffectID, DIEFFESCAPE* pEscape);
		virtual HRESULT __stdcall SetGain(DWORD dwDeviceID, DWORD dwGain);
		virtual HRESULT __stdcall SendForceFeedbackCommand(DWORD dwDeviceID, DWORD dwState);
		virtual HRESULT __stdcall GetForceFeedbackState(DWORD dwDeviceID, DIDEVICESTATE* pDeviceState);
		virtual HRESULT __stdcall DownloadEffect(DWORD dwDeviceID, DWORD dwInternalEffectType,
											DWORD* pdwDnloadID, DIEFFECT* pEffect, DWORD dwFlags);
		virtual HRESULT __stdcall DestroyEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall StartEffect(DWORD dwDeviceID, DWORD dwDnloadID, DWORD dwMode,  DWORD dwIterations);
		virtual HRESULT __stdcall StopEffect(DWORD dwDeviceID, DWORD dwDnloadID);
		virtual HRESULT __stdcall GetEffectStatus(DWORD dwDeviceID, DWORD dwDnloadID, DWORD* pdwStatusCode);

		void WaitForForceSchemeChange();
	private:
		void InitHidInformation(LPDIHIDFFINITINFO pHIDInitInfo);
		void SendSpringChange();

		DWORD m_dwDIVersion;
		DWORD m_dwExternalDeviceID;
		DWORD m_dwInternalDeviceID;

		ULONG m_ulReferenceCount;
		IDirectInputEffectDriver* m_pIPIDEffectDriver;
		IClassFactory* m_pIPIDClassFactory;
		HANDLE m_hKernelDeviceDriver;
		HANDLE m_hKernelDeviceDriverDuplicate;
		HANDLE m_hHidDeviceDriver;
		DWORD m_dwGcKernelDevice;
		HANDLE m_hForceSchemeChangeWaitThread;
		DWORD m_dwForceSchemeChangeThreadID;
		FORCE_BLOCK m_ForceMapping;
		PHIDP_PREPARSED_DATA m_pPreparsedData;
		HIDD_ATTRIBUTES m_HidAttributes;
		HIDP_CAPS m_HidCaps;
};

extern CIDirectInputEffectDriver* g_IEffectDriverObject;

#endif	__IDirectInputEffectDriver_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriverclassfactory.h ===
#ifndef	__IDirectInputEffectDriverClassFactory_H__
#define	__IDirectInputEffectDriverClassFactory_H__

#include <windows.h>
#include <unknwn.h>
//#include <dinputd.h>

class CIDirectInputEffectDriverClassFactory : public IClassFactory
{
	public:
		CIDirectInputEffectDriverClassFactory(IClassFactory* pIPIDClassFactory);
		~CIDirectInputEffectDriverClassFactory();

		//IUnknown members
		HRESULT __stdcall QueryInterface(REFIID refiid, void** ppvObject);
		ULONG __stdcall AddRef();
		ULONG __stdcall Release();

		//IClassFactory members
		HRESULT __stdcall CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		HRESULT __stdcall LockServer(BOOL fLock);

	private:
 		ULONG           m_ulLockCount;
		ULONG			m_ulReferenceCount;

		IClassFactory*	m_pIPIDClassFactory;
};

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

#endif	__IDirectInputEffectDriverClassFactory_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriverclassfactory.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriverClassFactory.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <crtdbg.h>
#include <objbase.h>

LONG DllAddRef();
LONG DllRelease();

extern CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject;

/******************** Class CIDirectInputEffectDriverClassFactory ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory
(
	IClassFactory* pIPIDClassFactory		//@parm [IN] Default PID Factory
) :
	m_ulLockCount(0),
	m_ulReferenceCount(1),
	m_pIPIDClassFactory(pIPIDClassFactory)
{
	// Increase global object count
	DllAddRef();

	// Add count to held object
	m_pIPIDClassFactory->AddRef();
}

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriverClassFactory::~CIDirectInputEffectDriverClassFactory()
{
	// Decrease Global object count
	DllRelease();

	_ASSERTE(m_pIPIDClassFactory == NULL);
	_ASSERTE(m_ulLockCount == 0);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an Unknown for a particular type. This causes increase locally only
**				If it is a type we don't know, should we give the PID factory a crack (PID factory
**			might have a customized private interface, we don't want to ruin that. Currently not
**			going to pass on the Query, because this could screwup Symmetry.
**
**	@rdesc	S_OK if all is well, E_INVALIDARG if ppvObject is NULL or E_NOINTERFACE
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
	HRESULT hrPidQuery = m_pIPIDClassFactory->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		*ppvObject = this;
		// Increase our reference count only (pid class fact would be incremented by AddRef call)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::AddRef()
**
**	@func	Bumps up the reference count
**				The PID Factory reference count is left alone. We only decrement it when
**				this factory is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::AddRef()
{
	m_pIPIDClassFactory->AddRef();
	return (ULONG)::InterlockedIncrement((LONG*)&m_ulReferenceCount);
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriverClassFactory::Release()
**
**	@func	Decrements the reference count.
**				If both the reference count and the lock count are zero the PID Factory is
**				released and this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriverClassFactory::Release()
{
	m_pIPIDClassFactory->Release();

	if (::InterlockedDecrement((LONG*)&m_ulReferenceCount) != 0)
	{
		return m_ulReferenceCount;
	}

	m_pIPIDClassFactory = NULL;
	g_pClassFactoryObject = NULL;
	delete this;

	return 0;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void** ppvObject)
**
**	@func	Create an instance of the object
**				Also tells the PID factory to create an instance, this is stored in our instance.
**			
**
**	@rdesc	S_OK if intstance is created
**			E_INVALIDARG if (ppvObject == NULL)
**			CLASS_E_NOAGGREGATION  if aggrigation is attempted (pUnkOuter != NULL)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::CreateInstance
(
	IUnknown* pUnkOuter,	//@parm [IN] Aggregate class or NULL
	REFIID riid,			//@parm [IN] IID of Object to create
	void** ppvObject		//@parm [OUT] Address to place the requested object
)
{
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	if (ppvObject == NULL)
	{
		return E_INVALIDARG;
	}

	if (riid == IID_IDirectInputEffectDriver)
	{
		// Let the PID Factory Create its driver
		IDirectInputEffectDriver* pPIDDriver = NULL;
		HRESULT hrPID = m_pIPIDClassFactory->CreateInstance(pUnkOuter, riid, (void**)(&pPIDDriver));
		if (FAILED(hrPID) || (pPIDDriver == NULL))
		{
			return hrPID;
		}


		// Create our effect driver
		*ppvObject = new CIDirectInputEffectDriver(pPIDDriver, m_pIPIDClassFactory);

		pPIDDriver->Release();	// We no longer care about this (held in our CIDirectInputEffectDriver)

		if (*ppvObject == NULL)
		{
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	return E_NOINTERFACE;
}

/***********************************************************************************
**
**	HRESULT CIDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
**
**	@func	Lock this factory down (prevents Release from causing deletion)
**				If Unlocked compleatly (m_ulLockCount becomes 0) and reference count
**			is at 0 - this Factory is destroyed (and the PID factory is released)
**
**	@rdesc	S_OK : All is well
**			E_UNEXPECTED: Unlock on non-locked object
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriverClassFactory::LockServer
(
	BOOL fLock		//@parm [IN] Is the server being locked or unlocked
)
{
	HRESULT hrPidLock = m_pIPIDClassFactory->LockServer(fLock);

	if (FAILED(hrPidLock))
	{
		return hrPidLock;
	}
	if (fLock != FALSE)
	{
		::InterlockedIncrement((LONG*)&m_ulLockCount);
		return S_OK;
	}

	if (m_ulLockCount == 0)
	{
		return E_UNEXPECTED;
	}

	::InterlockedDecrement((LONG*)&m_ulLockCount);

	return hrPidLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SWPIDFlt.rc
//
#define IDS_PROJNAME                    100
#define IDS_HELPFILESWPIDFlt          102
#define IDS_DOCSTRINGSWPIDFlt         103
#define IDR_SWPIDFLT                  110
#define IDS_TITLESWPIDFlt				120

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName = NULL, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\idirectinputeffectdriver.cpp ===
//	@doc
/**********************************************************************
*
*	@module	IDirectInputEffectDriver.cpp	|
*
*	Contains Class Implementation of CIDirectInputEffectDriverClassFactory:
*		Factory for Creating Proper Effect Driver
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	This IDirectInputEffectDriver	|
*		This Driver sits on top of the standard PID driver (which is also
*		an IDirectInputEffectDriver) and passes most requests to the PID driver.
*		Some requests such as, DownloadEffect and SendForceFeedback command are
*		modified for our use. Modification purposes are described at each function
*		definition.
*
**********************************************************************/

#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include <WinIOCTL.h>		// For CTL_CODE definition
#include "..\\GCKernel.sys\\GckExtrn.h"
#include <crtdbg.h>
#include <objbase.h>		// For CoUninitialize
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>

/*
void __cdecl LogIt(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);
	char szBuffer[1024];
	FILE* pLogFile = NULL;

	pLogFile = fopen("swpidflt.log", "a");

	_vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	fprintf(pLogFile, szBuffer);
	va_end(args);

	fclose(pLogFile);
}
*/

const GUID IID_IDirectInputEffectDriver = {
	0x02538130,
	0x898F,
	0x11D0,
	{ 0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35 }
};

extern TCHAR CLSID_SWPIDDriver_String[];

LONG DllAddRef();
LONG DllRelease();

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter);
const DWORD c_dwShutdownWait = 500;		// (0.5 Seconds)

struct DIHIDFFINITINFO_STRUCT {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
};

// PID Defines for Effect Tyoes
#define PID_CONSTANT_FORCE	0x26
#define	PID_RAMP	 		0x27
#define	PID_SQUARE			0x30
#define PID_SINE			0x31
#define	PID_TRIANGLE		0x32
#define	PID_SAWTOOTHUP		0x33
#define	PID_SAWTOOTHDOWN	0x34
#define PID_SPRING			0x40
#define PID_DAMPER			0x41
#define PID_INTERTIA		0x42
#define PID_FRICTION		0x43


struct PercentageEntry
{
	DWORD dwAngle;
	DWORD dwPercentageX;
//	DWORD dwPercentageY; Y == 10000 - X
};

// Array of Fixed value data
const PercentageEntry g_PercentagesArray[] =
{
	// Angle,	Sin^2(Angle)
	{    0,	    0},	// 0 Degrees
	{ 1125,	  381},	// 11.25 Degrees
	{ 2250,	 1465},	// 22.5 Degrees
	{ 3375,	 3087},	// 33.75 Degrees
	{ 4500,	 5000},	// 45 Degrees
	{ 5625,	 6913},	// 56.25 Degrees
	{ 6750,	 8536},	// 67.50 Degrees
	{ 7875,	 9619},	// 78.75 Degrees
	{ 9000,	10000},	// 90 Degrees
};

const DWORD c_dwTableQuantization = g_PercentagesArray[1].dwAngle;
const LONG c_lContributionY = 2;		// (1/2 = 50%)

const BYTE c_bSideWinderPIDReportID_SetEffect = 1;

// Usage Pages (just PID)
const USAGE c_HidUsagePage_PID = 0x0F;

// Usages
const USAGE c_HidUsage_EffectType = 0x25;
const USAGE c_HidUsage_EffectType_Spring = 0x40;
const USAGE c_HidUsage_EffectBlock_Gain = 0x52;
const USAGE c_HidUsage_EffectBlock_Index = 0x22;	// This is the ID of the effect

// Preloaded Effects
const BYTE c_EffectID_RTCSpring = 1;

// Local Debugging Streaming Function that works in release
#undef UseMyDebugOut
void __cdecl myDebugOut (LPCSTR lpszFormat, ...)
{
#ifdef UseMyDebugOut
    //Stolen from inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...) in AtlBase.h
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[1024];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

#ifdef _NDEBUG
	OutputDebugStringA(szBuffer);
#else
    _RPTF0 (_CRT_WARN, szBuffer);
#endif

	va_end(args);
#else
    UNREFERENCED_PARAMETER (lpszFormat);
    return;
#endif
}

/******************** Class CIDirectInputEffectDriver ***********************/

/*****************************************************************************
**
** CIDirectInputEffectDriverClassFactory::CIDirectInputEffectDriverClassFactory()
**
** @mfunc Constructor 
**
*****************************************************************************/
CIDirectInputEffectDriver::CIDirectInputEffectDriver
(
	IDirectInputEffectDriver* pIPIDEffectDriver,		//@parm [IN] Pointer to PID Effect Driver
	IClassFactory* pIPIDClassFactory					//@parm [IN] Pointer to PID Class Factory
) :

	m_ulReferenceCount(1),
	m_dwDIVersion(0xFFFFFFFF),
	m_dwExternalDeviceID(0xFFFFFFFF),
	m_dwInternalDeviceID(0xFFFFFFFF),
	m_pIPIDEffectDriver(pIPIDEffectDriver),
	m_pIPIDClassFactory(pIPIDClassFactory),
	m_hKernelDeviceDriver(NULL),
	m_hKernelDeviceDriverDuplicate(NULL),
	m_hHidDeviceDriver(NULL),
	m_dwGcKernelDevice(0),
	m_hForceSchemeChangeWaitThread(NULL),
	m_dwForceSchemeChangeThreadID(0),
	m_pPreparsedData(NULL)
{
    myDebugOut ("CIDirectInputEffectDriver::Constructor (pIPIDEffectDriver:0x%0p)\n", pIPIDEffectDriver);

	// Add to gobal object count
	DllAddRef();

	// Add references for objects we are holding
	m_pIPIDClassFactory->AddRef();
	m_pIPIDEffectDriver->AddRef();


	::memset((void*)&m_HidAttributes, 0, sizeof(m_HidAttributes));

	m_ForceMapping.AssignmentBlock.CommandHeader.eID = eForceMap;
	m_ForceMapping.AssignmentBlock.CommandHeader.ulByteSize = sizeof(m_ForceMapping);
	m_ForceMapping.AssignmentBlock.ulVidPid = 0;	// Irrelevant
    m_ForceMapping.bMapYToX = FALSE;
	m_ForceMapping.usRTC = 10000;
	m_ForceMapping.usGain = 10000;
}

/*****************************************************************************
**
** CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
**
** @mfunc Destructor
**
*****************************************************************************/
CIDirectInputEffectDriver::~CIDirectInputEffectDriver()
{
	_ASSERTE(m_pIPIDEffectDriver == NULL);
	_ASSERTE(m_ulReferenceCount == 0);

	DllRelease();	// Remove our object from the global object count

    myDebugOut ("CIDirectInputEffectDriver::Destructor\n");
}


//IUnknown members
/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::QueryInterface(REFIID refiid, void** ppvObject)
**
**	@func	Query an IUnknown for a particular type. This causes reference count increase locally only.
**				If it is a type we don't know, should we give the PID driver a crack (the PID driver
**			might have a customized private interface, we don't want to ruin that). Currently not
**			going to pass on the Query because this could screwup Symmetry.
**
**	@rdesc	S_OK : all is well
**			E_INVALIDARG : if (ppvObject == NULL)
**			E_NOINTERFACE : If requested interface is unsupported
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::QueryInterface
(
	REFIID refiid,		//@parm [IN] Identifier of the requested interface
	void** ppvObject	//@parm [OUT] Address to place requested interface pointer
)
{
    myDebugOut ("CIDirectInputEffectDriver::QueryInterface (refiid:0x%0p, ppvObject:0x%0p)\n", refiid, ppvObject);

	HRESULT hrPidQuery = m_pIPIDEffectDriver->QueryInterface(refiid, ppvObject);
	if (SUCCEEDED(hrPidQuery))
	{
		// Don't perform a real addref (PID.dll::QueryInterface will do its own)
		::InterlockedIncrement((LONG*)&m_ulReferenceCount);
		*ppvObject = this;
	}
	return hrPidQuery;
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::AddRef()
**
**	@func	Bumps up the reference count
**				The PID driver reference count is left alone. We only decrement it when
**				this object is ready to go away.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::AddRef()
{
    myDebugOut ("CIDirectInputEffectDriver::AddRef (Early) 0x%0p\n", m_ulReferenceCount);
	m_pIPIDEffectDriver->AddRef();
	return (ULONG)(::InterlockedIncrement((LONG*)&m_ulReferenceCount));
}

/***********************************************************************************
**
**	ULONG CIDirectInputEffectDriver::Release()
**
**	@func	Decrements the reference count.
**				if the reference count becomes zero this object is destroyed.
**				The PID Factory reference is only effected if it is time to release all.
**
**	@rdesc	New reference count
**
*************************************************************************************/
ULONG __stdcall CIDirectInputEffectDriver::Release()
{
    myDebugOut ("CIDirectInputEffectDriver::Release (Early) 0x%0p\n", m_ulReferenceCount);
	if (m_ulReferenceCount == 0)
	{
		return m_ulReferenceCount;
	}

	if ((::InterlockedDecrement((LONG*)&m_ulReferenceCount)) != 0)
	{
		m_pIPIDEffectDriver->Release();
		return m_ulReferenceCount;
	}


	// Tell the driver to complete outstanding IOCTLs to this device
	if (m_hKernelDeviceDriver == NULL)
	{	// Don't have a handle to PID driver, so open one
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
		}
	}
	if (m_hKernelDeviceDriver != NULL)	// Handle should be open, but check just incase
    {
        DWORD dwReturnDataSize;
        BOOL fSuccess = DeviceIoControl(m_hKernelDeviceDriver, 
            IOCTL_GCK_END_FF_NOTIFICATION,
            (void*)(&m_dwGcKernelDevice), sizeof(DWORD),	// In
            NULL, 0, &dwReturnDataSize,						// Out
            NULL);

        if (!fSuccess)
            myDebugOut ("CIDirectInputEffectDriver::Release : GCK IOCTL_GCK_END_FF_NOTIFICATION failed!\n");
    
        Sleep(c_dwShutdownWait);
        
        ::CloseHandle(m_hKernelDeviceDriver);
    }
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release : Could not Open GCK for IOCTL_GCK_END_FF_NOTIFICATION\n");
    }

	// Free up the preparsed data
	if (m_pPreparsedData != NULL)
	{
		::HidD_FreePreparsedData(m_pPreparsedData);
		m_pPreparsedData = NULL;
	}

	// Close the handle to the HID path of the driver
	::CloseHandle(m_hHidDeviceDriver);
	m_hHidDeviceDriver = NULL;

	// Close the thread handle (which should be done by now)
	if (m_hForceSchemeChangeWaitThread != NULL)
	{
		::CloseHandle(m_hForceSchemeChangeWaitThread);
		m_hForceSchemeChangeWaitThread = NULL;
		m_dwForceSchemeChangeThreadID = 0;
	}
    else
    {
        myDebugOut ("CIDirectInputEffectDriver::Release() m_hForceSchemeCHangeWaitThread did not finish!\n");
    }

	// Release the low level pid driver and delete ourselves
	m_pIPIDEffectDriver->Release();
	m_pIPIDEffectDriver = NULL;

	// Release the low level factory (include extra release to fix bug in PID.dll)
	if (m_pIPIDClassFactory->Release() > 0)
	{
		m_pIPIDClassFactory->Release();
	}
	m_pIPIDClassFactory = NULL;

	delete this;
	return 0;
}

//IDirectInputEffectDriver members
HRESULT __stdcall CIDirectInputEffectDriver::DeviceID
(
	DWORD dwDIVersion,
	DWORD dwExternalID,
	DWORD dwIsBegining,
	DWORD dwInternalID,
	void* pReserved
)
{
    myDebugOut ("CIDirectInputEffectDriver::DeviceID (dwDIVersion:0x%08p dwExternalID:0x%08p dwIsBeginning:0x%08p dwInternalID:0x%08p pReserved:0x%08p)\n",
        dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Store off some data
	m_dwExternalDeviceID = dwExternalID;
	m_dwInternalDeviceID = dwInternalID;

	bool bPossiblyFirstTime = false;
	// Get a handle to the Kernel Device and activate the thread
	if (m_hKernelDeviceDriver == NULL)
	{
		bPossiblyFirstTime = true;
		m_hKernelDeviceDriver = ::CreateFile(TEXT(GCK_CONTROL_W32Name), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hKernelDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hKernelDeviceDriver = NULL;
            myDebugOut ("CIDirectInputEffectDriver::DeviceID Create GCK File Failed!\n");
		}
		else
        {
			InitHidInformation((LPDIHIDFFINITINFO)pReserved);		// Set up the HID stuff (preparsed data et al)
            
            if (NULL == pReserved || 
                IsBadReadPtr ((const void*)pReserved, (UINT) sizeof (DIHIDFFINITINFO_STRUCT)) )
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID E_INVALIDARG (pReserved is NULL!)\n");
                return E_INVALIDARG;
                // Call the default guy
                //return m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);
            }
            
            //
			// get the handle for this device
			//
			WCHAR* pwcInstanceName = ((DIHIDFFINITINFO_STRUCT*)(pReserved))->pwszDeviceInterface;
			DWORD dwBytesReturned;
			BOOL fSuccess = ::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_HANDLE,
										pwcInstanceName, ::wcslen(pwcInstanceName)*sizeof(WCHAR),
										&m_dwGcKernelDevice, sizeof(m_dwGcKernelDevice), &dwBytesReturned,
										NULL);

			if (fSuccess != FALSE)
			{
				// Update the force block
				fSuccess =::DeviceIoControl(m_hKernelDeviceDriver, IOCTL_GCK_GET_FF_SCHEME_DATA,
										(void*)(&m_dwGcKernelDevice), sizeof(DWORD),
										(void*)(&m_ForceMapping), sizeof(m_ForceMapping), &dwBytesReturned,
										NULL);

				// Get the duplicate handle for the thread
				BOOL bDuplicated = ::DuplicateHandle(::GetCurrentProcess(), m_hKernelDeviceDriver, ::GetCurrentProcess(), &m_hKernelDeviceDriverDuplicate, 0, FALSE, DUPLICATE_SAME_ACCESS);
				if ((m_hKernelDeviceDriverDuplicate == INVALID_HANDLE_VALUE) || (bDuplicated == FALSE))
				{
					m_hKernelDeviceDriverDuplicate = NULL;
				}
				else
				{
					m_hForceSchemeChangeWaitThread = ::CreateThread(NULL, 0, DoWaitForForceSchemeChange, (void*)this, 0, &m_dwForceSchemeChangeThreadID);
				}
			}
            else
            {
                myDebugOut ("CIDirectInputEffectDriver::DeviceID IOCTL_GCK_GET_HANDLE Failed!\n");
            }

			// Close since I need to reopen at the end (why is this happening?)
			::CloseHandle(m_hKernelDeviceDriver);
			m_hKernelDeviceDriver = NULL;
		}
	}

	// Hack to get PID.DLL to place keys in registry.
	// -- It won't place them if OEM-FF Key is already there
/*
	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			// Open key specific to the current device (VIDPID is in m_HidAttributes)
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			if (hkeyOEMForceFeedback != NULL)
			{
				// Check to see if the effects key is already there
				HKEY hkeyEffects = NULL;
				::RegOpenKeyEx(hkeyOEMForceFeedback, TEXT("Effects"), 0, KEY_READ, &hkeyEffects);
				::RegCloseKey(hkeyOEMForceFeedback);
				if (hkeyEffects != NULL)
				{
					// Effects key is there, this is not the first time we have run
					::RegCloseKey(hkeyEffects);
					bPossiblyFirstTime = false;
				}
				else	// Delete the whole OEM ForceFeedback key
				{
					::RegDeleteKey(hkeyOEM, rgtcDeviceName);
				}
			}
		}
		::RegCloseKey(hkeyOEM);
	}
*/
	// Call the drivers DeviceID (if we have removed the OEMFF Key it will repopulate)
	HRESULT hrPID = m_pIPIDEffectDriver->DeviceID(dwDIVersion, dwExternalID, dwIsBegining, dwInternalID, pReserved);

	// Do we need to put ourselves back as the DIEffectDriver?
/*	if (bPossiblyFirstTime == true)
	{
		HKEY hkeyOEM = NULL;
		::RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM"), 0, KEY_ALL_ACCESS, &hkeyOEM);
		if (hkeyOEM != NULL)
		{
			HKEY hkeyOEMForceFeedback = NULL;
			TCHAR rgtcDeviceName[64];
			::wsprintf(rgtcDeviceName, TEXT("VID_%04X&PID_%04X\\OEMForceFeedback"), m_HidAttributes.VendorID, m_HidAttributes.ProductID);
			::RegOpenKeyEx(hkeyOEM, rgtcDeviceName, 0, KEY_ALL_ACCESS, &hkeyOEMForceFeedback);

			// Set the registry CLSID value to us
			if (hkeyOEMForceFeedback != NULL)
			{
				::RegSetValueEx(hkeyOEMForceFeedback, TEXT("CLSID"), 0, REG_SZ, (BYTE*)CLSID_SWPIDDriver_String, _tcslen(CLSID_SWPIDDriver_String) * sizeof(TCHAR));
				::RegCloseKey(hkeyOEMForceFeedback);
			}
			::RegCloseKey(hkeyOEM);
		}
	}
*/
	return hrPID;	// Value from the System PID driver
}

HRESULT __stdcall CIDirectInputEffectDriver::GetVersions
(
	DIDRIVERVERSIONS* pDriverVersions
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetVersions (pDriverVersions:0x%08p)\n", pDriverVersions);
 	return m_pIPIDEffectDriver->GetVersions(pDriverVersions);
}

HRESULT __stdcall CIDirectInputEffectDriver::Escape
(
	DWORD dwDeviceID,
	DWORD dwEffectID,
	DIEFFESCAPE* pEscape
)
{
    myDebugOut ("CIDirectInputEffectDriver::Escape (dwDeviceID:0x%08p, dwEffectID:0x%08p, pEscape:0x%08p)\n", dwDeviceID, dwEffectID, pEscape);
	return m_pIPIDEffectDriver->Escape(dwDeviceID, dwEffectID, pEscape);
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SetGain(DWORD dwDeviceID, DWORD dwGain)
**
**	@func	Modifies the user gain based on settings and sends it down to the lower PID driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SetGain
(
	DWORD dwDeviceID,		//@parm [IN] ID for device of interest
	DWORD dwGain			//@parm [IN] User selected gain
)
{
	dwGain *= m_ForceMapping.usGain/1000;	// 0 - 100K
	dwGain /= 10;							// 0 - 10K
    myDebugOut ("CIDirectInputEffectDriver::SetGain (dwDeviceID:%d, dwGain:%05d:)\n", dwDeviceID, dwGain);
	return m_pIPIDEffectDriver->SetGain(dwDeviceID, dwGain);
}


/***********************************************************************************
**
**	HRESULT CopyW2T(LPWSTR pswDest, UINT *puDestSize, LPTSTR ptszSrc)
**
**	@mfunc	Copies a WCHAR into a TCHAR while checking buffer length
**
**	@rdesc	S_OK on success, MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER)
**			if destination buffer is too small
**
*************************************************************************************/
HRESULT CopyW2T
(
	LPTSTR ptszDest,	// @parm pointer to WCHAR destination buffer
	UINT&  ruDestSize,	// @parm size of dest in WCHAR's
	LPCWSTR pwcszSrc	// @parm pointer to NULL terminated source string
)
{

	UINT uSizeRequired;
	HRESULT hr = S_OK;
	
	uSizeRequired = wcslen(pwcszSrc)+1; //the one is for a NULL character
	if(ruDestSize < uSizeRequired)
	{
		hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INSUFFICIENT_BUFFER);
	}
	else
	{
		//
		//	we always return wide, but TCHAR can be WCHAR or char
		//	this compile time so use preprocessor
		//
		#ifdef UNICODE 
			wcscpy(ptszDest, pwcszSrc);
		#else
			int iRetVal=WideCharToMultiByte
				(
					CP_ACP,
					0,
					pwcszSrc,
					-1,
					ptszDest,
					ruDestSize,
					NULL,
					NULL
				);
			if(0==iRetVal) 
					hr=GetLastError();
		#endif //UNICODE
	}
	//Copy size required, or chars copied (same thing)
	ruDestSize = uSizeRequired;
	return hr;
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::InitHidInformation(void* HidInformation)
**
**	@func	Open a hid path to the driver, and get preparsed data and hid caps.
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::InitHidInformation
(
	LPDIHIDFFINITINFO pHIDInitInfo	//@parm [IN] Pointer to structure containing the HID device name
)
{
    myDebugOut ("CIDirectInputEffectDriver::InitHidInformation (pHIDInitInfo: 0x%08p)\n", pHIDInitInfo);
	if (pHIDInitInfo != NULL)
	{
		TCHAR ptchHidDeviceName[MAX_PATH];
		unsigned int dwSize = MAX_PATH;
		::CopyW2T(ptchHidDeviceName, dwSize, pHIDInitInfo->pwszDeviceInterface);
		m_hHidDeviceDriver = ::CreateFile(ptchHidDeviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL);
		if (m_hHidDeviceDriver == INVALID_HANDLE_VALUE)
		{
			m_hHidDeviceDriver = NULL;
			return;
		}
		if (m_pPreparsedData == NULL)
		{
			::HidD_GetPreparsedData(m_hHidDeviceDriver, &m_pPreparsedData);
			if (m_pPreparsedData == NULL)
			{
				return;
			}
		}
		::HidP_GetCaps(m_pPreparsedData, &m_HidCaps);

		// Find VID/PID the USB way!
		::HidD_GetAttributes(m_hHidDeviceDriver, &m_HidAttributes);
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendSpringChange()
**
**	@func	Sends a new Spring Modify report to the driver
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::SendSpringChange()
{
    myDebugOut ("CIDirectInputEffectDriver::SendSpringChange ()\n");
	if ((m_hHidDeviceDriver != NULL) && (m_pPreparsedData != NULL))
	{
		// Setup the spring report
		// 1. Allocate an array of max output size
		BYTE* pbOutReport = new BYTE[m_HidCaps.OutputReportByteLength];
		if (pbOutReport == NULL)
		{
			return;
		}
		// 2. Zero out array
		::memset(pbOutReport, 0, m_HidCaps.OutputReportByteLength);
		// 3. Set the proper report ID
		pbOutReport[0] = c_bSideWinderPIDReportID_SetEffect;
		// 4. Cheat since we know what the firmware is expecting (Use usage Gunk where easy)
		pbOutReport[1] = c_EffectID_RTCSpring;	// Effect Block Index (ID)
		unsigned short usRTC = m_ForceMapping.usRTC;	// 0 - 10K
		usRTC /= 100;									// 0 - 100
		usRTC *= 255;									// 0 - 25500
		usRTC /= 100;									// 0 - 255
		if (usRTC > 255)
		{
			usRTC = 255;
		}
		pbOutReport[9] = BYTE(usRTC);		// Effect Gain - Only item the RTC Spring will look at
        myDebugOut ("CIDirectInputEffectDriver::SendSpringChange -> usRTC:%03d\n", usRTC);

		// 5. Send the report down
		DWORD dwBytesWritten;
		::WriteFile(m_hHidDeviceDriver, pbOutReport, m_HidCaps.OutputReportByteLength, &dwBytesWritten, NULL);

		// 6. Deallocate report array
		delete[] pbOutReport;
	}
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::SendForceFeedbackCommand()
**
**	@func	Intercepting this call gives us the chance to set the force level of the
**			RTC Spring after a reset
**
**	@rdesc	Result of SendForceFeedbackCommand (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::SendForceFeedbackCommand
(
	DWORD dwDeviceID,		//@parm [IN] ID of device this is for
	DWORD dwState			//@parm [IN] The command (we are interested in reset)
)
{
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Enter (dwDeviceID:%x, dwState:0x%08p)\n", dwDeviceID, dwState);
	HRESULT hr = m_pIPIDEffectDriver->SendForceFeedbackCommand(dwDeviceID, dwState);
    myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand Calling Base (hr:0x%08p)\n", hr);
	if (dwState == DISFFC_RESET)	// This is how they turn on the RTC Spring
	{
        myDebugOut ("CIDirectInputEffectDriver::SendForceFeedbackCommand RESET sent!\n");
		SendSpringChange();
	}

	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::GetForceFeedbackState
(
	DWORD dwDeviceID,
	DIDEVICESTATE* pDeviceState
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState Begin (dwDeviceID:%d, pDeviceState:0x%08p)\n", dwDeviceID, pDeviceState);
	HRESULT hrPidDriver = S_OK;

	__try
	{
		hrPidDriver = m_pIPIDEffectDriver->GetForceFeedbackState(dwDeviceID, pDeviceState);
	}
	__except ((GetExceptionCode() == EXCEPTION_INT_DIVIDE_BY_ZERO) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
	{
		hrPidDriver = DIERR_INPUTLOST;
		_RPT0(_CRT_WARN, "!!! Caught EXCEPTION_INT_DIVIDE_BY_ZERO !!!\n");
	}

    myDebugOut ("CIDirectInputEffectDriver::GetForceFeedbackState End (dwDeviceID:%d, pDeviceState:0x%08p; hr: 0x%08x)\n", 
        dwDeviceID, pDeviceState, hrPidDriver);

	return hrPidDriver;
}

/***********************************************************************************
**
**	void PercentagesFromAngle()
**
**	@func	Extrapolate the percentages from the table. Makes use of the fact that
**			sin^2(angle) + cos^2(angle) = 1 and xPercentage + yPercentage = 1
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
void PercentagesFromAngle
(
	DWORD dwAngle,		//@parm [IN] Angle to convert to percentages
	LONG& lXPercent,	//@parm [OUT] Resultant X Percentage
	LONG& lYPercent		//@parm [OUT] Resultant Y Percentage
)
{
	// Get the angle mapping into the first quadrant
	DWORD dwMappingAngle = dwAngle;	// 0 - 9000
	bool bFlipSignX = false;	// X is negative in 3rd and 4th quadrants
	bool bFlipSignY = true;		// Y is negative in 1st and 4th quadrants
	if (dwAngle > 9000)
	{
		bFlipSignY = false;
		if (dwAngle > 18000)
		{
			bFlipSignX = true;
			if (dwAngle > 27000)	// 27000 - 36000
			{
				bFlipSignY = true;
				dwMappingAngle = 36000 - dwAngle;
			}
			else	// 18000 - 27000
			{
				dwMappingAngle = dwAngle - 18000;
			}
		}
		else	// 9000 - 18000
		{
			dwMappingAngle = 18000 - dwAngle;
		}
	}

	_ASSERTE(dwMappingAngle <= 9000);

	DWORD quantizedEntry = dwMappingAngle / c_dwTableQuantization;
	DWORD quantizedAngle = quantizedEntry * c_dwTableQuantization;
	if (dwMappingAngle == quantizedAngle)
	{
		lXPercent = g_PercentagesArray[quantizedEntry].dwPercentageX;
	}
	else
	{
		_ASSERTE(quantizedAngle < dwMappingAngle);
		_ASSERTE(dwMappingAngle < 9000);

		DWORD lValue = g_PercentagesArray[quantizedEntry].dwPercentageX;
		DWORD rValue = g_PercentagesArray[quantizedEntry + 1].dwPercentageX;
		long int lSlope = ((rValue - lValue) * 1000)/c_dwTableQuantization;
		lXPercent = lValue + lSlope * (dwMappingAngle - quantizedAngle);
	}

	lYPercent = 10000 - lXPercent;
	if (bFlipSignX == true)
	{
		lXPercent *= -1;
	}
	if (bFlipSignY == true)
	{
		lYPercent *= -1;
	}
}


/***********************************************************************************
**
**	void CIDirectInputEffectDriver::DownloadEffect()
**
**	@func	Intercepting this call gives us the chance to map the Y forces to the X
**			axis. Switches off the type to determine if the mapping is done.
**
**	@rdesc	Result of download (from lower driver)
**
*************************************************************************************/
HRESULT __stdcall CIDirectInputEffectDriver::DownloadEffect
(
	DWORD dwDeviceID,				//@parm [IN] ID of device this is for
	DWORD dwInternalEffectType,		//@parm [IN] Type of effect (major, minor)
	DWORD* pdwDnloadID,				//@parm [IN, OUT] >0 - ID of effect to modify. 0 new effect ID returned
	DIEFFECT* pEffect,				//@parm [IN, OUT] Structure containing effect information
	DWORD dwFlags					//@parm [IN] Download flags
)
{
/*	LogIt("CIDirectInputEffectDriver::DownloadEffect:\n");
	LogIt("\tdwInternalEffectType: 0x%08X\n", dwInternalEffectType);
	LogIt("\tpdwDnloadID: 0x%08X", pdwDnloadID);
	if (pdwDnloadID != NULL)
	{
		LogIt(" (0x%08X)", *pdwDnloadID);
	}
	LogIt("\n\tpEffect: 0x%08X\n", pEffect);
	if (pEffect != NULL)
	{
		LogIt("\t\trglDirection[0]: %ld\n", pEffect->rglDirection[0]);
		LogIt("\t\tdwFlags: 0x%08X\n", pEffect->dwFlags);
		LogIt("\t\tdwGain: 0x%08X\n", pEffect->dwGain);
	}
	LogIt("\tdwFlags: 0x%08X\n", dwFlags);
*/
	DWORD dwOriginalEffectGain = pEffect->dwGain;

    myDebugOut ("CIDirectInputEffectDriver::DownloadEffect (<NOT DEBUGGED>)\n");

	if (pEffect == NULL)
	{
		return E_INVALIDARG;
	}

	WORD wType = WORD(dwInternalEffectType & 0x0000FFFF);
	bool bGainTruncation = false;

//	case EF_BEHAVIOR:		// We don't axis-map behaviour
//	case EF_USER_DEFINED:	// We don't axis-map user defined
//	case EF_RTC_SPRING:		// We don't axis-map RTC spring
//	case EF_VFX_EFFECT:		// Visual force VFX Effect!!! Danger Will Robinson!
	if ((m_ForceMapping.bMapYToX) && ((wType >= PID_CONSTANT_FORCE) && (wType <= PID_SAWTOOTHDOWN)))
	{
		// We don't support more than 2 axes (currently), and 0 is probably an error
		if ((pEffect->cAxes > 2) || (pEffect->cAxes == 0))
		{
			return E_NOTIMPL;
		}

		// We don't support sperical (3 axis force)
		if (pEffect->dwFlags & DIEFF_SPHERICAL)
		{
			return E_NOTIMPL;	 // .. since got by axis check, programmer goofed up anyway
		}

		// Are the axes reversed?
		bool bAxesReversed = (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1);

		LONG lPercentX = 0;
		LONG lPercentY = 0;

		// Polar, figure out percentage that is X and percentage that is Y
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			if (pEffect->cAxes == 1)	// Polar coordinate must have two axes of data (because DX says so)
			{
				_RPT0(_CRT_WARN, "POLAR effect that has only one AXIS\n");
//				return E_INVALIDARG;
			}
			long int lEffectAngle = pEffect->rglDirection[0];	// in [0] even if reversed
			if (bAxesReversed == true) {	// Indicates (-1, 0) as origin instead of (0, -1)
				lEffectAngle += 27000;
			}
			while (lEffectAngle < 0)	// Make it positive
			{
				lEffectAngle += 36000;
			}
			lEffectAngle %= 36000;	// Make it from 0 to 35900

			PercentagesFromAngle(DWORD(lEffectAngle), lPercentX, lPercentY);

			// Not going to bother reseting the angle, since PID.dll just sends it down and wheel ignores Y component
		}
		else if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			// Here I remove the Y component in case PID.dll maps this to an angle.
			if (bAxesReversed == true)
			{
				lPercentX = pEffect->rglDirection[1];
				lPercentY = pEffect->rglDirection[0];
				pEffect->rglDirection[0] = 0;
			}
			else
			{
				lPercentX = pEffect->rglDirection[0];
				lPercentY = pEffect->rglDirection[1];
				pEffect->rglDirection[1] = 0;
			}
			LONG lTotal = abs(lPercentX) + abs(lPercentY);
            // DIV ZERO Bug
            // If both of the percentages are zero then do nothing
            // Jen-Hung Ho
            if (lTotal)
            {
                lPercentX = (lPercentX * 10000)/lTotal;
				if ( lPercentY > 0 )
                	lPercentY = 10000 - abs(lPercentX);
				else
					lPercentY = abs(lPercentX) - 10000;
            }
		}
		else
		{
			_ASSERTE(FALSE);
			return E_NOTIMPL;	// Some new fangled coordinate system
		}
#if 0	// tempory remove by Jen-Hung Ho
		long int lContributionY = lPercentY/c_lContributionY;
		long int lTotal = lPercentX + lContributionY;
#else
		long int lTotal;
		long int lContributionY = lPercentY/c_lContributionY;
#endif

		// If POLAR set proper angle
		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Keep as orginal code, add by Jen-Hung Ho
			lTotal = lPercentX + lContributionY;
			if (lTotal < 0)
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 0 : 27000;
			}
			else
			{
				pEffect->rglDirection[0] = (bAxesReversed == true) ? 18000 : 9000;
			}
		}
		else	// Cartesian
		{	 
			// use X axis force to determain direction, add by Jen-Hung Ho
			// Y axis force follow X axis direction
			if ( lPercentX > 0 )
				lTotal = lPercentX + abs(lContributionY);
			else if ( lPercentX < 0 )
				lTotal = lPercentX - abs(lContributionY);
			else
				lTotal = lContributionY;

			// Already removed Y above
			if (bAxesReversed == true)
			{
				pEffect->rglDirection[1] = lTotal;
			}
			else
			{
				pEffect->rglDirection[0] = lTotal;
			}
		}

		// Allmost all the time we are changing the angle (and pid always sends it anyways)
		dwFlags |= DIEP_DIRECTION;

		// We avoid causing truncation - what if there was truncation? Need to check and return
		if (pEffect->dwGain > 10000)
		{
			bGainTruncation = true;
		}

		if (pEffect->dwFlags & DIEFF_POLAR)
		{
			// Modify the gain based on lPercentX and lPercentY
			pEffect->dwGain = pEffect->dwGain * abs(lTotal);
			pEffect->dwGain /= 10000;	// Put back in range 0 - 10000
		}

		// Make sure we don't go out of range and cause DI_TRUNCATED to be returned from below
		if (pEffect->dwGain > 10000)	
		{
			pEffect->dwGain = 10000;
		}
	}
	else	// We are not mapping fix cartesian pid bug
	{
		// Cartesian
		if (pEffect->dwFlags & DIEFF_CARTESIAN)
		{
			short int xAxisIndex = 0;
			short int yAxisIndex = 1;

			// Are the axes reversed?
			if (DIDFT_GETINSTANCE(pEffect->rgdwAxes[0]) == 1)
			{
				xAxisIndex = 1;
				yAxisIndex = 0;
			}

			LONG lTotal = abs(pEffect->rglDirection[0]) + abs(pEffect->rglDirection[1]);

			// Fixup the X component so the total maginitude is base on 10K
            if (lTotal)
            {
				pEffect->rglDirection[xAxisIndex] = (10000 * pEffect->rglDirection[xAxisIndex])/lTotal;
            }

			// Remove the Y component to keep PID.dll from playing with it.
			pEffect->rglDirection[yAxisIndex] = 0;
		}
	}

	HRESULT hr = m_pIPIDEffectDriver->DownloadEffect(dwDeviceID, dwInternalEffectType, pdwDnloadID, pEffect, dwFlags);
	pEffect->dwGain = dwOriginalEffectGain;

	if ((hr == S_OK) && (bGainTruncation == true))
	{
		hr = DI_TRUNCATED;
	}

/*	LogIt("-- pdwDnloadID: 0x%08X", pdwDnloadID);
	if (pdwDnloadID != NULL)
	{
		LogIt(" (0x%08X)", *pdwDnloadID);
	}
	LogIt("--\n", hr);
*/	return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::DestroyEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Enter(dwDeviceID:%d, dwDnloadID:%d)\n", 
        dwDeviceID, dwDnloadID);

    HRESULT hr = m_pIPIDEffectDriver->DestroyEffect(dwDeviceID, dwDnloadID);
    myDebugOut ("CIDirectInputEffectDriver::DestroyEffect Exit (hr:0x%08p)\n", hr); 
    return hr;
}

HRESULT __stdcall CIDirectInputEffectDriver::StartEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD dwMode,
	DWORD dwIterations
)
{
    myDebugOut ("CIDirectInputEffectDriver::StartEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StartEffect(dwDeviceID, dwDnloadID, dwMode, dwIterations);
}

HRESULT __stdcall CIDirectInputEffectDriver::StopEffect
(
	DWORD dwDeviceID,
	DWORD dwDnloadID
)
{
    myDebugOut ("CIDirectInputEffectDriver::StopEffect (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->StopEffect(dwDeviceID, dwDnloadID);
}

HRESULT __stdcall CIDirectInputEffectDriver::GetEffectStatus
(
	DWORD dwDeviceID,
	DWORD dwDnloadID,
	DWORD* pdwStatusCode
)
{
    myDebugOut ("CIDirectInputEffectDriver::GetEffectStatus (<NOT DEBUGGED>)\n");
	return m_pIPIDEffectDriver->GetEffectStatus(dwDeviceID, dwDnloadID, pdwStatusCode);
}

DWORD __stdcall DoWaitForForceSchemeChange(void* pParameter)
{
    myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange (pParameter: 0x%08p)\n", pParameter);

	CIDirectInputEffectDriver* pIDirectInputEffectDriver = (CIDirectInputEffectDriver*)pParameter;
    //TODO remove this it could be really slow!
    if (IsBadReadPtr ((const void*)pParameter, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver DoWaitForForceSchemeChange pParameter is not a valid read ptr!\n");
    }
	if (pIDirectInputEffectDriver != NULL)
	{
		pIDirectInputEffectDriver->WaitForForceSchemeChange();
	}

	return 0;
}

/***********************************************************************************
**
**	void CIDirectInputEffectDriver::WaitForForceSchemeChange()
**
**	@func	Thread waits on the Event signal for force scheme change until the object goes away.
**			If event is signaled, WaitForForceSchemeChange() is called
**
**	@rdesc	Nothing
**
*************************************************************************************/
void CIDirectInputEffectDriver::WaitForForceSchemeChange()
{
	_ASSERTE(m_hKernelDeviceDriverDuplicate != NULL);
    if (IsBadReadPtr ((const void*)this, sizeof CIDirectInputEffectDriver))
    {
        myDebugOut ("CIDirectInputEffectDriver WaitForForceSchemeChange is not a valid read ptr!\n");
    }

	FORCE_BLOCK forceMap;
	DWORD dwReturnDataSize = 0;
	for (;m_ulReferenceCount != 0;)
	{
		// Set up the IOCTL
		BOOL bRet = ::DeviceIoControl(m_hKernelDeviceDriverDuplicate, IOCTL_GCK_NOTIFY_FF_SCHEME_CHANGE,
							(void*)(&m_dwGcKernelDevice), sizeof(DWORD),					// In
							(void*)(&forceMap), sizeof(forceMap), &dwReturnDataSize,		// Out
							NULL);
		_RPT0(_CRT_WARN, "Returned from Scheme Change!\n");
		if ((m_ulReferenceCount != 0) && (bRet != FALSE) && (dwReturnDataSize == sizeof(forceMap)))
		{
			// Need a mutext here
			m_ForceMapping = forceMap;
			SendSpringChange();
			SetGain(m_dwInternalDeviceID, 10000);
		}
		else
		{	// We are done
			::CloseHandle(m_hKernelDeviceDriverDuplicate);
			m_hKernelDeviceDriverDuplicate = NULL;
			ExitThread(2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
		*(rkey.m_pReferenceCount) = 1;
	}

	m_pReferenceCount = rkey.m_pReferenceCount;
	++(*m_pReferenceCount);
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
		*(rhs.m_pReferenceCount) = 1;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_pReferenceCount = rhs.m_pReferenceCount;
	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	++(*m_pReferenceCount);

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ KEY_ALL_ACCESS, NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenNextSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName, REGSAM access)
{
	if (m_OSRegistryKey == NULL)
	{
		return c_InvalidKey;
	}

	TCHAR rgtcName[256];
	DWORD dwNameSize = 256;

	if (::RegEnumKeyEx(m_OSRegistryKey, ulCookie, rgtcName, &dwNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
	{
		if (subkeyName != NULL) {
			_tcscpy(subkeyName, rgtcName);
		}

		ulCookie++;
		return OpenSubkey(rgtcName, access);
	}

	return c_InvalidKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpdflt2.dll\usbwheeleffectdriverentrypoints.cpp ===
//	@doc
/**********************************************************************
*
*	@module	USEWheelEffectDriverEntryPoints.cpp	|
*
*	Contains DLL Entry points
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	DLL Entry points	|
*		DllMain - Main Entry Point for DLL (Process/Thread Attach/Detach)
*		DllCanUnloadNow - Can the DLL be removed from memory
*		DllGetClassObject - Retreive the Class Factory
*		DllRegisterServer - Insert keys into the system registry
*		DLLUnRefisterServer - Remove keys from the system registry
*
**********************************************************************/
#include <windows.h>
#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include "Registry.h"
#include <crtdbg.h>

// From objbase.h
WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject = NULL;
LONG g_lObjectCount = 0;
HINSTANCE g_hLocalInstance = NULL;

GUID g_guidSystemPIDDriver = { // EEC6993A-B3FD-11D2-A916-00C04FB98638
	0xEEC6993A,
	0xB3FD,
	0x11D2,
	{ 0xA9, 0x16, 0x00, 0xC0, 0x4F, 0xB9, 0x86, 0x38 }
};

extern TCHAR CLSID_SWPIDDriver_String[] = TEXT("{db11d351-3bf6-4f2c-a82b-b26cb9676d2b}");

#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder PID Filter Object")
#define THREADING_MODEL_STRING TEXT("Both")

/***********************************************************************************
**
**	BOOL DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
**
**	@func	Process/Thread is Attaching/Detaching
**
**	@rdesc	TRUE always
**
*************************************************************************************/
BOOL __stdcall DllMain
(
	HINSTANCE hInstance,	//@parm [IN] Instance of the DLL
	DWORD dwReason,			//@parm [IN] Reason for this call
	LPVOID lpReserved		//@parm [IN] Reserved - Ignored
)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_hLocalInstance = hInstance;
	}
	return TRUE;
}

/***********************************************************************************
**
**	HRESULT DllCanUnloadNow()
**
**	@func	Query the DLL for Unloadability
**
**	@rdesc	If there are any object S_FALSE, else S_OK
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllCanUnloadNow()
{
	if (g_lObjectCount > 0)
	{
		return S_FALSE;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
**
**	@func	Retrieve the requested Factory
**
**	@rdesc	E_INVALIDARG: if (ppv == NULL)
**			E_NOMEMORY: if can't create the object
**			S_OK: if all is well
**			E_NOINTERFACE: if interface is not supported
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllGetClassObject
(
	REFCLSID rclsid,
	REFIID riid,		//@parm [IN] ID of requested interface on retrieved object
	LPVOID* ppv			//@parm [OUT] Address of location for returned interface
)
{
	if (ppv == NULL)
	{
		return E_INVALIDARG;
	}
	*ppv = NULL;

	if (g_pClassFactoryObject == NULL)
	{
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

		// Need to get the PID Class Factory
		IClassFactory* pIClassFactory = NULL;
		HRESULT hrGetPIDFactory = ::CoGetClassObject(g_guidSystemPIDDriver, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pIClassFactory);
		if (FAILED(hrGetPIDFactory) || (pIClassFactory == NULL))
		{
			return hrGetPIDFactory;
		}

		g_pClassFactoryObject = new CIDirectInputEffectDriverClassFactory(pIClassFactory);
		pIClassFactory->Release();	// CIDirectInputEffectDriverClassFactory adds a reference
		if (g_pClassFactoryObject == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		g_pClassFactoryObject->AddRef();
	}

	HRESULT hrQuery = g_pClassFactoryObject->QueryInterface(riid, ppv);
	g_pClassFactoryObject->Release();		// Force a release (we start with 1)
	return hrQuery;
}

/***********************************************************************************
**
**	HRESULT DllRegisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllRegisterServer()
{
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey)
	{
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_SWPIDDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR rgtcFileName[MAX_PATH];
			DWORD dwNameSize = ::GetModuleFileName(g_hLocalInstance, rgtcFileName, MAX_PATH);
			if (dwNameSize > 0) {
				rgtcFileName[dwNameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)rgtcFileName, sizeof(rgtcFileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
	}

	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllUnregisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllUnregisterServer()
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_SWPIDDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_SWPIDDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}

LONG DllAddRef()
{
	_RPT1(_CRT_WARN, "(DllAddRef)g_lObjectCount: %d\n", g_lObjectCount);
	return ::InterlockedIncrement(&g_lObjectCount);
}

LONG DllRelease()
{
	_RPT1(_CRT_WARN, "(DllRelease)g_lObjectCount: %d\n", g_lObjectCount);
	DWORD dwCount = ::InterlockedDecrement(&g_lObjectCount);
	if (dwCount == 0)
	{
		g_pClassFactoryObject = NULL;
		::CoUninitialize();
	}
	return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\usbwheeleffectdriverentrypoints.cpp ===
//	@doc
/**********************************************************************
*
*	@module	USEWheelEffectDriverEntryPoints.cpp	|
*
*	Contains DLL Entry points
*
*	History
*	----------------------------------------------------------
*	Matthew L. Coill	(mlc)	Original	Jul-7-1999
*
*	(c) 1999 Microsoft Corporation. All right reserved.
*
*	@topic	DLL Entry points	|
*		DllMain - Main Entry Point for DLL (Process/Thread Attach/Detach)
*		DllCanUnloadNow - Can the DLL be removed from memory
*		DllGetClassObject - Retreive the Class Factory
*		DllRegisterServer - Insert keys into the system registry
*		DLLUnRefisterServer - Remove keys from the system registry
*
**********************************************************************/
#include <windows.h>
#include "IDirectInputEffectDriverClassFactory.h"
#include "IDirectInputEffectDriver.h"
#include "Registry.h"
#include <crtdbg.h>

// From objbase.h
WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

CIDirectInputEffectDriverClassFactory* g_pClassFactoryObject = NULL;
LONG g_lObjectCount = 0;
HINSTANCE g_hLocalInstance = NULL;

GUID g_guidSystemPIDDriver = { // EEC6993A-B3FD-11D2-A916-00C04FB98638
	0xEEC6993A,
	0xB3FD,
	0x11D2,
	{ 0xA9, 0x16, 0x00, 0xC0, 0x4F, 0xB9, 0x86, 0x38 }
};

extern TCHAR CLSID_SWPIDDriver_String[] = TEXT("{0914ff80-3477-11d3-8cbd-00c04f8eebb9}");

#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder PID Filter Object")
#define THREADING_MODEL_STRING TEXT("Both")

/***********************************************************************************
**
**	BOOL DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
**
**	@func	Process/Thread is Attaching/Detaching
**
**	@rdesc	TRUE always
**
*************************************************************************************/
BOOL __stdcall DllMain
(
	HINSTANCE hInstance,	//@parm [IN] Instance of the DLL
	DWORD dwReason,			//@parm [IN] Reason for this call
	LPVOID lpReserved		//@parm [IN] Reserved - Ignored
)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_hLocalInstance = hInstance;
	}
	return TRUE;
}

/***********************************************************************************
**
**	HRESULT DllCanUnloadNow()
**
**	@func	Query the DLL for Unloadability
**
**	@rdesc	If there are any object S_FALSE, else S_OK
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllCanUnloadNow()
{
	if (g_lObjectCount > 0)
	{
		return S_FALSE;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
**
**	@func	Retrieve the requested Factory
**
**	@rdesc	E_INVALIDARG: if (ppv == NULL)
**			E_NOMEMORY: if can't create the object
**			S_OK: if all is well
**			E_NOINTERFACE: if interface is not supported
**
*************************************************************************************/
extern "C" HRESULT __stdcall DllGetClassObject
(
	REFCLSID rclsid,
	REFIID riid,		//@parm [IN] ID of requested interface on retrieved object
	LPVOID* ppv			//@parm [OUT] Address of location for returned interface
)
{
	if (ppv == NULL)
	{
		return E_INVALIDARG;
	}
	*ppv = NULL;

	if (g_pClassFactoryObject == NULL)
	{
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

		// Need to get the PID Class Factory
		IClassFactory* pIClassFactory = NULL;
		HRESULT hrGetPIDFactory = ::CoGetClassObject(g_guidSystemPIDDriver, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pIClassFactory);
		if (FAILED(hrGetPIDFactory) || (pIClassFactory == NULL))
		{
			return hrGetPIDFactory;
		}

		g_pClassFactoryObject = new CIDirectInputEffectDriverClassFactory(pIClassFactory);
		pIClassFactory->Release();	// CIDirectInputEffectDriverClassFactory adds a reference
		if (g_pClassFactoryObject == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		g_pClassFactoryObject->AddRef();
	}

	HRESULT hrQuery = g_pClassFactoryObject->QueryInterface(riid, ppv);
	g_pClassFactoryObject->Release();		// Force a release (we start with 1)
	return hrQuery;
}

/***********************************************************************************
**
**	HRESULT DllRegisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllRegisterServer()
{
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey)
	{
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_SWPIDDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR rgtcFileName[MAX_PATH];
			DWORD dwNameSize = ::GetModuleFileName(g_hLocalInstance, rgtcFileName, MAX_PATH);
			if (dwNameSize > 0) {
				rgtcFileName[dwNameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)rgtcFileName, sizeof(rgtcFileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
	}

	return S_OK;
}

/***********************************************************************************
**
**	HRESULT DllUnregisterServer()
**
**	@func	
**
**	@rdesc	
**
*************************************************************************************/
HRESULT __stdcall DllUnregisterServer()
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_SWPIDDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_SWPIDDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}

LONG DllAddRef()
{
	_RPT1(_CRT_WARN, "(DllAddRef)g_lObjectCount: %d\n", g_lObjectCount);
	return ::InterlockedIncrement(&g_lObjectCount);
}

LONG DllRelease()
{
	_RPT1(_CRT_WARN, "(DllRelease)g_lObjectCount: %d\n", g_lObjectCount);
	DWORD dwCount = ::InterlockedDecrement(&g_lObjectCount);
	if (dwCount == 0)
	{
		g_pClassFactoryObject = NULL;
		::CoUninitialize();
	}
	return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
		*(rkey.m_pReferenceCount) = 1;
	}

	m_pReferenceCount = rkey.m_pReferenceCount;
	++(*m_pReferenceCount);
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
		*(rhs.m_pReferenceCount) = 1;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_pReferenceCount = rhs.m_pReferenceCount;
	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	++(*m_pReferenceCount);

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ KEY_ALL_ACCESS, NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenNextSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName, REGSAM access)
{
	if (m_OSRegistryKey == NULL)
	{
		return c_InvalidKey;
	}

	TCHAR rgtcName[256];
	DWORD dwNameSize = 256;

	if (::RegEnumKeyEx(m_OSRegistryKey, ulCookie, rgtcName, &dwNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
	{
		if (subkeyName != NULL) {
			_tcscpy(subkeyName, rgtcName);
		}

		ulCookie++;
		return OpenSubkey(rgtcName, access);
	}

	return c_InvalidKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swpidflt.dll\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenNextSubkey(ULONG& ulCookie, TCHAR* subkeyName = NULL, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swusbflt.sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SWUsbFlt.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swusbflt.sys\swusbfltshell.c ===
//	@doc
/**********************************************************************
*
*	@module	SwUsbFltShell.c	|
*
*	Basic driver entry points for SwUsbFlt.sys
*
*	History
*	----------------------------------------------------------
*	Matthew L Coill	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	SwUsbFltShell	|
*	Contains the most basic driver entry points (that any WDM driver
*	would have) for SwUsbFlt.sys.
*
**********************************************************************/
#define __DEBUG_MODULE_IN_USE__ SWUSBFLTSHELL_C

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include "SwUsbFltShell.h"

typedef unsigned char BYTE;

// Some Local defines for HID
#define HID_REQUEST_TYPE 0x22
#define HID_REPORT_REQUEST 0xA
#define USB_INTERFACE_CLASS_HID     0x03
#define DESCRIPTOR_TYPE_CONFIGURATION 0x22

// Memory TAG
#define SWFILTER_TAG (ULONG)'lfWS'

// Forward Definitions
NTSTATUS SWUSB_AddDevice(IN PDRIVER_OBJECT, IN PDEVICE_OBJECT);
NTSTATUS SWUSB_Power(IN PDEVICE_OBJECT, IN PIRP);
VOID SWUSB_Unload(IN PDRIVER_OBJECT);

//
//	Mark the pageable routines as such
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, SWUSB_AddDevice)
#pragma alloc_text (PAGE, SWUSB_Unload)
#pragma alloc_text (PAGE, SWUSB_Power)
#pragma alloc_text (PAGE, SWUSB_PnP)
#endif

/***********************************************************************************
**
**	NTSTATUS DriverEntry(IN PDRIVER_OBJECT  pDriverObject,  IN PUNICODE_STRING pRegistryPath )
**
**	@func	Standard DriverEntry routine
**
**	@rdesc	STATUS_SUCCESS or various errors
**
*************************************************************************************/
NTSTATUS DriverEntry
(
	IN PDRIVER_OBJECT  pDriverObject,	// @parm Driver Object
	IN PUNICODE_STRING puniRegistryPath	// @parm Path to driver specific registry section.
)
{
	int i;
                
    UNREFERENCED_PARAMETER (puniRegistryPath);
	
	PAGED_CODE();
	KdPrint(("Built %s at %s\n", __DATE__, __TIME__));
	KdPrint(("Entering DriverEntry, pDriverObject = 0x%0.8x\n", pDriverObject));
    
	//	Hook all IRPs so we can pass them on.
	for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION;	i++)
	{
        pDriverObject->MajorFunction[i] = SWUSB_Pass;
    }

	//	Define entries for IRPs we expect to handle
	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = SWUSB_Ioctl_Internal;
	pDriverObject->MajorFunction[IRP_MJ_PNP]            = SWUSB_PnP;
	pDriverObject->MajorFunction[IRP_MJ_POWER]			= SWUSB_Power;
	pDriverObject->DriverExtension->AddDevice           = SWUSB_AddDevice;
    pDriverObject->DriverUnload                         = SWUSB_Unload;

    return STATUS_SUCCESS;
}

/***********************************************************************************
**
**	VOID SWUSB_Unload(IN PDRIVER_OBJECT pDriverObject)
**
**	@func	Called to unload driver deallocate any memory here
**
*************************************************************************************/
VOID SWUSB_Unload
(
	IN PDRIVER_OBJECT pDriverObject		//@parm Driver Object for our driver
)
{
    PAGED_CODE();
	UNREFERENCED_PARAMETER(pDriverObject);

	KdPrint(("SWUsbFlt.sys unloading\n"));

	return;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPhysicalDeviceObject)
**
**	@func	Handles AddDevice calls from PnP system, create filter device and
**			attach to top of stack.
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_AddDevice
(
	IN PDRIVER_OBJECT pDriverObject,			// @parm Driver object to create filter device for
	IN PDEVICE_OBJECT pPhysicalDeviceObject		// @parm PDO for device to create
)
{
    NTSTATUS			NtStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT		pDeviceObject = NULL;
	PSWUSB_FILTER_EXT	pFilterExt = NULL;
    
    PAGED_CODE();
    KdPrint(("Entering SWUSB_AddDevice, pDriverObject = 0x%0.8x, pPDO = 0x%0.8x\n", pDriverObject, pPhysicalDeviceObject));
	    
    // Create a filter device object.
    NtStatus = IoCreateDevice(pDriverObject,
                             sizeof (SWUSB_FILTER_EXT),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &pDeviceObject);

    if (!NT_SUCCESS (NtStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
		KdPrint(("Failed to create filter device object\n"));
		KdPrint(("Exiting AddDevice(prematurely) Status: 0x%0.8x\n", NtStatus));
        return NtStatus;
    }

    // Initialize the the device extension.
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension; // Get pointer to extension
	pFilterExt->pPDO = pPhysicalDeviceObject; // Remember our PDO
	pFilterExt->pTopOfStack = NULL; //We are not attached to stack yet
	// We don't have the pipe information until PNP StartDevice
	RtlZeroMemory(&(pFilterExt->outputPipeInfo), sizeof(USBD_PIPE_INFORMATION));

	//we use the same IO method as hidclass.sys, which DO_DIRECT_IO
	pDeviceObject->StackSize = pPhysicalDeviceObject->StackSize + 1;
	pDeviceObject->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    pFilterExt->pTopOfStack = IoAttachDeviceToDeviceStack (pDeviceObject, pPhysicalDeviceObject);
    
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    ASSERT (NULL != pFilterExt->pTopOfStack);

	KdPrint(("Exiting SWUSB_AddDevice with STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}

NTSTATUS SWUSB_SubmitUrb
(
	IN PDEVICE_OBJECT pDeviceObject,	//@parm [OUT] Device Object to submit URB on
	IN PURB pUrb						//@parm [OUT] URB to submit	
)
{
    NTSTATUS NtStatus;
	PSWUSB_FILTER_EXT pFilterExt;
    PIRP pIrp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION pNextStack;

	KdPrint(("Entering SWUSB_SubmitUrb\n"));
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;

    // issue a synchronous request to read the UTB
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB,
                                        pFilterExt->pTopOfStack,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE, /* INTERNAL */
                                        &event,
                                        &ioStatus);

	if (pIrp)
	{	// pass the URB to the USB 'class driver'
		pNextStack = IoGetNextIrpStackLocation(pIrp);
		ASSERT(pNextStack != NULL);
		pNextStack->Parameters.Others.Argument1 = pUrb;

		NtStatus = IoCallDriver(pFilterExt->pTopOfStack, pIrp);
		if (NtStatus == STATUS_PENDING) {
			NTSTATUS waitStatus;

			// Specify a timeout of 5 seconds for this call to complete.
			LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

			waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeout);
			if (waitStatus == STATUS_TIMEOUT)
			{	//  Cancel the Irp we just sent.
				IoCancelIrp(pIrp);

				//  Now wait for the Irp to be cancelled/completed below
				waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

                /*
                 *  Note - Return STATUS_IO_TIMEOUT, not STATUS_TIMEOUT.
                 *  STATUS_IO_TIMEOUT is an NT error status, STATUS_TIMEOUT is not.
                 */
                ioStatus.Status = STATUS_IO_TIMEOUT;
			}

			// USBD maps the error code for us
			NtStatus = ioStatus.Status;
		}
	} 
	else 
	{
		NtStatus = STATUS_INSUFFICIENT_RESOURCES;
	}

	KdPrint(("Exiting SWUSB_SubmitUrb\n"));
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_GetConfigurationDescriptor(IN PDEVICE_OBJECT pDeviceObject, OUT USB_CONFIGURATION_DESCRIPTOR** ppUCD)
**
**	@func	Retreive the Full Configuration Descriptor from the device
**
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_GetConfigurationDescriptor
(
	IN PDEVICE_OBJECT pDeviceObject,			// @parm [IN] Pointer to our DeviceObject
	OUT USB_CONFIGURATION_DESCRIPTOR** ppUCD	// @parm [OUT] Usb Configuration Descriptor (allocated here)
)
{
	NTSTATUS NtStatus;
	PURB pDescriptorRequestUrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), SWFILTER_TAG);
	USB_CONFIGURATION_DESCRIPTOR sizingUCD;

	// Null out incase of error
	*ppUCD = NULL;
	KdPrint(("Entering SWUSB_GetConfigurationDescriptor\n"));
	if (pDescriptorRequestUrb == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Create and send a size gathering descriptor
	UsbBuildGetDescriptorRequest(
		pDescriptorRequestUrb,
		sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
		USB_CONFIGURATION_DESCRIPTOR_TYPE,
		1,
		0,
		&sizingUCD,
		NULL,
		sizeof(USB_CONFIGURATION_DESCRIPTOR),
		NULL
	);
	NtStatus = SWUSB_SubmitUrb(pDeviceObject, pDescriptorRequestUrb);

	if (NT_SUCCESS(NtStatus))
	{	// Allocate the UCD, Create and send an URB to retreive the information
		*ppUCD = ExAllocatePoolWithTag(NonPagedPool, sizingUCD.wTotalLength, SWFILTER_TAG);
		if (*ppUCD == NULL)
		{
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		}
		else
		{
			UsbBuildGetDescriptorRequest(
				pDescriptorRequestUrb,
				sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
				USB_CONFIGURATION_DESCRIPTOR_TYPE,
				1,
				0,
				*ppUCD,
				NULL,
				sizingUCD.wTotalLength,
				NULL
			);
			NtStatus = SWUSB_SubmitUrb(pDeviceObject, pDescriptorRequestUrb);
		}
	}

	// Deallocate the URB
	ExFreePool(pDescriptorRequestUrb);
	KdPrint(("Exiting SWUSB_GetConfigurationDescriptor\n"));
	return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS StartDeviceComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, PVOID pvContext)
**
**	@func	StartDeviceComplete
**
**	@rdesc	STATUS_SUCCESS always
**
*************************************************************************************/
NTSTATUS StartDeviceComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	PVOID pvContext		// @parm Actually a pointer to an event to signal
)
{
	PKEVENT pNotifyEvent;
	UNREFERENCED_PARAMETER(pDeviceObject);

	UNREFERENCED_PARAMETER(pIrp);

	// Cast context to device extension
	pNotifyEvent = (PKEVENT)pvContext;
	KeSetEvent(pNotifyEvent, IO_NO_INCREMENT, FALSE);
		
	// Done with this IRP let the system finish with it
	return STATUS_MORE_PROCESSING_REQUIRED;
}


/***********************************************************************************
**
**	NTSTATUS SWUSB_PnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Handles IRP_MJ_PnP
**
**	@rdesc	STATUS_SUCCESS, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_PnP
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object for our context
	IN PIRP pIrp						// @parm IRP to handle
)
{
	NTSTATUS            NtStatus = STATUS_SUCCESS;
	PSWUSB_FILTER_EXT	pFilterExt;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		*ppPrevDeviceObjectPtr;
	PDEVICE_OBJECT		pCurDeviceObject;
	BOOLEAN				fRemovedFromList;
	BOOLEAN				fFoundOne;

	PAGED_CODE();
	
	//cast device extension to proper type
	pFilterExt = (PSWUSB_FILTER_EXT) pDeviceObject->DeviceExtension;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch (pIrpStack->MinorFunction) {

		case IRP_MN_REMOVE_DEVICE:
		{
			KdPrint(("IRP_MN_REMOVE_DEVICE\n"));

			// Send on the remove IRP
			IoSkipCurrentIrpStackLocation (pIrp);
			NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

			// Clean up
			IoDetachDevice (pFilterExt->pTopOfStack);	//Detach from top of stack
			IoDeleteDevice (pDeviceObject);				//Delete ourselves

			// Must succeed this (???)
			return STATUS_SUCCESS;
		};
		case IRP_MN_START_DEVICE:
		case IRP_MN_QUERY_DEVICE_RELATIONS:
		case IRP_MN_QUERY_STOP_DEVICE:
		case IRP_MN_QUERY_REMOVE_DEVICE:
		case IRP_MN_SURPRISE_REMOVAL:
		case IRP_MN_STOP_DEVICE:			
		case IRP_MN_CANCEL_STOP_DEVICE:
		case IRP_MN_CANCEL_REMOVE_DEVICE:
		case IRP_MN_QUERY_INTERFACE:
		case IRP_MN_QUERY_CAPABILITIES:
		case IRP_MN_QUERY_RESOURCES:
		case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
		case IRP_MN_READ_CONFIG:
		case IRP_MN_WRITE_CONFIG:
		case IRP_MN_EJECT:
		case IRP_MN_SET_LOCK:
		case IRP_MN_QUERY_ID:
		case IRP_MN_QUERY_PNP_DEVICE_STATE:
		default:
			IoSkipCurrentIrpStackLocation (pIrp);
			NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
			break;
	}
	
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS ReportDescriptorComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, PVOID pvContext)
**
**	@func	ReportDescriptorComplete
**
**	@rdesc	STATUS_SUCCESS always
**
*************************************************************************************/
NTSTATUS ReportDescriptorComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	PVOID pvContext		// @parm Actually a pointer to an event to signal
)
{
	PKEVENT pNotifyEvent;

	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(pIrp);

	// Cast context to device extension
	pNotifyEvent = (PKEVENT)pvContext;
	KeSetEvent(pNotifyEvent, IO_NO_INCREMENT, FALSE);
		
	// Done with this IRP let the system finish with it
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***********************************************************************************
**
**	NTSTATUS SelectConfigComplete(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp, PVOID pvContext)
**
**	@func	SelectConfigComplete
**
**	@rdesc	STATUS_SUCCESS always
**
*************************************************************************************/
NTSTATUS SelectConfigComplete
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp,
	PVOID pvContext		// @parm Actually a pointer to an event to signal
)
{
	PKEVENT pNotifyEvent;
	USBD_INTERFACE_INFORMATION* pUsbInterfaceInformation;
	PSWUSB_FILTER_EXT pFilterExt;
	PURB pUrb = URB_FROM_IRP(pIrp);
	ULONG pipeIndex;
	pFilterExt = pDeviceObject->DeviceExtension;
	if (pIrp->IoStatus.Status == STATUS_SUCCESS)
	{
		pUsbInterfaceInformation = &(pUrb->UrbSelectConfiguration.Interface);
			
				for (pipeIndex = 0; pipeIndex < pUsbInterfaceInformation->NumberOfPipes; pipeIndex++){
					if ((pUsbInterfaceInformation->Pipes[pipeIndex].EndpointAddress & USB_ENDPOINT_DIRECTION_MASK) == 0)
					{
						if (pUsbInterfaceInformation->Pipes[pipeIndex].PipeType == UsbdPipeTypeInterrupt)
						{
							pFilterExt->outputPipeInfo = pUsbInterfaceInformation->Pipes[pipeIndex];
							break;
						}
					}
				}
	}
	//If the IRP failed somehow, make sure outputPipeInfo stays NULL
	else RtlZeroMemory(&(pFilterExt->outputPipeInfo), sizeof(USBD_PIPE_INFORMATION));

	// Cast context to device extension
	pNotifyEvent = (PKEVENT)pvContext;
	KeSetEvent(pNotifyEvent, IO_NO_INCREMENT, FALSE);
		
	// Done with this IRP let the system finish with it
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_Ioctl_Internal(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	IRP_MJ_INTERNAL_IOCTL
**
**	@rdesc	STATUS_SUCCES, or various errors
**
*************************************************************************************/
NTSTATUS SWUSB_Ioctl_Internal
(
	IN PDEVICE_OBJECT pDeviceObject,	// @parm pointer to Device Object
	IN PIRP pIrp						// @parm pointer to IRP
)
{
   	NTSTATUS	NtStatus;
	NTSTATUS	NTStatus2;
	ULONG		uIoctl;
	PSWUSB_FILTER_EXT	pFilterExt;
		
	uIoctl = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode;
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;

	switch (uIoctl)
	{
		case IOCTL_INTERNAL_USB_SUBMIT_URB:
		{
			PURB pUrb = URB_FROM_IRP(pIrp);
			//Only handle this if it's a HID descriptor request and we have a pipe handle
			if (pUrb->UrbHeader.Function == URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE &&
				pUrb->UrbControlDescriptorRequest.DescriptorType == DESCRIPTOR_TYPE_CONFIGURATION &&
				pFilterExt->outputPipeInfo.PipeHandle != NULL)
			{

				BYTE* pOutData = NULL;
				KEVENT irpCompleteEvent;
				PURB pInterruptUrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), SWFILTER_TAG);
				KdPrint(("IOCTL_INTERNAL_USB_SUBMIT_URB\n"));
				
				if (pInterruptUrb == NULL)
				{
					pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					IoCompleteRequest(pIrp, IO_NO_INCREMENT);
					KdPrint(("IOCTL_INTERNAL_USB_SUBMIT_URB -- STATUS_INSUFFICIENT_RESOURCES\n"));
					return STATUS_INSUFFICIENT_RESOURCES;
				}
				pOutData = ExAllocatePoolWithTag(NonPagedPool, sizeof(BYTE)*2, SWFILTER_TAG);
				if (pOutData == NULL)
				{
					ExFreePool(pInterruptUrb);
					pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					IoCompleteRequest(pIrp, IO_NO_INCREMENT);
					KdPrint(("IOCTL_INTERNAL_USB_SUBMIT_URB (1) -- STATUS_INSUFFICIENT_RESOURCES\n"));
					return STATUS_INSUFFICIENT_RESOURCES;
				}
				pOutData[0] = 0x0D;
				pOutData[1] = 0xFF;
				UsbBuildInterruptOrBulkTransferRequest(
					pInterruptUrb,
					sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
					pFilterExt->outputPipeInfo.PipeHandle,
					pOutData,
					NULL,
					2,
					USBD_SHORT_TRANSFER_OK,
					NULL
				);

				KeInitializeEvent(&irpCompleteEvent, NotificationEvent, FALSE);
				IoCopyCurrentIrpStackLocationToNext(pIrp);
				IoSetCompletionRoutine(pIrp, ReportDescriptorComplete, (PVOID)(&irpCompleteEvent), TRUE, TRUE, TRUE);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				if (NtStatus == STATUS_PENDING)
				{
					KeWaitForSingleObject(&irpCompleteEvent, Executive, KernelMode, FALSE, 0);
				}
				NtStatus = pIrp->IoStatus.Status;

				NTStatus2 = SWUSB_SubmitUrb(pDeviceObject, pInterruptUrb);
			
				ExFreePool(pOutData);
				ExFreePool(pInterruptUrb);
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				return NtStatus;
			}
			if ((pUrb->UrbHeader.Function == URB_FUNCTION_SELECT_CONFIGURATION))
			{
				KEVENT irpCompleteEvent;
				KeInitializeEvent(&irpCompleteEvent, NotificationEvent, FALSE);
				IoCopyCurrentIrpStackLocationToNext(pIrp);
				IoSetCompletionRoutine(pIrp, SelectConfigComplete, (PVOID)(&irpCompleteEvent), TRUE, TRUE, TRUE);
				NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
				if (NtStatus == STATUS_PENDING)
				{
					KeWaitForSingleObject(&irpCompleteEvent, Executive, KernelMode, FALSE, 0);
				}
				NtStatus = pIrp->IoStatus.Status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
				return NtStatus;
			}
		}
	}

	IoSkipCurrentIrpStackLocation (pIrp);
	NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);
	
    return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_Power(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Passes on power IRPs to lower drivers 
**
**	@rdesc	Status from lower level driver
**
*************************************************************************************/
NTSTATUS SWUSB_Power
(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
)
{
	NTSTATUS NtStatus;
	PSWUSB_FILTER_EXT pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;

	PAGED_CODE();

	KdPrint(("SWUSB_Power() - Entering\n"));
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	NtStatus = PoCallDriver(pFilterExt->pTopOfStack, pIrp);
	KdPrint(("SWUSB_Power() - Exiting\n"));
	return NtStatus;
}

/***********************************************************************************
**
**	NTSTATUS SWUSB_Pass (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
**
**	@func	Passes on unhandled IRPs to lower drivers DEBUG version trace out info
**			Cannot be pageable since we have no idea what IRPs we're getting.
**
**	@rdesc	STATUS_SUCCESS, various errors
**
*************************************************************************************/
NTSTATUS SWUSB_Pass ( 
	IN PDEVICE_OBJECT pDeviceObject,	// @parm Device Object as our context
	IN PIRP pIrp						// @parm IRP to pass on
)
{
	NTSTATUS			NtStatus;
	PSWUSB_FILTER_EXT	pFilterExt;
	KdPrint(("SWUSB_Pass() - Entering\n"));
	pFilterExt = (PSWUSB_FILTER_EXT)pDeviceObject->DeviceExtension;
	IoSkipCurrentIrpStackLocation (pIrp);
	NtStatus = IoCallDriver (pFilterExt->pTopOfStack, pIrp);

	//return
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffdevice.cpp ===
//@doc
/******************************************************
**
** @module FFDEVICE.CPP | Implementation file for FFDevice class
**
** Description:
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
**			20-Mar-99	waltw	Added dwDeviceID to SetFirmwareVersion
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#include "FFDevice.h"
#include "Midi_obj.hpp"
#include "DTrans.h"
#include "joyregst.hpp"

extern CJoltMidi* g_pJoltMidi;

ForceFeedbackDevice g_ForceFeedbackDevice;

/******************************************************
**
** ForceFeedbackDevice::ForceFeedbackDevice()
**
** @mfunc Constructor.
**
******************************************************/
ForceFeedbackDevice::ForceFeedbackDevice() :
	m_FirmwareAckNackValues(0),
	m_FirmwareVersionMajor(0),
	m_FirmwareVersionMinor(0),
	m_DriverVersionMajor(0),
	m_DriverVersionMinor(0)
{
	m_OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&m_OSVersion);
}

/******************************************************
**
** ForceFeedbackDevice::DetectHardware()
**
** @mfunc DetectHardware.
**
******************************************************/
BOOL ForceFeedbackDevice::DetectHardware()
{
	if (NULL == g_pJoltMidi) return FALSE;
	return g_pJoltMidi->QueryForJolt();
}

/******************************************************
**
** ForceFeedbackDevice::SetFirmwareVersion(DWORD major, DWORD minor)
**
** @mfunc SetFirmwareVersion.
**
******************************************************/
void ForceFeedbackDevice::SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor)
{
	m_FirmwareVersionMajor = major;
	m_FirmwareVersionMinor = minor;

	m_FirmwareAckNackValues = GetAckNackMethodFromRegistry(dwDeviceID);
}

/******************************************************
**
** ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
**
** @mfunc SetDriverVersion.
**
******************************************************/
void ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
{
	if ((major == 0xFFFFFFFF) && (minor == 0xFFFFFFFF)) {	// Check for version 1.0 driver version error
		m_DriverVersionMajor = 1;
		m_DriverVersionMinor = 0;
	} else {
		m_DriverVersionMajor = major;
		m_DriverVersionMinor = minor;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\dtrans.cpp ===
//@doc
/******************************************************
**
** @module DTRANS.CPP | DataTransmitter implementation file
**
** Description:
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "FFDevice.h"
#include "DTrans.h"
//#include <devioctl.h>

#ifdef _DEBUG
	extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
	#define DebugOut(x)
#endif _DEBUG

const char cCommPortNames[4][5] = { "COM1", "COM2", "COM3", "COM4" };
const unsigned short c1_16_BytesPerShot = 3;
const DWORD c1_16_SerialSleepTime = 1;

#define UART_FILTER_NAME TEXT("\\\\.\\.\\PortClass0\\Uart")
const WORD c_LongMsgMax = 256;

inline BOOL IsHandleValid(HANDLE handleToCheck)
{
	return ((handleToCheck != NULL) && (handleToCheck != INVALID_HANDLE_VALUE));
}

#define CHECK_RELEASE_AND_NULL(pIUnknown)	\
	if (pIUnknown != NULL)					\
	{										\
		pIUnknown->Release();				\
		pIUnknown = NULL;					\
	}

/************************** SerialDataTransmitter Class ******************************/

/******************************************************
**
** SerialDataTransmitter::SerialDataTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
SerialDataTransmitter::SerialDataTransmitter() : DataTransmitter(),
	m_SerialPort(INVALID_HANDLE_VALUE),
	m_SerialPortIDHack(0)
{
}

/******************************************************
**
** SerialDataTransmitter::~SerialDataTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
SerialDataTransmitter::~SerialDataTransmitter()
{
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (::CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}
}


/******************************************************
**
** SerialDataTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL SerialDataTransmitter::Initialize()
{
	// If already open, close for reinitialization
	if (m_SerialPort != INVALID_HANDLE_VALUE) {
		if (CloseHandle(m_SerialPort) == FALSE) {
//			ASSUME_NOT_REACHED();
		}
		m_SerialPort = INVALID_HANDLE_VALUE;
	}

	for (int portNum = 0; portNum < 4; portNum++) {
		DebugOut(cCommPortNames[portNum]);
		DebugOut(":\r\n");
		m_SerialPort = ::CreateFile(cCommPortNames[portNum], GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (m_SerialPort != INVALID_HANDLE_VALUE) {
			DCB CommDCB;
			if (::GetCommState(m_SerialPort, &CommDCB)) {
#ifdef _DEBUG
				char dbgout[255];
				wsprintf(dbgout, "Baud Rate = 0x%08X (38400 = 0x%08X)\r\n", CommDCB.BaudRate, CBR_38400);
				::OutputDebugString(dbgout);
#endif _DEBUG
				CommDCB.BaudRate = CBR_38400;
				CommDCB.StopBits = ONESTOPBIT;
				CommDCB.ByteSize = 8;
				CommDCB.Parity = NOPARITY;
				if (!::SetCommState(m_SerialPort, &CommDCB)) {
					DebugOut("Unabled to set baud rate\r\n");
				}
			}
			::GetCommState(m_SerialPort, &CommDCB);

			if (g_ForceFeedbackDevice.DetectHardware()) {
				m_SerialPortIDHack = portNum + 1;
				// Write to shared file
				DebugOut(" Opened and FFDev Detected\r\n");
				break;	// Exit from for loop
			}
			// Not found
			::CloseHandle(m_SerialPort);
			DebugOut(" Opened but FFDev NOT detected\r\n");
			m_SerialPort = INVALID_HANDLE_VALUE;
		} else {
			DebugOut(" Not able to open\r\n");
		}
	}
	return (m_SerialPort != INVALID_HANDLE_VALUE);
}

/******************************************************
**
** SerialDataTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL SerialDataTransmitter::Send(BYTE* data, UINT numBytes)
{
	// Do we have a valid serial port (hopefully with MS FF device connected)
	if (m_SerialPort == NULL) {
		return FALSE;
	}

/*	char dbgOut[255];
	::OutputDebugString("(SerialDataTransmitter::Send) : ");
	for (UINT i = 0; i < numBytes; i++) {
		wsprintf(dbgOut, " 0x%02X", data[i]);
		::OutputDebugString(dbgOut);
	}
	::OutputDebugString("\r\n");
*/
	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 16)) {
		DWORD subTotalWritten;
		DWORD totalWritten = 0;
		DWORD numLeft = numBytes;
		while (numLeft > c1_16_BytesPerShot) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), c1_16_BytesPerShot, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
			numLeft -= subTotalWritten;
			Sleep(c1_16_SerialSleepTime);
		}
		if (numLeft > 0) {
			if (::WriteFile(m_SerialPort, (data + totalWritten), numLeft, &subTotalWritten, NULL) == FALSE) {
				return FALSE;
			}
			totalWritten += subTotalWritten;
		}
		return (totalWritten == numBytes);
	}

	// Firmware other than 1.16
	DWORD numWritten;
	if (::WriteFile(m_SerialPort, data, numBytes, &numWritten, NULL) == FALSE) {
		return FALSE;
	}
	return (numWritten == numBytes);
}

/************************** DMusicTransmitter Class ******************************/

/****************************************
**
**	DMusicTransmitter::DMusicTransmitter()
**
**	@mfunc Constructor for DirectMusic Transmitter
**
*****************************************/
DMusicTransmitter::DMusicTransmitter() : DataTransmitter(),
	m_pIDirectMusic(NULL),
	m_pIDirectMusicPort(NULL),
	m_pIDirectMusicBuffer(NULL)
{
}

/****************************************
**
**	DMusicTransmitter::~DMusicTransmitter()
**
**	@mfunc Destructor for DirectMusic Transmitter
**
*****************************************/
DMusicTransmitter::~DMusicTransmitter()
{
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicBuffer);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicPort);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusic);
}

/****************************************
**
**	BOOL DMusicTransmitter::Initialize()
**
**	@mfunc Intialize the Direct Music Transmission path
**
**	@rdesc TRUE if initialization was successful, FALSE otherwise
**
*****************************************/
BOOL DMusicTransmitter::Initialize()
{
	// Case they are reinitializing
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicBuffer);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusicPort);
	CHECK_RELEASE_AND_NULL(m_pIDirectMusic);

	// Create the global IDirectMusic Interface
	HRESULT hr = ::CoCreateInstance(CLSID_DirectMusic, NULL, CLSCTX_INPROC, IID_IDirectMusic, (void**)&m_pIDirectMusic);
	if (FAILED(hr) || m_pIDirectMusic == NULL)
	{
		return FALSE;
	}

	// Enumerate and create the port when valid one is found
	DMUS_PORTCAPS portCaps;
	portCaps.dwSize = sizeof portCaps;
	DWORD dwPortIndex = 0;
	for (;;)
	{
		HRESULT hr = m_pIDirectMusic->EnumPort(dwPortIndex, &portCaps);
		if (FAILED(hr) || hr == S_FALSE)
		{	// Either we have failed or run out of ports
			return FALSE;
		}
		if (portCaps.dwClass == DMUS_PC_OUTPUTCLASS)
		{
			DMUS_PORTPARAMS portParams;
			portParams.dwSize = sizeof DMUS_PORTPARAMS;
			portParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS;
			portParams.dwChannelGroups = 1;
//			hr = m_pIDirectMusic->CreatePort(portCaps.guidPort, GUID_NULL, &portParams, &m_pIDirectMusicPort, NULL);
			hr = m_pIDirectMusic->CreatePort(portCaps.guidPort, &portParams, &m_pIDirectMusicPort, NULL);
			break;
		}
		dwPortIndex++;
	}

	// Create the buffer
	DMUS_BUFFERDESC dmbd;
	dmbd.dwSize = sizeof DMUS_BUFFERDESC;
	dmbd.dwFlags = 0;
//	dmbd.guidBufferFormat = GUID_KSMusicFormat;
	dmbd.guidBufferFormat = GUID_NULL;
	dmbd.cbBuffer = 256;
	hr = m_pIDirectMusic->CreateMusicBuffer(&dmbd, &m_pIDirectMusicBuffer, NULL);
	if (FAILED(hr) || m_pIDirectMusicBuffer == NULL)
	{
		return FALSE;
	}

	return TRUE;
}

/****************************************
**
**	BOOL DMusicTransmitter::Send(BYTE* pData, UINT ulByteCount)
**
**	@mfunc Sends bytes via DirectMusic to the stick
**
**	@rdesc TRUE if send was successful, FALSE otherwise
**
*****************************************/
BOOL DMusicTransmitter::Send
(
	BYTE* pData,		//@parm Data buffer to send
	UINT ulByteCount	//@parm Number of bytes in buffer to send
)
{
	// Do sanity checks
	if ((pData == NULL) || (m_pIDirectMusicPort == NULL) || (m_pIDirectMusicBuffer == NULL) || (ulByteCount == 0))
	{
		return FALSE;
	}

	// Check if we need to pack sysex or channel message
	if (pData[0] == 0xF0)
	{	// Create system exclusive
/*
		// Pack the sysex-message into the buffer
		HRESULT hr = m_pIDirectMusicBuffer->PackSysEx(0, 1, ulByteCount, pData);
		if (FAILED(hr))
		{	// Unable to pack the buffer
			return FALSE;
		}
*/	}
	else
	{	// Channel Message (fix intel backwards byte order)
		DWORD channelMessage = pData[0];
		if (ulByteCount > 1)
		{
			channelMessage |= pData[1] << 8;
			if (ulByteCount > 2)
			{
				channelMessage |= pData[2] << 16;
			}
		}

		// Pack the channel-message into the buffer
/*		HRESULT hr = m_pIDirectMusicBuffer->PackChannelMsg(0, 1, channelMessage);
		if (FAILED(hr))
		{	// Unable to pack the buffer
			return FALSE;
		}
*/	}

	// Send the buffer to the port
	HRESULT hr = m_pIDirectMusicPort->PlayBuffer(m_pIDirectMusicBuffer);
	if (FAILED(hr))
	{	// Unable to send the data across the port
		return FALSE;
	}

	return TRUE;
}


#if 0
/************************** PinTransmitter Class ******************************/

/******************************************************
**
** PinTransmitter::PinTransmitter()
**
** @mfunc Constructor.
**
******************************************************/
PinTransmitter::PinTransmitter() : DataTransmitter(),
	m_UartFilter(INVALID_HANDLE_VALUE),
	m_MidiPin(INVALID_HANDLE_VALUE),
	m_MidiOutEvent(INVALID_HANDLE_VALUE)
{
}

/******************************************************
**
** PinTransmitter::~PinTransmitter()
**
** @mfunc Destructor.
**
******************************************************/
PinTransmitter::~PinTransmitter()
{
	// Close the send event
	if (IsHandleValid(m_MidiOutEvent)) {
		::CloseHandle(m_MidiOutEvent);
		m_MidiOutEvent = NULL;
	}

	// Close the pin
	if (IsHandleValid(m_MidiPin)) {
		::CloseHandle(m_MidiPin);
		m_MidiPin = INVALID_HANDLE_VALUE;
	}

	// Close the Uart
	if (IsHandleValid(m_UartFilter)) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
	}
}

/******************************************************
**
** PinTransmitter::Initialize()
**
** returns: TRUE if initialized FALSE if not able to initialize
** @mfunc Initialize.
**
******************************************************/
BOOL PinTransmitter::Initialize()
{
	// Load the ksUserLibrary and grab the create pin function
	HINSTANCE ksUserLib = ::LoadLibrary(TEXT("KsUser.dll"));
	if (ksUserLib == NULL) {
		return FALSE;
	}
	KSCREATEPIN pfCreatePin = (KSCREATEPIN)::GetProcAddress(ksUserLib, TEXT("KsCreatePin"));
	if (pfCreatePin == NULL) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Open the Uart
	m_UartFilter = ::CreateFile(UART_FILTER_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (m_UartFilter == INVALID_HANDLE_VALUE) {
		::FreeLibrary(ksUserLib);
		return FALSE;
	}

	// Create Overlapped event
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

	// Get the number of pins
	KSP_PIN ksPinProp;
	::memset(&ksPinProp, 0, sizeof(ksPinProp));
	ksPinProp.Property.Set = KSPROPSETID_Pin;
	ksPinProp.Property.Id = KSPROPERTY_PIN_CTYPES;
	ksPinProp.Property.Flags = KSPROPERTY_TYPE_GET;
	DWORD numPins = 0;
	OverLappedPinIOCTL(overlapped, ksPinProp, &numPins, sizeof(numPins));

	// Check each pin for proper type, then try to create
	BOOL wasCreated = FALSE;
	for (UINT pinNum = 0; (pinNum < numPins) && (wasCreated == FALSE); pinNum++) {
		ksPinProp.PinId = pinNum;
		ksPinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
		KSPIN_DATAFLOW dataFlow = (KSPIN_DATAFLOW)0;
		if (OverLappedPinIOCTL(overlapped, ksPinProp, &dataFlow, sizeof(dataFlow)) == TRUE) {
			if (dataFlow == KSPIN_DATAFLOW_IN) {
				ksPinProp.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
				KSPIN_COMMUNICATION communication = KSPIN_COMMUNICATION_NONE;
				if (OverLappedPinIOCTL(overlapped, ksPinProp, &communication, sizeof(communication)) == TRUE) {
					if ((communication == KSPIN_COMMUNICATION_SINK) || (communication == KSPIN_COMMUNICATION_BOTH)) {
						wasCreated = CreatePinInstance(pinNum, pfCreatePin);
					}
				}
			}
		}
	}
	::FreeLibrary(ksUserLib);
	::CloseHandle(overlapped.hEvent);
	if (wasCreated == FALSE) {
		::CloseHandle(m_UartFilter);
		m_UartFilter = INVALID_HANDLE_VALUE;
		return FALSE;
	}
	return TRUE;
}

/******************************************************
**
** PinTransmitter::OverLappedPinIOCTL()
**
** returns: TRUE if able to proform Pin Property IOCTL
** @mfunc OverLappedPinIOCTL.
******************************************************/
BOOL PinTransmitter::OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize)
{
	// IOCTL the Property
	if (::DeviceIoControl(m_UartFilter, IOCTL_KS_PROPERTY, &ksPinProp, sizeof(ksPinProp), pData, dataSize, NULL, &overlapped) == TRUE) {
		return TRUE;
	}

	// Failed IOCTL check if more time is needed
	if (::GetLastError() != ERROR_IO_PENDING) {
		return FALSE;
	}

	// Do wait
	if (::WaitForSingleObject(overlapped.hEvent, 3000) == WAIT_OBJECT_0) {
		return TRUE;	// Waiting paid off
	}
	return FALSE;	// Grew tired of waiting
}

/******************************************************
**
** PinTransmitter::CreatePinInstance()
**
** returns: TRUE if able to create the requested pin instance
** @mfunc CreatePinInstance.
******************************************************/
BOOL PinTransmitter::CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin)
{
	// Set the pin format
	KSDATAFORMAT ksDataFormat;
	::memset(&ksDataFormat, 0, sizeof(ksDataFormat));
	ksDataFormat.FormatSize = sizeof(ksDataFormat);
	ksDataFormat.MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
	ksDataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
	ksDataFormat.Specifier = KSDATAFORMAT_SPECIFIER_NONE;

	// Set the pin connection information
	KSPIN_CONNECT* pConnectionInfo = (KSPIN_CONNECT*) new BYTE[sizeof(KSPIN_CONNECT) + sizeof(ksDataFormat)];
	::memset(pConnectionInfo, 0, sizeof(KSPIN_CONNECT));
	pConnectionInfo->Interface.Set = KSINTERFACESETID_Standard;
	pConnectionInfo->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
	pConnectionInfo->Medium.Set = KSMEDIUMSETID_Standard;
	pConnectionInfo->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
	pConnectionInfo->PinId = pinNumber;
	pConnectionInfo->Priority.PriorityClass = KSPRIORITY_NORMAL;
	pConnectionInfo->Priority.PrioritySubClass  = 1;
	::memcpy(pConnectionInfo + 1, &ksDataFormat, sizeof(ksDataFormat));

	DWORD status = pfCreatePin(m_UartFilter, pConnectionInfo, FILE_WRITE_ACCESS, &m_MidiPin);
	delete[] pConnectionInfo;
	if (status != NO_ERROR) {
#ifdef _DEBUG
		TCHAR buff[256];
		wsprintf(buff, TEXT("Error Creating Pin: 0x%08X\r\n"), status);
		::OutputDebugString(buff);
#endif
		return FALSE;
	}

	SetPinState(KSSTATE_PAUSE);

	return TRUE;
}

/******************************************************
**
** PinTransmitter::Send()
**
** returns: TRUE if all data was successfully sent
** @mfunc Send.
**
******************************************************/
BOOL PinTransmitter::Send(BYTE* pData, UINT numBytes)
{
	if (!IsHandleValid(m_MidiPin)) {
		return FALSE;
	}

	BYTE musicData[c_LongMsgMax + sizeof(KSMUSICFORMAT)];
	::memset(musicData, 0, sizeof(musicData));
	((KSMUSICFORMAT*)musicData)->ByteCount = numBytes;
	::memcpy(((KSMUSICFORMAT*)musicData) + 1, pData, numBytes);

	KSSTREAM_HEADER ksStreamHeader;
	::memset(&ksStreamHeader, 0, sizeof(ksStreamHeader));
	ksStreamHeader.Size = sizeof(ksStreamHeader);
	ksStreamHeader.PresentationTime.Numerator = 1;
	ksStreamHeader.PresentationTime.Denominator = 1;
	ksStreamHeader.FrameExtent = sizeof(musicData);
	ksStreamHeader.DataUsed = sizeof KSMUSICFORMAT + numBytes;
	ksStreamHeader.Data = (void*)musicData;

	if (!IsHandleValid(m_MidiOutEvent)) {
		m_MidiOutEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	}
	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = m_MidiOutEvent;


	SetPinState(KSSTATE_RUN);
	if (!DeviceIoControl(m_MidiPin, IOCTL_KS_WRITE_STREAM, NULL, 0,
							&ksStreamHeader, sizeof(ksStreamHeader), NULL, &overlapped)) {
		if (GetLastError() == ERROR_IO_PENDING) {
			::WaitForSingleObject(overlapped.hEvent, 3000);
		}
	}
	SetPinState(KSSTATE_PAUSE);
	return TRUE;
}

/******************************************************
**
** PinTransmitter::SetPinState()
**
** returns: Nothing
** @mfunc SetPinState.
**
******************************************************/
void PinTransmitter::SetPinState(KSSTATE state)
{
	if (!IsHandleValid(m_MidiPin)) {
		return;
	}

	KSPROPERTY ksProperty;
	::memset(&ksProperty, 0, sizeof(ksProperty));
	ksProperty.Set = KSPROPSETID_Connection;
	ksProperty.Id = KSPROPERTY_CONNECTION_STATE;
	ksProperty.Flags = KSPROPERTY_TYPE_SET;

	OVERLAPPED overlapped;
	::memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (IsHandleValid(overlapped.hEvent)) {
		if( !DeviceIoControl(m_MidiPin, IOCTL_KS_PROPERTY, &ksProperty, sizeof ksProperty, &state, sizeof state, NULL, &overlapped )) {
			if (GetLastError() == ERROR_IO_PENDING) {
				WaitForSingleObject(overlapped.hEvent, 30000);
			}
		}
		::CloseHandle(overlapped.hEvent);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\swusbflt.sys\swusbfltshell.h ===
#ifndef __SWUSBFLTSHELL_H__
#define __SWUSBFLTSHELL_H__
//	@doc
/**********************************************************************
*
*	@module	SwUsbFltShell.h	|
*
*	Header file for SwUsbFlt.sys WDM shell structure
*
*	History
*	----------------------------------------------------------------------
*	Matthew L. Coill	Original (Adopted from GckShell.h from MitchD)
*
*	(c) 1986-2000 Microsoft Corporation. All right reserved.
*
*	@topic	SwUsbFltShell	|
*	Declaration of all structures, and functions in SwUsbFlt that make up
*	the shell of the driver.
*
**********************************************************************/

//	We use some structures from hidclass.h
#include <hidclass.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <hidusage.h>

//	A little more rigorous than our normal build
#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
//	@struct SWUSB_FILTER_EXT | Device Extension for this device filter
//
typedef struct _tagSWUSB_FILTER_EXT
{
    PDEVICE_OBJECT	pPDO;						// @field PDO to which this filter is attached
    PDEVICE_OBJECT	pTopOfStack;				// @field Top of the device stack just beneath this filter device object
	USBD_PIPE_INFORMATION outputPipeInfo;		// @field Information about the Output Pipe
} SWUSB_FILTER_EXT, *PSWUSB_FILTER_EXT;


/*****************************************************************************
** Declaration of Driver Entry Points
******************************************************************************/
//
// General Entry Points - In SwUsbFltShell.c
//

NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT  pDriverObject,
	IN PUNICODE_STRING pRegistryPath
);

NTSTATUS SWUSB_PnP (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS SWUSB_Ioctl_Internal (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

NTSTATUS SWUSB_Pass (
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
);

#endif __SWUSBFLTSHELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\dx_map.hpp ===
/****************************************************************************

    MODULE:     	DX_MAP.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Mapper for converting SWForce FFD_ to DirectInput Force
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	14-Feb-97       MEA     original
        
****************************************************************************/
#ifndef _DX_MAP_SEEN
#define _DX_MAP_SEEN
#include <windows.h>
#include "dinput.h"
#include "dinputd.h"


// Diagnostics Counters
typedef struct _DIAG_COUNTER
{
	ULONG			m_NACKCounter;		// For Debugging, how many NACKS
	ULONG			m_LongMsgCounter;  	// How many SysEx messages
	ULONG			m_ShortMsgCounter;	// How many 3 byte Short messages
	ULONG			m_RetryCounter;		// Number of retries
} DIAG_COUNTER, *PDIAG_COUNTER;

//
// --- Mapping from DX to SWForce FFD
//

typedef struct IDirectInputEffect	 *PSWEFFECT;  
typedef struct IDirectInputEffect	**PPSWEFFECT;  

#define SW_NUMBER_OF_BUTTONS 9

#define DNHANDLE	USHORT		// Download Effect Handle type
#define PDNHANDLE	DNHANDLE *	// Pointer

#define MIN_ANGLE			0
#define MAX_ANGLE			36000
#define MIN_FORCEOUTPUTRATE 1
#define MIN_GAIN			1
#define MAX_GAIN			10000
#define MAX_FORCE			10000
#define MIN_FORCE			-10000
#define MIN_TIME_PERIOD		1
#define MAX_TIME_PERIOD		4294967296L	// 4096 * 10^^6 usecs
#define MAX_POSITION		10000
#define MIN_POSITION		-10000
#define MAX_CONSTANT		10000
#define MIN_CONSTANT		-10000

#define SCALE_GAIN			100		// DX is +/- 10000, SWForce in +/-100
#define SCALE_TIME			1000	// DX is in microseconds, SWForce in msec
#define	SCALE_POSITION		100		// DX is +/- 10000, SWForce in +/- 100+
#define	SCALE_CONSTANTS		100		// DX is +/- 10000, SWForce in +/- 100+
#define SCALE_DIRECTION		100		// DX is 0 to 35900, SWForce is 0 to 359

// 
// --- Default Values
//
#define	DEFAULT_OFFSET			0
#define DEFAULT_ATTACK_LEVEL	0
#define DEFAULT_ATTACK_TIME		0
#define DEFAULT_SUSTAIN_LEVEL	10000
#define DEFAULT_FADE_LEVEL		0
#define DEFAULT_FADE_TIME		0

// PlaybackEffect Command Modes
#define PLAY_SUPERIMPOSE	0x01
#define PLAY_SOLO			0x02
#define PLAY_STORE			0x04	// Store only
#define PLAY_UPDATE			0x08
//reserved					0x10
#define PLAY_LOOP			0x20
#define PLAY_FOREVER		0x40
#define PLAY_STOP			0x80
#define PLAY_MODE_MASK		0xff

#define DEV_SHUTDOWN		DEV_RESET

//
// --- Effect Status
//
#define ES_HOST			0x00000001L	// Effect is in HOST memory
#define ES_DOWNLOADED	0x00000002L	// Effect is downloaded
#define ES_STOPPED		0x00000004L	// Effect is stopped
#define ES_PLAYING		0x00000008L	// Effect is playing

//
// --- Axis Masks
//
#define X_AXIS		0x01
#define Y_AXIS		0x02
#define Z_AXIS		0x04
#define ROT_X_AXIS	0x08
#define ROT_Y_AXIS	0x10
#define ROT_Z_AXIS	0x20

//
// --- Button Masks
//
#define BUTTON1_PLAY 	0x00000001L	// Trigger button (usually)
#define BUTTON2_PLAY	0x00000002L
#define BUTTON3_PLAY	0x00000004L
#define BUTTON4_PLAY	0x00000008L
#define BUTTON5_PLAY	0x00000010L
#define BUTTON6_PLAY	0x00000020L
#define BUTTON7_PLAY	0x00000040L
#define BUTTON8_PLAY	0x00000080L
#define BUTTON9_PLAY	0x00000100L
#define BUTTON10_PLAY	0x00000200L
#define BUTTON11_PLAY	0x00000400L
#define BUTTON12_PLAY	0x00000800L
#define BUTTON13_PLAY	0x00001000L
#define BUTTON14_PLAY	0x00002000L
#define BUTTON15_PLAY	0x00004000L
#define BUTTON16_PLAY	0x00008000L	// . . . 16th button

// 
// --- Force Feedback Device State
//
typedef struct _SWDEVICESTATE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
								//  0 = Hands Off, 1 = Hands On
	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
								// Lower number indicates CPU is in trouble!
	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
} SWDEVICESTATE, *PSWDEVICESTATE;


#define MAX_SIZE_SNAME	64

//
//
// --- Force Feedback Device Capabilities
//
typedef struct _FFDEVICEINFO {
	ULONG	m_Bytes;		// Size of this structure
	TCHAR	m_ProductName[MAX_SIZE_SNAME];	// Device Name 64 chars
	TCHAR	m_ManufacturerName[MAX_SIZE_SNAME]; // Manufacturer
	ULONG	m_ProductVersion;	// Device Product Version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceDriverVersion;	// Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_DeviceFirmwareVersion; // Device Driver version
								// HIWORD: MajorVersion,,MinorVersion
								// LOWORD: Build#
	ULONG	m_Interface;		// HIWORD: OUTPUT:HID_INTERFACE||VJOYD_INTERFACE 
								// LOWORD: INPUT: HID_INTERFACE||VJOYD_INTERFACE 
	ULONG	m_MaxSampleRate;	// Maximum Force output rate
	ULONG	m_MaxMemory;		// Max amount of RAM
	ULONG	m_NumberOfSensors;	// SENSOR_AXIS total in the device (INPUT)
	ULONG	m_NumberOfAxes;		// ACTUATOR_AXIS total in the device (OUTPUT)
	ULONG	m_EffectsCaps;		// Built-in Effects capability
	ULONG	m_Reserved;			// 
	ULONG	m_JoystickID;		// VJOYD Joystick ID (0-based)
	ULONG	m_ExtraInfo;		// For future stuff
} FFDEVICEINFO, *PFFDEVICEINFO;


//
// --- AXISCAPS Sensor or Actuator Axes capabilities
//
typedef struct _AXISCAPS {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bit position for Actuator or Sensor Axes
	ULONG	m_LogicalExtentMin;	// Minimum logical extent
	ULONG	m_LogicalExtentMax;	// Maximum logical extent
	ULONG	m_PhysicalExtentMin;// Minimum physical extent
	ULONG	m_PhysicalExtentMax;// Maximum Physical extent
	ULONG	m_Units;			// HID style physical SI units
	ULONG	m_Resolution;		// Position increments per physical SI unit
	ULONG	m_ServoLoopRate;	// Loop rate in cycles/sec
} AXISCAPS, *PAXISCAPS;


typedef struct _FORCE {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_DirectionAngle2D;	// From X-Axis = theta1
	LONG	m_DirectionAngle3D;	// From Z-Axis = (theta2, note: theta1+theta2)>= 90
	LONG	m_ForceValue;		// Actual force in +/- 100%
} FORCE, *PFORCE;


typedef struct _FORCECONTEXT {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_AxisMask;			// Bitmask for the axis
	LONG	m_Position;			// Position along the Axis -32768 to +32767
	LONG	m_Velocity;			// Velocity in -32768 to +32767 units TBD
	LONG	m_Acceleration;		// Acceleration in -32768 to +32767 units TBD
} FORCECONTEXT, *PFORCECONTEXT;


// The following are Type Specific parameters structures
//
//

//
// -- an Effect structure
//
typedef struct _EFFECT {
	ULONG	m_Bytes;			// Size of this structure
	TCHAR	m_Name[MAX_SIZE_SNAME];
	ULONG	m_Type;				// Major Effect type, e.g. EF_BEHAVIOR, etc..
	ULONG	m_SubType;			// Minor Effect type, e.g. SE_xxx,BE_xxx,UD_xxx
	ULONG	m_AxisMask;			// Bitmask for axis to send the effect, 
								//   If NULL, use value from Device Capabilities
	ULONG	m_DirectionAngle2D;	// From Y-Axis (cone) = theta1
	ULONG	m_DirectionAngle3D;	// From Z-Axis (cone) = theta2
								//  note: theta1+theta2)>= 90
	ULONG	m_Duration;			// Duration in ms., 00 = infinite
	ULONG	m_ForceOutputRate;	// Sample Rate for Force Data output
	ULONG	m_Gain;				// Gain to apply, normally this is set
								// to 100. Gain is 1 to  100.
	ULONG	m_ButtonPlayMask;	// Mask to indicate which button to assign Effect
} EFFECT, *PEFFECT;


//
// --- ENVELOPE
//
// Note:  There are two types of Envelope control, using PERCENTAGE,
// and using TIME.  
// PERCENTAGE defines Envelope using Percentage for the Attack,Sustain and Decay
//
// TIME Envelope type will require the time in 1 millisecond increment, and
// m_StartAmp is the Amplitude to start the waveform, while m_EndAmp is used
// to decay or end the waveform. m_SustainAmp is used to set Sustain amplitude
//
#define PERCENTAGE	0x00000000	// Envelope is in percentage values
#define TIME		0x00000001	// Envelope is in 1 millisecond time increments

//For PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Note: Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline -->>> (m_MaxAmp - m_MinAmp)/2
// m_EndAmp = m_StartAmp;
//
//Valid Ranges:
//PERCENTAGE mode:  
//		m_Attack, m_Sustain, m_Decay = 1 to 100%, and must sum up to 100%
//TIME mode:
//		m_Attack = 0 to 32,768 ms,
//      m_Sustain = 0 to 32,768 ms
//      m_Decay = 0 to 32,768 ms.   (All are in 1 ms increments).
//Note: For an infinite duration (value in m_Duration = 0), the Effect will 
//      never decay and m_Decay is ignored.
//
// Envelopes are only valid for Synthesized Waveforms (SE_XXX) type
//
//
typedef struct _ENVELOPE {
	ULONG	m_Bytes;		// Size of this structure
	ULONG	m_Type;			// PERCENTAGE || TIME
	ULONG	m_Attack;		// Rise time to Sustain Value
							//  in % of Duration, or in msec Time
	ULONG	m_Sustain;		// Sustain time at Sustain Value in % Duration,
							//  or in msec Time
	ULONG	m_Decay;		// Decay time to Minimum Value,
							//  in % of Duration, or in msec Time
	ULONG	m_StartAmp;		// Amplitude to start the Envelope, from baseline		
	ULONG	m_EndAmp;		// Amplitude to End the Envelope, from baseline
	ULONG	m_SustainAmp;	// Amplitude to Sustain the Envelope, from baseline
} ENVELOPE, *PENVELOPE;


//
// ---	EF_BEHAVIOR = {BE_SPRINGxx||BE_DAMPERxx||BE_INTERTIAxx||BE_FRICTIONxx
//						||BE_WALL||BE_DELAY}
//  Note: Behavioral Effects do not have an Envelope.
//
typedef struct _BE_SPRING_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_Kconstant;		// K constant
	LONG	m_AxisCenter;		// Center of the function
} BE_SPRING_PARAM, *PBE_SPRING_PARAM;

typedef struct _BE_SPRING_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
 	LONG	m_XKconstant;		// X_Axis K constant
	LONG	m_XAxisCenter;		// X_Axis Center
	LONG	m_YKconstant;		// Y_Axis K constant
	LONG	m_YAxisCenter;		// Y_Axis Center
} BE_SPRING_2D_PARAM, *PBE_SPRING_2D_PARAM;

typedef struct _BE_DAMPER_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Bconstant;		// B constant
	LONG	m_V0;				// Initial Velocity
} BE_DAMPER_PARAM, *PBE_DAMPER_PARAM;

typedef struct _BE_DAMPER_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XBconstant;		// X_AXIS B constant
	LONG	m_XV0;				// X_AXIS Initial Velocity
	LONG	m_YBconstant;		// Y_Axis B constant
	LONG	m_YV0;				// Y_AXIS Initial Velocity
} BE_DAMPER_2D_PARAM, *PBE_DAMPER_2D_PARAM;

typedef struct _BE_INERTIA_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_Mconstant;		// M constant
	LONG	m_A0;				// Initial Acceleration
} BE_INERTIA_PARAM, *PBE_INERTIA_PARAM;

typedef struct _BE_INERTIA_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XMconstant;		// X_AXIS M constant
	LONG	m_XA0;				// X_AXIS Initial Acceleration
	LONG	m_YMconstant;		// Y_AXIS M constant
	LONG	m_YA0;				// Y_AXIS Initial Acceleration
} BE_INERTIA_2D_PARAM, *PBE_INERTIA_2D_PARAM;

typedef struct _BE_FRICTION_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG    m_Fconstant;        // F Friction constant
} BE_FRICTION_PARAM, *PBE_FRICTION_PARAM;

typedef struct _BE_FRICTION_2D_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	LONG	m_XFconstant;		// X_AXIS F Friction constant
	LONG	m_YFconstant;		// Y_AXIS F Friction constant
} BE_FRICTION_2D_PARAM, *PBE_FRICTION_2D_PARAM;

//
// --- WALL Effect
//
#define WALL_INNER			0	// Wall material:from center to Wall Distance
#define WALL_OUTER			1	// Wall material:greater than Wall Distance

typedef struct _BE_WALL_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG 	m_WallType;			// WALL_INNER or WALL_OUTER
	LONG	m_WallConstant;		// in +/- 10000%
	ULONG	m_WallAngle;		// 0 to 35900
	ULONG	m_WallDistance;		// Distance from Wall face normal to center. 0 to 100
} BE_WALL_PARAM, *PBE_WALL_PARAM;

//
// ---	DELAY Effect
//
// Use EFFECT.m_SubType = BE_DELAY
// This has no type specific parameters.
//

//
// ---	EF_SYNTHESIZED = {  SE_CONSTANT_FORCE||SE_SINE||SE_SQUARE||SE_RAMPUP
//						  ||SE_RAMPDN||SE_TRIANGLE||SE_SAWTOOTH}
typedef struct _SE_PARAM {
	ULONG	m_Bytes;			// size of this structure
	ULONG	m_Freq;				// Frequency in Hz units
	ULONG	m_SampleRate;		// Sample rate in Hz units
	LONG	m_MaxAmp;			// Maximum Amplitude in Force units
	LONG	m_MinAmp;			// Minimum Amplitude in Force units
} SE_PARAM, *PSE_PARAM;

//
// ---	EF_USER_DEFINED = { Waveform defined by the user }
//
// Subtype: UD_WAVEFORM
typedef struct _UD_PARAM {
	ULONG	m_Bytes;			// Size of this structure
	ULONG	m_NumVectors;		// Number of entries in the Array
	LONG *	m_pForceData;		// Ptr to an array of LONG Force values.
} UD_PARAM, *PUD_PARAM;

//
// { Process List defined by the user }
// Subtype: PL_CONCATENATE || PL_SUPERIMPOSE
//
typedef struct _PL_PARAM {
	ULONG		m_Bytes;		// Size of this structure
	ULONG		m_NumEffects;	// # of Effects in list
	PPSWEFFECT	m_pProcessList;	// Ptr to a list of ISWEffect pointers
} PL_PARAM, *PPL_PARAM;

//
// ---	EF_ROM_EFFECT = { ROM Built-in Waveforms defined by the OEM }
//
// This has no type specific parameters.
// Subtypes:  See further below

#define DEFAULT_ROM_EFFECT_GAIN		100		// Set dwGain to this for Default
											// ROM Effect gain
#define DEFAULT_ROM_EFFECT_DURATION	1000	// Set dwDuration to this for Default
											// ROM Effect Duration
#define DEFAULT_ROM_EFFECT_OUTPUTRATE	1000	// Set dwSampleRate to this for 
												// Default ROM Effect output rate

//
// ---	EF_VFX_EFFECT = { FRC file effects }
//
// Subtypes:  none

#define VFX_FILENAME	0L
#define VFX_BUFFER		1L

#define DEFAULT_VFX_EFFECT_GAIN			10000	// Set dwGain to this for Default
												// VFX Effect gain
#define DEFAULT_VFX_EFFECT_DIRECTION	0		// Set polar direction to this for Default
												// VFX Effect direction
#define DEFAULT_VFX_EFFECT_DURATION		1000	// Set dwDuration to this for Default
												// VFX Effect duration

typedef struct _VFX_PARAM
{
	ULONG	m_Bytes;				// Size of this structure
	ULONG	m_PointerType;			// VFX_FILENAME or VFX_BUFFER
	ULONG	m_BufferSize;			// number of bytes in buffer (if VFX_BUFFER)
	PVOID	m_pFileNameOrBuffer;	// file name to open
} VFX_PARAM, *PVFX_PARAM;

//
// --- RTC Spring Effect Structure
//
typedef struct _RTCSPRING_PARAM{
	ULONG	m_Bytes;				// Size of this structure
	LONG	m_XKConstant;			// K Constant for X-axis
	LONG	m_YKConstant;			// "   "      for Y-axis
	LONG	m_XAxisCenter;			// RTC Spring center for X-axis
	LONG	m_YAxisCenter;			// "   "      "      for Y-axis
	LONG	m_XSaturation;			// Saturation for X-axis
	LONG	m_YSaturation;			// "          for Y-axis
	LONG	m_XDeadBand;			// Deadband for X-axis
	LONG	m_YDeadBand;			// "        for Y-axis
} RTCSPRING_PARAM, *PRTCSPRING_PARAM;


//
// --- Major Type: Effects categories
//
#define	EF_BEHAVIOR		1L	// Behavioral Effect, e.g. Spring, Damper, etc.
#define	EF_SYNTHESIZED	2L	// Synthesized Effect, e.g. Sine, Square
#define EF_USER_DEFINED	3L	// User Defined Waveform
#define EF_ROM_EFFECT	4L	// ROM Built-in Waveforms defined by the OEM 
#define EF_VFX_EFFECT	5L	// FRC file effects
#define EF_RAW_FORCE	6L	// For PutRawForce
#define EF_RTC_SPRING	7L	// Permanent RTC Spring

//
// --- Subtypes for EF_BEHAVIOR
//
#define BE_SPRING	   	1L
#define BE_SPRING_2D   	2L
#define BE_DAMPER	   	3L
#define BE_DAMPER_2D   	4L
#define BE_INERTIA	   	5L
#define BE_INERTIA_2D  	6L
#define BE_FRICTION	   	7L
#define BE_FRICTION_2D	8L
#define BE_WALL			9L
#define BE_DELAY		10L
//
// --- DXFF map
//
#define ID_SPRING			(BE_SPRING 			+ (EF_BEHAVIOR<<16))
#define ID_DAMPER			(BE_DAMPER 			+ (EF_BEHAVIOR<<16))
#define ID_INERTIA			(BE_INERTIA 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION			(BE_FRICTION 		+ (EF_BEHAVIOR<<16))
// --- SWForce extensions
#define ID_SPRING_2D		(BE_SPRING_2D 		+ (EF_BEHAVIOR<<16))
#define ID_DAMPER_2D		(BE_DAMPER_2D 		+ (EF_BEHAVIOR<<16))
#define ID_INERTIA_2D		(BE_INERTIA_2D 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION_2D		(BE_FRICTION_2D 	+ (EF_BEHAVIOR<<16))
#define ID_WALL				(BE_WALL 			+ (EF_BEHAVIOR<<16))
#define ID_DELAY			(BE_DELAY 			+ (EF_BEHAVIOR<<16))

//
// --- Subtypes for EF_SYNTHESIZE
//								
#define SE_CONSTANT_FORCE	101L
#define SE_SINE				102L
#define SE_COSINE			103L
#define	SE_SQUARELOW		104L
#define	SE_SQUAREHIGH		105L
#define	SE_RAMPUP  			106L
#define	SE_RAMPDOWN			107L
#define	SE_TRIANGLEUP		108L
#define	SE_TRIANGLEDOWN		109L
#define	SE_SAWTOOTHUP		110L
#define	SE_SAWTOOTHDOWN		111L
//
// --- DXFF map
//
#define ID_CONSTANTFORCE	(SE_CONSTANTFORCE 	+ (EF_SYNTHESIZED<<16))
#define ID_RAMPFORCE		(SE_RAMPUP  	  	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARE			(SE_SQUARELOW	  	+ (EF_SYNTHESIZED<<16))
#define ID_SINE				(SE_SINE		  	+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLE			(SE_TRIANGLEUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHUP		(SE_SAWTOOTHUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHDOWN		(SE_SAWTOOTHDOWN	+ (EF_SYNTHESIZED<<16))
#define ID_RAMP				(SE_RAMPUP		  	+ (EF_SYNTHESIZED<<16))
//
// --- SWForce extensions
//
#define ID_COSINE			(SE_COSINE		 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUAREHIGH		(SE_SQUAREHIGH	 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARELOW		(SE_SQUARELOW		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPUP  			(SE_RAMPUP  		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPDOWN			(SE_RAMPDOWN		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEUP		(SE_TRIANGLEUP		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEDOWN		(SE_TRIANGLEDOWN	+ (EF_SYNTHESIZED<<16))

//
// --- Subtypes for EF_USER_DEFINED
//
#define UD_WAVEFORM			201L
#define PL_CONCATENATE		202L
#define PL_SUPERIMPOSE		203L
//
// --- DXFF map
//
#define ID_CUSTOMFORCE		(UD_WAVEFORM	 	+ (EF_USER_DEFINED<<16))
//
// --- SWForce extensions
//
#define ID_PL_CONCATENATE	(PL_CONCATENATE 	+ (EF_USER_DEFINED<<16))
#define ID_PL_SUPERIMPOSE	(PL_SUPERIMPOSE 	+ (EF_USER_DEFINED<<16))

//
// --- Subtypes for EF_ROM_EFFECT
// starts at 0x12D
#define RE_ROMID_START	301L
#define	RE_ROMID1		(RE_ROMID_START     )	
#define	RE_ROMID2		(RE_ROMID_START +  1)		
#define	RE_ROMID3		(RE_ROMID_START +  2)			
#define	RE_ROMID4		(RE_ROMID_START +  3)		
#define	RE_ROMID5		(RE_ROMID_START +  4)		
#define	RE_ROMID6		(RE_ROMID_START +  5)	
#define RE_ROMID7		(RE_ROMID_START +  6)
#define	RE_ROMID8		(RE_ROMID_START +  7)	
#define	RE_ROMID9		(RE_ROMID_START +  8)		
#define	RE_ROMID10		(RE_ROMID_START +  9)			
#define	RE_ROMID11		(RE_ROMID_START + 10)		
#define	RE_ROMID12		(RE_ROMID_START + 11)		
#define	RE_ROMID13		(RE_ROMID_START + 12)	
#define RE_ROMID14		(RE_ROMID_START + 13)
#define	RE_ROMID15		(RE_ROMID_START + 14)		
#define	RE_ROMID16		(RE_ROMID_START + 15)	
#define RE_ROMID17		(RE_ROMID_START + 16)
#define	RE_ROMID18		(RE_ROMID_START + 17)	
#define	RE_ROMID19		(RE_ROMID_START + 18)
#define	RE_ROMID20		(RE_ROMID_START + 19)			
#define	RE_ROMID21		(RE_ROMID_START + 20)		
#define	RE_ROMID22		(RE_ROMID_START + 21)		
#define	RE_ROMID23		(RE_ROMID_START + 22)	
#define RE_ROMID24		(RE_ROMID_START + 23)
#define	RE_ROMID25		(RE_ROMID_START + 24)		
#define	RE_ROMID26		(RE_ROMID_START + 25)	
#define RE_ROMID27		(RE_ROMID_START + 26)
#define	RE_ROMID28		(RE_ROMID_START + 27)
#define	RE_ROMID29		(RE_ROMID_START + 28)
#define	RE_ROMID30		(RE_ROMID_START + 29)
#define RE_ROMID31		(RE_ROMID_START + 30)
#define RE_ROMID32		(RE_ROMID_START + 31)
#if 0
#define	RE_ROMID33		(RE_ROMID_START + 32)	
#define RE_ROMID34		(RE_ROMID_START + 33)
#define	RE_ROMID35		(RE_ROMID_START + 34)		
#define	RE_ROMID36		(RE_ROMID_START + 35)	
#define RE_ROMID37		(RE_ROMID_START + 36)
#define	RE_ROMID38		(RE_ROMID_START + 37)	
#define	RE_ROMID39		(RE_ROMID_START + 38)
#define	RE_ROMID40		(RE_ROMID_START + 39)			
#define	RE_ROMID41		(RE_ROMID_START + 40)		
#define	RE_ROMID42		(RE_ROMID_START + 41)		
#define	RE_ROMID43		(RE_ROMID_START + 42)	
#define RE_ROMID44		(RE_ROMID_START + 43)
#define	RE_ROMID45		(RE_ROMID_START + 44)		
#define	RE_ROMID46		(RE_ROMID_START + 45)	
#define RE_ROMID47		(RE_ROMID_START + 46)
#define	RE_ROMID48		(RE_ROMID_START + 47)
#define	RE_ROMID49		(RE_ROMID_START + 48)
#define	RE_ROMID50		(RE_ROMID_START + 49)
#define RE_ROMID51		(RE_ROMID_START + 50)
#define RE_ROMID52		(RE_ROMID_START + 51)
#define	RE_ROMID53		(RE_ROMID_START + 52)	
#define RE_ROMID54		(RE_ROMID_START + 53)
#define	RE_ROMID55		(RE_ROMID_START + 54)		
#define	RE_ROMID56		(RE_ROMID_START + 55)	
#define RE_ROMID57		(RE_ROMID_START + 56)
#define	RE_ROMID58		(RE_ROMID_START + 57)	
#define	RE_ROMID59		(RE_ROMID_START + 58)
#define	RE_ROMID60		(RE_ROMID_START + 59)			
#define	RE_ROMID61		(RE_ROMID_START + 60)		
#define	RE_ROMID62		(RE_ROMID_START + 61)		
#define	RE_ROMID63		(RE_ROMID_START + 62)	
#define RE_ROMID64		(RE_ROMID_START + 63)
#endif
#define MAX_ROM_EFFECTS (RE_ROMID32 - RE_ROMID_START + 1)

//
// --- DXFF map
//
#define ID_RANDOM_NOISE				(RE_ROMID1  + (EF_ROM_EFFECT<<16))
#define ID_AIRCRAFT_CARRIER_TAKEOFF	(RE_ROMID2	+ (EF_ROM_EFFECT<<16))
#define ID_BASKETBALL_DRIBBLE		(RE_ROMID3	+ (EF_ROM_EFFECT<<16))
#define ID_CAR_ENGINE_IDLE			(RE_ROMID4	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IDLE			(RE_ROMID5	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IN_ACTION		(RE_ROMID6	+ (EF_ROM_EFFECT<<16))
#define ID_DIESEL_ENGINE_IDLE		(RE_ROMID7	+ (EF_ROM_EFFECT<<16))
#define ID_JUMP						(RE_ROMID8	+ (EF_ROM_EFFECT<<16))
#define ID_LAND						(RE_ROMID9	+ (EF_ROM_EFFECT<<16))
#define ID_MACHINEGUN				(RE_ROMID10 + (EF_ROM_EFFECT<<16))
#define ID_PUNCHED					(RE_ROMID11 + (EF_ROM_EFFECT<<16))
#define ID_ROCKET_LAUNCH			(RE_ROMID12 + (EF_ROM_EFFECT<<16))
#define ID_SECRET_DOOR				(RE_ROMID13 + (EF_ROM_EFFECT<<16))
#define ID_SWITCH_CLICK				(RE_ROMID14 + (EF_ROM_EFFECT<<16))
#define ID_WIND_GUST				(RE_ROMID15 + (EF_ROM_EFFECT<<16))
#define ID_WIND_SHEAR				(RE_ROMID16 + (EF_ROM_EFFECT<<16))
#define ID_PISTOL					(RE_ROMID17 + (EF_ROM_EFFECT<<16))
#define ID_SHOTGUN					(RE_ROMID18 + (EF_ROM_EFFECT<<16))
#define ID_LASER1					(RE_ROMID19 + (EF_ROM_EFFECT<<16))
#define ID_LASER2					(RE_ROMID20 + (EF_ROM_EFFECT<<16))
#define ID_LASER3					(RE_ROMID21 + (EF_ROM_EFFECT<<16))
#define ID_LASER4					(RE_ROMID22 + (EF_ROM_EFFECT<<16))
#define ID_LASER5					(RE_ROMID23 + (EF_ROM_EFFECT<<16))
#define ID_LASER6					(RE_ROMID24 + (EF_ROM_EFFECT<<16))
#define ID_OUT_OF_AMMO				(RE_ROMID25 + (EF_ROM_EFFECT<<16))
#define ID_LIGHTNING_GUN			(RE_ROMID26 + (EF_ROM_EFFECT<<16))
#define ID_MISSILE					(RE_ROMID27 + (EF_ROM_EFFECT<<16))
#define ID_GATLING_GUN				(RE_ROMID28 + (EF_ROM_EFFECT<<16))
#define ID_SHORT_PLASMA				(RE_ROMID29 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON1			(RE_ROMID30 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON2			(RE_ROMID31 + (EF_ROM_EFFECT<<16))
#define ID_CANNON					(RE_ROMID32 + (EF_ROM_EFFECT<<16))
//#define ID_FLAME_THROWER			(RE_ROMID33 + (EF_ROM_EFFECT<<16))
//#define ID_BOLT_ACTION_RIFLE		(RE_ROMID34 + (EF_ROM_EFFECT<<16))
//#define ID_CROSSBOW					(RE_ROMID35 + (EF_ROM_EFFECT<<16))



#endif // of ifdef _DX_MAP_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\critsec.h ===
//@doc
/******************************************************
**
** @module CRITSEC.H | Header file for CriticalSection class
**
** Description:
**		Critical Section - Encapsulation of CriticalSection object
**
** History:
**	Created 03/02/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__CRITSEC_H__
#define	__CRITSEC_H__

#include <winbase.h>
#include <winuser.h>

// Assumption macros (I don't like asserts msg boxes)
#ifdef _DEBUG
	inline void _myassume(BOOL condition, const char* fname, int line)
	{
		if (!condition) {
			char buff[256];
			::wsprintf(buff, "SW_EFFECT.DLL: Assumption Failed in %s on line %d\r\n", fname, line);
			::OutputDebugString(buff);
		}
	}

	#define ASSUME(x) _myassume(x, __FILE__, __LINE__);
	#define ASSUME_NOT_NULL(x) _myassume(x != NULL, __FILE__, __LINE__);
	#define ASSUME_NOT_REACHED() _myassume(FALSE, __FILE__, __LINE__);
#else	!_DEBUG
	#define ASSUME(x)
	#define ASSUME_NOT_NULL(x)
	#define ASSUME_NOT_REACHED()
#endif _DEBUG

//
// @class CriticalSection class
//
class CriticalSection
{
	public:
		CriticalSection() : m_EntryDepth(0) {
			__try
			{
				::InitializeCriticalSection(&m_OSCriticalSection); 
				m_Initialized = TRUE;
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				m_Initialized = FALSE;
			}
		}

		~CriticalSection() {
			ASSUME(m_EntryDepth == 0);
			::DeleteCriticalSection(&m_OSCriticalSection);
		}

		bool IsInitialized() const
		{
			if (m_Initialized == TRUE)
			{
				return true;
			}
			return false;
		}

		bool Enter() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			m_EntryDepth++;
			::EnterCriticalSection(&m_OSCriticalSection);
			return true;
		}

		bool Leave() {
			if (m_Initialized == FALSE)
			{
				return false;
			}

			ASSUME(m_EntryDepth > 0);
			m_EntryDepth--;
			::LeaveCriticalSection(&m_OSCriticalSection);
			return true;
		}

/*	-- Windows NT Only
		BOOL TryEntry() {
			if (::TryEnterCriticalSection(&m_OSCriticalSection) != 0) {
				m_EntryDepth++;
				return TRUE;
			}
			return FALSE;
		}

		BOOL WaitEntry(short timeOut, BOOL doSleep) {
			// right now timeout is just a loop (since it is not being used anyways)
			while(1) {
				if (TryEntry()) { return TRUE; }
				if (--timeOut > 0) {
					if (doSleep) { ::Sleep(0); }
				} else {
					return FALSE;
				}
			}
		}
 -- Windows NT Only */
	private:
		CriticalSection& operator=(CriticalSection& rhs);	// Cannot be copied

		CRITICAL_SECTION m_OSCriticalSection;
		short m_EntryDepth;
		short m_Initialized;
};
extern CriticalSection g_CriticalSection;

//
// @class CriticalLock class
//
// Critical lock is usefor functions with multiple-exit points. Create a stack CriticalLock
// -- object and everything is taken care of for you when it's lifetime ends.
class CriticalLock
{
	public:
		CriticalLock() { g_CriticalSection.Enter(); }
		~CriticalLock() { g_CriticalSection.Leave(); }
};

#endif	__CRITSEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\dtrans.h ===
//@doc
/******************************************************
**
** @module DTRANS.H | Definition file for DataTransmitter
**
** Description:
**		The Data Transmitters allow virtualization of the
**	actual media used for transmission of data to the FF Device
**		DataTransmitter - Base class that defines the functionality
**		SerialDataTransmitter - Transmitter for Serial (via CreateFile)
**
** Classes:
**		DataTransmitter
**		SerialDataTransmitter
**		PinTransmitter
**
** History:
**	Created 11/13/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__DTRANS_H__
#define	__DTRANS_H__

#ifdef DIRECTINPUT_VERSION
#undef DIRECTINPUT_VERSION
#endif
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>
#include <dmusicc.h>

#ifndef override
#define override
#endif

//
// @class DataTransmitter class
//
class DataTransmitter
{
	//@access Constructor
	protected:
		//@cmember constructor
		DataTransmitter() {};
	//@access Destructor
	public:
		//@cmember destructor
		virtual ~DataTransmitter() {};

	//@access Member functions
	public:
		virtual BOOL Initialize() { return FALSE; }

		virtual BOOL Send(BYTE* data, UINT numBytes) { return FALSE; }
		virtual BOOL ReceiveData(BYTE* data, UINT numBytes) { return FALSE; }
		virtual HANDLE GetCOMMHandleHack() const { return NULL; }
		virtual void StopAutoClose() {}; // Temporary hack to avoid closing own handle (for backdoor serial)
		virtual ULONG GetSerialPortHack() { return 0; }
};

//
// @class SerialDataTransmitter class
//
class SerialDataTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		SerialDataTransmitter();
		//@cmember destructor
		override ~SerialDataTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* data, UINT numBytes);

		override  HANDLE GetCOMMHandleHack() const { return m_SerialPort; }
		override void StopAutoClose() { m_SerialPort = INVALID_HANDLE_VALUE; }
		override ULONG GetSerialPortHack() { return m_SerialPortIDHack; }
		//@access private data members
	private:
		HANDLE m_SerialPort;
		ULONG m_SerialPortIDHack;
};


/************************************************************************
**
**	@class DMusicTransmitter |
**		This transmitter uses the IDirectMusic Interface to send data
**		to the joystick.
**
*************************************************************************/
class DMusicTransmitter :
	public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		DMusicTransmitter();
		//@cmember destructor
		override ~DMusicTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* pData, UINT ulByteCount);

		//@access private data members
	private:
		IDirectMusic* m_pIDirectMusic;
		IDirectMusicPort* m_pIDirectMusicPort;
		IDirectMusicBuffer* m_pIDirectMusicBuffer;
};

#if 0		// Fix pin later

typedef DWORD (WINAPI* KSCREATEPIN)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, HANDLE*);

//
// @class PinTransmitter class
//
class PinTransmitter : public DataTransmitter
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		PinTransmitter();
		//@cmember destructor
		override ~PinTransmitter();

		override BOOL Initialize();
		override BOOL Send(BYTE* data, UINT numBytes);

		//@access private data members
	private:
		BOOL CreatePinInstance(UINT pinNumber, KSCREATEPIN pfCreatePin);
		BOOL OverLappedPinIOCTL(OVERLAPPED overlapped, KSP_PIN ksPinProp, void* pData, DWORD dataSize);
		void SetPinState(KSSTATE state);

		HANDLE m_UartFilter;
		HANDLE m_MidiPin;
		HANDLE m_MidiOutEvent;
};

#endif

#endif	__DTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffdevice.h ===
//@doc
/******************************************************
**
** @module FFDEVICE.H | Definition file for FFDevice class
**
** Description:
**		This is the generic FF device. Independant of
**	Firmawate and how data reaches the device
**	This first implementation uses the old CJoltMidi to
**	minimize new code.
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__FFDEVICE_H__
#define	__FFDEVICE_H__

#ifdef DIRECTINPUT_VERSION
#undef DIRECTINPUT_VERSION
#endif
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>

// Currently there is some extra stuff in here, that should be part of other objects

//
// @class ForceFeedbackDevice class
//
class ForceFeedbackDevice
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		ForceFeedbackDevice();
		//@cmember destructor
		~ForceFeedbackDevice() {};

		BOOL DetectHardware();

		DWORD GetPlatform() const { return m_OSVersion.dwPlatformId; }
		DWORD GetPlatformMajorVersion() const { return m_OSVersion.dwMajorVersion; }
		DWORD GetPlatformMinorVersion() const { return m_OSVersion.dwMinorVersion; }
		DWORD GetOSBuildNumber() const { return m_OSVersion.dwBuildNumber; }

		BOOL IsOSNT5() const { return ((m_OSVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) && (m_OSVersion.dwMajorVersion == 5)); }

		void SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor);
		DWORD GetFirmwareVersionMajor() const { return m_FirmwareVersionMajor; }
		DWORD GetFirmwareVersionMinor() const { return m_FirmwareVersionMinor; }

		USHORT GetAckNackMethod(USHORT methodIndex) const { return USHORT((m_FirmwareAckNackValues >> methodIndex) & 0x00000003); }

		DWORD GetDriverVersionMajor() const { return m_DriverVersionMajor; }
		DWORD GetDriverVersionMinor() const { return m_DriverVersionMinor; }
		void SetDriverVersion(DWORD major, DWORD minor);

		//@access private data members
	private:
		OSVERSIONINFO m_OSVersion;
		DWORD m_FirmwareVersionMajor;
		DWORD m_FirmwareVersionMinor;
		DWORD m_FirmwareAckNackValues;
		DWORD m_DriverVersionMajor;
		DWORD m_DriverVersionMinor;
};


extern ForceFeedbackDevice g_ForceFeedbackDevice;

#endif	__FFDEVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffd_swff.cpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.CPP
	Tab settings: 	5 9

	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	FFD (SWForce HAL) API
    
    FUNCTIONS:		Function prototypes for Force Feedback Joystick interface
    				between the SWForce and the device

		FFD_PutRawForce
		FFD_DownloadEffect
	  	FFD_DestroyEffect
		FFD_GetEffectForceValue
		FFD_PutRawForce

		VFX functions:
			Download_VFX
			CreateEffectFromFile
			CreateEffectFromBuffer

	These functionality are not necessarily supported by all Force Feedback 
	devices.  For example, if a device does not support built-in synthesis 
	capability, then the entry point DownloadEffect, will return an error
	code ERROR_NO_SUPPORT.

	COMMENTS:
	This module of functions are encapsulated in SWFF_PRO.dll the DirectInput 
	DDI driver

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	21-Mar-97       MEA     original from SWForce code
			12-Mar-99		waltw	Removed dead code (mostly FFD_xxx functions)
										These functions no longer exported in .def
	              
****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "midi.hpp"
#include "hau_midi.hpp"
#include "math.h"
#include "FFD_SWFF.hpp"
#include "midi_obj.hpp"
#include "CritSec.h"


// Force Output range values
#define MAX_AMP	2047
#define MIN_AMP	-2048
#define FORCE_RANGE ((MAX_AMP - MIN_AMP)/2)

extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;
#ifdef _DEBUG
extern char g_cMsg[160];
#endif

static HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY);

// *** ---------------------------------------------------------------------***
// Function:   	FFD_GetDiagCounters
// Purpose:    	Returns the DIAG_COUNTER structure
// Parameters: 
//			   	PDIAG_COUNTER pDiagCounter	- Ptr to DIAG_COUNTER struct.
//
// Returns:    	SUCCESS - always successful
//
// Algorithm:
// Comments:   	
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_GetDiagCounters(PDIAG_COUNTER pDiagCounter)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "FFD_GetDiagCounters: %s \r\n", &szDeviceName[0]);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);
	pDiagCounter = g_pJoltMidi->DiagCounterPtrOf();
	return (SUCCESS);
}


// *** ---------------------------------------------------------------------***
// Function:   	FFD_PutRawForce
// Purpose:    	Send force object parameters to be played back by the FF device.
// Parameters: 
//				IN PFORCE	pForce	- A pointer to a FORCE data structure
//
// Returns:    	SUCCESS if successful, else
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//			Note:  The Playback mode will be ONCE
//
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_PutRawForce(
	IN PFORCE pForce)
{
	assert(pForce);
	HRESULT hRet;

	long lForceDataX, lForceDataY;
	long lForceData = (long) ( FORCE_RANGE * (float) (pForce->m_ForceValue/100.00));

// If single Axis only, then use the force on that axis.
// If X and Y-axis, then use 2D angle
//	if (AngleToXY(pForce->m_DirectionAngle2D+90, lForceData, pForce->m_AxisMask, 
//		&lForceDataX, &lForceDataY) != SUCCESS) return SFERR_NO_SUPPORT;

	if (AngleToXY(pForce->m_DirectionAngle2D, lForceData, pForce->m_AxisMask, 
		&lForceDataX, &lForceDataY) != SUCCESS) return SFERR_NO_SUPPORT;

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_PutRawForce: %Force=%ld\n",szDeviceName, (LONG) lForceData);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	switch (pForce->m_AxisMask)
	{
		case (X_AXIS|Y_AXIS):			// use 2D
			hRet = CMD_Force_Out(lForceDataX, X_AXIS);
			if (FAILED(hRet)) break;
			hRet = CMD_Force_Out(lForceDataY, Y_AXIS);
			break;

		case X_AXIS:
			lForceDataX = lForceData;
			hRet = CMD_Force_Out(lForceDataX, X_AXIS);
			break;

		case Y_AXIS:
			lForceDataY = lForceData;
			hRet = CMD_Force_Out(lForceDataY, Y_AXIS);
			break;
		
		default:
			hRet = SFERR_NO_SUPPORT;	
			break;
	}

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_PutRawForce: %Force=%ld\n",szDeviceName, (LONG) lForceData);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return hRet;
}


// ----------------------------------------------------------------------------
// Function:    FFD_Download
//
// Purpose:     Downloads the specified Effect object UD/BE/SE to the FF device.
// Parameters:
//				IN OUT PDNHANDLE pDnloadD   - Ptr to DNHANDLE to store EffectID
//				IN PEFFECT 		 pEffect	- Ptr Common attributes for Effects
//				IN PENVELOPE	 pEnvelope	- Ptr to an ENVELOPE
// 				IN PVOID		 pTypeParam	- Ptr to a Type specific parameter
// 				IN ULONG		 ulAction	- Type of action desired
//
// Returns:
//		SUCCESS - if successful
//		SFERR_FFDEVICE_MEMORY - no more download RAM available
//		SFERR_INVALID_PARAM - Invalid parameters
//		SFERR_NO_SUPPORT - if function is unsupported.
// Algorithm:
//
// Comments:
//
//  ulAction: Type of action desired after downloading
//      PLAY_STORE   - stores in Device only
//      || the following options:
//      PLAY_STORE   - stores in Device only
//      || the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
//          PLAY_LOOP       - Loops for Count times, where count value is in
//                            HIWORD 
//          PLAY_FOREVER    - Play forever until told to stop: PLAY_LOOP with 0 
//							  value in HIWORD
// ----------------------------------------------------------------------------
HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DownloadEffect. DnloadID= %ld, Type=%ld, SubType=%ld\r\n",
   					*pDnloadID,
   					pEffect->m_Type, pEffect->m_SubType);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

//REVIEW: Still need to do boundary Assertions, structure size check etc...
	assert(pDnloadID && pEffect);
	if (!pDnloadID || !pEffect) return (SFERR_INVALID_PARAM);	

// If the Effect type is not a BE_DELAY or EF_ROM_EFFECT,
// make sure there is a pTypeParam
	if ((BE_DELAY != pEffect->m_SubType) && (EF_ROM_EFFECT != pEffect->m_Type))
	{
		assert(pTypeParam);
		if (NULL == pTypeParam) return (SFERR_INVALID_PARAM);
	}

	// Don't support PLAY_LOOP for this version
	if ((ulAction & PLAY_LOOP) || (ulAction & 0xffff0000))
		return (SFERR_NO_SUPPORT);

// REVIEW:  TO increase performance, we should do a parameter mod check
// For now, we'll assume all parameters are changed, for dwFlags
// otherwise, we should check for:
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Figure out the Common members
	BYTE bAxisMask = (BYTE) pEffect->m_AxisMask;
	ULONG ulDuration = pEffect->m_Duration;
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER)) 	ulDuration  = 0;

	// map button 10 to button 9
	if(pEffect->m_ButtonPlayMask == 0x0200)
		pEffect->m_ButtonPlayMask = 0x0100;
	else if(pEffect->m_ButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;

	DWORD dwFlags = DIEP_ALLPARAMS;
	SE_PARAM seParam = { sizeof(SE_PARAM)};

	PBE_SPRING_PARAM pBE_xxx1D;
	PBE_SPRING_2D_PARAM pBE_xxx2D;
	BE_XXX BE_xxx;
	PBE_WALL_PARAM pBE_Wall;

	// Decode the type of Download to use
	HRESULT hRet = SFERR_INVALID_PARAM;
	ULONG ulSubType = pEffect->m_SubType;
	switch (pEffect->m_Type)
	{
		case EF_BEHAVIOR:
			switch (ulSubType)
			{
				case BE_SPRING:		// 1D Spring
				case BE_DAMPER:		// 1D Damper
				case BE_INERTIA:	// 1D Inertia
				case BE_FRICTION:	// 1D Friction
					pBE_xxx1D = (PBE_SPRING_PARAM) pTypeParam;
					if (X_AXIS == bAxisMask)
					{
						BE_xxx.m_XConstant = pBE_xxx1D->m_Kconstant;
						BE_xxx.m_YConstant = 0;
						if (ulSubType != BE_FRICTION)
							BE_xxx.m_Param3 = pBE_xxx1D->m_AxisCenter;
						BE_xxx.m_Param4= 0;
					}
					else
					{
						if (Y_AXIS != bAxisMask)
							break;
						else
						{
							BE_xxx.m_YConstant = pBE_xxx1D->m_Kconstant;
							BE_xxx.m_XConstant = 0;
							if (ulSubType != BE_FRICTION)
								BE_xxx.m_Param4 = pBE_xxx1D->m_AxisCenter;
							BE_xxx.m_Param3= 0;
						}
					}
					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
   					break;

				case BE_SPRING_2D:		// 2D Spring
				case BE_DAMPER_2D:		// 2D Damperfs
 				case BE_INERTIA_2D:		// 2D Inertia
				case BE_FRICTION_2D:	// 2D Friction
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;
					pBE_xxx2D = (PBE_SPRING_2D_PARAM) pTypeParam;
					BE_xxx.m_XConstant = pBE_xxx2D->m_XKconstant;
					if (ulSubType != BE_FRICTION_2D)
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_YKconstant;
						BE_xxx.m_Param3 = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param4 = pBE_xxx2D->m_YAxisCenter;
					}
					else
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param3 = 0;
						BE_xxx.m_Param4 = 0;
					}

					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					break;

				case BE_WALL:
					pBE_Wall = (PBE_WALL_PARAM) pTypeParam;
					if (   (pBE_Wall->m_WallAngle == 0)
						|| (pBE_Wall->m_WallAngle == 90)
						|| (pBE_Wall->m_WallAngle == 180)
						|| (pBE_Wall->m_WallAngle == 270) )
					{
						BE_xxx.m_XConstant = pBE_Wall->m_WallType;
						BE_xxx.m_YConstant = pBE_Wall->m_WallConstant;
						BE_xxx.m_Param3    = pBE_Wall->m_WallAngle;
						BE_xxx.m_Param4    = pBE_Wall->m_WallDistance;
						hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					}
					else
						hRet = SFERR_NO_SUPPORT;
					break;

				case BE_DELAY:
					if (0 == ulDuration) return (SFERR_INVALID_PARAM);
					hRet = CMD_Download_NOP_DELAY(ulDuration, pEffect, (PDNHANDLE) pDnloadID);
					break;

				default:
					hRet = SFERR_NO_SUPPORT;
					break;
			}
			break;

		case EF_USER_DEFINED:
			hRet = CMD_Download_UD_Waveform(ulDuration, pEffect, 
					((PUD_PARAM)pTypeParam)->m_NumVectors,
					((PUD_PARAM)pTypeParam)->m_pForceData, 
					 ulAction, pDnloadID, dwFlags);
			break;

		case EF_ROM_EFFECT:
			// Setup the default parameters for the Effect
			if (SUCCESS != g_pJoltMidi->SetupROM_Fx(pEffect))
			{
				hRet = SFERR_INVALID_OBJECT;
				break;
			}
			
			// Map the SE_PARAM
			// set the frequency
			seParam.m_Freq = 0;				// unused by ROM Effect
			seParam.m_SampleRate = pEffect->m_ForceOutputRate;
			seParam.m_MinAmp = -100;
			seParam.m_MaxAmp = 100;
			
			hRet = CMD_Download_SYNTH(pEffect, pEnvelope, 
						&seParam, ulAction, (USHORT *) pDnloadID, dwFlags);			
			break;
			
		case EF_SYNTHESIZED:
			if (0 == ((PSE_PARAM)pTypeParam)->m_SampleRate)
				((PSE_PARAM)pTypeParam)->m_SampleRate = DEFAULT_JOLT_FORCE_RATE;
			if (0 == pEffect->m_ForceOutputRate)
				pEffect->m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;

			hRet = CMD_Download_SYNTH(pEffect, pEnvelope, 
						(PSE_PARAM) pTypeParam, ulAction, pDnloadID, dwFlags);
			break;

		default:
			hRet = SFERR_INVALID_PARAM;
	}
	
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_DownloadEffect. DnloadID = %lx, hRet=%lx\r\n", 
				*pDnloadID, hRet);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	FFD_DestroyEffect
// Purpose:    	Destroys the Effect from download RAM storage area.
// Parameters: 
//				IN EFHANDLE EffectID		// an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_ID
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//				The Device's Effect ID and memory is returned to free pool.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DestroyEffect. DnloadID:%ld\r\n",
   			  DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	HRESULT hRet = CMD_DestroyEffect(DnloadID);

#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_DestroyEffect. DnloadID:%ld\r\n",
   			  DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
}





// *** ---------------------------------------------------------------------***
// Function:   	FFD_VFXProcessEffect
// Purpose:    	Commands FF device to process downloaded Effects
//
// Parameters: 
//				IN OUT PDNHANDLE pDnloadID	// Storage for new Download ID
//				IN int 	nNumEffects			// Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	// Processing mode
//				IN PDNHANDLE pPListArray// Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				SFERR_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pEFHandle:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  The first entry pEFHandle[0] will be
//		used to store the new Effect ID created for the CONCATENATE
//		and SUPERIMPOSE process choice.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "FFD_ProcessEffect, DnloadID=%ld\r\n",
					*pDnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif

	assert(pDnloadID && pPListArray);
	if ((NULL == pDnloadID) || (NULL == pPListArray)) return (SFERR_INVALID_PARAM);

	assert(nNumEffects > 0 && nNumEffects <= MAX_PLIST_EFFECT_SIZE);
	if ((nNumEffects > MAX_PLIST_EFFECT_SIZE) || (nNumEffects <= 0))
		return (SFERR_INVALID_PARAM);

	// map button 10 to button 9
	if(ulButtonPlayMask == 0x0200)
		ulButtonPlayMask = 0x0100;
	else if(ulButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;   

	HRESULT hRet;
	hRet = CMD_VFXProcessEffect(ulButtonPlayMask, pDnloadID,nNumEffects,
			ulProcessMode,pPListArray, PLAY_STORE);
	return (hRet);
}

// *** ---------------------------------------------------------------------***
// Function:   	FFD_GetEffectForceValue
// Purpose:    	Returns the force value at tick time for the Effect
//
// Parameters:	DNHANDLE DnloadID	- Effect ID
//				ULONG ulAxisMask	- X_AXIS or Y_AXIS
//				ULONG ulIndex		- Index into the Effect
//				PLONG pForceValue	- Ptr to a LONG variable
//
// Returns:    	SUCCESS - if successful, else
//				SFERR_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
// *** ---------------------------------------------------------------------***
HRESULT FFD_GetEffectForceValue(
	IN DNHANDLE DnloadID,
	IN ULONG ulAxisMask,
	IN ULONG ulIndex,
	IN OUT PLONG pForceValue)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "FFD_GetEffectForceValue, DnloadID=%d\r\n", DnloadID);
   	OutputDebugString(g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (SFERR_NO_SUPPORT);
}


// *** ---------------------------------------------------------------------***
// Function:   	AngleToXY
// Purpose:    	Computes XY from Angle
// Parameters: 
//				IN LONG lDirectionAngle2D	- Angle in Degrees
//				IN LONG lForceValue			- Resultant Force
//				IN ULONG ulAxisMask			- Axis to Affect
//				IN OUT PLONG pX				- X-Axis store
//				IN OUT PLONG pY				- Y-Axis store
// Returns:    	pX, pY with valid angle components
//
// *** ---------------------------------------------------------------------***
HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY)
{
// If single Axis only, then use the force on that axis.
// If X and Y-axis, then use 2D angle
// If X, Y, and Z-axis, then use 3D angle
// If axis is other than X,Y,Z then no support
	double Radian;

	switch (ulAxisMask)
	{
		case (X_AXIS|Y_AXIS):	// use 2D
			Radian = xDegrees2Radians(lDirectionAngle2D % 360);
#ifdef ORIENTATION_MODE1
			*pX = - (long) (lValueData * cos(Radian));
			*pY = (long) (lValueData * sin(Radian));
#else
			*pX = - (long) (lValueData * sin(Radian));
			*pY = (long) (lValueData * cos(Radian));
#endif
			break;

		case X_AXIS:
			*pX = lValueData;
			*pY = 0;
			break;

		case Y_AXIS:
			*pX = 0;
			*pY = lValueData;
			break;
		
		case (X_AXIS|Y_AXIS|Z_AXIS):	// use 3D
		default:
			return (SFERR_NO_SUPPORT);	
			break;
	}
	return SUCCESS;
}

//
// ---  VFX SUPPORT FUNCTIONS
//

// *** ---------------------------------------------------------------------***
// Function:   	CreateEffectFromFile
// Purpose:    	Creates an Effect from a RIFF file
// Parameters: 	PSWFORCE pISWForce		- Ptr to a SWForce
//				PPSWEFFECT ppISWEffect	- Ptr to a SWEffect 
//				TCHAR* pszFileName				- Name of file to open 
//				DWORD dwByteCount				- Bytes in block 
//				LPGUID lpGUID					- Joystick GUID
//				
//
// Returns:    	SUCCESS - if successful, else
//				error code
//
// Algorithm:
//
// Comments:
//   	
// *** ---------------------------------------------------------------------***
HRESULT CreateEffectFromFile(
		IN LPCTSTR pszFileName,
		IN ULONG ulAction,
		IN OUT PDNHANDLE pDnloadID,
		IN DWORD dwFlags)
{
#ifdef _DEBUG
   	OutputDebugString("CImpIVFX::CreateEffectFromFile\n");
#endif
	// parameter checking
	if ( !(pszFileName && pDnloadID) ) 
			return SFERR_INVALID_PARAM;

	HMMIO hmmio = NULL;
	DWORD dwFileSize;
	DWORD dwFilePos;
	BYTE* pBuffer = NULL;
	DWORD dwBytesRead;
	HRESULT hResult = SUCCESS;
	MMRESULT mmresult;
	
	// open a RIFF file using the buffer
	MMIOINFO mmioinfo;
	mmioinfo.dwFlags		= 0;
	mmioinfo.fccIOProc		= NULL;
	mmioinfo.pIOProc		= NULL;
	mmioinfo.wErrorRet		= 0;
	mmioinfo.htask			= NULL;
	mmioinfo.cchBuffer		= 0;
	mmioinfo.pchBuffer		= NULL;
	mmioinfo.pchNext		= 0;
	mmioinfo.pchEndRead		= 0;
	mmioinfo.lBufOffset		= 0;
	mmioinfo.adwInfo[0]		= 0;
	mmioinfo.adwInfo[1]		= 0;
	mmioinfo.adwInfo[3]		= 0;
	mmioinfo.dwReserved1	= 0;
	mmioinfo.dwReserved2	= 0;
	mmioinfo.hmmio			= NULL;

	// make a non-constant copy of the string
	TCHAR szFileNameCopy[256];
	strcpy(szFileNameCopy, pszFileName);

	// open the RIFF file for reading
	hmmio = mmioOpen(szFileNameCopy, &mmioinfo, MMIO_READ);
	if(hmmio == NULL)
	{
		hResult = MMIOErrorToSFERRor(mmioinfo.wErrorRet);
		goto cleanup;
	}

	// calculate the size of the file
	dwFileSize = mmioSeek(hmmio, 0, SEEK_END);
	if(dwFileSize == -1)
	{
		hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
		goto cleanup;
	}
	dwFilePos = mmioSeek(hmmio, 0, SEEK_SET);
	if(dwFilePos == -1)
	{
		hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
		goto cleanup;
	}

	// get a chunk of memory big enough to hold it
	pBuffer = new BYTE[dwFileSize];
	if(pBuffer == NULL)
	{
		hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
		goto cleanup;
	}
	
	// read the file into the chunk of memory
	dwBytesRead = mmioRead(hmmio, (char*)pBuffer, dwFileSize);
	if(dwBytesRead != dwFileSize)
	{
		if(dwBytesRead == 0)
			hResult = VFX_ERR_FILE_END_OF_FILE;
		else
			hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
		goto cleanup;
	}

	// close the RIFF file
	mmresult = mmioClose(hmmio, 0);
	hmmio = NULL;
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// call CreateEffectFromBuffer
	hResult = CreateEffectFromBuffer(pBuffer, dwFileSize, ulAction, pDnloadID, dwFlags);
	// clean up
	cleanup:

	// close the RIFF file
	if(hmmio != NULL)
	{
		mmresult = mmioClose(hmmio, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
		}
	}

	// de-allocate any allocated memory
	if(pBuffer != NULL)
		delete [] pBuffer;

	// return the error code, which is SUCCESS, unless there was an error
	return hResult;
}


// *** ---------------------------------------------------------------------***
// Function:   	CreateEffectFromBuffer
// Purpose:    	Creates an Effect from a buffer
// Parameters: 	PSWFORCE pISWForce		- Ptr to a SWForce
//				PPSWEFFECT ppISWEffect	- Ptr to a SWEffect 
//				PVOID pBuffer					- Ptr to a buffer block 
//				DWORD dwByteCount				- Bytes in block 
//				LPGUID lpGUID					- Joystick GUID
//				
//
// Returns:    	SUCCESS - if successful, else
//				error code
//
// Algorithm:
//
// Comments:
//   	
// *** ---------------------------------------------------------------------***

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwByteCount,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags)
{
#ifdef _DEBUG
   	OutputDebugString("CImpIVFX::CreateEffectFromBuffer\n");
#endif
	// parameter checking
	if ( !(pBuffer && pDnloadID) ) 
			return SFERR_INVALID_PARAM;

	// variables used in this function
	#define ID_TABLE_SIZE	50
	MMRESULT mmresult;
	DWORD dwMaxID = 0;		// maximum id of effects entered into the following table
	DNHANDLE rgdwDnloadIDTable[ID_TABLE_SIZE];
	DNHANDLE dwCurrentDnloadID = 0;
	int nNextID = 0;
	HRESULT hResult = SUCCESS;
	DWORD dwBytesRead;
	DWORD dwBytesToRead;
	BYTE* pParam = NULL;
	BOOL bDone = FALSE;
	BOOL bSubEffects = FALSE;
	DWORD dwID;
	DWORD c;	// cleanup counter variable

	// debugging variables (to make sure we destroy all but one
	// created effect on success, and that we destory every
	// created effect on failure)...
#ifdef _DEBUG
	int nEffectsCreated = 0;
	int nEffectsDestroyed = 0;
	BOOL bFunctionSuccessful = FALSE;
#endif //_DEBUG

	// clear effect table (we check it during cleanup...  anything
	// that isn't NULL gets destroyed.)
	memset(rgdwDnloadIDTable,NULL,sizeof(rgdwDnloadIDTable));

	// open a RIFF memory file using the buffer
	MMIOINFO mmioinfo;
	mmioinfo.dwFlags		= 0;
	mmioinfo.fccIOProc		= FOURCC_MEM;
	mmioinfo.pIOProc		= NULL;
	mmioinfo.wErrorRet		= 0;
	mmioinfo.htask			= NULL;
	mmioinfo.cchBuffer		= dwByteCount;
	mmioinfo.pchBuffer		= (char*)pBuffer;
	mmioinfo.pchNext		= 0;
	mmioinfo.pchEndRead		= 0;
	mmioinfo.lBufOffset		= 0;
	mmioinfo.adwInfo[0]		= 0;
	mmioinfo.adwInfo[1]		= 0;
	mmioinfo.adwInfo[2]		= 0;
	mmioinfo.dwReserved1	= 0;
	mmioinfo.dwReserved2	= 0;
	mmioinfo.hmmio			= NULL;
	
	HMMIO hmmio;
	hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);
	if(hmmio == NULL)
	{
		hResult = MMIOErrorToSFERRor(mmioinfo.wErrorRet);
		goto cleanup;
	}

	// descend into FORC RIFF
	MMCKINFO mmckinfoForceEffectRIFF;
	mmckinfoForceEffectRIFF.fccType = FCC_FORCE_EFFECT_RIFF;
	mmresult = mmioDescend(hmmio, &mmckinfoForceEffectRIFF, NULL, MMIO_FINDRIFF);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	//! handle loading of GUID chunk when its implemented/testable

	// descend into trak list
	MMCKINFO mmckinfoTrackLIST;
	mmckinfoTrackLIST.fccType = FCC_TRACK_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoTrackLIST, &mmckinfoForceEffectRIFF,
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// descend into the first efct list (there has to be at least one effect)
	MMCKINFO mmckinfoEffectLIST;
	mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	bDone = FALSE;
	do
	{
		// descend into id chunk
		MMCKINFO mmckinfoIDCHUNK;
		mmckinfoIDCHUNK.ckid = FCC_ID_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoIDCHUNK, &mmckinfoEffectLIST, 
							   MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the id
		//DWORD dwID;  moved to being function global so we can use it near the end
		dwBytesToRead = sizeof(DWORD);
		dwBytesRead = mmioRead(hmmio, (char*)&dwID, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}
		if(dwID >= ID_TABLE_SIZE)
		{
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			goto cleanup;
		}

		// ascend from id chunk
		mmresult = mmioAscend(hmmio, &mmckinfoIDCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// descend into data chunk
		MMCKINFO mmckinfoDataCHUNK;
		mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoDataCHUNK, &mmckinfoEffectLIST, 
								MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the effect structure
		EFFECT effect;
		dwBytesToRead = sizeof(EFFECT);
		dwBytesRead = mmioRead(hmmio, (char*)&effect, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// get the envelope structure
		ENVELOPE envelope;
		dwBytesToRead = sizeof(ENVELOPE);
		dwBytesRead = mmioRead(hmmio, (char*)&envelope, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// calculate the size of and allocate a param structure
		if(pParam != NULL)
		{
			delete [] pParam;
			pParam = NULL;
		}
		// find cur pos w/o changing it
		DWORD dwCurrentFilePos = mmioSeek(hmmio, 0, SEEK_CUR);
		if(dwCurrentFilePos == -1)
		{
			hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
			goto cleanup;
		}
		DWORD dwEndOfChunk = mmckinfoDataCHUNK.dwDataOffset
							 + mmckinfoDataCHUNK.cksize;
		dwBytesToRead = dwEndOfChunk - dwCurrentFilePos;
		pParam = new BYTE[dwBytesToRead];
		if(pParam == NULL)
		{
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			goto cleanup;
		}

		// get the param structure
		dwBytesRead = mmioRead(hmmio, (char*)pParam, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// ascend the data chunk
		mmresult = mmioAscend(hmmio, &mmckinfoDataCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// ascend from the efct list
		mmresult = mmioAscend(hmmio, &mmckinfoEffectLIST, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// reset subeffects flag
		bSubEffects = FALSE;

		// special fix-ups for user-defined
		if(effect.m_Type == EF_USER_DEFINED && 
				(effect.m_SubType == PL_CONCATENATE 
				|| effect.m_SubType == PL_SUPERIMPOSE
				|| effect.m_SubType == UD_WAVEFORM))
		{
			if(effect.m_SubType == UD_WAVEFORM)
			{
				// fix the pointer to the force data in the UD_PARAM
				BYTE* pForceData = pParam + sizeof(UD_PARAM); // - sizeof(LONG*);
				UD_PARAM* pUDParam =  (UD_PARAM*)pParam;
				pUDParam->m_pForceData = (LONG*)pForceData;

				// do a sanity check
				if(pUDParam->m_NumVectors > MAX_UD_PARAM_FORCE_DATA_COUNT)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}
			}
			else if(effect.m_SubType == PL_CONCATENATE 
									|| effect.m_SubType == PL_SUPERIMPOSE)
			{
				// fix the pointer to the PSWEFFECT list in the PL_PARAM
				BYTE* pProcessList = pParam + sizeof(PL_PARAM);
				PL_PARAM* pPLParam = (PL_PARAM*)pParam;
				pPLParam->m_pProcessList = (PPSWEFFECT)pProcessList;
				
				// do a sanity check
				if(pPLParam->m_NumEffects > MAX_PL_PARAM_NUM_EFFECTS)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}

				// make sure all entries in this process list are valid
				ULONG i;
				for (i = 0; i < pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];
					if(nThisID >= ID_TABLE_SIZE)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];
					if(dwThisDnloadID == 0)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}
				}
				
				// use the ID table to insert the download ID's
				for(i=0; i<pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];

					pPLParam->m_pProcessList[i] = (IDirectInputEffect*)dwThisDnloadID;

					// since this effect has been used in a process list,
					// and it will be destroyed after being used in CreateEffect,
					// null it's entry in the table so it doesn't get erroneously
					// redestroyed during cleanup of an error.
					rgdwDnloadIDTable[nThisID] = NULL;
				}

				// we have a process list with sub effects, so set the flag
				bSubEffects = TRUE;
			}
			else
			{
				// there are no other UD sub-types
				hResult = VFX_ERR_FILE_BAD_FORMAT;
				goto cleanup;
			}
		}

		// download the effect

		// create the effect
		//hResult = pISWForce->CreateEffect(&pISWEffect, &effect, 
		//				&envelope, pParam);


		if(effect.m_SubType != PL_CONCATENATE && effect.m_SubType != PL_SUPERIMPOSE)
		{
			EFFECT SmallEffect;
			SmallEffect.m_Bytes = sizeof(EFFECT);
			SmallEffect.m_Type = effect.m_Type;
			SmallEffect.m_SubType = effect.m_SubType;
			SmallEffect.m_AxisMask = effect.m_AxisMask;
			SmallEffect.m_DirectionAngle2D = effect.m_DirectionAngle2D;
			SmallEffect.m_DirectionAngle3D = effect.m_DirectionAngle3D;
			SmallEffect.m_Duration = effect.m_Duration;
			SmallEffect.m_ForceOutputRate = effect.m_ForceOutputRate;
			SmallEffect.m_Gain = effect.m_Gain;
			SmallEffect.m_ButtonPlayMask = effect.m_ButtonPlayMask;
			*pDnloadID = 0;

			hResult = FFD_DownloadEffect(pDnloadID, &SmallEffect, &envelope, pParam, ulAction);
		}
		else
		{
			ULONG ulButtonPlayMask = effect.m_ButtonPlayMask;
			int nNumEffects = ((PL_PARAM*)pParam)->m_NumEffects;
			ULONG ulProcessMode = effect.m_SubType;
			PDNHANDLE pPListArray = new DNHANDLE[ID_TABLE_SIZE];
			for(int i=0; i<nNumEffects; i++)
				pPListArray[i] = (DNHANDLE)(((PL_PARAM*)pParam)->m_pProcessList[i]);
			*pDnloadID = 0;

			hResult = FFD_VFXProcessEffect(ulButtonPlayMask, pDnloadID, nNumEffects,
				ulProcessMode,pPListArray);
		}

		// moved check for success below...

#ifdef _DEBUG
		if (!FAILED(hResult))
			nEffectsCreated++;
#endif //_DEBUG

		// if there were sub effects we need to destroy them, making
		// their ref counts become 1, so the entire effect can be destroyed
		// by destroying the root effect.
#if 0
		if (bSubEffects)
		{
			PL_PARAM* pPLParam = (PL_PARAM*)pParam;

			for (ULONG i = 0; i < pPLParam->m_NumEffects; i++)
			{
				ASSERT(pPLParam->m_pProcessList[i] != NULL);
				pISWForce->DestroyEffect(pPLParam->m_pProcessList[i]);
#ifdef _DEBUG
				nEffectsDestroyed++;
#endif //_DEBUG
			}
		}
#endif

		// now check for success of CreateEffect, because regardless of
		// whether or not it succeeded, we -must- have destroyed the subeffects
		// before continuing, or cleanup will not work properly...
		if (SUCCESS != hResult)
		{
			goto cleanup;
		}

		// put the id/DnloadID pair into the map
		rgdwDnloadIDTable[dwID] = *pDnloadID; //pISWEffect;
		
		// keep track of the highest ID in the effect table
		if (dwID > dwMaxID)
			dwMaxID = dwID;

		// try to descend the next efct
		mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
							   MMIO_FINDLIST);
		if(mmresult == MMIOERR_CHUNKNOTFOUND)
		{
			// we are at the end of the list
			bDone = TRUE;
		}
		else if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}
	}
	while(!bDone);

	// ascend from trak list
	mmresult = mmioAscend(hmmio, &mmckinfoTrackLIST, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// ascend from FORCE RIFF
	mmresult = mmioAscend(hmmio, &mmckinfoForceEffectRIFF, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// get the return value
	//*pDnloadID = dwCurrentDnloadID;

	// clear the final effect's entry in the table so we don't destroy it during cleanup
	rgdwDnloadIDTable[dwID] = 0;

	// at this point the entire table should be NULL... make sure of it
	for (c = 0; c <= dwMaxID; c++)
		;

#ifdef _DEBUG
	bFunctionSuccessful = TRUE;
#endif //_DEBUG

	cleanup:

	// destroy everything in the effect table that isn't NULL 
	for (c = 0; c <= dwMaxID; c++)
		if (NULL != rgdwDnloadIDTable[c])
		{
			FFD_DestroyEffect(rgdwDnloadIDTable[c]);
			rgdwDnloadIDTable[c] = 0;
#ifdef _DEBUG
			nEffectsDestroyed++;
#endif //_DEBUG
		}

#ifdef _DEBUG
	// make sure we destroy all but one created effect on success,
	// and that we destory -every- created effect on failure.
	if (bFunctionSuccessful)
	{
		;//ASSERT(nEffectsCreated - 1 == nEffectsDestroyed);
	}
	else
	{
		;//ASSERT(nEffectsCreated == nEffectsDestroyed);
	}
#endif //_DEBUG

	// close the memory RIFF file
	if(hmmio != NULL)
	{
		mmresult = mmioClose(hmmio, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
		}
	}

	// de-allocate any allocated memory
	if(pParam != NULL)
		delete [] pParam;

	// return the error code, which is SUCCESS, unless there was an error
	return hResult;

}

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult)
{
	HRESULT hResult;

	switch(mmresult)
	{
		case MMIOERR_FILENOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_OUTOFMEMORY:
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			break;
		case MMIOERR_CANNOTOPEN:
			hResult = VFX_ERR_FILE_CANNOT_OPEN;
			break;
		case MMIOERR_CANNOTCLOSE:
			hResult = VFX_ERR_FILE_CANNOT_CLOSE;
			break;
		case MMIOERR_CANNOTREAD:
			hResult = VFX_ERR_FILE_CANNOT_READ;
			break;
		case MMIOERR_CANNOTWRITE:
			hResult = VFX_ERR_FILE_CANNOT_WRITE;
			break;
		case MMIOERR_CANNOTSEEK:
			hResult = VFX_ERR_FILE_CANNOT_SEEK;
			break;
		case MMIOERR_CANNOTEXPAND:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_CHUNKNOTFOUND:
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			break;
		case MMIOERR_UNBUFFERED:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_PATHNOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_ACCESSDENIED:
			hResult = VFX_ERR_FILE_ACCESS_DENIED;
			break;
		case MMIOERR_SHARINGVIOLATION:
			hResult = VFX_ERR_FILE_SHARING_VIOLATION;
			break;
		case MMIOERR_NETWORKERROR:
			hResult = VFX_ERR_FILE_NETWORK_ERROR;
			break;
		case MMIOERR_TOOMANYOPENFILES:
			hResult = VFX_ERR_FILE_TOO_MANY_OPEN_FILES;
			break;
		case MMIOERR_INVALIDFILE:
			hResult = VFX_ERR_FILE_INVALID;
			break;
		default:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
	}

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffeature.h ===
#ifndef __ForceFeatures_h__
#define __ForceFeatures_h__

#define MSGAME_FEATURE_GETID		2
#define MSGAME_FEATURE_GETSTATUS	3
#define MSGAME_FEATURE_GETACKNAK	4
#define MSGAME_FEATURE_GETNAKACK	5
#define MSGAME_FEATURE_GETSYNC		6
#define MSGAME_FEATURE_DORESET		7

/*
#define	MSGAME_INPUT_JOYINFOEX		0x01
#define	MSGAME_FEATURE_GETID			0x02
#define	MSGAME_FEATURE_GETSTATUS	0x03
#define	MSGAME_FEATURE_GETACKNAK	0x04
#define	MSGAME_FEATURE_GETNAKACK	0x05
#define	MSGAME_FEATURE_GETSYNC		0x06
#define	MSGAME_FEATURE_RESET			0x07
#define	MSGAME_FEATURE_GETVERSION	0x08
*/		

typedef struct
{
	ULONG	cBytes;
	ULONG	dwProductID;
	ULONG	dwFWVersion;
} PRODUCT_ID;

typedef	struct
{
	ULONG	cBytes;
	LONG		dwXVel;
	LONG		dwYVel;
	LONG		dwXAccel;
	LONG		dwYAccel;
	ULONG	dwEffect;
	ULONG	dwDeviceStatus;
} JOYCHANNELSTATUS;

//
//	HID prepends exactly, one byte so we need to
//	be careful about packing
//
#pragma pack(push, OLD_CONTEXT_1)
#pragma pack(1)
typedef struct
{
	BYTE		bReportId;
	PRODUCT_ID	ProductId;
} PRODUCT_ID_REPORT;
typedef struct
{
	BYTE				bReportId;
	JOYCHANNELSTATUS	JoyChannelStatus;
} JOYCHANNELSTATUS_REPORT;

typedef struct
{
	BYTE	bReportId;
	ULONG	uLong;
} ULONG_REPORT;
#pragma pack(pop, OLD_CONTEXT_1)
//
//	End packing of 1
//


class CForceFeatures
{
	public:
		CForceFeatures();
		~CForceFeatures();

		HRESULT Initialize(UINT uJoystickId, HINSTANCE hinstModule);
		ULONG GetVersion(){ return (4 << 16 | 0 ); } //returns version 4.0
		HRESULT GetId(PRODUCT_ID_REPORT& rProductId);
		HRESULT GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus);
		HRESULT GetAckNak(ULONG_REPORT& rulAckNak);
		HRESULT GetNakAck(ULONG_REPORT& rulNakAck);
		HRESULT GetSync(ULONG_REPORT& rulGameport);
		HRESULT DoReset();
	private:
		HANDLE	m_hDevice;
		UINT m_uiMaxFeatureLength;
};

#endif // __ForceFeatures_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\legacy\mshgame\sw_effct\ffeature.cpp ===
//	@doc
/**********************************************************************
*
*	@module	ForceFeatures.cpp	|
*
*	Implements CForceFeatures to use msgame's HID features.
*
*	History
*	----------------------------------------------------------
*	Mitchell Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ForceFeatures	|
*	CForceFeatures opens a handle to msgame in the context of
*	a particular device on construction.
*	The public members expose the feature interface for msgame.
*
*	Will work with NT5 as is.  For Win98 we need a different
*	scheme for getting HID path.  DI promises to fix somehow.
**********************************************************************///

#include <windows.h>
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>
#include <dinputd.h>
extern "C" {
	#include <hidsdi.h>
}
#include "FFeature.h"

/***********************************************************************************
**
**	CForceFeatures::CForceFeatures(UINT uJoystickId)
**
**	@mfunc	C'tor gets Hid Path from Joystick and opens path to driver
**
**	@rdesc	None since this is c'tor.  However at the end of this routine
**			m_hDevice will contain a handle for the driver on success, or
**			will contain NULL on failure.  All routines will check the
**			value of m_hDevice before proceeding.
**
*************************************************************************************/
CForceFeatures::CForceFeatures() :
	m_hDevice(NULL)
{
}


/***********************************************************************************
**
**	CForceFeatures::~CForceFeatures()
**
**	@mfunc	D'tor closes handle to driver, if it was open
**
*************************************************************************************/
CForceFeatures::~CForceFeatures()
{
	if(m_hDevice)
	{
		CloseHandle(m_hDevice);
	}
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::Initialize(UINT uJoystickId, HINSTANCE hinstModule)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::Initialize
(
	UINT uJoystickId,		//@parm Joystick Id as used by winmm
	HINSTANCE hinstModule	//@parm Instance of the DLL for Creating DirectInput
)
{
	if (m_hDevice != NULL) {
		return S_OK;	// No need to reinitialize
	}

	HRESULT hr;
	
	//**
	//** Get HidPath
	//**  
	//**

	//
	//	Get IDirectInput interface	
	//
	IDirectInput *pDirectInput = NULL;
	IDirectInputJoyConfig *pDirectInputJoyConfig = NULL; 
	hr = DirectInputCreate(
			hinstModule,
			DIRECTINPUT_VERSION,
			&pDirectInput,
			NULL
			);
	if( FAILED(hr) ) return hr;

	//
	//	Get IDirectInputJoyConfig
	//
	hr=pDirectInput->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID *)&pDirectInputJoyConfig);
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}
	
	//
	//	GetConfig for JoyId
	//
	DIJOYCONFIG DiJoyConfig;
	DiJoyConfig.dwSize=sizeof(DIJOYCONFIG);
	hr = pDirectInputJoyConfig->GetConfig(
									uJoystickId,
									&DiJoyConfig,
									DIJC_GUIDINSTANCE
									);
	//
	//	Done with pDirectInputJoyConfig
	//
	pDirectInputJoyConfig->Release();
	pDirectInputJoyConfig = NULL;
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}

	//
	//  Get IDirectInputDevice interface
	//
	IDirectInputDevice *pDirectInputDevice;
	hr = pDirectInput->CreateDevice(DiJoyConfig.guidInstance, &pDirectInputDevice, NULL);
	//
	//	Done pDirectInput
	//
	pDirectInput->Release();
	pDirectInput = NULL;
	if( FAILED(hr) ) return hr;
	
	//
	//	Get HidPath
	//
	DIPROPGUIDANDPATH DiPropGuidAndPath;
	DiPropGuidAndPath.diph.dwSize = sizeof(DIPROPGUIDANDPATH);
	DiPropGuidAndPath.diph.dwHeaderSize = sizeof(DIPROPHEADER);
	DiPropGuidAndPath.diph.dwObj = 0;
	DiPropGuidAndPath.diph.dwHow = DIPH_DEVICE;
	hr=pDirectInputDevice->GetProperty( DIPROP_GUIDANDPATH, &DiPropGuidAndPath.diph);

	//
	//	Done with pDirectInputDevice
	//
	pDirectInputDevice->Release();
	pDirectInputDevice = NULL;
	if( FAILED(hr) ) return hr;

	//**
	//**	Open Path to Driver
	//**
	m_hDevice = CreateFileW(
		DiPropGuidAndPath.wszPath,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL
	);

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		m_hDevice = NULL;
	}
	if (m_hDevice == NULL)
	{
		DWORD err = ::GetLastError();
		return E_FAIL;
	}

	PHIDP_PREPARSED_DATA pHidPreparsedData;
	if (HidD_GetPreparsedData(m_hDevice, &pHidPreparsedData) == FALSE)
	{
		::CloseHandle(m_hDevice);
		m_hDevice = NULL;
		return E_FAIL;
	}
	HIDP_CAPS hidpCaps;
	HidP_GetCaps(pHidPreparsedData, &hidpCaps);
	m_uiMaxFeatureLength = hidpCaps.FeatureReportByteLength;
	HidD_FreePreparsedData(pHidPreparsedData);
	
	//
	//	On success, m_hDevice now contains a handle to the device
	//
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetId(PRODUCT_ID_REPORT& rProductId)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetId
(
	PRODUCT_ID_REPORT& rProductId	// @parm Reference to PRODUCT_ID_REPORT to get from driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}

	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rProductId.bReportId = MSGAME_FEATURE_GETID;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID