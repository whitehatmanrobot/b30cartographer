        if(pElem == NULL)
        {
            return NULL;
        }
        else
        {
            return *pElem;
        }
    }
}


//
// CStringPool
//

HRESULT CStringPool::GetNewString(LPCWSTR i_wsz, ULONG i_cch, LPWSTR* o_pwsz)
{
    DBG_ASSERT(o_pwsz != NULL);

    HRESULT hr;

    hr = GetNewArray(i_cch+1, o_pwsz);
    if(FAILED(hr))
    {
        return hr;
    }

    memcpy(*o_pwsz, i_wsz, (i_cch+1)*sizeof(wchar_t));
    return hr;
}

HRESULT CStringPool::GetNewString(LPCWSTR i_wsz, LPWSTR* o_pwsz) 
{
    return GetNewString(i_wsz, wcslen(i_wsz), o_pwsz);
}

//
// for debugging only
//
void CStringPool::ToConsole() const
{
    ULONG i;

    for(i = 0; i < m_PoolFixedSize.GetUsed(); i++)
    {
        wprintf(L"%s\n", Lookup(i));
    }
    for(i = 0; i < m_PoolDynamic.GetUsed(); i++)
    {
        wprintf( L"%s\n", Lookup( i | (1 << 31) ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\instancehelper.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    instancehelper.cpp

Abstract:

    Implementation of:
    CInstanceHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <comdef.h>
#include "iisfiles.h"

#include "instancehelper.h"
#include "utils.h"
#include "iiswmimsg.h"

#include "globalconstants.h"
#include "adminacl.h"
#include "ipsecurity.h"
#include "metabase.h"
#include "SmartPointer.h"
#include "schemadynamic.h"

extern CDynSchema* g_pDynSch;

CInstanceHelper::CInstanceHelper(
    ParsedObjectPath* i_pParsedObjPath,
    CWbemServices*    i_pNamespace) : 
    m_PathParser(e_ParserAcceptRelativeNamespace)
/*++

Synopsis: 
    Use this constructor when you have already parsed the object path.
    Caller owns the ParsedObjectPath.

Arguments: [i_pParsedObjPath] - 
           [i_pNamespace] - 
           
--*/
{
    Init(i_pParsedObjPath, i_pNamespace);
}


CInstanceHelper::CInstanceHelper(
    BSTR           i_bstrObjPath,
    CWbemServices* i_pNamespace) :
    m_PathParser(e_ParserAcceptRelativeNamespace)
/*++

Synopsis: 
    Use this constructor when have not already parsed the object path.

Arguments: [i_bstrObjPath] - 
           [i_pNamespace] - 
           
--*/
{
    DBG_ASSERT(i_bstrObjPath != NULL);
    DBG_ASSERT(i_pNamespace  != NULL);

    TSmartPointer<ParsedObjectPath> spParsedObject;

    HRESULT hr = WBEM_S_NO_ERROR;
    hr = CUtils::ParserErrToHR( m_PathParser.Parse(i_bstrObjPath, &spParsedObject) );
    THROW_ON_ERROR(hr);

    Init(spParsedObject, i_pNamespace);

    m_pParsedObjPath  = spParsedObject;
    spParsedObject    = NULL;

    m_bOwnObjPath = true;
}

void CInstanceHelper::Init(
    ParsedObjectPath* i_pParsedObjPath,
    CWbemServices*    i_pNamespace)
/*++

Synopsis: 
    Called by constructors.

Arguments: [i_pParsedObjPath] - 
           [i_pNamespace] - 
           
--*/
{
    m_pWmiClass = NULL;
    m_pWmiAssoc = NULL;

    DBG_ASSERT(i_pParsedObjPath != NULL);
    DBG_ASSERT(i_pNamespace     != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(CUtils::GetClass(i_pParsedObjPath->m_pClass,&m_pWmiClass))
    {
    }
    else if(CUtils::GetAssociation(i_pParsedObjPath->m_pClass,&m_pWmiAssoc))
    {
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    m_pParsedObjPath = i_pParsedObjPath;
    m_bOwnObjPath    = false;
    m_pNamespace     = i_pNamespace;

    THROW_ON_ERROR(hr);
}

void CInstanceHelper::GetAssociation(
    IWbemClassObject**       o_ppObj,
    bool                     i_bVerifyLeft,  //default(true)
    bool                     i_bVerifyRight) //default(true)
/*++

Synopsis: 
    Specifying i_bVerifyLeft or i_bVerifyRight can be expensive, especially
    during enumeration.  If you have already verified prior to calling this
    function that the left and/or right parts exist, then set these params
    to false.

Arguments: [o_ppObj] -        The WMI association that you "indicate" to WMI.
           [i_bVerifyLeft] -  Verify left part of the association is valid.
           [i_bVerifyRight] - Verify right part of association is valid.
           
--*/
{
    DBG_ASSERT(o_ppObj != NULL);

    CComPtr<IWbemClassObject>   spObj;   // This is the obj that the client gets back
    HRESULT                     hr = WBEM_S_NO_ERROR;

    if(m_pParsedObjPath->m_dwNumKeys < 2)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    KeyRef* pkrLeft  = NULL;
    KeyRef* pkrRight = NULL;
    for(ULONG i = 0; i < m_pParsedObjPath->m_dwNumKeys; i++)
    {
        KeyRef* pkr = m_pParsedObjPath->m_paKeys[i];
        if(pkr->m_pName)
        {
            if( !pkrLeft &&
                _wcsicmp(pkr->m_pName, m_pWmiAssoc->pType->pszLeft) == 0 )
            {
                pkrLeft = pkr;
            }
            if( !pkrRight &&
                _wcsicmp(pkr->m_pName, m_pWmiAssoc->pType->pszRight) == 0 )
            {
                pkrRight = pkr;
            }
        }
    }

    if( !pkrLeft || !pkrRight                 ||
        pkrLeft->m_vValue.vt       != VT_BSTR ||
        pkrRight->m_vValue.vt      != VT_BSTR ||
        pkrLeft->m_vValue.bstrVal  == NULL    ||
        pkrRight->m_vValue.bstrVal == NULL )
    {
        THROW_ON_ERROR(WBEM_E_INVALID_OBJECT_PATH);
    }

    //
    // Now verify the two object paths are valid
    //
    bool    abVerify[2];
    abVerify[0] = i_bVerifyLeft;
    abVerify[1] = i_bVerifyRight;
    KeyRef* apKr[2];
    apKr[0] = pkrLeft;
    apKr[1] = pkrRight;
    if(abVerify[0] || abVerify[1])
    {
        CMetabase metabase;
        CComPtr<IWbemClassObject> spObjTemp;
        for(ULONG i = 0; i < 2; i++)
        {
            if(abVerify[i])
            {
                spObjTemp = NULL;
                CInstanceHelper InstanceHelper(apKr[i]->m_vValue.bstrVal, m_pNamespace);
                if(InstanceHelper.IsAssoc())
                {
                    THROW_ON_ERROR(WBEM_E_NOT_FOUND);
                }
                InstanceHelper.GetInstance(
                    false,
                    &metabase,
                    &spObjTemp);
            }
        }
    }

    hr = CUtils::CreateEmptyInstance(m_pParsedObjPath->m_pClass, m_pNamespace, &spObj);
    THROW_ON_ERROR(hr);

    hr = spObj->Put(pkrLeft->m_pName, 0, &pkrLeft->m_vValue, 0);
    THROW_ON_ERROR(hr);

    hr = spObj->Put(pkrRight->m_pName, 0, &pkrRight->m_vValue, 0);
    THROW_ON_ERROR(hr);

    //
    // Set out parameters on success
    //
    *o_ppObj = spObj;
    (*o_ppObj)->AddRef();
}

void CInstanceHelper::GetInstance(
    bool                            i_bCreateKeyIfNotExist,
    CMetabase*                      io_pMetabase,
    IWbemClassObject**              o_ppObj,
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp)     // default(NULL)
/*++

Synopsis: 
    Will throw an exception on failure (generallly instance not found in mb).
    If GetInstance finds the instance in the metabase, but i_pExp was specified,
    it is possible *o_ppObj will not be populated with an instance.  
    This is a SUCCESS case.

Arguments: [i_bCreateKeyIfNotExist] - 
           [io_pMetabase] - 
           [o_ppObj] - The only success case where *o_ppObj will be NULL
                       is if it the instance is found in the metabase but i_pExp
                       (i.e. a query) is specified and the query doesn't match.
           [i_pExp] -  An optional query.
           
--*/
{ 
    DBG_ASSERT(o_ppObj         != NULL);
    DBG_ASSERT(io_pMetabase    != NULL);

    *o_ppObj = NULL;
    CComPtr<IWbemClassObject> spObj;

    HRESULT              hr = WBEM_S_NO_ERROR;
    METABASE_PROPERTY**  ppmbp;
    _bstr_t              bstrMbPath;
    METADATA_HANDLE      hKey = NULL;

    VARIANT    vtTrue;
    vtTrue.boolVal    = VARIANT_TRUE;
    vtTrue.vt         = VT_BOOL;

    hr = CUtils::CreateEmptyInstance(m_pParsedObjPath->m_pClass, m_pNamespace, &spObj);
    THROW_ON_ERROR(hr);

    CUtils::GetMetabasePath(spObj, m_pParsedObjPath, m_pWmiClass, bstrMbPath);

    //
    // if AdminACL 
    //
    if( m_pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        m_pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE
        )
    {
        CAdminACL objACL;
        hr = objACL.OpenSD(bstrMbPath);
        if(SUCCEEDED(hr))
            hr  = objACL.GetObjectAsync(spObj, m_pParsedObjPath, m_pWmiClass);
        THROW_ON_ERROR(hr);
        *o_ppObj = spObj;
        (*o_ppObj)->AddRef();
        return;
    }
    //
    // if IPSecurity
    //
    else if( m_pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        CIPSecurity IPSecurity;
        hr = IPSecurity.OpenSD(bstrMbPath, *io_pMetabase);
        if(SUCCEEDED(hr))
            hr  = IPSecurity.GetObjectAsync(spObj);
        THROW_ON_ERROR(hr);
        *o_ppObj = spObj;
        (*o_ppObj)->AddRef();
        return;
    }

    if(!i_bCreateKeyIfNotExist)
    {
        hKey = io_pMetabase->OpenKey(bstrMbPath, false);    
    }
    else
    {
        hKey = io_pMetabase->CreateKey(bstrMbPath);
    }

    _variant_t vt;

    //
    // If anything throws, CacheFree and then CloseKey is called automatically
    //
    io_pMetabase->CacheInit(hKey);

    //
    // Make sure requested keytype matches the keytype set at the node
    //
    if(!i_bCreateKeyIfNotExist)
    {
        io_pMetabase->Get(hKey, &METABASE_PROPERTY_DATA::s_KeyType, m_pNamespace, vt, NULL, NULL);
        if( vt.vt != VT_BSTR   || 
            vt.bstrVal == NULL ||
            !CUtils::CompareKeyType(vt.bstrVal, m_pWmiClass->pkt) )
        {
            CIIsProvException e;
            e.SetMC(WBEM_E_NOT_FOUND, IISWMI_INVALID_KEYTYPE, NULL);
            throw e;
        }
        vt.Clear();
    }

    //
    // User wants to filter number of instances returned
    // Walk thru all filters, and try and get these first.
    //
    if(i_pExp && !i_pExp->GetContainsOrOrNot())
    {
        SQL_LEVEL_1_TOKEN* pToken    = i_pExp->pArrayOfTokens;
        METABASE_PROPERTY* pMbpQuery = NULL;
        for(int i = 0; i < i_pExp->nNumTokens; i++, pToken++)
        {
            BOOL bInherited    = false;
            BOOL bDefault      = false;
            if( pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION )
            {
                hr = g_pDynSch->GetHashProps()->Wmi_GetByKey(
                    pToken->pPropertyName,
                    &pMbpQuery);
                //
                // User requested a property that is not in the schema
                //
                if(FAILED(hr))
                {
                    DBGPRINTF( (DBG_CONTEXT, 
                        "Property %ws not in schema\n", pToken->pPropertyName) );
                    THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
                }

                io_pMetabase->Get(hKey, pMbpQuery, m_pNamespace, vt, &bInherited, &bDefault);

                if(!CheckForQueryMatch(pToken, &vt))
                {
                    //
                    // We don't need to return this instance.
                    // value from metabase is not what user wanted.
                    //
					io_pMetabase->CacheFree();
					io_pMetabase->CloseKey(hKey);
                    return;
                }

                PutProperty(spObj, pToken->pPropertyName, &vt, bInherited, bDefault);

                vt.Clear();
            }
        }
    }

    //
    // Walk thru all the properties in the class and put them in an instance
    // we will return back to WMI
    //
    for (ppmbp=m_pWmiClass->ppmbp;*ppmbp; ppmbp++) 
    {            
        BOOL bInherited = false;
        BOOL bDefault   = false;

        BOOL bSkipProp  = false;
        if(i_pExp)
        {
            if(!i_pExp->FindRequestedProperty((*ppmbp)->pszPropName))
            {
                //
                // User did not request this property
                //
                bSkipProp = true;
            }
            else if(!i_pExp->GetContainsOrOrNot() && i_pExp->GetFilter((*ppmbp)->pszPropName))
            {
                //
                // Right above for loop, we handled all filters already.
                //
                bSkipProp = true;
            }
        }

        if( !bSkipProp )
        {
            io_pMetabase->Get(hKey, *ppmbp, m_pNamespace, vt, &bInherited, &bDefault);

            _bstr_t bstrPropName = (*ppmbp)->pszPropName;
            
            PutProperty(spObj, bstrPropName, &vt, bInherited, bDefault);

            vt.Clear();
        }
    }

    io_pMetabase->CacheFree();        
    io_pMetabase->CloseKey(hKey);
    hKey = NULL;

    //
    // Set qualifiers
    //
    LPCWSTR  awszNames[2] = { g_wszInstanceName, g_wszInstanceExists };
    VARIANT  apvValues[2];
    apvValues[0].bstrVal = bstrMbPath;
    apvValues[0].vt      = VT_BSTR;
    apvValues[1].boolVal = vtTrue.boolVal;
    apvValues[1].vt      = vtTrue.vt;

    hr = CUtils::SetQualifiers(spObj, awszNames, apvValues, 2,
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
    THROW_ON_ERROR(hr);

    //
    // Set out parameters on success
    //
    *o_ppObj = spObj;
    (*o_ppObj)->AddRef();
}

void CInstanceHelper::PutProperty(
    IWbemClassObject*        i_pInstance,
    const BSTR               i_bstrPropName,
    VARIANT*                 i_vtPropValue,
    BOOL                     i_bIsInherited,
    BOOL                     i_bIsDefault)
{
    DBG_ASSERT(i_pInstance);
    DBG_ASSERT(i_bstrPropName);
    DBG_ASSERT(i_vtPropValue);

    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    //
    // TODO: Log error if Put fails.
    //
    hr = i_pInstance->Put(i_bstrPropName, 0, i_vtPropValue, 0);
    if(FAILED(hr))
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "The property %ws in class %ws is not in repository\n", 
            i_bstrPropName, 
            m_pWmiClass->pszClassName));
    }

    if(i_bIsInherited && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            i_pInstance, i_bstrPropName, &g_wszIsInherit, &vtTrue, 1);
        THROW_ON_ERROR(hr);
    }
    else if(i_bIsDefault && SUCCEEDED(hr))
    {
        hr = CUtils::SetPropertyQualifiers(
            i_pInstance, i_bstrPropName, &g_wszIsDefault, &vtTrue, 1);
        THROW_ON_ERROR(hr);
    }
}

bool CInstanceHelper::CheckForQueryMatch(
    const SQL_LEVEL_1_TOKEN* i_pToken,
    const VARIANT*           i_pvtMatch)
/*++

Synopsis: 
    It's okay to return true even if there is not a match, but we should
    never do the opposite.

Arguments: [i_pToken] - 
           [i_pvtMatch] - 
           
Return Value: 

--*/{
    DBG_ASSERT(i_pToken);
    DBG_ASSERT(i_pvtMatch);
    DBG_ASSERT(i_pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION);

    bool bTypesMatch = false;


    //
    // Used only for VT_BOOL and VT_I4
    //
    ULONG ulToken = 0;
    ULONG ulMatch = 0;
    
    if( i_pvtMatch->vt == i_pToken->vConstValue.vt )
    {
        bTypesMatch = true;
    }

    if(bTypesMatch)
    {
        switch(i_pvtMatch->vt)
        {
        case VT_BOOL:
            ulMatch = i_pvtMatch->boolVal ? 1 : 0;
            ulToken = i_pToken->vConstValue.boolVal ? 1 : 0;
            //
            // deliberate fall thru
            //
        case VT_I4:
            if(i_pvtMatch->vt == VT_I4)
            {
                ulMatch = i_pvtMatch->lVal;
                ulToken = i_pToken->vConstValue.lVal;
            }
            switch(i_pToken->nOperator)
            {
            case SQL_LEVEL_1_TOKEN::OP_EQUAL:
                if(ulToken != ulMatch)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                if(ulToken == ulMatch)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                if(ulToken < ulMatch)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                if(ulToken > ulMatch)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
                if(ulToken >= ulMatch)
                {
                    return false;
                }
                break;
            case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                if(ulToken <= ulMatch)
                {
                    return false;
                }
                break;
            }
            break;
        case VT_BSTR:
            if(i_pToken->vConstValue.bstrVal && i_pvtMatch->bstrVal)
            {
                switch(i_pToken->nOperator)
                {
                case SQL_LEVEL_1_TOKEN::OP_EQUAL:
                    if(_wcsicmp(i_pToken->vConstValue.bstrVal, i_pvtMatch->bstrVal) != 0)
                    {
                        return false;
                    }
                    break;
                case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    if(_wcsicmp(i_pToken->vConstValue.bstrVal, i_pvtMatch->bstrVal) == 0)
                    {
                        return false;
                    }
                    break;
                }
            }
            break;
        default:
            break;
        }
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\instancehelper.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    instancehelper.h

Abstract:

    Definition of:
    CInstanceHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _instancehelper_h_
#define _instancehelper_h_

#include <windows.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <atlbase.h>

#include "sqllex.h"
#include <sql_1ext.h>

#include "schema.h"
#include "wbemservices.h"

//
// forward decl
//
class CMetabase;

class CInstanceHelper
{
public:
    CInstanceHelper(
        ParsedObjectPath* i_pParsedObjPath, 
        CWbemServices*    i_pNamespace);

    CInstanceHelper(
        BSTR              i_bstrObjPath,    
        CWbemServices*    i_pNamespace);

    ~CInstanceHelper()
    {
        if(m_pParsedObjPath && m_bOwnObjPath)
        {
            m_PathParser.Free(m_pParsedObjPath);
        }
    }

    void GetAssociation(
        IWbemClassObject**       o_ppObj,
        bool                     i_bVerifyLeft =true,
        bool                     i_bVerifyRight=true);

    void GetInstance(
        bool                            i_bCreateKeyIfNotExist,
        CMetabase*                      io_pMetabase,
        IWbemClassObject**              o_ppObj,
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp=NULL);

    bool IsAssoc() 
    { 
        return (m_pWmiAssoc != NULL);
    }

private:
    void Init(
        ParsedObjectPath* i_pParsedObjPath, 
        CWbemServices*    i_pNamespace);

    void PutProperty(
        IWbemClassObject*        i_pInstance,
        const BSTR               i_bstrPropName,
        VARIANT*                 i_vtPropValue,
        BOOL                     i_bIsInherited,
        BOOL                     i_bIsDefault);

    bool CheckForQueryMatch(
        const SQL_LEVEL_1_TOKEN* i_pToken,
        const VARIANT*           i_pvtMatch);

    bool                   m_bOwnObjPath;
    ParsedObjectPath*      m_pParsedObjPath;
    CObjectPathParser      m_PathParser;

    WMI_CLASS*             m_pWmiClass;
    WMI_ASSOCIATION*       m_pWmiAssoc;

    CWbemServices*         m_pNamespace;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\iisprov.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    iisprov.cpp

Abstract:

    Defines the CIISInstProvider class.  An object of this class is
    created by the class factory for each connection.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#define WMI_HR(hr)  \
    (FAILED(hr) && HRESULT_FACILITY(hr) != FACILITY_ITF) ? WBEM_E_FAILED : hr

#include "iisprov.h"
#include "appladmin.h"
#include "enum.h"
#include "ipsecurity.h"
#include "adminacl.h"
#include "certmap.h"
#include "iiswmimsg.h"
#include "pusher.h"
#include "instancehelper.h"
#include "webservicemethod.h"
#include "queryhelper.h"
#include "smartpointer.h"

#define PARAMS  WMI_METHOD_PARAM_DATA
#define METHODS WMI_METHOD_DATA
#define CLASSES WMI_CLASS_DATA
#define PROPS   METABASE_PROPERTY_DATA

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp
bool CIISInstProvider::ms_bInitialized = false;

HRESULT CIISInstProvider::DoInitialize(
    LPWSTR                  i_wszUser,
    LONG                    i_lFlags,
    LPWSTR                  i_wszNamespace,
    LPWSTR                  i_wszLocale,
    IWbemServices*          i_pNamespace,
    IWbemContext*           i_pCtx,
    IWbemProviderInitSink*  i_pInitSink)
/*++

Synopsis: 
    According to stevm from WMI, calls to Initialize are guaranteed to be
    synchronized - so long as all providers are in the same namespace.

Arguments: [wszUser] - 
           [lFlags] - 
           [wszNamespace] - 
           [wszLocale] - 
           [pNamespace] - 
           [pCtx] - 
           [pInitSink] - 
           
Return Value: 

--*/
{
    CPusher            pusher;
    CSchemaExtensions* pcatalog = NULL;
    HRESULT            hr       = WBEM_S_NO_ERROR;    // return value
    LONG               lStatus  = WBEM_S_INITIALIZED; // param to SetStatus

    CComPtr<IWbemContext>  spCtx       = i_pCtx;     // must AddRef according to doc

    //
    // If we hit this, we are leaking memory, because m_pNamespace is 
    // initilaized in this function only and cleaned up by the destructor only.
    //
    DBG_ASSERT(m_pNamespace == NULL);

    //
    // Initialize members
    //
    m_pNamespace = new CWbemServices(i_pNamespace); 
    if(m_pNamespace == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        i_pInitSink->SetStatus(WBEM_E_FAILED,0);
        return hr;
    }

    //
    // If we've already initialized globals, jump to the end.
    // Else, we're going to initialize globals.
    //
    if(ms_bInitialized)
    {
        goto exit;
    }

    pcatalog = new CSchemaExtensions();
    if(pcatalog == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    //
    // Initialize the g_pDynSch
    // Populate pCatalog
    //
    g_pDynSch = new CDynSchema();
    if(g_pDynSch == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    hr = g_pDynSch->Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = g_pDynSch->RunRules(pcatalog);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Use pCatalog, g_pDynSch to update repository
    //
    hr = pusher.Initialize(m_pNamespace, i_pCtx);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = pusher.Push(
        pcatalog,
        g_pDynSch->GetHashClasses(),
        g_pDynSch->GetHashAssociations());
    if(FAILED(hr))
    {
        goto exit;
    }

    ms_bInitialized = true;

    //
    // Destructor makes IST calls, so call before we unload dispenser dll.
    //
    delete pcatalog;
    pcatalog = NULL;

    //
    // If Init was successful, we will no longer need this dll.
    //
    UnloadDispenserDll(WSZ_PRODUCT_IIS);
    
exit:
    delete pcatalog;
    if(FAILED(hr))
    {
        DBG_ASSERT(ms_bInitialized == false);
        delete g_pDynSch;
        g_pDynSch = NULL;
        lStatus = WBEM_E_FAILED;
    }

    //
    //Let CIMOM know you are initialized
    //
    i_pInitSink->SetStatus(lStatus,0);
    return hr;
}

HRESULT CIISInstProvider::DoCreateInstanceEnumAsync( 
    const BSTR              i_ClassName,
    long                    i_lFlags, 
    IWbemContext*           i_pCtx, 
    IWbemObjectSink FAR*    i_pHandler
    )
/*++

Synopsis:
    Asynchronously enumerates the instances.

Arguments: 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject FAR* pes = NULL;
  
    //
    // Do a check of arguments.
    //
    if(i_ClassName == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try 
    {
        WorkerEnumObjectAsync(i_ClassName, i_pHandler);
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }
   
    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoDeleteInstanceAsync( 
    const BSTR          i_ObjectPath, 
    long                i_lFlags,
    IWbemContext*       i_pCtx,
    IWbemObjectSink*    i_pHandler
    )
{
    DBG_ASSERT(m_pNamespace != NULL);

    CObjectPathParser PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath* pParsedObject = NULL;
    IWbemClassObject* pes = NULL;
    HRESULT           hr = WBEM_S_NO_ERROR;

    if(i_ObjectPath == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    try
    {
        hr = CUtils::ParserErrToHR( PathParser.Parse(i_ObjectPath, &pParsedObject) );
        THROW_ON_ERROR(hr);
        DBG_ASSERT(pParsedObject);

        WorkerDeleteObjectAsync(pParsedObject);
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }

    if (pParsedObject)
    {
        PathParser.Free(pParsedObject);
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoExecMethodAsync(
    const BSTR          i_strObjectPath,                   
    const BSTR          i_strMethodName,
    long                i_lFlags,                       
    IWbemContext*       i_pCtx,                 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler
    )
{
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject* pes = NULL;

    //
    // Do a check of arguments and make sure we have pointer to Namespace
    //
    if( i_pHandler == NULL || 
        i_strMethodName == NULL || 
        i_strObjectPath == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try 
    {
        WorkerExecMethodAsync(
            i_strObjectPath,
            i_strMethodName, 
            i_pCtx,
            i_pInParams,
            i_pHandler
            );
    }
    catch (_com_error c)
    {
        hr = c.Error();
    }
    catch (CIIsProvException e) 
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoGetObjectAsync(
    const BSTR          i_ObjectPath, 
    long                i_lFlags,
    IWbemContext*       i_pCtx,
    IWbemObjectSink*    i_pHandler
    )
/*++

Synopsis:
    Creates an instance given a particular path value.

Arguments: 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_pNamespace != NULL);

    IWbemClassObject* pObj = NULL;
    IWbemClassObject* pes = NULL;
    HRESULT           hr = WBEM_S_NO_ERROR;

    if(i_ObjectPath == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    try
    {
        WorkerGetObjectAsync(&pObj, i_ObjectPath, false);
    
        hr = i_pHandler->Indicate(1,&pObj);
        pObj->Release();
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...) 
    {
        hr = WBEM_E_FAILED;
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}
    
HRESULT CIISInstProvider::DoPutInstanceAsync( 
    IWbemClassObject*    i_pObj,
    long                 i_lFlags,
    IWbemContext*        i_pCtx,
    IWbemObjectSink*     i_pHandler
    )
{
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT                    hr = WBEM_S_NO_ERROR;
    CObjectPathParser          PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath*          pParsedObject = NULL;
    CComPtr<IWbemClassObject>  spObjOld;
    CComBSTR                   sbstrObjPath;
    IWbemClassObject*          pes = NULL;

    if(i_pObj == NULL || i_pCtx == NULL || i_pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try 
    {
        _bstr_t    bstr = L"__RelPath"; 
        _variant_t vtObjPath;
        hr = i_pObj->Get(bstr, 0, &vtObjPath, NULL, NULL);
        THROW_ON_ERROR(hr);

        if (vtObjPath.vt != VT_BSTR)
        {
            bstr = L"__Class";
            vtObjPath.Clear();
            hr = i_pObj->Get(bstr, 0, &vtObjPath, NULL, NULL);
            THROW_ON_ERROR(hr);

            //
            // This means the user is trying to create an instance but did not
            // specify a primary key.
        }

        if(vtObjPath.vt != VT_BSTR)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_OBJECT);
        }

        hr = CUtils::ParserErrToHR( PathParser.Parse(vtObjPath.bstrVal, &pParsedObject) );
        THROW_ON_ERROR(hr);
        DBG_ASSERT(pParsedObject != NULL);

        bool      bInstanceExists = false; // existing or new instance

        WMI_CLASS* pWmiClass = NULL;
        ValidatePutParsedObject(
            pParsedObject, 
            i_pObj, 
            NULL, 
            &bInstanceExists,
            &pWmiClass);

        //
        // We auto-generate primary key only for IIsWebServer and IIsFtpServer
        //
        if( pParsedObject->m_dwNumKeys == 0 && 
            (pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer || 
             pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpServer) )
        {
            //
            // Get the ServerComment
            //
            _variant_t vtServerComment;
            hr = i_pObj->Get(PROPS::s_ServerComment.pszPropName, 
                0, &vtServerComment, NULL, NULL);
            if(hr == WBEM_E_NOT_FOUND || vtServerComment.vt != VT_BSTR)
            {
                vtServerComment.Clear();
                vtServerComment.bstrVal = NULL;
                vtServerComment.vt      = VT_BSTR;
                hr = WBEM_S_NO_ERROR;
            }
            THROW_ON_ERROR(hr);

            //
            // Create the site
            //
            eSC_SUPPORTED_SERVICES eServiceId;
            _bstr_t sbstrKeyValue;
            DWORD   dwSiteId      = 0;
            WCHAR   wszSiteId[11] = {0};

            if( pWmiClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer )
            {
                eServiceId      = SC_W3SVC;
                sbstrKeyValue   = "w3svc/";
            }
            else
            {
                eServiceId      = SC_MSFTPSVC;
                sbstrKeyValue   = "msftpsvc/";
            }
            CServiceMethod method(eServiceId);
            hr = method.Init();
            THROW_ON_ERROR(hr);
            hr = method.CreateNewSite(vtServerComment.bstrVal, &dwSiteId);
            THROW_ON_ERROR(hr);
            sbstrKeyValue += _itow(dwSiteId, wszSiteId, 10);

            VARIANT vtKeyValue;
            vtKeyValue.bstrVal = sbstrKeyValue;
            vtKeyValue.vt      = VT_BSTR;
            THROW_ON_FALSE(pParsedObject->AddKeyRefEx(pWmiClass->pszKeyName, &vtKeyValue));
        }

        if( pWmiClass->pkt != &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE &&
            pWmiClass->pkt != &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL &&
            pWmiClass->pkt != &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
        {
            WorkerGetObjectAsync(&spObjOld, pParsedObject, true);
        }

        WorkerPutObjectAsync(
            i_pObj, 
            spObjOld, 
            pParsedObject, 
            i_lFlags, 
            bInstanceExists,
            &sbstrObjPath);
    }    
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr  = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    if (pParsedObject)
    {
        PathParser.Free(pParsedObject);
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pHandler->SetStatus(
        WBEM_STATUS_COMPLETE, hr, sbstrObjPath, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

HRESULT CIISInstProvider::DoExecQueryAsync( 
    const BSTR                  i_bstrQueryLanguage,
    const BSTR                  i_bstrQuery,
    long                        i_lFlags,
    IWbemContext*               i_pCtx,
    IWbemObjectSink*            i_pResponseHandler)
{
    if( i_bstrQueryLanguage == NULL ||
        i_bstrQuery         == NULL ||
        i_pCtx              == NULL ||
        i_pResponseHandler  == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT                     hr  = WBEM_S_NO_ERROR;
    IWbemClassObject*           pes = NULL;

    try
    {
        CQueryHelper QueryHelper(
            i_bstrQueryLanguage,
            i_bstrQuery,
            m_pNamespace,
            i_pResponseHandler);
        if(QueryHelper.IsAssoc())
        {
            QueryHelper.GetAssociations();
        }
        else
        {
            QueryHelper.GetInstances();
        }
    }
    catch (CIIsProvException e)
    {
        pes = ConstructExtendedStatus(&e);
        hr  = e.GetHR();
    }
    catch (HRESULT hrError)
    {
        hr = hrError;
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    //
    // Set status
    //
    if(!pes)
    {
        pes = ConstructExtendedStatus(hr);
    }
    SCODE sc = i_pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, pes);
    if(pes)
    {
        pes->Release();
    }

    return sc;
}

IWbemClassObject* CIISInstProvider::ConstructExtendedStatus(
    HRESULT i_hr) const
{
    IWbemClassObject* pes     = NULL;

    //
    // We only need extended status on failure.
    //
    if(SUCCEEDED(i_hr))
    {
        return NULL;
    }

    CIIsProvException e;
    e.SetHR(i_hr);

    pes = ConstructExtendedStatus(&e);

    return pes;
}

IWbemClassObject* CIISInstProvider::ConstructExtendedStatus(
    const CIIsProvException* i_pException) const
{
    DBG_ASSERT(m_pNamespace != NULL);
    DBG_ASSERT(i_pException != NULL);

    HRESULT hr;
    CComPtr<IWbemClassObject> spClass;
    CComPtr<IWbemClassObject> spES;
    IWbemClassObject*         pESRet = NULL;

    CComBSTR sbstr = L"__ExtendedStatus";
    if(sbstr.m_str == NULL)
    {
        return NULL;
    }

    //
    // Get the __ExtendedStatus class and Spawn and instance
    //
    hr = m_pNamespace->GetObject(
        sbstr,
        0,
        NULL,
        &spClass,
        NULL
        );
    if(FAILED(hr))
    {
        return NULL;
    }

    hr = spClass->SpawnInstance(0, &spES);
    if(FAILED(hr))
    {
        return NULL;
    }

    //
    // Set the description.
    //
    CComVariant svt;
    sbstr.Empty();
    sbstr = i_pException->GetErrorText();
    svt = sbstr.Detach();
    if(svt.vt == VT_BSTR && svt.bstrVal != NULL)
    {
        hr = spES->Put(L"Description", 0, &svt, 0);
        if(FAILED(hr))
        {
            return NULL;
        }
    }

    //
    // Set the status code.
    //
    svt = i_pException->GetHR();
    hr = spES->Put(L"StatusCode", 0, &svt, 0);
    if(FAILED(hr))
    {
        return NULL;
    }

    //
    // Set the parameter info.
    //
    svt = i_pException->GetParams();
    if(svt.vt == VT_BSTR && svt.bstrVal != NULL)
    {
        hr = spES->Put(L"ParameterInfo", 0, &svt, 0);
        if(FAILED(hr))
        {
            return NULL;
        }
    }

    //
    // Set the provider name.
    //
    svt = g_wszIIsProvider;
    if(svt.vt == VT_BSTR && svt.bstrVal != NULL)
    {
        hr = spES->Put(L"ProviderName", 0, &svt, 0);
        if(FAILED(hr))
        {
            return NULL;
        }
    }

    //
    // If everything succeeded...
    //
    spES.CopyTo(&pESRet);
    return pESRet;
}

void CIISInstProvider::WorkerExecMethodAsync(
    BSTR                i_strObjectPath,
    BSTR                i_strMethodName,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler
    )
{ 
    DBG_ASSERT(i_strObjectPath != NULL);
    DBG_ASSERT(i_strMethodName != NULL);
    DBG_ASSERT(i_pHandler      != NULL);
    DBG_ASSERT(m_pNamespace    != NULL);

    WMI_CLASS*          pWMIClass;
    CObjectPathParser   PathParser(e_ParserAcceptRelativeNamespace);
    TSmartPointer<ParsedObjectPath> spParsedObjPath;
    _bstr_t             bstrMbPath;
    WMI_METHOD*         pmethod;
    HRESULT             hr   = WBEM_S_NO_ERROR;

    hr = CUtils::ParserErrToHR( PathParser.Parse(i_strObjectPath, &spParsedObjPath) );
    THROW_ON_ERROR(hr);
    DBG_ASSERT(spParsedObjPath != NULL);

    if (!CUtils::GetClass(spParsedObjPath->m_pClass,&pWMIClass))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    if (!CUtils::GetMethod(i_strMethodName, pWMIClass->ppMethod, &pmethod ))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_METHOD);
    }

    CUtils::GetMetabasePath(NULL,spParsedObjPath,pWMIClass,bstrMbPath);    

    if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpService)
    {
        WorkerExecFtpServiceMethod(
            bstrMbPath, 
            pWMIClass,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebService)
    {
        WorkerExecWebServiceMethod(
            bstrMbPath, 
            pWMIClass,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer)
    {
        CMetabase metabase;
        HRESULT hr = S_OK;
        metabase.PutMethod(bstrMbPath, pmethod->dwMDId);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory)
    {
        WorkerExecWebAppMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsComputer)
    {
        WorkerExecComputerMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsCertMapper)
    {
        WorkerExecCertMapperMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsApplicationPool)
    {
        WorkerExecAppPoolMethod(
            bstrMbPath, 
            pWMIClass->pszClassName,
            pmethod,
            i_pCtx,
            i_pInParams,
            i_pHandler,
            m_pNamespace
            );
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_METHOD);
    }
}

void CIISInstProvider::WorkerDeleteObjectAsync(
    ParsedObjectPath*    i_pParsedObject
    )
{ 
    DBG_ASSERT(m_pNamespace    != NULL);
    DBG_ASSERT(i_pParsedObject != NULL);

    HRESULT              hr   = WBEM_S_NO_ERROR;
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;
    METADATA_HANDLE      hKey = NULL;
    CMetabase            metabase;

    if (!CUtils::GetClass(i_pParsedObject->m_pClass,&pWMIClass))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    //
    // get the meta path of object
    //
    CUtils::GetMetabasePath(NULL,i_pParsedObject,pWMIClass,bstrMbPath);

    //
    // if AdminACL
    //
    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL )
    {
        THROW_ON_ERROR(WBEM_E_NOT_SUPPORTED);
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity)
    {
        hKey = metabase.OpenKey(bstrMbPath, true);
        metabase.DeleteData(hKey, MD_IP_SEC, BINARY_METADATA);
        metabase.CloseKey(hKey);
        return;
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE)
    {
        CAdminACL objACL;
        hr = objACL.OpenSD(bstrMbPath);
        if(SUCCEEDED(hr))
            hr = objACL.DeleteObjectAsync(i_pParsedObject);
        THROW_ON_ERROR(hr);
        return;
    }
    else if(pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsApplicationPool)
    {
        CAppPoolMethod objAppPool;
        objAppPool.DeleteAppPool(bstrMbPath);
        return;
    }

    if( pWMIClass->pkt->m_pszDisallowDeletionNode &&
        _wcsicmp(bstrMbPath, pWMIClass->pkt->m_pszDisallowDeletionNode) == 0 )
    {
        CIIsProvException e;
        e.SetMC(WBEM_E_INVALID_OPERATION, IISWMI_INSTANCE_DELETION_DISALLOWED, NULL);
        throw e;
    }

    DBG_ASSERT(((LPWSTR)(bstrMbPath))[0] == L'/');
    DBG_ASSERT(((LPWSTR)(bstrMbPath))[1] != L'\0');
    LPWSTR pParent = wcsrchr(bstrMbPath, L'/');

    WCHAR wcStore = *pParent;
    *pParent      = L'\0';

    hKey     = metabase.OpenKey(bstrMbPath, true);
    *pParent = wcStore;
    hr       = metabase.DeleteKey(hKey, pParent);
    THROW_ON_ERROR(hr);
  
    metabase.CloseKey(hKey);
}

void CIISInstProvider::WorkerGetObjectAsync(
    IWbemClassObject**   o_ppObj,
    ParsedObjectPath*    i_pParsedObjPath,
    bool                 i_bCreateKeyIfNotExist)
{
    WMI_CLASS*       pWmiClass = NULL;
    WMI_ASSOCIATION* pWmiAssoc = NULL;
    CMetabase        metabase;

    CInstanceHelper  InstanceHelper(i_pParsedObjPath, m_pNamespace);

    if(!InstanceHelper.IsAssoc())
    {
        InstanceHelper.GetInstance(
            i_bCreateKeyIfNotExist,     // in
            &metabase,                  // in/out
            o_ppObj);                   // out
    }
    else
    {
        InstanceHelper.GetAssociation(
            o_ppObj);                   // out
    }
}

void CIISInstProvider::WorkerGetObjectAsync(
    IWbemClassObject**   o_ppObj,
    BSTR                 i_bstrObjPath,
    bool                 i_bCreateKeyIfNotExist)
{
    WMI_CLASS*       pWmiClass = NULL;
    WMI_ASSOCIATION* pWmiAssoc = NULL;
    CMetabase        metabase;

    CInstanceHelper  InstanceHelper(i_bstrObjPath, m_pNamespace);

    if(!InstanceHelper.IsAssoc())
    {
        InstanceHelper.GetInstance(
            i_bCreateKeyIfNotExist,     // in
            &metabase,                  // in/out
            o_ppObj);                   // out
    }
    else
    {
        InstanceHelper.GetAssociation(
            o_ppObj);                   // out
    }
}

void CIISInstProvider::ValidatePutParsedObject(
    ParsedObjectPath*    i_pParsedObject,
    IWbemClassObject*    i_pObj,
    bool*                io_pbInstanceNameSame,
    bool*                io_pbInstanceExists,
    WMI_CLASS**          o_ppWmiClass
    )
/*++

Synopsis: 
    Validates stuff before a Put operation.

      - Checks to see that the user is not changing the instance's
        primary key.

      - Verifies the parent metabase node exists.

      - Checks the container class list of the parent node in the metabase
        to see if it contains the node we are trying to insert.

      - Throws on failure.  You should not continue with the put operation.

Arguments: [i_pParsedObject] - 
           
--*/
{    
    DBG_ASSERT(i_pParsedObject != NULL);
    DBG_ASSERT(i_pObj          != NULL);
    DBG_ASSERT(m_pNamespace    != NULL);

    WMI_CLASS*           pWMIClass  = NULL;
    WMI_ASSOCIATION*     pWMIAssoc  = NULL;
    _bstr_t              bstrMbPath;
    HRESULT              hr         = WBEM_S_NO_ERROR;

    if(CUtils::GetClass(i_pParsedObject->m_pClass,&pWMIClass))
    {
    }
    else if(CUtils::GetAssociation(i_pParsedObject->m_pClass,&pWMIAssoc))
    {
        THROW_ON_ERROR(WBEM_E_INVALID_OPERATION);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS)
    }
    if(o_ppWmiClass)
    {
        *o_ppWmiClass = pWMIClass;
    }

    bool bSpecialPut = false;
    if( i_pParsedObject->m_dwNumKeys == 0)
    {
        if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsFtpServer )
        {
            bSpecialPut = true;
        }
        else
        {
            THROW_ON_ERROR(WBEM_E_INVALID_OBJECT);
        }
    }

    if(!bSpecialPut)
    {
        CUtils::GetMetabasePath(NULL, i_pParsedObject, pWMIClass, bstrMbPath);
        DBG_ASSERT(((LPWSTR)bstrMbPath) != NULL);
    }

    //
    // Get the instance qualifiers in order to eventually evaluate
    // that the user has not tried to change the primary key on
    // this instance.
    //
    const ULONG iQuals = 2;
    _variant_t  avtQualValues[iQuals];
    LPCWSTR     awszQualNames[iQuals];

    DBG_ASSERT(g_idxInstanceExists < iQuals);
    DBG_ASSERT(g_idxInstanceName   < iQuals);

    awszQualNames[g_idxInstanceExists] = g_wszInstanceExists;
    awszQualNames[g_idxInstanceName]   = g_wszInstanceName;
    hr = CUtils::GetQualifiers(i_pObj, awszQualNames, avtQualValues, iQuals);
    THROW_ON_ERROR(hr);

    //
    // We assume the instance names are the same unless we can explicitly
    // detect they are not.
    //
    bool bInstanceNameSame = true;
    if( avtQualValues[g_idxInstanceName].vt == VT_BSTR &&
        avtQualValues[g_idxInstanceName].bstrVal != NULL)
    {
        if(!bSpecialPut)
        {
            if(_wcsicmp(avtQualValues[g_idxInstanceName].bstrVal, bstrMbPath) != 0)
            {
                bInstanceNameSame = false;
            }
        }
        else
        {
            bInstanceNameSame = false;
        }
    }

    bool bInstanceExists = false;
    if( avtQualValues[g_idxInstanceExists].vt == VT_BOOL &&
        avtQualValues[g_idxInstanceExists].boolVal )
    {
        bInstanceExists = true;
    }

    if(bInstanceExists && !bInstanceNameSame)
    {
        //
        // Someone has tried to change the primary key.
        //
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_CANNOT_CHANGE_PRIMARY_KEY_FIELD, NULL);
        DBGPRINTF((DBG_CONTEXT, "Cannot change primary key field\n"));
        throw e;
    }

    if(io_pbInstanceExists)
    {
        *io_pbInstanceExists   = bInstanceExists;
    }
    if(io_pbInstanceNameSame)
    {
        *io_pbInstanceNameSame = bInstanceNameSame;
    }

    //
    // Now verify that if this is a new class, creation is allowed.
    //
    if(!bInstanceExists && !pWMIClass->bCreateAllowed)
    {
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_INSTANCE_CREATION_DISALLOWED, NULL);
        DBGPRINTF((DBG_CONTEXT, "Instance creation disallowed\n"));
        throw e;
    }

    if(bSpecialPut)
    {
        return;
    }

    //
    // Now, validate the keytype against the parent's container
    // class list.  The return cases below are the few times
    // we actually won't do this validation.
    //
    METADATA_HANDLE      hKey = NULL;

    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity)
    {
        return;
    }
    if(((LPWSTR)bstrMbPath) && _wcsicmp(bstrMbPath, L"/LM") == 0)
    {
        return;
    }

    ULONG cch = wcslen(bstrMbPath);
    CComBSTR sbstrMbParentPath(cch);
    if(sbstrMbParentPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }
    hr = CUtils::GetParentMetabasePath(
        bstrMbPath,
        sbstrMbParentPath);
    if(FAILED(hr))
    {
        //
        // There is no parent node in the string specified
        //
        return;
    }

    //
    // Get parent keytype from metabase
    //
    WMI_CLASS* pWMIParentClass = NULL;
    CMetabase  metabase;
    _variant_t vt;

    hKey = metabase.OpenKey(sbstrMbParentPath, false);
    metabase.Get(hKey, &METABASE_PROPERTY_DATA::s_KeyType, m_pNamespace, vt, NULL, NULL);
    metabase.CloseKey(hKey);

    if( vt.vt != VT_BSTR)
    {
        CIIsProvException e;
        e.SetMC(
            WBEM_E_INVALID_OBJECT, 
            IISWMI_NO_PARENT_KEYTYPE, 
            NULL, 
            pWMIClass->pkt->m_pszName);
        DBGPRINTF((DBG_CONTEXT, "No parent keytype.\n"));
        throw e;
    }

    //
    // Walk thru the current class's inverse container class list and see
    // if the parent keytype is there.
    //
    if(!CUtils::GetClass(vt.bstrVal, &pWMIParentClass))
    {
        if( _wcsicmp(vt.bstrVal, L"IIs_ROOT") == 0 &&
            pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_IIsComputer )
        {
            return;
        }
        else
        {
            CIIsProvException e;
            e.SetMC(
                WBEM_E_INVALID_OBJECT, 
                IISWMI_INVALID_PARENT_KEYTYPE, 
                NULL, 
                pWMIClass->pkt->m_pszName, 
                L"<NULL>");
            DBGPRINTF((DBG_CONTEXT, "Invalid parent keytype.\n"));
            throw e;
        }
    }
    METABASE_KEYTYPE_NODE* pKtNode = pWMIClass->pkt->m_pKtListInverseCCL;
    while(pKtNode != NULL)
    {
        if(pWMIParentClass->pkt == pKtNode->m_pKt)
        {
            break;
        }
        pKtNode = pKtNode->m_pKtNext;
    }
    if(pKtNode == NULL)
    {
        CIIsProvException e;
        e.SetMC(
            WBEM_E_INVALID_OBJECT, 
            IISWMI_INVALID_PARENT_KEYTYPE, 
            NULL, 
            pWMIClass->pkt->m_pszName, 
            pWMIParentClass->pkt->m_pszName);
        DBGPRINTF((DBG_CONTEXT, "Invalid parent keytype.\n"));
        throw e;
    }
}

void CIISInstProvider::WorkerPutObjectAsync(
    IWbemClassObject*    i_pObj,
    IWbemClassObject*    i_pObjOld,               // can be NULL
    ParsedObjectPath*    i_pParsedObject,
    long                 i_lFlags,
    bool                 i_bInstanceExists,
    BSTR*                o_pbstrObjPath
    )
{ 
    DBG_ASSERT(i_pObj          != NULL);
    DBG_ASSERT(i_pParsedObject != NULL);
    DBG_ASSERT(m_pNamespace    != NULL);
    DBG_ASSERT(o_pbstrObjPath  != NULL);
    DBG_ASSERT(*o_pbstrObjPath == NULL);

    *o_pbstrObjPath = NULL;

    CComBSTR             sbstrObjPath;
    HRESULT              hr        = WBEM_S_NO_ERROR;
    METABASE_PROPERTY**  ppmbp;
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;
    METADATA_HANDLE      hKey = NULL;
    DWORD                dwQuals = 0;

    if (!CUtils::GetClass(i_pParsedObject->m_pClass,&pWMIClass))
        throw (HRESULT)WBEM_E_INVALID_CLASS;

    CUtils::GetMetabasePath(NULL,i_pParsedObject,pWMIClass,bstrMbPath);

    //
    // if AdminACL
    //
    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE
        )
    {
        CAdminACL objACL;
        hr = objACL.OpenSD(bstrMbPath);
        if( SUCCEEDED(hr) )        
            hr = objACL.PutObjectAsync(i_pObj, i_pParsedObject, pWMIClass);
        THROW_ON_ERROR(hr);
        return;
    }
    //
    // IPSecurity
    //
    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        CIPSecurity objIPSec;
        CMetabase   metabase;
        hr = objIPSec.OpenSD(bstrMbPath, metabase);
        if( SUCCEEDED(hr) )        
            hr = objIPSec.PutObjectAsync(i_pObj);
        THROW_ON_ERROR(hr);
        return;
    }

    //
    // Walk thru the properties
    //
    CMetabase metabase;
    hKey = metabase.CreateKey(bstrMbPath);

    _variant_t  vt;
    _variant_t  vtOld;
    _variant_t* pvtOld;
    _bstr_t     bstrPropName;

    for (ppmbp=pWMIClass->ppmbp;*ppmbp && hr==WBEM_S_NO_ERROR; ppmbp++) 
    {
        bstrPropName = (*ppmbp)->pszPropName;
        hr = i_pObj->Get(bstrPropName, 0, &vt, NULL, NULL);

        //
        // Just ignore properties that are not in the repository.
        //
        if(FAILED(hr))
        {
            hr = WBEM_S_NO_ERROR;
            continue;
        }

        //
        // Get the property qualifiers
        //
        hr = CUtils::GetPropertyQualifiers(i_pObj, bstrPropName, &dwQuals);
        THROW_E_ON_ERROR(hr,*ppmbp);

        pvtOld = NULL;
        if(i_pObjOld != NULL) 
        {
            hr = i_pObjOld->Get(bstrPropName, 0, &vtOld, NULL, NULL);
            pvtOld = &vtOld;
            THROW_E_ON_ERROR(hr,*ppmbp);
        }
        THROW_E_ON_ERROR(hr,*ppmbp);
        
        if (vt.vt == VT_NULL) 
        {
            //
            // Only delete non-flag properties.
            //
            if ((*ppmbp)->dwMDMask == 0 && vtOld.vt != VT_NULL)
            {
                if(i_bInstanceExists)
                {
                    metabase.DeleteData(hKey, *ppmbp, true);
                }
                else
                {
                    metabase.DeleteData(hKey, *ppmbp, false);
                }
            }
            continue;
        }

        metabase.Put(
            hKey, 
            *ppmbp, 
            m_pNamespace,
            vt, 
            pvtOld, 
            dwQuals, 
            i_bInstanceExists);
        vt.Clear();
        vtOld.Clear();
    }
    
    if( pWMIClass->pkt != NULL && 
        pWMIClass->pkt->m_pszName != NULL &&
        pWMIClass->pkt != &METABASE_KEYTYPE_DATA::s_IIsObject )
    {
        vt = pWMIClass->pkt->m_pszName;
        metabase.PutString(hKey, &METABASE_PROPERTY_DATA::s_KeyType, vt, NULL);
    }

    metabase.CloseKey(hKey);

    hr = CUtils::ConstructObjectPath(bstrMbPath, pWMIClass, &sbstrObjPath);
    THROW_ON_ERROR(hr);

    //
    // Set out parameters if everything succeeds
    //
    *o_pbstrObjPath = sbstrObjPath.Detach();
}

void CIISInstProvider::WorkerEnumObjectAsync(
    BSTR                    i_bstrClassName, 
    IWbemObjectSink FAR*    i_pHandler
    )
{
    WMI_CLASS*          pClass;
    WMI_ASSOCIATION*    pAssociation = NULL;
    ParsedObjectPath    ParsedObject;            //deconstructer frees memory

    if (CUtils::GetAssociation(i_bstrClassName,&pAssociation))
    {
        CEnum EnumAssociation;
        EnumAssociation.Init(
            i_pHandler,
            m_pNamespace,
            &ParsedObject,
            pAssociation->pcRight->pszMetabaseKey,
            pAssociation
            );
        EnumAssociation.Recurse(
            NULL,
            &METABASE_KEYTYPE_DATA::s_IIsComputer,        
            NULL,
            pAssociation->pcRight->pszKeyName,
            pAssociation->pcRight->pkt
            );
    } 
    else if (CUtils::GetClass(i_bstrClassName,&pClass))
    {
        if (!ParsedObject.SetClassName(pClass->pszClassName))
            throw (HRESULT)WBEM_E_FAILED;

        CEnum EnumObject;
        EnumObject.Init(
            i_pHandler,
            m_pNamespace,
            &ParsedObject,
            pClass->pszMetabaseKey,
            NULL
            );
        EnumObject.Recurse(
            NULL,
            &METABASE_KEYTYPE_DATA::s_NO_TYPE,
            NULL,
            pClass->pszKeyName, 
            pClass->pkt
            );
    }
    else
        throw (HRESULT)WBEM_E_INVALID_CLASS;
}


void CIISInstProvider::WorkerExecWebAppMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    HRESULT    hr = WBEM_S_NO_ERROR;
    _variant_t vt;                      // stores the parameter value
    _variant_t vt2;                      // stores the parameter value
    _variant_t vt3;                      // stores the parameter value
    CWebAppMethod obj;                  // encapsulates all the web app methods

    if(i_pMethod == &METHODS::s_AppCreate)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_InProcFlag.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_AppPoolName.pszParamName, 0, &vt2, NULL, NULL);   
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_bCreate.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);

        if (vt3.vt != VT_BOOL) {
            hr = obj.AppCreate(i_wszMbPath, vt, 
                                CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_AppPoolName.pszParamName),
                                false);
        }
        else {
            hr = obj.AppCreate(i_wszMbPath, vt, 
                                CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_AppPoolName.pszParamName),
                                vt3);
        }
    }
    else if(i_pMethod == &METHODS::s_AppCreate2)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_AppMode.pszParamName, 0, &vt, NULL, NULL);   
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_AppPoolName.pszParamName, 0, &vt2, NULL, NULL);   
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_bCreate.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);

        if (vt3.vt != VT_BOOL) {
            hr = obj.AppCreate(i_wszMbPath, vt, 
                                CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_AppPoolName.pszParamName),
                                false);
        }
        else {
            hr = obj.AppCreate(i_wszMbPath, vt, 
                                CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_AppPoolName.pszParamName),
                                vt3);
        }
    }
    else if(i_pMethod == &METHODS::s_AppDelete)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppDelete(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppDisable)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppDisable(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppEnable)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppEnable(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppUnLoad)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Recursive.pszParamName, 0, &vt, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.AppUnLoad(i_wszMbPath, vt);
    }
    else if(i_pMethod == &METHODS::s_AppGetStatus)
    {
        //
        // call method - AppGetStatus
        //
        DWORD dwStatus;
        hr = obj.AppGetStatus(i_wszMbPath, &dwStatus);
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams = NULL;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put it into the output object
        //
        vt.vt   = VT_I4;
        vt.lVal = dwStatus;
        hr = spOutParams->Put(L"ReturnValue", 0, &vt, 0);      
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else if(i_pMethod == &METHODS::s_AspAppRestart)
    {
        hr = obj.AspAppRestart(i_wszMbPath);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}

void CIISInstProvider::WorkerExecFtpServiceMethod(
    LPCWSTR             i_wszMbPath,
    WMI_CLASS*          i_pClass,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler)
{
    DBG_ASSERT(i_pClass       != NULL);
    DBG_ASSERT(i_pHandler     != NULL);
    DBG_ASSERT(m_pNamespace   != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(i_pMethod == &METHODS::s_ServiceCreateNewServer)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        CServiceMethod ServiceMethod(SC_MSFTPSVC);
        hr = ServiceMethod.Init();
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = ServiceMethod.CreateNewSite(
            m_pNamespace,
            i_wszMbPath,
            i_pCtx,
            i_pClass,
            i_pMethod,
            i_pInParams,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}


void CIISInstProvider::WorkerExecWebServiceMethod(
    LPCWSTR             i_wszMbPath,
    WMI_CLASS*          i_pClass,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler
    )
{
    DBG_ASSERT(i_pHandler   != NULL);
    DBG_ASSERT(m_pNamespace != NULL);

    HRESULT   hr          = WBEM_S_NO_ERROR;
    METADATA_HANDLE hKey  = 0;

    if(i_pMethod == &METHODS::s_GetCurrentMode)
    {
        _variant_t     vtServerMode;
        CAppPoolMethod obj;
        obj.GetCurrentMode(&vtServerMode);

        //
        // Set out params
        //
        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            m_pNamespace,
            i_pCtx,
            i_pClass->pszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_ServerMode.pszParamName, 0, &vtServerMode, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if(i_pMethod == &METHODS::s_ServiceCreateNewServer)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        CServiceMethod ServiceMethod(SC_W3SVC);
        hr = ServiceMethod.Init();
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = ServiceMethod.CreateNewSite(
            m_pNamespace,
            i_wszMbPath,
            i_pCtx,
            i_pClass,
            i_pMethod,
            i_pInParams,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr); 
}

void CIISInstProvider::WorkerExecComputerMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t vt1, vt2, vt3, vt4, vt5, vt6;
    CMetabase obj;

    if(i_pMethod == &METHODS::s_SaveData)
    {
        hr = obj.SaveData();
        THROW_ON_ERROR(hr);
    }
    else if(i_pMethod == &METHODS::s_EnumBackups)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        //
        // get in params
        //
        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_IndexIn.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
       
        //
        // make in/out params
        //
        WCHAR BackupLocation[MD_BACKUP_MAX_LEN] = {0};
        if(vt1.vt == VT_BSTR && vt1.bstrVal != NULL)
        {
            ULONG cchBackupLocation = wcslen(vt1.bstrVal);
            if(cchBackupLocation < MD_BACKUP_MAX_LEN)
            {
                memcpy(
                    BackupLocation, 
                    vt1.bstrVal, 
                    sizeof(WCHAR)*(cchBackupLocation+1));
            }
            else
            {
                CIIsProvException e;
                e.SetHR(
                    WBEM_E_INVALID_PARAMETER, 
                    PARAMS::s_BackupLocation.pszParamName);
                throw e;
            }            
        }

        //
        // define out params
        //
        DWORD    BackupVersionOut; 
        FILETIME BackupDateTimeOut;

        //
        // call method - EnumBackups.
        //
        hr = obj.EnumBackups(
            BackupLocation, 
            &BackupVersionOut, 
            &BackupDateTimeOut, 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_IndexIn.pszParamName));
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put it into the output object
        // out BackupLocation
        //
        vt1 = BackupLocation;
        hr = spOutParams->Put(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 
        //
        // out BackupVersionOut        
        //
        vt1.vt = VT_I4;
        vt1.lVal = BackupVersionOut;
        hr = spOutParams->Put(PARAMS::s_BackupVersionOut.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 
        //
        // out BackupDateTimeOut (UTC time)
        //
        WCHAR datetime[30];
        CUtils::FileTimeToWchar(&BackupDateTimeOut, datetime);
        vt1 = datetime;
        hr = spOutParams->Put(PARAMS::s_BackupDateTimeOut.pszParamName, 0, &vt1, 0);
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else if(i_pMethod == &METHODS::s_BackupWithPasswd)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_PARAMETER);
        }

        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_BackupVersion.pszParamName, 0, &vt2, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_BackupFlags.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_Password.pszParamName, 0, &vt4, NULL, NULL);   
        THROW_ON_ERROR(hr);

        hr = obj.BackupWithPasswd(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_BackupLocation.pszParamName),
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_BackupVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt3, PARAMS::s_BackupFlags.pszParamName),
            CUtils::ExtractBstrFromVt(&vt4, PARAMS::s_Password.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_DeleteBackup)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_BackupVersion.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.DeleteBackup(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_BackupLocation.pszParamName), 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_BackupVersion.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_RestoreWithPasswd)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_BackupLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_BackupVersion.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_BackupFlags.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_Password.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.RestoreWithPasswd(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_BackupLocation.pszParamName), 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_BackupVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt3, PARAMS::s_BackupFlags.pszParamName),
            CUtils::ExtractBstrFromVt(&vt4, PARAMS::s_Password.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_Export)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Passwd.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_FileName.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_SourcePath.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MDFlags.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.Export(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_Passwd.pszParamName), 
            CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_FileName.pszParamName), 
            CUtils::ExtractBstrFromVt(&vt3, PARAMS::s_SourcePath.pszParamName), 
            CUtils::ExtractLongFromVt(&vt4, PARAMS::s_MDFlags.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_Import)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_Passwd.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_FileName.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_SourcePath.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_DestPath.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MDFlags.pszParamName, 0, &vt5, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.Import(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_Passwd.pszParamName),
            CUtils::ExtractBstrFromVt(&vt2, PARAMS::s_FileName.pszParamName),
            CUtils::ExtractBstrFromVt(&vt3, PARAMS::s_SourcePath.pszParamName),
            CUtils::ExtractBstrFromVt(&vt4, PARAMS::s_DestPath.pszParamName),
            CUtils::ExtractLongFromVt(&vt5, PARAMS::s_MDFlags.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_RestoreHistory)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_MDHistoryLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MajorVersion.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MinorVersion.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_MDFlags.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = obj.RestoreHistory(
            CUtils::ExtractBstrFromVt(&vt1, PARAMS::s_MDHistoryLocation.pszParamName), 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_MajorVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt3, PARAMS::s_MinorVersion.pszParamName),
            CUtils::ExtractLongFromVt(&vt4, PARAMS::s_MDFlags.pszParamName));
    }
    else if(i_pMethod == &METHODS::s_EnumHistory)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        //
        // get in params
        //
        hr = i_pInParams->Get(PARAMS::s_MDHistoryLocation.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_EnumIndex.pszParamName, 0, &vt2, NULL, NULL);  
        THROW_ON_ERROR(hr);
       
        //
        // make in/out params
        //
        WCHAR MDHistoryLocation[MD_BACKUP_MAX_LEN] = {0};
        if(vt1.vt == VT_BSTR && vt1.bstrVal != NULL)
        {
            ULONG cchHistoryLocation = wcslen(vt1.bstrVal);
            if(cchHistoryLocation < MD_BACKUP_MAX_LEN)
            {
                memcpy(
                    MDHistoryLocation, 
                    vt1.bstrVal, 
                    sizeof(WCHAR)*(cchHistoryLocation+1));
            }
            else
            {
                CIIsProvException e;
                e.SetHR(
                    WBEM_E_INVALID_PARAMETER,
                    PARAMS::s_MDHistoryLocation.pszParamName);
                throw e;
            }            
        }

        //
        // define out params
        //
        DWORD HistoryMajorVersionOut; 
        DWORD HistoryMinorVersionOut; 
        FILETIME HistoryDateTimeOut;

        //
        // call method - EnumHistory.
        //
        hr = obj.EnumHistory(
            MDHistoryLocation, 
            &HistoryMajorVersionOut, 
            &HistoryMinorVersionOut, 
            &HistoryDateTimeOut, 
            CUtils::ExtractLongFromVt(&vt2, PARAMS::s_EnumIndex.pszParamName));
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put it into the output object
        // out MDHistoryLocation
        //
        vt1 = MDHistoryLocation;
        hr = spOutParams->Put(PARAMS::s_MDHistoryLocation.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr);
 
        //
        // out HistoryMajorVersionOut        
        //
        vt1.vt = VT_I4;
        vt1.lVal = HistoryMajorVersionOut;
        hr = spOutParams->Put(PARAMS::s_MajorVersion.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 

        //
        // out HistoryMinorVersionOut        
        //
        vt1.vt = VT_I4;
        vt1.lVal = HistoryMinorVersionOut;
        hr = spOutParams->Put(PARAMS::s_MinorVersion.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 

        //
        // out HistoryDateTimeOut (UTC time)
        //
        WCHAR datetime[30];
        CUtils::FileTimeToWchar(&HistoryDateTimeOut, datetime);
        vt1 = datetime;
        hr = spOutParams->Put(PARAMS::s_HistoryTime.pszParamName, 0, &vt1, 0);      
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}

void CIISInstProvider::WorkerExecAppPoolMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    DBG_ASSERT(i_wszMbPath  != NULL);
    DBG_ASSERT(i_pNameSpace != NULL);
    DBG_ASSERT(i_pHandler   != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    CAppPoolMethod obj;

    if(i_pMethod == &METHODS::s_EnumAppsInPool)
    {
        CComVariant vtApplications;
        obj.EnumAppsInPool(i_wszMbPath, &vtApplications);


        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        hr = spOutParams->Put(PARAMS::s_Applications.pszParamName, 0, &vtApplications, 0);
        THROW_ON_ERROR(hr);

        hr = i_pHandler->Indicate(1, &spOutParams);
        THROW_ON_ERROR(hr);
    }
    else if(i_pMethod == &METHODS::s_RecycleAppPool)
    {
        obj.RecycleAppPool(i_wszMbPath);
    }
    else if(i_pMethod == &METHODS::s_Start)
    {
        obj.Start(i_wszMbPath);
    }
    else if(i_pMethod == &METHODS::s_Stop)
    {
        obj.Stop(i_wszMbPath);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_METHOD);
    }
}


void CIISInstProvider::WorkerExecCertMapperMethod(
    LPCWSTR             i_wszMbPath,
    LPCWSTR             i_wszClassName,
    WMI_METHOD*         i_pMethod,
    IWbemContext*       i_pCtx, 
    IWbemClassObject*   i_pInParams,
    IWbemObjectSink*    i_pHandler,
    CWbemServices*      i_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t vt1, vt2, vt3=L"1", vt4=L"1", vt5=L"1", vt6=L"1", vt7=L"1";
    CCertMapperMethod obj(i_wszMbPath);

    if(i_pMethod == &METHODS::s_CreateMapping)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS)
        }

        hr = i_pInParams->Get(PARAMS::s_vCert.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtAcct.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtPwd.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_strName.pszParamName, 0, &vt4, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_IEnabled.pszParamName, 0, &vt5, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - CreateMapping.
        //
        hr = obj.CreateMapping(vt1, vt2.bstrVal, vt3.bstrVal, vt4.bstrVal, vt5);
    }
    else if(i_pMethod == &METHODS::s_DeleteMapping)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);

        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - DeleteMapping.
        //
        hr = obj.DeleteMapping(vt1, vt2);
    }
    else if(i_pMethod == &METHODS::s_GetMapping)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        //
        // get in params
        //
        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
       
        //
        // call method - GetMapping.
        //
        hr = obj.GetMapping(vt1, vt2, &vt3, &vt4, &vt5, &vt6, &vt7);
        THROW_ON_ERROR(hr);

        CComPtr<IWbemClassObject> spOutParams;
        hr = CUtils::CreateEmptyMethodInstance(
            i_pNameSpace,
            i_pCtx,
            i_wszClassName,
            i_pMethod->pszMethodName,
            &spOutParams);
        THROW_ON_ERROR(hr);

        //
        // put them into the output object
        //
        hr = spOutParams->Put(PARAMS::s_vCert.pszParamName, 0, &vt3, 0);      
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_NtAcct.pszParamName, 0, &vt4, 0);
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_NtPwd.pszParamName, 0, &vt5, 0);      
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_strName.pszParamName, 0, &vt6, 0);      
        THROW_ON_ERROR(hr); 
        hr = spOutParams->Put(PARAMS::s_IEnabled.pszParamName, 0, &vt7, 0);
        THROW_ON_ERROR(hr); 

        //
        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        //
        hr = i_pHandler->Indicate(1, &spOutParams);
    }
    else if(i_pMethod == &METHODS::s_SetAcct)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
        
        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtAcct.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetAcct.
        //
        hr = obj.SetAcct(vt1, vt2, vt3.bstrVal);
    }
    else if(i_pMethod == &METHODS::s_SetEnabled)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);  
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_IEnabled.pszParamName, 0, &vt3, NULL, NULL);  
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetEnabled.
        //
        hr = obj.SetEnabled(vt1, vt2, vt3);
    }
    else if(i_pMethod == &METHODS::s_SetName)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_strName.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetName.
        //
        hr = obj.SetName(vt1, vt2, vt3.bstrVal);
    }
    else if(i_pMethod == &METHODS::s_SetPwd)
    {
        if(i_pInParams == NULL)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_METHOD_PARAMETERS);
        }

        hr = i_pInParams->Get(PARAMS::s_IMethod.pszParamName, 0, &vt1, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_vKey.pszParamName, 0, &vt2, NULL, NULL);
        THROW_ON_ERROR(hr);
        hr = i_pInParams->Get(PARAMS::s_NtPwd.pszParamName, 0, &vt3, NULL, NULL);
        THROW_ON_ERROR(hr);
      
        //
        // call method - SetPwd.
        //
        hr = obj.SetPwd(vt1, vt2, vt3.bstrVal);
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }

    THROW_ON_ERROR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\hashtable.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.h

Abstract:

    Definition of:
    CPool<T>, CStringPool, CHashTableElement<T>

    Implementation of:
    CHashTable<T>

Author:

    Mohit Srivastava            10-Nov-2000

Revision History:

--*/

#ifndef _hashtable_h_
#define _hashtable_h_

#include <lkrhash.h>

const ULONG POOL_ARRAY_SIZE         = 10;
const ULONG HASH_TABLE_POOL_SIZE    = 10;
const ULONG STRING_POOL_STRING_SIZE = 64;

//
// This is an array of pointers to arrays (aka buckets).
// -You pass the size of the first bucket to Initialize.
// -When first bucket is full, a new bucket is created
//  that is twice as big as the last one.
// -When the array itself is full, it is doubled and the
//  bucket pointers from the old array are copied.  Then
//  the old array is cleaned up.
//

template <class T> class CPool
{
public:
    CPool() : 
        m_bInitCalled(false),
        m_bInitSuccessful(false),
        m_apBuckets(NULL),
        m_iArrayPosition(0),
        m_iArraySize(0),
        m_iCurrentBucketPosition(0),
        m_iCurrentBucketSize(0),
        m_iFirstBucketSize(0) {}
    ~CPool()
    {
        for(ULONG i = 0; i < m_iArrayPosition; i++)
        {
            delete [] m_apBuckets[i];
        }
        delete [] m_apBuckets;
    }
    HRESULT Initialize(ULONG i_iFirstBucketSize);
    HRESULT GetNewElement(T** o_ppElement);
    T* Lookup(ULONG i_idx) const;
    ULONG GetUsed() const
    {
        return (GetSize() - m_iCurrentBucketSize) + m_iCurrentBucketPosition;
    }
    ULONG GetSize() const
    {
        return (2 * m_iCurrentBucketSize - m_iFirstBucketSize);
    }

private:
    //
    // Change this as necessary for best performance.
    //
    static const ULONG ARRAY_SIZE = ::POOL_ARRAY_SIZE;

    bool m_bInitCalled;
    bool m_bInitSuccessful;

    ULONG m_iCurrentBucketPosition;
    ULONG m_iCurrentBucketSize;
    ULONG m_iFirstBucketSize;

    ULONG m_iArraySize;
    ULONG m_iArrayPosition;
    T**   m_apBuckets;
};


//
// CArrayPool contains two pools.
// If a user calls GetNewArray with i <= size, then we serve request from fixedsize pool.
// If i > size, then we serve request from dynamic pool.  In this case, we need to perform
// a new since the dynamic pool is a pool of ptrs to T.
//

template <class T, ULONG size>
struct CArrayPoolEntry
{
    T m_data[size];
};

template <class T, ULONG size> class CArrayPool
{
public:
    CArrayPool() {}
    virtual ~CArrayPool()
    {
        T* pElem;
        for(ULONG i = 0; i < m_PoolDynamic.GetUsed(); i++)
        {
            pElem = *m_PoolDynamic.Lookup(i);
            delete [] pElem;
        }
    }
    HRESULT Initialize();
    HRESULT GetNewArray(ULONG i_cElem, T** o_ppElem);
    T* Lookup(ULONG i_idx) const;

protected:
    CPool< CArrayPoolEntry<T, size> >  m_PoolFixedSize;
    CPool< T * >                       m_PoolDynamic;

private:
    //
    // This is  passed to constructor of the embedded CPools.
    //
    static const FIRST_BUCKET_SIZE = 10;
};


class CStringPool: public CArrayPool<wchar_t, ::STRING_POOL_STRING_SIZE>
{
public:
    void ToConsole() const;
    HRESULT GetNewString(LPCWSTR i_wsz, LPWSTR* o_pwsz);
    HRESULT GetNewString(LPCWSTR i_wsz, ULONG i_cch, LPWSTR* o_pwsz);
};


template <class T> class CHashTableElement
{
public:
    LPWSTR                m_wszKey;
    T                     m_data;
    ULONG                 m_idx;
};

template <class T>
class CHashTable : public CTypedHashTable<CHashTable, const CHashTableElement<T>, const WCHAR*>
{
public:
    CHashTable() : CTypedHashTable<CHashTable, const CHashTableElement<T>, const WCHAR*>("n")
    {
        m_idxCur = 0;
    }

    ~CHashTable()
    {
    }

public:
    //
    // These 4 functions are callbacks and must be implemented.
    // The user of CHashTable should NOT call these explicitly.
    //
    static const WCHAR* ExtractKey(
        const CHashTableElement<T>* i_pElem)
    { 
        return i_pElem->m_wszKey;
    }
    static DWORD CalcKeyHash(
        const WCHAR* i_wszKey) 
    { 
        return HashStringNoCase(i_wszKey); 
    }
    static bool EqualKeys(
        const WCHAR* i_wszKey1,
        const WCHAR* i_wszKey2)
    { 
        return ( _wcsicmp( i_wszKey1, i_wszKey2 ) == 0 ); 
    }  
    static void AddRefRecord(
        const CHashTableElement<T>* i_pElem,
        int                         i_iIncrementAmount)
    { 
        //
        // do nothing
        //
    }

    //
    // The following functions are the functions that the user should
    // actually call.
    //
    HRESULT Wmi_Initialize()
    {
        return m_pool.Initialize(HASH_TABLE_POOL_SIZE);
    }

    HRESULT Wmi_Insert(LPWSTR i_wszKey, T i_DataNew)
    {
        DBG_ASSERT(i_wszKey != NULL);

        HRESULT    hr = WBEM_S_NO_ERROR;
        LK_RETCODE lkrc;

        CHashTableElement<T>* pElementNew;

        hr = m_pool.GetNewElement(&pElementNew);
        if(FAILED(hr))
        {
            goto exit;
        }

        pElementNew->m_data   = i_DataNew;
        pElementNew->m_wszKey = i_wszKey;
        pElementNew->m_idx    = m_idxCur;

        lkrc = InsertRecord(pElementNew);
        if(lkrc != LK_SUCCESS)
        {
            hr = Wmi_LKRToHR(lkrc);
            goto exit;
        }

    exit:
        if(SUCCEEDED(hr))
        {
            m_idxCur++;
        }
        return hr;
    }

    HRESULT Wmi_GetByKey(LPCWSTR i_wszKey, T* o_pData, ULONG *o_idx)
    {
        DBG_ASSERT(i_wszKey != NULL);
        DBG_ASSERT(o_pData  != NULL);

        *o_pData = NULL;

        HRESULT                     hr = WBEM_S_NO_ERROR;
        LK_RETCODE                  lkrc;
        const CHashTableElement<T>* pElem = NULL;

        lkrc = FindKey(i_wszKey, &pElem);
        if(lkrc != LK_SUCCESS)
        {
            hr = Wmi_LKRToHR(lkrc);
            return hr;
        }

        *o_pData = pElem->m_data;
        if(o_idx != NULL)
        {
            *o_idx = pElem->m_idx;
        }
        return hr;
    }

    HRESULT Wmi_GetByKey(LPCWSTR i_wszKey, T* o_pData)
    {
        return Wmi_GetByKey(i_wszKey, o_pData, NULL);
    }

    HRESULT Wmi_LKRToHR(LK_RETCODE i_lkrc)
    {
        if(i_lkrc == LK_SUCCESS)
        {
            return WBEM_S_NO_ERROR;
        }

        switch(i_lkrc)
        {
        case LK_ALLOC_FAIL:
            return WBEM_E_OUT_OF_MEMORY;
        default:
            return E_FAIL;
        }
    }

    ULONG Wmi_GetNumElements()
    {
        CLKRHashTableStats stats;
        stats = GetStatistics();
        DBG_ASSERT(stats.RecordCount == m_idxCur);
        return m_idxCur;
    }

private:
    CPool< CHashTableElement<T> > m_pool;
    ULONG m_idxCur;
};

//

#endif // _hashtable_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\iiscnfgp.h ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       iiscnfgp.h

   Abstract:

        Contains private Metadata IDs used internally by IIS.

   Environment:

      Win32 User Mode

--*/

#ifndef _IISCNFGP_H_
#define _IISCNFGP_H_

#include <iiscnfg.h>

#define MD_CLUSTER_ENABLED              (IIS_MD_SERVER_BASE+25 )

#define MD_CLUSTER_SERVER_COMMAND       (IIS_MD_SERVER_BASE+26 )

//
// Set by server at startup
//

#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )

typedef VOID (WINAPI * PFN_MAPPER_TOUCHED)( VOID );

#define MD_SSL_MINSTRENGTH              (IIS_MD_HTTP_BASE+30)
#define MD_SSL_ALG                      (IIS_MD_HTTP_BASE+31)
#define MD_SSL_PROTO                    (IIS_MD_HTTP_BASE+32)
#define MD_SSL_CA                       (IIS_MD_HTTP_BASE+33)

#define MD_ETAG_CHANGE_NUMBER           (IIS_MD_HTTP_BASE+39)

#define MD_AUTH_CHANGE_URL              (IIS_MD_HTTP_BASE+60 )
#define MD_AUTH_EXPIRED_URL             (IIS_MD_HTTP_BASE+61 )
#define MD_AUTH_NOTIFY_PWD_EXP_URL      (IIS_MD_HTTP_BASE+62 )
#define MD_AUTH_EXPIRED_UNSECUREURL     (IIS_MD_HTTP_BASE+67 )
#define MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL  (IIS_MD_HTTP_BASE+69 )

//
//  Account Mapping properties - these are INTERNAL ONLY and currently
//  reside under /LM/W3Svc/{instance}/<Account Mapper NSE>
//

#define MD_MAPCERT                      (IIS_MD_HTTP_BASE+78 )
#define MD_MAPNTACCT                    (IIS_MD_HTTP_BASE+79 )
#define MD_MAPNAME                      (IIS_MD_HTTP_BASE+80 )
#define MD_MAPENABLED                   (IIS_MD_HTTP_BASE+81 )
#define MD_MAPREALM                     (IIS_MD_HTTP_BASE+82 )
#define MD_MAPPWD                       (IIS_MD_HTTP_BASE+83 )
#define MD_ITACCT                       (IIS_MD_HTTP_BASE+84 )
#define MD_CPP_CERT11                   (IIS_MD_HTTP_BASE+85 )
#define MD_SERIAL_CERT11                (IIS_MD_HTTP_BASE+86 )
#define MD_CPP_CERTW                    (IIS_MD_HTTP_BASE+87 )
#define MD_SERIAL_CERTW                 (IIS_MD_HTTP_BASE+88 )
#define MD_CPP_DIGEST                   (IIS_MD_HTTP_BASE+89 )
#define MD_SERIAL_DIGEST                (IIS_MD_HTTP_BASE+90 )
#define MD_CPP_ITA                      (IIS_MD_HTTP_BASE+91 )
#define MD_SERIAL_ITA                   (IIS_MD_HTTP_BASE+92 )
#define MD_MAPNTPWD                     (IIS_MD_HTTP_BASE+93 )
#define MD_SERIAL_ISSUERS               (IIS_MD_HTTP_BASE+94 )
#define MD_NOTIFY_CERT11_TOUCHED        (IIS_MD_HTTP_BASE+96)

#define MD_NSEPM_ACCESS_ACCOUNT         (IIS_MD_HTTP_BASE+72 )
#define MD_NSEPM_ACCESS_CERT            (IIS_MD_HTTP_BASE+73 )
#define MD_NSEPM_ACCESS_NAME            (IIS_MD_HTTP_BASE+74 )
#define MD_SERIAL_ALL_CERT11            (IIS_MD_HTTP_BASE+76 )
#define MD_SERIAL_ALL_DIGEST            (IIS_MD_HTTP_BASE+77 )

#define MD_APP_LAST_OUTPROC_PID         (IIS_MD_HTTP_BASE+108)
#define MD_APP_STATE                    (IIS_MD_HTTP_BASE+109)
// Default value for MD_APP_OOP_RECOVER_LIMIT
#define APP_OOP_RECOVER_LIMIT_DEFAULT   ((DWORD)-1)

// Used by U2 to tell www admin UI that U2 authentication is installed
#define MD_U2_AUTH                      (IIS_MD_HTTP_BASE+117)

//
//  Private CAL configuration parameters
//

#define MD_CAL_MODE                     (IIS_MD_HTTP_BASE+134)
#define MD_CAL_AUTH_ERRORS              (IIS_MD_HTTP_BASE+135)
#define MD_CAL_SSL_ERRORS               (IIS_MD_HTTP_BASE+136)

#define MD_LB_REDIRECTED_HOST           (IIS_MD_HTTP_BASE+137 )
#define MD_LB_USER_AGENT_LIST           (IIS_MD_HTTP_BASE+138 )

#define MD_CERT_CHECK_MODE      (IIS_MD_HTTP_BASE+160)
#define MD_VR_ACL                       (IIS_MD_VR_BASE+4 )
//
// This is used to flag down updated vr entries - Used for migrating vroots
//

#define MD_VR_UPDATE                    (IIS_MD_VR_BASE+5 )
#define MD_SSL_FRIENDLY_NAME            ( IIS_MD_SSL_BASE+4 )
#define MD_SSL_IDENT                    ( IIS_MD_SSL_BASE+5 )
#define MD_SSL_CERT_HASH                ( IIS_MD_SSL_BASE+6 )
#define MD_SSL_CERT_CONTAINER           ( IIS_MD_SSL_BASE+7 )
#define MD_SSL_CERT_PROVIDER            ( IIS_MD_SSL_BASE+8 )
#define MD_SSL_CERT_PROVIDER_TYPE       ( IIS_MD_SSL_BASE+9 )
#define MD_SSL_CERT_OPEN_FLAGS          ( IIS_MD_SSL_BASE+10 )
#define MD_SSL_CERT_STORE_NAME          ( IIS_MD_SSL_BASE+11 )
#define MD_SSL_CTL_IDENTIFIER           ( IIS_MD_SSL_BASE+12 )
#define MD_SSL_CTL_CONTAINER            ( IIS_MD_SSL_BASE+13 )
#define MD_SSL_CTL_PROVIDER             ( IIS_MD_SSL_BASE+14 )
#define MD_SSL_CTL_PROVIDER_TYPE        ( IIS_MD_SSL_BASE+15 )
#define MD_SSL_CTL_OPEN_FLAGS           ( IIS_MD_SSL_BASE+16 )
#define MD_SSL_CTL_STORE_NAME           ( IIS_MD_SSL_BASE+17 )
#define MD_SSL_CTL_SIGNER_HASH          ( IIS_MD_SSL_BASE+18 )
//
// Metabase property that holds SSL replication information
//
#define MD_SSL_REPLICATION_INFO         ( IIS_MD_SSL_BASE+20 )
#define   MD_SSL_CERT_ENROLL_HISTORY        ( IIS_MD_SSL_BASE+31 )
#define   MD_SSL_CERT_ENROLL_TIME           ( IIS_MD_SSL_BASE+32 )
#define   MD_SSL_CERT_ENROLL_STATE          ( IIS_MD_SSL_BASE+33 )
#define   MD_SSL_CERT_ENROLL_STATE_ERROR    ( IIS_MD_SSL_BASE+34 )
#define MD_SSL_CERT_IS_FORTEZZA             ( IIS_MD_SSL_BASE+35 )
#define MD_SSL_CERT_FORTEZZA_PIN            ( IIS_MD_SSL_BASE+36 )
#define MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER  ( IIS_MD_SSL_BASE+37 )
#define MD_SSL_CERT_FORTEZZA_PERSONALITY    ( IIS_MD_SSL_BASE+38 )
#define MD_SSL_CERT_FORTEZZA_PROG_PIN       ( IIS_MD_SSL_BASE+39 )
#define MD_SSL_CERT_WIZ_DEBUG                      ( IIS_MD_SSL_BASE+50 )
#define MD_SSL_CERT_WIZHIST_SZ_TARGET_CA           ( IIS_MD_SSL_BASE+51 )
#define MD_SSL_CERT_WIZHIST_SZ_FILE_NAME_USED_LAST ( IIS_MD_SSL_BASE+52 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_COMMON_NAME      ( IIS_MD_SSL_BASE+53 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_O                ( IIS_MD_SSL_BASE+54 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_OU               ( IIS_MD_SSL_BASE+55 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_C                ( IIS_MD_SSL_BASE+56 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_L                ( IIS_MD_SSL_BASE+57 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_S                ( IIS_MD_SSL_BASE+58 )
#define MD_SSL_CERT_WIZHIST_SZ_USER_NAME           ( IIS_MD_SSL_BASE+59 )
#define MD_SSL_CERT_WIZHIST_SZ_USER_PHONE          ( IIS_MD_SSL_BASE+60 )
#define MD_SSL_CERT_WIZHIST_SZ_USER_EMAIL          ( IIS_MD_SSL_BASE+61 )

#define MD_SSL_CERT_WIZGUID_ICERTGETCONFIG         ( IIS_MD_SSL_BASE+71 )
#define MD_SSL_CERT_WIZGUID_ICERTREQUEST           ( IIS_MD_SSL_BASE+72 )
#define MD_SSL_CERT_WIZGUID_XENROLL                ( IIS_MD_SSL_BASE+73 )
#define MD_SSL_CERT_WIZGUID_ICERTCONFIG            ( IIS_MD_SSL_BASE+74 )

#define MD_SSL_CERT_WIZ_OOB_PKCS10                 ( IIS_MD_SSL_BASE+80 )
#define MD_SSL_CERT_WIZ_OOB_PKCS10_ACCEPTED        ( IIS_MD_SSL_BASE+81 )
#define MD_SSL_CERT_WIZ_OOB_TEMPCERT               ( IIS_MD_SSL_BASE+82 )
#define MD_CONTENT_NEGOTIATION          (IIS_MD_FILE_PROP_BASE+7 )
#define MD_NOTIFY_EXAUTH                (IIS_MD_FILE_PROP_BASE+40 )

//
// The following are "Virtual Properties", in that they have prop values in
// the Metabase schema, but sets map to a particular metabase property.
// For the most part these are where a DWORD property is used as a bitfield.
//

#define MD_VPROP_DIRBROW_SHOW_DATE            (IIS_MD_FILE_PROP_BASE+200 )
#define MD_VPROP_DIRBROW_SHOW_TIME            (IIS_MD_FILE_PROP_BASE+201 )
#define MD_VPROP_DIRBROW_SHOW_SIZE            (IIS_MD_FILE_PROP_BASE+202 )
#define MD_VPROP_DIRBROW_SHOW_EXTENSION       (IIS_MD_FILE_PROP_BASE+203)
#define MD_VPROP_DIRBROW_LONG_DATE            (IIS_MD_FILE_PROP_BASE+204 )

#define MD_VPROP_DIRBROW_ENABLED              (IIS_MD_FILE_PROP_BASE+205 )  // Allow directory browsing
#define MD_VPROP_DIRBROW_LOADDEFAULT          (IIS_MD_FILE_PROP_BASE+206 )  // Load default doc if exists

#define MD_VPROP_ACCESS_READ                  (IIS_MD_FILE_PROP_BASE+207 )    // Allow for Read
#define MD_VPROP_ACCESS_WRITE                 (IIS_MD_FILE_PROP_BASE+208 )    // Allow for Write
#define MD_VPROP_ACCESS_EXECUTE               (IIS_MD_FILE_PROP_BASE+209 )    // Allow for Execute
#define MD_VPROP_ACCESS_SCRIPT                (IIS_MD_FILE_PROP_BASE+211 )    // Allow for Script execution

#define MD_VPROP_ACCESS_SSL                   (IIS_MD_FILE_PROP_BASE+213 )    // Require SSL
#define MD_VPROP_ACCESS_NEGO_CERT             (IIS_MD_FILE_PROP_BASE+214 )    // Allow client SSL certs
#define MD_VPROP_ACCESS_REQUIRE_CERT          (IIS_MD_FILE_PROP_BASE+215 )    // Require client SSL certs
#define MD_VPROP_ACCESS_MAP_CERT              (IIS_MD_FILE_PROP_BASE+216 )    // Map SSL cert to NT account
#define MD_VPROP_ACCESS_SSL128                (IIS_MD_FILE_PROP_BASE+217 )    // Require 128 bit SSL

#define MD_VPROP_AUTH_ANONYMOUS               (IIS_MD_FILE_PROP_BASE+218 )
#define MD_VPROP_AUTH_BASIC                   (IIS_MD_FILE_PROP_BASE+219 )
#define MD_VPROP_AUTH_NT                      (IIS_MD_FILE_PROP_BASE+220 )    // Use NT auth provider (like NTLM)
#define MD_VPROP_AUTH_MD5                     (IIS_MD_FILE_PROP_BASE+221 )
#define MD_VPROP_AUTH_MAPBASIC                (IIS_MD_FILE_PROP_BASE+222 )

#define MD_VPROP_SERVER_CONFIG_SSL_40         (IIS_MD_FILE_PROP_BASE+223 )
#define MD_VPROP_SERVER_CONFIG_SSL_128        (IIS_MD_FILE_PROP_BASE+224 )
#define MD_VPROP_SERVER_CONFIG_ALLOW_ENCRYPT  (IIS_MD_FILE_PROP_BASE+225 )
#define MD_VPROP_SERVER_CONFIG_AUTO_PW_SYNC   (IIS_MD_FILE_PROP_BASE+226 )

#define MD_VPROP_ACCESS_NO_REMOTE_WRITE       (IIS_MD_FILE_PROP_BASE+230 )    // Local host access only
#define MD_VPROP_ACCESS_NO_REMOTE_READ        (IIS_MD_FILE_PROP_BASE+231 )    // Local host access only
#define MD_VPROP_ACCESS_NO_REMOTE_EXECUTE     (IIS_MD_FILE_PROP_BASE+232 )    // Local host access only
#define MD_VPROP_ACCESS_NO_REMOTE_SCRIPT      (IIS_MD_FILE_PROP_BASE+233 )    // Local host access only

#define MD_VPROP_EXTLOG_DATE                  (IIS_MD_FILE_PROP_BASE+234 )
#define MD_VPROP_EXTLOG_TIME                  (IIS_MD_FILE_PROP_BASE+235 )
#define MD_VPROP_EXTLOG_CLIENT_IP             (IIS_MD_FILE_PROP_BASE+236 )
#define MD_VPROP_EXTLOG_USERNAME              (IIS_MD_FILE_PROP_BASE+237 )
#define MD_VPROP_EXTLOG_SITE_NAME             (IIS_MD_FILE_PROP_BASE+238 )
#define MD_VPROP_EXTLOG_COMPUTER_NAME         (IIS_MD_FILE_PROP_BASE+239 )
#define MD_VPROP_EXTLOG_SERVER_IP             (IIS_MD_FILE_PROP_BASE+240 )
#define MD_VPROP_EXTLOG_METHOD                (IIS_MD_FILE_PROP_BASE+241 )
#define MD_VPROP_EXTLOG_URI_STEM              (IIS_MD_FILE_PROP_BASE+242 )
#define MD_VPROP_EXTLOG_URI_QUERY             (IIS_MD_FILE_PROP_BASE+243 )
#define MD_VPROP_EXTLOG_HTTP_STATUS           (IIS_MD_FILE_PROP_BASE+244 )
#define MD_VPROP_EXTLOG_WIN32_STATUS          (IIS_MD_FILE_PROP_BASE+245 )
#define MD_VPROP_EXTLOG_BYTES_SENT            (IIS_MD_FILE_PROP_BASE+246 )
#define MD_VPROP_EXTLOG_BYTES_RECV            (IIS_MD_FILE_PROP_BASE+247 )
#define MD_VPROP_EXTLOG_TIME_TAKEN            (IIS_MD_FILE_PROP_BASE+248 )
#define MD_VPROP_EXTLOG_SERVER_PORT           (IIS_MD_FILE_PROP_BASE+249 )
#define MD_VPROP_EXTLOG_USER_AGENT            (IIS_MD_FILE_PROP_BASE+250 )
#define MD_VPROP_EXTLOG_COOKIE                (IIS_MD_FILE_PROP_BASE+251 )
#define MD_VPROP_EXTLOG_REFERER               (IIS_MD_FILE_PROP_BASE+252 )

#define MD_VPROP_NOTIFY_SECURE_PORT           (IIS_MD_FILE_PROP_BASE+253 )
#define MD_VPROP_NOTIFY_NONSECURE_PORT        (IIS_MD_FILE_PROP_BASE+254 )
#define MD_VPROP_NOTIFY_READ_RAW_DATA         (IIS_MD_FILE_PROP_BASE+255 )
#define MD_VPROP_NOTIFY_PREPROC_HEADERS       (IIS_MD_FILE_PROP_BASE+256 )
#define MD_VPROP_NOTIFY_AUTHENTICATION        (IIS_MD_FILE_PROP_BASE+257 )
#define MD_VPROP_NOTIFY_URL_MAP               (IIS_MD_FILE_PROP_BASE+258 )
#define MD_VPROP_NOTIFY_ACCESS_DENIED         (IIS_MD_FILE_PROP_BASE+259 )
#define MD_VPROP_NOTIFY_SEND_RESPONSE         (IIS_MD_FILE_PROP_BASE+260 )
#define MD_VPROP_NOTIFY_SEND_RAW_DATA         (IIS_MD_FILE_PROP_BASE+261 )
#define MD_VPROP_NOTIFY_LOG                   (IIS_MD_FILE_PROP_BASE+262 )
#define MD_VPROP_NOTIFY_END_OF_REQUEST        (IIS_MD_FILE_PROP_BASE+263 )
#define MD_VPROP_NOTIFY_END_OF_NET_SESSION    (IIS_MD_FILE_PROP_BASE+264 )
#define MD_VPROP_NOTIFY_ORDER_HIGH            (IIS_MD_FILE_PROP_BASE+265 )
#define MD_VPROP_NOTIFY_ORDER_MEDIUM          (IIS_MD_FILE_PROP_BASE+266 )
#define MD_VPROP_NOTIFY_ORDER_LOW             (IIS_MD_FILE_PROP_BASE+267 )
#define MD_VPROP_EXTLOG_PROTOCOL_VERSION      (IIS_MD_FILE_PROP_BASE+268 )

#define MD_ISM_ACCESS_CHECK                   (IIS_MD_FILE_PROP_BASE+269 )

#define MD_VPROP_CPU_ENABLE_ALL_PROC_LOGGING  (IIS_MD_FILE_PROP_BASE+270 )
#define MD_VPROP_CPU_ENABLE_CGI_LOGGING       (IIS_MD_FILE_PROP_BASE+271 )
#define MD_VPROP_CPU_ENABLE_APP_LOGGING       (IIS_MD_FILE_PROP_BASE+272 )
#define MD_VPROP_CPU_ENABLE_EVENT             (IIS_MD_FILE_PROP_BASE+273 )
#define MD_VPROP_CPU_ENABLE_PROC_TYPE         (IIS_MD_FILE_PROP_BASE+274 )
#define MD_VPROP_CPU_ENABLE_USER_TIME         (IIS_MD_FILE_PROP_BASE+275 )
#define MD_VPROP_CPU_ENABLE_KERNEL_TIME       (IIS_MD_FILE_PROP_BASE+276 )
#define MD_VPROP_CPU_ENABLE_PAGE_FAULTS       (IIS_MD_FILE_PROP_BASE+277 )
#define MD_VPROP_CPU_ENABLE_TOTAL_PROCS       (IIS_MD_FILE_PROP_BASE+278 )
#define MD_VPROP_CPU_ENABLE_ACTIVE_PROCS      (IIS_MD_FILE_PROP_BASE+279 )
#define MD_VPROP_CPU_ENABLE_TERMINATED_PROCS  (IIS_MD_FILE_PROP_BASE+280 )
#define MD_VPROP_CPU_ENABLE_LOGGING           (IIS_MD_FILE_PROP_BASE+281 )
#define MD_VPROP_ACCESS_READ_SOURCE           (IIS_MD_FILE_PROP_BASE+282 )    // part of MD_ACCESS_PERM bit

#define MD_VPROP_AUTH_SINGLEREQUEST                 (IIS_MD_FILE_PROP_BASE+283 )
#define MD_VPROP_AUTH_SINGLEREQUESTIFPROXY          (IIS_MD_FILE_PROP_BASE+284 )
#define MD_VPROP_AUTH_SINGLEREQUESTALWAYSIFPROXY    (IIS_MD_FILE_PROP_BASE+285 )

//
//  The following properties are used for ADSI schema only
//

#define MD_SCHEMA_CLASS_CONTAINMENT           (IIS_MD_FILE_PROP_BASE+350 )
#define MD_SCHEMA_CLASS_CONTAINER             (IIS_MD_FILE_PROP_BASE+351 )
#define MD_SCHEMA_CLASS_CLSID                 (IIS_MD_FILE_PROP_BASE+352 )
#define MD_SCHEMA_CLASS_OID                   (IIS_MD_FILE_PROP_BASE+353 )
#define MD_SCHEMA_CLASS_PRIMARY_INTERFACE     (IIS_MD_FILE_PROP_BASE+354 )
#define MD_SCHEMA_CLASS_OPT_PROPERTIES        (IIS_MD_FILE_PROP_BASE+355 )
#define MD_SCHEMA_CLASS_MAND_PROPERTIES       (IIS_MD_FILE_PROP_BASE+356 )
#define MD_AUTH_MD5                     0x00000010
#define MD_AUTH_MAPBASIC                0x00000020
#define MD_SERVER_STATE_INVALID         ((DWORD)(-1L))

// NOTE: This value is reserved for internal use by the server,
// and cannot be set in the metabase.

#define MD_SCRIPTMAPFLAG_WILDCARD                   0x80000000

#ifdef REMOVE   // SteveBr
//
//  This flag gets ORed in by the server for *all* script maps - i.e., if an
//  entry is in the script map list, then it will never be allowed to be sent.
//  We leave the flag but make it private in case we decide to expose this
//  functionality
//

#define MD_SCRIPTMAPFLAG_NOTRANSMIT_ON_READ_DIR     0x00000002
#endif // REMOVE

//
//  Valid values for MD_CAL_MODE
//

#define MD_CAL_MODE_NONE        0
#define MD_CAL_MODE_HTTPERR     1
#define MD_CAL_MODE_LOGCOUNT    2


#endif // _IISCNFGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\ipsecurity.h ===
#ifndef _IPSecurity_h_
#define _IPSecurity_h_



#import "adsiis.tlb" no_namespace named_guids
#include <iads.h>
#include <adshlp.h>

class CIPSecurity
{
private:

    IISIPSecurity* m_pIPSec;
    IADs* m_pADs;
    BOOL bIsInherit;

public:

    CIPSecurity();
    ~CIPSecurity();

    HRESULT GetObjectAsync(
        IWbemClassObject* pObj
        ); 

    HRESULT PutObjectAsync(
        IWbemClassObject* pObj
        );

    HRESULT OpenSD(
        _bstr_t        bstrAdsPath,
        IMSAdminBase2* pAdminBase);
    void CloseSD();

private:

    HRESULT SetSD();
    HRESULT GetAdsPath(_bstr_t& bstrAdsPath);    
    HRESULT LoadBstrArrayFromVariantArray(VARIANT& i_vtVariant, VARIANT& o_vtBstr);
    HRESULT LoadVariantArrayFromBstrArray(VARIANT& i_vtBstr, VARIANT& o_vtVariant);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\metabase.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    metabase.h

Abstract:

    This file contains implementation of:
        CMetabase, CServerMethod

    CMetabase encapsulates an IMSAdminBase pointer.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _metabase_h_
#define _metabase_h_

#include <iadmw.h>
#include <comdef.h>

//
// Used by CMetabase
//
#define MAX_METABASE_PATH 1024
#define DEFAULT_TIMEOUT_VALUE 30000

//
// Period to sleep while waiting for service to attain desired state
// Used by CServerMethod
//
#define SLEEP_INTERVAL (500L)
#define MAX_SLEEP_INST (60000)       // For an instance

class CMetabase;

//
// CMetabaseCache
//

class CMetabaseCache
{
private:
    static const m_cbBufFixed = 1024;
    BYTE         m_pBufFixed[m_cbBufFixed];
    LPBYTE       m_pBufDynamic;

    LPBYTE       m_pBuf;
    DWORD        m_cbBuf;

    DWORD        m_dwNumEntries;

    METADATA_HANDLE m_hKey;

public:
    CMetabaseCache()
    {
        memset(m_pBufFixed, 0, sizeof(m_pBufFixed));
        m_pBufDynamic  = NULL;

        m_pBuf         = NULL;
        m_cbBuf        = 0;

        m_dwNumEntries = 0;

        m_hKey         = 0;
    }

    ~CMetabaseCache()
    {
        delete [] m_pBufDynamic;
        m_pBufDynamic = NULL;
        m_pBuf        = NULL;
    }

    METADATA_HANDLE GetHandle()
    {
        return m_hKey;
    }

    HRESULT Populate(
        IMSAdminBase*           i_pIABase,
        METADATA_HANDLE         i_hKey);

    HRESULT GetProp(
        DWORD                    i_dwId,
        DWORD                    i_dwUserType,
        DWORD                    i_dwDataType,
        LPBYTE*                  o_ppData,
        METADATA_GETALL_RECORD** o_ppmr) const;
};

class CMetabaseKeyList
{
public:
    CMetabaseKeyList()
    {
        InitializeListHead(&m_leHead);
    }

    ~CMetabaseKeyList()
    {
        while(!IsListEmpty(&m_leHead))
        {
            CKeyListNode* pNode = 
                CONTAINING_RECORD(m_leHead.Flink, CKeyListNode, m_leEntry);
            DBG_ASSERT(pNode != NULL);
            RemoveEntryList(&pNode->m_leEntry);
            delete pNode;
            pNode = NULL;
        }
    }

    HRESULT Add(METADATA_HANDLE i_hKey)
    {
        CKeyListNode* pNew = new CKeyListNode;
        if(pNew == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        pNew->hKey  = i_hKey;
        InsertHeadList(&m_leHead, &pNew->m_leEntry);

        return WBEM_S_NO_ERROR;
    }

    HRESULT Remove(METADATA_HANDLE i_hKey)
    {
        LIST_ENTRY* pleEntry = &m_leHead;
        while(pleEntry->Flink != pleEntry)
        {
            CKeyListNode* pNode = 
                CONTAINING_RECORD(pleEntry->Flink, CKeyListNode, m_leEntry);
            if(pNode->hKey == i_hKey)
            {
                RemoveEntryList(&pNode->m_leEntry);
                delete pNode;
                pNode = NULL;
                return WBEM_S_NO_ERROR;
            }
            pleEntry = pleEntry->Flink;
        }
        return WBEM_E_FAILED;
    }

    struct CKeyListNode
    {
        LIST_ENTRY      m_leEntry;
        METADATA_HANDLE hKey;
    };

    const LIST_ENTRY* GetHead() const { return &m_leHead; }

private:
    LIST_ENTRY    m_leHead;
};

//
// CMetabase
//

class CMetabase
{
private:

    IMSAdminBase2*    m_pIABase;
    CMetabaseKeyList  m_keyList;
    CMetabaseCache*   m_pNodeCache;

    bool CheckKeyType(
        LPCWSTR             i_wszKeyTypeCurrent,
        METABASE_KEYTYPE*&  io_pktKeyTypeSearch);

public:

    CMetabase();
    ~CMetabase();

    operator IMSAdminBase2*()
    {
        return m_pIABase;
    }

    //
    // IMSAdminBase/IMSAdminBase2 methods exposed thru WMI
    //
    HRESULT SaveData();

    HRESULT BackupWithPasswd( 
        LPCWSTR i_wszMDBackupLocation, 
        DWORD   i_dwMDVersion, 
        DWORD   i_dwMDFlags, 
        LPCWSTR i_wszPassword);

    HRESULT DeleteBackup( 
        LPCWSTR i_wszMDBackupLocation, 
        DWORD   i_dwMDVersion);

    HRESULT EnumBackups( 
        LPWSTR    io_wszMDBackupLocation, 
        DWORD*    o_pdwMDVersion, 
        PFILETIME o_pftMDBackupTime, 
        DWORD     i_dwMDEnumIndex);

    HRESULT RestoreWithPasswd( 
        LPCWSTR i_wszMDBackupLocation, 
        DWORD   i_dwMDVersion, 
        DWORD   i_dwMDFlags, 
        LPCWSTR i_wszPassword);

    HRESULT Export(
        LPCWSTR i_wszPasswd, 
        LPCWSTR i_wszFileName, 
        LPCWSTR i_wszSourcePath, 
        DWORD   i_dwMDFlags);
        
    HRESULT Import(
        LPCWSTR i_wszPasswd,
        LPCWSTR i_wszFileName,
        LPCWSTR i_wszSourcePath,
        LPCWSTR i_wszDestPath,
        DWORD   i_dwMDFlags);
        
    HRESULT RestoreHistory( 
        LPCWSTR i_wszMDHistoryLocation,
        DWORD   i_dwMDMajorVersion,
        DWORD   i_dwMDMinorVersion,
        DWORD   i_dwMDFlags);
        
    HRESULT EnumHistory( 
        LPWSTR    io_wszMDHistoryLocation,
        DWORD*    o_pdwMDMajorVersion,
        DWORD*    o_pdwMDMinorVersion,
        PFILETIME o_pftMDHistoryTime,
        DWORD     i_dwMDEnumIndex);

    //
    // Other IMSAdminBase methods
    //
    void CloseKey(METADATA_HANDLE i_hKey);
    METADATA_HANDLE OpenKey(LPCWSTR i_wszKey, BOOL i_bWrite);
    METADATA_HANDLE CreateKey(LPCWSTR i_wszKey);
    bool CheckKey(LPCWSTR i_wszKey);
    HRESULT CheckKey(LPCWSTR i_wszKey, METABASE_KEYTYPE* i_pktSearchKeyType);
    HRESULT DeleteKey(METADATA_HANDLE i_hKey, LPCWSTR i_wszKeyPath);

    //
    // Cache
    //
    void CacheInit(METADATA_HANDLE i_hKey);
    void CacheFree();

    //
    // Get Data from metabase and convert to WMI-friendly format
    //
    void Get(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetDword(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetString(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetMultiSz(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         io_vt,
        BOOL*               io_pbIsInherited,
        BOOL*               io_pbIsDefault);

    void GetBinary(
        METADATA_HANDLE    i_hKey,
        METABASE_PROPERTY* i_pmbp,
        _variant_t&        io_vt,
        BOOL*              io_pbIsInherited,
        BOOL*              io_pbIsDefault);

    //
    // Put data to metabase (converting from WMI-friendly format in the process)
    //
    void Put(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld, // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutDword(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld, // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutString(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld, // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutMultiSz(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        CWbemServices*      i_pNamespace,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld,            // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutBinary(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        _variant_t&         i_vt,
        _variant_t*         i_pvtOld,            // can be NULL
        DWORD               i_dwQuals=0,
        BOOL                i_bDoDiff=false);

    void PutMethod(
        LPWSTR          i_wszPath,
        DWORD           i_id);

    //
    // Delete from metabase
    //
    void DeleteData(
        METADATA_HANDLE     i_hKey,
        DWORD               i_dwMDIdentifier,
        DWORD               i_dwMDDataType);

    void DeleteData(
        METADATA_HANDLE     i_hKey,
        METABASE_PROPERTY*  i_pmbp,
        bool                i_bThrowOnRO);

    HRESULT EnumKeys(
        METADATA_HANDLE    i_hKey,
        LPCWSTR            i_wszMDPath,
        LPWSTR             io_wszMDName,
        DWORD*             io_pdwMDEnumKeyIndex,
        METABASE_KEYTYPE*& io_pktKeyTypeSearch,
        bool               i_bLookForMatchAtCurrentLevelOnly=false);

    HRESULT WebAppCheck(METADATA_HANDLE);
    HRESULT WebAppGetStatus(METADATA_HANDLE, PDWORD);
    HRESULT WebAppSetStatus(METADATA_HANDLE, DWORD);
};

//
// Handles the Server.{Start,Stop,Pause,Continue} methods
//
class CServerMethod
{
private:
    LPWSTR          m_wszPath; // full metabase path of loc where we will execute method
    IMSAdminBase*   m_pIABase;

    HRESULT IISGetServerState(
        METADATA_HANDLE hObjHandle,
        LPDWORD pdwState);

    HRESULT IISGetServerWin32Error(
        METADATA_HANDLE hObjHandle,
        HRESULT* phrError);

    HRESULT IISSetDword(
        METADATA_HANDLE hKey,
        DWORD dwPropId,
        DWORD dwValue);

public:
    CServerMethod()
    {
        m_wszPath = 0;
    }
    HRESULT Initialize(IMSAdminBase* i_pIABase, LPWSTR i_wszPath)
    {
        m_pIABase = i_pIABase;
        m_wszPath = new WCHAR[wcslen(i_wszPath)+1];
        if(m_wszPath == NULL)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(m_wszPath, i_wszPath);

        return S_OK;
    }
    ~CServerMethod()
    {
        delete [] m_wszPath;
    }

    HRESULT ExecMethod(DWORD dwControl);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\maindll.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    maindll.cpp

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks as well as routines that support
    self registration.

Author:

    ???

Revision History:

    Mohit Srivastava            06-Feb-01

--*/

//#include <objbase.h>
//#include <initguid.h>
#include "iisprov.h"

HMODULE g_hModule;

//
// Count number of objects and number of locks.
//
long               g_cObj=0;
long               g_cLock=0;

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp

//
// GuidGen generated GUID for the IIS WMI Provider.
// the GUID in somewhat more legible terms: {D78F1796-E03B-4a81-AFE0-B3B6B0EEE091}
//
DEFINE_GUID(CLSID_IISWbemProvider, 0xd78f1796, 0xe03b, 0x4a81, 0xaf, 0xe0, 0xb3, 0xb6, 0xb0, 0xee, 0xe0, 0x91);

//
// Debugging Stuff
//
#include "pudebug.h"
DECLARE_DEBUG_PRINTS_OBJECT()

//
// Forward declaration(s)
//
HRESULT MofCompile(TCHAR *i_tszPathMofFile, ULONG i_cch);
STDAPI  RegisterEventLog();
STDAPI  UnregisterEventLog();

//
// Entry points
//

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD ulReason, LPVOID pvReserved)
/*++

Synopsis: 
    Entry point for the DLL

Arguments: [hInstance] - 
           [ulReason] - 
           [pvReserved] - 
           
Return Value: 

--*/
{
    switch( ulReason )
    {
    case DLL_PROCESS_ATTACH:
        g_hModule = hInstance;
#ifndef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("IISWMI");
#else
        CREATE_DEBUG_PRINT_OBJECT("IISWMI");
#endif
        break;
        
    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT( );
        delete g_pDynSch;
        g_pDynSch = NULL;
        break;     
    }
    
    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
/*++

Synopsis: 
    Called by Ole when some client wants a class factory.  Return
    one only if it is the sort of class this DLL supports.

Arguments: [rclsid] - 
           [riid] - 
           [ppv] - 
           
Return Value: 

--*/
{
    HRESULT        hr   = S_OK;
    IClassFactory* pObj = NULL;

    if (CLSID_IISWbemProvider == rclsid)
    {
        pObj=new CProvFactory();

        if(NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    hr = pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
    {
        delete pObj;
        pObj = NULL;
    }

    return hr;
}

STDAPI DllCanUnloadNow(void)
/*++

Synopsis: 
    Called periodically by Ole in order to determine if the DLL can be freed.

Arguments: [void] - 
           
Return Value: 
    S_OK if there are no objects in use and the class factory isn't locked.
    S_FALSE otherwise.

--*/
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = (0L>=g_cObj && 0L>=g_cLock) ? S_OK : S_FALSE;

    return sc;
}

STDAPI DllRegisterServer(void)
/*++

Synopsis: 
    Called during setup or by regsvr32

Arguments: [void] - 
           
Return Value: 
    NOERROR if registration successful, error otherwise.

--*/
{   
    WCHAR   szID[MAX_PATH+1];
    WCHAR   wcID[MAX_PATH+1];
    WCHAR   szCLSID[MAX_PATH+1];
    WCHAR   szModule[MAX_PATH+1];
    WCHAR * pName = L"Microsoft Internet Information Server Provider";
    WCHAR * pModel = L"Both";
    HKEY hKey1, hKey2;

    // Create the path.
    StringFromGUID2(CLSID_IISWbemProvider, wcID, MAX_PATH);
    lstrcpyW(szID, wcID);
    lstrcpyW(szCLSID, L"Software\\classes\\CLSID\\");
    lstrcatW(szCLSID, szID);

    // Create entries under CLSID
    LONG lRet;
    lRet = RegCreateKeyExW(HKEY_LOCAL_MACHINE, 
                          szCLSID, 
                          0, 
                          NULL, 
                          0, 
                          KEY_ALL_ACCESS, 
                          NULL, 
                          &hKey1, 
                          NULL);
    if(lRet != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueExW(hKey1, 
                  NULL,
                  0, 
                  REG_SZ, 
                  (BYTE *)pName, 
                  lstrlenW(pName)*sizeof(WCHAR)+1);

    lRet = RegCreateKeyExW(hKey1,
                          L"InprocServer32", 
                          0, 
                          NULL, 
                          0, 
                          KEY_ALL_ACCESS, 
                          NULL, 
                          &hKey2, 
                          NULL);
        
    if(lRet != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return SELFREG_E_CLASS;
    }

    GetModuleFileNameW(g_hModule, szModule,  MAX_PATH);
    RegSetValueExW(hKey2, 
                  NULL, 
                  0, 
                  REG_SZ, 
                  (BYTE*)szModule, 
                  lstrlenW(szModule) * sizeof(WCHAR) + 1);
    RegSetValueExW(hKey2, 
                  L"ThreadingModel", 
                  0, 
                  REG_SZ, 
                  (BYTE *)pModel, 
                  lstrlenW(pModel) * sizeof(WCHAR) + 1);

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    //
    // Register other stuff
    //
    HRESULT hr = RegisterEventLog();
    if(FAILED(hr))
    {
        return hr;
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
/*++

Synopsis: 
    Called when it is time to remove the registry entries.

Arguments: [void] - 
           
Return Value: 
    NOERROR if registration successful, error otherwise.

--*/
{
    WCHAR      szID[MAX_PATH+1];
    WCHAR      wcID[MAX_PATH+1];
    WCHAR      szCLSID[MAX_PATH+1];
    HKEY       hKey;

    //
    // Create the path using the CLSID
    //
    StringFromGUID2(CLSID_IISWbemProvider, wcID, 128);
    lstrcpyW(szID, wcID);
    lstrcpyW(szCLSID, L"Software\\classes\\CLSID\\");
    lstrcatW(szCLSID, szID);

    //
    // First delete the InProcServer subkey.
    //
    LONG lRet;
    lRet = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, 
        szCLSID, 
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if(lRet == ERROR_SUCCESS)
    {
        RegDeleteKeyW(hKey, L"InProcServer32");
        RegCloseKey(hKey);
    }

    lRet = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, 
        L"Software\\classes\\CLSID",
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if(lRet == ERROR_SUCCESS)
    {
        RegDeleteKeyW(hKey,szID);
        RegCloseKey(hKey);
    }

    UnregisterEventLog();

    return S_OK;
}

STDAPI DoMofComp(void)
/*++

Synopsis: 
    Called by NT Setup to put MOF in repository.

Arguments: [void] - 
           
Return Value: 
    NOERROR if registration successful, error otherwise.

--*/
{
    ULONG     cchWinPath;
    LPCTSTR   tszSysPath = TEXT("\\system32\\wbem\\");
    ULONG     cchSysPath = _tcslen(tszSysPath);

    LPCTSTR   tszMOFs[]  = { TEXT("iiswmi.mof"), TEXT("iiswmi.mfl"), NULL };
    ULONG     idx        = 0;
    LPCTSTR   tszCurrent = NULL;
    TCHAR     tszMOFPath[_MAX_PATH];

    HRESULT hres = S_OK;

    hres = CoInitialize(NULL);
    if (FAILED(hres))
    {
        return hres;
    }

    //
    // After this block, tszMOFPath = C:\winnt, len = cchWinPath
    //
    cchWinPath = GetSystemWindowsDirectory(tszMOFPath, _MAX_PATH);
    if(cchWinPath == 0)
    {
        hres = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    if(cchWinPath > _MAX_PATH)
    {
        hres = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto exit;
    }
    if(tszMOFPath[cchWinPath-1] == TEXT('\\'))
    {
        tszMOFPath[cchWinPath-1] = TEXT('\0');
        cchWinPath--;
    }

    //
    // After this block, tszMOFPath = C:\winnt\system32\wbem\, len = cchWinPath+cchSysPath
    //
    if(cchWinPath+cchSysPath+1 > _MAX_PATH)
    {
        hres = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto exit;
    }
    memcpy(&tszMOFPath[cchWinPath], tszSysPath, sizeof(TCHAR)*(cchSysPath+1));

    //
    // Verify each file exists, and compile it.
    //
    for(idx = 0, tszCurrent = tszMOFs[0]; 
        tszCurrent != NULL; 
        tszCurrent = tszMOFs[++idx])
    {
        ULONG cchCurrent = _tcslen(tszCurrent);
        if(cchWinPath+cchSysPath+cchCurrent+1 > _MAX_PATH)
        {
            hres = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto exit;
        }
        memcpy(&tszMOFPath[cchWinPath+cchSysPath], 
               tszCurrent, 
               sizeof(TCHAR)*(cchCurrent+1));
        if (GetFileAttributes(tszMOFPath) == 0xFFFFFFFF)
        {
            hres = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        hres = MofCompile(tszMOFPath, cchWinPath+cchSysPath+cchCurrent);       
        if(FAILED(hres))
        {
            goto exit;
        }
    }

exit:
    CoUninitialize();
    return hres;
}

//
// Below this line are helper functions.
// They are not actually exported.
//

HRESULT MofCompile(TCHAR *i_tszPathMofFile, ULONG i_cch)
/*++

Synopsis: 
    NOT Exported.  Call by DoMofComp (above)

Arguments: [i_tszPathMofFile] - 
           [i_cch] - count of chars NOT including null terminator.
           
Return Value: 
    HRESULT

--*/
{
    DBG_ASSERT(i_tszPathMofFile != NULL);
    DBG_ASSERT(i_cch < _MAX_PATH);
    DBG_ASSERT(i_cch > 0);
    DBG_ASSERT(i_tszPathMofFile[i_cch] == TEXT('\0'));

    HRESULT hRes = E_FAIL;
    WCHAR wszFileName[_MAX_PATH];
    CComPtr<IMofCompiler>       spMofComp;
    WBEM_COMPILE_STATUS_INFO    Info;
  
    hRes = CoCreateInstance( CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&spMofComp);
    if (FAILED(hRes))
    {
        goto exit;
    }

    //
    // Ensure that the string is WCHAR.
    //
#if defined(UNICODE) || defined(_UNICODE)
    memcpy(wszFileName, i_tszPathMofFile, sizeof(TCHAR)*(i_cch+1));
#else
    if(MultiByteToWideChar( CP_ACP, 0, i_tszPathMofFile, -1, wszFileName, _MAX_PATH) == 0)
    {
        hres = GetLastError();
        hres = HRESULT_FROM_WIN32(hres);
        goto exit;
    }
#endif

    hRes = spMofComp->CompileFile (
                (LPWSTR) wszFileName,
                NULL,			// load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,				// no class flags
                0,              // no instance flags
                &Info);
    if(FAILED(hRes))
    {
        goto exit;
    }

exit:
	return hRes;
}

STDAPI RegisterEventLog(void)
/*++

Synopsis: 
    Sets up iiswmi.dll in the EventLog registry for resolution of NT EventLog
    message strings

Arguments: [void] - 
           
Return Value: 
    HRESULT

--*/
{
    HKEY  hk;
    WCHAR wszModuleFullPath[MAX_PATH];
    DWORD dwTypesSupported = 0;

    DWORD   dwRet;
    HRESULT hr = S_OK;

    dwRet = GetModuleFileNameW(g_hModule, wszModuleFullPath, MAX_PATH);
    if(dwRet == 0)
    {
        return SELFREG_E_CLASS;
    }

    //
    // Create the key
    //
    dwRet = RegCreateKeyW(
        HKEY_LOCAL_MACHINE,
		L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\IISWMI", &hk);
    if(dwRet != ERROR_SUCCESS)
    {
        return SELFREG_E_CLASS;
    }

    //
    // Set the "EventMessageFile" value
    //
    dwRet = RegSetValueExW(
        hk,                                            // subkey handle
        L"EventMessageFile",                           // value name
        0,                                             // must be zero
        REG_EXPAND_SZ,                                 // value type
        (LPBYTE)wszModuleFullPath,                     // address of value data
        sizeof(WCHAR)*(wcslen(wszModuleFullPath)+1) ); // length of value data
    if(dwRet != ERROR_SUCCESS)
    {
        hr = SELFREG_E_CLASS;
        goto exit;
    }

    //
    // Set the "TypesSupported" value
    //
    dwTypesSupported = 
        EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    dwRet = RegSetValueExW(
        hk,                                            // subkey handle
        L"TypesSupported",                             // value name
        0,                                             // must be zero
        REG_DWORD,                                     // value type
        (LPBYTE)&dwTypesSupported,                     // address of value data
        sizeof(DWORD) );                               // length of value data
    if(dwRet != ERROR_SUCCESS)
    {
        hr = SELFREG_E_CLASS;
        goto exit;
    }

exit:
    RegCloseKey(hk);
    return hr;
}

STDAPI UnregisterEventLog(void)
/*++

Synopsis: 
    Called by DllUnregisterServer.
    Called when it is time to remove the registry entries for event logging.

Arguments: [void] - 
           
Return Value: 
    HRESULT

--*/
{
    //
    // Delete the key
    //
    RegDeleteKeyW(
        HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\IISWMI");

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszdata.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzHelper.h

Abstract:

    Defines the TFormattedMultiSz datatype.

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#ifndef _multiszdata_h_
#define _multiszdata_h_

#include <windows.h>
#include <dbgutil.h>

//
// Max Number of fields in a MultiSz
// For example, apServerBindings has 3: IP, Port, Hostname
//
static const ULONG MAX_FIELDS = 10;

struct TFormattedMultiSz
{
    DWORD        dwPropId;
    LPWSTR       wszWmiClassName;
    WCHAR        wcDelim;
    LPCWSTR*     awszFields;
};

//
// Used as the astrFields parameter of TFormattedMultiSz
//
struct TFormattedMultiSzFields
{
    static LPCWSTR             apCustomErrorDescriptions[];
    static LPCWSTR             apHttpCustomHeaders[];
    static LPCWSTR             apHttpErrors[];
    static LPCWSTR             apScriptMaps[];
    static LPCWSTR             apSecureBindings[];
    static LPCWSTR             apServerBindings[];
    static LPCWSTR             apMimeMaps[];
};

//
// Collection of TFormmatedMultiSz's
//
struct TFormattedMultiSzData
{
    static TFormattedMultiSz   CustomErrorDescriptions;
    static TFormattedMultiSz   HttpCustomHeaders;
    static TFormattedMultiSz   HttpErrors;
    static TFormattedMultiSz   ScriptMaps;
    static TFormattedMultiSz   SecureBindings;
    static TFormattedMultiSz   ServerBindings;
    static TFormattedMultiSz   MimeMaps;

    static TFormattedMultiSz*  apFormattedMultiSz[];

    static TFormattedMultiSz*  Find(ULONG i_dwPropId)
    {
        DBG_ASSERT(apFormattedMultiSz != NULL);
        for(ULONG i = 0; apFormattedMultiSz[i] != NULL; i++)
        {
            if(i_dwPropId == apFormattedMultiSz[i]->dwPropId)
            {
                return apFormattedMultiSz[i];
            }
        }

        return NULL;
    }
};

#endif  // _multiszdata_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\ipsecurity.cpp ===
//***************************************************************************
//
//  IPSecurity.cpp
//
//  Module: WBEM Instance provider
//
//  Purpose: IIS IPSecurity class 
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "iisprov.h"
#include "ipsecurity.h"

#define DEFAULT_TIMEOUT_VALUE 30000
#define BUFFER_SIZE 512

CIPSecurity::CIPSecurity()
{
    m_pADs = NULL;
    m_pIPSec = NULL;
    bIsInherit = FALSE;
}


CIPSecurity::~CIPSecurity()
{
    CloseSD();
}


void CIPSecurity::CloseSD()
{
    if(m_pIPSec)
    {
        m_pIPSec->Release();
        m_pIPSec = NULL;
    }

    if(m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }
}


HRESULT CIPSecurity::GetObjectAsync(
    IWbemClassObject* pObj
    )
{
    VARIANT vt;
    VARIANT vtBstrArray;
    HRESULT hr;

    VARIANT vtTrue;
    vtTrue.boolVal = VARIANT_TRUE;
    vtTrue.vt      = VT_BOOL;

    // IPDeny
    hr = m_pIPSec->get_IPDeny(&vt);
    if(SUCCEEDED(hr))
    {
        hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
        VariantClear(&vt);

        if(SUCCEEDED(hr))
        {
            hr = pObj->Put(L"IPDeny", 0, &vtBstrArray, 0);
            VariantClear(&vtBstrArray);
        }

        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"IPDeny", &g_wszIsInherit, &vtTrue, 1);
        }
    }

    // IPGrant
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_IPGrant(&vt);

        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"IPGrant", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }    
 
            if(bIsInherit && SUCCEEDED(hr))
            {
                hr = CUtils::SetPropertyQualifiers(
                    pObj, L"IPGrant", &g_wszIsInherit, &vtTrue, 1);
            }
        }
    }

    // DomainDeny
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_DomainDeny(&vt);

        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"DomainDeny", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }

            if(bIsInherit && SUCCEEDED(hr))
            {
                hr = CUtils::SetPropertyQualifiers(
                    pObj, L"DomainDeny", &g_wszIsInherit, &vtTrue, 1);
            }
        }
    }

    // DomainGrant
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_DomainGrant(&vt);
    
        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"DomainGrant", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }

            if(bIsInherit && SUCCEEDED(hr))
            {
                hr = CUtils::SetPropertyQualifiers(
                    pObj, L"DomainGrant", &g_wszIsInherit, &vtTrue, 1);
            }
        }   
    }

    // GrantByDefault
    if(SUCCEEDED(hr))
        hr = m_pIPSec->get_GrantByDefault(&vt.boolVal);
    if(SUCCEEDED(hr))
    {
        vt.vt = VT_BOOL;
        hr = pObj->Put(L"GrantByDefault", 0, &vt, 0);
        
        if(bIsInherit && SUCCEEDED(hr))
        {
            hr = CUtils::SetPropertyQualifiers(
                pObj, L"GrantByDefault", &g_wszIsInherit, &vtTrue, 1);
        }
    }

    return hr;
}

// Convert SAFEARRAY of BSTRs to SAFEARRAY of VARIANTs
HRESULT CIPSecurity::LoadVariantArrayFromBstrArray(
    VARIANT&    i_vtBstr,
    VARIANT&    o_vtVariant)
{
    SAFEARRAYBOUND  aDim;
    SAFEARRAY*      pBstrArray = NULL;
    SAFEARRAY*      pVarArray = NULL;
    BSTR*           paBstr = NULL;
    VARIANT         vt;
    LONG            i=0;
    HRESULT         hr = ERROR_SUCCESS;

    try
    {
        // Verify that the input VARIANT is a BSTR array or NULL.
        if (i_vtBstr.vt != (VT_ARRAY | VT_BSTR) &&
            i_vtBstr.vt != VT_NULL) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Initialize the output VARIANT (Set type to VT_EMPTY)
        VariantInit(&o_vtVariant);

        // Handle the case when there is no input array
        if (i_vtBstr.vt == VT_NULL) {
            aDim.lLbound = 0;
            aDim.cElements = 0;
        }
        else {
            // Verify that the input VARIANT contains a SAFEARRAY
            pBstrArray = i_vtBstr.parray;
            if (pBstrArray == NULL) {
                hr = WBEM_E_INVALID_PARAMETER;
                THROW_ON_ERROR(hr);
            }

            // Get the size of the BSTR SAFEARRAY.
            aDim.lLbound = 0;
            aDim.cElements = pBstrArray->rgsabound[0].cElements;
        }

        // Create the new VARIANT SAFEARRAY
        pVarArray = SafeArrayCreate(VT_VARIANT, 1, &aDim);
        if (pVarArray == NULL) {
            hr = E_OUTOFMEMORY;
            THROW_ON_ERROR(hr);
        }

        // Put the new VARIANT SAFEARRAY into our output VARIANT
        o_vtVariant.vt = VT_ARRAY | VT_VARIANT;
        o_vtVariant.parray = pVarArray;

        if(aDim.cElements > 0) {
            // Get the BSTR SAFEARRAY pointer.
            hr = SafeArrayAccessData(pBstrArray, (void**)&paBstr);
            THROW_ON_ERROR(hr);

            // Copy all the BSTRS to VARIANTS
            VariantInit(&vt);
            vt.vt = VT_BSTR;
            for(i = aDim.lLbound; i < (long) aDim.cElements; i++)
            {
                vt.bstrVal = SysAllocString(paBstr[i]);
                if (vt.bstrVal == NULL) {
                    hr = E_OUTOFMEMORY;
                    THROW_ON_ERROR(hr);
                }
                hr = SafeArrayPutElement(pVarArray, &i, &vt);
                VariantClear(&vt);
                THROW_ON_ERROR(hr);
            }

            hr = SafeArrayUnaccessData(pBstrArray);
            THROW_ON_ERROR(hr);
        }
    }
    catch(...)
    {
        // Destroy the VARIANT, the contained SAFEARRAY and the VARIANTs in the SAFEARRAY.
        // It also free the BSTRS contained in the VARIANTs
        VariantClear(&o_vtVariant);
    }
    return hr;
}

HRESULT CIPSecurity::LoadBstrArrayFromVariantArray(
    VARIANT&    i_vtVariant,
    VARIANT&    o_vtBstr
    )
{
    SAFEARRAYBOUND  aDim;
    SAFEARRAY*      pVarArray = NULL;
    SAFEARRAY*      pBstrArray = NULL;
    VARIANT*        paVar = NULL;
    BSTR            bstr = NULL;
    LONG            i = 0;
    HRESULT         hr = ERROR_SUCCESS;

    try 
    {
        // Verify the Variant array.
        if (i_vtVariant.vt != (VT_ARRAY | VT_VARIANT)) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Verify that the variant contains a safearray.
        pVarArray = i_vtVariant.parray;
        if (pVarArray == NULL) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Initialize the out paramter.
        VariantInit(&o_vtBstr);

        // Get the size of the array.
        aDim.lLbound = 0;
        aDim.cElements = pVarArray->rgsabound[0].cElements;

        // Create the new BSTR array
        pBstrArray = SafeArrayCreate(VT_BSTR, 1, &aDim);
        if (pBstrArray == NULL) {
            hr = E_OUTOFMEMORY;
            THROW_ON_ERROR(hr);
        }

        // Put the array into the variant.
        o_vtBstr.vt = VT_ARRAY | VT_BSTR;
        o_vtBstr.parray = pBstrArray;

        // Get the variant array pointer.
        hr = SafeArrayAccessData(pVarArray, (void**)&paVar);
        THROW_ON_ERROR(hr);

        // Copy all the bstrs.
        for (i = aDim.lLbound; i < (long) aDim.cElements; i++)
        {
            if (paVar[i].vt != VT_BSTR) {
                hr = WBEM_E_FAILED;
                THROW_ON_ERROR(hr);
            }
            bstr = SysAllocString(paVar[i].bstrVal);
            if (bstr == NULL) {
                hr = E_OUTOFMEMORY;
                THROW_ON_ERROR(hr);
            }
            hr = SafeArrayPutElement(pBstrArray, &i, bstr);
            SysFreeString(bstr);
            bstr = NULL;
            THROW_ON_ERROR(hr);
        }

        hr = SafeArrayUnaccessData(pVarArray);
        THROW_ON_ERROR(hr);
    }
    catch (...)
    {
        // Destroy the variant, the safearray and the bstr's in the array.
        VariantClear(&o_vtBstr);
    }

    return hr;
}



HRESULT CIPSecurity::PutObjectAsync(
    IWbemClassObject* pObj
    )
{
    VARIANT vt;
    VARIANT vtVarArray;
    HRESULT hr;

    // IPDeny
    hr = pObj->Get(L"IPDeny", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr)) {
        hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
        VariantClear(&vt);
    
        if(SUCCEEDED(hr)) {
            hr = m_pIPSec->put_IPDeny(vtVarArray);
            VariantClear(&vtVarArray);
        }
    }

    // IPGrant
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"IPGrant", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_IPGrant(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // DomainDeny
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"DomainDeny", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_DomainDeny(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // DomainGrant
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"DomainGrant", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_DomainGrant(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // GrantByDefault
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"GrantByDefault", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr))
        hr = m_pIPSec->put_GrantByDefault(vt.boolVal); 
    VariantClear(&vt);

    // set the modified IPSecurity back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}


HRESULT CIPSecurity::OpenSD(
    _bstr_t        bstrAdsPath,
    IMSAdminBase2* pAdminBase)
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    BYTE pBuffer[BUFFER_SIZE];
    _bstr_t oldPath;

    try
    {    // close SD interface first
        CloseSD();

        oldPath = bstrAdsPath.copy();

        hr = GetAdsPath(bstrAdsPath);
        if(FAILED(hr))
           return hr;

        // get m_pADs
        hr = ADsGetObject(
             bstrAdsPath,
             IID_IADs,
             (void**)&m_pADs
             );
        if(FAILED(hr))
            return hr;
     
        // get m_pSD
        hr = m_pADs->Get(L"IPSecurity",&var);
        if(FAILED(hr))
            return hr;  
    
        hr = V_DISPATCH(&var)->QueryInterface(
            IID_IISIPSecurity,
            (void**)&m_pIPSec
            );
        if(FAILED(hr))
            return hr;

        // set bIsInherit

        hr = pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                oldPath,
                METADATA_PERMISSION_READ,
                DEFAULT_TIMEOUT_VALUE,
                &hObjHandle
                );
        if(FAILED(hr))
            return hr;

        MD_SET_DATA_RECORD(&mdrMDData,
                       MD_IP_SEC,  // ID for "IPSecurity"
                       METADATA_INHERIT | METADATA_ISINHERITED,
                       ALL_METADATA,
                       ALL_METADATA,
                       BUFFER_SIZE,
                       pBuffer);
    
        hr = pAdminBase->GetData(
                hObjHandle,
                L"",
                &mdrMDData,
                &dwBufferSize
                );

        hr = S_OK;

        bIsInherit = mdrMDData.dwMDAttributes & METADATA_ISINHERITED;

    }
    catch(...)
    {
        hr = E_FAIL;
    }

    if (hObjHandle && pAdminBase) {
        pAdminBase->CloseKey(hObjHandle);
    }

    return hr;
}


HRESULT CIPSecurity::SetSD()
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;

    try
    {
        // put IPSecurity
        hr = m_pIPSec->QueryInterface(
            IID_IDispatch,
            (void**)&pDisp
            );
        if(FAILED(hr))
           return hr;

        var.vt = VT_DISPATCH;
        var.pdispVal = pDisp;
        hr = m_pADs->Put(L"IPSecurity",var);  // pDisp will be released by this call Put().
        if(FAILED(hr))
           return hr;

        // Commit the change to the active directory
        hr = m_pADs->SetInfo();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CIPSecurity::GetAdsPath(_bstr_t& bstrAdsPath)
{
    DBG_ASSERT(((LPWSTR)bstrAdsPath) != NULL);

    WCHAR* p = new WCHAR[bstrAdsPath.length() + 1];
    if(p == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(p, bstrAdsPath);

    try
    {
        bstrAdsPath = L"IIS://LocalHost";

        // trim first three charaters "/LM" 
        bstrAdsPath += (p+3);
    }
    catch(_com_error e)
    {
        delete [] p;
        return e.Error();
    }

    delete [] p;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\metabase.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    metabase.cpp

Abstract:

    This file contains implementation of:
        CMetabase, CServerMethod

    CMetabase encapsulates an IMSAdminBase pointer.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/


#include "iisprov.h"
#include "MultiSzHelper.h"

extern CDynSchema* g_pDynSch;

//
// CMetabaseCache
//
HRESULT CMetabaseCache::Populate(
    IMSAdminBase*   i_pIABase,
    METADATA_HANDLE i_hKey)
{
    DBG_ASSERT(i_pIABase);
    DBG_ASSERT(m_pBuf == NULL); // only call populate once

    DWORD dwDataSetNumber      = 0;
    DWORD dwRequiredBufSize    = 0;

    HRESULT hr                 = WBEM_S_NO_ERROR;

    m_pBuf  = m_pBufFixed;
    m_cbBuf = m_cbBufFixed;
    hr = i_pIABase->GetAllData(
        i_hKey,
        NULL,
        METADATA_INHERIT | METADATA_ISINHERITED,
        ALL_METADATA,
        ALL_METADATA,
        &m_dwNumEntries,
        &dwDataSetNumber,
        m_cbBuf,
        m_pBuf,
        &dwRequiredBufSize);
    if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        m_pBufDynamic = new BYTE[dwRequiredBufSize];
        if(m_pBufDynamic == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        m_pBuf  = m_pBufDynamic;
        m_cbBuf = dwRequiredBufSize;
        hr = i_pIABase->GetAllData(
            i_hKey,
            NULL,
            METADATA_INHERIT | METADATA_ISINHERITED,
            ALL_METADATA,
            ALL_METADATA,
            &m_dwNumEntries,
            &dwDataSetNumber,
            m_cbBuf,
            m_pBuf,
            &dwRequiredBufSize);
        if(FAILED(hr))
        {
            DBG_ASSERT(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
            goto exit;
        }
    }
    else if(FAILED(hr))
    {
        goto exit;
    }

    //
    // If we are here, we have a valid data buffer
    //
    m_hKey = i_hKey;

exit:
    if(FAILED(hr))
    {
        m_pBuf  = NULL;
        m_cbBuf = 0;
    }
    return hr;
}

HRESULT CMetabaseCache::GetProp(
    DWORD                          i_dwId,
    DWORD                          i_dwUserType,
    DWORD                          i_dwDataType,
    LPBYTE*                        o_ppData,
    METADATA_GETALL_RECORD**       o_ppmr) const
{
    DBG_ASSERT(o_ppmr   != NULL);
    DBG_ASSERT(o_ppData != NULL);

    *o_ppmr   = NULL;
    *o_ppData = NULL;

    if(m_pBuf == NULL)
    {
        return MD_ERROR_DATA_NOT_FOUND;
    }

    for(ULONG i = 0; i < m_dwNumEntries; i++)
    {
        METADATA_GETALL_RECORD* pmr = ((METADATA_GETALL_RECORD*)m_pBuf) + i;
        if( i_dwId       == pmr->dwMDIdentifier &&
            i_dwUserType == pmr->dwMDUserType &&
            i_dwDataType == pmr->dwMDDataType)
        {
            *o_ppmr   = pmr;
            *o_ppData = m_pBuf + pmr->dwMDDataOffset;
            return S_OK;
        }
    }

    return MD_ERROR_DATA_NOT_FOUND;
}

//
// CMetabase
//

CMetabase::CMetabase()
{
    m_pNodeCache = NULL;
    HRESULT hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase2,
        (void**)&m_pIABase
        );

    THROW_ON_ERROR(hr);
}

CMetabase::~CMetabase()
{
    CacheFree();

    const LIST_ENTRY* ple = m_keyList.GetHead()->Flink;
    while(ple != m_keyList.GetHead())
    {
        const CMetabaseKeyList::CKeyListNode* pNode = 
            CONTAINING_RECORD(ple, CMetabaseKeyList::CKeyListNode, m_leEntry);
        DBG_ASSERT(pNode);
        ple = ple->Flink;
        CloseKey(pNode->hKey);
    }

    if(m_pIABase)
        m_pIABase->Release();
}


HRESULT CMetabase::SaveData()
{
    HRESULT hr = m_pIABase->SaveData();
    return hr;
}


HRESULT CMetabase::BackupWithPasswd( 
    LPCWSTR i_wszMDBackupLocation, 
    DWORD   i_dwMDVersion, 
    DWORD   i_dwMDFlags, 
    LPCWSTR i_wszPassword 
    )
{
    HRESULT hr;
    hr = m_pIABase->BackupWithPasswd(
        i_wszMDBackupLocation, 
        i_dwMDVersion,
        i_dwMDFlags,
        i_wszPassword);
    return hr;
}

HRESULT CMetabase::DeleteBackup( 
    LPCWSTR i_wszMDBackupLocation, 
    DWORD   i_dwMDVersion 
    )
{
    HRESULT hr;
    hr = m_pIABase->DeleteBackup(
        i_wszMDBackupLocation, 
        i_dwMDVersion
        );

    return hr;
}

HRESULT CMetabase::EnumBackups( 
    LPWSTR    io_wszMDBackupLocation, 
    DWORD*    o_pdwMDVersion, 
    PFILETIME o_pftMDBackupTime, 
    DWORD     i_dwMDEnumIndex 
    )
{
    HRESULT hr;
    hr = m_pIABase->EnumBackups(
        io_wszMDBackupLocation, 
        o_pdwMDVersion,
        o_pftMDBackupTime,
        i_dwMDEnumIndex
        );

    return hr;
}

HRESULT CMetabase::RestoreWithPasswd( 
    LPCWSTR i_wszMDBackupLocation, 
    DWORD   i_dwMDVersion, 
    DWORD   i_dwMDFlags, 
    LPCWSTR i_wszPassword 
    )
{
    HRESULT hr;
    hr = m_pIABase->RestoreWithPasswd(
        i_wszMDBackupLocation, 
        i_dwMDVersion,
        i_dwMDFlags,
        i_wszPassword);
    return hr;
}

HRESULT CMetabase::Export( 
    LPCWSTR i_wszPasswd,
    LPCWSTR i_wszFileName,
    LPCWSTR i_wszSourcePath,
    DWORD   i_dwMDFlags)
{
    HRESULT hr;
    hr = m_pIABase->Export(
        i_wszPasswd, 
        i_wszFileName,
        i_wszSourcePath,
        i_dwMDFlags);
    return hr;
}

HRESULT CMetabase::Import( 
    LPCWSTR i_wszPasswd,
    LPCWSTR i_wszFileName,
    LPCWSTR i_wszSourcePath,
    LPCWSTR i_wszDestPath,
    DWORD   i_dwMDFlags)
{
    HRESULT hr;
    hr = m_pIABase->Import(
        i_wszPasswd, 
        i_wszFileName,
        i_wszSourcePath,
        i_wszDestPath,
        i_dwMDFlags);
    return hr;
}

HRESULT CMetabase::RestoreHistory( 
    LPCWSTR i_wszMDHistoryLocation,
    DWORD   i_dwMDMajorVersion,
    DWORD   i_dwMDMinorVersion,
    DWORD   i_dwMDFlags)
{
    HRESULT hr;
    hr = m_pIABase->RestoreHistory(
        i_wszMDHistoryLocation, 
        i_dwMDMajorVersion,
        i_dwMDMinorVersion,
        i_dwMDFlags);
    return hr;
}

HRESULT CMetabase::EnumHistory( 
    LPWSTR    io_wszMDHistoryLocation,
    DWORD*    o_pdwMDMajorVersion,
    DWORD*    o_pdwMDMinorVersion,
    PFILETIME o_pftMDHistoryTime,
    DWORD     i_dwMDEnumIndex)
{
    HRESULT hr;
    hr = m_pIABase->EnumHistory(
        io_wszMDHistoryLocation, 
        o_pdwMDMajorVersion,
        o_pdwMDMinorVersion,
        o_pftMDHistoryTime,
        i_dwMDEnumIndex);
    return hr;
}
 
void CMetabase::CloseKey(METADATA_HANDLE i_hKey)
{
    m_keyList.Remove(i_hKey);
    if(i_hKey && m_pIABase)
    {
        m_pIABase->CloseKey(i_hKey);
        DBGPRINTF((DBG_CONTEXT, "Close Key: %x\n", i_hKey));
    }
}

METADATA_HANDLE CMetabase::OpenKey(LPCWSTR i_wszKey, BOOL i_bWrite)
{
    METADATA_HANDLE hKey = NULL;

    DWORD dwMDAccessRequested;
    if(i_bWrite)
        dwMDAccessRequested = METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE;
    else
        dwMDAccessRequested = METADATA_PERMISSION_READ;
   
    HRESULT hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        dwMDAccessRequested,
        DEFAULT_TIMEOUT_VALUE,         // 30 seconds
        &hKey 
        );

    THROW_ON_ERROR(hr);

    hr = m_keyList.Add(hKey);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        THROW_ON_ERROR(hr);
    }

    DBGPRINTF((DBG_CONTEXT, "Open Key on %ws, returned handle %x\n", i_wszKey, hKey));
    return hKey;
}

//
// force to create or open a key by read/write permision
//
METADATA_HANDLE CMetabase::CreateKey(LPCWSTR i_wszKey)
{
    HRESULT hr;
    METADATA_HANDLE hKey;

    // open and return key if exists
    hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        DEFAULT_TIMEOUT_VALUE,       // 30 seconds
        &hKey
        );

    if(FAILED(hr)) 
    {
        //  create key if not there
        hr = m_pIABase->OpenKey( 
            METADATA_MASTER_ROOT_HANDLE,
            NULL,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            DEFAULT_TIMEOUT_VALUE,       // 30 seconds
            &hKey
            );
        THROW_ON_ERROR(hr);

        // add key
        hr = m_pIABase->AddKey(hKey, i_wszKey);

        // close this root key first
        m_pIABase->CloseKey(hKey);
        THROW_ON_ERROR(hr);

        // now open the key just created
        hr = m_pIABase->OpenKey( 
            METADATA_MASTER_ROOT_HANDLE,
            i_wszKey,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            DEFAULT_TIMEOUT_VALUE,    // 30 seconds
            &hKey 
            );
    
        THROW_ON_ERROR(hr);
    }

    hr = m_keyList.Add(hKey);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        THROW_ON_ERROR(hr);
    }

    DBGPRINTF((DBG_CONTEXT, "Create Key on %ws, returned handle %x\n", i_wszKey, hKey));
    return hKey;
}

//
// Check if the key is existed
//
bool CMetabase::CheckKey(LPCWSTR i_wszKey)
{
    METADATA_HANDLE hKey = NULL;

    HRESULT hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        METADATA_PERMISSION_READ,
        DEFAULT_TIMEOUT_VALUE,       // 30 seconds
        &hKey 
        );
    
    if(hr == ERROR_SUCCESS)  
    {
        DBGPRINTF((DBG_CONTEXT, "Open Key on %ws, returned handle %x\n", i_wszKey, hKey));
        CloseKey(hKey);
    }
    
    return (hr == ERROR_PATH_BUSY) || (hr == ERROR_SUCCESS) ? true : false;
}

//
// Check if the key is existed
//
HRESULT CMetabase::CheckKey(
    LPCWSTR           i_wszKey,
    METABASE_KEYTYPE* i_pktSearchKeyType)
{
    WCHAR wszBuf[MAX_BUF_SIZE];
    METADATA_RECORD mr = {
        MD_KEY_TYPE, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        STRING_METADATA,
        MAX_BUF_SIZE*sizeof(WCHAR),
        (unsigned char*)wszBuf,
        0    
        };

    DWORD dwLen;
    HRESULT hr = m_pIABase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        i_wszKey,
        &mr,
        &dwLen);
    if( hr == MD_ERROR_DATA_NOT_FOUND &&
        METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue )
    {
        mr.pbMDData = (LPBYTE)METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue;
        hr = S_OK;
    }
    else if(FAILED(hr))
    {
        return hr;
    }

    if( i_pktSearchKeyType && 
        CUtils::CompareKeyType((LPCWSTR)mr.pbMDData, i_pktSearchKeyType) )
    {
        return S_OK;
    }

    return MD_ERROR_DATA_NOT_FOUND;
}

HRESULT CMetabase::DeleteKey(
    METADATA_HANDLE  i_hKey,
    LPCWSTR          i_wszKeyPath)
{
    return m_pIABase->DeleteKey( 
        i_hKey,
        i_wszKeyPath
        );
}

void CMetabase::CacheInit(
    METADATA_HANDLE i_hKey)
{
    HRESULT hr = S_OK;
    delete m_pNodeCache;
    m_pNodeCache = new CMetabaseCache();
    if(m_pNodeCache == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }
    
    hr = m_pNodeCache->Populate(
        m_pIABase,
        i_hKey);
    THROW_ON_ERROR(hr);
}

void CMetabase::CacheFree()
{
    delete m_pNodeCache;
    m_pNodeCache = NULL;
}

void CMetabase::Get(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    switch (i_pmbp->dwMDDataType) 
    {
    case DWORD_METADATA:
        GetDword(i_hKey, i_pmbp, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    case EXPANDSZ_METADATA:
    case STRING_METADATA:
        GetString(i_hKey, i_pmbp, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    case MULTISZ_METADATA:
        GetMultiSz(i_hKey, i_pmbp, i_pNamespace, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    case BINARY_METADATA:
        GetBinary(i_hKey, i_pmbp, io_vt, io_pbIsInherited, io_pbIsDefault);
        break;

    default:        
        DBGPRINTF((DBG_CONTEXT,
            "[CMetabase::Get] Cannot retrieve %ws because type %u is unknown\n",
            i_pmbp->pszPropName,
            i_pmbp->dwMDDataType));
        break;
    }
}

//
// GetDword 
//
// A long or bool is returned in the VARIANT.  The value is a bool if the
// METABASE_PROPERTY has a mask otherwise the DWORD is returned as a long.
// The METADATA_HANDLE is expected to be valid and open.
//
void CMetabase::GetDword(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DWORD    dw    = 0;
    DWORD    dwRet = 0;
    HRESULT  hr    = WBEM_S_NO_ERROR;

    BOOL     bIsInherited = false;
    BOOL     bIsDefault   = false;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    METADATA_RECORD mr = {
        i_pmbp->dwMDIdentifier, 
        i_pmbp->dwMDAttributes | METADATA_ISINHERITED,
        i_pmbp->dwMDUserType,
        i_pmbp->dwMDDataType,
        sizeof(DWORD),
        (unsigned char*)&dw,
        0
        };

    if(m_pNodeCache && m_pNodeCache->GetHandle() == i_hKey)
    {
        METADATA_GETALL_RECORD* pmr = NULL;
        hr = m_pNodeCache->GetProp(
            i_pmbp->dwMDIdentifier,
            i_pmbp->dwMDUserType,
            i_pmbp->dwMDDataType,
            &mr.pbMDData,
            &pmr);
        if(SUCCEEDED(hr))
        {
            DBG_ASSERT(pmr);
            mr.dwMDAttributes = pmr->dwMDAttributes;
            dw                = *((DWORD*)mr.pbMDData);
        }
    }
    else
    {
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    }

    //
    // Set out parameters
    //
    if (hr == MD_ERROR_DATA_NOT_FOUND)
    {
        bIsInherited = false;
        if(i_pmbp->pDefaultValue == NULL)
        {
            io_vt.vt        = VT_NULL;
            bIsDefault      = false;
        }
        else
        {
            if(i_pmbp->dwMDMask)
            {
                io_vt.vt      = VT_BOOL;
                io_vt.boolVal = (i_pmbp->dwDefaultValue & i_pmbp->dwMDMask ? -1 : 0);
            }
            else
            {
                io_vt.vt    = VT_I4;
                io_vt.lVal  = i_pmbp->dwDefaultValue;
            }
            bIsDefault      = true;
        }
    }
    else
    {
        THROW_E_ON_ERROR(hr,i_pmbp);
        if (i_pmbp->dwMDMask) 
        {
            io_vt.vt      = VT_BOOL;
            io_vt.boolVal = (dw & i_pmbp->dwMDMask? -1 : 0);
        }
        else 
        {
            io_vt.vt      = VT_I4;
            io_vt.lVal    = dw;
        }
        bIsDefault        = false;
        bIsInherited      = mr.dwMDAttributes & METADATA_ISINHERITED;
    }

    if(io_pbIsInherited != NULL)
    {
        *io_pbIsInherited = bIsInherited;
    }
    if(io_pbIsDefault != NULL)
    {
        *io_pbIsDefault = bIsDefault;
    }
}


//
// GetStringFromMetabase 
//
void CMetabase::GetString(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DWORD    dwRet;
    HRESULT  hr;
    WCHAR    wszBufStack[MAX_BUF_SIZE];

    BOOL     bIsDefault   = false;
    BOOL     bIsInherited = false;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    METADATA_RECORD mr = {
        i_pmbp->dwMDIdentifier, 
        i_pmbp->dwMDAttributes | METADATA_ISINHERITED,
        i_pmbp->dwMDUserType,
        i_pmbp->dwMDDataType,
        MAX_BUF_SIZE*sizeof(WCHAR),
        (LPBYTE)wszBufStack,
        0
        };

    if(m_pNodeCache && m_pNodeCache->GetHandle() == i_hKey)
    {
        METADATA_GETALL_RECORD* pmr = NULL;
        hr = m_pNodeCache->GetProp(
            i_pmbp->dwMDIdentifier,
            i_pmbp->dwMDUserType,
            i_pmbp->dwMDDataType,
            &mr.pbMDData,
            &pmr);
        if(SUCCEEDED(hr))
        {
            DBG_ASSERT(pmr);
            mr.dwMDAttributes = pmr->dwMDAttributes;
        }
    }
    else
    {
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    }

    //
    // Set out parameters.
    //
    if (hr == MD_ERROR_DATA_NOT_FOUND) 
    {
        bIsInherited = false;
        if(i_pmbp->pDefaultValue == NULL)
        {
            io_vt.vt   = VT_NULL;
            bIsDefault = false;
        }
        else
        {
            io_vt      = (LPWSTR)i_pmbp->pDefaultValue;
            bIsDefault = true;
        }
    }
    else
    {
        THROW_E_ON_ERROR(hr, i_pmbp);

        io_vt        = (LPWSTR)mr.pbMDData;
        bIsInherited = mr.dwMDAttributes & METADATA_ISINHERITED;
        bIsDefault   = false;
    }

    if(io_pbIsDefault)
    {
        *io_pbIsDefault   = bIsDefault;
    }
    if(io_pbIsInherited)
    {
        *io_pbIsInherited = bIsInherited;
    }
}

//
// GetMultiSz 
//
void CMetabase::GetMultiSz(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         io_vt,
    BOOL*               io_pbIsInherited,
    BOOL*               io_pbIsDefault
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    DWORD    dwRet;
    HRESULT  hr;
    WCHAR    *buffer = NULL;

    BOOL     bIsDefault   = false;
    BOOL     bIsInherited = false;

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes | METADATA_ISINHERITED;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.pbMDData       = NULL;
    mr.dwMDDataLen    = 0;
    mr.dwMDDataTag    = 0;

    try 
    {
        if(m_pNodeCache && m_pNodeCache->GetHandle() == i_hKey)
        {
            METADATA_GETALL_RECORD* pmr = NULL;
            hr = m_pNodeCache->GetProp(
                i_pmbp->dwMDIdentifier,
                i_pmbp->dwMDUserType,
                i_pmbp->dwMDDataType,
                &mr.pbMDData,
                &pmr);
            if(SUCCEEDED(hr))
            {
                DBG_ASSERT(pmr);
                mr.dwMDAttributes = pmr->dwMDAttributes;
            }
        }
        else
        {
            buffer = new WCHAR[10*MAX_BUF_SIZE];
            if(buffer == NULL)
            {
                throw WBEM_E_OUT_OF_MEMORY;
            }
            buffer[0]      = L'\0';
            mr.pbMDData    = (LPBYTE)buffer;
            mr.dwMDDataLen = 10*MAX_BUF_SIZE*sizeof(WCHAR);

            hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);

            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                delete [] buffer;
                buffer = new WCHAR[dwRet/sizeof(WCHAR) + 1];
                if(buffer == NULL)
                {
                    throw (HRESULT)WBEM_E_OUT_OF_MEMORY;
                }
                buffer[0]      = L'\0';
                mr.pbMDData    = (LPBYTE)buffer;
                mr.dwMDDataLen = sizeof(WCHAR) + dwRet;
        
                hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
            }
        }

        CMultiSz MultiSz(i_pmbp, i_pNamespace);
        if (hr == MD_ERROR_DATA_NOT_FOUND) 
        {
            bIsInherited = false;
            if(i_pmbp->pDefaultValue == NULL)
            {
                io_vt.vt   = VT_NULL;
                bIsDefault = false;
            }
            else
            {
                hr = MultiSz.ToWmiForm((LPWSTR)i_pmbp->pDefaultValue, &io_vt);
                THROW_E_ON_ERROR(hr,i_pmbp);
                bIsDefault = true;
            }
        }
        else
        {
            THROW_E_ON_ERROR(hr,i_pmbp);
            hr = MultiSz.ToWmiForm((LPWSTR)mr.pbMDData,&io_vt);
            THROW_E_ON_ERROR(hr,i_pmbp);
            bIsInherited = mr.dwMDAttributes & METADATA_ISINHERITED;
            bIsDefault   = false;
        }

        if(io_pbIsDefault)
        {
            *io_pbIsDefault   = bIsDefault;
        }
        if(io_pbIsInherited)
        {
            *io_pbIsInherited = bIsInherited;
        }

        //
        // Cleanup
        //
        delete [] buffer;
    }
    catch (...)
    {
        delete [] buffer;
        throw;
    }
}

void CMetabase::GetBinary(
    METADATA_HANDLE    i_hKey,
    METABASE_PROPERTY* i_pmbp,
    _variant_t&        io_vt,
    BOOL*              io_pbIsInherited,
    BOOL*              io_pbIsDefault
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    DWORD      dwRet  = 0;
    HRESULT    hr     = S_OK;
    CHAR*      pszBuf = NULL;
    SAFEARRAY* safeArray = NULL;

    BOOL       bIsDefault   = false;
    BOOL       bIsInherited = false;

    pszBuf = new CHAR[10*MAX_BUF_SIZE];
    if(pszBuf == NULL)
    {
        throw (HRESULT)WBEM_E_OUT_OF_MEMORY;
    }

    METADATA_RECORD mr = {
        i_pmbp->dwMDIdentifier, 
        (i_pmbp->dwMDAttributes  & !METADATA_REFERENCE) | METADATA_ISINHERITED,
        i_pmbp->dwMDUserType,
        i_pmbp->dwMDDataType,
        10*MAX_BUF_SIZE*sizeof(CHAR),
        (unsigned char*)pszBuf,
        0
        };

    hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    if (hr == ERROR_INSUFFICIENT_BUFFER)
    {
        delete [] pszBuf;
        pszBuf = new CHAR[dwRet/sizeof(CHAR) + 1];
        if(pszBuf == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        mr.pbMDData = (unsigned char*)pszBuf;
        mr.dwMDDataLen = dwRet/sizeof(CHAR) + 1;
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);
    }
    if (hr == MD_ERROR_DATA_NOT_FOUND) 
    {
        bIsInherited = false;
        if(i_pmbp->pDefaultValue == NULL)
        {
            io_vt.vt   = VT_NULL;
            bIsDefault = false;
            hr = S_OK;
        }
        else
        {
            hr = CUtils::LoadSafeArrayFromByteArray(
                (LPBYTE)i_pmbp->pDefaultValue, 
                i_pmbp->dwDefaultValue,
                io_vt);
            if(FAILED(hr))
            {
                goto exit;
            }
            bIsDefault = true;
        }
    }
    else if(FAILED(hr))
    {
        goto exit;
    }
    else
    {
        hr = CUtils::LoadSafeArrayFromByteArray((LPBYTE)pszBuf, mr.dwMDDataLen, io_vt);
        if(FAILED(hr))
        {
            goto exit;
        }
        bIsInherited = mr.dwMDAttributes & METADATA_ISINHERITED;
        bIsDefault   = false;
    }

    //
    // If everything succeeded, set out parameters.
    //
    if(io_pbIsInherited)
    {
        *io_pbIsInherited = bIsInherited;
    }
    if(io_pbIsDefault)
    {
        *io_pbIsDefault   = bIsDefault;
    }

exit:
    delete [] pszBuf;
    if(FAILED(hr))
    {
        throw (HRESULT)hr;
    }
}

//
// Put
//
void CMetabase::Put(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    switch(i_pmbp->dwMDDataType)
    {
    case DWORD_METADATA:
        PutDword(i_hKey, i_pmbp, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        PutString(i_hKey, i_pmbp, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    case MULTISZ_METADATA:
        PutMultiSz(i_hKey, i_pmbp, i_pNamespace, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    case BINARY_METADATA:
        PutBinary(i_hKey, i_pmbp, i_vt, i_pvtOld, i_dwQuals, i_bDoDiff);
        break;

    default:
        DBGPRINTF((DBG_CONTEXT,
            "[CMetabase::Put] Cannot set %ws because type %u is unknown\n",
            i_pmbp->pszPropName,
            i_pmbp->dwMDDataType));
        break;
    }
}

//
// PutDword 
//
void CMetabase::PutDword(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DWORD    dw=0;
    DWORD    dwOld=0;
    DWORD    dwRet=0;
    HRESULT  hr=0;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataLen    = sizeof(DWORD_METADATA);
    mr.pbMDData       = (unsigned char*)&dwOld;
    mr.dwMDDataTag    = 0;

    // if it's the bit of a flag
    if (i_vt.vt == VT_BOOL && i_pmbp->dwMDMask != 0)
    {
        // Read the entire flag from in the metabase so we can set the bit
        hr = m_pIABase->GetData(i_hKey, NULL, &mr, &dwRet);

        if(hr == MD_ERROR_DATA_NOT_FOUND)
        {
            if(i_pmbp->pDefaultValue != NULL)
            {
                dwOld = i_pmbp->dwDefaultValue;
            }
            else
            {
                dwOld = 0;
            }
            hr = ERROR_SUCCESS;
        }

        if (hr == ERROR_SUCCESS)
        {
            if (i_vt.boolVal)
                dw = dwOld | i_pmbp->dwMDMask;
            else
                dw = dwOld & ~i_pmbp->dwMDMask;
        }
        else
            THROW_ON_ERROR(hr);

        if(dw == -1)
            dw = 1;  // true
    }
    else if (i_vt.vt  == VT_I4)
    {
        dw = i_vt.lVal;
    }
    else if (i_vt.vt == VT_BOOL)
    {
        DBG_ASSERT(false && "i_pmbp->dwMDMask should not be 0");
        dw = i_vt.bVal;
    }
    else 
        throw WBEM_E_INVALID_OBJECT;
   
    // Decide whether to write to metabase
    bool bWriteToMb    = true;
    if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
    {
        bool bMatchOld     = i_pvtOld != NULL && 
                             (i_pvtOld->vt == VT_I4 || i_pvtOld->vt == VT_BOOL) &&
                             *i_pvtOld == i_vt;
        bWriteToMb = !bMatchOld;
    }

    if (bWriteToMb)
    {    
        if( i_pmbp->fReadOnly )
        {
            THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
        }
        mr.pbMDData = (unsigned char*)&dw;
        hr = m_pIABase->SetData(i_hKey, NULL, &mr);
    }

    THROW_E_ON_ERROR(hr,i_pmbp);
}


//
// PutString 
//
void CMetabase::PutString(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    HRESULT  hr=0;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    if(i_vt.vt != VT_BSTR)
    {
        throw (HRESULT)WBEM_E_INVALID_OBJECT;
    }

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataTag    = 0;

    // Decide whether to write to metabase
    bool bWriteToMb    = true;
    if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
    {
        bool bMatchOld     = i_pvtOld != NULL && 
                             i_pvtOld->vt == VT_BSTR &&
                             _wcsicmp(i_pvtOld->bstrVal, i_vt.bstrVal) == 0;
        bWriteToMb = !bMatchOld;
    }

    // Set the value, only if old and new values differ.
    if(bWriteToMb)
    {   
        if( i_pmbp->fReadOnly )
        {
            THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
        }
        mr.dwMDDataLen = (wcslen(i_vt.bstrVal)+1)*sizeof(WCHAR);
        mr.pbMDData = (unsigned char*)i_vt.bstrVal;

        hr = m_pIABase->SetData(i_hKey, NULL, &mr);
    }

    THROW_E_ON_ERROR(hr,i_pmbp);
}


//
// PutMultiSz 
//
void CMetabase::PutMultiSz(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    CWbemServices*      i_pNamespace,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DWORD    dwRet;
    DWORD    dwRetOld;
    WCHAR    *buffer = NULL;
    WCHAR    *bufferOld = NULL;
    HRESULT  hr=0;

    DBG_ASSERT(i_hKey       != NULL);
    DBG_ASSERT(i_pmbp       != NULL);
    DBG_ASSERT(i_pNamespace != NULL);

    if(i_vt.vt != (VT_ARRAY | VT_BSTR) && i_vt.vt != (VT_ARRAY | VT_UNKNOWN))
    {
        throw (HRESULT)WBEM_E_INVALID_OBJECT;
    }

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataTag    = 0;

    try
    {
        CMultiSz MultiSz(i_pmbp, i_pNamespace);
        hr = MultiSz.ToMetabaseForm(&i_vt, &buffer, &dwRet);
        THROW_ON_ERROR(hr);

        // Decide whether to write to metabase
        bool bWriteToMb    = true;
        if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
        {
            bool bMatchOld = false;
            if(i_pvtOld != NULL && 
               (i_pvtOld->vt == (VT_ARRAY | VT_BSTR) || i_pvtOld->vt == (VT_ARRAY | VT_UNKNOWN)))
            {
                hr = MultiSz.ToMetabaseForm(i_pvtOld, &bufferOld, &dwRetOld);
                THROW_ON_ERROR(hr);
                if(CUtils::CompareMultiSz(buffer, bufferOld))
                {
                    bMatchOld = true;
                }
                delete [] bufferOld;
                bufferOld = NULL;
            }
            bWriteToMb = !bMatchOld;
        }

        if (bWriteToMb)
        {    
            if( i_pmbp->fReadOnly )
            {
                THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
            }

            mr.pbMDData = (unsigned char*)buffer;
            mr.dwMDDataLen = dwRet*sizeof(WCHAR);
        
            if(buffer != NULL)
            {
                hr = m_pIABase->SetData(i_hKey, NULL, &mr);
            }
            else
            {
                //
                // non-fatal if it fails
                //
                m_pIABase->DeleteData(i_hKey, 
                    NULL, 
                    i_pmbp->dwMDIdentifier, 
                    ALL_METADATA);
            }

        }
        delete [] buffer;
        buffer = NULL;
        THROW_E_ON_ERROR(hr,i_pmbp);
    }
    catch (...)
    {
        delete [] buffer;
        delete [] bufferOld;
        throw;
    }   
}

//
// PutBinary 
//
void CMetabase::PutBinary(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    _variant_t&         i_vt,
    _variant_t*         i_pvtOld,            // can be NULL
    DWORD               i_dwQuals,           // optional
    BOOL                i_bDoDiff            // optional
    )
{
    DWORD    dwRet;
    DWORD    dwRetOld;
    LPBYTE   buffer = NULL;
    LPBYTE   bufferOld = NULL;
    HRESULT  hr=0;

    bool bWriteToMb    = true;

    DBG_ASSERT(i_hKey != NULL);
    DBG_ASSERT(i_pmbp != NULL);

    if(i_vt.vt != (VT_ARRAY | VT_UI1))
    {
        throw (HRESULT)WBEM_E_INVALID_OBJECT;
    }

    METADATA_RECORD mr;
    mr.dwMDIdentifier = i_pmbp->dwMDIdentifier;
    mr.dwMDAttributes = i_pmbp->dwMDAttributes & !METADATA_REFERENCE;
    mr.dwMDUserType   = i_pmbp->dwMDUserType;
    mr.dwMDDataType   = i_pmbp->dwMDDataType;
    mr.dwMDDataTag    = 0;

    hr = CUtils::CreateByteArrayFromSafeArray(i_vt, &buffer, &dwRet);
    if(FAILED(hr))
    {
        goto exit;
    }

    // Decide whether to write to metabase
    if( (i_dwQuals & g_fForcePropertyOverwrite) == 0 && i_bDoDiff )
    {
        bool bMatchOld = false;
        if(i_pvtOld != NULL && 
           i_pvtOld->vt == (VT_ARRAY | VT_UI1))
        {
            hr = CUtils::CreateByteArrayFromSafeArray(*i_pvtOld, &bufferOld, &dwRetOld);                
            if(FAILED(hr))
            {
                goto exit;
            }
            if(CUtils::CompareByteArray(buffer, dwRet, bufferOld, dwRetOld))
            {
                bMatchOld = true;
            }
            delete [] bufferOld;
            bufferOld = NULL;
        }
        bWriteToMb = !bMatchOld;
    }

    if (bWriteToMb)
    {    
        if( i_pmbp->fReadOnly )
        {
            hr = WBEM_E_READ_ONLY;
            goto exit;
        }

        mr.pbMDData    = buffer;
        mr.dwMDDataLen = dwRet;
        
        if(buffer != NULL)
        {
            hr = m_pIABase->SetData(i_hKey, NULL, &mr);
        }
        else
        {
            //
            // non-fatal if it fails
            //
            m_pIABase->DeleteData(i_hKey, 
                NULL, 
                i_pmbp->dwMDIdentifier, 
                ALL_METADATA);
        }

    }
    delete [] buffer;
    buffer = NULL;
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    delete [] buffer;
    delete [] bufferOld;
    THROW_E_ON_ERROR(hr, i_pmbp);
}


//
// DeleteData
//
void CMetabase::DeleteData(
    METADATA_HANDLE     i_hKey,
    DWORD               i_dwMDIdentifier,
    DWORD               i_dwMDDataType)
{
    HRESULT hr;

    if(i_hKey == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    hr = m_pIABase->DeleteData(
        i_hKey, 
        NULL, 
        i_dwMDIdentifier, 
        i_dwMDDataType
        );

    if (hr == MD_ERROR_DATA_NOT_FOUND || hr == ERROR_SUCCESS)
        return;

    THROW_ON_ERROR(hr);
}


//
// DeleteData 
//
void CMetabase::DeleteData(
    METADATA_HANDLE     i_hKey,
    METABASE_PROPERTY*  i_pmbp,
    bool                i_bThrowOnRO)
{
    HRESULT hr;

    if(i_hKey == NULL || i_pmbp == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    if(i_pmbp->fReadOnly && i_bThrowOnRO)
    {
        THROW_E_ON_ERROR(WBEM_E_READ_ONLY, i_pmbp);
    }

    hr = m_pIABase->DeleteData(
        i_hKey, 
        NULL, 
        i_pmbp->dwMDIdentifier, 
        i_pmbp->dwMDDataType
        );

    if (hr == MD_ERROR_DATA_NOT_FOUND || hr == ERROR_SUCCESS)
        return;

    THROW_E_ON_ERROR(hr,i_pmbp);
}

//
// Enumuerates all the subkeys of i_wszMDPath under i_hKey.
// If we hit a 'valid' subkey, set io_pktKeyTypeSearch to this subkey and return.
// A 'valid' subkey is one where io_pktKeyTypeSearch can be a (grand*)child.
//
HRESULT CMetabase::EnumKeys(
    METADATA_HANDLE    i_hKey,
    LPCWSTR            i_wszMDPath,          //path to the key
    LPWSTR             io_wszMDName,         //receives the name of the subkey --must be METADATA_MAX_NAME_LEN
    DWORD*             io_pdwMDEnumKeyIndex, //index of the subkey
    METABASE_KEYTYPE*& io_pktKeyTypeSearch,
    bool               i_bLookForMatchAtCurrentLevelOnly
    )
{
    HRESULT  hr;
    DWORD    dwRet;
    WCHAR    wszBuf[MAX_BUF_SIZE];

    // DBG_ASSERT(i_hKey != NULL);
    // DBG_ASSERT(i_wszMDPath != NULL);
    DBG_ASSERT(io_wszMDName != NULL);
    DBG_ASSERT(io_pdwMDEnumKeyIndex != NULL);
    DBG_ASSERT(io_pktKeyTypeSearch != NULL);
   
    while(1)
    {
        hr = m_pIABase->EnumKeys(
            i_hKey,
            i_wszMDPath,
            io_wszMDName,
            *io_pdwMDEnumKeyIndex);
        if(hr != ERROR_SUCCESS)
        {
            break;
        }

        wszBuf[0] = L'\0';

        METADATA_RECORD mr = {
            METABASE_PROPERTY_DATA::s_KeyType.dwMDIdentifier, 
            METADATA_NO_ATTRIBUTES,
            IIS_MD_UT_SERVER,
            STRING_METADATA,
            MAX_BUF_SIZE*sizeof(WCHAR),
            (unsigned char*)wszBuf,
            0    
            };

        //
        // Eg. blah/
        //
        _bstr_t bstrPath = L"";
        if(i_wszMDPath)
        {
            bstrPath += i_wszMDPath;
            bstrPath += L"/";
        }
        //
        // Eg. blah/1
        //
        bstrPath += io_wszMDName;

        DBGPRINTF((DBG_CONTEXT, "CMetabase::EnumKeys::GetData (Key = 0x%x, bstrPath = %ws)\n", i_hKey, (LPWSTR)bstrPath));
        hr = m_pIABase->GetData(
            i_hKey, 
            bstrPath,
            &mr, 
            &dwRet);
        if( hr == MD_ERROR_DATA_NOT_FOUND && 
            METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue )
        {
            mr.pbMDData = (LPBYTE)METABASE_PROPERTY_DATA::s_KeyType.pDefaultValue;
            hr = S_OK;
        }

        //
        // If this is a 'valid' subkey, then set io_pktKeyTypeSearch and return.
        //
        if (hr == ERROR_SUCCESS)
        {
            if(i_bLookForMatchAtCurrentLevelOnly == false)
            {
                if(CheckKeyType((LPCWSTR)mr.pbMDData,io_pktKeyTypeSearch))
                {
                    break;
                }
            }
            else
            {
                if(CUtils::CompareKeyType((LPWSTR)mr.pbMDData,io_pktKeyTypeSearch))
                {
                    break;
                }
            }
        }

        //
        // Otherwise, go to next subkey.
        //
        (*io_pdwMDEnumKeyIndex) = (*io_pdwMDEnumKeyIndex)+1;
    }

    return hr;
}

void CMetabase::PutMethod(
    LPWSTR          i_wszPath,
    DWORD           i_id)
{
    HRESULT hr = S_OK;

    CServerMethod method;
    hr = method.Initialize(m_pIABase, i_wszPath);
    THROW_ON_ERROR(hr);

    hr = method.ExecMethod(i_id);
    THROW_ON_ERROR(hr);
}

//
// You are currently at i_wszKeyTypeCurrent in the metabase.  You want to see
// if io_pktKeyTypeSearch can be contained somewhere further down the tree.
//
bool CMetabase::CheckKeyType(
    LPCWSTR             i_wszKeyTypeCurrent,
    METABASE_KEYTYPE*&  io_pktKeyTypeSearch 
    )
{
    bool bRet = false;
    METABASE_KEYTYPE*  pktKeyTypeCurrent = &METABASE_KEYTYPE_DATA::s_NO_TYPE;

    if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_NO_TYPE)
    {
        return false;
    }

    if(FAILED(g_pDynSch->GetHashKeyTypes()->Wmi_GetByKey(i_wszKeyTypeCurrent, &pktKeyTypeCurrent)))
    {
        return (io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsObject) ? true : false;
    }

    if(pktKeyTypeCurrent == io_pktKeyTypeSearch)
    {
        return true;
    }

    if( io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE ||
        io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        bRet = true;
    }
    else
    {
        bRet = g_pDynSch->IsContainedUnder(pktKeyTypeCurrent, io_pktKeyTypeSearch);
    }

    if(bRet)
    {
        io_pktKeyTypeSearch = pktKeyTypeCurrent;
    }

    return bRet;

    /*if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsLogModule)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsLogModules )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFtpInfo)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFtpServer)
    {
         if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebInfo)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFilters)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsFilter)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFilters
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFilters )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsCompressionScheme)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFilters ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes)
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebServer)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsCertMapper)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer 
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_IIsWebFile)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebFile ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
    }
    else if(io_pktKeyTypeSearch == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity)
    {
        if( pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsWebFile ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            pktKeyTypeCurrent == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
    }*/
}

HRESULT CMetabase::WebAppCheck(
    METADATA_HANDLE a_hKey
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize;
    METADATA_RECORD mdrMDData;
    WCHAR DataBuf[MAX_PATH];
    DWORD dwState;

    dwBufferSize = MAX_PATH;
    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_APP_ROOT,
        METADATA_INHERIT|METADATA_ISINHERITED,
        IIS_MD_UT_FILE,
        STRING_METADATA,
        dwBufferSize,
        &DataBuf
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );
    THROW_ON_ERROR(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED)
    {
        hr = MD_ERROR_DATA_NOT_FOUND;
        THROW_ON_ERROR(hr);
    }

    dwBufferSize = sizeof(DWORD);
    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_APP_ISOLATED,
        METADATA_INHERIT|METADATA_ISINHERITED,
        IIS_MD_UT_WAM,
        DWORD_METADATA,
        dwBufferSize,
        &dwState
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );
    THROW_ON_ERROR(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED)
    {
        hr = MD_ERROR_DATA_NOT_FOUND;
        THROW_ON_ERROR(hr);
    }

    return hr;
}

HRESULT CMetabase::WebAppGetStatus(
    METADATA_HANDLE a_hKey,
    PDWORD pdwState)
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;

    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_ASP_ENABLEAPPLICATIONRESTART, 
        METADATA_INHERIT,
        ASP_MD_UT_APP,
        DWORD_METADATA,
        dwBufferSize,
        pdwState
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );

    return hr;
}



HRESULT CMetabase::WebAppSetStatus(
    METADATA_HANDLE a_hKey,
    DWORD dwState
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;

    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_ASP_ENABLEAPPLICATIONRESTART,
        METADATA_INHERIT,
        ASP_MD_UT_APP,
        DWORD_METADATA,
        dwBufferSize,
        &dwState
        );

    hr = m_pIABase->SetData(
        a_hKey,
        NULL,
        &mdrMDData
        );

    return hr;
}


HRESULT
CServerMethod::ExecMethod(
    DWORD dwControl
    )
{
    DWORD dwTargetState;
    DWORD dwPendingState;
    DWORD dwState = 0;
    DWORD dwSleepTotal = 0L;

    METADATA_HANDLE  hKey = 0;

    HRESULT hr       = S_OK;
    HRESULT hrMbNode = S_OK;

    switch(dwControl)
    {
    case MD_SERVER_COMMAND_STOP:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_STARTING;
        break;

    case MD_SERVER_COMMAND_CONTINUE:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_CONTINUING;
        break;

    case MD_SERVER_COMMAND_PAUSE:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        break;

    default:
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        if(FAILED(hr))
        {
            goto error;
        }
    }

    hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    if(FAILED(hr))
    {
        goto error;
    }
 
    if (dwState == dwTargetState) 
    {
        return (hr);
    }

    //
    // Write the command to the metabase
    //
    hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        m_wszPath,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        DEFAULT_TIMEOUT_VALUE,         // 30 seconds
        &hKey);
    if(FAILED(hr))
    {
        goto error;
    }

    hr = IISSetDword(hKey, MD_WIN32_ERROR, 0);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        goto error;
    }
    hr = IISSetDword(hKey, MD_SERVER_COMMAND, dwControl);
    if(FAILED(hr))
    {
        m_pIABase->CloseKey(hKey);
        goto error;
    }
    m_pIABase->CloseKey(hKey);

    while (dwSleepTotal < MAX_SLEEP_INST) 
    {
        hr       = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
        if(FAILED(hr))
        {
            goto error;
        }
        hrMbNode = 0;
        hr       = IISGetServerWin32Error(METADATA_MASTER_ROOT_HANDLE, &hrMbNode);
        if(FAILED(hr))
        {
            goto error;
        }

        //
        // First check if we've hit target state
        //
        if (dwState != dwPendingState)
        {
            //
            // Done one way or another
            //
            if (dwState == dwTargetState)
            {
                break;
            }
        }
        //
        // If we haven't check the Win32 Error from the metabase
        //
        if(FAILED(hrMbNode))
        {
            hr = hrMbNode;
            goto error;
        }

        //
        // Still pending...
        //
        ::Sleep(SLEEP_INTERVAL);

        dwSleepTotal += SLEEP_INTERVAL;
    }

    if (dwSleepTotal >= MAX_SLEEP_INST)
    {
        //
        // Timed out.  If there is a real error in the metabase
        // use it, otherwise use a generic timeout error
        //

        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
    }

error :

    return (hr);
}

//
// Helper routine for ExecMethod.
// Gets Win32 error from the metabase
//
HRESULT
CServerMethod::IISGetServerWin32Error(
    METADATA_HANDLE hObjHandle,
    HRESULT*        phrError)
{
    DBG_ASSERT(phrError != NULL);

    long    lWin32Error = 0;
    DWORD   dwLen;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = m_pIABase->GetData(
        hObjHandle,
        m_wszPath,
        &mr,
        &dwLen);
    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_FALSE;
    }

    //
    // Set out param
    //
    *phrError = HRESULT_FROM_WIN32(lWin32Error);

    return hr;
}

//
// Helper routine for ExecMethod.
// Gets server state from the metabase.
//
HRESULT
CServerMethod::IISGetServerState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_SERVER_STATE,    // server state
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = m_pIABase->GetData(
             hObjHandle,
             m_wszPath,
             &mdrMDData,
             &dwBufferSize
             );
    
    if( hr == MD_ERROR_DATA_NOT_FOUND )
    {
        //
        // If the data is not there, but the path exists, then the
        // most likely cause is that the service is not running and
        // this object was just created.
        //
        // Since MD_SERVER_STATE would be set as stopped if the
        // service were running when the key is added, we'll just 
        // say that it's stopped. 
        // 
        // Note: starting the server or service will automatically set 
        // the MB value.
        //
        *pdwState = MD_SERVER_STATE_STOPPED;
        hr = S_FALSE;
    }
    else
    {
        if(FAILED(hr))
        {
            goto error;
        }
    }

error:

    return(hr);
}

//
// Helper routine for ExecMethod.
// Used to sets the command or Win32Error in the metabase.
//
HRESULT
CServerMethod::IISSetDword(
    METADATA_HANDLE hKey,
    DWORD dwPropId,
    DWORD dwValue
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwValue;

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwPropId,
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = m_pIABase->SetData(
             hKey,
             L"",
             &mdrMDData
             );
    if(FAILED(hr))
    {
        goto error;
    }

error:

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszdata.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzData.cpp

Abstract:

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#include "MultiSzData.h"
#include <iiscnfg.h>

//
// CustomErrorDescriptions
//
LPCWSTR TFormattedMultiSzFields::apCustomErrorDescriptions[] =
{
    L"ErrorCode", L"ErrorSubCode", L"ErrorText", L"ErrorSubcodeText", L"FileSupportOnly", NULL
};
TFormattedMultiSz TFormattedMultiSzData::CustomErrorDescriptions =
{
    MD_CUSTOM_ERROR_DESC,
    L"CustomErrorDescription",
    L',',
    TFormattedMultiSzFields::apCustomErrorDescriptions
};

//
// HttpCustomHeaders
//
LPCWSTR TFormattedMultiSzFields::apHttpCustomHeaders[] =
{
    L"Keyname", L"Value", NULL
};
TFormattedMultiSz TFormattedMultiSzData::HttpCustomHeaders =
{
    MD_HTTP_CUSTOM,
    L"HttpCustomHeader",
    L',',
    TFormattedMultiSzFields::apHttpCustomHeaders
};

//
// HttpErrors
//
LPCWSTR TFormattedMultiSzFields::apHttpErrors[] =
{
    L"HttpErrorCode", L"HttpErrorSubcode", L"HandlerType", L"HandlerLocation", NULL
};
TFormattedMultiSz TFormattedMultiSzData::HttpErrors =
{
    MD_CUSTOM_ERROR,
    L"HttpError",
    L',',
    TFormattedMultiSzFields::apHttpErrors
};

//
// ScriptMaps
//
LPCWSTR TFormattedMultiSzFields::apScriptMaps[] =
{
    L"Extensions", L"ScriptProcessor", L"Flags", L"IncludedVerbs", NULL
};
TFormattedMultiSz TFormattedMultiSzData::ScriptMaps =
{
    MD_SCRIPT_MAPS,
    L"ScriptMap",
    L',',
    TFormattedMultiSzFields::apScriptMaps
};

//
// SecureBindings
//
LPCWSTR TFormattedMultiSzFields::apSecureBindings[] =
{
    L"IP", L"Port", NULL
};
TFormattedMultiSz TFormattedMultiSzData::SecureBindings =
{ 
    MD_SECURE_BINDINGS, 
    L"SecureBinding", 
    L':', 
    TFormattedMultiSzFields::apSecureBindings 
};

//
// ServerBindings
//
LPCWSTR TFormattedMultiSzFields::apServerBindings[] =
{
    L"IP", L"Port", L"Hostname", NULL
};
TFormattedMultiSz TFormattedMultiSzData::ServerBindings =
{ 
    MD_SERVER_BINDINGS, 
    L"ServerBinding",
    L':', 
    TFormattedMultiSzFields::apServerBindings 
};

//
// MimeMap
//
LPCWSTR TFormattedMultiSzFields::apMimeMaps[] =
{
    L"Extension", L"MimeType", NULL
};
TFormattedMultiSz TFormattedMultiSzData::MimeMaps =
{ 
    MD_MIME_MAP, 
    L"MimeMap",
    L',', 
    TFormattedMultiSzFields::apMimeMaps 
};

//
// Collection of Formatted MultiSz's
//
TFormattedMultiSz* TFormattedMultiSzData::apFormattedMultiSz[] =
{
    &CustomErrorDescriptions,
    &HttpCustomHeaders,
    &HttpErrors,
    &ScriptMaps,
    &SecureBindings,
    &ServerBindings,
    &MimeMaps,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\queryhelper.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    queryhelper.h

Abstract:

    Definition of:
    CQueryHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _queryhelper_h_
#define _queryhelper_h_

#include <windows.h>
#include <wbemprov.h>
#include <stdio.h>
#include <atlbase.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>
#include <dbgutil.h>

#include "wbemservices.h"
#include "schema.h"

class CQueryHelper
{
public:
    CQueryHelper(
        BSTR              i_bstrQueryLanguage,
        BSTR              i_bstrQuery,
        CWbemServices*    i_pNamespace,
        IWbemObjectSink*  i_pResponseHandler);

    ~CQueryHelper();

    void GetAssociations();

    void GetInstances();

    bool IsAssoc() const
    {
        return (m_pWmiAssoc != NULL);
    }

private:
    WMI_CLASS*                  m_pWmiClass;
    WMI_ASSOCIATION*            m_pWmiAssoc;

    CWbemServices*              m_pNamespace;
    CComPtr<IWbemObjectSink>    m_spResponseHandler;

    SQL_LEVEL_1_RPN_EXPRESSION_EXT* m_pExp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\queryhelper.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    queryhelper.cpp

Abstract:

    Implementation of:
    CQueryHelper

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// Needed for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include "assocbase.h"
#include "assocsamelevel.h"
#include "assocACLACE.h"
#include "assocComponent.h"

#include "adminacl.h"
#include "queryhelper.h"
#include "instancehelper.h"
#include "utils.h"
#include "metabase.h"
#include "enum.h"
#include "SmartPointer.h"

#include <opathlex.h>
#include <objpath.h>

CQueryHelper::CQueryHelper(
    BSTR              i_bstrQueryLanguage,
    BSTR              i_bstrQuery,
    CWbemServices*    i_pNamespace,
    IWbemObjectSink*  i_pResponseHandler) :
    m_pWmiClass(NULL),
    m_pWmiAssoc(NULL),
    m_pExp(NULL),
    m_pNamespace(NULL)
{
    DBG_ASSERT(i_bstrQueryLanguage != NULL);
    DBG_ASSERT(i_bstrQuery         != NULL);
    DBG_ASSERT(i_pNamespace        != NULL);
    DBG_ASSERT(i_pResponseHandler  != NULL);

    if(_wcsicmp(i_bstrQueryLanguage, L"WQL") != 0)
    {
        DBGPRINTF((DBG_CONTEXT, "Invalid query language: %ws\n", i_bstrQueryLanguage));
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY_TYPE);
    }

    m_spResponseHandler = i_pResponseHandler;
    m_pNamespace        = i_pNamespace;

    //
    // Get the class name from the query
    //
    WCHAR                       wszClass[512];
    wszClass[0] = L'\0';
    CTextLexSource              src(i_bstrQuery);
    SQL1_Parser                 parser(&src);

    int nRes = parser.GetQueryClass(wszClass, 511);
    if(nRes)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }

    //
    // Determine if class, association, or neither
    //
    if( CUtils::GetClass(wszClass, &m_pWmiClass) )
    {
    }
    else if( CUtils::GetAssociation(wszClass,&m_pWmiAssoc) )
    {
        DBG_ASSERT(m_pWmiClass == NULL);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }
    DBG_ASSERT((m_pWmiClass == NULL) || (m_pWmiAssoc == NULL));
    DBG_ASSERT((m_pWmiClass != NULL) || (m_pWmiAssoc != NULL));

    //
    // Parse
    //
    nRes = parser.Parse((SQL_LEVEL_1_RPN_EXPRESSION**)&m_pExp);
    if(nRes)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }
}

CQueryHelper::~CQueryHelper()
{
    delete m_pExp;
    m_pExp       = NULL;
    m_pNamespace = NULL;
    m_pWmiClass  = NULL;
    m_pWmiAssoc  = NULL;
}

void CQueryHelper::GetAssociations()
{
    DBG_ASSERT(IsAssoc());

    TSmartPointer<CAssocBase> spAssocBase;

    if( m_pWmiAssoc == &WMI_ASSOCIATION_DATA::s_AdminACLToACE )
    {
        //
        // Special association
        //
        spAssocBase = new CAssocACLACE(m_pNamespace, m_spResponseHandler);
    }
    else if( m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity ||
        m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL   ||
        m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting )
    {
        spAssocBase = new CAssocSameLevel(m_pNamespace, m_spResponseHandler, m_pWmiAssoc);
    }
    else if( m_pWmiAssoc->pType == &WMI_ASSOCIATION_TYPE_DATA::s_Component )
    {
        spAssocBase = new CAssocComponent(m_pNamespace, m_spResponseHandler, m_pWmiAssoc);
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_CLASS);
    }

    if(spAssocBase == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    spAssocBase->GetInstances(m_pExp);
}

void CQueryHelper::GetInstances()
{
    DBG_ASSERT(!IsAssoc());
    DBG_ASSERT(m_pWmiClass != NULL);

    if(m_pExp)
    {
        m_pExp->SetContainsOrOrNot();
    }

    //
    // Optimization: Just return the instance
    //
    if(m_pExp && !m_pExp->GetContainsOrOrNot())
    {
        const SQL_LEVEL_1_TOKEN* pToken = m_pExp->GetFilter(m_pWmiClass->pszKeyName);
        if(pToken)
        {
            if(m_pWmiClass != &WMI_CLASS_DATA::s_ACE)
            {
                ParsedObjectPath popInstance;

                if(!popInstance.SetClassName(m_pWmiClass->pszClassName))
                {
                    THROW_ON_ERROR(WBEM_E_FAILED);
                }
                if(!popInstance.AddKeyRef(m_pWmiClass->pszKeyName, &pToken->vConstValue))
                {
                    THROW_ON_ERROR(WBEM_E_FAILED);
                }

                CComPtr<IWbemClassObject> spInstance;
                CInstanceHelper InstanceHelper(&popInstance, m_pNamespace);
                DBG_ASSERT(!IsAssoc());
                try
                {
                    InstanceHelper.GetInstance(
                        false,
                        &CMetabase(),
                        &spInstance);
                }
                catch(...)
                {
                }
                if(spInstance != NULL)
                {
                    HRESULT hr = m_spResponseHandler->Indicate(1, &spInstance);
                    THROW_ON_ERROR(hr);
                }
            }
            else
            {
                if(pToken->vConstValue.vt != VT_BSTR)
                {
                    THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
                }

                _bstr_t bstrMbPath = WMI_CLASS_DATA::s_ACE.pszMetabaseKey;
                bstrMbPath        += L"/";
                bstrMbPath        += pToken->vConstValue.bstrVal;

                //
                // CloseSD called automatically.
                //
                CAdminACL AdminACL;
                HRESULT hr = AdminACL.OpenSD(bstrMbPath);
                THROW_ON_ERROR(hr);

                hr = AdminACL.EnumerateACEsAndIndicate(
                    pToken->vConstValue.bstrVal,
                    *m_pNamespace,
                    *m_spResponseHandler);
                THROW_ON_ERROR(hr);
            }
            return;
        }
    }

    ParsedObjectPath    ParsedObject;            //deconstructer frees memory

    if (!ParsedObject.SetClassName(m_pWmiClass->pszClassName))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    CEnum EnumObject;
    EnumObject.Init(
        m_spResponseHandler,
        m_pNamespace,
        &ParsedObject,
        m_pWmiClass->pszMetabaseKey,
        NULL,
        m_pExp);
    EnumObject.Recurse(
        NULL,
        &METABASE_KEYTYPE_DATA::s_NO_TYPE,
        NULL,
        m_pWmiClass->pszKeyName, 
        m_pWmiClass->pkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\pusher.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pusher.h

Abstract:

    This file contains the definition of the CPusher class.
    This class contains the logic for pushing schema to the repository.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#ifndef _pusher_h_
#define _pusher_h_

#include "schemaextensions.h"

//
// Property Names
//
static LPCWSTR g_wszProp_Class         = L"__CLASS";
static LPCWSTR g_wszProp_Name          = L"Name";

//
// Property Qualifier Names
//
static LPCWSTR g_wszPq_Key             = L"Key";
static LPCWSTR g_wszPq_CimType         = L"CIMTYPE";
static LPCWSTR g_wszPq_Read            = L"Read";
static LPCWSTR g_wszPq_Write           = L"Write";

//
// Class Qualifier Names
//
static LPCWSTR   g_wszCq_Provider      = L"provider";
static LPCWSTR   g_wszCq_Dynamic       = L"dynamic";
static LPCWSTR   g_wszCq_Extended      = L"extended";
static LPCWSTR   g_wszCq_SchemaTS      = L"MbSchemaTimeStamp";

//
// Method Qualifier Names
//
static LPCWSTR   g_wszMq_Implemented   = L"Implemented";

//
// Class Qualifier Values
//
static LPCWSTR   g_wszCqv_Provider     = L"IIS__PROVIDER";

class CPusher
{
public:
    CPusher() : m_pNamespace(NULL), 
        m_pCtx(NULL),
        m_bInitCalled(false),
        m_bInitSuccessful(false)
    {
    }

    virtual ~CPusher();

    HRESULT Initialize(
        CWbemServices* i_pNamespace,
        IWbemContext*  i_pCtx);

    HRESULT Push(
        const CSchemaExtensions*      i_pCatalog,
        CHashTable<WMI_CLASS *>*      i_phashClasses,
        CHashTable<WMI_ASSOCIATION*>* i_phashAssocs);

private:
    //
    // These are called by Push.
    //
    HRESULT RepositoryInSync(
        const CSchemaExtensions* i_pCatalog,
        bool*                    io_pbInSync);

    HRESULT PushClasses(
        CHashTable<WMI_CLASS *>* i_phashTable);

    HRESULT PushAssocs(
        CHashTable<WMI_ASSOCIATION *>* i_phashTable);

    HRESULT SetTimeStamp(
        const CSchemaExtensions* i_pCatalog);

    //
    // Called by PushClasses and PushAssocs
    //
    HRESULT DeleteChildren(
        LPCWSTR i_wszExtSuperClass);

    bool NeedToDeleteAssoc(
        IWbemClassObject* i_pObj) const;

    HRESULT GetObject(
        LPCWSTR            i_wszClass, 
        IWbemClassObject** o_ppObj);

    HRESULT SetClassInfo(
        IWbemClassObject* i_pObj,
        LPCWSTR           i_wszClassName,
        ULONG             i_iShipped);

    //
    // Called by PushClasses
    //
    HRESULT PrepareForPutClass(
        const WMI_CLASS* i_pElement,
        bool*            io_pbPutNeeded);

    HRESULT SetProperties(
        const WMI_CLASS*  i_pElement, 
        IWbemClassObject* i_pObject) const;

    HRESULT SetMethods(
        const WMI_CLASS*  i_pElement,
        IWbemClassObject* i_pObject) const;

    //
    // Called by PushAssocs
    //
    HRESULT SetAssociationComponent(
        IWbemClassObject* i_pObject, 
        LPCWSTR           i_wszComp, 
        LPCWSTR           i_wszClass) const;


    CWbemServices* m_pNamespace;
    IWbemContext*  m_pCtx;

    //
    // These are base classes that are opened in "Initialize" to
    // prevent repeated WMI calls to m_pNamespace->GetObject().
    //
    CComPtr<IWbemClassObject> m_spBaseElementObject;
    CComPtr<IWbemClassObject> m_spBaseSettingObject;
    CComPtr<IWbemClassObject> m_spBaseElementSettingObject;
    CComPtr<IWbemClassObject> m_spBaseGroupPartObject;

    //
    // Class qualifier name/value pairs
    // Used in PushClasses and PushAssocs
    //
    LPCWSTR     m_awszClassQualNames[2];
    CComVariant m_avtClassQualValues[2];

    bool m_bInitCalled;
    bool m_bInitSuccessful;
};

#endif // _pusher_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszhelper.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzHelper.h

Abstract:

    Defines the CMultiSzHelper class

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#ifndef _multiszhelper_h_
#define _multiszhelper_h_

#include <windows.h>
#include <comutil.h>
#include <wbemprov.h>
#include "schema.h"
#include "WbemServices.h"
#include "MultiSzData.h"

class CMultiSz
{
public:
    CMultiSz(
        METABASE_PROPERTY* i_pMbp,
        CWbemServices*     i_pNamespace);

    CMultiSz();

    virtual ~CMultiSz();

    HRESULT ToMetabaseForm(
        const VARIANT* i_pvt,
        LPWSTR*        o_msz,
        PDWORD         io_pdw);

    HRESULT ToWmiForm(
        LPCWSTR        i_msz,
        VARIANT*       io_pvt);

private:
    HRESULT CreateMultiSzFromSafeArray(
        const VARIANT&     i_vt,
        WCHAR**            o_pmsz,
        DWORD*             io_pdw);

    HRESULT MzCat(
        WCHAR**        io_ppdst,
        const WCHAR*   i_psz);

    HRESULT LoadSafeArrayFromMultiSz(
        LPCWSTR      i_msz,
        VARIANT&     io_vt);

    HRESULT ParseEntry(
        LPCWSTR            i_wszEntry,
        IWbemClassObject*  io_pObj);

    HRESULT UnparseEntry(
        IWbemClassObject*  i_pObj,
        BSTR*              o_pbstrEntry);

    METABASE_PROPERTY*  m_pMbp;
    CWbemServices*      m_pNamespace;
    TFormattedMultiSz*  m_pFormattedMultiSz;
};

#endif  // _multiszhelper_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\multiszhelper.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    MultiSzHelper.cpp

Abstract:

    Implements the CMultiSzHelper class

Author:

    Mohit Srivastava            22-March-01

Revision History:

--*/

#include "MultiSzHelper.h"
#include <iiscnfg.h>
#include <dbgutil.h>
#include <atlbase.h>

#include "utils.h"

//
// CMultiSz
//

CMultiSz::CMultiSz()
{
    m_pMbp              = NULL;
    m_pNamespace        = NULL;
    m_pFormattedMultiSz = NULL;
}

CMultiSz::CMultiSz(
    METABASE_PROPERTY* i_pMbp,
    CWbemServices*     i_pNamespace)
{
    DBG_ASSERT(i_pMbp       != NULL);
    DBG_ASSERT(i_pNamespace != NULL);

    m_pMbp              = i_pMbp;
    m_pNamespace        = i_pNamespace;
    m_pFormattedMultiSz = NULL;

    if(m_pMbp != NULL)
    {
        TFormattedMultiSz* pFormattedMultiSz = NULL;
        for(ULONG i = 0; ; i++)
        {
            pFormattedMultiSz = TFormattedMultiSzData::apFormattedMultiSz[i];
            if(pFormattedMultiSz == NULL)
            {
                break;
            }
            else if(pFormattedMultiSz->dwPropId == m_pMbp->dwMDIdentifier)
            {
                m_pFormattedMultiSz = pFormattedMultiSz;
                break;
            }
        }
    }
}

CMultiSz::~CMultiSz()
{
}

HRESULT CMultiSz::ToMetabaseForm(
    const VARIANT* i_pvt,
    LPWSTR*        o_pmsz,
    PDWORD         io_pdw)
{
    DBG_ASSERT(i_pvt   != NULL);
    DBG_ASSERT(o_pmsz  != NULL);
    DBG_ASSERT(io_pdw  != NULL);

    *o_pmsz  = NULL;
    *io_pdw  = NULL;

    return CreateMultiSzFromSafeArray(
        *i_pvt,
        o_pmsz,
        io_pdw);
}

HRESULT CMultiSz::ToWmiForm(
    LPCWSTR        i_msz,
    VARIANT*       io_pvt)
{
    DBG_ASSERT(i_msz  != NULL);
    DBG_ASSERT(io_pvt != NULL);

    return LoadSafeArrayFromMultiSz(
        i_msz,
        *io_pvt);
}

//
// private
//

HRESULT CMultiSz::CreateMultiSzFromSafeArray(
    const VARIANT&     i_vt,
    WCHAR**            o_pmsz,
    DWORD*             io_pdw
    )
/*++

Synopsis: 

Arguments: [i_vt] - 
           [o_pmsz] - 
           [io_pdw] - 
           
--*/
{
    DBG_ASSERT(i_vt.vt == (VT_ARRAY | VT_BSTR) || i_vt.vt == (VT_ARRAY | VT_UNKNOWN));
    DBG_ASSERT(o_pmsz != NULL);
    DBG_ASSERT(io_pdw != NULL);

    HRESULT hr = S_OK;

    if(i_vt.parray == NULL)
    {
        *o_pmsz = NULL;
        *io_pdw  = 0;
    }

    WCHAR*          msz = NULL;
    long            iLo,iUp,c;
    SAFEARRAY*      psa = i_vt.parray;
    long            i = 0;
    BSTR            bstr = NULL;

    hr = SafeArrayGetLBound(psa,1,&iLo);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = SafeArrayGetUBound(psa,1,&iUp);
    if(FAILED(hr))
    {
        goto exit;
    }

    for (*io_pdw=0, c = iLo; c <= iUp; c++)
    {
        if(m_pFormattedMultiSz)
        {
            DBG_ASSERT(m_pMbp       != NULL);
            DBG_ASSERT(m_pNamespace != NULL);

            CComPtr<IWbemClassObject> spObj;
            hr = SafeArrayGetElement(psa, &c, &spObj);
            if(FAILED(hr))
            {
                goto exit;
            }
            hr = UnparseEntry(spObj, &bstr);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
        else
        {
            hr = SafeArrayGetElement(psa,&c,&bstr);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
        *io_pdw = *io_pdw + wcslen(bstr) + 1;
        hr = MzCat(&msz,bstr);
        if(FAILED(hr))
        {
            goto exit;
        }
        SysFreeString(bstr);
        bstr = NULL;
    }
    *io_pdw +=1;
    *o_pmsz = msz;

exit:
    if(FAILED(hr))
    {
        delete [] msz;
        msz = NULL;
    }
    SysFreeString(bstr);
    bstr = NULL;

    return hr;
}

HRESULT CMultiSz::MzCat(
    WCHAR**        io_ppdst,
    const WCHAR*   i_psz
    )
/*++

Synopsis: 
    The metabase has this animal called METADATA_STRINGSZ which has the 
    following form: <string><null><string><null><null>.  MzCat concatenates
    strings in the defined way.  *io_ppdst has the new pointer upon exit.  The
    previous value of *io_ppdst is delelted.  *io_ppdst == NULL is handled.

Arguments: [io_ppdst] - 
           [i_psz] - 
           
--*/
{
    DBG_ASSERT(io_ppdst != NULL);

    WCHAR  *psrc;
    WCHAR  *pdst;
    WCHAR  *pnew;
    int    ilen;

    if (i_psz == NULL)
        return WBEM_E_FAILED;

    if (*io_ppdst) 
    {
        for ( ilen=0, psrc = *io_ppdst
            ; *psrc || *(psrc+1)
            ; psrc++, ilen++
            )
        {
            ;
        }

        ilen = ilen + wcslen(i_psz)+3;
    }
    else ilen = wcslen(i_psz)+2;

    pnew = pdst = new WCHAR[ilen];

    if (!pdst)
        return WBEM_E_OUT_OF_MEMORY;
    
    if (*io_ppdst) 
    {
        for ( psrc = *io_ppdst
            ; *psrc || *(psrc+1)
            ; pdst++, psrc++
            )
        {
            *pdst = *psrc;
        }

        *pdst = L'\0';
        pdst++;
    }
    wcscpy(pdst,i_psz);
    *(pnew+ilen-1)=L'\0';

    delete *io_ppdst;
    *io_ppdst=pnew;

    return WBEM_S_NO_ERROR;
}

HRESULT CMultiSz::LoadSafeArrayFromMultiSz(
    LPCWSTR      i_msz,
    VARIANT&     io_vt)
/*++

Synopsis: 

Arguments: [i_msz] - 
           [io_vt] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_msz        != NULL);

    LPCWSTR           msz;
    HRESULT           hr = WBEM_S_NO_ERROR;
    DWORD             c;
    SAFEARRAYBOUND    aDim;
    SAFEARRAY*        psa = NULL;
    long              i = 0;
    VARTYPE           vtypeData = (m_pFormattedMultiSz) ? VT_UNKNOWN : VT_BSTR;
    CComPtr<IWbemClassObject> spClass;

    //
    // figure the dimensions of the multisz
    //
    for (c=1,msz=i_msz; *msz||*(msz+1); msz++)
    {
        if(!*msz) 
        {
            c++;
        }
    }

    aDim.lLbound    = 0;
    aDim.cElements= c;

    psa = SafeArrayCreate(vtypeData, 1, &aDim);
    if (!psa)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    if( m_pFormattedMultiSz )
    {
        HRESULT hr = S_OK;

        hr = m_pNamespace->GetObject(
            m_pFormattedMultiSz->wszWmiClassName, 
            0, 
            NULL, 
            &spClass, 
            NULL);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    for (msz=i_msz; ; i++) 
    {
        if(m_pFormattedMultiSz)
        {
            DBG_ASSERT(m_pMbp       != NULL);
            DBG_ASSERT(m_pNamespace != NULL);

            CComPtr<IWbemClassObject> spObj;
            hr = spClass->SpawnInstance(0, &spObj);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = ParseEntry(msz, spObj);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = SafeArrayPutElement(psa, &i, spObj);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
        else
        {
            CComBSTR sbstr = msz;
            if(sbstr.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
            hr = SafeArrayPutElement(psa, &i, (BSTR)sbstr);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    
        msz += wcslen(msz) + 1;
        if (!*msz)
        {
            break;
        }
    }
    io_vt.vt = VT_ARRAY | vtypeData;
    io_vt.parray = psa;

exit:
    if (psa && FAILED(hr)) 
    {
        SafeArrayDestroy(psa);
    }

    return hr;
}

HRESULT CMultiSz::ParseEntry(
    LPCWSTR            i_wszEntry,
    IWbemClassObject*  io_pObj)
/*++

Synopsis: 

Arguments: [i_wszEntry] - 
           [io_pObj] - WMI object corresponding to the particular entry.
                       SpawnInstance should have been called by caller.
           
Return Value: 

--*/
{
    DBG_ASSERT(i_wszEntry          != NULL);
    DBG_ASSERT(io_pObj             != NULL);
    DBG_ASSERT(m_pFormattedMultiSz != NULL);

    HRESULT hr       = WBEM_S_NO_ERROR;

    ULONG   idx                     = 0;
    LPCWSTR wszValue                = NULL;
    ULONG   NrFields                = 0;
    CComPtr<IWbemClassObject> spObj = io_pObj; // dest object

    //
    // Make a copy of the entry.  Put on stack or heap depending on size.
    //
    WCHAR  wszBufStack[64];
    LPWSTR wszBufDyn       = NULL;
    LPWSTR wszEntry        = NULL;
    ULONG  cchEntry        = wcslen(i_wszEntry);
    if((cchEntry+1) < 64)
    {
        wszEntry = wszBufStack;
    }
    else
    {
        wszBufDyn = new WCHAR[cchEntry+1];
        if(wszBufDyn == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        wszEntry = wszBufDyn;
    }
    memcpy(wszEntry, i_wszEntry, sizeof(WCHAR) * (cchEntry + 1));

    //
    // get the number of fields
    //
    if(m_pFormattedMultiSz->awszFields != NULL)
    {
        for(idx = 0; m_pFormattedMultiSz->awszFields[idx] != NULL; idx++)
        {
        }
        NrFields = idx;
        DBG_ASSERT(NrFields <= MAX_FIELDS);
    }

    //
    // Parse
    //
    ULONG jdx = 0;
    LONG  idxEndOfLastString = -1;
    for(idx = 0; idx < (cchEntry+1) && jdx < NrFields; idx++)
    {
        if( wszEntry[idx] == m_pFormattedMultiSz->wcDelim ||
            wszEntry[idx] == L'\0' )
        {
            //
            // If there's only one spot left in our array, we take the remaining
            // string -- including delimeters -- and put it as the last element
            //
            if(jdx != NrFields-1)
            {
                wszEntry[idx]            = L'\0';
            }

            CComVariant vtEntry;
            vtEntry = wszEntry + idxEndOfLastString + 1;
            if(vtEntry.vt == VT_ERROR)
            {
                hr = vtEntry.scode;
                goto exit;
            }

            hr = spObj->Put(
                m_pFormattedMultiSz->awszFields[jdx],
                0,
                &vtEntry,
                0);
            if(FAILED(hr))
            {
                goto exit;
            }

            jdx++;
            idxEndOfLastString       = idx;
        }
    }
    
exit:
    delete [] wszBufDyn;
    wszBufDyn = NULL;
    return hr;
}

HRESULT CMultiSz::UnparseEntry(
    IWbemClassObject* i_pObj,
    BSTR*             o_pbstrEntry)
{
    DBG_ASSERT(i_pObj              != NULL);
    DBG_ASSERT(o_pbstrEntry       != NULL);
    DBG_ASSERT(m_pFormattedMultiSz != NULL);

    *o_pbstrEntry = NULL;

    HRESULT  hr            = S_OK;
    LPCWSTR* awszFields    = m_pFormattedMultiSz->awszFields;
    CComBSTR sbstrUnparsed;

    if(awszFields == NULL)
    {
        goto exit;
    }

    WCHAR wszDelim[2];
    wszDelim[0] = m_pFormattedMultiSz->wcDelim;
    wszDelim[1] = L'\0';

    for(ULONG i = 0; awszFields[i] != NULL; i++)
    {
        CComVariant vtValue;
        hr = i_pObj->Get(
            awszFields[i],
            0,
            &vtValue,
            NULL,
            NULL);
        if(FAILED(hr))
        {
            goto exit;
        }
        if(vtValue.vt == VT_BSTR && vtValue.bstrVal != NULL)
        {
            sbstrUnparsed += vtValue.bstrVal;
            if(sbstrUnparsed.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
        }
        if(awszFields[i+1] != NULL)
        {
            sbstrUnparsed += wszDelim;
            if(sbstrUnparsed.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
        }
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_pbstrEntry = sbstrUnparsed.Detach();

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\pusher.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pusher.cpp

Abstract:

    This file contains the implementation of the CPusher class.
    This class contains the logic for pushing schema to the repository.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#include "iisprov.h"
#include "pusher.h"
#include "MultiSzData.h"

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp

HRESULT CPusher::RepositoryInSync(
    const CSchemaExtensions* i_pCatalog,
    bool*                    io_pbInSync)
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(io_pbInSync       != NULL);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    CComBSTR                  sbstrTemp;
    CComVariant               svtTimeStamp;
    CComPtr<IWbemClassObject> spObjIIsComputer;

    sbstrTemp = WMI_CLASS_DATA::s_Computer.pszClassName;
    if(sbstrTemp.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    hr = m_pNamespace->GetObject(sbstrTemp, 0, m_pCtx, &spObjIIsComputer, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Try to get timestamp from repository
    //
    hr = CUtils::GetQualifiers(spObjIIsComputer, &g_wszCq_SchemaTS, &svtTimeStamp, 1);
    if(FAILED(hr) || svtTimeStamp.vt != VT_BSTR)
    {
        *io_pbInSync = false;
        return WBEM_S_NO_ERROR;
    }

    //
    // Get timestamp of mbschema.xml
    //
    FILETIME FileTime;
    hr = i_pCatalog->GetMbSchemaTimeStamp(&FileTime);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Finally, compare the timestamps
    //
    WCHAR wszFileTime[30];
    CUtils::FileTimeToWchar(&FileTime, wszFileTime);
    if(_wcsicmp(wszFileTime, svtTimeStamp.bstrVal) == 0)
    {
        *io_pbInSync = true;
    }
    else
    {
        *io_pbInSync = false;
    }
    return hr;
}

HRESULT CPusher::SetTimeStamp(
    const CSchemaExtensions* i_pCatalog)
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    CComBSTR                  sbstrTemp;
    CComVariant               svtTimeStamp;
    CComPtr<IWbemClassObject> spObjIIsComputer;

    sbstrTemp = WMI_CLASS_DATA::s_Computer.pszClassName;
    if(sbstrTemp.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    hr = m_pNamespace->GetObject(sbstrTemp, 0, m_pCtx, &spObjIIsComputer, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Get timestamp of mbschema.xml
    //
    FILETIME FileTime;
    hr = i_pCatalog->GetMbSchemaTimeStamp(&FileTime);
    if(FAILED(hr))
    {
        return hr;
    }
    WCHAR wszFileTime[30];
    CUtils::FileTimeToWchar(&FileTime, wszFileTime);

    //
    // Finally, Set the timestamp in the repository
    //
    svtTimeStamp = wszFileTime;
    if(svtTimeStamp.vt != VT_BSTR || svtTimeStamp.bstrVal == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    hr = CUtils::SetQualifiers(
        spObjIIsComputer,
        &g_wszCq_SchemaTS,
        &svtTimeStamp,
        1,
        0);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Finally, put the class
    //
    hr = m_pNamespace->PutClass(spObjIIsComputer, WBEM_FLAG_OWNER_UPDATE, m_pCtx, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    return hr;
}

HRESULT CPusher::Initialize(CWbemServices* i_pNamespace,
                            IWbemContext*  i_pCtx)
/*++

Synopsis: 
    Only call once.

Arguments: [i_pNamespace] - 
           [i_pCtx] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pNamespace      != NULL);
    DBG_ASSERT(i_pCtx            != NULL);
    DBG_ASSERT(m_bInitCalled     == false);
    DBG_ASSERT(m_bInitSuccessful == false);

    HRESULT  hr = WBEM_S_NO_ERROR;
    CComBSTR bstrTemp;

    m_bInitCalled           = true;
    m_pCtx                  = i_pCtx;
    m_pNamespace            = i_pNamespace;
    m_awszClassQualNames[1] = g_wszCq_Dynamic;
    m_avtClassQualValues[1] = (bool)true;
    m_awszClassQualNames[0] = g_wszCq_Provider;
    m_avtClassQualValues[0] = g_wszCqv_Provider;;
    if(m_avtClassQualValues[0].bstrVal == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    //
    // Get pointers to most commonly used base classes
    //
    bstrTemp = g_wszExtElementParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseElementObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    bstrTemp = g_wszExtSettingParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseSettingObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    bstrTemp = g_wszExtElementSettingAssocParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseElementSettingObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

    bstrTemp = g_wszExtGroupPartAssocParent;
    if(bstrTemp.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }
    hr = m_pNamespace->GetObject(bstrTemp, 0, m_pCtx, &m_spBaseGroupPartObject, NULL);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "CPusher::Initialize failed, hr=0x%x\n", hr));
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        m_bInitSuccessful = true;
    }
    return hr;
}

CPusher::~CPusher()
{
}

HRESULT CPusher::Push(
    const CSchemaExtensions*      i_pCatalog,
    CHashTable<WMI_CLASS *>*      i_phashClasses,
    CHashTable<WMI_ASSOCIATION*>* i_phashAssocs)
{
    DBG_ASSERT(i_pCatalog        != NULL);
    DBG_ASSERT(i_phashClasses    != NULL);
    DBG_ASSERT(i_phashAssocs     != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;

    bool bInSync= false;

    hr = RepositoryInSync(i_pCatalog, &bInSync);
    if(FAILED(hr))
    {
        return hr;
    }

    if(!bInSync)
    {
        hr = PushClasses(i_phashClasses);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::Push failed, hr=0x%x\n", hr));
            return hr;
        }
        hr = PushAssocs(i_phashAssocs);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::Push failed, hr=0x%x\n", hr));
            return hr;
        }
        hr = SetTimeStamp(i_pCatalog);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::Push failed, hr=0x%x\n", hr));
            return hr;
        }
    }

    return hr;
}

HRESULT CPusher::PushClasses(
    CHashTable<WMI_CLASS *>* i_phashTable)
/*++

Synopsis: 
    Public function to push classes to repository.
    1) Precondition: All USER_DEFINED_TO_REPOSITORY classes are not in repository.
    2) Pushes all USER_DEFINED_TO_REPOSITORY classes to repository.
    3) Deletes and recreates SHIPPED_TO_MOF, SHIPPED_NOT_TO_MOF, and
       EXTENDED classes if necessary.

Arguments: [i_phashTable] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_phashTable      != NULL);
    DBG_ASSERT(m_pNamespace      != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemClassObject>  spObject = NULL;
    CComPtr<IWbemClassObject>  spChildObject = NULL;

    //
    // Vars needed for iteration
    //
    CHashTable<WMI_CLASS*>::Record*  pRec = NULL;
    CHashTable<WMI_CLASS*>::iterator iter;
    CHashTable<WMI_CLASS*>::iterator iterEnd;

    CComVariant v;    

    //
    // DeleteChildren of extended base classes
    //
    LPWSTR awszBaseClasses[] = { 
        g_wszExtElementParent, 
        g_wszExtSettingParent,
        NULL };

    for(ULONG idx = 0; awszBaseClasses[idx] != NULL; idx++)
    {
        hr = DeleteChildren(awszBaseClasses[idx]);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
            goto exit;
        }
    }

    //
    // Walk thru the hashtable of classes
    //
    bool  bPutNeeded;
    iterEnd = i_phashTable->end();
    for(iter = i_phashTable->begin(); iter != iterEnd; ++iter)
    {
        pRec = iter.Record();
        DBG_ASSERT(pRec != NULL);

        //
        // Deletes SHIPPED_TO_MOF, SHIPPED_NOT_TO_MOF, EXTENDED classes if necessary.
        //
        hr = PrepareForPutClass(pRec->m_data, &bPutNeeded);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
            goto exit;
        }

        if(bPutNeeded)
        {
            hr = GetObject(pRec->m_data->pszParentClass, &spObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            hr = spObject->SpawnDerivedClass(0, &spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }
            spObject = NULL;

            //
            // Push class qualifiers and special __CLASS property.
            //
            hr = SetClassInfo(
                spChildObject, 
                pRec->m_wszKey,
                pRec->m_data->dwExtended);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Name property and corresponding qualifier
            // Base class may contain Name.  Handle this case
            //
            bool bPutNameProperty = true;
            for(ULONG j = 0; g_awszParentClassWithNamePK[j] != NULL; j++)
            {
                //
                // Deliberate ==
                //
                if(g_awszParentClassWithNamePK[j] == pRec->m_data->pszParentClass)
                {
                    bPutNameProperty = false;
                }
            }
            if( bPutNameProperty )
            {
                hr = spChildObject->Put(g_wszProp_Name, 0, NULL, CIM_STRING);
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                    goto exit;
                }
                v = (bool)true;
                hr = CUtils::SetPropertyQualifiers(
                    spChildObject, 
                    g_wszProp_Name, // Property name
                    &g_wszPq_Key,   // Array of qual names
                    &v,             // Array of qual values
                    1               // Nr of quals
                    );
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                    goto exit;
                }
            }

            //
            // All other properties
            //
            hr = SetProperties(pRec->m_data, spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Any methods
            //
            hr = SetMethods(pRec->m_data, spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Finally, put the class
            //
            hr = m_pNamespace->PutClass(spChildObject, WBEM_FLAG_OWNER_UPDATE, m_pCtx, NULL);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushClasses failed, hr=0x%x\n", hr));
                goto exit;
            }

            spChildObject = NULL;
        }
    }

exit:
    return hr;
}

HRESULT CPusher::PushAssocs(
    CHashTable<WMI_ASSOCIATION*>* i_phashTable)
/*++

Synopsis: 
    Public function to push assocs to repository.
    - Precondition: All USER_DEFINED_TO_REPOSITORY assocs are not in repository.
    - Pushes all USER_DEFINED_TO_REPOSITORY assocs to repository.

Arguments: [i_phashTable] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_phashTable      != NULL);
    DBG_ASSERT(m_pNamespace      != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemClassObject>  spObject = NULL;
    CComPtr<IWbemClassObject>  spChildObject = NULL;

    //
    // Vars needed for iteration
    //
    CHashTable<WMI_ASSOCIATION*>::Record*  pRec = NULL;
    CHashTable<WMI_ASSOCIATION*>::iterator iter;
    CHashTable<WMI_ASSOCIATION*>::iterator iterEnd;

    //
    // DeleteChildren of extended base classes
    //
    LPWSTR awszBaseClasses[] = { 
        g_wszExtElementSettingAssocParent, 
        g_wszExtGroupPartAssocParent,
        NULL };

    for(ULONG idx = 0; awszBaseClasses[idx] != NULL; idx++)
    {
        hr = DeleteChildren(awszBaseClasses[idx]);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
            goto exit;
        }
    }

    //
    // Walk thru the hashtable of assocs
    //
    for(iter = i_phashTable->begin(), iterEnd = i_phashTable->end();
        iter != iterEnd; 
        ++iter)
    {
        pRec = iter.Record();
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
            goto exit;
        }

        if(pRec->m_data->dwExtended == USER_DEFINED_TO_REPOSITORY)
        {
            hr = GetObject(pRec->m_data->pszParentClass, &spObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }

            hr = spObject->SpawnDerivedClass(0, &spChildObject);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }
            spObject = NULL;

            //
            // Push class qualifiers and special __CLASS property.
            //
            hr = SetClassInfo(
                spChildObject, 
                pRec->m_wszKey,
                pRec->m_data->dwExtended);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }

            //
            // Push the two ref properties of the association.
            //
            hr = SetAssociationComponent(
                spChildObject,
                pRec->m_data->pType->pszLeft,
                pRec->m_data->pcLeft->pszClassName);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }
            hr = SetAssociationComponent(
                spChildObject,
                pRec->m_data->pType->pszRight,
                pRec->m_data->pcRight->pszClassName);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                goto exit;
            }

            hr = m_pNamespace->PutClass(
                spChildObject, 
                WBEM_FLAG_OWNER_UPDATE | WBEM_FLAG_CREATE_ONLY, 
                m_pCtx, 
                NULL);
            if(FAILED(hr))
            {
                if(hr == WBEM_E_ALREADY_EXISTS)
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "CPusher::PushAssocs failed, hr=0x%x\n", hr));
                    goto exit;
                }
            }

            spChildObject = NULL;
        }
    }

exit:
    return hr;
}

HRESULT CPusher::PrepareForPutClass(
    const WMI_CLASS* i_pClass,
    bool*            io_pbPutNeeded)
/*++

Synopsis: 
    Deletes and recreates SHIPPED_TO_MOF, SHIPPED_NOT_TO_MOF, and
    EXTENDED classes if necessary.  Sets io_pbPutNeeded accordingly.

Arguments: [i_pClass] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pClass          != NULL);
    DBG_ASSERT(io_pbPutNeeded    != NULL);

    HRESULT  hr               = WBEM_S_NO_ERROR;
    CComPtr<IWbemClassObject> spObj;
    CComBSTR bstrClass        = i_pClass->pszClassName;
    if(bstrClass.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    bool bExtendedQual        = false;
    bool bPutNeeded           = false;

    HRESULT hrGetObject = m_pNamespace->GetObject(
        bstrClass, 
        WBEM_FLAG_RETURN_WBEM_COMPLETE, 
        m_pCtx, 
        &spObj, 
        NULL);
    if( hrGetObject != WBEM_E_INVALID_CLASS && 
        hrGetObject != WBEM_E_NOT_FOUND)
    {
        hr = hrGetObject;
    }
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Determine if the [extended] qualifier is set.
    //
    if(SUCCEEDED(hrGetObject))
    {
        VARIANT  vtExtended;
        VariantInit(&vtExtended);

        HRESULT hrGetQuals = 
            CUtils::GetQualifiers(spObj, &g_wszCq_Extended, &vtExtended, 1);
        if(FAILED(hrGetQuals))
        {
            bExtendedQual = false;
        }
        else if(vtExtended.vt == VT_BOOL)
        {
            bExtendedQual = vtExtended.boolVal ? true : false;
        }
    }

    //
    // Pretty much, don't do a Put class if both the catalog and repository
    // versions are shipped.  This is an optimization for the normal case.
    //
    switch(i_pClass->dwExtended)
    {
    case EXTENDED:
        if( hrGetObject != WBEM_E_INVALID_CLASS && 
            hrGetObject != WBEM_E_NOT_FOUND)
        {
            hr = m_pNamespace->DeleteClass(
                bstrClass,
                WBEM_FLAG_OWNER_UPDATE,
                m_pCtx,
                NULL);
            if(FAILED(hr))
            {
                return hr;
            }
        }
        bPutNeeded = true;
        break;
    case USER_DEFINED_NOT_TO_REPOSITORY:
        bPutNeeded = false;
        break;
    case USER_DEFINED_TO_REPOSITORY:
        if( hrGetObject != WBEM_E_INVALID_CLASS && 
            hrGetObject != WBEM_E_NOT_FOUND)
        {
            //
            // There is already a class in the repository with the same name
            // as this user-defined class.
            // TODO: Log an error.
            //
            bPutNeeded = false;
        }
        else
        {
            bPutNeeded = true;
        }
        break;
    case SHIPPED_TO_MOF:
    case SHIPPED_NOT_TO_MOF:
        if(bExtendedQual)
        {
            if( hrGetObject != WBEM_E_INVALID_CLASS && 
                hrGetObject != WBEM_E_NOT_FOUND)
            {
                hr = m_pNamespace->DeleteClass(
                    bstrClass,
                    WBEM_FLAG_OWNER_UPDATE,
                    m_pCtx,
                    NULL);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            bPutNeeded = true;
        }
        else
        {
            bPutNeeded = (hrGetObject == WBEM_E_INVALID_CLASS || 
                          hrGetObject == WBEM_E_NOT_FOUND) ? true : false;
        }
        break;
    default:
        DBG_ASSERT(false && "Unknown i_pClass->dwExtended");
        break;
    }

    *io_pbPutNeeded = bPutNeeded;

    return hr;
}

HRESULT CPusher::SetClassInfo(
    IWbemClassObject* i_pObj,
    LPCWSTR           i_wszClassName,
    ULONG             i_iShipped)
/*++

Synopsis: 
    Sets class qualifiers and special __CLASS property on i_pObj

Arguments: [i_pObj]         - The class or association
           [i_wszClassName] - Will be value of __CLASS property
           [i_iShipped]     - Determines if we set g_wszCq_Extended qualifier
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pObj            != NULL);
    DBG_ASSERT(i_wszClassName    != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);
    HRESULT     hr;
    CComVariant v;

    //
    // Class qualifiers (propagated to instance)
    //
    hr = CUtils::SetQualifiers(
        i_pObj, 
        m_awszClassQualNames, 
        m_avtClassQualValues, 
        2,
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Another class qualifier (not propagated to instance)
    //
    if(i_iShipped == EXTENDED)
    {
        v = (bool)true;
        hr = CUtils::SetQualifiers(
            i_pObj, 
            &g_wszCq_Extended, 
            &v, 
            1, 
            0);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Special __CLASS property
    //
    v = i_wszClassName;
    if(v.bstrVal == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    hr = i_pObj->Put(g_wszProp_Class, 0, &v, 0);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

HRESULT CPusher::SetMethods(
    const WMI_CLASS*  i_pElement,
    IWbemClassObject* i_pObject) const
/*++

Synopsis: 
    Called by PushClasses.
    Sets the methods in i_pObject using i_pElement

Arguments: [i_pElement] -
           [i_pObject] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement        != NULL);
    DBG_ASSERT(i_pObject         != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(i_pElement->ppMethod == NULL)
    {
        return WBEM_S_NO_ERROR;
    }

    CComPtr<IWbemClassObject> spParamsIn;
    CComPtr<IWbemClassObject> spParamsOut;

    //
    // Run thru all the methods
    //
    WMI_METHOD* pMethCurrent = NULL;
    for(ULONG i = 0; i_pElement->ppMethod[i] != NULL; i++)
    {
        pMethCurrent = i_pElement->ppMethod[i];
        spParamsIn   = NULL;
        spParamsOut  = NULL;

        if(pMethCurrent->ppParams != NULL)
        {
            WMI_METHOD_PARAM* pParamCur = NULL;

            //
            // The index to indicate to WMI the order of the parameters
            // wszId is the qualifier name.  svtId is a variant so we can give to WMI.
            //
            static LPCWSTR    wszId     = L"ID";
            CComVariant       svtId     = (int)0;

            //
            // Run thru all the parameters
            //
            for(ULONG j = 0; pMethCurrent->ppParams[j] != NULL; j++)
            {
                //
                // This will just hold spParamsIn and spParamsOut so we
                // don't need to duplicate the code.
                //
                IWbemClassObject* apParamInOut[] = { NULL, NULL };

                //
                // Create the WMI instance for the in and/or out params as needed.
                //
                pParamCur = pMethCurrent->ppParams[j];
                if( pParamCur->iInOut == PARAM_IN ||
                    pParamCur->iInOut == PARAM_INOUT )
                {
                    if(spParamsIn == NULL)
                    {
                        hr = m_pNamespace->GetObject(L"__Parameters", 0, m_pCtx, &spParamsIn, NULL);
                        if(FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                            goto exit;
                        }
                    }
                    apParamInOut[0] = spParamsIn;
                }
                if( pParamCur->iInOut == PARAM_OUT ||
                    pParamCur->iInOut == PARAM_INOUT )
                {
                    if(spParamsOut == NULL)
                    {
                        hr = m_pNamespace->GetObject(L"__Parameters", 0, m_pCtx, &spParamsOut, NULL);
                        if(FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                            goto exit;
                        }
                    }
                    apParamInOut[1] = spParamsOut;
                }

                //
                // Finally set them.  First ins then outs.
                //
                for(ULONG k = 0; k < 2; k++)
                {
                    if(apParamInOut[k] == NULL)
                    {
                        continue;
                    }
                    hr = apParamInOut[k]->Put(
                        pParamCur->pszParamName, 0, NULL, pParamCur->type);
                    if(FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                        goto exit;
                    }

                    hr = CUtils::SetPropertyQualifiers(
                        apParamInOut[k], pParamCur->pszParamName, &wszId, &svtId, 1);
                    if(FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                        goto exit;
                    }
                }
                if(apParamInOut[0] || apParamInOut[1])
                {
                    svtId.lVal++;
                }
            }
        }

        //
        // Put the method.
        //
        hr = i_pObject->PutMethod(
            pMethCurrent->pszMethodName, 0, spParamsIn, spParamsOut);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
            goto exit;
        }

        VARIANT vImplemented;
        vImplemented.boolVal = VARIANT_TRUE;
        vImplemented.vt      = VT_BOOL;
        hr = CUtils::SetMethodQualifiers(
            i_pObject,
            pMethCurrent->pszMethodName,
            &g_wszMq_Implemented,
            &vImplemented,
            1);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
            goto exit;
        }

        /*if(pMethCurrent->pszDescription)
        {
            VARIANT vDesc;
            vDesc.bstrVal = pMethCurrent->pszDescription;
            vDesc.vt      = VT_BSTR;
            hr = CUtils::SetMethodQualifiers(
                i_pObject, 
                pMethCurrent->pszMethodName, 
                &g_wszMq_Description,
                &vDesc, 
                1);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "CPusher::SetMethods failed, hr=0x%x\n", hr));
                goto exit;
            }
        }*/
    }

exit:
    return hr;
}

HRESULT CPusher::SetProperties(
    const WMI_CLASS*  i_pElement, 
    IWbemClassObject* i_pObject) const
/*++

Synopsis: 
    Called by PushClasses.
    Sets the properties in i_pObject using i_pElement

Arguments: [i_pElement] -
           [i_pObject] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement        != NULL);
    DBG_ASSERT(i_pObject         != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT            hr                = WBEM_S_NO_ERROR;
    METABASE_PROPERTY* pPropCurrent      = NULL;
    TFormattedMultiSz* pFormattedMultiSz = NULL;
    CIMTYPE typeProp;

    CComPtr<IWbemQualifierSet> spQualSet;
    VARIANT v;
    VariantInit(&v);

    if(i_pElement->ppmbp == NULL)
    {
        return hr;
    }

    for(ULONG i = 0; i_pElement->ppmbp[i] != NULL; i++)
    {
        pPropCurrent      = i_pElement->ppmbp[i];
        pFormattedMultiSz = NULL;
        switch(pPropCurrent->dwMDDataType)
        {
        case DWORD_METADATA:
            if(pPropCurrent->dwMDMask != 0)
            {
                typeProp = CIM_BOOLEAN;
            }
            else
            {
                typeProp = CIM_SINT32;
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            typeProp = CIM_STRING;
            break;
        case MULTISZ_METADATA:
            typeProp = VT_ARRAY | CIM_STRING;
            
            pFormattedMultiSz = 
                TFormattedMultiSzData::Find(pPropCurrent->dwMDIdentifier);
            if(pFormattedMultiSz)
            {
                typeProp = VT_ARRAY | CIM_OBJECT;
            }
            break;
        case BINARY_METADATA:
            typeProp = VT_ARRAY | CIM_UINT8;
            break;
        default:
            //
            // Non fatal if we cannot recognize type
            //
            continue;
        }

        hr = i_pObject->Put(pPropCurrent->pszPropName, 0, NULL, typeProp);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // qualifiers
        //
        hr = i_pObject->GetPropertyQualifierSet(pPropCurrent->pszPropName, &spQualSet);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // qualifier for read-only
        //
        V_VT(&v)   = VT_BOOL;
        V_BOOL(&v) = (pPropCurrent->fReadOnly) ? VARIANT_FALSE : VARIANT_TRUE;
        hr = spQualSet->Put(g_wszPq_Write, &v, 0);
        if(FAILED(hr))
        {
            goto exit;
        }
        V_BOOL(&v) = VARIANT_TRUE;
        hr = spQualSet->Put(g_wszPq_Read, &v, 0);
        if(FAILED(hr))
        {
            goto exit;
        }
        VariantClear(&v);

        //
        // CIMType qualifier
        //
        if(pFormattedMultiSz)
        {
            DBG_ASSERT(typeProp == (VT_ARRAY | CIM_OBJECT));

            CComBSTR sbstrValue = L"object:";
            if(sbstrValue.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
            sbstrValue += pFormattedMultiSz->wszWmiClassName;
            if(sbstrValue.m_str == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }

            //
            // Deliberately not smart variant.  We will let sbstrValue do deconstruction.
            //
            VARIANT vValue;
            vValue.vt      = VT_BSTR;
            vValue.bstrVal = sbstrValue;
            hr = spQualSet->Put(g_wszPq_CimType, &vValue, 0);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

        spQualSet = NULL;
    }

exit:
    VariantClear(&v);
    return hr;
}

HRESULT CPusher::SetAssociationComponent(
    IWbemClassObject* i_pObject, 
    LPCWSTR           i_wszComp, 
    LPCWSTR           i_wszClass) const
/*++

Synopsis: 
    Called by PushAssocs
    Sets a ref property of an association, i_pObj, using i_wszComp and i_wszClass

Arguments: [i_pObject] - the association
           [i_wszComp] - property name (Eg. Group, Part)
           [i_wszClass] - the class we are "ref"fing to.
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pObject         != NULL);
    DBG_ASSERT(i_wszComp         != NULL);
    DBG_ASSERT(i_wszClass        != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT                    hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemQualifierSet> spQualSet;
    VARIANT                    v;
    VariantInit(&v);

    //
    // Store "Ref:[class name]" in a bstr.
    //
    ULONG                      cchClass = wcslen(i_wszClass);
    CComBSTR                   sbstrClass(4 + cchClass);
    if(sbstrClass.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    memcpy(sbstrClass.m_str    , L"Ref:",    sizeof(WCHAR)*4);
    memcpy(sbstrClass.m_str + 4, i_wszClass, sizeof(WCHAR)*(cchClass+1));

    //
    // Put the property (Eg. Group, Part, etc.)
    //
    hr = i_pObject->Put(i_wszComp, 0, NULL, CIM_REFERENCE);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Set Qualifiers on the property
    //
    hr = i_pObject->GetPropertyQualifierSet(i_wszComp, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    hr = spQualSet->Put(g_wszPq_Key, &v, 0);
    if(FAILED(hr))
    {
        goto exit;
    }

    V_VT(&v)   = VT_BSTR;
    V_BSTR(&v) = sbstrClass.m_str;
    if(V_BSTR(&v) == NULL)
    {
        V_VT(&v) = VT_EMPTY;
        hr       = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    hr = spQualSet->Put(g_wszPq_CimType, &v, 0);
    V_VT(&v)   = VT_EMPTY;
    V_BSTR(&v) = NULL;
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

bool CPusher::NeedToDeleteAssoc(
    IWbemClassObject*  i_pObj) const
/*++

Synopsis: 
    Sees if the association i_pObj is already in hashtable.
    If it is, no point in deleting i_pObj from repository only to recreate
    it later.

Arguments: [i_pObj] -   An IWbemClassObject representation of an assoc
           
Return Value: 
    true  if i_pObj not in hashtable
    false otherwise

--*/
{
    DBG_ASSERT(i_pObj            != NULL);
    DBG_ASSERT(g_pDynSch         != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT     hr     = WBEM_S_NO_ERROR;
    bool        bMatch = false;
    
    CComVariant vt;
    LPWSTR      wsz;

    CComPtr<IWbemQualifierSet>     spQualSet;

    CHashTable<WMI_ASSOCIATION *>* pHash  = g_pDynSch->GetHashAssociations();
    WMI_ASSOCIATION*               pAssoc;

    DBG_ASSERT(pHash != NULL);

    //
    // Compare the association names
    //
    hr = i_pObj->Get(g_wszProp_Class, 0, &vt, NULL, NULL);
    if(FAILED(hr) || vt.vt != VT_BSTR)
    {
        goto exit;
    }
    hr = pHash->Wmi_GetByKey(vt.bstrVal, &pAssoc);
    if(FAILED(hr))
    {
        goto exit;
    }
    vt.Clear();

    //
    // This is the only case we care about
    //
    if(pAssoc->dwExtended != USER_DEFINED_TO_REPOSITORY)
    {
        goto exit;
    }

    //
    // Compare the left association component
    //
    hr = i_pObj->GetPropertyQualifierSet(
        pAssoc->pType->pszLeft,
        &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }
    spQualSet->Get(g_wszPq_CimType, 0, &vt, NULL);
    spQualSet = NULL;
    if(FAILED(hr) || vt.vt != VT_BSTR)
    {
        goto exit;
    }
    if( (wsz = wcschr(vt.bstrVal, L':')) == NULL )
    {
        goto exit;
    }
    wsz++;
    if(_wcsicmp(wsz, pAssoc->pcLeft->pszClassName) != 0)
    {
        goto exit;
    }
    vt.Clear();

    //
    // Compare the right association component
    //
    hr = i_pObj->GetPropertyQualifierSet(
        pAssoc->pType->pszRight,
        &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }
    spQualSet->Get(g_wszPq_CimType, 0, &vt, NULL);
    spQualSet = NULL;
    if(FAILED(hr) || vt.vt != VT_BSTR)
    {
        goto exit;
    }
    if( (wsz = wcschr(vt.bstrVal, L':')) == NULL )
    {
        goto exit;
    }
    wsz++;
    if(_wcsicmp(wsz, pAssoc->pcRight->pszClassName) != 0)
    {
        goto exit;
    }
    vt.Clear();

    bMatch = true;
    pAssoc->dwExtended = USER_DEFINED_NOT_TO_REPOSITORY;

exit:
    return !bMatch;
}

HRESULT CPusher::DeleteChildren(LPCWSTR i_wszExtSuperClass)
{
    DBG_ASSERT(i_wszExtSuperClass != NULL);
    DBG_ASSERT(m_bInitSuccessful  == true);

    //
    // Only can be called from inside Initialize
    //
    DBG_ASSERT(m_bInitCalled      == true);
    DBG_ASSERT(m_bInitSuccessful  == true);

    IEnumWbemClassObject*pEnum     = NULL;
    HRESULT              hr        = WBEM_S_NO_ERROR;

    IWbemClassObject*    apObj[10] = {0};
    ULONG                nrObj     = 0;
    ULONG                i = 0;

    VARIANT              v;
    VariantInit(&v);

    CComBSTR bstrExtSuperClass = i_wszExtSuperClass;
    if(bstrExtSuperClass.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    hr = m_pNamespace->CreateClassEnum(
        bstrExtSuperClass, 
        WBEM_FLAG_FORWARD_ONLY, 
        m_pCtx,
        &pEnum);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = pEnum->Next(WBEM_INFINITE, 10, apObj, &nrObj);
    while(SUCCEEDED(hr) && nrObj > 0)
    {
        for(i = 0; i < nrObj; i++)
        {
            bool bDelete;
            if( i_wszExtSuperClass == g_wszExtElementSettingAssocParent ||
                i_wszExtSuperClass == g_wszExtGroupPartAssocParent)
            {
                bDelete = NeedToDeleteAssoc(apObj[i]);
            }
            else
            {
                bDelete = true;
            }
            if(bDelete)
            {
                hr = apObj[i]->Get(g_wszProp_Class, 0, &v, NULL, NULL);
                if(FAILED(hr))
                {
                    goto exit;
                }

                hr = m_pNamespace->DeleteClass(v.bstrVal, WBEM_FLAG_OWNER_UPDATE, m_pCtx, NULL);
                if(FAILED(hr))
                {
                    goto exit;
                }

                VariantClear(&v);
            }
            apObj[i]->Release();
            apObj[i] = NULL;
        }
        
        hr = pEnum->Next(WBEM_INFINITE, 10, apObj, &nrObj);
    }
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(pEnum)
    {
        pEnum->Release();
        pEnum = NULL;
    }
    VariantClear(&v);
    for(i = 0; i < 10; i++)
    {
        if(apObj[i])
        {
            apObj[i]->Release();
        }
    }
    return hr;
}

HRESULT CPusher::GetObject(
    LPCWSTR            i_wszClass, 
    IWbemClassObject** o_ppObj)
{
    DBG_ASSERT(o_ppObj != NULL);
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject* pObject;

    if(i_wszClass == g_wszExtElementParent)
    {
        *o_ppObj = m_spBaseElementObject;
        (*o_ppObj)->AddRef();
    }
    else if(i_wszClass == g_wszExtSettingParent)
    {
        *o_ppObj = m_spBaseSettingObject;
        (*o_ppObj)->AddRef();
    }
    else if(i_wszClass == g_wszExtElementSettingAssocParent)
    {
        *o_ppObj = m_spBaseElementSettingObject;
        (*o_ppObj)->AddRef();
    }
    else if(i_wszClass == g_wszExtGroupPartAssocParent)
    {
        *o_ppObj = m_spBaseGroupPartObject;
        (*o_ppObj)->AddRef();
    }
    else
    {
        const CComBSTR sbstrClass = i_wszClass;
        if(sbstrClass.m_str == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        hr = m_pNamespace->GetObject(sbstrClass, 0, m_pCtx, &pObject, NULL);
        if(FAILED(hr))
        {
            goto exit;
        }
        *o_ppObj = pObject;
    }

exit:
    return hr;
}

/*HRESULT CPusher::NeedToPutAssoc(
    WMI_ASSOCIATION* i_pAssoc,
    bool*            io_pbPutNeeded)
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pAssoc          != NULL);
    DBG_ASSERT(io_pbPutNeeded    != NULL);

    HRESULT  hr               = WBEM_S_NO_ERROR;
    CComBSTR bstrAssoc;
    bool bExtendedQual        = false;
    bool bPutNeeded           = false;

    if(i_pAssoc->dwExtended != USER_DEFINED_TO_REPOSITORY)
    {
        goto exit;
    }
    
    bstrAssoc = i_pAssoc->pszAssociationName;
    if(bstrAssoc.m_str == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    HRESULT hrGetObject = m_pNamespace->GetObject(
        bstrAssoc, 
        WBEM_FLAG_RETURN_WBEM_COMPLETE, 
        m_pCtx, 
        NULL, 
        NULL);
    if( hrGetObject != WBEM_E_INVALID_CLASS && 
        hrGetObject != WBEM_E_NOT_FOUND)
    {
        hr = hrGetObject;
    }
    if(FAILED(hr))
    {
        goto exit;
    }

    if( hrGetObject == WBEM_E_INVALID_CLASS ||
        hrGetObject == WBEM_E_NOT_FOUND )
    {
        bPutNeeded = true;
    }

exit:
    if(SUCCEEDED(hr))
    {
        *io_pbPutNeeded = bPutNeeded;
    }
    return hr;
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\schema.h ===
#ifndef _schema_h_
#define _schema_h_

#include "globalconstants.h"

//
// Forward declarations
//
struct METABASE_KEYTYPE;
struct METABASE_KEYTYPE_NODE;


//
// DataTypes
//
struct METABASE_KEYTYPE
{
    //
    // Not populated automatically for static data
    //
    LPWSTR m_pszName; 

    //
    // This is the list of keytypes that can contain this keytype
    // (the opposite of the container class list)
    //
    // Populated automatically even for static data
    //
    METABASE_KEYTYPE_NODE* m_pKtListInverseCCL;

    //
    // Not populated automatically for static data
    //
    LPCWSTR m_pszDisallowDeletionNode;
};

struct METABASE_KEYTYPE_NODE
{
    const METABASE_KEYTYPE* m_pKt;
    METABASE_KEYTYPE_NODE*  m_pKtNext;
};

struct WMI_METHOD_PARAM
{
    LPWSTR   pszParamName;
    CIMTYPE  type;
    ULONG    iInOut;
};

struct WMI_METHOD 
{
    LPWSTR   pszMethodName;
    DWORD    dwMDId;
    
    LPWSTR             pszRetType;
    WMI_METHOD_PARAM** ppParams;

    LPWSTR   pszDescription;
};

struct METABASE_PROPERTY
{
    LPWSTR pszPropName;
    DWORD  dwMDIdentifier;
    DWORD  dwMDUserType; 
    DWORD  dwMDDataType; 
    DWORD  dwMDMask;  // if this is set to all bits on, it means this is bool, but not part of a flag.
    DWORD  dwMDAttributes;
    BOOL   fReadOnly;

    // if DWORD_METADATA, pDefaultValue points to the above dwDefaultValue.
    // otherwise it points to memory in pool.
    LPVOID pDefaultValue;

    // used for DWORD_METADATA
    DWORD  dwDefaultValue;
}; 

struct WMI_CLASS
{
    LPWSTR               pszClassName;
    LPWSTR               pszMetabaseKey;
    LPWSTR               pszKeyName;
    METABASE_PROPERTY**  ppmbp;
    METABASE_KEYTYPE*    pkt;
    WMI_METHOD**         ppMethod;
    DWORD                dwExtended;

    // This is only set for hardcoded wmi classes.  Otherwise, the defaults
    // at the top of this file are used.
    LPWSTR               pszParentClass;

    //
    // Whether we let users create instances of this class.
    // Some examples where this is false are IIsFtpService, IIsWebService, etc.
    //
    bool                 bCreateAllowed;

    // This pointer is only valid during initialization time.
    // It points to mbschema.bin
    LPWSTR               pszDescription;
}; 

struct WMI_ASSOCIATION_TYPE
{
    LPWSTR pszLeft;
    LPWSTR pszRight;

    LPWSTR pszParent;
    LPWSTR pszExtParent;
};

struct WMI_ASSOCIATION 
{
    LPWSTR                    pszAssociationName;
    WMI_CLASS*                pcLeft;
    WMI_CLASS*                pcRight;
    WMI_ASSOCIATION_TYPE      *pType;
    DWORD                     fFlags;
    DWORD                     dwExtended;
    
    LPWSTR                    pszParentClass;
};


//
// Hardcoded Data
//
struct METABASE_KEYTYPE_DATA
{
    static METABASE_KEYTYPE s_IIsApplicationPool;
    static METABASE_KEYTYPE s_IIsApplicationPools;
    static METABASE_KEYTYPE s_IIsCertMapper;
    static METABASE_KEYTYPE s_IIsCompressionScheme;
    static METABASE_KEYTYPE s_IIsCompressionSchemes;
    static METABASE_KEYTYPE s_IIsComputer;
    static METABASE_KEYTYPE s_IIsCustomLogModule;
    static METABASE_KEYTYPE s_IIsFilter;
    static METABASE_KEYTYPE s_IIsFilters;
    static METABASE_KEYTYPE s_IIsFtpInfo;
    static METABASE_KEYTYPE s_IIsFtpServer;
    static METABASE_KEYTYPE s_IIsFtpService;
    static METABASE_KEYTYPE s_IIsFtpVirtualDir;
    static METABASE_KEYTYPE s_IIsImapInfo;
    static METABASE_KEYTYPE s_IIsImapService;
    static METABASE_KEYTYPE s_IIsLogModule;
    static METABASE_KEYTYPE s_IIsLogModules;
    static METABASE_KEYTYPE s_IIsMimeMap;
    static METABASE_KEYTYPE s_IIsNntpInfo;
    static METABASE_KEYTYPE s_IIsNntpService;
    static METABASE_KEYTYPE s_IIsObject;
    static METABASE_KEYTYPE s_IIsPop3Info;
    static METABASE_KEYTYPE s_IIsPop3Service;
    static METABASE_KEYTYPE s_IIsSmtpInfo;
    static METABASE_KEYTYPE s_IIsSmtpService;
    static METABASE_KEYTYPE s_IIsWebDirectory;
    static METABASE_KEYTYPE s_IIsWebFile;
    static METABASE_KEYTYPE s_IIsWebInfo;
    static METABASE_KEYTYPE s_IIsWebServer;
    static METABASE_KEYTYPE s_IIsWebService;
    static METABASE_KEYTYPE s_IIsWebVirtualDir;

    static METABASE_KEYTYPE s_TYPE_AdminACL;
    static METABASE_KEYTYPE s_TYPE_AdminACE;
    static METABASE_KEYTYPE s_TYPE_IPSecurity;
    static METABASE_KEYTYPE s_NO_TYPE;

    static METABASE_KEYTYPE* s_MetabaseKeyTypes[];
};

struct METABASE_PROPERTY_DATA
{
    static METABASE_PROPERTY s_KeyType;
    static METABASE_PROPERTY s_ServerComment;
    static METABASE_PROPERTY s_ServerBindings;
    static METABASE_PROPERTY s_Path;
    static METABASE_PROPERTY s_AppRoot;

    static METABASE_PROPERTY* s_MetabaseProperties[];
};

struct WMI_METHOD_PARAM_DATA
{
    static WMI_METHOD_PARAM s_Applications;
    static WMI_METHOD_PARAM s_AppMode;
    static WMI_METHOD_PARAM s_BackupDateTimeOut;
    static WMI_METHOD_PARAM s_BackupFlags;
    static WMI_METHOD_PARAM s_BackupLocation;
    static WMI_METHOD_PARAM s_BackupLocation_io;
    static WMI_METHOD_PARAM s_BackupVersion;
    static WMI_METHOD_PARAM s_BackupVersionOut;
    static WMI_METHOD_PARAM s_DestPath;
    static WMI_METHOD_PARAM s_EnumIndex;
    static WMI_METHOD_PARAM s_FileName;
    static WMI_METHOD_PARAM s_HistoryTime;
    static WMI_METHOD_PARAM s_IEnabled;
    static WMI_METHOD_PARAM s_IEnabled_o;
    static WMI_METHOD_PARAM s_IMethod;
    static WMI_METHOD_PARAM s_IndexIn;
    static WMI_METHOD_PARAM s_InProcFlag;
    static WMI_METHOD_PARAM s_AppPoolName;
    static WMI_METHOD_PARAM s_bCreate;
    static WMI_METHOD_PARAM s_MajorVersion;
    static WMI_METHOD_PARAM s_MajorVersion_o;
    static WMI_METHOD_PARAM s_MDFlags;
    static WMI_METHOD_PARAM s_MDHistoryLocation;
    static WMI_METHOD_PARAM s_MDHistoryLocation_io;
    static WMI_METHOD_PARAM s_MinorVersion;
    static WMI_METHOD_PARAM s_MinorVersion_o;
    static WMI_METHOD_PARAM s_NtAcct;
    static WMI_METHOD_PARAM s_NtAcct_o;
    static WMI_METHOD_PARAM s_NtPwd;
    static WMI_METHOD_PARAM s_NtPwd_o;
    static WMI_METHOD_PARAM s_Password;
    static WMI_METHOD_PARAM s_Passwd;
    static WMI_METHOD_PARAM s_PathOfRootVirtualDir;
    static WMI_METHOD_PARAM s_Recursive;
    static WMI_METHOD_PARAM s_ServerComment;
    static WMI_METHOD_PARAM s_ServerBindings;
    static WMI_METHOD_PARAM s_ServerId;
    static WMI_METHOD_PARAM s_ServerMode;
    static WMI_METHOD_PARAM s_SourcePath;
    static WMI_METHOD_PARAM s_strName;
    static WMI_METHOD_PARAM s_strName_o;
    static WMI_METHOD_PARAM s_vCert;
    static WMI_METHOD_PARAM s_vCert_o;
    static WMI_METHOD_PARAM s_vKey;

    static WMI_METHOD_PARAM* s_ServiceCreateNewServer[];
    static WMI_METHOD_PARAM* s_GetCurrentMode[];

    static WMI_METHOD_PARAM* s_AppCreate[];
    static WMI_METHOD_PARAM* s_AppCreate2[];
    static WMI_METHOD_PARAM* s_AppDelete[];
    static WMI_METHOD_PARAM* s_AppUnLoad[];
    static WMI_METHOD_PARAM* s_AppDisable[];
    static WMI_METHOD_PARAM* s_AppEnable[];

    static WMI_METHOD_PARAM* s_BackupWithPasswd[];
    static WMI_METHOD_PARAM* s_DeleteBackup[];
    static WMI_METHOD_PARAM* s_EnumBackups[];
    static WMI_METHOD_PARAM* s_RestoreWithPasswd[];
    static WMI_METHOD_PARAM* s_Export[];
    static WMI_METHOD_PARAM* s_Import[];
    static WMI_METHOD_PARAM* s_RestoreHistory[];
    static WMI_METHOD_PARAM* s_EnumHistory[];

    static WMI_METHOD_PARAM* s_CreateMapping[];
    static WMI_METHOD_PARAM* s_DeleteMapping[];
    static WMI_METHOD_PARAM* s_GetMapping[];
    static WMI_METHOD_PARAM* s_SetAcct[];
    static WMI_METHOD_PARAM* s_SetEnabled[];
    static WMI_METHOD_PARAM* s_SetName[];
    static WMI_METHOD_PARAM* s_SetPwd[];

    static WMI_METHOD_PARAM* s_EnumAppsInPool[];
};

struct WMI_METHOD_DATA
{
    static WMI_METHOD s_ServiceCreateNewServer;
    static WMI_METHOD s_GetCurrentMode;

    static WMI_METHOD s_ServerStart;
    static WMI_METHOD s_ServerStop;
    static WMI_METHOD s_ServerContinue;
    static WMI_METHOD s_ServerPause;

    static WMI_METHOD s_AppCreate;
    static WMI_METHOD s_AppCreate2;
    static WMI_METHOD s_AppDelete;
    static WMI_METHOD s_AppUnLoad;
    static WMI_METHOD s_AppDisable;
    static WMI_METHOD s_AppEnable;
    static WMI_METHOD s_AppGetStatus;
    static WMI_METHOD s_AspAppRestart;

    static WMI_METHOD s_SaveData;
    static WMI_METHOD s_BackupWithPasswd;
    static WMI_METHOD s_DeleteBackup;
    static WMI_METHOD s_EnumBackups;
    static WMI_METHOD s_RestoreWithPasswd;
    static WMI_METHOD s_Export;
    static WMI_METHOD s_Import;
    static WMI_METHOD s_RestoreHistory;
    static WMI_METHOD s_EnumHistory;

    static WMI_METHOD s_CreateMapping;
    static WMI_METHOD s_DeleteMapping;
    static WMI_METHOD s_GetMapping;
    static WMI_METHOD s_SetAcct;
    static WMI_METHOD s_SetEnabled;
    static WMI_METHOD s_SetName;
    static WMI_METHOD s_SetPwd;

    static WMI_METHOD s_EnumAppsInPool;
    static WMI_METHOD s_RecycleAppPool;
    static WMI_METHOD s_Start;
    static WMI_METHOD s_Stop;

    static WMI_METHOD* s_WebServiceMethods[];
    static WMI_METHOD* s_ServiceMethods[];
    static WMI_METHOD* s_ServerMethods[];
    static WMI_METHOD* s_WebAppMethods[];
    static WMI_METHOD* s_ComputerMethods[];
    static WMI_METHOD* s_CertMapperMethods[];
    static WMI_METHOD* s_AppPoolMethods[];
};

struct WMI_CLASS_DATA
{
    static WMI_CLASS s_Computer;
    static WMI_CLASS s_ComputerSetting;
    static WMI_CLASS s_FtpService;
    static WMI_CLASS s_FtpServer;
    static WMI_CLASS s_FtpVirtualDir;
    static WMI_CLASS s_WebService;
    static WMI_CLASS s_WebFilter;
    static WMI_CLASS s_WebServer;
    static WMI_CLASS s_WebCertMapper;
    static WMI_CLASS s_WebVirtualDir;
    static WMI_CLASS s_WebDirectory;
    static WMI_CLASS s_WebFile;
    static WMI_CLASS s_ApplicationPool;

    static WMI_CLASS s_AdminACL;
    static WMI_CLASS s_ACE;
    static WMI_CLASS s_IPSecurity;

    static WMI_CLASS* s_WmiClasses[];
};

struct WMI_ASSOCIATION_TYPE_DATA
{
    static WMI_ASSOCIATION_TYPE s_ElementSetting;
    static WMI_ASSOCIATION_TYPE s_Component;
    static WMI_ASSOCIATION_TYPE s_AdminACL;
    static WMI_ASSOCIATION_TYPE s_IPSecurity;
};

struct WMI_ASSOCIATION_DATA
{
    static WMI_ASSOCIATION s_AdminACLToACE;
    static WMI_ASSOCIATION* s_WmiAssociations[];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\schemadynamic.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemadynamic.cpp

Abstract:

    This file contains the implementation of the CDynSchema class.
    This class contains the dynamic schema structures.
    It also contains the rules for populating the schema structures.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#include "iisprov.h"

#define USE_DEFAULT_VALUES
#define USE_DEFAULT_BINARY_VALUES

CDynSchema* g_pDynSch = NULL;

HRESULT CDynSchema::Initialize()
/*++

Synopsis: 
    If fails, object must be destroyed.
    If succeeds, object is ready for use.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == false);
    DBG_ASSERT(m_bInitSuccessful == false);

    HRESULT hr = WBEM_S_NO_ERROR;

    m_bInitCalled = true;

    hr = m_hashProps.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }
    
    hr = m_hashClasses.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_hashAssociations.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_hashKeyTypes.Wmi_Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolAssociations.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolClasses.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolProps.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolKeyTypes.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_poolKeyTypeNodes.Initialize(10);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_spoolStrings.Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_apoolPMbp.Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_apoolBytes.Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        m_bInitSuccessful = true;
    }
    return hr;
}

HRESULT CDynSchema::RulePopulateFromStatic()
/*++

Synopsis: 
    Populates hashtables with pointers to hardcoded schema.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // Populate Properties
    //
    if(METABASE_PROPERTY_DATA::s_MetabaseProperties != NULL)
    {
        METABASE_PROPERTY* pStatMbpCurrent;
        for(ULONG i = 0; ; i++)
        {
            pStatMbpCurrent = METABASE_PROPERTY_DATA::s_MetabaseProperties[i];
            if(pStatMbpCurrent == NULL)
            {
                break;
            }
            hr = m_hashProps.Wmi_Insert(pStatMbpCurrent->pszPropName, pStatMbpCurrent);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

    //
    // Populate KeyTypes
    //
    METABASE_KEYTYPE** apMetabaseKeyTypes;
    apMetabaseKeyTypes = METABASE_KEYTYPE_DATA::s_MetabaseKeyTypes;
    for(ULONG i = 0; apMetabaseKeyTypes[i] != NULL; i++)
    {
        if( apMetabaseKeyTypes[i]->m_pszName != NULL )
        {
            apMetabaseKeyTypes[i]->m_pKtListInverseCCL = NULL;
            hr = m_hashKeyTypes.Wmi_Insert(apMetabaseKeyTypes[i]->m_pszName,
                apMetabaseKeyTypes[i]);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

exit:
    return hr;
}

HRESULT CDynSchema::Rule2PopulateFromStatic()
/*++

Synopsis: 
    Populates hashtables with pointers to hardcoded schema.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);    

    HRESULT hr = S_OK;
    int i;

    //
    // Populate Classes
    //
    WMI_CLASS* pStatWmiClassCurrent;
    for(i = 0; ; i++)
    {
        pStatWmiClassCurrent = WMI_CLASS_DATA::s_WmiClasses[i];
        if(pStatWmiClassCurrent == NULL)
        {
            break;
        }
        hr = m_hashClasses.Wmi_Insert(
            pStatWmiClassCurrent->pszClassName,
            pStatWmiClassCurrent);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Populate Associations
    //
    WMI_ASSOCIATION* pStatWmiAssocCurrent;
    for(i = 0; ; i++)
    {
        pStatWmiAssocCurrent = WMI_ASSOCIATION_DATA::s_WmiAssociations[i];
        if(pStatWmiAssocCurrent == NULL)
        {
            break;
        }
        hr = m_hashAssociations.Wmi_Insert(
            pStatWmiAssocCurrent->pszAssociationName, 
            pStatWmiAssocCurrent);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CDynSchema::RuleKeyType(
    const CTableMeta *i_pTableMeta)
/*++

Synopsis: 
    If not already in hashtable of keytypes, a keytype structure
    is allocated thru the keytype pool.  Then, a pointer to it is inserted
    in hashtable.

Arguments: [i_pTableMeta] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta != NULL);

    HRESULT           hr     = WBEM_S_NO_ERROR;
    HRESULT           hrTemp = WBEM_S_NO_ERROR;
    METABASE_KEYTYPE* pktNew;
    LPWSTR            wszNew;

    hrTemp = m_hashKeyTypes.Wmi_GetByKey(
        i_pTableMeta->TableMeta.pInternalName,
        &pktNew);
    if(FAILED(hrTemp))
    {
        hr = m_spoolStrings.GetNewString(i_pTableMeta->TableMeta.pInternalName, &wszNew);
        if(FAILED(hr))
        {
            goto exit;
        }
        hr = m_poolKeyTypes.GetNewElement(&pktNew);
        if(FAILED(hr))
        {
            goto exit;
        }
        pktNew->m_pszName           = wszNew;
        pktNew->m_pKtListInverseCCL = NULL;
        m_hashKeyTypes.Wmi_Insert(wszNew, pktNew);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CDynSchema::RuleWmiClassDescription(
    const CTableMeta* i_pTableMeta, 
    WMI_CLASS*        i_pElementClass, 
    WMI_CLASS*        i_pSettingClass) const
/*++

Synopsis:
    Sets WMI_CLASS::pDescription if needed.
    This pointer will be invalid after initialization since it points to 
    catalog.

Arguments: [i_pTableMeta] -
           [i_pElementClass] -
           [i_pSettingClass] -

Return Value:

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta      != NULL);
    DBG_ASSERT(i_pElementClass   != NULL);
    DBG_ASSERT(i_pSettingClass   != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    if(i_pTableMeta->TableMeta.pDescription != NULL)
    {
        i_pElementClass->pszDescription = i_pTableMeta->TableMeta.pDescription;
        i_pSettingClass->pszDescription = i_pTableMeta->TableMeta.pDescription;
    }

    return hr;
}

HRESULT CDynSchema::RuleWmiClass(
    const CTableMeta* i_pTableMeta,
    WMI_CLASS**       o_ppElementClass,
    WMI_CLASS**       o_ppSettingClass,
    DWORD             io_adwIgnoredProps[])
/*++

Synopsis: 
    Creates an Element and Setting class based on 
    i_pTableMeta->TableMeta.pInternalName.  If not in hashtable of classes,
    these classes are inserted.

    At bottom,
        RuleProperties is called to set up list of properties for each class.

Arguments: [i_pTableMeta] - 
           [o_ppElementClass] - can be NULL
           [o_ppSettingClass] - can be NULL
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta      != NULL);

    WMI_CLASS* pWmiClass = NULL;
    WMI_CLASS* pWmiSettingsClass = NULL;
    LPWSTR wszClassName, wszSettingsClassName;
    LPWSTR wszParentClassName, wszParentSettingsClassName;
    HRESULT hr     = WBEM_S_NO_ERROR;
    HRESULT hrTemp = WBEM_S_NO_ERROR;

    ULONG cPropsAndTagsRW = 0;
    ULONG cPropsAndTagsRO = 0;

    ULONG iShipped = 0;

    CColumnMeta* pColumnMeta;
    ULONG  cchTable;

    //
    // Ignore table if it has no name
    //
    if(i_pTableMeta->TableMeta.pInternalName == NULL)
    {
        hr = WBEM_S_NO_ERROR;
        goto exit;
    }

    //
    // Determine iShipped and Parent Classes
    //
    if(fTABLEMETA_USERDEFINED & *i_pTableMeta->TableMeta.pSchemaGeneratorFlags)
    {
        iShipped                   = USER_DEFINED_TO_REPOSITORY;
        DBG_ASSERT(iShipped != USER_DEFINED_NOT_TO_REPOSITORY);
        wszParentClassName         = g_wszExtElementParent;
        wszParentSettingsClassName = g_wszExtSettingParent;
    }
    else
    {
        if(fTABLEMETA_EXTENDED & *i_pTableMeta->TableMeta.pSchemaGeneratorFlags)
        {
            iShipped = EXTENDED;
        }
        else
        {
            iShipped = SHIPPED_TO_MOF;
        }
        wszParentClassName = g_wszElementParent;
        wszParentSettingsClassName = g_wszSettingParent;
    }

    //
    // Determine number of RO and RW properties
    //
    for(ULONG idxProps = 0; idxProps < i_pTableMeta->ColCount(); idxProps++)
    {
        pColumnMeta = i_pTableMeta->paColumns[idxProps];
        if(*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
            fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
        {
            cPropsAndTagsRW += pColumnMeta->cNrTags + 1;
        }
        else
        {
            cPropsAndTagsRO += pColumnMeta->cNrTags + 1;
        }
    }

    cchTable = wcslen(i_pTableMeta->TableMeta.pInternalName);

    //
    // The keytype should already exist.
    //
    METABASE_KEYTYPE* pktTemp;
    hrTemp = m_hashKeyTypes.Wmi_GetByKey(i_pTableMeta->TableMeta.pInternalName, &pktTemp);
    if( FAILED(hrTemp) )
    {
        goto exit;
    }

    //
    // The Element class (named PrefixC)
    //
    hr = m_spoolStrings.GetNewArray(g_cchIIs_+cchTable+1, &wszClassName);
    if(FAILED(hr))
    {
        goto exit;
    }
    memcpy(wszClassName, g_wszIIs_, sizeof(WCHAR)*g_cchIIs_);
    memcpy(&wszClassName[g_cchIIs_], 
        i_pTableMeta->TableMeta.pInternalName, 
        sizeof(WCHAR)*(cchTable+1));

    if(FAILED(m_hashClasses.Wmi_GetByKey(wszClassName, &pWmiClass)))
    {
        hr = m_poolClasses.GetNewElement(&pWmiClass);
        if(FAILED(hr))
        {
            goto exit;
        }
        pWmiClass->pkt            = pktTemp;
        pWmiClass->pszClassName   = wszClassName;
        pWmiClass->pszMetabaseKey = L"/LM";
        pWmiClass->pszKeyName     = L"Name";
        pWmiClass->ppMethod       = NULL;
        pWmiClass->pszParentClass = wszParentClassName;
        pWmiClass->bCreateAllowed = true;
        pWmiClass->pszDescription = NULL;

        hr = m_hashClasses.Wmi_Insert(wszClassName, pWmiClass);
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    pWmiClass->ppmbp          = NULL;
    pWmiClass->dwExtended     = iShipped;

    //
    // The Settings class (named PrefixCSetting)
    //
    hr = m_spoolStrings.GetNewArray(g_cchIIs_+cchTable+g_cchSettings+1, &wszSettingsClassName);
    if(FAILED(hr))
    {
        goto exit;
    }
    memcpy(wszSettingsClassName, g_wszIIs_, sizeof(WCHAR)*g_cchIIs_);
    memcpy(&wszSettingsClassName[g_cchIIs_], 
        i_pTableMeta->TableMeta.pInternalName, 
        sizeof(WCHAR)*cchTable);
    memcpy(&wszSettingsClassName[g_cchIIs_+cchTable],
        g_wszSettings,
        sizeof(WCHAR)*(g_cchSettings+1));

    if(FAILED(m_hashClasses.Wmi_GetByKey(wszSettingsClassName, &pWmiSettingsClass)))
    {
        hr = m_poolClasses.GetNewElement(&pWmiSettingsClass);
        if(FAILED(hr))
        {
            goto exit;
        }
        pWmiSettingsClass->pkt            = pktTemp;
        pWmiSettingsClass->pszClassName   = wszSettingsClassName;
        pWmiSettingsClass->pszMetabaseKey = L"/LM";
        pWmiSettingsClass->pszKeyName     = L"Name";
        pWmiSettingsClass->ppMethod       = NULL;
        pWmiSettingsClass->pszParentClass = wszParentSettingsClassName;
        pWmiSettingsClass->bCreateAllowed = true;
        pWmiSettingsClass->pszDescription = NULL;

        hr = m_hashClasses.Wmi_Insert(wszSettingsClassName, pWmiSettingsClass);
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    pWmiSettingsClass->ppmbp          = NULL;
    pWmiSettingsClass->dwExtended     = iShipped;

    //
    // Fill in the ppmbp field
    //
    hr = RuleProperties(
        i_pTableMeta,
        cPropsAndTagsRO, 
        pWmiClass,
        cPropsAndTagsRW, 
        pWmiSettingsClass,
        io_adwIgnoredProps);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        if(o_ppElementClass != NULL)
        {
            *o_ppElementClass = pWmiClass;
        }
        if(o_ppSettingClass != NULL)
        {
            *o_ppSettingClass = pWmiSettingsClass;
        }
    }
    return hr;
}

HRESULT CDynSchema::RuleProperties(
    const CTableMeta*          i_pTableMeta, 
    ULONG                      i_cPropsAndTagsRO,
    WMI_CLASS*                 io_pWmiClass,
    ULONG                      i_cPropsAndTagsRW,
    WMI_CLASS*                 io_pWmiSettingsClass,
    DWORD                      io_adwIgnoredProps[])
/*++

Synopsis: 
    Given i_pTableMeta, puts the properties either under the Element class
    or under the Setting class.

Arguments: [i_pTableMeta] - 
           [i_cPropsAndTagsRO] - 
           [o_papMbp] - 
           [i_cPropsAndTagsRW] - 
           [o_papMbpSettings] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled        == true);
    DBG_ASSERT(m_bInitSuccessful    == true);
    DBG_ASSERT(i_pTableMeta         != NULL);
    DBG_ASSERT(io_pWmiClass         != NULL);
    DBG_ASSERT(io_pWmiSettingsClass != NULL);
    // DBG_ASSERT(sizeof(io_awszIgnoredProps) >= sizeof(g_awszPropIgnoreList));

    HRESULT            hr = WBEM_S_NO_ERROR;
    CColumnMeta*       pColumnMeta = NULL;
    METABASE_PROPERTY* pMbp;
    ULONG              idxProps = 0;
    ULONG              idxTags = 0;

    ULONG              idxPropsAndTagsRO = 0;
    ULONG              idxPropsAndTagsRW = 0;

    METABASE_PROPERTY*** papMbp         = &io_pWmiClass->ppmbp;
    METABASE_PROPERTY*** papMbpSettings = &io_pWmiSettingsClass->ppmbp;

    //
    // Allocate enough memory for the RO properties
    //
    if(i_cPropsAndTagsRO > 0)
    {
        hr = m_apoolPMbp.GetNewArray(i_cPropsAndTagsRO+1, papMbp);
        if(FAILED(hr))
        {
            goto exit;
        }
        memset(*papMbp, 0, (1+i_cPropsAndTagsRO)*sizeof(METABASE_PROPERTY*));
    }

    //
    // Allocate enough memory for the RW properties
    //
    if(i_cPropsAndTagsRW > 0)
    {
        hr = m_apoolPMbp.GetNewArray(i_cPropsAndTagsRW+1, papMbpSettings);
        if(FAILED(hr))
        {
            goto exit;
        }
        memset(*papMbpSettings, 0, (1+i_cPropsAndTagsRW)*sizeof(METABASE_PROPERTY*));
    }

    //
    // Walk thru all the properties
    //
    for (idxProps=0, idxPropsAndTagsRO = 0, idxPropsAndTagsRW = 0; 
         idxProps < i_pTableMeta->ColCount();
         ++idxProps)
    {
        pColumnMeta = i_pTableMeta->paColumns[idxProps];

        //
        // Ignore property if its in g_adwPropIgnoreList and store the prop in
        // io_adwIgnoredProps
        //
        if( (*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags & fCOLUMNMETA_HIDDEN) ||
            IgnoreProperty(io_pWmiClass->pkt, *(pColumnMeta->ColumnMeta.pID), io_adwIgnoredProps) )
        {
            continue;
        }

        //
        // Call RulePropertiesHelper if Property is not already in the 
        // properties hashtable
        //
        if(FAILED(m_hashProps.Wmi_GetByKey(pColumnMeta->ColumnMeta.pInternalName, &pMbp)))
        {
            hr = RulePropertiesHelper(pColumnMeta, &pMbp, NULL);
            if(FAILED(hr))
            {
                goto exit;
            }
        }

        //
        // If RW, put pointer to property in Setting class, else in Element
        // class.
        //
        if(*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
            fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
        {
            (*papMbpSettings)[idxPropsAndTagsRW] = pMbp;
            idxPropsAndTagsRW++;
        }
        else
        {
            (*papMbp)[idxPropsAndTagsRO] = pMbp;
            idxPropsAndTagsRO++;
        }

        //
        // Same steps as above, except for the tags.
        //
        for(idxTags=0; idxTags < pColumnMeta->cNrTags; idxTags++)
        {
            if(FAILED(m_hashProps.Wmi_GetByKey(pColumnMeta->paTags[idxTags]->pInternalName, &pMbp)))
            {
                hr = RulePropertiesHelper(pColumnMeta, &pMbp, &idxTags);
                if(FAILED(hr))
                {
                    goto exit;
                }
            }
            if(*pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
                fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
            {
                (*papMbpSettings)[idxPropsAndTagsRW] = pMbp;
                idxPropsAndTagsRW++;
            }
            else
            {
                (*papMbp)[idxPropsAndTagsRO] = pMbp;
                idxPropsAndTagsRO++;
            }
        }        
    }

exit:
    return hr;
}

HRESULT CDynSchema::RulePropertiesHelper(
    const CColumnMeta*        i_pColumnMeta, 
    METABASE_PROPERTY**       o_ppMbp,
    ULONG*                    i_idxTag)
/*++

Synopsis: 
    This class creates a property and inserts it into the hashtable of props.
    PRECONDITION: The property does not exist in the hashtable yet.
    i_idxTag is null if you want to insert the property.  else you want to
    insert a tag, and *i_idxTag is the index of the tag

Arguments: [i_pColumnMeta] - 
           [o_ppMbp] - 
           [i_idxTag] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pColumnMeta     != NULL);
    DBG_ASSERT(o_ppMbp           != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    METABASE_PROPERTY* pMbp = NULL;
    
    hr = m_poolProps.GetNewElement(&pMbp);
    if(FAILED(hr))
    {
        goto exit;
    }

    if(i_idxTag == NULL)
    {
        pMbp->dwMDMask   = 0;
        hr = m_spoolStrings.GetNewString(
            i_pColumnMeta->ColumnMeta.pInternalName,
            &(pMbp->pszPropName));
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    else
    {
        pMbp->dwMDMask   = *(i_pColumnMeta->paTags[*i_idxTag]->pValue);
        hr = m_spoolStrings.GetNewString(
            i_pColumnMeta->paTags[*i_idxTag]->pInternalName,
            &(pMbp->pszPropName));
        if(FAILED(hr))
        {
            goto exit;
        }
    }
    pMbp->dwMDIdentifier = *(i_pColumnMeta->ColumnMeta.pID);
    pMbp->dwMDUserType   = *(i_pColumnMeta->ColumnMeta.pUserType);

    switch(*(i_pColumnMeta->ColumnMeta.pType))
    {
    case eCOLUMNMETA_int32:
        if(fCOLUMNMETA_BOOL & *(i_pColumnMeta->ColumnMeta.pMetaFlags))
        {
            if(pMbp->dwMDMask == 0)
            {
                pMbp->dwMDMask = ALL_BITS_ON;
            }
        }
        pMbp->dwMDDataType   = DWORD_METADATA;
        pMbp->pDefaultValue  = NULL;
#ifdef USE_DEFAULT_VALUES
        if(i_pColumnMeta->ColumnMeta.pDefaultValue != NULL)
        {
            pMbp->dwDefaultValue = *i_pColumnMeta->ColumnMeta.pDefaultValue;
            pMbp->pDefaultValue  = &pMbp->dwDefaultValue;
        }
#endif
        break;
    case eCOLUMNMETA_String:
        if(fCOLUMNMETA_MULTISTRING & *(i_pColumnMeta->ColumnMeta.pMetaFlags))
        {
            pMbp->dwMDDataType   = MULTISZ_METADATA;
        }
        else if(fCOLUMNMETA_EXPANDSTRING & *(i_pColumnMeta->ColumnMeta.pMetaFlags))
        {
            pMbp->dwMDDataType   = EXPANDSZ_METADATA;
        }
        else
        {
            pMbp->dwMDDataType   = STRING_METADATA;
        }
		//
		// Default values.
		//
        pMbp->pDefaultValue = NULL;
#ifdef USE_DEFAULT_VALUES
        if(i_pColumnMeta->ColumnMeta.pDefaultValue != NULL)
        {
            if(pMbp->dwMDDataType != MULTISZ_METADATA)
            {
                hr = m_spoolStrings.GetNewString(
                    (LPWSTR)i_pColumnMeta->ColumnMeta.pDefaultValue,
                    (LPWSTR*)&pMbp->pDefaultValue);
                if(FAILED(hr))
                {
                    goto exit;
                }
            }
            else
            {
                bool  bLastCharNull = false;
                ULONG idx  = 0;
                ULONG iLen = 0;
                LPWSTR msz =  (LPWSTR)i_pColumnMeta->ColumnMeta.pDefaultValue;

                do
                {
                    bLastCharNull = msz[idx] == L'\0' ? true : false;
                }
                while( !(msz[++idx] == L'\0' && bLastCharNull) );
                iLen = idx+1;

                hr = m_spoolStrings.GetNewArray(
                    iLen,
                    (LPWSTR*)&pMbp->pDefaultValue);
                if(FAILED(hr))
                {
                    goto exit;
                }
                memcpy(
                    pMbp->pDefaultValue,
                    i_pColumnMeta->ColumnMeta.pDefaultValue,
                    sizeof(WCHAR)*iLen);
            }
        }
#endif
        break;
    case eCOLUMNMETA_BYTES:
        pMbp->dwMDDataType   = BINARY_METADATA;
        pMbp->pDefaultValue  = NULL;
#ifdef USE_DEFAULT_VALUES
#ifdef USE_DEFAULT_BINARY_VALUES
        if( i_pColumnMeta->ColumnMeta.pDefaultValue != NULL )
        {
            hr = m_apoolBytes.GetNewArray(
                i_pColumnMeta->cbDefaultValue,
                (BYTE**)&pMbp->pDefaultValue);
            if(FAILED(hr))
            {
                goto exit;
            }
            memcpy(
                pMbp->pDefaultValue,
                i_pColumnMeta->ColumnMeta.pDefaultValue,
                i_pColumnMeta->cbDefaultValue);
            //
            // Use dwDefaultValue to store the length.
            //
            pMbp->dwDefaultValue = i_pColumnMeta->cbDefaultValue;
        }
#endif
#endif
        break;
    default:
        pMbp->dwMDDataType   = -1;
        pMbp->pDefaultValue  = NULL;
        break;
    }
    pMbp->dwMDAttributes = *(i_pColumnMeta->ColumnMeta.pAttributes);
    if(*i_pColumnMeta->ColumnMeta.pSchemaGeneratorFlags &
        fCOLUMNMETA_CACHE_PROPERTY_MODIFIED)
    {
        pMbp->fReadOnly = FALSE;
    }
    else
    {
        pMbp->fReadOnly = TRUE;
    }

    hr = m_hashProps.Wmi_Insert(pMbp->pszPropName, pMbp);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(SUCCEEDED(hr))
    {
        *o_ppMbp = pMbp;
    }
    return hr;
}

bool CDynSchema::IgnoreProperty(
    METABASE_KEYTYPE* io_pkt,
    DWORD             i_dwPropId,
    DWORD             io_adwIgnored[])
/*++

Synopsis: 
    Checks to see if i_wszProp is in g_adwPropIgnoreList.
    If it is, sets next free element in io_adwIgnored to point to this.

Arguments: [i_wszProp] - 
           [io_adwIgnored] - Must be as big as g_adwPropIgnoreList.
                              Allocated AND must be memset to 0 by caller.
           
Return Value: 
    true if property is in the ignore list.
    false otherwise.

--*/
{
    DBG_ASSERT(io_pkt);

    if(g_adwPropIgnoreList == NULL)
    {
        return false;
    }

    if( io_pkt == &METABASE_KEYTYPE_DATA::s_IIsObject &&
        i_dwPropId == MD_KEY_TYPE )
    {
        return false;
    }

    for(ULONG i = 0; i < g_cElemPropIgnoreList; i++)
    {
        if(i_dwPropId == g_adwPropIgnoreList[i])
        {
            for(ULONG j = 0; j < g_cElemPropIgnoreList; j++)
            {
                if(io_adwIgnored[j] == NULL)
                {
                    io_adwIgnored[j] = g_adwPropIgnoreList[i];
                    break;
                }
            }
            return true;
        }
    }

    return false;
}

#if 0
bool CDynSchema::IgnoreProperty(LPCWSTR i_wszProp)
/*++

Synopsis: 
    Checks to see if i_wszProp is in g_adwPropIgnoreList

Arguments: [i_wszProp] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_wszProp != NULL);

    if(g_adwPropIgnoreList == NULL)
    {
        return false;
    }

    for(ULONG i = 0; i < g_cElemPropIgnoreList; i++)
    {
        if(_wcsicmp(i_wszProp, g_adwPropIgnoreList[i]) == 0)
        {
            return true;
        }
    }

    return false;
}
#endif


HRESULT CDynSchema::RuleGenericAssociations(
    WMI_CLASS*            i_pcElement, 
    WMI_CLASS*            i_pcSetting, 
    WMI_ASSOCIATION_TYPE* i_pAssocType,
    ULONG                 i_iShipped)
/*++

Synopsis: 
    Create the Element/Setting association.    

Arguments: [i_pcElement] - 
           [i_pcSetting] - 
           [i_iShipped] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pcElement       != NULL);
    DBG_ASSERT(i_pcSetting       != NULL);
    DBG_ASSERT(i_pAssocType      != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR wszElement = i_pcElement->pszClassName;
    LPWSTR wszSetting = i_pcSetting->pszClassName;
    LPWSTR wszParent  = NULL;
    LPWSTR wszAssocName;
    WMI_ASSOCIATION* pWmiAssoc;

    ULONG  cchElement = wcslen(wszElement);
    ULONG  cchSetting = wcslen(wszSetting);

    hr = m_spoolStrings.GetNewArray(cchElement+cchSetting+2+1, &wszAssocName);
    if(FAILED(hr))
    {
        goto exit;
    }
    wcscpy(wszAssocName, wszElement);
    wcscat(wszAssocName, L"_");
    wcscat(wszAssocName, wszSetting);

    hr = m_poolAssociations.GetNewElement(&pWmiAssoc);
    if(FAILED(hr))
    {
         goto exit;
    }

    if(i_iShipped == USER_DEFINED_TO_REPOSITORY ||
       i_iShipped == USER_DEFINED_NOT_TO_REPOSITORY)
    {
        wszParent = i_pAssocType->pszExtParent;
    }
    else
    {
        wszParent = i_pAssocType->pszParent;
    }

    pWmiAssoc->pszAssociationName   = wszAssocName;
    pWmiAssoc->pcLeft               = i_pcElement;
    pWmiAssoc->pcRight              = i_pcSetting;
    pWmiAssoc->pType                = i_pAssocType;
    pWmiAssoc->fFlags               = 0;
    pWmiAssoc->pszParentClass       = wszParent;
    pWmiAssoc->dwExtended           = i_iShipped;

    hr = m_hashAssociations.Wmi_Insert(wszAssocName, pWmiAssoc);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

void CDynSchema::RuleWmiClassServices(
    WMI_CLASS* i_pElement,
    WMI_CLASS* i_pSetting)
/*++

Synopsis: 
    Sets the bCreateAllowed fields to false if necessary.
    i_pSetting must be the corresponding Setting class to i_pElement.

    Also sets i_pElement->pszParentClass

Arguments: [i_pElement] - 
           [i_pSetting] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement        != NULL);
    DBG_ASSERT(i_pSetting        != NULL);
    DBG_ASSERT(m_bInitSuccessful == true);

    //
    // Element Class Suffixes for which Create will be disallowed
    //
    static LPCWSTR const wszService = L"Service";
    static const ULONG   cchService = wcslen(wszService);

    //
    // We only care about shipped classes
    //
    if( i_pElement->dwExtended != SHIPPED_TO_MOF &&
        i_pElement->dwExtended != SHIPPED_NOT_TO_MOF )
    {
        return;
    }

    ULONG cchElement = wcslen(i_pElement->pszClassName);

    if( cchElement >= cchService &&
        _wcsicmp(wszService, &i_pElement->pszClassName[cchElement-cchService]) == 0 )
    {
        i_pElement->bCreateAllowed = false;
        i_pElement->pszParentClass = L"Win32_Service";
        i_pSetting->bCreateAllowed = false;
    }
}

HRESULT CDynSchema::RuleWmiClassInverseCCL(
    const METABASE_KEYTYPE* pktGroup, 
    METABASE_KEYTYPE*       pktPart)
/*++

Synopsis: 
    Adds pktGroup to pktPart's inverse container class list

Arguments: [pktGroup] - 
           [pktPart] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(pktGroup          != NULL);
    DBG_ASSERT(pktPart           != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    METABASE_KEYTYPE_NODE* pktnode = NULL;

    hr = m_poolKeyTypeNodes.GetNewElement(&pktnode);
    if(FAILED(hr))
    {
        goto exit;
    }

    pktnode->m_pKt               = pktGroup;
    pktnode->m_pKtNext           = pktPart->m_pKtListInverseCCL;

    pktPart->m_pKtListInverseCCL = pktnode;

exit:
    return hr;
}

HRESULT CDynSchema::RuleGroupPartAssociations(
    const CTableMeta *i_pTableMeta)
/*++

Synopsis: 
    Walks thru container class list to create Group/Part associations.
    Also calls RuleWmiClassInverseCCL for each contained class to create inverse
    container class list.

Arguments: [i_pTableMeta] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pTableMeta      != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    WMI_ASSOCIATION *pWmiAssoc;
    WMI_CLASS       *pWmiClassLeft;
    WMI_CLASS       *pWmiClassRight;

    LPWSTR wszCCL        = NULL;    // Needs to be cleaned up
    LPWSTR wszGroupClass = NULL;    // Ptr to catalog
    LPWSTR wszPartClass  = NULL;    // Ptr to catalog
    LPWSTR wszAssocName  = NULL;    // Ptr to pool
    LPWSTR wszTemp       = NULL;    // Needs to be cleaned up

    static LPCWSTR wszSeps = L", ";

    ULONG cchGroupClass = 0;
    ULONG cchPartClass  = 0;
    ULONG cchCCL        = 0;

    wszGroupClass = i_pTableMeta->TableMeta.pInternalName;
    cchGroupClass = wcslen(wszGroupClass);
    hr = m_hashClasses.Wmi_GetByKey(wszGroupClass, &pWmiClassLeft);
    if(FAILED(hr))
    {
        goto exit;
    }

    if(i_pTableMeta->TableMeta.pContainerClassList &&
       i_pTableMeta->TableMeta.pContainerClassList[0] != L'\0')
    {   
        //
        // Make copy of CCL so we can wcstok
        // 
        cchCCL = wcslen(i_pTableMeta->TableMeta.pContainerClassList);
        wszCCL = new WCHAR[cchCCL+1];
        if(wszCCL == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
        memcpy(wszCCL, i_pTableMeta->TableMeta.pContainerClassList, sizeof(WCHAR)*(cchCCL+1));

        //
        // we will use wszTemp to construct assoc name (GroupClass_PartClass)
        //
        wszTemp = new WCHAR[cchGroupClass+1+cchCCL+1];
        if(wszTemp == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }

        for(wszPartClass =  wcstok(wszCCL, wszSeps); 
            wszPartClass != NULL; 
            wszPartClass =  wcstok(NULL, wszSeps))
        {
            hr = m_hashClasses.Wmi_GetByKey(wszPartClass, &pWmiClassRight);
            if(FAILED(hr))
            {
                //
                // This just means there is a class in the container list that
                // doesn't exist.
                //
                hr = WBEM_S_NO_ERROR;
                continue;
            }

            //
            // Construct association name
            //
            cchPartClass = wcslen(wszPartClass);
            memcpy(wszTemp,               wszGroupClass, sizeof(WCHAR)*cchGroupClass);
            memcpy(wszTemp+cchGroupClass, L"_",          sizeof(WCHAR));
            memcpy(
                wszTemp + cchGroupClass + 1, 
                wszPartClass, 
                sizeof(WCHAR)*(cchPartClass+1));

            hr = m_hashAssociations.Wmi_GetByKey(wszTemp, &pWmiAssoc);
            if(SUCCEEDED(hr))
            {
                if( pWmiClassLeft->dwExtended  != USER_DEFINED_TO_REPOSITORY &&
                    pWmiClassLeft->dwExtended  != USER_DEFINED_NOT_TO_REPOSITORY &&
                    pWmiClassRight->dwExtended != USER_DEFINED_TO_REPOSITORY &&
                    pWmiClassRight->dwExtended != USER_DEFINED_NOT_TO_REPOSITORY )
                {
                    //
                    // This means we already put this shipped association in, but it is
                    // not a conflict.
                    // We need this because this method is called twice for each
                    // group class.
                    //
                    continue;
                }
            }
            hr = WBEM_S_NO_ERROR;

            //
            // TODO: Move this outside?
            //
            hr = RuleWmiClassInverseCCL(pWmiClassLeft->pkt, pWmiClassRight->pkt);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_spoolStrings.GetNewString(
                wszTemp,
                cchGroupClass+1+cchPartClass, // cch
                &wszAssocName);
            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_poolAssociations.GetNewElement(&pWmiAssoc);
            if(FAILED(hr))
            {
                goto exit;
            }

            pWmiAssoc->pszAssociationName = wszAssocName;
            pWmiAssoc->pcLeft = pWmiClassLeft;
            pWmiAssoc->pcRight = pWmiClassRight;
            pWmiAssoc->pType = &WMI_ASSOCIATION_TYPE_DATA::s_Component;
            pWmiAssoc->fFlags = 0;            

            if( pWmiClassLeft->dwExtended  == EXTENDED || 
                pWmiClassLeft->dwExtended  == USER_DEFINED_TO_REPOSITORY ||
                pWmiClassRight->dwExtended == EXTENDED ||
                pWmiClassRight->dwExtended == USER_DEFINED_TO_REPOSITORY)
            {
                pWmiAssoc->pszParentClass = g_wszExtGroupPartAssocParent;
                pWmiAssoc->dwExtended     = USER_DEFINED_TO_REPOSITORY;
            }
            else
            {
                pWmiAssoc->pszParentClass = g_wszGroupPartAssocParent;
                pWmiAssoc->dwExtended     = SHIPPED_TO_MOF;
            }
            hr = m_hashAssociations.Wmi_Insert(wszAssocName, pWmiAssoc);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

exit:
    delete [] wszCCL;
    delete [] wszTemp;
    return hr;
}

HRESULT CDynSchema::RuleSpecialAssociations(
    DWORD      i_adwIgnoredProps[],
    WMI_CLASS* i_pElement)
/*++

Synopsis: 
    Creates IPSecurity and AdminACL associations

Arguments: [i_adwIgnoredProps[]] - 
           [i_pElement] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pElement != NULL);
    
    HRESULT hr                   = WBEM_S_NO_ERROR;
    bool    bCreateIPSecAssoc    = false;
    bool    bCreateAdminACLAssoc = false;

    if(i_pElement->dwExtended != SHIPPED_TO_MOF && i_pElement->dwExtended != EXTENDED)
    {
        return hr;
    }

    for(ULONG i = 0; 
        i < g_cElemPropIgnoreList && i_adwIgnoredProps[i] != 0;
        i++)
    {
        if(i_adwIgnoredProps[i] == MD_IP_SEC)
        {
            bCreateIPSecAssoc = true;
        }
        else if(i_adwIgnoredProps[i] == MD_ADMIN_ACL)
        {
            bCreateAdminACLAssoc = true;
        }
    }

    if(bCreateIPSecAssoc)
    {
        hr = RuleGenericAssociations(
            i_pElement,
            &WMI_CLASS_DATA::s_IPSecurity,
            &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity,
            SHIPPED_TO_MOF);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    if(bCreateAdminACLAssoc)
    {
        hr = RuleGenericAssociations(
            i_pElement,
            &WMI_CLASS_DATA::s_AdminACL,
            &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL,
            SHIPPED_TO_MOF);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

HRESULT CDynSchema::ConstructFlatInverseContainerList()
/*++

Synopsis: 
    Constructs an "inverse flat container class list".
    This list is stored in m_abKtContainers, an array of size iNumKeys*iNumKeys.
    The first iNumKeys entries are for Key #1 and then so on.  Let's call this row 1.
    In row 1, entry i corresponds to Key #i.
    This entry [1,i] is set to true if Key #1 can be contained somewhere under Key #i.
    For instance, [IIsWebDirectory, IIsWebService] is true since an IIsWebService
    can contain an IIsWebServer which can contain an IIsWebDirectory.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    ULONG iNumKeys = m_hashKeyTypes.Wmi_GetNumElements();

    m_abKtContainers = new bool[iNumKeys * iNumKeys];
    if(m_abKtContainers == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memset(m_abKtContainers, 0, iNumKeys * iNumKeys * sizeof(bool));

    CHashTable<METABASE_KEYTYPE*>::iterator iter;
	CHashTable<METABASE_KEYTYPE*>::iterator iterEnd = m_hashKeyTypes.end();
	for (iter = m_hashKeyTypes.begin(); iter != iterEnd; ++iter)
    {
        CHashTable<METABASE_KEYTYPE*>::Record* pRec = iter.Record();
        ConstructFlatInverseContainerListHelper(
            pRec->m_data, 
            &m_abKtContainers[pRec->m_idx * iNumKeys]);
    }

    return WBEM_S_NO_ERROR;
}

//
// TODO: Prove this will always terminate.
//
void CDynSchema::ConstructFlatInverseContainerListHelper(
    const METABASE_KEYTYPE* i_pkt, 
    bool*                   io_abList)
/*++

Synopsis: 
    This walks the inverse container class list of i_pkt.
    For each entry, we call ConstructFlatInverseContainerListHelper and mark all the keytypes
    we see on the way.
    We terminate when we hit a keytype we've already seen or if there are no more keytypes
    in the inverse container class list.

Arguments: [i_pkt] - 
           [io_abList] - 
           
--*/
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pkt != NULL);
    DBG_ASSERT(io_abList != NULL);

    ULONG idx;
    METABASE_KEYTYPE* pktDummy;
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = m_hashKeyTypes.Wmi_GetByKey(i_pkt->m_pszName, &pktDummy, &idx);
    if(FAILED(hr))
    {
        DBG_ASSERT(false && "Keytype should be in hashtable of keytypes");
        return;
    }
    if(io_abList[idx] == true) return;

    io_abList[idx] = true;

    METABASE_KEYTYPE_NODE* pktnode = i_pkt->m_pKtListInverseCCL;
    while(pktnode != NULL)
    {
        ConstructFlatInverseContainerListHelper(pktnode->m_pKt, io_abList);
        pktnode = pktnode->m_pKtNext;
    }
}

bool CDynSchema::IsContainedUnder(METABASE_KEYTYPE* i_pktParent, METABASE_KEYTYPE* i_pktChild)
/*++

Synopsis: 
    Uses m_abKtContainers described above to determine whether i_pktChild can
    be contained somewhere under i_pktParent.

Arguments: [i_pktParent] - 
           [i_pktChild] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pktParent       != NULL);
    DBG_ASSERT(i_pktChild        != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    METABASE_KEYTYPE* pktDummy;
    ULONG idxParent;
    ULONG idxChild;

    hr = m_hashKeyTypes.Wmi_GetByKey(i_pktParent->m_pszName, &pktDummy, &idxParent);
    if(FAILED(hr))
    {
        return false;
    }
    hr = m_hashKeyTypes.Wmi_GetByKey(i_pktChild->m_pszName, &pktDummy, &idxChild);
    if(FAILED(hr))
    {
        return false;
    }

    return m_abKtContainers[idxChild * m_hashKeyTypes.Wmi_GetNumElements() + idxParent];
}

void CDynSchema::ToConsole()
{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    /*CHashTableElement<WMI_CLASS *>* pElement;
    m_hashClasses.Enum(NULL, &pElement);
    while(pElement != NULL)
    {
        wprintf(L"%s\n", pElement->m_data->pszClassName);
        // wprintf(L"\tShipped: %d\n", pElement->m_iShipped);
        wprintf(L"\tKT: %s\n", pElement->m_data->pkt->m_pszName);
        wprintf(L"\tKN: %s\n", pElement->m_data->pszKeyName);
        wprintf(L"\tMK: %s\n", pElement->m_data->pszMetabaseKey);
        METABASE_PROPERTY** ppmbp = pElement->m_data->ppmbp;
        for(ULONG q = 0; ppmbp != NULL && ppmbp[q] != NULL; q++)
        {
            wprintf(L"\tProp: %s\n", ppmbp[q]->pszPropName);
        }
        pElement = pElement->m_pNext;
    }


    ULONG i;

    m_hashKeyTypes.ToConsole();

    WMI_CLASS *pWmiClass;
    for(i = 0; i < m_poolClasses.GetUsed(); i++)
    {
        pWmiClass = m_poolClasses.Lookup(i);
        wprintf( L"%s KT: %d\n", pWmiClass->pszClassName, pWmiClass->pkt );
        for(ULONG j = 0; ; j++)
        {
            if(pWmiClass->ppmbp[j] == NULL)
            {
                break;
            }
            wprintf(L"\t%s\tId: %d\tUT: %d\tDT: %d\tMSK: %d\tAttr: %d\tRO: %d\n", 
                pWmiClass->ppmbp[j]->pszPropName,
                pWmiClass->ppmbp[j]->dwMDIdentifier,
                pWmiClass->ppmbp[j]->dwMDUserType,
                pWmiClass->ppmbp[j]->dwMDDataType,
                pWmiClass->ppmbp[j]->dwMDMask,
                pWmiClass->ppmbp[j]->dwMDAttributes,
                pWmiClass->ppmbp[j]->fReadOnly);
        }
    }
    WMI_ASSOCIATION *pWmiAssoc;
    for(i = 0; i < m_poolAssociations.GetUsed(); i++)
    {
        pWmiAssoc = m_poolAssociations.Lookup(i);
        wprintf(L"%s\n", pWmiAssoc->pszAssociationName);
        wprintf(L"\t%s\n\t%s\n",
            pWmiAssoc->pcLeft->pszClassName,
            pWmiAssoc->pcRight->pszClassName);
    }

    for(unsigned int q = 0; q < m_poolProps.GetUsed(); q++)
    {
        METABASE_PROPERTY* qt = m_poolProps.Lookup(q);
        wprintf(L"%s\n", qt->pszPropName);
    }*/
}

HRESULT CDynSchema::RulePopulateFromDynamic(
    CSchemaExtensions* i_pCatalog,
    BOOL               i_bUserDefined)
{
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr                = WBEM_S_NO_ERROR;
    ULONG i                   = 0;
    CTableMeta* pTableMeta    = NULL;
    WMI_CLASS*  pElementClass = NULL;
    WMI_CLASS*  pSettingClass = NULL;
    DWORD       adwIgnoredProps[g_cElemPropIgnoreList];

    DWORD       dwUserDefined = 0;

    while(pTableMeta = i_pCatalog->EnumTables(&i))
    {
        dwUserDefined =
            (fTABLEMETA_USERDEFINED & *pTableMeta->TableMeta.pSchemaGeneratorFlags);
        if( (i_bUserDefined && !dwUserDefined) || (!i_bUserDefined && dwUserDefined) )
        {
            continue;
        }

        memset(adwIgnoredProps, 0, g_cElemPropIgnoreList*sizeof(DWORD));
        pElementClass = NULL;
        pSettingClass = NULL;

        hr = RuleKeyType(pTableMeta);
        if(FAILED(hr))
        {
            return hr;
        }

        DBG_ASSERT(pTableMeta->TableMeta.pInternalName);
        hr = RuleWmiClass(
            pTableMeta, 
            &pElementClass, 
            &pSettingClass, 
            adwIgnoredProps);
        if(FAILED(hr))
        {
             return hr;
        }
        DBG_ASSERT(pElementClass != NULL);
        DBG_ASSERT(pSettingClass != NULL);

        hr = RuleGenericAssociations(
            pElementClass, 
            pSettingClass, 
            &WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting,
            pElementClass->dwExtended);
        if(FAILED(hr))
        {
            return hr;
        }

        hr = RuleSpecialAssociations(
            adwIgnoredProps,
            pElementClass);
        if(FAILED(hr))
        {
            return hr;
        }

        RuleWmiClassServices(pElementClass, pSettingClass);

        hr = RuleWmiClassDescription(pTableMeta, pElementClass, pSettingClass);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    i = 0;
    while(pTableMeta = i_pCatalog->EnumTables(&i))
    {
        dwUserDefined =
            (fTABLEMETA_USERDEFINED & *pTableMeta->TableMeta.pSchemaGeneratorFlags);
        if( (i_bUserDefined && !dwUserDefined) || (!i_bUserDefined && dwUserDefined) )
        {
            continue;
        }

        hr = RuleGroupPartAssociations(pTableMeta);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

HRESULT CDynSchema::RunRules(
    CSchemaExtensions* i_pCatalog, 
    bool               i_bUseExtensions)
/*++

Synopsis: 
    Does all the work

Arguments: [i_pCatalog] - This function calls Initialize.
                       Don't call Init outside this function.
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(i_pCatalog        != NULL);

    HRESULT hr                = S_OK;
    ULONG i                   = 0;

    //
    // TODO: Don't think I need this
    //
    if(m_bRulesRun)
    {
        return hr;
    }

    hr = RulePopulateFromStatic();
    if(FAILED(hr))
    {
        return hr;
    }

    hr = Rule2PopulateFromStatic();
    if(FAILED(hr))
    {
        return hr;
    }

    hr = i_pCatalog->Initialize(i_bUseExtensions);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = RulePopulateFromDynamic(
        i_pCatalog, 
        false);     // shipped schema
    if(FAILED(hr))
    {
        return hr;
    }
    hr = RulePopulateFromDynamic(
        i_pCatalog, 
        true);      // user-defined schema
    if(FAILED(hr))
    {
        return hr;
    }

    hr = ConstructFlatInverseContainerList();

    if(SUCCEEDED(hr))
    {
        m_bRulesRun = true;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\schemaextensions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemaextensions.cpp

Abstract:

    This file contains the implementation of the CSchemaExtensions class.
    This is the only class that talks to the catalog.

Author:

    MarcelV

Revision History:

    Mohit Srivastava            28-Nov-00

--*/

#include "iisprov.h"
#include "schemaextensions.h"
#include "metabase.hxx"

LPWSTR g_wszDatabaseName = L"Metabase";

HRESULT GetMetabasePath(LPTSTR io_tszPath)
/*++

Synopsis: 
    This beast was copied and modified from 
    \%sdxroot%\iis\svcs\infocomm\metadata\dll\metasub.cxx

Arguments: [io_tszPath] - must be at least size MAX_PATH
           
Return Value: 

--*/
{
    DBG_ASSERT(io_tszPath != NULL);

    HRESULT hresReturn = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    TCHAR tszBuffer[MAX_PATH] = {0};
    HKEY hkRegistryKey = NULL;
    DWORD dwRegReturn;
    DWORD dwType;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);

    dwRegReturn = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        ADMIN_REG_KEY,      // TEXT("SOFTWARE\\Microsoft\\INetMgr\\Parameters")
        &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) 
    {
        dwRegReturn = RegQueryValueEx(
            hkRegistryKey,
            MD_FILE_VALUE,  // TEXT("MetadataFile")
            NULL,
            &dwType,
            (BYTE *) tszBuffer,
            &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) 
        {
            //
            // TODO: Change this error code
            //
            hresReturn = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
            for(ULONG i = dwSize/sizeof(TCHAR)-1; i > 0; i--)
            {
                if(tszBuffer[i] == TEXT('\\'))
                {
                    tszBuffer[i] = TEXT('\0');
                    hresReturn = ERROR_SUCCESS;
                    break;
                }
            }
        }
        RegCloseKey( hkRegistryKey );
        hkRegistryKey = NULL;

    }
    if (FAILED(hresReturn)) 
    {
        dwRegReturn = RegOpenKey(
            HKEY_LOCAL_MACHINE,
            SETUP_REG_KEY,  // TEXT("SOFTWARE\\Microsoft\\InetStp")
            &hkRegistryKey);
        if (dwRegReturn == ERROR_SUCCESS) 
        {
            dwSize = MAX_PATH * sizeof(TCHAR);
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                                          INSTALL_PATH_VALUE,
                                          NULL,
                                          &dwType,
                                          (BYTE *) tszBuffer,
                                          &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_SZ)) 
            {
                hresReturn = HRESULT_FROM_WIN32(dwRegReturn);
            }
            RegCloseKey( hkRegistryKey );
        }
        else 
        {
            hresReturn = HRESULT_FROM_WIN32(dwRegReturn);
        }
    }

    _tcscpy(io_tszPath, tszBuffer);

    if(FAILED(hresReturn))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not get metabase path, hr=0x%x\n", hresReturn));
    }
    return hresReturn;
}

int __cdecl 
CompDBNames (const void * pDBMetaLHS, const void * pDBMetaRHS)
{
    const tDATABASEMETARow *pLHS = static_cast<const tDATABASEMETARow *> (pDBMetaLHS );
    const tDATABASEMETARow *pRHS = static_cast<const tDATABASEMETARow *> (pDBMetaRHS );

    return _wcsicmp (pLHS->pInternalName, pRHS->pInternalName);
}

int __cdecl 
CompTableMeta (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
    const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
    const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

    return _wcsicmp (pLHS->TableMeta.pInternalName, pRHS->TableMeta.pInternalName);
}

int __cdecl 
CompTableDBName (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
    const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
    const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

    return _wcsicmp (pLHS->TableMeta.pDatabase, pRHS->TableMeta.pDatabase);
}

// sorted by table name and index
int __cdecl 
CompColumnMetas (const void * pColumnMetaLHS, const void * pColumnMetaRHS)
{
    const CColumnMeta *pLHS = static_cast<const CColumnMeta *> (pColumnMetaLHS );
    const CColumnMeta *pRHS = static_cast<const CColumnMeta *> (pColumnMetaRHS );

    int iCmp = _wcsicmp (pLHS->ColumnMeta.pTable, pRHS->ColumnMeta.pTable);
    if (iCmp != 0)
    {
        return iCmp;
    }

    return (*pLHS->ColumnMeta.pIndex) - (*pRHS->ColumnMeta.pIndex);
}

// sorted by table name and index
int __cdecl 
CompTagMetas (const void * pTagMetaLHS, const void * pTagMetaRHS)
{
    const tTAGMETARow *pLHS = static_cast<const tTAGMETARow *> (pTagMetaLHS );
    const tTAGMETARow *pRHS = static_cast<const tTAGMETARow *> (pTagMetaRHS );

    int iCmp = _wcsicmp (pLHS->pTable, pRHS->pTable);
    if (iCmp != 0)
    {
        return iCmp;
    }

    int iResult = (*pLHS->pColumnIndex) - (*pRHS->pColumnIndex);
    if (iResult != 0)
    {
        return iResult;
    }

    return (*pLHS->pValue) - (*pRHS->pValue);
}

CSchemaExtensions::CSchemaExtensions ()
{
    m_paTableMetas   = 0;
    m_cNrTables      = 0;

    m_paColumnMetas  = 0;
    m_cNrColumns     = 0;

    m_paTags         = 0;
    m_cNrTags        = 0;

    m_pQueryCells    = 0;
    m_cQueryCells    = 0;

    m_wszBinFileName = 0;
    m_tszBinFilePath = 0;

    m_bBinFileLoaded = false;
}

CSchemaExtensions::~CSchemaExtensions()
{
    if(m_bBinFileLoaded)
    {
        m_spIMbSchemaComp->ReleaseBinFileName(m_wszBinFileName);
    }

    delete [] m_paTableMetas;
    delete [] m_paColumnMetas;
    delete [] m_paTags;

    delete [] m_pQueryCells;
    delete [] m_wszBinFileName;
    delete [] m_tszBinFilePath;
}

HRESULT CSchemaExtensions::Initialize(bool i_bUseExtensions)
{
    HRESULT hr  = S_OK;
    ULONG   cch = 0;

    InitializeSimpleTableDispenser();

    //
    // Get the dispenser
    //
    hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &m_spDispenser);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not get dispenser, hr=0x%x\n", hr));
        return hr;
    }

    //
    // Get the schema compiler interface from the dispenser which will help us
    // get the bin file name.
    //
    hr = m_spDispenser->QueryInterface(IID_IMetabaseSchemaCompiler,
                                       (LPVOID*)&m_spIMbSchemaComp);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get SchemaCompiler interface, hr=0x%x\n", hr));
        return hr;
    }

    //
    // Get the path of mbschema.xml
    //
    m_tszBinFilePath = new TCHAR[MAX_PATH+1];
    if(m_tszBinFilePath == NULL)
    {
        return E_OUTOFMEMORY;
    }
    hr = GetMetabasePath(m_tszBinFilePath);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get metabase path, hr=0x%x\n", hr));
        return hr;
    }

    //
    // Convert it to Unicode, Set Bin Path
    //
#ifndef UNICODE
    // we want to convert an MBCS string in lpszA
    int nLen = MultiByteToWideChar(CP_ACP, 0,m_tszBinFilePath, -1, NULL, NULL);
    LPWSTR lpszW = new WCHAR[nLen];
    if(lpszW == NULL)
    {
        return E_OUTOFMEMORY;
    }
    if(MultiByteToWideChar(CP_ACP, 0, m_tszBinFilePath, -1, lpszW, nLen) == 0)
    {
        delete [] lpszW;
        hr = GetLastError();
        return HRESULT_FROM_WIN32(hr);
    }
    hr = m_spIMbSchemaComp->SetBinPath(lpszW);
    delete [] lpszW;
#else
    hr = m_spIMbSchemaComp->SetBinPath(m_tszBinFilePath);
#endif
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Get Bin FileName
    //
    hr = m_spIMbSchemaComp->GetBinFileName(NULL, &cch);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get schema bin filename size, hr=0x%x\n", hr));
        return hr;
    }
    m_wszBinFileName = new WCHAR[cch+1];
    if(m_wszBinFileName == NULL)
    {
        return E_OUTOFMEMORY;
    }
    hr = m_spIMbSchemaComp->GetBinFileName(m_wszBinFileName, &cch);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Couldn't get schema bin filename, hr=0x%x\n", hr));
        return hr;
    }
    m_bBinFileLoaded = true;

    //
    // Set up the query cells
    //
    m_cQueryCells = 2;
    m_pQueryCells = new STQueryCell[m_cQueryCells];
    if(m_pQueryCells == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if(i_bUseExtensions)
    {
        m_pQueryCells[0].pData     = (LPVOID)m_wszBinFileName;
    }
    else
    {
        m_pQueryCells[0].pData     = (LPVOID)NULL;
    }

    m_pQueryCells[0].eOperator = eST_OP_EQUAL;
    m_pQueryCells[0].iCell     = iST_CELL_SCHEMAFILE;
    m_pQueryCells[0].dbType    = DBTYPE_WSTR;
    m_pQueryCells[0].cbSize    = 0;

    m_pQueryCells[1].pData = (void *) g_wszDatabaseName;
    m_pQueryCells[1].eOperator = eST_OP_EQUAL;
    m_pQueryCells[1].iCell = iCOLLECTION_META_Database;
    m_pQueryCells[1].dbType = DBTYPE_WSTR;
    m_pQueryCells[1].cbSize = 0;

    hr = GenerateIt();
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "GenerateIt failed, hr=0x%x\n", hr));
        return hr;
    }
    
    return hr;
}

HRESULT CSchemaExtensions::GetMbSchemaTimeStamp(
    FILETIME* io_pFileTime) const
{
    DBG_ASSERT(io_pFileTime     != NULL);
    DBG_ASSERT(m_tszBinFilePath != NULL);

    HRESULT hr = S_OK;

    ULONG cchBinFilePath     = _tcslen(m_tszBinFilePath);
    ULONG cchSchFileName     = _tcslen(MD_SCHEMA_FILE_NAME);

    TCHAR* tszPathPlusName = new TCHAR[cchBinFilePath+1+cchSchFileName+1];
    TCHAR* tszCurPos       = tszPathPlusName;
    if(tszPathPlusName == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Copy the path
    //
    tszCurPos = tszPathPlusName;
    memcpy(tszCurPos, m_tszBinFilePath, sizeof(TCHAR)*(cchBinFilePath+1));

    //
    // Concat a \ if necessary, and the filename,
    //
    tszCurPos = tszPathPlusName + cchBinFilePath;
    if(m_tszBinFilePath[cchBinFilePath-1] != TEXT('\\'))
    {
        memcpy(tszCurPos, TEXT("\\"), sizeof(TCHAR)*2);
        tszCurPos++;
    }
    memcpy(tszCurPos, MD_SCHEMA_FILE_NAME, sizeof(TCHAR)*(cchSchFileName+1));

    //
    // Now get the file info
    //
    {
        WIN32_FIND_DATA FindFileData;
        memset(&FindFileData, 0, sizeof(WIN32_FIND_DATA));

        HANDLE hFindFile = FindFirstFile(tszPathPlusName, &FindFileData);
        if(hFindFile == INVALID_HANDLE_VALUE)
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            goto exit;
        }
        FindClose(hFindFile);

        //
        // Set out parameters if everything succeeded
        //
        memcpy(io_pFileTime, &FindFileData.ftLastWriteTime, sizeof(FILETIME));
    }

exit:
    delete [] tszPathPlusName;
    return hr;
}

HRESULT
CSchemaExtensions::GenerateIt ()
{
    HRESULT hr = S_OK;

    hr = GetTables ();
    if (FAILED (hr))
    {
        return hr;
    }

    
    hr = GetColumns ();
    if (FAILED (hr))
    {
        return hr;
    }

    hr = GetTags ();
    if (FAILED (hr))
    {
        return hr;
    }

    hr = BuildInternalStructures ();
    if (FAILED (hr))
    {
        return hr;
    }

    return hr;
}


HRESULT
CSchemaExtensions::GetTables ()
{
    HRESULT hr = S_OK;

    ULONG one = 1;

    hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA,
                                  m_pQueryCells, (void *)&one, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTTableMeta);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = m_spISTTableMeta->GetTableMeta (0, 0, &m_cNrTables, 0);
    if (FAILED (hr))
    {
        return hr;
    }

    if (m_cNrTables == 0)
    {
        return S_OK;
    }

    m_paTableMetas = new CTableMeta [m_cNrTables];
    if (m_paTableMetas == 0)
    {
        return E_OUTOFMEMORY;
    }


    for (ULONG idx =0; idx < m_cNrTables; ++idx)
    {
        hr = m_spISTTableMeta->GetColumnValues (idx, sizeof (tTABLEMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paTableMetas[idx].TableMeta);
        if (FAILED (hr))
        {
            return hr;
        }
    
        if (m_paTableMetas[idx].ColCount () > 0)
        {
            // set number of columns
            m_paTableMetas[idx].paColumns = new LPCColumnMeta[m_paTableMetas[idx].ColCount()];
            if (m_paTableMetas[idx].paColumns == 0)
            {
                return E_OUTOFMEMORY;
            }
        }
    }

    // and sort them by table name

    qsort (m_paTableMetas, m_cNrTables, sizeof (CTableMeta), CompTableMeta);
    return hr;
}

HRESULT
CSchemaExtensions::GetColumns ()
{
    HRESULT hr = S_OK;

    ULONG one = 1;

    hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA,
                                  m_pQueryCells, (void *)&one, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTColumnMeta);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = m_spISTColumnMeta->GetTableMeta (0, 0, &m_cNrColumns, 0);
    if (FAILED (hr))
    {
        return hr;
    }

    if (m_cNrColumns == 0)
    {
        return E_FAIL;
    }

    m_paColumnMetas = new CColumnMeta[m_cNrColumns];
    if (m_paColumnMetas == 0)
    {
        return E_OUTOFMEMORY;
    }

    ULONG acbSizes[cCOLUMNMETA_NumberOfColumns];
    for (ULONG idx =0; idx < m_cNrColumns; ++idx)
    {
        hr = m_spISTColumnMeta->GetColumnValues (idx, sizeof (tCOLUMNMETARow)/sizeof (ULONG *), 0, acbSizes, (void **) &m_paColumnMetas[idx].ColumnMeta);
        m_paColumnMetas[idx].cbDefaultValue = acbSizes[iCOLUMNMETA_DefaultValue];
        if (FAILED (hr))
        {
            return hr;
        }
    }
    
    qsort (m_paColumnMetas, m_cNrColumns, sizeof (CColumnMeta), CompColumnMetas);
    
    return hr;
}

HRESULT
CSchemaExtensions::GetTags ()
{
    HRESULT hr = S_OK;

    ULONG one = 1;

    hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TAGMETA,
                                  m_pQueryCells, (void *)&one, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTTagMeta);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = m_spISTTagMeta->GetTableMeta (0, 0, &m_cNrTags, 0);
    if (FAILED (hr))
    {
        return hr;
    }

    if (m_cNrTags == 0)
    {
        return E_FAIL;
    }

    m_paTags = new tTAGMETARow[m_cNrTags];
    if (m_paTags == 0)
    {
        return E_OUTOFMEMORY;
    }

    for (ULONG idx =0; idx < m_cNrTags; ++idx)
    {
        hr = m_spISTTagMeta->GetColumnValues (idx, sizeof (tTAGMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paTags[idx]);
        if (FAILED (hr))
        {
            return hr;
        }
    }
    qsort (m_paTags, m_cNrTags, sizeof (tTAGMETARow), CompTagMetas);

    return hr;
}

HRESULT 
CSchemaExtensions::BuildInternalStructures ()
{
    HRESULT hr = S_OK;

    // attach the tags to the tables

    ULONG idx = 0;
    while (idx < m_cNrTags)
    {
        // find the correct column
        CColumnMeta dummyColumnMeta;
        dummyColumnMeta.ColumnMeta.pTable = m_paTags[idx].pTable;
        dummyColumnMeta.ColumnMeta.pIndex = m_paTags[idx].pColumnIndex;
        // get column
        CColumnMeta *pColMeta = (CColumnMeta *) bsearch (&dummyColumnMeta,
                                                         m_paColumnMetas,
                                                         m_cNrColumns,
                                                         sizeof (CColumnMeta),
                                                         CompColumnMetas);

        DBG_ASSERT (pColMeta != NULL);
        DBG_ASSERT (wcscmp(pColMeta->ColumnMeta.pTable, m_paTags[idx].pTable) == 0 &&
            *pColMeta->ColumnMeta.pIndex == *m_paTags[idx].pColumnIndex);

        // get count
        ULONG iStartIdx = idx;
        pColMeta->cNrTags = 1;
        idx++; // skip over this element
        while ((idx < m_cNrTags) &&
               (wcscmp(pColMeta->ColumnMeta.pTable, m_paTags[idx].pTable) == 0) &&
               (*pColMeta->ColumnMeta.pIndex == *m_paTags[idx].pColumnIndex))
        {
            idx++;
            pColMeta->cNrTags += 1;
        }

        if (pColMeta->cNrTags > 0)
        {
            // allocate memory and copy the stuff
            pColMeta->paTags = new LPtTAGMETA[pColMeta->cNrTags];
            if (pColMeta->paTags == 0)
            {
                return E_OUTOFMEMORY;
            }
            for (ULONG tagIdx = 0; tagIdx < pColMeta->cNrTags; ++tagIdx)
            {
                pColMeta->paTags[tagIdx] = &m_paTags[iStartIdx + tagIdx];
            }
        }
    }

    // attach the columns to the tables
    for (idx=0; idx < m_cNrColumns; ++idx)
    {
        CTableMeta dummyTableMeta;
        dummyTableMeta.TableMeta.pInternalName = m_paColumnMetas[idx].ColumnMeta.pTable;
        // find table
        CTableMeta *pTableMeta =  (CTableMeta *) bsearch (&dummyTableMeta, m_paTableMetas,
                                                          m_cNrTables,
                                                          sizeof (CTableMeta), 
                                                          CompTableMeta);
        DBG_ASSERT (pTableMeta != 0);
        DBG_ASSERT (wcscmp(pTableMeta->TableMeta.pInternalName, m_paColumnMetas[idx].ColumnMeta.pTable) == 0);

        // add Column to table

        ULONG iColumnIndex = *(m_paColumnMetas[idx].ColumnMeta.pIndex);
        DBG_ASSERT (iColumnIndex < pTableMeta->ColCount ());
        pTableMeta->paColumns[iColumnIndex] = &m_paColumnMetas[idx];
    }

    return hr;
}

CTableMeta* CSchemaExtensions::EnumTables(ULONG *io_idx)
{
    DBG_ASSERT(io_idx != NULL);

    CTableMeta* pRet = NULL;

    while(1)
    {
        if(*io_idx < m_cNrTables)
        {
            pRet = &m_paTableMetas[*io_idx];
            if( _wcsicmp(pRet->TableMeta.pDatabase, g_wszDatabaseName) == 0 && 
                !(*pRet->TableMeta.pMetaFlags & fTABLEMETA_HIDDEN) )
            {
                *io_idx = 1 + *io_idx;
                return pRet;
            }
            else
            {
                *io_idx = 1 + *io_idx;
            }
        }
        else
        {
            *io_idx = 1 + *io_idx;
            return NULL;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\smartpointer.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.

//This pointer class wraps a pointer so that delete happens automatically when the TSmartPointer goes out of scope
//If this is not the behavior you want then don't use this wrapper class


#ifndef __SMARTPOINTER_H__
#define __SMARTPOINTER_H__

#ifndef ASSERT
    #define ASSERT(x)
#endif

//Destructor is NOT virtual bacause I don't see why anyone would ever treat a TSmartPointerArray as a TSmartPointer

#pragma warning(disable : 4284)//It's OK to use this SmartPointer class with native types; but the -> operator doesn't make sense.  Compiler warns of this.

template <class T> class TSmartPointer
{
public:
    TSmartPointer()                     : m_p(0) {}
    TSmartPointer(T* p)                 : m_p(p) {}
    ~TSmartPointer()                    { Delete();}

    operator T*() const                 { return m_p; }
    T& operator*() const                { ASSERT(0!=m_p); return *m_p; }

    T** operator&()                     { ASSERT(0==m_p); return &m_p; }
    T* operator->() const               { ASSERT(0!=m_p); return m_p; }
    T* operator=(T* p)                  { return (m_p = p); }
    bool operator!() const              { return (0 == m_p); }
    bool operator==(const T* p) const   { return m_p == p; }

    void Delete()                       { delete m_p; m_p=0; }

    T* m_p;
private:
    TSmartPointer(const TSmartPointer<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


template <class T> class TSmartPointerArray : public TSmartPointer<T>
{
public:
    TSmartPointerArray(T *p)            : TSmartPointer<T>(p) {}
    TSmartPointerArray()                : TSmartPointer<T>() {}
    ~TSmartPointerArray()               { Delete();}

    T* operator++()                     { ASSERT(0!=m_p); return ++m_p; }
    T* operator+=(int n)                { ASSERT(0!=m_p); return (m_p+=n); }
    T* operator-=(int n)                { ASSERT(0!=m_p); return (m_p-=n); }
    T* operator--()                     { ASSERT(0!=m_p); return --m_p; }
//    T& operator[](int n) const          { ASSERT(0!=m_p); return m_p[n]; }
    bool operator<(const T* p) const    { return m_p < p; }
    bool operator>(const T* p) const    { return m_p > p; }
    bool operator<=(const T* p) const   { return m_p <= p; }
    bool operator>=(const T* p) const   { return m_p >= p; }
    T* operator=(T p[])                 { return (m_p = p); }

    void Delete()                       { delete [] m_p; m_p=0; }
private:
    TSmartPointerArray(const TSmartPointerArray<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


#endif //__SMARTPOINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\schemaextensions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemaextensions.h

Abstract:

    This file contains the definition of the CSchemaExtensions class.
    This is the only class that talks to the catalog.

Author:

    MarcelV

Revision History:

    Mohit Srivastava            28-Nov-00

--*/

#ifndef _schemaextensions_h_
#define _schemaextensions_h_

#include "catalog.h"
#include "catmeta.h"
#include <atlbase.h>

//forward decl
struct CTableMeta;

struct CColumnMeta
{
    CColumnMeta() {paTags = 0; cbDefaultValue = 0; cNrTags = 0;}
    ~CColumnMeta() {delete [] paTags;}
    tCOLUMNMETARow ColumnMeta;
    ULONG cbDefaultValue;
    ULONG cNrTags;
    tTAGMETARow **paTags;
};

struct CTableMeta
{
    CTableMeta () {paColumns=0;}
    ~CTableMeta () {delete []paColumns;}

    ULONG ColCount () const
    {
        return *(TableMeta.pCountOfColumns);
    }

    tTABLEMETARow TableMeta;
    CColumnMeta **paColumns;
};



typedef tTAGMETARow * LPtTAGMETA;
typedef CColumnMeta * LPCColumnMeta;
    

class CSchemaExtensions
{
public:
    CSchemaExtensions ();
    ~CSchemaExtensions ();
    
    HRESULT Initialize (bool i_bUseExtensions = true);
    CTableMeta* EnumTables(ULONG *io_idx);

    HRESULT GetMbSchemaTimeStamp(FILETIME* io_pFileTime) const;

private:

    HRESULT GenerateIt ();

    HRESULT GetTables ();
    HRESULT GetColumns ();
    HRESULT GetTags ();
    HRESULT GetRelations ();    
    
    HRESULT BuildInternalStructures ();

    CComPtr<ISimpleTableDispenser2>  m_spDispenser;
    CComPtr<IMetabaseSchemaCompiler> m_spIMbSchemaComp;

    CComPtr<ISimpleTableRead2> m_spISTTableMeta;
    CComPtr<ISimpleTableRead2> m_spISTColumnMeta;
    CComPtr<ISimpleTableRead2> m_spISTTagMeta;
    CComPtr<ISimpleTableRead2> m_spISTRelationMeta;
    
    LPWSTR              m_wszBinFileName;
    
    LPTSTR              m_tszBinFilePath;

    CTableMeta*         m_paTableMetas;     // all table information
    ULONG               m_cNrTables;

    CColumnMeta*        m_paColumnMetas;    // all column information
    ULONG               m_cNrColumns;

    tTAGMETARow*        m_paTags;           // all tag information
    ULONG               m_cNrTags;

    ULONG               m_cQueryCells;
    STQueryCell*        m_pQueryCells;

    bool                m_bBinFileLoaded;
};

#endif // _schemaextensions_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\sources.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    Internet Information Services provider

Author:

    Zeyong Xu    Oct 1999

Revision History:

!ENDIF

!include $(PROJECT_ROOT)\iis\place.inc

DLLDEF=..\iiswmi.def
TARGETPATH=obj
TARGETTYPE=DYNLINK

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

NTTARGETFILE0=$(O)\iiswmimsg.h                  \
              $(O)\msg00001.bin                 \
              $(O)\iiswmimsg.rc

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib      	\
    $(SDK_LIB_PATH)\user32.lib          \
    $(SDK_LIB_PATH)\oleaut32.lib        \
    $(SDK_LIB_PATH)\ole32.lib           \
    $(SDK_LIB_PATH)\uuid.lib            \
    $(SDK_LIB_PATH)\advapi32.lib        \
    $(SDK_LIB_PATH)\crypt32.lib         \
    $(SDK_LIB_PATH)\wbemuuid.lib        \
    $(SDK_LIB_PATH)\adsiid.lib          \
    $(SDK_LIB_PATH)\activeds.lib        \
    ..\wmiutils\$(O)\wmiutils.lib       \
    ..\..\sitecreator\$(O)\sitecreator.lib \
    $(IISBASEDIR)\lib\$(O)\iisutil.lib  \
    $(IISBASEDIR)\iisrearc\import\lib\*\cat.lib \


INCLUDES=..; \
         ..\wmiutils; \
         ..\..\sitecreator; \
         $(O); \
         $(SDK_INC_PATH); \
         $(IISBASEDIR)\iisrearc\core\inc; \
         $(IISBASEDIR)\iisrearc\import\inc; \
         $(IISBASEDIR)\svcs\infocomm\metadata\inc; \
         $(IISBASEDIR)\inc; \
         $(IISBASEDIR)\admin\adsi\adsiis\$(O); \

USE_VCCOM=1
USE_NATIVE_EH=1
USE_MSVCRT=1
USE_ATL=1
ATL_VER=30
C_DEFINES = -DUNICODE -D_WIN32_DCOM -D_WIN32_WINNT=0x0500

SOURCES= \
	maindll.cpp				\
	iisprov.cpp				\
        instancehelper.cpp			\
        queryhelper.cpp				\
        AssocBase.cpp                           \
        AssocSameLevel.cpp                      \
        AssocACLACE.cpp                         \
        AssocComponent.cpp                      \
	classfac.cpp				\
	certmap.cpp				\
	adminacl.cpp				\
	ipsecurity.cpp				\
	iisprov.rc				\
	globdata.cpp				\
	utils.cpp				\
	enum.cpp				\
	metabase.cpp				\
	appladmin.cpp				\
	hashtable.cpp				\
	schemaextensions.cpp			\
	schemadynamic.cpp			\
	pusher.cpp                              \
	webservicemethod.cpp                    \
	multiszdata.cpp                         \
	multiszhelper.cpp			\

MISCFILES = ..\iiswmi.mof \
            ..\iiswmi.mfl

DLLENTRY=_DllMainCRTStartup

TARGETNAME=iiswmi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\schemadynamic.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    schemadynamic.h

Abstract:

    This file contains the definition of the CDynSchema class.
    This class contains the dynamic schema structures.
    It also contains the rules for populating the schema structures.

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#ifndef _schemadynamic_h_
#define _schemadynamic_h_

#include "hashtable.h"
#include "schema.h"
#include "schemaextensions.h"

//
// Prefix added to all auto-generated classes/associations
//
const LPWSTR g_wszIIs_ =     L"";
const ULONG  g_cchIIs_ =     wcslen(g_wszIIs_);

//
// Suffix added to "Settings" classes
//
const WCHAR  g_wszSettings[] = L"Setting";
const ULONG  g_cchSettings   = sizeof(g_wszSettings)/sizeof(WCHAR) - 1;

//
// These properties are ignored when building the property list
// for a class.
//
const DWORD  g_adwPropIgnoreList[]  = { MD_LOCATION, MD_KEY_TYPE, MD_IP_SEC, MD_ADMIN_ACL };
const ULONG  g_cElemPropIgnoreList  = sizeof(g_adwPropIgnoreList) / sizeof(DWORD);

class CDynSchema
{
public:
    CDynSchema() : m_bInitCalled(false),
        m_bInitSuccessful(false),
        m_bRulesRun(false),
        m_abKtContainers(NULL)
    {
    }
    ~CDynSchema()
    {
        delete [] m_abKtContainers;
    }
    CHashTable<METABASE_PROPERTY *> *GetHashProps()
    {
        return &m_hashProps;
    }
    CHashTable<WMI_CLASS *> *GetHashClasses()
    {
        return &m_hashClasses;
    }
    CHashTable<WMI_ASSOCIATION *> *GetHashAssociations()
    {
        return &m_hashAssociations;
    }
    CHashTable<METABASE_KEYTYPE *> *GetHashKeyTypes()
    {
        return &m_hashKeyTypes;
    }

    HRESULT Initialize();
    HRESULT RunRules(CSchemaExtensions* catalog, bool biUseExtensions = true);
    bool IsContainedUnder(METABASE_KEYTYPE* i_pktParent, METABASE_KEYTYPE* i_pktChild);
    void ToConsole();

private:
    HRESULT RulePopulateFromStatic();
    HRESULT Rule2PopulateFromStatic();
    HRESULT RulePopulateFromDynamic(
        CSchemaExtensions* i_pCatalog,
        BOOL               i_bUserDefined);

    //
    // KeyType stuff
    //
    HRESULT RuleKeyType(
        const CTableMeta *i_pTableMeta);

    HRESULT RuleWmiClassInverseCCL(
        const METABASE_KEYTYPE* pktGroup, 
        METABASE_KEYTYPE*       pktPart);

    HRESULT ConstructFlatInverseContainerList();

    void ConstructFlatInverseContainerListHelper(
        const METABASE_KEYTYPE* i_pkt, 
        bool*                   io_abList);    

    //
    // Wmi Class
    //
    HRESULT RuleWmiClass(
        const CTableMeta* i_pTableMeta, 
        WMI_CLASS**       o_ppElementClass, 
        WMI_CLASS**       o_ppSettingClass,
        DWORD             io_adwIgnoredProps[]);

    HRESULT RuleProperties(
        const CTableMeta*          i_pTableMeta, 
        ULONG                      i_cPropsAndTagsRO, 
        WMI_CLASS*                 io_pWmiClass,
        ULONG                      i_cPropsAndTagsRW, 
        WMI_CLASS*                 io_pWmiSettingsClass,
        DWORD                      io_adwIgnoredProps[]);

    HRESULT RulePropertiesHelper(
        const CColumnMeta*        i_pColumnMeta, 
        METABASE_PROPERTY**       o_ppMbp,
        ULONG*                    i_idxTag);

    HRESULT RuleWmiClassDescription(
        const CTableMeta* i_pTableMeta, 
        WMI_CLASS*        i_pElementClass, 
        WMI_CLASS*        i_pSettingClass) const;

    void RuleWmiClassServices(
        WMI_CLASS* i_pElement,
        WMI_CLASS* i_pSetting);

    //
    // Associations
    //
    HRESULT RuleGroupPartAssociations(
        const CTableMeta *i_pTableMeta);

    HRESULT RuleGenericAssociations(
        WMI_CLASS*            i_pcElement, 
        WMI_CLASS*            i_pcSetting, 
        WMI_ASSOCIATION_TYPE* i_pAssocType,
        ULONG                 i_iShipped);

    HRESULT RuleSpecialAssociations(
        DWORD      i_adwIgnoredProps[],
        WMI_CLASS* i_pElement);

#if 0
    bool IgnoreProperty(LPCWSTR i_wszProp);
#endif
    bool IgnoreProperty(
        METABASE_KEYTYPE* io_pkt, 
        DWORD             i_dwPropId, 
        DWORD             io_adwIgnored[]);

    CHashTable<METABASE_PROPERTY *> m_hashProps;
    CPool<METABASE_PROPERTY> m_poolProps;

    CHashTable<WMI_CLASS *> m_hashClasses;
    CPool<WMI_CLASS> m_poolClasses;

    CHashTable<WMI_ASSOCIATION *> m_hashAssociations;
    CPool<WMI_ASSOCIATION> m_poolAssociations;

    CHashTable<METABASE_KEYTYPE *> m_hashKeyTypes;
    CPool<METABASE_KEYTYPE> m_poolKeyTypes;
    bool* m_abKtContainers;

    CStringPool                        m_spoolStrings;
    CArrayPool<METABASE_PROPERTY*, 10> m_apoolPMbp;
    CArrayPool<BYTE, 10>               m_apoolBytes;

    CPool<METABASE_KEYTYPE_NODE> m_poolKeyTypeNodes;

    bool m_bInitCalled;
    bool m_bInitSuccessful;

    bool m_bRulesRun;
};

#endif // _schemadynamic_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\utils.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    General purpose utilities

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#include "iisprov.h"
#include "iiswmimsg.h"

extern CDynSchema* g_pDynSch;
extern HMODULE     g_hModule;

BSTR CUtils::ExtractBstrFromVt(
    const VARIANT* i_pvt,
    LPCWSTR        i_wszVtName) // default(NULL)
/*++

Synopsis: 
    This is different from VARAINT::ChangeType in that it handles conversion
    from VT_NULL also.

Arguments: [i_pvt] - 
           
Return Value: 
    BSTR: If non-null, points to i_pvt->bstrVal

--*/
{
    DBG_ASSERT(i_pvt != NULL);

    switch(i_pvt->vt)
    {
    case VT_BSTR:
        return i_pvt->bstrVal;
    case VT_NULL:
        return NULL;
    default:
        CIIsProvException e;
        e.SetHR(DISP_E_TYPEMISMATCH, i_wszVtName);
        throw e;
    }

    return NULL;
}

LONG CUtils::ExtractLongFromVt(
    const VARIANT* i_pvt,
    LPCWSTR        i_wszVtName) //default(NULL)
{
    DBG_ASSERT(i_pvt);

    try
    {
        _variant_t svt;
        svt = *i_pvt;

        return (long)svt;
    }
    catch(_com_error ce)
    {
        CIIsProvException e;
        e.SetHR(ce.Error(), i_wszVtName);
        throw e;
    }
}

bool CUtils::CompareKeyType(
    LPCWSTR           i_wszKeyFromMb,
    METABASE_KEYTYPE* i_pktKeyCompare)
{
    DBG_ASSERT(i_wszKeyFromMb);
    DBG_ASSERT(i_pktKeyCompare);

    if(!i_pktKeyCompare->m_pszName)
    {
        return false;
    }

    if(_wcsicmp(i_wszKeyFromMb, i_pktKeyCompare->m_pszName) == 0)
    {
        return true;
    }

    //
    // If i_wszKeyFromMb is not in our hashtable and i_wszKeyCompare is
    // IIsObject, treat as a match.
    //
    METABASE_KEYTYPE* pKt = NULL;
    HRESULT hr = g_pDynSch->GetHashKeyTypes()->Wmi_GetByKey(i_wszKeyFromMb, &pKt);
    if( FAILED(hr) && i_pktKeyCompare == &METABASE_KEYTYPE_DATA::s_IIsObject )
    {
        return true;
    }

    return false;
}

bool CUtils::CompareMultiSz(
    WCHAR*       i_msz1,
    WCHAR*       i_msz2
    )
{
    if(i_msz1 == NULL && i_msz2 == NULL)
        return true;
    else if(i_msz1 == NULL || i_msz2 == NULL)
        return false;

    // compare the two multisz buffers.
    for ( ; (*i_msz1 && *i_msz2); )
    {
        if (_wcsicmp(i_msz1, i_msz2) != NULL)
            return false;
        i_msz1 += wcslen(i_msz1) + 1;
        i_msz2 += wcslen(i_msz2) + 1;
    }

    if (!*i_msz1 && !*i_msz2)
    {
        return true;
    }

    return false;
}

HRESULT CUtils::LoadSafeArrayFromByteArray(
    LPBYTE       i_aBytes,
    DWORD        i_iBytes,
    _variant_t&     io_vt
    )
{
    DBG_ASSERT(i_aBytes != NULL);

    HRESULT hr = S_OK;
    SAFEARRAY* pSafeArray = NULL;

    SAFEARRAYBOUND safeArrayBounds[1];
    safeArrayBounds[0].lLbound = 0;
    safeArrayBounds[0].cElements = i_iBytes;
    pSafeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
    if(pSafeArray == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }
    for(ULONG idx = 0; idx < i_iBytes; idx++)
    {
        hr = SafeArrayPutElement(pSafeArray, (LONG *)&idx, &i_aBytes[idx]);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // If everything succeeded, set out parameters.
    //
    io_vt.vt = VT_UI1 | VT_ARRAY;
    io_vt.parray = pSafeArray;

exit:
    if(FAILED(hr))
    {
        if(pSafeArray != NULL)
        {
            SafeArrayDestroy(pSafeArray);
        }
    }
    return hr;
}

//
// CreateByteArrayFromSafeArray
//
HRESULT CUtils::CreateByteArrayFromSafeArray(
    _variant_t&  i_vt,
    LPBYTE*      o_paBytes,
    DWORD*       io_pdw
    )
{
    DBG_ASSERT(i_vt.vt == (VT_ARRAY | VT_UI1));
    DBG_ASSERT(o_paBytes != NULL);
    DBG_ASSERT(io_pdw != NULL);

    if(i_vt.parray == NULL)
    {
        *o_paBytes = NULL;
        *io_pdw    = 0;
    }

    HRESULT hr     = S_OK;
    LONG    iLo    = 0;
    LONG    iUp    = 0;
    LPBYTE  aBytes = NULL;

    hr = SafeArrayGetLBound(i_vt.parray,1,&iLo);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = SafeArrayGetUBound(i_vt.parray,1,&iUp);
    if(FAILED(hr))
    {
        goto exit;
    }

    aBytes = new BYTE[iUp-iLo+1];
    if(aBytes == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto exit;
    }

    for(LONG i = iLo; i <= iUp; i++)
    {
        hr = SafeArrayGetElement(i_vt.parray, &i, &aBytes[i-iLo]);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // If everything succeeded, set out parameters.
    //
    *o_paBytes = aBytes;
    *io_pdw    = iUp-iLo+1;

exit:
    if(FAILED(hr))
    {
        delete [] aBytes;
    }
    return hr;
}

bool CUtils::CompareByteArray(
    LPBYTE       i_aBytes1,
    ULONG        i_iBytes1,
    LPBYTE       i_aBytes2,
    ULONG        i_iBytes2
    )
{
    if(i_aBytes1 == NULL && i_aBytes2 == NULL)
    {
        return true;
    }
    if(i_aBytes1 == NULL || i_aBytes2 == NULL)
    {
        return false;
    }
    if(i_iBytes1 != i_iBytes2)
    {
        return false;
    }

    for(ULONG i = 0; i < i_iBytes1; i++)
    {
        if(i_aBytes1[i] != i_aBytes2[i])
        {
            return false;
        }
    }

    return true;
}

KeyRef* CUtils::GetKey(
    ParsedObjectPath*    i_pParsedObjectPath, 
    WCHAR*               i_wsz
    )
/*++

Synopsis: 
    Return the KeyRef pointer from the ParsedObjectPath for the given string.

Arguments: [i_pParsedObjectPath] - 
           [i_wsz] - 
           
Return Value: 

--*/
{
    KeyRef* pkr;
    DWORD   numkeys = i_pParsedObjectPath->m_dwNumKeys;
    DWORD   c;

    if(numkeys == 1)
    {
        pkr = *(i_pParsedObjectPath->m_paKeys);
        if(pkr->m_pName == NULL)
        {
            return pkr;
        }
    }

    for ( c=0; numkeys; numkeys--,c++ ) 
    {
        pkr = *(i_pParsedObjectPath->m_paKeys + c);
        if (!_wcsicmp(pkr->m_pName,i_wsz))
            return pkr;
    }

    CIIsProvException e;
    e.SetMC(WBEM_E_INVALID_OBJECT, IISWMI_NO_PRIMARY_KEY, i_wsz);
    throw e;
}

bool CUtils::GetAssociation(
    LPCWSTR              i_wszAssocName,
    WMI_ASSOCIATION**    o_ppAssoc
    )
/*++

Synopsis: 
    Association i_wszAssocName is returned in o_ppAssoc if found. 

Arguments: [i_wszAssocName] - 
           [o_ppAssoc] - 
           
Return Value: 
    true  if found
    false otherwise

--*/
{
    DBG_ASSERT(o_ppAssoc != NULL);

    HRESULT hr;
    hr = g_pDynSch->GetHashAssociations()->Wmi_GetByKey(
        (LPWSTR)i_wszAssocName,
        o_ppAssoc);
    if(SUCCEEDED(hr))
    {
        return true;
    }
    else
    {
        return false;
    }    
}

bool CUtils::GetClass(
    LPCWSTR        i_wszClassName,
    WMI_CLASS**    o_ppClass
    )
/*++

Synopsis: 
    Class i_wszClassName is returned in o_ppClass if found.

Arguments: [i_wszClassName] - 
           [o_ppClass] - 
           
Return Value: 
    true if found
    false otherwise

--*/
{
    DBG_ASSERT(o_ppClass != NULL);

    HRESULT hr;

    hr = g_pDynSch->GetHashClasses()->Wmi_GetByKey(
        (LPWSTR)i_wszClassName,
        o_ppClass);

    if(SUCCEEDED(hr))
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool CUtils::GetMethod(
    LPCWSTR         i_wszMethod,
    WMI_METHOD**    i_apMethodList,
    WMI_METHOD**    o_ppMethod
    )
/*++

Synopsis: 
    The Method descriptor for i_wszMethod is returned via o_ppMethod if found

Arguments: [i_wszMethod] - 
           [i_apMethodList] - 
           [o_ppMethod] - 
           
Return Value: 
    true  if found.
    false otherwise.

--*/
{
    DBG_ASSERT(i_wszMethod    != NULL);
    DBG_ASSERT(o_ppMethod     != NULL);

    WMI_METHOD**    ppmethod;

    if(i_apMethodList == NULL)
    {
        return false;
    }

    for (ppmethod = i_apMethodList; *ppmethod != NULL;ppmethod++)
    {
        if (_wcsicmp(i_wszMethod,(*ppmethod)->pszMethodName) ==0) 
        {
            *o_ppMethod = *ppmethod;        
            return true;
        }
    }

    return false;
}

HRESULT CUtils::ConstructObjectPath(
    LPCWSTR          i_wszMbPath,
    const WMI_CLASS* i_pClass,
    BSTR*            o_pbstrPath)
{
    DBG_ASSERT(i_wszMbPath  != NULL);
    DBG_ASSERT(i_pClass     != NULL);
    DBG_ASSERT(o_pbstrPath  != NULL);
    DBG_ASSERT(*o_pbstrPath == NULL);

    CComBSTR sbstrPath;

    ULONG   cchPrefix = wcslen(i_pClass->pszMetabaseKey);
    DBG_ASSERT(cchPrefix <= wcslen(i_wszMbPath));

    LPCWSTR wszSuffix = &i_wszMbPath[cchPrefix];

    if(wszSuffix[0] == L'/')
    {
        wszSuffix++;
    }

    sbstrPath =  i_pClass->pszClassName;
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    sbstrPath += L"='";
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    sbstrPath += wszSuffix;
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    sbstrPath += L"'";
    if(sbstrPath.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    *o_pbstrPath = sbstrPath.Detach();

    return S_OK;
}


void CUtils::GetMetabasePath(
    IWbemClassObject* io_pObj,
    ParsedObjectPath* i_pParsedObjectPath,
    WMI_CLASS*        i_pClass,
    _bstr_t&          io_bstrPath)
/*++

Synopsis: 
    Populates io_bstrPath and sets the key field in IWbemClassObject

Arguments: [io_pObj] - 
           [i_pParsedObjectPath] - 
           [i_pClass] - 
           [io_bstrPath] - 
           
--*/
{
    KeyRef* pkr;
    LPWSTR  wszWmiKey     = i_pClass->pszKeyName;

    DBG_ASSERT(i_pParsedObjectPath      != NULL);
    DBG_ASSERT(i_pClass                 != NULL);
    DBG_ASSERT(wszWmiKey                != NULL);
    DBG_ASSERT(i_pClass->pszMetabaseKey != NULL);

    pkr = GetKey(i_pParsedObjectPath, wszWmiKey);
    DBG_ASSERT(pkr != NULL);

    if (io_pObj)
    {
        _bstr_t bstr;
        if(pkr->m_pName == NULL)
        {
            bstr = wszWmiKey;
        }
        else
        {
            bstr = pkr->m_pName;
        }
        HRESULT hr = io_pObj->Put(bstr, 0, &pkr->m_vValue, 0);
        THROW_ON_ERROR(hr);
    }

    io_bstrPath = i_pClass->pszMetabaseKey;

    switch ((pkr)->m_vValue.vt)
    {
    case VT_I4:
        {
            WCHAR wszBuf[32] = {0};
            io_bstrPath += L"/";
            io_bstrPath += _itow(pkr->m_vValue.lVal, wszBuf, 10);
            break;
        }
    case VT_BSTR:
        {
            io_bstrPath += L"/";
            io_bstrPath += pkr->m_vValue.bstrVal;
            break;
        }
    }

    return;
}

HRESULT CUtils::GetParentMetabasePath(
    LPCWSTR i_wszChildPath,
    LPWSTR  io_wszParentPath)
/*++

Synopsis: 
    Eg. /LM/w3svc/1 => /LM/w3svc/
        /           => E_FAIL

Arguments: [i_wszChildPath] - 
           [io_wszParentPath] - Should be allocated by caller to at least same
                                size as i_wszChildPath.
           
Return Value: 
    E_FAIL
    S_OK

--*/
{
    DBG_ASSERT(i_wszChildPath != NULL);
    DBG_ASSERT(io_wszParentPath != NULL);

    ULONG cchChildPath = wcslen(i_wszChildPath);
    BOOL  bParentFound = false;

    //
    // This should trim all the ending L'/'
    //
    while(cchChildPath > 0 && i_wszChildPath[cchChildPath-1] == L'/')
    {
        cchChildPath--;
    }

    if(cchChildPath <= 1)
    {
        //
        // does not have a parent
        //
        return E_FAIL;
    }

    for(LONG i = cchChildPath-1; i >= 0; i--)
    {
        if(i_wszChildPath[i] == L'/')
        {
            bParentFound = true;
            break;
        }
    }

    if(!bParentFound)
    {
        return E_FAIL;
    }

    memcpy(io_wszParentPath, i_wszChildPath, (i+1)*sizeof(WCHAR));
    io_wszParentPath[i+1] = L'\0';

    return S_OK;
}

void CUtils::Throw_Exception(
    HRESULT               a_hr,
    METABASE_PROPERTY*    a_pmbp
    )
{
    CIIsProvException t_e;

    t_e.SetHR(a_hr, a_pmbp->pszPropName);

    throw(t_e);
}

//
// io_wszDateTime should be allocated outside with 30 elements
//
void CUtils::FileTimeToWchar(FILETIME *i_pFileTime, LPWSTR io_wszDateTime)
{
    DBG_ASSERT(i_pFileTime    != NULL);
    DBG_ASSERT(io_wszDateTime != NULL);

    SYSTEMTIME  systime;
    if(FileTimeToSystemTime(i_pFileTime, &systime) == 0)
    {
        THROW_ON_ERROR(HRESULT_FROM_WIN32(GetLastError()));
    }
    swprintf(
        io_wszDateTime,
        L"%04d%02d%02d%02d%02d%02d.%06d+000",
        systime.wYear,
        systime.wMonth,
        systime.wDay,
        systime.wHour,
        systime.wMinute,
        systime.wSecond,
        systime.wMilliseconds
        );
}

//
// Below this line, added by Mohit
//

HRESULT CUtils::CreateEmptyMethodInstance(
    CWbemServices*     i_pNamespace,
    IWbemContext*      i_pCtx,
    LPCWSTR            i_wszClassName,
    LPCWSTR            i_wszMethodName,
    IWbemClassObject** o_ppMethodInstance)
/*++

Synopsis: 
    Generally used when executing a WMI method that has out parameters.

Arguments: 
           
--*/
{
    DBG_ASSERT(i_pNamespace    != NULL);
    DBG_ASSERT(i_pCtx          != NULL);
    DBG_ASSERT(i_wszClassName  != NULL);
    DBG_ASSERT(i_wszMethodName != NULL);
    DBG_ASSERT(o_ppMethodInstance   != NULL);

    CComPtr<IWbemClassObject> spClass;
    CComPtr<IWbemClassObject> spMethodClass;
    CComPtr<IWbemClassObject> spMethodInstance;
    HRESULT hr = S_OK;

    hr = i_pNamespace->GetObject(_bstr_t(i_wszClassName), 0, i_pCtx, &spClass, NULL);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = spClass->GetMethod(i_wszMethodName, 0, NULL, &spMethodClass);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = spMethodClass->SpawnInstance(0, &spMethodInstance);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // If everything succeeded, set out parameters
    //
    *o_ppMethodInstance = spMethodInstance;
    (*o_ppMethodInstance)->AddRef();

exit:
    return hr;
}

HRESULT CUtils::GetQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR*          i_awszQualNames,
    VARIANT*          io_aQualValues,
    ULONG             i_NrQuals
    )
/*++

Synopsis: 
    Gets Qualifiers.

Arguments: [i_pClass] - 
           [i_awszQualNames] - An array of size i_NrQuals with names of quals.
           [io_aQualValues]  - An array of size i_NrQuals with empty variants.
                               Will be populated on success.
           [i_NrQuals] - 
           
--*/
{
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(io_aQualValues  != NULL);

    HRESULT hr = S_OK;
    ULONG   i = 0;

    CComPtr<IWbemQualifierSet> spQualSet = NULL;

    hr = i_pClass->GetQualifierSet(&spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    // Looking for qualifiers
    for(i = 0; i < i_NrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Get(i_awszQualNames[i], 0, &io_aQualValues[i], NULL);
        if(FAILED(hr) && hr != WBEM_E_NOT_FOUND)
        {
            break;
        }
        hr = WBEM_S_NO_ERROR;
    }
    if(FAILED(hr))
    {
        for(i = 0; i < i_NrQuals; i++)
        {
            VariantClear(&io_aQualValues[i]);
        }
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::GetPropertyQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR i_wszPropName,
    DWORD*  io_pdwQuals)
/*++

Synopsis:  Unlike SetPropertyQualifiers, this method is specific to this 
           provider.

Arguments: 
           
--*/
{
    DBG_ASSERT(i_pClass != NULL);
    DBG_ASSERT(i_wszPropName != NULL);
    DBG_ASSERT(io_pdwQuals != NULL);

    HRESULT hr = S_OK;

    CComPtr<IWbemQualifierSet> spQualSet = NULL;
    BSTR               bstrQualName = NULL;
    VARIANT            varQualValue;
    VariantInit(&varQualValue);

    DWORD              dwQuals = 0;

    bool               bSeenForcePropertyOverwrite = false;
    bool               bSeenIsDefault              = false;
    bool               bSeenIsInherit              = false;

    hr = i_pClass->GetPropertyQualifierSet(i_wszPropName, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    // Looking for qualifiers
    spQualSet->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);
    while(!bSeenForcePropertyOverwrite || !bSeenIsDefault || !bSeenIsInherit)
    {
        hr = spQualSet->Next(0, &bstrQualName, &varQualValue, NULL);
        if(hr == WBEM_S_NO_MORE_DATA || FAILED(hr)) 
        {
            // No more qualifiers.
            // We don't need to worry about cleanup - nothing was allocated.
            break;
        }

        if(!bSeenForcePropertyOverwrite && _wcsicmp(bstrQualName, g_wszForcePropertyOverwrite) == 0) 
        {
            bSeenForcePropertyOverwrite = true;
            if(varQualValue.vt == VT_BOOL && varQualValue.boolVal) 
            {
                dwQuals |= g_fForcePropertyOverwrite;
            }
        }
        else if(!bSeenIsDefault && _wcsicmp(bstrQualName, g_wszIsDefault) == 0)
        {
            bSeenIsDefault = true;
            if(varQualValue.vt == VT_BOOL && varQualValue.boolVal)
            {
                dwQuals |= g_fIsDefault;
            }
        }
        else if(!bSeenIsInherit && _wcsicmp(bstrQualName, g_wszIsInherit) == 0)
        {
            bSeenIsInherit = true;
            if(varQualValue.vt == VT_BOOL && varQualValue.boolVal)
            {
                dwQuals |= g_fIsInherit;
            }
        }
        SysFreeString(bstrQualName);        
        VariantClear(&varQualValue);
    }
    spQualSet->EndEnumeration();

    if(FAILED(hr))
    {
        goto exit;
    }

    *io_pdwQuals = dwQuals;

exit:
    if(hr == WBEM_S_NO_MORE_DATA)
    {
        hr = WBEM_S_NO_ERROR;
    }
    return hr;
}
    
HRESULT CUtils::SetQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR*          i_awszQualNames,
    VARIANT*          i_avtQualValues,
    ULONG             i_iNrQuals,
    ULONG             i_iFlags)
{
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(i_avtQualValues != NULL);

    HRESULT hr = S_OK;
    CComPtr<IWbemQualifierSet> spQualSet = NULL;

    hr = i_pClass->GetQualifierSet(&spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    for(ULONG i = 0; i < i_iNrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Put(i_awszQualNames[i], &i_avtQualValues[i], i_iFlags);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::SetMethodQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR           i_wszMethName,
    LPCWSTR*          i_awszQualNames,
    VARIANT*          i_avtQualValues,
    ULONG             i_iNrQuals)
{
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_wszMethName   != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(i_avtQualValues != NULL);

    HRESULT hr = WBEM_S_NO_ERROR;
    CComPtr<IWbemQualifierSet> spQualSet;

    hr = i_pClass->GetMethodQualifierSet(i_wszMethName, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    for(ULONG i = 0; i < i_iNrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Put(i_awszQualNames[i], &i_avtQualValues[i], 
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::SetPropertyQualifiers(
    IWbemClassObject* i_pClass,
    LPCWSTR i_wszPropName,
    LPCWSTR* i_awszQualNames,
    VARIANT* i_avtQualValues,
    ULONG i_iNrQuals)
/*++

Synopsis: 

Arguments: [i_pClass] - 
           [i_wszPropName] - 
           [i_awszQualNames] - 
           [i_avtQualValues] - 
           [i_iNrQuals] -
           
--*/
{
    DBG_ASSERT(i_pClass != NULL);
    DBG_ASSERT(i_wszPropName != NULL);
    DBG_ASSERT(i_awszQualNames != NULL);
    DBG_ASSERT(i_avtQualValues != NULL);

    HRESULT hr = S_OK;
    CComPtr<IWbemQualifierSet> spQualSet = NULL;

    hr = i_pClass->GetPropertyQualifierSet(i_wszPropName, &spQualSet);
    if(FAILED(hr))
    {
        goto exit;
    }

    for(ULONG i = 0; i < i_iNrQuals; i++)
    {
        DBG_ASSERT(i_awszQualNames[i] != NULL);
        hr = spQualSet->Put(i_awszQualNames[i], &i_avtQualValues[i], 
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CUtils::CreateEmptyInstance(
    LPWSTR i_wszClass,
    CWbemServices* i_pNamespace,
    IWbemClassObject** o_ppInstance)
/*++

Synopsis: 
    Creates an IWbemClassObject populated with default values.

Arguments: [i_wszClass] - 
           [i_pNamespace] - 
           [o_ppInstance] - Must Release() if this function succeeds.
           
--*/
{
    DBG_ASSERT(i_wszClass != NULL);
    DBG_ASSERT(i_pNamespace != NULL);
    DBG_ASSERT(o_ppInstance != NULL);

    HRESULT hr = S_OK;
    CComPtr<IWbemClassObject> spClass;
    CComPtr<IWbemClassObject> spInstance;

    hr = i_pNamespace->GetObject(
        i_wszClass, 
        0, 
        NULL, 
        &spClass, 
        NULL);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = spClass->SpawnInstance(0, &spInstance);
    
    if(FAILED(hr))
    {
        goto exit;
    }

    *o_ppInstance = spInstance;
    (*o_ppInstance)->AddRef();

exit:
    return hr;
}

void CUtils::MessageCodeToText(
    DWORD    i_dwMC,
    va_list* i_pArgs,
    BSTR*    o_pbstrText)
/*++

Synopsis: 

Arguments: [i_dwMC] - 
           [i_pArgs] -     Can be NULL
           [o_pbstrText] - Needs to be freed by caller
           
--*/
{
    DBG_ASSERT(o_pbstrText != NULL);
    *o_pbstrText = NULL;

    LPVOID lpMsgBuf = NULL;
    DWORD dwRet = FormatMessageW( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        g_hModule,
        i_dwMC,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        i_pArgs);
    if(dwRet == 0)
    {
        DBG_ASSERT(lpMsgBuf == NULL);
    }

    CComBSTR sbstrOut;
    if(lpMsgBuf != NULL)
    {
        //
        // If out of memory, sbstrOut will be NULL.  This is okay.
        //
        sbstrOut = (LPWSTR)lpMsgBuf;

        //
        // Free the buffer.
        //
        LocalFree( lpMsgBuf );
    }

    //
    // Set out parameter
    //
    *o_pbstrText = sbstrOut.Detach();
}

void CUtils::HRToText(
    HRESULT i_hr,
    BSTR*   o_pbstrText)
{
    DBG_ASSERT(o_pbstrText != NULL);

    CComPtr<IWbemStatusCodeText> spStatus;

    *o_pbstrText = NULL;
    i_hr         = HRESULT_FROM_WIN32(i_hr);

    if(HRESULT_FACILITY(i_hr) == FACILITY_INTERNET)
    {
        MessageCodeToText(i_hr, NULL, o_pbstrText);
        return;
    }

    HRESULT hr = CoCreateInstance(
        CLSID_WbemStatusCodeText, 
        0, 
        CLSCTX_INPROC_SERVER,
        IID_IWbemStatusCodeText, 
        (LPVOID *) &spStatus);
    
    CComBSTR sbstrError    = NULL;
    CComBSTR sbstrFacility = NULL;
    if(SUCCEEDED(hr))
    {
        spStatus->GetErrorCodeText(i_hr, 0, 0, &sbstrError);       // ignore hr
        spStatus->GetFacilityCodeText(i_hr, 0, 0, &sbstrFacility); // ignore hr
    }

    CComBSTR sbstrFullError = NULL;
    if(sbstrError != NULL && sbstrFacility != NULL)
    {
        sbstrFullError =  sbstrFacility;
        sbstrFullError += L": ";
        sbstrFullError += sbstrError;   // sbstrFullError may be NULL in low mem -- okay
    }
    else if(sbstrError != NULL)
    {
        sbstrFullError =  sbstrError;   // sbstrFullError may be NULL in low mem -- okay
    }
    else if(sbstrFacility != NULL)
    {
        sbstrFullError = sbstrFacility; // sbstrFullError may be NULL in low mem -- okay
    }

    *o_pbstrText = sbstrFullError.Detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\utils.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    General purpose utilities

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _utils_h_
#define _utils_h_


#define MAX_BUF_SIZE         1024
#define MAX_KEY_NAME_SIZE      32
#define MAX_KEY_TYPE_SIZE      32

#include "WbemServices.h"
#include "schema.h"
#include <wbemprov.h>
#include <windows.h>
#include <comutil.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <dbgutil.h>
#include <atlbase.h>

class CUtils
{
public:
    //
    // Wrappers for commonly used WMI operations
    //
    static HRESULT CreateEmptyMethodInstance(
        CWbemServices*     i_pNamespace,
        IWbemContext*      i_pCtx,
        LPCWSTR            i_wszClassName,
        LPCWSTR            i_wszMethodName,
        IWbemClassObject** o_ppMethodInstance);

    static HRESULT GetQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR*          i_awszQualNames,
        VARIANT*          io_aQualValues,
        ULONG             i_NrQuals);

    static HRESULT GetPropertyQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR i_wszPropName,
        DWORD*  io_pdwQuals);

    static HRESULT SetQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR*          i_awszQualNames,
        VARIANT*          i_avtQualValues,
        ULONG             i_iNrQuals,
        ULONG             i_iFlags);
    
    static HRESULT SetMethodQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR           i_wszMethName,
        LPCWSTR*          i_awszQualNames,
        VARIANT*          i_avtQualValues,
        ULONG             i_iNrQuals);

    static HRESULT SetPropertyQualifiers(
        IWbemClassObject* i_pClass,
        LPCWSTR i_wszPropName,
        LPCWSTR* i_awszQualNames,
        VARIANT* i_avtQualValues,
        ULONG i_iNrQuals);

    static HRESULT CreateEmptyInstance(
        LPWSTR i_wszClass,
        CWbemServices* i_pNamespace,
        IWbemClassObject** o_ppInstance);

    //
    // Retrieval from schema
    //
    static bool GetClass(
        LPCWSTR i_wszClassName,
        WMI_CLASS** o_ppClass);

    static bool GetAssociation(
        LPCWSTR i_wszAssocName, 
        WMI_ASSOCIATION** o_ppAssoc);

    static bool GetMethod(
        LPCWSTR         i_wszMethod,
        WMI_METHOD**    i_apMethodList,
        WMI_METHOD**    o_ppMethod);

    //
    // Data conversion/comparison
    //
    static bool CompareKeyType(
        LPCWSTR           i_wszKeyFromMb,
        METABASE_KEYTYPE* i_pktKeyCompare);

    static bool CompareMultiSz(
        WCHAR*       i_msz1,
        WCHAR*       i_msz2);

    static HRESULT CreateByteArrayFromSafeArray(
        _variant_t&  i_vt,
        LPBYTE*      o_paBytes,
        DWORD*       io_pdw);

    static HRESULT LoadSafeArrayFromByteArray(
        LPBYTE       i_aBytes,
        DWORD        i_iBytes,
        _variant_t&  io_vt);

    static bool CompareByteArray(
        LPBYTE       i_aBytes1,
        ULONG        i_iBytes1,
        LPBYTE       i_aBytes2,
        ULONG        i_iBytes2
        );

    static BSTR ExtractBstrFromVt(
        const VARIANT* i_pvt,
        LPCWSTR        i_wszVtName=NULL);

    static LONG ExtractLongFromVt(
        const VARIANT* i_pvt,
        LPCWSTR        i_wszVtName=NULL);

    //
    // Other
    //
    static KeyRef* GetKey(
        ParsedObjectPath* i_pParsedObjectPath, 
        WCHAR* i_wsz);

    static void GetMetabasePath(
        IWbemClassObject* i_pObj,
        ParsedObjectPath* i_pParsedObjectPath,    
        WMI_CLASS*        i_pClass,
        _bstr_t&          io_bstrPath);

    static HRESULT GetParentMetabasePath(
        LPCWSTR i_wszChildPath,
        LPWSTR  io_wszParentPath);

    static HRESULT ConstructObjectPath(
        LPCWSTR          i_wszMbPath,
        const WMI_CLASS* i_pClass,
        BSTR*            o_pbstrPath);

    static void FileTimeToWchar(
        FILETIME* i_pFileTime, 
        LPWSTR io_wszDateTime);

    //
    // For exception handling and/or errors
    //
    static HRESULT ParserErrToHR(DWORD i_dwErr)
    {
        switch(i_dwErr)
        {
        case CObjectPathParser::NoError:
            break;
        case CObjectPathParser::OutOfMemory:
            return WBEM_E_OUT_OF_MEMORY;
        default:
            return WBEM_E_INVALID_OBJECT;
        }

        return WBEM_S_NO_ERROR;
    }

    static void HRToText(
        HRESULT i_hr,
        BSTR*   o_pbstrText);

    static void MessageCodeToText(
        DWORD    i_dwMC,
        va_list* i_pArgs,
        BSTR*    o_pbstrText);

    static void Throw_Exception(HRESULT, METABASE_PROPERTY*);
};



class CIIsProvException
{
public:
    CIIsProvException() :
      m_hr(0),
      m_bErrorSet(false)
    {
    }

    ~CIIsProvException()
    {
    }

    void SetHR(HRESULT i_hr, LPCWSTR i_wszParams=NULL)
    /*++

    Synopsis: 

    Arguments: [i_hr] -             The HR
               [i_wszParams=NULL] - The param field of __ExtendedStatus
           
    --*/
    {
        DBG_ASSERT(m_bErrorSet == false);
        m_hr               = i_hr;
        m_sbstrParams      = i_wszParams;

        m_bErrorSet        = true;

        ConstructStringFromHR(i_hr);
    }

    void SetMC(HRESULT i_hr, DWORD i_dwMC, LPCWSTR i_wszParams, ...)
    /*++

    Synopsis: 

    Arguments: [i_hr] -         The HR
               [i_dwMC] -       The MC code
               [i_wszParams] -  The param field of __ExtendedStatus
               [...] -          The args for the MC error string
           
    --*/
    {
        DBG_ASSERT(m_bErrorSet == false);
        m_hr               = i_hr;
        m_sbstrParams      = i_wszParams;

        va_list (marker);
        va_start(marker, i_wszParams);

        m_bErrorSet        = true;

        ConstructStringFromMC(i_dwMC, &marker);
    }

    //
    // For getting errors (Get text representation, hr, and culprit param)
    // These are fields of __Extended Status
    //

    HRESULT GetHR() const
    {
        DBG_ASSERT(m_bErrorSet == true);
        return m_hr;
    }

    BSTR GetParams() const
    {
        DBG_ASSERT(m_bErrorSet == true);
        return m_sbstrParams;
    }

    BSTR GetErrorText() const
    {
        DBG_ASSERT(m_bErrorSet == true);
        return m_sbstrError;
    }

private:
    void ConstructStringFromHR(
        HRESULT i_hr)
    {
        DBG_ASSERT(m_bErrorSet == true);

        //
        // If this fails, m_sbstrError will be NULL.  This is okay.
        //
        CUtils::HRToText(i_hr, &m_sbstrError);
    }

    void ConstructStringFromMC(
        DWORD    i_dwMC,
        va_list* i_pArgs)
    {
        DBG_ASSERT(m_bErrorSet == true);
        
        //
        // If this fails, m_sbstrError will be NULL.  This is okay.
        //
        CUtils::MessageCodeToText(i_dwMC, i_pArgs, &m_sbstrError);
    }

    //
    // These are fields of __ExtendedStatus
    //
    HRESULT  m_hr;
    CComBSTR m_sbstrParams;
    CComBSTR m_sbstrError;

    //
    // Used just for assert
    //
    bool     m_bErrorSet;
};


#define THROW_ON_FALSE(b)               \
    if (!b)                             \
        throw((HRESULT)WBEM_E_FAILED);

// if client cancelled, stop and return successfully
#define THROW_ON_ERROR(hr)              \
    if (FAILED(hr))                     \
    {                                   \
        DBGPRINTF((DBG_CONTEXT, "FAILED: hr = %x\n", hr)); \
        throw(hr == WBEM_E_CALL_CANCELLED ? WBEM_NO_ERROR : (HRESULT)hr); \
    }                                                                     \

#define THROW_E_ON_ERROR(hr, pmbp)          \
    if (FAILED(hr))                         \
    {                                       \
        CUtils::Throw_Exception(hr, pmbp);  \
    }

#define EXIT_ON_ERROR(hr)                   \
    if(FAILED(hr))                          \
    {                                       \
        goto exit;                          \
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\webservicemethod.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ServiceMethod.cpp

Abstract:

    Implements the CServiceMethod class.

    All the methods in this class return HRESULTs and do not throw exceptions.

Author:

    Mohit Srivastava            25-March-01

Revision History:

--*/

#include "WebServiceMethod.h"
#include "MultiSzHelper.h"
#include "Utils.h"
#include "SmartPointer.h"

#include <dbgutil.h>
#include <iiscnfg.h>
#include <atlbase.h>
#include <iwamreg.h>

CServiceMethod::CServiceMethod(
    eSC_SUPPORTED_SERVICES i_eServiceId)
{
    m_bInit         = false;
    m_pSiteCreator  = NULL;
    m_eServiceId    = i_eServiceId;

    DBG_ASSERT(m_eServiceId == SC_W3SVC || m_eServiceId == SC_MSFTPSVC);
}

CServiceMethod::~CServiceMethod()
{
    if(m_pSiteCreator)
    {
        delete m_pSiteCreator;
        m_pSiteCreator = NULL;
    }
}


HRESULT CServiceMethod::Init()
/*++

Synopsis: 
    Should be called immediately after constructor.

Return Value: 

--*/
{
    DBG_ASSERT(m_bInit == false);

    m_pSiteCreator = new CSiteCreator();
    if(m_pSiteCreator == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_bInit = true;

    return WBEM_S_NO_ERROR;
}


HRESULT CServiceMethod::CreateNewSite(
    LPCWSTR        i_wszServerComment,
    PDWORD         o_pdwSiteId,
    PDWORD         i_pdwRequestedSiteId)    // default value NULL
/*++

Synopsis: 
    This is the CreateNewSite called when someone does a Put on a Server w/o
    specifying a SiteId.

Arguments: [o_pdwSiteId] - 
           [i_pdwRequestedSiteId] - 
           
Return Value: 
    HRESULT

--*/
{
    DBG_ASSERT(m_bInit);
    DBG_ASSERT(o_pdwSiteId != NULL);

    HRESULT hr                   = S_OK;

    //
    // Call API
    //
    hr = m_pSiteCreator->CreateNewSite(
        m_eServiceId,
        (i_wszServerComment == NULL) ? L"" : i_wszServerComment,
        o_pdwSiteId,
        i_pdwRequestedSiteId);

    return hr;
}

HRESULT CServiceMethod::CreateNewSite(
    CWbemServices*     i_pNamespace,
    LPCWSTR            i_wszMbPath,
    IWbemContext*      i_pCtx,
    WMI_CLASS*         i_pClass,
    WMI_METHOD*        i_pMethod,
    IWbemClassObject*  i_pInParams,
    IWbemClassObject** o_ppRetObj)
/*++

Synopsis: 
    This is the CreateNewSite called by the WMI Method of the same name.

Arguments: [i_pNamespace] -
           [i_wszMbPath] -  needed for creating WMI return object
           [i_pCtx] -       needed for creating WMI return object
           [i_pClass] -     needed for creating WMI return object
           [i_pMethod] -    needed for creating WMI return object
           [i_pInParams] - 
           [o_ppRetObj] - 
           
Return Value: 
    HRESULT

--*/
{
    DBG_ASSERT(m_bInit);
    DBG_ASSERT(i_pNamespace    != NULL);
    DBG_ASSERT(i_wszMbPath     != NULL);
    DBG_ASSERT(i_pCtx          != NULL);
    DBG_ASSERT(i_pClass        != NULL);
    DBG_ASSERT(i_pMethod       != NULL);
    DBG_ASSERT(i_pInParams     != NULL);
    DBG_ASSERT(o_ppRetObj      != NULL);
    DBG_ASSERT(*o_ppRetObj     == NULL);

    HRESULT     hr = WBEM_S_NO_ERROR;
    CComVariant vtServerId, vtServerComment, vtServerBindings, vtPath;

    //
    // get in params
    //
    hr = InternalGetInParams(
        i_pInParams, 
        vtServerId, 
        vtServerComment, 
        vtServerBindings, 
        vtPath);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Set pdwRequestedSite based on whether the user specified a site
    //
    DWORD  dwRequestedSiteId  = 0;
    PDWORD pdwRequestedSiteId = NULL;
    if(vtServerId.vt == VT_I4)
    {
        pdwRequestedSiteId = &dwRequestedSiteId;
        dwRequestedSiteId  = vtServerId.lVal;
    }

    //
    // Create the new site
    //
    CComPtr<IIISApplicationAdmin> spAppAdmin;
    if(m_eServiceId == SC_W3SVC)
    {
        hr = CoCreateInstance(
            CLSID_WamAdmin,
            NULL,
            CLSCTX_ALL,
            IID_IIISApplicationAdmin,
            (void**)&spAppAdmin);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "[%s] CoCreateInstance failed, hr=0x%x\n", __FUNCTION__, hr));
            return hr;
        }
    }

    DWORD dwSiteId = 0;
    hr = InternalCreateNewSite(
        *i_pNamespace,
        vtServerComment,
        vtServerBindings,
        vtPath,
        spAppAdmin,
        &dwSiteId,
        pdwRequestedSiteId);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] InternalCreateNewSite failed, hr=0x%x\n", __FUNCTION__, hr));
        return hr;
    }

    //
    // convert dwSiteId to a metabase path
    //
    WCHAR wszServerId[11] = {0};
    _itow(dwSiteId, wszServerId, 10);

    SIZE_T        cchMbPath               = wcslen(i_wszMbPath);
    SIZE_T        cchServerId             = wcslen(wszServerId);

    SIZE_T       cchKeyPath               = cchMbPath + 1 + cchServerId;
    TSmartPointerArray<WCHAR> swszKeyPath = new WCHAR[cchKeyPath+1];
    if(swszKeyPath == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    LPWSTR pEnd  = NULL;
    memcpy(pEnd  = swszKeyPath, i_wszMbPath,  sizeof(WCHAR) * cchMbPath);
    memcpy(pEnd += cchMbPath,   L"/",         sizeof(WCHAR) * 1);
    memcpy(pEnd += 1,           wszServerId,  sizeof(WCHAR) * (cchServerId+1));

    //
    // From sbstrKeyPath, get sbstrRetVal, a full obj path.
    // This is our return value.
    //
    WMI_CLASS* pServer = (m_eServiceId == SC_MSFTPSVC) ? 
        &WMI_CLASS_DATA::s_FtpServer : &WMI_CLASS_DATA::s_WebServer;

    CComBSTR  sbstrRetVal;
    hr = CUtils::ConstructObjectPath(
        swszKeyPath,
        pServer,
        &sbstrRetVal);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Create WMI return object
    //
    CComPtr<IWbemClassObject> spOutParams;
    hr = CUtils::CreateEmptyMethodInstance(
        i_pNamespace,
        i_pCtx,
        i_pClass->pszClassName,
        i_pMethod->pszMethodName,
        &spOutParams);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Put treats vtRetVal as RO.
    // Deliberately not using smart variant.
    //
    VARIANT  vtRetVal;
    vtRetVal.vt      = VT_BSTR;
    vtRetVal.bstrVal = sbstrRetVal;
    hr = spOutParams->Put(L"ReturnValue", 0, &vtRetVal, 0);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_ppRetObj = spOutParams.Detach();

    return hr;
}

//
// private
//

HRESULT CServiceMethod::InternalGetInParams(
    IWbemClassObject*   i_pInParams,
    VARIANT&            io_refServerId,
    VARIANT&            io_refServerComment,
    VARIANT&            io_refServerBindings,
    VARIANT&            io_refPath)
/*++

Synopsis: 
    Given in parameters from the WMI method call, return the values of the
    parameters in variants.

Arguments: [i_pInParams] - 
           [io_refServerId] - 
           [io_refServerComment] - 
           [io_refServerBindings] - 
           [io_refPath] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_pInParams);

    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR awszParamNames[] = { 
        WMI_METHOD_PARAM_DATA::s_ServerId.pszParamName,
        WMI_METHOD_PARAM_DATA::s_ServerComment.pszParamName,
        WMI_METHOD_PARAM_DATA::s_ServerBindings.pszParamName,
        WMI_METHOD_PARAM_DATA::s_PathOfRootVirtualDir.pszParamName,
        NULL
    };
    VARIANT* apvtParamValues[] = {
        &io_refServerId, &io_refServerComment, &io_refServerBindings, &io_refPath, NULL
    };

    //
    // get in params
    //
    for(ULONG i = 0; awszParamNames[i] != NULL; i++)
    {
        hr = i_pInParams->Get(awszParamNames[i], 0, apvtParamValues[i], NULL, NULL);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

HRESULT CServiceMethod::InternalCreateNewSite(
    CWbemServices&        i_refNamespace,
    const VARIANT&        i_refServerComment,
    const VARIANT&        i_refServerBindings,
    const VARIANT&        i_refPathOfRootVirtualDir,
    IIISApplicationAdmin* i_pIApplAdmin,
    PDWORD                o_pdwSiteId,
    PDWORD                i_pdwRequestedSiteId)   // default value NULL
/*++

Synopsis: 
    Private method that calls the API

Arguments: [i_refNamespace] - 
           [i_refServerComment] - 
           [i_refServerBindings] - 
           [i_refPathOfRootVirtualDir] - 
           [o_pdwSiteId] - 
           [i_pdwRequestedSiteId] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(m_bInit);
    DBG_ASSERT(o_pdwSiteId != NULL);

    HRESULT                       hr                      = S_OK;
    LPWSTR                        mszServerBindings       = NULL;
    DWORD                         dwTemp                  = 0;

    LPWSTR                        wszServerComment        = NULL;
    LPWSTR                        wszPathOfRootVirtualDir = NULL;

    if(i_refServerBindings.vt == (VT_ARRAY | VT_UNKNOWN))
    {
        CMultiSz MultiSz(&METABASE_PROPERTY_DATA::s_ServerBindings, &i_refNamespace);
        hr = MultiSz.ToMetabaseForm(
            &i_refServerBindings,
            &mszServerBindings,
            &dwTemp);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "[%s] MultiSz.ToMetabaseForm failed, hr=0x%x\n", __FUNCTION__, hr));
            goto exit;
        }
    }

    try
    {
        wszServerComment        = CUtils::ExtractBstrFromVt(&i_refServerComment);
        wszPathOfRootVirtualDir = CUtils::ExtractBstrFromVt(&i_refPathOfRootVirtualDir);
    }
    catch(HRESULT ehr)
    {
        hr = ehr;
        goto exit;
    }
    catch(...)
    {
        DBG_ASSERT(false && "Should not be throwing unknown exception");
        hr = WBEM_E_FAILED;
        goto exit;
    }

    hr = m_pSiteCreator->CreateNewSite2(
        m_eServiceId,
        (wszServerComment == NULL) ? L"" : wszServerComment,
        mszServerBindings,
        wszPathOfRootVirtualDir,
        i_pIApplAdmin,
        o_pdwSiteId,
        i_pdwRequestedSiteId);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "[%s] CreateNewSite2 failed, hr=0x%x\n", __FUNCTION__, hr));
        goto exit;
    }

exit:
    delete [] mszServerBindings;
    mszServerBindings = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\provider\makefile.inc ===
#
# Supplemental rules for generating message file.
#


$(O)\iiswmimsg.h $(O)\iiswmimsg.rc $(O)\msg00001.bin: iiswmimsg.mc $(IISBASEDIR)\svcs\infocomm\metadata\interfac\mdmsg.mc
    copy iiswmimsg.mc+$(IISBASEDIR)\svcs\infocomm\metadata\interfac\mdmsg.mc tmp.mc
    mc -v -h .\$(O) -r .\$(O) tmp.mc
    copy $(O)\tmp.h $(O)\iiswmimsg.h
    copy $(O)\tmp.rc $(O)\iiswmimsg.rc
    del $(O)\tmp.*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\webservicemethod.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ServiceMethod.h

Abstract:

    Defines the CServiceMethod class.

    All the methods in this class return HRESULTs and do not throw exceptions.

Author:

    Mohit Srivastava            25-March-01

Revision History:

--*/

#ifndef _ServiceMethod_h_
#define _ServiceMethod_h_

#include "sitecreator.h"
#include "wbemservices.h"
#include "schema.h"

class CServiceMethod
{
public:
    CServiceMethod(
        eSC_SUPPORTED_SERVICES i_eServiceId);

    ~CServiceMethod();

    HRESULT CreateNewSite(
        LPCWSTR        i_wszServerComment,
        PDWORD         o_pdwSiteId,
        PDWORD         i_pdwRequestedSiteId = NULL);

    HRESULT CreateNewSite(
        CWbemServices*     i_pNamespace,
        LPCWSTR            i_wszMbPath,      // needed for creating WMI return object
        IWbemContext*      i_pCtx,           // needed for creating WMI return object
        WMI_CLASS*         i_pClass,         // needed for creating WMI return object
        WMI_METHOD*        i_pMethod,        // needed for creating WMI return object
        IWbemClassObject*  i_pInParams,
        IWbemClassObject** o_ppRetObj);

    HRESULT Init();

private:
    HRESULT InternalGetInParams(
        IWbemClassObject*   i_pInParams,
        VARIANT&            io_refServerId,
        VARIANT&            io_refServerComment,
        VARIANT&            io_refServerBindings,
        VARIANT&            io_refPath);

    HRESULT InternalCreateNewSite(
        CWbemServices&        i_refNamespace, // for formatted multisz: ServerBinding
        const VARIANT&        i_refServerComment,
        const VARIANT&        i_refServerBindings,
        const VARIANT&        i_refPathOfRootVirtualDir,
        IIISApplicationAdmin* i_pIApplAdmin,
        PDWORD                o_pdwSiteId,
        PDWORD                i_pdwRequestedSiteId = NULL);

    bool                     m_bInit;
    CSiteCreator*            m_pSiteCreator;
    eSC_SUPPORTED_SERVICES   m_eServiceId;
};

#endif // _ServiceMethod_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\objpath.cpp ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

inline LPWSTR Macro_CloneLPWSTR(LPCWSTR x)
{
    if (x)
    {
        LPWSTR szTemp = new wchar_t[wcslen(x) + 1];

        if (szTemp)
            wcscpy(szTemp, x);

        return szTemp;
    }
    else
        return NULL;
}

ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    if(m_paNamespaces)
		for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
			m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    if (m_pServer)
        delete m_pServer;

    if (m_paNamespaces)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
            delete m_paNamespaces[dwIx];
        delete m_paNamespaces;
    }

    if (m_pClass)
        delete m_pClass;

    if (m_paKeys)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
            delete m_paKeys[dwIx];
        delete m_paKeys;
    }
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    if (m_pClass)
        delete [] m_pClass;

    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        if(paNewNamespaces == NULL) return FALSE;
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Macro_CloneLPWSTR(wszNamespace);
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

                VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)

    m_paKeys = new KeyRef *[2];
    if (m_paKeys)
        m_dwAllocKeys = 2;
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (!paNewKeys)
            return FALSE;

        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

	if(m_paKeys == NULL)
		return FALSE;
    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    if (!m_paKeys[m_dwNumKeys])
        return FALSE;

    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if(paNewKeys == NULL)return FALSE;
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }
    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];

    if (!wszPath)
        return OutOfMemory;

    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;
    if (!m_pOutput)
        return OutOfMemory;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];

                if (!m_pOutput->m_pServer)
                {
                    delete m_pOutput;
                    return OutOfMemory;
                }

                wcscpy(m_pOutput->m_pServer, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        if (!m_pOutput->m_pServer)
        {
            delete m_pOutput;
            return OutOfMemory;
        }

        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);
    if (!m_pLexer)
    {
        delete m_pOutput;
        return OutOfMemory;
    }

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            if (!m_pOutput->m_pServer)
            {
                delete m_pOutput;
                return OutOfMemory;
            }

            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

void CObjectPathParser::Free( LPWSTR wszUnparsedPath )
{
    delete wszUnparsedPath;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        if (!m_pTmpKeyRef)
            return OutOfMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    if (!m_pTmpKeyRef)
        return OutOfMemory;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        
        if (pTmp)
            wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    if (!pRetVal)
        return NULL;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];

    if (!wszOut)
        return NULL;

    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if(wszOut == NULL)return NULL;
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    if(wszCopy == NULL)return FALSE;
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\mofgen\mofgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mofgen.cpp

Abstract:

    This file contains the implementation of the CMofGen class

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#include "iisprov.h"
#include "mofgen.h"
#include "MultiSzData.h"

#include <initguid.h>
// {041FFF3F-EB8F-4d51-9736-A26E91E3A3CA}
DEFINE_GUID(IisWmiMofgenGuid, 
0x41fff3f, 0xeb8f, 0x4d51, 0x97, 0x36, 0xa2, 0x6e, 0x91, 0xe3, 0xa3, 0xca);

//
// Debugging Stuff
//
#include "pudebug.h"
DECLARE_DEBUG_PRINTS_OBJECT()

extern CDynSchema* g_pDynSch; // Initialized to NULL in schemadynamic.cpp

void ConstructFlatContainerList(METABASE_KEYTYPE*, bool*);

bool CMofGen::ParseCmdLine (int argc, wchar_t **argv)
{
    for (int i=1; i<argc; ++i)
    {
        static wchar_t * wszOUT = L"/out:";
        static wchar_t * wszHEADER = L"/header:";
        static wchar_t * wszFOOTER = L"/footer:";
        
        if (wcsncmp (argv[i], wszOUT, wcslen(wszOUT)) == 0)
        {
            if (m_wszOutFileName != 0)
            {
                // duplicate parameter
                return false;
            }
            m_wszOutFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszOUT) + 1];
            if (m_wszOutFileName == 0)
            {
                return false;
            }
            wcscpy (m_wszOutFileName, argv[i] + wcslen(wszOUT));
        }
        else if (wcsncmp (argv[i], wszHEADER, wcslen (wszHEADER)) == 0)
        {
            if (m_wszHeaderFileName != 0)
            {
                // duplicate parameter
                return false;
            }
            m_wszHeaderFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszHEADER) + 1];
            if (m_wszHeaderFileName == 0)
            {
                return false;
            }
            wcscpy (m_wszHeaderFileName, argv[i] + wcslen(wszHEADER));
        }
        else if (wcsncmp (argv[i], wszFOOTER, wcslen (wszFOOTER)) == 0)
        {
            if (m_wszFooterFileName != 0)
            {
                // duplicate parameter
                return false;
            }
            m_wszFooterFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszFOOTER) + 1];
            if (m_wszFooterFileName == 0)
            {
                return false;
            }
            wcscpy (m_wszFooterFileName, argv[i] + wcslen(wszFOOTER));
        }
        else
        {
            wprintf (L"Unknown parameter: %s\n", argv[i]);
            return false;
        }
    }

    // verify that we have the required parameters

    if (m_wszOutFileName == 0)
    {
        printf ("You need to specify an output file name\n");
        return false;
    }

    if (m_wszHeaderFileName == 0)
    {
        printf ("You need to specify a header file name\n");
        return false;
    }

    if (m_wszFooterFileName == 0)
    {
        printf ("You need to specify a footer file name\n");
        return false;
    }

    return true;
}


void CMofGen::PrintUsage (wchar_t **argv)
{
    DBG_ASSERT(argv != NULL);
    wprintf (L"Usage:\n%s /out:<filename> /header:<filename> /footer:<filename>\n", argv[0]);
}


HRESULT CMofGen::PushMethods(WMI_CLASS* i_pElement)
{
    DBG_ASSERT(i_pElement != NULL);
    DBG_ASSERT(m_pFile != NULL);

    WMI_METHOD* pMethCurrent;

    LPWSTR wszRetType = NULL;
    LPWSTR wszDescription = NULL;
    LPWSTR wszParamType = NULL;
    LPWSTR wszParamTypeSuffix = NULL;
    LPWSTR wszParamInOut = NULL;

    int iError = 0;

    if(i_pElement->ppMethod == NULL)
    {
        return S_OK;
    }

    for(ULONG i = 0; i_pElement->ppMethod[i] != NULL; i++)
    {
        pMethCurrent = i_pElement->ppMethod[i];

        if(pMethCurrent->pszRetType == NULL)
        {
            wszRetType = L"void";
        }
        else
        {
            wszRetType = pMethCurrent->pszRetType;
        }
        wszDescription = pMethCurrent->pszDescription;

        iError = fwprintf(m_pFile, L"\t[Implemented");
        if(iError < 0)
        {
            return E_FAIL;
        }
        if(wszDescription)
        {
            iError = fwprintf(m_pFile, L",Description(\"%s\")", wszDescription);
        }
        iError = fwprintf(m_pFile, L"] %s %s(", wszRetType, pMethCurrent->pszMethodName);
        if(iError < 0)
        {
            return E_FAIL;
        }

        ULONG j = 0;
        if(pMethCurrent->ppParams != NULL)
        {
            for(j = 0; pMethCurrent->ppParams[j] != NULL; j++)
            {
                wszParamType = L"";
                wszParamTypeSuffix = L"";
                wszParamInOut = L"";
                if(j != 0)
                {
                    iError = fwprintf(m_pFile, L", ");
                    if(iError < 0)
                    {
                        return E_FAIL;
                    }
                }
                switch(pMethCurrent->ppParams[j]->type)
                {
                case CIM_STRING:
                    wszParamType = L"string";
                    break;
                case CIM_SINT32:
                    wszParamType = L"sint32";
                    break;
                case VT_ARRAY | CIM_STRING:
                    wszParamType = L"string";
                    wszParamTypeSuffix = L"[]";
                    break;
                case VT_ARRAY | VT_UNKNOWN:
                    wszParamType = L"ServerBinding";
                    wszParamTypeSuffix = L"[]";
                    break;
                case CIM_BOOLEAN:
                    wszParamType = L"boolean";
                    break;
                case CIM_DATETIME:
                    wszParamType = L"datetime";
                    break;
                default:
                    wprintf(L"Warning: Type of Param: %s in Method: %s unknown.  Not outputting type.\n", 
                        pMethCurrent->ppParams[j]->pszParamName,
                        pMethCurrent->pszMethodName);
                    break;
                }
                switch(pMethCurrent->ppParams[j]->iInOut)
                {
                case PARAM_IN:
                    wszParamInOut = L"[IN]";
                    break;
                case PARAM_OUT:
                    wszParamInOut = L"[OUT]";
                    break;
                case PARAM_INOUT:
                    wszParamInOut = L"[IN,OUT]";
                    break;
                default:
                    wprintf(L"Warning: Unsure if Param: %s in Method: %s is IN or OUT param.  Not outputting IN/OUT qualifier\n",
                        pMethCurrent->ppParams[j]->pszParamName,
                        pMethCurrent->pszMethodName);
                    break;
                }
                iError = fwprintf(m_pFile, L"%s %s %s%s", 
                    wszParamInOut, wszParamType, pMethCurrent->ppParams[j]->pszParamName, wszParamTypeSuffix);
                if(iError < 0)
                {
                    return E_FAIL;
                }
            }
        }

        iError = fwprintf(m_pFile, L");\n");
        if(iError < 0)
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT CMofGen::GenerateEscapedString(LPCWSTR i_wsz)
{
    DBG_ASSERT(i_wsz != NULL);

    ULONG cchOld = 0;
    ULONG cchNew = 0;
    LPWSTR wsz;

    for(ULONG i = 0; i_wsz[i] != L'\0'; i++)
    {
        if(i_wsz[i] == L'\\' || i_wsz[i] == L'\"')
        {
            cchNew += 2;
        }
        else
        {
            cchNew++;
        }
        cchOld++;
    }

    if(cchNew > m_cchTemp || m_wszTemp == NULL)
    {
        delete [] m_wszTemp;
        m_wszTemp = new WCHAR[1+cchNew*2];
        if(m_wszTemp == NULL)
        {
            m_cchTemp = 0;
            return E_OUTOFMEMORY;
        }
        m_cchTemp = cchNew*2;
    }

    ULONG j = 0;
    for(ULONG i = 0; i < cchOld; i++)
    {
        if(i_wsz[i] == L'\\' || i_wsz[i] == L'\"')
        {
            m_wszTemp[j] = L'\\';
            m_wszTemp[j+1] = i_wsz[i];
            j+=2;
        }
        else
        {
            m_wszTemp[j] = i_wsz[i];
            j++;
        }
    }
    DBG_ASSERT(m_wszTemp != NULL);
    m_wszTemp[j] = L'\0';

    return S_OK;
}

HRESULT CMofGen::PushProperties(WMI_CLASS* i_pElement)
{
    DBG_ASSERT(i_pElement != NULL);
    DBG_ASSERT(m_pFile != NULL);

    HRESULT hr = S_OK;
    METABASE_PROPERTY* pPropCurrent;
    
    LPWSTR wszType = NULL;
    LPWSTR wszTypeSuffix = NULL;
    LPWSTR wszQual = NULL;
    LPWSTR wszDefault = NULL;
    LPWSTR wszQuote = L"";

    int iError = 0;

    if(i_pElement->ppmbp == NULL)
    {
        return hr;
    }

    for(ULONG i = 0; i_pElement->ppmbp[i] != NULL; i++)
    {   
        wszQual = wszTypeSuffix = wszType = wszQuote = L"";
        wszDefault = NULL;
        WCHAR wszBuf[20];

        pPropCurrent= i_pElement->ppmbp[i];
        switch(pPropCurrent->dwMDDataType)
        {
        case DWORD_METADATA:
            if(pPropCurrent->dwMDMask != 0)
            {
                wszType = L"boolean";
                if(pPropCurrent->pDefaultValue)
                {
                    if(*((int *)(pPropCurrent->pDefaultValue)) == 0)
                    {
                        //wcscpy(wszBuf, L"false");
                        //wszDefault = wszBuf;
                    }
                    else
                    {
                        //wcscpy(wszBuf, L"true");
                        //wszDefault = wszBuf;
                    }
                }
            }
            else
            {
                wszType = L"sint32";
                if(pPropCurrent->pDefaultValue)
                {
                    //swprintf(wszBuf, L"%d", *((int *)(pPropCurrent->pDefaultValue)));
                    //wszDefault = wszBuf;
                }
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            wszType = L"string";
            wszQuote = L"\"";
            /*if(pPropCurrent->pDefaultValue != NULL)
            {
                //
                // Sets m_wszTemp
                //
                hr = GenerateEscapedString((LPWSTR)pPropCurrent->pDefaultValue);
                if(FAILED(hr))
                {
                    goto exit;
                }
                wszDefault = m_wszTemp;;
            }*/
            break;
        case MULTISZ_METADATA:
            {
                wszType = L"string";
                TFormattedMultiSz* pFormattedMultiSz = 
                    TFormattedMultiSzData::Find(pPropCurrent->dwMDIdentifier);
                if(pFormattedMultiSz)
                {
                    wszType = pFormattedMultiSz->wszWmiClassName;
                }
                wszTypeSuffix = L"[]";
                break;
            }
        case BINARY_METADATA:
            wszType = L"uint8";
            wszTypeSuffix = L"[]";
            break;
        default:
            wprintf(L"Warning: Cannot determine type of Prop: %s in Class: %s.  Ignoring property.\n", pPropCurrent->pszPropName, i_pElement->pszClassName);
            continue;
        }
        
        //
        // qualifier for read-only
        //
        if(pPropCurrent->fReadOnly)
        {
            wszQual = L"[read, write(FALSE)]";
        }
        else
        {
            wszQual = L"[read, write]";
        }

        if(wszDefault)
        {
            iError = fwprintf(m_pFile, L"\t%s %s %s%s = %s%s%s;\n", 
                wszQual, wszType, pPropCurrent->pszPropName, wszTypeSuffix, 
                wszQuote, wszDefault, wszQuote);
        }
        else
        {
            iError = fwprintf(m_pFile, L"\t%s %s %s%s;\n", 
                wszQual, wszType, pPropCurrent->pszPropName, wszTypeSuffix);
        }
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CMofGen::PushAssociationComponent(LPWSTR i_wszComp, 
                                          LPWSTR i_wszClass)
{
    DBG_ASSERT(i_wszComp != NULL);
    DBG_ASSERT(i_wszClass != NULL);
    DBG_ASSERT(m_pFile != NULL);

    HRESULT hr = S_OK;

    int iError = fwprintf(m_pFile, L"\t[key] %s ref %s = NULL;\n", i_wszClass, i_wszComp);
    if(iError < 0)
    {
        return E_FAIL;
    }

    return hr;
}

HRESULT CMofGen::PushFormattedMultiSz()
{
    DBG_ASSERT(m_pFile != NULL);

    HRESULT             hr                     = S_OK;
    int                 iError                 = 0;
    TFormattedMultiSz** apFormattedMultiSz     = TFormattedMultiSzData::apFormattedMultiSz;

    if(apFormattedMultiSz == NULL)
    {
        goto exit;
    }

    for(ULONG i = 0; apFormattedMultiSz[i] != NULL; i++)
    {
        iError = fwprintf(m_pFile, L"[provider(\"%s\"),Locale(1033)", g_wszIIsProvider);
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
        iError = fwprintf(m_pFile, L"]\n");
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
        iError = fwprintf(m_pFile, L"class %s : IIsStructuredDataClass\n", apFormattedMultiSz[i]->wszWmiClassName);
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
        iError = fwprintf(m_pFile, L"{\n");
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }

        LPCWSTR* awszFields = apFormattedMultiSz[i]->awszFields;
        if(awszFields != NULL)
        {
            for(ULONG j = 0; awszFields[j] != NULL; j++)
            {
                iError = fwprintf(m_pFile, L"\t[key, read, write] string %s;\n", awszFields[j]);
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
            }
        }

        iError = fwprintf(m_pFile, L"};\n\n");
        if(iError < 0)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

exit:
    return hr;
}

HRESULT CMofGen::PushFile (LPWSTR i_wszFile)
{
    DBG_ASSERT(i_wszFile != NULL);
    DBG_ASSERT(m_pFile != NULL);

    FILE *pFile = _wfopen (i_wszFile, L"r");
    if (pFile == NULL)
    {
        wprintf(L"Could not open %s for reading\n", i_wszFile);
        return RETURNCODETOHRESULT(ERROR_OPEN_FAILED);
    }

    WCHAR wszBuffer[512];

    while (fgetws (wszBuffer, 512, pFile) != 0)
    {
        fputws (wszBuffer, m_pFile);
    }

    fclose (pFile);

    return S_OK;
}

HRESULT CMofGen::Push()
{
    HRESULT hr = S_OK;

    if(m_pFile == NULL)
    {
        m_pFile = _wfopen(m_wszOutFileName, L"w+");
        if(m_pFile == NULL)
        {
            wprintf(L"Could not open %s for writing\n", m_wszOutFileName);
            hr = RETURNCODETOHRESULT(ERROR_OPEN_FAILED);
            goto exit;
        }
    }

    hr = PushFile(m_wszHeaderFileName);
    if(FAILED(hr))
    {
        goto exit;
    }
    if(fwprintf(m_pFile, L"\n\n") < 0)
    {
        hr = E_FAIL;
        goto exit;
    }
    hr = PushFormattedMultiSz();
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = PushClasses(g_pDynSch->GetHashClasses(), false);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = PushClasses(g_pDynSch->GetHashAssociations(), true);
    if(FAILED(hr))
    {
        goto exit;
    }
    hr = PushFile(m_wszFooterFileName);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    return hr;
}

int __cdecl wmain(int argc, wchar_t* argv[])
{
#ifndef _NO_TRACING_
    // CREATE_DEBUG_PRINT_OBJECT("Mofgen.exe", IisWmiMofgenGuid);
    CREATE_DEBUG_PRINT_OBJECT("Mofgen.exe");
#else
    CREATE_DEBUG_PRINT_OBJECT("Mofgen.exe");
#endif

    HRESULT hr = S_OK;
    CMofGen mofgen;
    CSchemaExtensions catalog;

    g_pDynSch = NULL;
    
    g_pDynSch = new CDynSchema();
    if(g_pDynSch == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = g_pDynSch->Initialize();
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = g_pDynSch->RunRules(&catalog, false);
    if(FAILED(hr))
    {
        goto exit;
    }
    if(!mofgen.ParseCmdLine(argc, argv))
    {
        mofgen.PrintUsage(argv);
        hr = E_INVALIDARG;
        goto exit;
    }
    hr = mofgen.Push();
    if(FAILED(hr))
    {
        goto exit;
    }
    
exit:
    delete g_pDynSch;
    g_pDynSch = NULL;
    DELETE_DEBUG_PRINT_OBJECT();
    if(FAILED(hr))
    {
        printf("MofGen failed, code: 0x%x\n", hr);
        return 1;
    }
    else
    {
        wprintf(L"MofGen successful!  %s created.\n", mofgen.GetOutFileName());
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\mofgen\mofgen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mofgen.h

Abstract:

    This include file contains the definition for the CMofGen class

Author:

    Mohit Srivastava            28-Nov-00

Revision History:

--*/

#ifndef _mofgen_h_
#define _mofgen_h_

extern LPCWSTR g_wszIIsProvider; // defined in iisprov.h

class CMofGen
{
public:
    CMofGen() : m_pFile(NULL),
        m_wszHeaderFileName(NULL),
        m_wszFooterFileName(NULL),
        m_wszOutFileName(NULL),
        m_wszTemp(NULL),
        m_cchTemp(0)
    {
    }
    virtual ~CMofGen()
    {
        if(m_pFile != NULL)
        {
            fclose(m_pFile);
        }
        delete [] m_wszTemp;
    }
    bool ParseCmdLine (int argc, wchar_t **argv);
    void PrintUsage (wchar_t **argv);

    HRESULT Push();
    LPWSTR GetOutFileName()
    {
        return m_wszOutFileName;
    }

private:
    //
    // File handle to output file
    //
    FILE* m_pFile;

    LPWSTR m_wszHeaderFileName;
    LPWSTR m_wszFooterFileName;
    LPWSTR m_wszOutFileName;

    LPWSTR m_wszTemp;
    ULONG  m_cchTemp;

    HRESULT GenerateEscapedString(LPCWSTR i_wsz);

    HRESULT PushProperties(
        WMI_CLASS* i_pElement);

    HRESULT PushMethods(
        WMI_CLASS* i_pElement);

    HRESULT PushAssociationComponent(
        LPWSTR i_wszComp, 
        LPWSTR i_wszClass);

    HRESULT PushFormattedMultiSz();

    HRESULT PushFile(
        LPWSTR i_wszFile);

    template <class T>
    HRESULT PushClasses(CHashTable<T>* i_phashTable,
                        bool bAssoc)
    {
        DBG_ASSERT(i_phashTable != NULL);
        DBG_ASSERT(m_pFile != NULL);

        HRESULT hr = S_OK;

        //
        // Vars needed for iteration
        //
        CHashTable<T>::Record*   pRec = NULL;

        LPWSTR wszParentClass = NULL;
        LPWSTR wszDescription = NULL;

        int iError = 0;

        //
        // Walk thru classes
        //
        ULONG iShipped;
        CHashTable<T>::iterator iter;
	    CHashTable<T>::iterator iterEnd = i_phashTable->end();
	    for (iter = i_phashTable->begin();  iter != iterEnd;  ++iter)
        {
            pRec = iter.Record();
            iShipped = bAssoc ? 
                ((WMI_ASSOCIATION*)(pRec->m_data))->dwExtended :
                ((WMI_CLASS*)(pRec->m_data))->dwExtended;
            if(iShipped == SHIPPED_TO_MOF)
            {
                if(!bAssoc)
                {
                    wszParentClass = ((WMI_CLASS*)(pRec->m_data))->pszParentClass;
                    wszDescription = ((WMI_CLASS*)(pRec->m_data))->pszDescription;
                }
                else
                {
                    wszParentClass = ((WMI_ASSOCIATION*)(pRec->m_data))->pszParentClass;
                    // wszDescription = ((WMI_ASSOCIATION*)(pRec->m_data))->pszDescription;
                }

                iError = fwprintf(m_pFile, L"[dynamic : ToInstance,provider(\"%s\"),Locale(1033)", g_wszIIsProvider);
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                if(wszDescription != NULL)
                {
                    iError = fwprintf(m_pFile, L",Description(\"%s\")", wszDescription);
                    if(iError < 0)
                    {
                        hr = E_FAIL;
                        goto exit;
                    }
                }
                iError = fwprintf(m_pFile, L"]\n");
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                iError = fwprintf(m_pFile, L"class %s : %s\n", pRec->m_wszKey, wszParentClass);
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                iError = fwprintf(m_pFile, L"{\n");
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }

                if(!bAssoc)
                {
                    bool bPutNameProperty = true;
                    for(ULONG j = 0; g_awszParentClassWithNamePK[j] != NULL; j++)
                    {
                        //
                        // Deliberate ==
                        //
                        if(g_awszParentClassWithNamePK[j] == ((WMI_CLASS *)(pRec->m_data))->pszParentClass)
                        {
                            bPutNameProperty = false;
                        }
                    }
                    if( bPutNameProperty )
                    {
                        iError = fwprintf(m_pFile, L"\t[Key] string Name;\n");
                        if(iError < 0)
                        {
                            hr = E_FAIL;
                            goto exit;
                        }
                    }
                    hr = PushProperties((WMI_CLASS *)(pRec->m_data));
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                    hr = PushMethods((WMI_CLASS *)(pRec->m_data));
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                }
                else
                {
                    hr = PushAssociationComponent(
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pType->pszLeft,
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pcLeft->pszClassName);
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                    hr = PushAssociationComponent(
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pType->pszRight,
                        ((WMI_ASSOCIATION *)(pRec->m_data))->pcRight->pszClassName);
                    if(FAILED(hr))
                    {
                        goto exit;
                    }
                }

                iError = fwprintf(m_pFile, L"};\n\n");
                if(iError < 0)
                {
                    hr = E_FAIL;
                    goto exit;
                }
            }
        }

    exit:
        return hr;
    }
};

#endif // _mofgen_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\providerbase.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ProviderBase.cpp

Abstract:

    Implementation of:
        CProviderBase

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#include "ProviderBase.h"
#include <dbgutil.h>

extern long        g_cObj;

//
// CProviderBase (Implements IWbemServices, IWbemProviderInit)
//

CProviderBase::CProviderBase(
    const BSTR ObjectPath,
    const BSTR User, 
    const BSTR Password, 
    IWbemContext * pCtx)
    :m_cRef(0), m_pNamespace(NULL)
{
}

CProviderBase::~CProviderBase()
{
    if(m_pNamespace)
        delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CProviderBase::AddRef(void)
{
    InterlockedIncrement(&g_cObj);

    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CProviderBase::Release(void)
{
    InterlockedDecrement(&g_cObj);

    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
        delete this;
    
    return (lNewCount > 0) ? lNewCount : 0;
}

STDMETHODIMP 
CProviderBase::QueryInterface(
    REFIID riid, 
    PPVOID ppv)
{
    *ppv=NULL;

    //
    // Since we have dual inheritance, it is necessary to cast the return type
    //

    if(riid== IID_IWbemServices)
       *ppv = (IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv = (IWbemProviderInit*)this;
    
    if (NULL != *ppv)
    {
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
  
}

HRESULT
CProviderBase::Initialize(
    LPWSTR                 wszUser, 
    LONG                   lFlags,
    LPWSTR                 wszNamespace, 
    LPWSTR                 wszLocale,
    IWbemServices*         pNamespace, 
    IWbemContext*          pCtx,
    IWbemProviderInitSink* pInitSink)
/*++

Synopsis: 
    According to stevm from WMI, calls to Initialize are guaranteed to be
    synchronized - so long as all providers are in the same namespace.

Arguments: [wszUser] - 
           [lFlags] - 
           [wszNamespace] - 
           [wszLocale] - 
           [pNamespace] - 
           [pCtx] - 
           [pInitSink] - 
           
Return Value: 

--*/
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pInitSink->SetStatus(WBEM_E_FAILED, 0);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoInitialize(
        wszUser,
        lFlags,
        wszNamespace,
        wszLocale,
        pNamespace,
        pCtx,
        pInitSink);
}



HRESULT
CProviderBase::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoCreateInstanceEnumAsync(
        Class,
        lFlags,
        pCtx,
        pResponseHandler);
}

HRESULT
CProviderBase::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoDeleteInstanceAsync(
        ObjectPath,
        lFlags,
        pCtx,
        pResponseHandler);
}


HRESULT
CProviderBase::ExecMethodAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR MethodName, 
    /* [in] */ long lFlags, 
    /* [in] */ IWbemContext* pCtx,
    /* [in] */ IWbemClassObject* pInParams,
    /* [in] */ IWbemObjectSink* pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoExecMethodAsync(
        strObjectPath,
        MethodName,
        lFlags,
        pCtx,
        pInParams,
        pResponseHandler);
    
}


HRESULT
CProviderBase::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoExecQueryAsync(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        pResponseHandler);
    
}


HRESULT
CProviderBase::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoGetObjectAsync(
        ObjectPath,
        lFlags,
        pCtx,
        pResponseHandler);
    
}


HRESULT
CProviderBase::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if(FAILED(hr))
    {
        pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        DBGPRINTF((DBG_CONTEXT, "CoImpersonateClient failed\n"));
        return WBEM_E_FAILED;
    }
    return DoPutInstanceAsync(
        pInst,
        lFlags,
        pCtx,
        pResponseHandler);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sqllex.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    sqllex.cpp

Abstract:

    SQL Level 1 DFA Table

History:


--*/

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>             

#define ST_STRING   23
#define ST_IDENT    28
#define ST_GE       34
#define ST_LE       36
#define ST_NE       39
#define ST_NUMERIC  41
#define ST_REAL     44
#define ST_STRING2  50
#define ST_STRING_ESC 55
#define ST_STRING2_ESC 56

// DFA State Table for SQL Level 1 lexical symbols.
// ================================================

LexEl Sql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,  SQL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  SQL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, 0,  SQL_1_TOK_DOT,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  SQL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  SQL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  SQL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  SQL_1_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 22 */ GLEX_ANY, GLEX_EMPTY, 0,        SQL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 23 */   L'\n', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 24 */   L'\r', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'"',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 26 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 27 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 28 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 29 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  0x80,   0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 34 */  L'=',   GLEX_EMPTY,  0,  SQL_1_TOK_GE,  GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 36 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_LE,  GLEX_ACCEPT,
/* 37 */  L'>',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,    0,  SQL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 39 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,     GLEX_ACCEPT,
/* 40 */  GLEX_ANY,  GLEX_EMPTY,   0,  SQL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 41 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 42 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 43 */  GLEX_ANY, GLEX_EMPTY, 0,          SQL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 44 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 45 */  L'E',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 46 */  L'e',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 47 */  L'+',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 48 */  L'-',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 49 */  GLEX_ANY,       GLEX_EMPTY,   0,     SQL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 50 */   L'\n',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\r',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 52 */   L'\'',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 53 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 56 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemobjectsink.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    WbemObjectSink.h

Abstract:

    Definition of:
        CWbemObjectSink

    Wraps IWbemObjectSink.  Batches the Indicate call.

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#ifndef __wbemobjectsink_h__
#define __wbemobjectsink_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <windows.h>
#include <wbemprov.h>

typedef LPVOID * PPVOID;

class CWbemObjectSink
{   
protected:
    IWbemObjectSink*   m_pSink;
    IWbemClassObject** m_ppInst;
    DWORD              m_dwThreshHold; // Number of "Indicates" to cache
    DWORD              m_dwIndex;

public:
    CWbemObjectSink(
        IWbemObjectSink*,
        DWORD = 50);

    virtual ~CWbemObjectSink();

    void Indicate(IWbemClassObject*);

    void SetStatus(
        LONG,
        HRESULT,
        const BSTR, 
        IWbemClassObject*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sql_1ext.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    sql_1ext.h

Abstract:

    Extends the SQL_LEVEL_1_RPN_EXPRESSION

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _sql_1ext_h_
#define _sql_1ext_h_

#include <sql_1.h>

struct SQL_LEVEL_1_RPN_EXPRESSION_EXT : public SQL_LEVEL_1_RPN_EXPRESSION
{
    SQL_LEVEL_1_RPN_EXPRESSION_EXT() : SQL_LEVEL_1_RPN_EXPRESSION()
    {
        m_bContainsOrOrNot = false;
    }

    void SetContainsOrOrNot()
    {
        SQL_LEVEL_1_TOKEN* pToken     = pArrayOfTokens;

        m_bContainsOrOrNot = false;
        for(int i = 0; i < nNumTokens; i++, pToken++)
        {
            if( pToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_OR ||
                pToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_NOT )
            {
                m_bContainsOrOrNot = true;
                break;
            }
        }
    }

    bool GetContainsOrOrNot() const { return m_bContainsOrOrNot; }

    const SQL_LEVEL_1_TOKEN* GetFilter(LPCWSTR    i_wszProp) const
    {
        SQL_LEVEL_1_TOKEN* pToken = pArrayOfTokens;

        for(int i = 0; i < nNumTokens; i++, pToken++)
        {
             if( pToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION && 
                 _wcsicmp(pToken->pPropertyName, i_wszProp) == 0 )
             {
                 return pToken;
             }
        }
        return NULL;
    }

    bool FindRequestedProperty(LPCWSTR i_wszProp) const
    {
        //
        // This means someone did a select *
        //
        if(nNumberOfProperties == 0)
        {
            return true;
        }

        for(int i = 0; i < nNumberOfProperties; i++)
        {
            if(_wcsicmp(pbsRequestedPropertyNames[i], i_wszProp) == 0)
            {
                return true;
            }
        }

        return false;
    }

private:
    bool m_bContainsOrOrNot;
};

#endif // _sql_1ext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemobjectsink.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    WbemObjectSink.cpp

Abstract:

    Implementation of:
        CWbemObjectSink

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#include "WbemObjectSink.h"
#include <dbgutil.h>

CWbemObjectSink::CWbemObjectSink(
    IWbemObjectSink* pHandler,
    DWORD            dwSize)
    :m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
    m_pSink = pHandler;
    if(m_pSink != NULL)
    {
        m_pSink->AddRef();
    }
    m_dwThreshHold = dwSize;
    m_ppInst       = new IWbemClassObject*[dwSize];
    memset(m_ppInst, 0, sizeof(IWbemClassObject*) * dwSize);
}

CWbemObjectSink::~CWbemObjectSink()
{
    if(m_ppInst != NULL)
    {
        if(m_dwIndex >0)
        {
            m_pSink->Indicate(
                m_dwIndex,
                m_ppInst);
        }

        for(DWORD i =0; i<m_dwIndex; i++)
        {
            if(m_ppInst[i] != NULL)
            {
                (m_ppInst[i])->Release();
            }
        }
        delete [] m_ppInst;
    }

    if(m_pSink != NULL)
    {
        m_pSink->Release();
    }
}

void 
CWbemObjectSink::Indicate(IWbemClassObject* pInst)
{
    if(pInst == NULL)
    {
        throw (HRESULT)WBEM_E_INVALID_PARAMETER;
    }

    m_ppInst[m_dwIndex++] = pInst;
    DBG_ASSERT(m_dwIndex <= m_dwThreshHold);
    pInst->AddRef();
    if(m_dwIndex == m_dwThreshHold)
    {
        SCODE  sc = m_pSink->Indicate(
            m_dwIndex,
            m_ppInst);
        
        //
        // reset state
        //
        for(DWORD i=0; i< m_dwThreshHold; i++)
        {
            if(m_ppInst[i] != NULL)
            {
                (m_ppInst[i])->Release();
            }
            m_ppInst[i] = NULL;
        }
        m_dwIndex = 0;

        if(sc != S_OK)
        {
            throw (HRESULT)sc;
        }
    }
    return;
}

void
CWbemObjectSink::SetStatus(
    LONG              lFlags,
    HRESULT           hr,
    const BSTR        bstrParam,
    IWbemClassObject* pObjParam)
{
    m_pSink->SetStatus(
        lFlags,
        hr,
        bstrParam,
        pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\providerbase.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ProviderBase.h

Abstract:

    Definition of:
        CProviderBase

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#ifndef __providerbase_h__
#define __providerbase_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include "WbemServices.h"

typedef LPVOID * PPVOID;

//
// CProviderBase
// Purpose: provide a general solution for impersonate client for 
// Wbem providers.
// USAGE:
// Inherit from this class, and implement abstact virtual functions.
// child class should implement function prefixed with "Do".
//
class CProviderBase : public IWbemServices, public IWbemProviderInit 
{
protected:
    ULONG           m_cRef;                 // Object reference count
    CWbemServices*  m_pNamespace;
 
public:
    CProviderBase(
        const BSTR    = NULL, 
        const BSTR    = NULL, 
        const BSTR    = NULL, 
        IWbemContext* = NULL);

    virtual ~CProviderBase();

    //
    // Non-delegating object IUnknown
    //
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    //IWbemProviderInit
    //
    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR wszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR wszNamespace,
         /* [in] */ LPWSTR wszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
         );

    //
    //IWbemServices  
    //
    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemClassObject**, 
        IWbemCallResult**) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        const BSTR,
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemObjectSink*);

protected:
    virtual HRESULT STDMETHODCALLTYPE DoInitialize(
         /* [in] */ LPWSTR wszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR wszNamespace,
         /* [in] */ LPWSTR wszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
        /* [in] */ const BSTR,                      // Class,
        /* [in] */ long,                            // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ const BSTR ,                     // ObjectPath,
        /* [in] */ long,                            // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        /* [in] */ const BSTR,
        /* [in] */ const BSTR, 
        /* [in] */ long, 
        /* [in] */ IWbemContext*,
        /* [in] */ IWbemClassObject*,
        /* [in] */ IWbemObjectSink*
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ const BSTR,                      // QueryLanguage,
        /* [in] */ const BSTR,                      // Query,
        /* [in] */ long,                            // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *,    // pInst,
        /* [in] */ long ,   // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,        // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *      // pResponseHandler
        ) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sqllex.h ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    sqllex.h

Abstract:

    SQL Level 1 DFA Table & Tokens

History:

--*/

#ifndef _SQLLEX_H_
#define _SQLLEX_H_

#define SQL_1_TOK_EOF           0
#define SQL_1_TOK_ERROR         1
#define SQL_1_TOK_IDENT         100
#define SQL_1_TOK_QSTRING       101
#define SQL_1_TOK_INT           102
#define SQL_1_TOK_REAL          103
#define SQL_1_TOK_CHAR          104
#define SQL_1_TOK_BOOL          105

#define SQL_1_TOK_LE            106
#define SQL_1_TOK_LT            107
#define SQL_1_TOK_GE            108
#define SQL_1_TOK_GT            109
#define SQL_1_TOK_EQ            110
#define SQL_1_TOK_NE            111

#define SQL_1_TOK_DOT           112
#define SQL_1_TOK_OPEN_PAREN    113
#define SQL_1_TOK_CLOSE_PAREN   114
#define SQL_1_TOK_ASTERISK      115
#define SQL_1_TOK_COMMA         116

#define SQL_1_TOK_SELECT        120
#define SQL_1_TOK_WHERE         121
#define SQL_1_TOK_FROM          122
#define SQL_1_TOK_LIKE          123
#define SQL_1_TOK_OR            124
#define SQL_1_TOK_AND           125
#define SQL_1_TOK_NOT           126
#define SQL_1_TOK_IS            127
#define SQL_1_TOK_NULL          128

extern LexEl Sql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\sql_1.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SQL_1.CPP

Abstract:

  Level 1 Syntax SQL Parser

  Implements the syntax described in SQL_1.BNF.  This translates the input
  into an RPN stream of tokens.

History:

  21-Jun-96       Created.

--*/

#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

class CX_Exception {};

class CX_MemoryException : CX_Exception {};

//#define trace(x) printf x
#define trace(x)

static DWORD TranslateIntrinsic(LPWSTR pFuncName)
{
    if (_wcsicmp(pFuncName, L"UPPER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_UPPER;
    if (_wcsicmp(pFuncName, L"LOWER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_LOWER;
    return SQL_LEVEL_1_TOKEN::IFUNC_NONE;
}

SQL1_Parser::SQL1_Parser(CGenLexSource *pSrc)
{
    Init(pSrc);
}

SQL1_Parser::~SQL1_Parser()
{
    Cleanup();
}

void SQL1_Parser::Init(CGenLexSource *pSrc)
{
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_pExpression = 0;
    m_pLexer = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_pIdent = 0;
    m_pPropComp = 0;
    m_bConstIsStrNumeric = FALSE;

    if (pSrc)
    {
        m_pLexer = new CGenLexer(Sql_1_LexTable, pSrc);
        m_pExpression = new SQL_LEVEL_1_RPN_EXPRESSION;
    }
}

void SQL1_Parser::Cleanup()
{
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    delete m_pPropComp;
    delete m_pLexer;
    delete m_pExpression;
}

void SQL1_Parser::SetSource(CGenLexSource *pSrc)
{
    Cleanup();
    Init(pSrc);
}

int SQL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    if ((!m_pLexer) || (!pDestBuf))
    {
        return FAILED;
    }

    // Scan until 'FROM' and then get the class name.
    // ==============================================

    for (;;)
    {
        m_nCurrentToken = m_pLexer->NextToken();

        if (m_nCurrentToken == SQL_1_TOK_EOF)
        {
            m_pLexer->Reset();
            return FAILED;
        }

        if (_wcsicmp(m_pLexer->GetTokenText(), L"from") == 0)
        {
            m_nCurrentToken = m_pLexer->NextToken();
            if (m_nCurrentToken != SQL_1_TOK_IDENT)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            // If here, we have the class name.
            // ================================
            if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen)
            {
                m_pLexer->Reset();
                return BUFFER_TOO_SMALL;
            }

            wcscpy(pDestBuf, m_pLexer->GetTokenText());
            break;
        }
    }

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

int SQL1_Parser::Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    if ((!m_pLexer) || (!pOutput))
    {
        return FAILED;
    }

    *pOutput = 0;

    int nRes = parse();
    if (nRes)
        return nRes;

    *pOutput = m_pExpression;
    m_pExpression = 0;

    return SUCCESS;
}

LPSTR ToAnsi(LPWSTR Src)
{
    static char buf[256];
    WideCharToMultiByte(CP_ACP, NULL, Src, -1, buf, 256, NULL, NULL);
    return buf;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL SQL1_Parser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == SQL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == SQL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        if (_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = SQL_1_TOK_SELECT;
        else if (_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = SQL_1_TOK_FROM;
        else if (_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = SQL_1_TOK_WHERE;
        else if (_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = SQL_1_TOK_LIKE;
        else if (_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = SQL_1_TOK_OR;
        else if (_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = SQL_1_TOK_AND;
        else if (_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = SQL_1_TOK_NOT;
        else if (_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = SQL_1_TOK_IS;
        else if (_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = SQL_1_TOK_NULL;
        else if (_wcsicmp(m_pTokenText, L"TRUE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"65535";
        }
        else if (_wcsicmp(m_pTokenText, L"FALSE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"0";
        }
    }

    return TRUE;
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int SQL1_Parser::parse()
{
    int nRes;

    // SELECT
    // ======
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != SQL_1_TOK_SELECT)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <prop_list>
    // ===========
    if (nRes = prop_list())
        return nRes;

    // FROM
    // ====
    if (m_nCurrentToken != SQL_1_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <classname>
    // ===========
    if (nRes = class_name())
        return nRes;

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int SQL1_Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_EOF)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != SQL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is SQL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != SQL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int SQL1_Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != SQL_1_TOK_ASTERISK &&
        m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    if (!Next())
        return LEXICAL_ERROR;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::prop_list_2()
{
    if (m_nCurrentToken == SQL_1_TOK_COMMA)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int SQL1_Parser::property_name()
{
    try
    {
        if (m_nCurrentToken == SQL_1_TOK_ASTERISK)
        {
            trace(("Asterisk\n"));

            // We need to clean up the expression so far.
            for (int i = 0; i < m_pExpression->nNumberOfProperties; i++)
                SysFreeString(m_pExpression->pbsRequestedPropertyNames[i]);

            m_pExpression->nNumberOfProperties = 0;
                // This signals 'all properties' to the evaluator
            return SUCCESS;
        }

        // Else a property name.
        // =====================

        trace(("Property name %S\n", m_pTokenText));

        m_pExpression->AddProperty(m_pTokenText);
    }
    catch (...)
    {
        return FAILED;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int SQL1_Parser::class_name()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pExpression->bsClassName = SysAllocString(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int SQL1_Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int SQL1_Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_OR)
        {
            trace(("Token OR\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int SQL1_Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_AND)
        {
            trace(("Token AND\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int SQL1_Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
        pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
        m_pExpression->AddToken(pNewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == SQL_1_TOK_INT ||
             m_nCurrentToken == SQL_1_TOK_REAL ||
             m_nCurrentToken == SQL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER <trailing_prop_expr2>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (!m_pIdent)
    {
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);
    }
    else
    {
        m_pPropComp = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pPropComp, m_pTokenText);
    }

    if (!Next())
        return LEXICAL_ERROR;

    return trailing_prop_expr2();
}

//***************************************************************************
//
//  <trailing_prop_expr2> ::= OPEN_PAREN IDENTIFIER CLOSE_PAREN;
//  <trailing_prop_expr2> ::= <>;
//
//***************************************************************************
// ok

int SQL1_Parser::trailing_prop_expr2()
{
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // If we got to this point, the string pointed to by m_pIdent
        // was an intrinsic function and not a property name, and we
        // are about to get the property name, so we have to translate
        // the function name to its correct code before overwriting it.
        // ============================================================
        trace(("Translating intrinsic function %S\n", m_pIdent));
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    trace(("Property name is %S\n", m_pIdent));
    return SUCCESS;
}


//***************************************************************************
//
//  <leading_ident_expr> ::= OPEN_PAREN <unknown_func_expr>;
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int SQL1_Parser::leading_ident_expr()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return unknown_func_expr();
    }
    if (SUCCESS ==  comp_operator() || SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != SQL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <unknown_func_expr> ::= IDENTIFIER CLOSE_PAREN
//                          <rel_operator> <trailing_const_expr>;
//
//  <unknown_func_expr> ::= <typed_constant> CLOSE_PAREN
//                          <rel_operator> <trailing_prop_expr>;
//
//***************************************************************************
// ok
int SQL1_Parser::unknown_func_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = rel_operator())
            return nRes;
        return trailing_const_expr();
    }

    // Else the other production.
    // ==========================

    if (nRes = typed_constant())
        return nRes;

    // If here, we know that the leading ident was
    // an intrinsic function.
    // ===========================================

    m_dwConstFunction = TranslateIntrinsic(m_pIdent);
    delete m_pIdent;
    m_pIdent = 0;

    if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;
    if (nRes = rel_operator())
        return nRes;

    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//  <trailing_or_null> ::= <trailing_prop_expr>;
//
//***************************************************************************

int SQL1_Parser::trailing_or_null()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    else if (!(nRes = trailing_const_expr()))
        return nRes;
    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_const_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("Function applied to typed const = %S\n", m_pTokenText));

        m_dwConstFunction = TranslateIntrinsic(m_pTokenText);
        if (!m_dwConstFunction)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
    if (!Next())
            return LEXICAL_ERROR;

        if (nRes = typed_constant())
            return nRes;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    return typed_constant();
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the SQL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int SQL1_Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
    if (!pNewTok)
        return FAILED;

    pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
    pNewTok->pPropertyName = SysAllocString(m_pIdent);
    if (m_pPropComp)
        pNewTok->pPropName2 = SysAllocString(m_pPropComp);
    pNewTok->nOperator = m_nRelOp;
    VariantInit(&pNewTok->vConstValue);
    VariantCopy(&pNewTok->vConstValue, &m_vTypedConst);
    pNewTok->dwPropertyFunction = m_dwPropFunction;
    pNewTok->dwConstFunction = m_dwConstFunction;
    pNewTok->bConstIsStrNumeric = m_bConstIsStrNumeric;

    m_pExpression->AddToken(pNewTok);

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    m_pIdent = 0;
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bConstIsStrNumeric = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int SQL1_Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bConstIsStrNumeric = FALSE;

    if (m_nCurrentToken == SQL_1_TOK_INT)
    {
        trace((" Integer\n"));
        DWORD x = wcslen(m_pTokenText);

        if (*m_pTokenText == L'-')
        {
            //negative

            if ((x < 11) ||
                ((x == 11) && (wcscmp(m_pTokenText, L"-2147483648") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
                m_bConstIsStrNumeric = TRUE;
            }
        }
        else
        {
            //positive

            if ((x < 10) ||
                ((x == 10) && (wcscmp(m_pTokenText, L"2147483647") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
                m_bConstIsStrNumeric = TRUE;
            }
        }

    }
    else if (m_nCurrentToken == SQL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
    }
    else if (m_nCurrentToken == SQL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        V_R8(&m_vTypedConst) = 0.0;

        if (m_pTokenText)
        {
            VARIANT varFrom;
            varFrom.vt = VT_BSTR;
            varFrom.bstrVal = SysAllocString(m_pTokenText);

            if(varFrom.bstrVal != NULL)
            {
                VariantClear(&m_vTypedConst);
                VariantInit(&m_vTypedConst);
                SCODE sc = VariantChangeTypeEx(&m_vTypedConst, &varFrom, 0, 0x409, VT_R8);
                VariantClear(&varFrom);

                if(sc != S_OK)
                {
                    VariantClear(&m_vTypedConst);
                    VariantInit(&m_vTypedConst);
                    return LEXICAL_ERROR;
                }
            }
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_BOOL)
    {
        trace((" Bool\n"));
        V_VT(&m_vTypedConst) = VT_BOOL;
        if (m_pTokenText && _wcsicmp(m_pTokenText, L"65535") == 0)
        {
            V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
        }
        else
            V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int SQL1_Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == SQL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != SQL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

SQL_LEVEL_1_RPN_EXPRESSION::SQL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    pArrayOfTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    pbsRequestedPropertyNames = 0;
    nCurSize = 32;
    nCurPropSize = 32;
    pArrayOfTokens = new SQL_LEVEL_1_TOKEN[nCurSize];
    pbsRequestedPropertyNames = new BSTR[nCurPropSize];

}

SQL_LEVEL_1_RPN_EXPRESSION::~SQL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    for (int i = 0; i < nNumberOfProperties; i++)
        SysFreeString(pbsRequestedPropertyNames[i]);
    delete pbsRequestedPropertyNames;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN *pTok)
{
    AddToken(*pTok);
    delete pTok;
    pTok = NULL;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN &pTok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 32;
        SQL_LEVEL_1_TOKEN *pTemp = new SQL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = pTok;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddProperty (LPWSTR pProp)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 32;
        BSTR *pTemp = new BSTR[nCurPropSize];
        if (!pTemp)
            throw CX_MemoryException();

        if (pbsRequestedPropertyNames)
            memcpy(pTemp, pbsRequestedPropertyNames,
                sizeof(BSTR) * nNumberOfProperties);
        else
        {
            delete [] pTemp;
            throw CX_MemoryException();
        }

        delete pbsRequestedPropertyNames;
        pbsRequestedPropertyNames = pTemp;
    }

    pbsRequestedPropertyNames[nNumberOfProperties++] = SysAllocString(pProp);
}

void SQL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pbsRequestedPropertyNames[i]);
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;

    *this = Src;
}

SQL_LEVEL_1_TOKEN& SQL_LEVEL_1_TOKEN::operator =(SQL_LEVEL_1_TOKEN &Src)
{
    //first clear any old values...
    if (pPropertyName)
        SysFreeString(pPropertyName);
    if (pPropName2)
        SysFreeString(pPropName2);

    VariantClear(&vConstValue);

    nTokenType = Src.nTokenType;
    pPropertyName = SysAllocString(Src.pPropertyName);
    if (Src.pPropName2)
        pPropName2 = SysAllocString(Src.pPropName2);
    nOperator = Src.nOperator;
    VariantCopy(&vConstValue, &Src.vConstValue);
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bConstIsStrNumeric = Src.bConstIsStrNumeric;
    return *this;
}

SQL_LEVEL_1_TOKEN::~SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    if (pPropertyName)
        SysFreeString(pPropertyName);
    if (pPropName2)
        SysFreeString(pPropName2);

    nOperator = 0;
    VariantClear(&vConstValue);
}

void SQL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        fprintf(f, "    Property = %S\n", pPropertyName);
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");
        if (pPropName2)
            fprintf(f, "   <Property:%S\n", pPropName2);
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "VT_BOOL = %d (%s)\n",
                        V_BOOL(&vConstValue),
                        V_BOOL(&vConstValue) == VARIANT_TRUE ? "VARIANT_TRUE" : "VARIANT_FALSE"
                        );
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }
        }

        switch (dwPropertyFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to property\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to property\n");
                break;
        }
        switch (dwConstFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                break;
        }

    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of SQL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\browseinfo\makefile.inc ===
# We want to do this so that our rule for createing the bsc file
# will win over the makefile.def rule.  We do much funkier things
NO_BROWSER_FILE=1

!ifdef IIS_BROWSER_INFO 
!  if "$(NOLINK)" == ""

# this is a wild nmake hack to always run a command
# I picked this up from makefile.def where the do a 
# build -O to make _objects.mac.
!if [-perl gensbrlists.pl .. $O]
!endif

!include $O\sbrlist.inc

$O\iis.bsc: $(SBRLIST) 
    -bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!  else

$O\iis.bsc: 

!  endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemservices.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    WbemServices.h

Abstract:

    Definition of:
        CWbemServices

    Wraps IWbemServices.  Sets out params to NULL and calls
    CoImpersonateClient.

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#ifndef __wbemservices_h__
#define __wbemservices_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>

class CWbemServices
{
protected:
    IWbemServices* m_pWbemServices;

public:
    CWbemServices(IWbemServices*);
    virtual ~CWbemServices();

    operator IWbemServices*() const
    {
        return m_pWbemServices;
    }

    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;

    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemClassObject**, 
        IWbemCallResult**) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\wmiutils\wbemservices.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WbemServices.cpp

Abstract:

    Implementation of:
        CWbemServices

Author:

    ???

Revision History:

    Mohit Srivastava            10-Nov-2000

--*/

#include "WbemServices.h"
#include <wbemprov.h>
#include <dbgutil.h>

CWbemServices::CWbemServices(
    IWbemServices* pNamespace)
    :m_pWbemServices(NULL)
{
    m_pWbemServices = pNamespace;
    if(m_pWbemServices != NULL)
    {
        m_pWbemServices->AddRef();
    }
}

CWbemServices::~CWbemServices()
{
    if(m_pWbemServices != NULL)
    {
        m_pWbemServices->Release();
        m_pWbemServices = NULL;
    }
}

HRESULT
CWbemServices::CreateClassEnum(
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    ) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    SCODE sc = m_pWbemServices->CreateClassEnum(
        Superclass,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return sc;
}

HRESULT
CWbemServices::CreateInstanceEnum(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    HRESULT hr = m_pWbemServices->CreateInstanceEnum(
        Class,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::DeleteClass(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->DeleteClass(
        Class,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->DeleteInstance(
        ObjectPath,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;
}



HRESULT
CWbemServices::ExecMethod(
    const BSTR strObjectPath, 
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx,
    IWbemClassObject* pInParams,
    IWbemClassObject** ppOurParams, 
    IWbemCallResult** ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppOurParams)
    {
        *ppOurParams = NULL;
    }
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->ExecMethod(
        strObjectPath, 
        MethodName, 
        lFlags, 
        pCtx,
        pInParams,
        ppOurParams, 
        ppCallResult) ;
    CoImpersonateClient();    
    return hr;    
}

HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    HRESULT hr = m_pWbemServices->ExecNotificationQuery(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::ExecQuery(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppEnum)
    {
        *ppEnum = NULL;
    }
    HRESULT hr = m_pWbemServices->ExecQuery(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::GetObject(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppObject)
    {
        *ppObject = NULL;
    }
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->GetObject(
        ObjectPath,
        lFlags,
        pCtx,
        ppObject,
        ppCallResult);
    CoImpersonateClient();    
    return hr;

}
 
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->PutClass(
        pObject,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;

}

HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{    
    DBG_ASSERT(m_pWbemServices != NULL);
    if(ppCallResult)
    {
        *ppCallResult = NULL;
    }
    HRESULT hr = m_pWbemServices->PutInstance(
        pInst,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acerror.h ===
#ifndef _CAcError_H_
#define _CAcError_H_

/*----------------------------------------------------------------
 Compiler output Macros (e.g., #pragma message (...)
----------------------------------------------------------------*/
// helper macros
#define __STRINGIZE__(x)    #x
#define __STR__(x)          __STRINGIZE__(x)
#define _LOC_               __FILE__"("__STR__(__LINE__)") : "

#ifdef _UI_BUILD_
// define message macros for use with #pragma

// Usage: #pragma _TODO_(This code needs to be tested)

#define _TODO_(x)       message(_LOC_ " Todo: "#x)

// Usage: #pragma _INFO_(This code needs to be tested)

#define _INFO_(x)       message(_LOC_ " Info: "#x)

#else
// NOTE: These macros get interpreted as warnings by the NT build envrinment
// Usage: #pragma _TODO_(This code needs to be tested)

#define _TODO_(x)       message(" Todo: "#x)

// Usage: #pragma _INFO_(This code needs to be tested)

#define _INFO_(x)       message(" Info: "#x)

#endif

// Warning macro, emit a warning message.  Causes build step to include
//                  a comiler formatted warning.
// Usage: #pragma _WARNING_(This code needs to be tested)

#define _WARNING_(x)    message(_LOC_ "warning: "#x)

// Error macro, emit an error message.  Causes build step to fail
// Usage: #pragma _ERROR_(This code needs to be tested)

#define _ERROR_(x)      message(_LOC_ "error: "#x)

#if defined(_DEBUG)
// THIS IS AN I386 ONLY MACRO.  Use it to force a break point in your
// server code
#define BreakPoint()    DebugBreak()
#else   // !DEBUG
#define BreakPoint()
#endif  // _DEBUG

#include "CppPragmas.h"
#include <winerror.h>
#include <acserrmsg.h>  // header file for appcenter server error message dll
#include "CppPragmas.h"


/*----------------------------------------------------------------
 Tracing macros - outputdebugstring
----------------------------------------------------------------*/
#define ceAssert(a,expr,msg)    if (!(expr)) a.Assert(__FILE__,__LINE__, msg)

#define ceTrace(a)              a.Trace(__FILE__, __LINE__)
#define ceTrace1(a,b)           a.Trace(__FILE__, __LINE__, b)
#define ceTrace2(a,b,c)         a.Trace(__FILE__, __LINE__, b, c)
#define ceTrace3(a,b,c,d)       a.Trace(__FILE__, __LINE__, b, c, d)
#define ceTrace4(a,b,c,d,e) a.Trace(__FILE__, __LINE__, b, c, d,e)

//
// Flags for formatting the error text
// Pass to GetText as an optional param
//
#define ACERR_FORMAT_DEFAULT    0x00000000  // Default formatting err msg + err code
#define ACERR_FORMAT_NOCODE     0x00000001  // exclude the err code from the msg

class CAcError 
    {
    public:     // types
        // Windows Facility Codes
        enum FacilityCode
            {
            Null        = FACILITY_NULL,
            Rpc         = FACILITY_RPC,
            Dispatch    = FACILITY_DISPATCH,
            Storage     = FACILITY_STORAGE,
            Itf         = FACILITY_ITF,
            Reserved5   = 5,
            Reserved6   = 6,
            Win32       = FACILITY_WIN32,
            Windows     = FACILITY_WINDOWS,
            Sspi        = FACILITY_SSPI,
            Control     = FACILITY_CONTROL,
            Cert        = FACILITY_CERT,
            Internet    = FACILITY_INTERNET,
            Reserved13  = 13,
            Reserved14  = 14,
            Reserved15  = 15,
            Reserved16  = 16
            };

        enum SeverityCode
            {
            Success = 0,
            Informational = 1,
            Warning = 2,
            Error = 3
            };

        typedef unsigned short StatusCode;
        typedef bool    CustomerCode;

    public:     // methods

        // value get

        // retrieve the Severity Code
        SeverityCode    Severity    ( void ) const;

        // Retrieve the Facility code
        FacilityCode    Facility    ( void ) const;

        // Retrieve the Customer code
        CustomerCode    Customer    ( void ) const;

        // Retrieve the Ctatus code
        StatusCode      Status      ( void ) const;

        // value set

        void            Severity    ( SeverityCode sc );
        void            Facility    ( FacilityCode fc );
        void            Customer    ( CustomerCode cc );
        void            Status  ( StatusCode sc );

        // set HRESULT by part - note: you must cast stc parameter to
        // StatusCode when using #defined values otherwise the compiler
        // can't distinguish between LONG and WORD forms of Set
        HRESULT     Set (
                        StatusCode stc,
                        SeverityCode sc = Error,
                        FacilityCode fc = Win32,
                        CustomerCode cc = FALSE
                        );

        // allows passing a Win32 error code as the status code
        // Note: You must cast the lWin32Code parameter to LONG if you
        // pass in defined values since the compiler can't distinguish between
        // this and the StatusCode version of CAcError::Set.
        HRESULT     Set (
                        LONG lWin32Code,
                        SeverityCode sc = CAcError::Error,
                        FacilityCode fc = CAcError::Win32,
                        CustomerCode cc = FALSE
                        );

        // Calls ::GetLastError, sets the internal HRESULT and returns it.
        HRESULT         GetLastError ( void );

        // reset to zero ( e.g., not error ) state
        HRESULT         Empty       ( void );


        // success/failure

        bool            Failed      ( void ) const;
        bool            Succeeded   ( void ) const;
        bool            IsError     ( void ) const;
        bool            IsWarning   ( void ) const;
        HRESULT         Result      ( void ) const;

        /*----------------------------------------------------------------
         Construction / Destruction
        ----------------------------------------------------------------*/
        // default constructor, no error
        CAcError ( HRESULT hResult = 0 );

        // construct from another CAcError
        CAcError ( const CAcError &ce );

        // fully qualified constructer
        CAcError    ( 
                    StatusCode stc, 
                    SeverityCode sc = Error,
                    FacilityCode fc = Win32, 
                    CustomerCode cc = FALSE
                    );

        virtual ~CAcError ();

        /*----------------------------------------------------------------
         Operators
        ----------------------------------------------------------------*/
        operator HRESULT ()         const;

        // calls GetText() and returns the result.  If GetText returns NULL
        // returns the HRESULT as a string.  If this last step fails,
        // a constant empty string (e.g., "\0") is returned.

        // NOTE 1: The string is stored in the instance.  Assign a new hresult
        // to CAcError will cause the previous string to be free (e.g., the pointer is invalid)

        // NOTE 2: This method will always return a valid string.  However, if an error occurs
        // internally, the string may be empty or the hex string form of the HRESULT.  Use the 
        // GetText() method if you need explicit error handling.
        operator LPCWSTR ();

        // returns the text associated with the passed in HRESULT.

        // NOTE 1: Returns NULL if the HRESULT can not be converted to text
        // (e.g., private facility, etc).

        // NOTE 2: The returned string is allocated via LocalAlloc().  Use 
        // LocalFree() to free the memory allocated for the string.  It is the
        // Caller's responsibility to free this memory.

        // Return Value:
        // S_OK - a valid string was returned
        // S_FALSE - a string lookup failed (e.g., no associated text)
        // E_OUTOFMEMORY - insufficient memory to allocate the string
        // Others - Underlying SDK's returned an error.

        static HRESULT  GetText (IN HRESULT hResult, OUT LPCWSTR & pszwErrorText,
            DWORD dwFormatFlags = ACERR_FORMAT_DEFAULT);

        CAcError &operator= ( HRESULT hResult );
        CAcError &operator= ( unsigned long ulValue );
        CAcError &operator= ( const CAcError &ce );
#ifdef IA64
        CAcError &operator= ( LONG_PTR ulValue );
#endif

        // trace with filename and line number
        void            Trace 
                            (
                            LPCSTR szFile,
                            int nLine, 
                            LPCTSTR szMsg1 = NULL, 
                            LPCTSTR szMsg2 = NULL,
                            LPCTSTR szMsg3 = NULL,
                            LPCTSTR szMsg4 = NULL
                            );

        void            Assert (LPCSTR szFile, int nLine, LPCTSTR szExpr);


        //////////////////////////////////////////////////////////////////////
        // Initialize tracing for the module or process
        //
        // .EXE     - call with bIsProcess = true in the shutdown code
        // .DLL     - call with bIsProcess = false in DLL_PROCESS_DETACH
        // SNAPIN   - Call with bIsProcess true.  WARNING - DO NOT CALL IN DLL_PROCESS_ATTACH
        //            Use OnFinalAddRef or AddRef() method when the object is created
        //////////////////////////////////////////////////////////////////////
        static void InitializeTracing 
            (
            IN LPCSTR pszModuleName,            // modules name for tracing
            IN const GUID & refModuleGUID,      // module's tracing giud (see guids.txt)
            IN bool bIsProcess                  // true for exe or MMC snapin, false for all others
            );

        //////////////////////////////////////////////////////////////////////
        // Cleanup tracing for the module or process
        //
        // .EXE     - call with bIsProcess = true in the shutdown code
        // .DLL     - call with bIsProcess = false in DLL_PROCESS_DETACH
        // SNAPIN   - Call with bIsProcess true.  WARNING - DO NOT CALL IN DLL_PROCESS_DETACH
        //            Use OnFinalRelease or Release() method when the object is going away. 
        //
        // NOTE: bIsProcess = true causes a deadlock if called from DLL_PROCESS_DETACH
        //////////////////////////////////////////////////////////////////////
        static void TerminateTracing 
            (
            IN bool bIsProcess                  // is this a process (true for .EXE or MMC snapin)
            );

        // dantra: 3/10/2000: Bug - this needs to be public so asptrace.dll can call it
        // Call once to initialize the location of acserrmsg.dll
        static void InitErrorFileName();

    public:     // types
    //protected:

        struct ErrorBits
            {
            DWORD           Status:16;          
            DWORD           Facility:12;
            DWORD           Reserved:1;
            DWORD           Customer:1;
            DWORD           Severity:2;
            };

        union WinError
            {
            HRESULT         hResult;
            ErrorBits       bits;
            };

    protected:      // data
        WinError        m_Error;        // current HRESULT
        static LPCWSTR  m_EmptyString;
        LPWSTR          m_szText;
        static WCHAR    m_szwErrorPath[1024];

        static long     m_lProcessInit;
        static long     m_lModuleInit;

    protected:      // members

        void        Reserved ( void )   {m_Error.bits.Reserved = 0;}
        void        FreeText (void);
        LPCTSTR     EmptyString (void)  {return m_EmptyString;}

        // zero terminate at CRLF
        static void TrimCRLF (IN LPWSTR pszString);


        // called once per process to intialize
        // WARNING: DO NOT CALL FROM DLL_PROCESS_ATTACH
        static void ProcessInitTracing();

        // called once per process to cleanup process level tracing
        // WARNING: DO NOT CALL FROM DLL_PROCESS_ATTACH
        static void ProcessTermTracing();

        // Call once for your module (.DLL or .EXE) to initialize component tracing.
        // This should be done inside the PROCESS_ATTTACH for most DLL's and COM objects
        static void ModuleInitTracing 
            (
            IN LPCSTR pszModuleName, 
            IN const GUID & refModuleGUID
            );

        // Call once for your module (.DLL or .EXE) to initialize component tracing.
        // This should be done inside the PROCESS_ATTTACH for most DLL's and COM objects
        static void ModuleTermTracing ();

    };

// ----------------------------  get 

inline HRESULT CAcError::Result ( void ) const
    {
    return m_Error.hResult;
    }

inline CAcError::SeverityCode CAcError::Severity ( void ) const             
    {
    return ( SeverityCode ) m_Error.bits.Severity; 
    }

inline CAcError::FacilityCode CAcError::Facility ( void ) const
    {
    return ( FacilityCode ) m_Error.bits.Facility; 
    }

inline CAcError::CustomerCode CAcError::Customer ( void ) const
    {
    return ( CustomerCode ) m_Error.bits.Customer; 
    }

inline CAcError::StatusCode CAcError::Status ( void ) const
    {
    return ( StatusCode ) m_Error.bits.Status; 
    }

// ----------------------------  set
inline void CAcError::Severity ( SeverityCode sc )  
    {
    m_Error.bits.Severity = sc;
    }

inline void CAcError::Facility ( FacilityCode fc )  
    {
    m_Error.bits.Facility = fc;
    }

inline void CAcError::Customer ( CustomerCode cc )          
    {
    m_Error.bits.Customer = cc & 1; 
    }

inline void CAcError::Status ( StatusCode sc ) 
    {
    m_Error.bits.Status = sc;
    }

inline HRESULT CAcError::Set
    ( 
    StatusCode      stc,
    SeverityCode    sc,
    FacilityCode    fc,
    CustomerCode    cc
    ) 
    {
    Status ( stc );
    Facility ( fc );
    Customer ( cc );
    Reserved ();

    if ( stc ) 
        Severity ( sc );
    else
        Severity ( CAcError::Success );
    return m_Error.hResult;
    }

inline HRESULT CAcError::Set
    ( 
    LONG         lWin32Code,
    SeverityCode sc,
    FacilityCode fc,
    CustomerCode cc
    ) 
    {
    Set (  ( StatusCode )  ( lWin32Code & 0xFFFF ) , sc, fc, cc );
    return m_Error.hResult;
    }

inline HRESULT CAcError::GetLastError ( void ) 
    {
    long lError = ::GetLastError ();
    if (lError)
        {
        Set (lError);
        }
    else
        {
        Empty();
        }
    return m_Error.hResult;
    }


// ----------------------------  success/failure

inline bool CAcError::Failed ( void ) const
    {
    return FAILED ( m_Error.hResult );
    }

inline bool CAcError::Succeeded ( void ) const
    {
    return SUCCEEDED ( m_Error.hResult );
    }

inline bool CAcError::IsError ( void ) const
    {
    return Severity () == Error;
    }

inline bool CAcError::IsWarning ( void ) const
    {
    return Severity () == Warning;
    }

// ----------------------------  operators
inline CAcError & CAcError::operator= ( HRESULT hResult ) 
    {
    m_Error.hResult = hResult; 
    return *this;
    }

inline CAcError & CAcError::operator= ( unsigned long ulResult ) 
    {
    m_Error.hResult = HRESULT_FROM_WIN32(ulResult); 
    return *this;
    }

#ifdef IA64
inline CAcError & CAcError::operator= ( LONG_PTR lResult ) 
    {
    m_Error.hResult = HRESULT_FROM_WIN32((LONG) lResult); 
    return *this;
    }
#endif

inline CAcError & CAcError::operator= ( const CAcError &ce )        
    {
    m_Error.hResult = ce.m_Error.hResult; 
    //_ASSERT (Facility() != 0);
    return *this; 
    }

inline CAcError::operator HRESULT () const
    {
    return Result();
    }

// for CLSID_WbemStatusCodeText
// and IID_IWbemStatusCodeText
#pragma comment(lib, "wbemuuid.lib")


#endif // _CAcError_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acbstr.h ===
/*++

  Copyright 1999-2000 Microsoft Corporation

  Abstract:

    Fake BSTR encapsulation class.  Also provides
    utility string functions that manage memory and
    BSTR-like buffers.

  Author:

    Dan Travison (dantra)

  History:

    08/21/2000 Jon Rowlett (jrowlett) Added Copyright
    08/21/2000 Jon Rowlett (jrowlett) Added Stream functions

--*/

#if !defined(AFX_ACBSTR_H__F2DC718E_B198_478B_AC6B_EA67C0A69F8D__INCLUDED_)
#define AFX_ACBSTR_H__F2DC718E_B198_478B_AC6B_EA67C0A69F8D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// jrowlett 08/21/2000 debugging signatures
// signature to check when reading a CAcBstr to a stream
#define ACBSTR_STG_SIG ((DWORD)'aCb~')

#define ACBSTR_CCHDEFAULT 40

class CAcBstr
	{
	public:
		CAcBstr(LPCWSTR pszSrc = NULL);
		CAcBstr(LPCSTR pszSrc);
		CAcBstr(DWORD dwSize);

        // no link in build env
        CAcBstr(const CAcBstr& src);

		CAcBstr(REFGUID refGuid);

		~CAcBstr();
		void Empty();

		bool IsEmpty() const;

        // no link in build env
		CAcBstr& operator=(const CAcBstr& src);

//
// Only available in Dev Studio Build
//
#ifdef _UI_BUILD_
		CAcBstr& operator=(LPCWSTR pSrc);
		CAcBstr& operator=(LPCSTR pSrc);
		CAcBstr& operator=(REFGUID refGuid);

		CAcBstr& operator+=(const CAcBstr& src);
		CAcBstr& operator+=(LPCWSTR pSrc);
		CAcBstr& operator+=(LPCSTR pSrc);
#endif /* _UI_BUILD_ */

		// assignment with HRESULT return
		HRESULT Assign (const CAcBstr& src);
		HRESULT Assign (LPCWSTR pSrc);
		HRESULT Assign (LPCSTR pSrc);
		HRESULT Assign (REFGUID refGuid);

		operator BSTR() const;

		// returns the character size of the BSTR buffer, NOT the string length
		DWORD Length() const;

		HRESULT Append (const CAcBstr& bstrSrc);
		HRESULT Append (LPCWSTR lpsz, DWORD dwLen = 0);
		HRESULT Append (LPCSTR lpsz, DWORD dwLen = 0);
		HRESULT AppendBSTR (BSTR p);

		bool LoadString(HINSTANCE hInst, UINT nID);

		bool operator< (BSTR bstrSrc) const;
		bool operator> (BSTR bstrSrc) const;
		bool operator==(BSTR bstrSrc) const;
		bool operator!() const;

		// Generate a guid and assign to self
		HRESULT	CreateGuid();

		HRESULT	__cdecl Format (LPCWSTR lpszFormat, ...);

        // dantra: 04/16/2000 = made public
        HRESULT	__cdecl FormatV(LPCWSTR lpszFormat, va_list argList);

		int		CompareNoCase	(IN const BSTR bstrStr) const;
		int		Compare			(IN const BSTR bstrStr) const;
		int		Find				(IN WCHAR wcCharToFind, int nStartOffset = 0) const;

        HRESULT ExchangeWindowText(HWND hwnd, bool fUpdateData = true);

        // jrowlett: 08/21/2000 Stream Functions
        HRESULT ReadStream(IN IStream* pstmIn);
        HRESULT WriteStream(IN IStream* pstmOut);

	protected:	// data
		BSTR    m_bstr;
        BSTR    m_bstrDefault;

        // provide a default buffer that is sufficient to hold
        // a GUID as a string +
        // the zero terminator +
        // the dword length prefix
        BYTE                m_bDefault [ sizeof (DWORD) + ACBSTR_CCHDEFAULT * sizeof (WCHAR) ];
		static DWORD        m_dwEmptyBstr[];

		static const BSTR	EmptyBSTR() {return (BSTR) (CAcBstr::m_dwEmptyBstr + 1); }

	protected:	// members

        friend class CAcSecureBstr;

		BSTR		Copy();

        // called to assign the bstr to m_bstr. This also handles NULL to ensure
        // we never return a NULL pointer
        void        Set         (BSTR pszSource);

		BSTR AllocLen	(LPCWSTR pszSource, DWORD dwCharLen, bool bUseInternal = true);
		void Free		(BSTR bstrSource);

		static DWORD Len		(BSTR bstrSource);
        static BSTR MakeBSTR    (BYTE * pBuffer, DWORD dwBufSize);
	};

inline DWORD CAcBstr::Length() const
	{
	if (IsEmpty())
		{
		return 0;
		}
    return CAcBstr::Len (m_bstr);
	}

inline BSTR CAcBstr::Copy()
	{
	return CAcBstr::AllocLen ( m_bstr, Length(), false );
	}

inline HRESULT CAcBstr::Append (const CAcBstr& bstrSrc)
	{
	return Append (bstrSrc.m_bstr, bstrSrc.Length());
	}

inline HRESULT CAcBstr::AppendBSTR (BSTR p)
	{
	return Append (p, CAcBstr::Len(p) );
	}

inline CAcBstr::operator BSTR() const
	{
	return m_bstr;
	}

inline bool CAcBstr::operator> (BSTR bstrSource) const
	{
	return ! (operator<(bstrSource));
	}

inline bool CAcBstr::operator== (BSTR bstrSrc) const
	{
	return Compare (bstrSrc) == 0;
	}

inline bool CAcBstr::operator!() const
	{
	return IsEmpty();
	}

inline bool CAcBstr::IsEmpty() const
	{
	return (m_bstr == NULL || m_bstr == CAcBstr::EmptyBSTR() );
	}


/*-------------------------------------------
 Function name      : CAcBstr::MakeBSTR
 Description        : Convert a byte buffer into a BSTR
 Return type        : inline BSTR 
 Argument           : BYTE *pBuffer
 Argument           : DWORD dwBufSize
-------------------------------------------*/
inline BSTR CAcBstr::MakeBSTR (BYTE *pBuffer, DWORD dwBufSize)
    {
    * ((DWORD *)pBuffer) = dwBufSize - sizeof (DWORD);
    return (BSTR) (pBuffer + sizeof (DWORD));
    }

inline void CAcBstr::Set (BSTR bstr)
    {
    if (!bstr)
        {
        Empty();
        }
    else
        {
        m_bstr = bstr;
        }
    }


#endif // !defined(AFX_ACBSTR_H__F2DC718E_B198_478B_AC6B_EA67C0A69F8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acauthutil.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

      AcAuthUtil.h

   Abstract :

        wrapper class for managing interface authentication data

   Author :

      Dan Travison (dantra)

   Project :

      Application Server

   Revision History:
    01/12/2000 Jon Rowlett (jrowlett)
        added Assign member function that returns an HRESULT inplace of operator =
    01/18/2000 Jon Rowlett (jrowlett)
        re-vamp
        use Win2k negotiate service before defaulting to NTLMSSP
    02/01/2000 Jon Rowlett (jrowlett)
        added CreateInstanceEx which uses Amallet's enhanced name resolution mechanism
    06/01/2000 Jon Rowlett (jrowlett)
        Changed passwords to use CAcSecureBstr

--*/

// AcAuthUtil.h: interface for the CAcAuthUtil class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_AcAuthUtil_H__6726B4BE_0304_11D3_8248_0050040F9DBD__INCLUDED_)
#define AFX_AcAuthUtil_H__6726B4BE_0304_11D3_8248_0050040F9DBD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wincrypt.h>
#include <acsrtl.h>
#include <acsecurebstr.h>

// bohrhe: 9/28/2000 added
// This is how we format domain\username, if we have to localize this
// change this #define instead of inside the code
#define WCH_AUTH_DELIMITER  L'\\'

//09/19/2000 jrowlett added
//
// loopback subnet mask for IsLoopbackIP()
// debate over whether or not to recognize just 127.0.0.1 or all of 127.x.x.x
// by default on Windows 2000 all of 127. gets routed to 127.0.0.1
//
#define LOOPBACK_SUBNET_MASK 0x000000FF
#define LOOPBACK_NETWORK     0x0000007F

//01/19/2000 jrowlett added enumeration
typedef enum _acauthlvl{
    ACAUTH_DEFAULT = RPC_C_AUTHN_LEVEL_DEFAULT,
    ACAUTH_NONE,
    ACAUTH_CONNECT,
    ACAUTH_CALL,
    ACAUTH_PKT,
    ACAUTH_PKT_INTEGRITY,
    ACAUTH_PKT_PRIVACY
    } AcAuthLevel;

class CAcAuthUtil
    {
    public:

//01/19/2000 jrowlett added
        //new constructor which sets desired authenication level
        //use Create to pass credentials
        CAcAuthUtil(AcAuthLevel aclvl = ACAUTH_CONNECT);

        virtual ~CAcAuthUtil();

        //
        // Usage Inhibitors (not implemented)
        //
        CAcAuthUtil(const CAcAuthUtil& );

        //////////////////////////////////////////////////////////////////////
        // Attribute access
        //////////////////////////////////////////////////////////////////////

        HRESULT     GetPassword(OUT CAcSecureBstr& rsecbstrPassword) const;
        const BSTR  UserName () const;
        const BSTR  Domain ()   const;
        const BSTR  MachineName() const;

// bohrhe: 9/28/2000 added
        HRESULT GetDomainUsername(OUT CAcBstr &racbstrUsername) const;

        static bool IsRetryError (HRESULT hr);

        // returns a service specific HRESULT for CO_E_SERVER_EXEC_FAILURE.
        // if a service specific HRESULT is not found, CO_E_SERVER_EXEC_FAILURE is returned.
        static HRESULT GetCLSIDSpecificExecFailureCode 
            (
            IN REFCLSID rclsid,     // clsid ID of interface that failed to create
            IN HRESULT hrFailure    // hresult to remap
            );

//01/12/2000 jrowlett added
        HRESULT Assign(const CAcAuthUtil& auth);

/*
        DWORD           AuthorizationService (DWORD dwAuthzService);
        DWORD           AuthorizationService () const;

        DWORD           AuthenticationService (DWORD dwAuthnService);
        DWORD           AuthenticationService () const;
*/
        AcAuthLevel         AuthLevel () const;
        AcAuthLevel         AuthLevel (AcAuthLevel aclvl);
/*
        DWORD           ImpersonateLevel () const;
        DWORD           ImpersonateLevel (DWORD dwNewImpLevel);

        const BSTR  Authority() const;
*/


        // is account local to MachineName
        BOOL        LocalAccount() const;

        // are we talking to the local system
        BOOL        LocalHost() const;

        void Empty();
        bool IsEmpty() const;

        //////////////////////////////////////////////////////////////////////
        // Attribute setting
        //////////////////////////////////////////////////////////////////////

        // fill a COAUTHINFO structure
        HRESULT SetInterfaceSecurity (IUnknown * pTo);

        // initializes the auth util for machine, username, password
        HRESULT Create
                        (
                        BSTR pszMachineName = NULL,
                        BSTR pszUsername = NULL,
                        BSTR pszPassword = NULL
                        );

        //06/05/2000 jrowlett added
        // overload of create that does not require a plaintext passwd
        HRESULT CreateEx(LPCWSTR pszMachineName = NULL, LPCWSTR pszUsername = NULL,
            const CAcSecureBstr& secbstrPassword = CAcSecureBstr());

        // ::CoCreateInstance using the internal data
        HRESULT CreateInstance
                        (
                        REFCLSID rclsid, 
                        LPUNKNOWN punkOuter, 
                        REFIID riid, 
                        OUT LPVOID* ppvObj, 
                        bool bSetInterfaceSecurity = true
                        );

//02/01/2000 jrowlett added
        // dantra: 03/10/2000: Fixed
        // Used for intracluster DCOM connections.
        // This should only be called from a cluster member.
        HRESULT ClusterCreateInstanceEx
                        (
                        REFCLSID rclsid, 
                        LPUNKNOWN punkOuter, 
                        REFIID riid, 
                        OUT LPVOID* ppvObj, 
                        bool bSetInterfaceSecurity = true
                        );

        const BSTR  LocalComputer() const;

//05/25/2000 jrowlett added for bug 14410
        HRESULT GetPlainTextPassword(OUT /*PTR*/ BSTR* pbstrPassword);
        ULONG   ReleasePlainTextPassword(IN /*PTR*/ BSTR bstrPassword);

        //09/19/2000 jrowlett added
        static BOOL IsLoopbackIP(IN LPCWSTR pwszIP);

    protected: // data
        CAcBstr m_acbstrUserName;
        CAcBstr m_acbstrDomain;
        //06/01/2000 jrowlett added
        CAcSecureBstr m_secbstrPassword;
        CAcBstr m_acbstrMachineName;    // target computer
        CAcBstr m_acbstrAuthority;      // calculated - for local account use and Wbem
        CAcBstr m_acbstrIP;             // resolved IP Address

        static CAcBstr  m_acbstrLocalComputerName; // local computername

        BOOL        m_bLocalAccount;
        BOOL        m_bLocalHost;

        AcAuthLevel m_aclvlAuth;

        bool m_bIsEmpty;

        //
        // DCOM structures
        // the password referenced by the ident structure
        // is set with FillAuthIdentity and EmptyAuthIdentity
        //
        COAUTHIDENTITY m_ident;
        COAUTHINFO     m_authinfo;
        COSERVERINFO   m_serverinfo;

    protected:  // methods

        //
        // Used by Create to parse domain\username 
        //
        HRESULT Parse();

        //
        // DCOM security structure helper functions
        // COAUTHIDENTITY potentially uses a plaintext password
        //
        void FillAuthInfo();
        void FillServerInfo();
        HRESULT FillAuthIdentity();
        ULONG   EmptyAuthIdentity();

        HRESULT GetAuthImp (IUnknown * pFrom, OUT DWORD* pdwAuthnSvc, OUT DWORD* pdwAuthzSvc, IN OUT DWORD * pdwAuthLevel, IN OUT DWORD * pdwImpLevel);

//01/13/2000 jrowlett added
        static HRESULT SetProxyBlanket(
            IUnknown * pProxy,         //Indicates the proxy to set
            DWORD dwAuthnSvc,          //Authentication service to use
            DWORD dwAuthzSvc,          //Authorization service to use
            WCHAR * pServerPrincName,  //Server principal name to use with 
                                         // the authentication service
            DWORD dwAuthnLevel,        //Authentication level to use
            DWORD dwImpLevel,          //Impersonation level to use
            RPC_AUTH_IDENTITY_HANDLE   pAuthInfo,
                                         //Identity of the client
            DWORD dwCapabilities       //Capability flags
            );

    //05/25/2000 jrowlett added
        HRESULT AssignPassword(IN /*PTR*/ LPCWSTR pszPassword);

    private:
        // the actual calls to CoCreateInstanceEx
        HRESULT CreateInstanceEx 
                    (
                    REFCLSID rclsid, 
                    LPUNKNOWN punkOuter, 
                    REFIID riid, 
                    LPVOID* ppvObj,
                    bool bSetInterfaceSecurity = true
                    );

        CAcAuthUtil& operator =(const CAcAuthUtil& auth) { auth; return *this;}


    };

// 06/06/2000 jrowlett added
inline HRESULT CAcAuthUtil::GetPassword(OUT CAcSecureBstr& rsecbstrPassword) const
{
    return rsecbstrPassword.Assign(m_secbstrPassword);
}

inline const BSTR CAcAuthUtil::UserName() const
    {
    if (m_acbstrUserName.Length()) 
        {
        return m_acbstrUserName; 
        }
    else
        {
        return NULL;
        }
    }

inline const BSTR CAcAuthUtil::Domain() const
    {
    if (m_acbstrDomain.Length()) 
        {
        return m_acbstrDomain; 
        }
    else
        {
        return NULL;
        }
    }

inline const BSTR CAcAuthUtil::MachineName() const
    {
    if (LocalHost())
        {
        return LocalComputer();
        }
    else if (m_acbstrMachineName.Length()) 
        {
        return m_acbstrMachineName; 
        }
    else
        {
        return NULL;
        }
    }
/*
inline const BSTR CAcAuthUtil::Authority() const
    {
    if (m_bstrAuthority.Length()) 
        {
        return m_bstrAuthority; 
        }
    else
        {
        return NULL;
        }
    }
*/
inline BOOL CAcAuthUtil::LocalAccount() const
    {
    return m_bLocalAccount;
    }

inline BOOL CAcAuthUtil::LocalHost() const
    {
    return m_bLocalHost;
    }
/*
inline COAUTHIDENTITY * CAcAuthUtil::GetAuthIdentity ()
    {
    return &m_ident;
    }
*/
inline const BSTR CAcAuthUtil::LocalComputer() const
    {
    return m_acbstrLocalComputerName;
    }
/*
inline DWORD CAcAuthUtil::ImpersonateLevel() const
    {
    return m_dwImpLevel;
    }

inline DWORD CAcAuthUtil::ImpersonateLevel (DWORD dwImpLevel)
    {
    m_dwImpLevel = dwImpLevel;
    return m_dwImpLevel;
    }
*/
inline AcAuthLevel CAcAuthUtil::AuthLevel() const
    {
    return m_aclvlAuth;
    }

inline AcAuthLevel CAcAuthUtil::AuthLevel (AcAuthLevel aclvl)
    {
    m_aclvlAuth = aclvl;
    return m_aclvlAuth;
    }

/*
inline DWORD CAcAuthUtil::AuthenticationService (DWORD dwAuthnService)
    {
    m_dwAuthnSvc = dwAuthnService;
    return m_dwAuthnSvc;
    }

inline DWORD CAcAuthUtil::AuthenticationService () const
    {
    return m_dwAuthnSvc;
    }

inline DWORD CAcAuthUtil::AuthorizationService (DWORD dwAuthzService)
    {
    m_dwAuthzSvc = dwAuthzService;
    return m_dwAuthzSvc;
    }

inline DWORD CAcAuthUtil::AuthorizationService () const
    {
    return m_dwAuthzSvc;
    }
*/

inline HRESULT CAcAuthUtil::AssignPassword(IN LPCWSTR pszPassword)
{
    return m_secbstrPassword.Assign(pszPassword);
}

inline HRESULT CAcAuthUtil::GetPlainTextPassword(OUT /*PTR*/ BSTR* pbstrPassword)
{
    return m_secbstrPassword.GetBSTR(pbstrPassword);
}

inline ULONG   CAcAuthUtil::ReleasePlainTextPassword(IN /*PTR*/ BSTR bstrPassword)
{
    return m_secbstrPassword.ReleaseBSTR(bstrPassword);
}

//09/19/2000 jrowlett added
inline BOOL CAcAuthUtil::IsLoopbackIP(IN LPCWSTR pwszIP)
/*++
 
        Given a UNICODE string representation of an IP address
        converts it to a inet_addr style ip and determines
        whether or not it is a ip that would be routed through
        the loopback interface.

  Arguments :
  
        pwszIP - IP string in the form x[.x[.x[.x]]]

  Returns:
 
     HRESULT status 
--*/

{
    //
    // using inet_addrW from acsrtl
    //
    unsigned long ulIP = inet_addrW((WCHAR*)pwszIP);

    return (ulIP & LOOPBACK_SUBNET_MASK) == LOOPBACK_NETWORK;
}

#endif // !defined(AFX_AcAuthUtil_H__6726B4BE_0304_11D3_8248_0050040F9DBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acserrmsg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    acserrmsg.h

    This file is generated by the MC tool from the ACSERRMSG.MC message
    file.


    FILE HISTORY:
        AMallet   14-Dec-1999  Created

*/


#ifndef _ACSERRMSG_H_
#define _ACSERRMSG_H_

#define ACS_ERROR_MESSAGE_DLL       _T("acerrmsg.dll")

#define FACILITY_APPSERVER          20
#define SEV_SUCCESS                 0x0
#define SEV_INFORMATIONAL           0x1
#define SEV_WARNING                 0x2
#define SEV_ERROR                   0x3


/******************************* Success Codes ***************************************/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: ACS_CAT_UNKNOWN
//
// MessageText:
//
//  Application Center%0
//
#define ACS_CAT_UNKNOWN                  0x00000001L

//
// MessageId: ACS_CAT_GENERAL
//
// MessageText:
//
//  General%0
//
#define ACS_CAT_GENERAL                  0x00000002L

//
// MessageId: ACS_CAT_CLUSTER
//
// MessageText:
//
//  Cluster%0
//
#define ACS_CAT_CLUSTER                  0x00000003L

//
// MessageId: ACS_CAT_REPLICATION
//
// MessageText:
//
//  Replication%0
//
#define ACS_CAT_REPLICATION              0x00000004L

//
// MessageId: ACS_CAT_MONITORING
//
// MessageText:
//
//  Monitoring%0
//
#define ACS_CAT_MONITORING               0x00000005L

//
// MessageId: ACS_CAT_RF
//
// MessageText:
//
//  RF%0
//
#define ACS_CAT_RF                       0x00000006L

/************************************ Information Codes ***************************************/
/************************************ Warning Codes ***************************************/
/************************************ Error Codes ***************************************/
//
// MessageId: AS_ERROR_BAD_OS
//
// MessageText:
//
//  To use this feature, install or upgrade to Windows 2000 Advanced Server or later. 
//
#define AS_ERROR_BAD_OS                  0xC0140001L

//
// MessageId: AS_ERROR_NLB_NOT_INSTALLED
//
// MessageText:
//
//  Network Load Balancing (NLB) is not installed on this server.
//
#define AS_ERROR_NLB_NOT_INSTALLED       0xC0140002L

//
// MessageId: AS_ERROR_MACHINE_ALREADY_IN_CLUSTER
//
// MessageText:
//
//  This server is already part of a cluster. Try a different server name.
//
#define AS_ERROR_MACHINE_ALREADY_IN_CLUSTER 0xC0140003L

//
// MessageId: AS_ERROR_BAD_IIS_VERSION
//
// MessageText:
//
//  This feature requires Internet Information Services (IIS), version 5.0 or later.
//
#define AS_ERROR_BAD_IIS_VERSION         0xC0140004L

//
// MessageId: AS_ERROR_MACHINE_NOT_IN_CLUSTER
//
// MessageText:
//
//  This server is not part of this Application Center cluster.
//
#define AS_ERROR_MACHINE_NOT_IN_CLUSTER  0xC0140005L

//
// MessageId: AS_ERROR_INVALID_PARTITION
//
// MessageText:
//
//  The partition ID is not valid.
//
#define AS_ERROR_INVALID_PARTITION       0xC0140006L

//
// MessageId: AS_ERROR_MACHINE_ALREADY_IN_PARTITION
//
// MessageText:
//
//  The server is already part of the partition.
//
#define AS_ERROR_MACHINE_ALREADY_IN_PARTITION 0xC0140007L

//
// MessageId: AS_ERROR_SVC_NOT_INSTALLED
//
// MessageText:
//
//  A necessary service is not installed. The services are Application Center... Administration, Cluster, Log Query Helper, Name Resolution, and Synchronization.
//
#define AS_ERROR_SVC_NOT_INSTALLED       0xC0140008L

//
// MessageId: AS_ERROR_INVALID_SITE_BINDING
//
// MessageText:
//
//  A site is bound to an IP address that is not valid. 
//
#define AS_ERROR_INVALID_SITE_BINDING    0xC0140009L

//
// MessageId: AS_ERROR_BAD_SUBNET
//
// MessageText:
//
//  The server is on a different subnet.
//
#define AS_ERROR_BAD_SUBNET              0xC014000AL

//
// MessageId: AS_ERROR_MASTER_NOT_FOUND
//
// MessageText:
//
//  The cluster controller could not be located.
//
#define AS_ERROR_MASTER_NOT_FOUND        0xC014000BL

//
// MessageId: AS_ERROR_NOT_CLUSTER_MASTER
//
// MessageText:
//
//  This server is not the cluster controller. 
//
#define AS_ERROR_NOT_CLUSTER_MASTER      0xC014000CL

//
// MessageId: AS_ERROR_DIFFERENT_CLUSTER
//
// MessageText:
//
//  This server is part of a different cluster.
//
#define AS_ERROR_DIFFERENT_CLUSTER       0xC014000DL

//
// MessageId: AS_ERROR_WRONG_MEMBERSHIP
//
// MessageText:
//
//  This server is part of a different domain/workgroup than the cluster controller.
//
#define AS_ERROR_WRONG_MEMBERSHIP        0xC014000EL

//
// MessageId: AS_ERROR_SVC_SHUTTING_DOWN
//
// MessageText:
//
//  The Cluster service is shutting down.
//
#define AS_ERROR_SVC_SHUTTING_DOWN       0xC014000FL

//
// MessageId: AS_ERROR_NOT_INITIALIZED
//
// MessageText:
//
//  The object was not initialized.
//
#define AS_ERROR_NOT_INITIALIZED         0xC0140010L

//
// MessageId: AS_ERROR_INVALID_CLUSTER_IP
//
// MessageText:
//
//  The cluster IP address and/or subnet mask is not valid.
//
#define AS_ERROR_INVALID_CLUSTER_IP      0xC0140011L

//
// MessageId: AS_ERROR_INVALID_DEDICATED_IP
//
// MessageText:
//
//  The dedicated IP address and/or subnet mask is not valid.
//
#define AS_ERROR_INVALID_DEDICATED_IP    0xC0140012L

//
// MessageId: AS_ERROR_NO_NIC
//
// MessageText:
//
//  No network adapter was supplied.
//
#define AS_ERROR_NO_NIC                  0xC0140013L

//
// MessageId: AS_ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object was already initialized.
//
#define AS_ERROR_ALREADY_INITIALIZED     0xC0140014L

//
// MessageId: AS_ERROR_NETWORK_CFG_CONFLICT
//
// MessageText:
//
//  Network properties are already being modified.
//
#define AS_ERROR_NETWORK_CFG_CONFLICT    0xC0140015L

//
// MessageId: AS_ERROR_CONFLICTING_ACTION
//
// MessageText:
//
//  An administrative action is in progress that conflicts with the requested action.
//
#define AS_ERROR_CONFLICTING_ACTION      0xC0140016L

//
// MessageId: AS_ERROR_STALE_DATA
//
// MessageText:
//
//  A more recent copy of the data exists.
//
#define AS_ERROR_STALE_DATA              0xC0140017L

//
// MessageId: AS_ERROR_CONTROLLER_CHANGING
//
// MessageText:
//
//  A cluster controller change is in progress.
//
#define AS_ERROR_CONTROLLER_CHANGING     0xC0140018L

//
// MessageId: AS_ERROR_CONTROLLER_NOT_CHANGING
//
// MessageText:
//
//  There is no cluster controller change currently in progress.
//
#define AS_ERROR_CONTROLLER_NOT_CHANGING 0xC0140019L

//
// MessageId: AS_ERROR_CONTROLLER_EXISTS
//
// MessageText:
//
//  A cluster controller already exists for this cluster.
//
#define AS_ERROR_CONTROLLER_EXISTS       0xC014001AL

//
// MessageId: AS_ERROR_CONTROLLER_UNREACHABLE
//
// MessageText:
//
//  The cluster controller could not be reached.
//
#define AS_ERROR_CONTROLLER_UNREACHABLE  0xC014001BL

//
// MessageId: AS_ERROR_NLB_NOT_BOUND
//
// MessageText:
//
//  Network Load Balancing (NLB) is not bound to any network adapter.
//
#define AS_ERROR_NLB_NOT_BOUND           0xC014001CL

//
// MessageId: AS_ERROR_NLB_CONFLICTING_HOST_PRIORITY
//
// MessageText:
//
//  The server has a conflicting Network Load Balancing (NLB) host priority.
//
#define AS_ERROR_NLB_CONFLICTING_HOST_PRIORITY 0xC014001DL

//
// MessageId: AS_ERROR_NLB_ONLY_ONE_NIC
//
// MessageText:
//
//  The server has only one network adapter.
//
#define AS_ERROR_NLB_ONLY_ONE_NIC        0xC014001EL

//
// MessageId: AS_ERROR_NLB_UNSUPP_PORTRULES
//
// MessageText:
//
//  The server has unsupported (probably single-host) Network Load Balancing (NLB) port rules.
//
#define AS_ERROR_NLB_UNSUPP_PORTRULES    0xC014001FL

//
// MessageId: AS_ERROR_NLB_UNMANAGEABLE_CONFIG
//
// MessageText:
//
//  The server has a Network Load Balancing (NLB) or network configuration that prevents it from going into managed NLB mode.
//
#define AS_ERROR_NLB_UNMANAGEABLE_CONFIG 0xC0140020L

//
// MessageId: AS_ERROR_NLB_ON_DHCP_NIC
//
// MessageText:
//
//  Network Load Balancing (NLB) is bound to a network adapter that is using Dynamic Host Configuration Protocol(DHCP) instead of static addresses.
//
#define AS_ERROR_NLB_ON_DHCP_NIC         0xC0140021L

//
// MessageId: AS_ERROR_STOPPING_WORKER_THREAD
//
// MessageText:
//
//  A worker thread could not be stopped.
//
#define AS_ERROR_STOPPING_WORKER_THREAD  0xC0140022L

//
// MessageId: ACS_ERROR_EVENT
//
// MessageText:
//
//  %1%0
//
#define ACS_ERROR_EVENT                  0xC0140035L

//
// MessageId: ACS_ERROR_PASSPROV_FAILED_SENDEVENT
//
// MessageText:
//
//  Event provider was unable to send event.
//
#define ACS_ERROR_PASSPROV_FAILED_SENDEVENT 0xC0140036L

//
// MessageId: ACS_ERROR_CANT_REMOVE_CONTROLLER
//
// MessageText:
//
//  The cluster controller could not be removed from the cluster.
//
#define ACS_ERROR_CANT_REMOVE_CONTROLLER 0xC0140037L

//
// MessageId: ACS_ERROR_MEMBER_CLEANUP_FAILED
//
// MessageText:
//
//  The server has been removed from the cluster. However, some or all settings could not be removed from the member because the member was not reachable or too busy. To remove these settings, use the command line AC CLUSTER /CLEAN on the member.
//
#define ACS_ERROR_MEMBER_CLEANUP_FAILED  0xC0140038L

//
// MessageId: ACS_ERROR_ACSARRAY_SVC_TOO_BUSY
//
// MessageText:
//
//  The Cluster service is too busy to complete this request.
//
#define ACS_ERROR_ACSARRAY_SVC_TOO_BUSY  0xC0140040L

//
// MessageId: ACS_ERROR_LB_CRITICAL_MONITOR
//
// MessageText:
//
//  The server could not be brought online because a monitor was in the critical state.
//
#define ACS_ERROR_LB_CRITICAL_MONITOR    0xC0140041L

//
// MessageId: ACS_ERROR_CONTROLLER_CLEANUP_FAILED
//
// MessageText:
//
//  Some settings on the controller could not be updated. 
//
#define ACS_ERROR_CONTROLLER_CLEANUP_FAILED 0xC0140042L

//
// MessageId: ACS_ERROR_LB_DISABLED
//
// MessageText:
//
//  Load balancing is disabled on this server.
//
#define ACS_ERROR_LB_DISABLED            0xC0140043L

//
// MessageId: AC_ERROR_CLUSTER_NAME_CONFLICT
//
// MessageText:
//
//  The cluster name conflicts with an existing name on the network. The cluster name must be unique.
//
#define AC_ERROR_CLUSTER_NAME_CONFLICT   0xC0140044L

//
// MessageId: AC_ERROR_MSDE_INSTALL_CONFLICT
//
// MessageText:
//
//  The SQL Server 2000 Desktop Engine (MSDE) setting on the member is not the same as on the controller. This flag is used to confirm that the members and the controller have the same MSDE installation configuration.
//
#define AC_ERROR_MSDE_INSTALL_CONFLICT   0xC0140045L

//
// MessageId: AC_ERROR_MSDE_SETTING_MISSING
//
// MessageText:
//
//  The SQL Server 2000 Desktop Engine (MSDE) setting could not be found. This flag is used to confirm that the members and the controller have the same MSDE installation. A cluster cannot be created without this setting.
//
#define AC_ERROR_MSDE_SETTING_MISSING    0xC0140046L

//
// MessageId: AC_ERROR_CLUSTERIZATION_IN_PROGRESS
//
// MessageText:
//
//  A cluster is being created or disbanded, or a server is being added to, or removed from, the cluster.
//
#define AC_ERROR_CLUSTERIZATION_IN_PROGRESS 0xC0140047L

//
// MessageId: AC_ERROR_MORE_THAN_FIVE_GATEWAYS
//
// MessageText:
//
//  A maximum of five default gateways may be specified.
//
#define AC_ERROR_MORE_THAN_FIVE_GATEWAYS 0xC0140048L

//
// MessageId: AC_ERROR_INVALID_IP
//
// MessageText:
//
//  An IP address was specified that is not valid.
//
#define AC_ERROR_INVALID_IP              0xC0140049L

//
// MessageId: AC_ERROR_INVALID_GATEWAY_IP
//
// MessageText:
//
//  A default gateway IP address was specified that is not valid.
//
#define AC_ERROR_INVALID_GATEWAY_IP      0xC014004AL

//
// MessageId: AC_ERROR_REGISTRY_FAILURE
//
// MessageText:
//
//  The Windows registry could not be changed.
//
#define AC_ERROR_REGISTRY_FAILURE        0xC014004BL

//
// MessageId: AC_ERROR_NO_PRIMARY_WINS_SERVER
//
// MessageText:
//
//  No primary Windows Internet Name Service (WINS) server was specified.
//
#define AC_ERROR_NO_PRIMARY_WINS_SERVER  0xC014004CL

//
// MessageId: AC_ERROR_INVALID_WINS_LOOKUP_FILE
//
// MessageText:
//
//  A Windows Internet Name Service (WINS) host lookup file was specified that is not valid.
//
#define AC_ERROR_INVALID_WINS_LOOKUP_FILE 0xC014004DL

//
// MessageId: AC_ERROR_INVALID_SYSTEM_PATH
//
// MessageText:
//
//  The system path was not valid. 
//
#define AC_ERROR_INVALID_SYSTEM_PATH     0xC014004EL

//
// MessageId: AC_ERROR_FILE_COPY_FAILED
//
// MessageText:
//
//  The file could not be copied.
//
#define AC_ERROR_FILE_COPY_FAILED        0xC014004FL

//
// MessageId: AC_ERROR_UNABLE_TO_CONFIG_TCPIP
//
// MessageText:
//
//  The TCP/IP NetBIOS Helper service could not be configured.
//
#define AC_ERROR_UNABLE_TO_CONFIG_TCPIP  0xC0140050L

//
// MessageId: AC_ERROR_UNABLE_TO_CONFIG_DHCP
//
// MessageText:
//
//  The Dynamic Host Configuration Protocol (DHCP) service could not be configured. The most likely reason is that the IP address is already in use.
//
#define AC_ERROR_UNABLE_TO_CONFIG_DHCP   0xC0140051L

//
// MessageId: AC_ERROR_UNABLE_TO_RENEW_DHCP_LEASE
//
// MessageText:
//
//  The Dynamic Host Configuration Protocol (DHCP) lease could not be renewed.
//
#define AC_ERROR_UNABLE_TO_RENEW_DHCP_LEASE 0xC0140052L

//
// MessageId: AC_ERROR_UNABLE_TO_RELEASE_DHCP_LEASE
//
// MessageText:
//
//  The Dynamic Host Configuration Protocol (DHCP) lease could not be released.
//
#define AC_ERROR_UNABLE_TO_RELEASE_DHCP_LEASE 0xC0140053L

//
// MessageId: AC_ERROR_IP_NOT_ENABLED
//
// MessageText:
//
//  The Internet Protocol (TCP/IP) is not enabled on this network adapter.
//
#define AC_ERROR_IP_NOT_ENABLED          0xC0140054L

//
// MessageId: AC_ERROR_IPX_NOT_ENABLED
//
// MessageText:
//
//  The IPX protocol is not enabled on this network adapter.
//
#define AC_ERROR_IPX_NOT_ENABLED         0xC0140055L

//
// MessageId: AC_ERROR_UNABLE_TO_NOTIFY_DNS_SERVICE
//
// MessageText:
//
//  The Domain Name Server (DNS) service could not be notified.
//
#define AC_ERROR_UNABLE_TO_NOTIFY_DNS_SERVICE 0xC0140056L

//
// MessageId: AC_ERROR_INTERFACE_NOT_CONFIGURABLE
//
// MessageText:
//
//  The network adapter is not configurable.
//
#define AC_ERROR_INTERFACE_NOT_CONFIGURABLE 0xC0140057L

//
// MessageId: AC_ERROR_PARTIAL_COMPLETION
//
// MessageText:
//
//  The operation was partially successful.
//
#define AC_ERROR_PARTIAL_COMPLETION      0xC0140058L

//
// MessageId: AC_ERROR_PARAMETER_OUTSIDE_BOUNDS
//
// MessageText:
//
//  The parameter is outside the valid range. 
//
#define AC_ERROR_PARAMETER_OUTSIDE_BOUNDS 0xC0140059L

//
// MessageId: AC_ERROR_MSCS_NOT_SUPPORTED
//
// MessageText:
//
//  The server is part of a Microsoft Cluster Service (MSCS) cluster. The server must be removed from the MSCS cluster before being made a member of an Application Center cluster.
//
#define AC_ERROR_MSCS_NOT_SUPPORTED      0xC014005AL

//
// MessageId: AC_ERROR_ALREADY_OFFLINE
//
// MessageText:
//
//  The server is already offline.
//
#define AC_ERROR_ALREADY_OFFLINE         0xC014005BL

//
// MessageId: AC_ERROR_ALREADY_DRAINING
//
// MessageText:
//
//  The server is already draining.
//
#define AC_ERROR_ALREADY_DRAINING        0xC014005CL

//
// MessageId: AC_ERROR_NO_BACKEND_DEFAULT_GW
//
// MessageText:
//
//  The back-end network adapter does not have a default gateway associated with it. 
//
#define AC_ERROR_NO_BACKEND_DEFAULT_GW   0xC014005DL

//
// MessageId: AC_ERROR_NAMERES_SVC_TOO_BUSY
//
// MessageText:
//
//  The Application Center Name Resolution Service is too busy to complete this request.
//
#define AC_ERROR_NAMERES_SVC_TOO_BUSY    0xC014005EL

//
// MessageId: AC_ERROR_NETCARD_MISCONFIGURED
//
// MessageText:
//
//  The network adapter is misconfigured - it may have IP addresses and/or subnet masks that are not valid.
//
#define AC_ERROR_NETCARD_MISCONFIGURED   0xC014005FL

//
// MessageId: AC_ERROR_SQL_CONNECT_FAILED
//
// MessageText:
//
//  Failed to authenticate, or connect to, SQL Server.
//
#define AC_ERROR_SQL_CONNECT_FAILED      0xC0140060L

//
// MessageId: AC_ERROR_SQL_QUERY_FAILED
//
// MessageText:
//
//  Failed to execute a SQL query.
//
#define AC_ERROR_SQL_QUERY_FAILED        0xC0140061L

//
// MessageId: AC_ERROR_NETBT_DISABLED
//
// MessageText:
//
//  NetBIOS over TCP/IP is disabled on one or more network adapters.
//
#define AC_ERROR_NETBT_DISABLED          0xC0140062L

//
// MessageId: AC_ERROR_MISMATCHED_DIR_STRUCTURE
//
// MessageText:
//
//  The server to be added did not have the same directory and drive structure as the controller.  Ensure that the server being added has the same System Root, and Program Files paths, and Application Center installation directory paths as the controller.
//
#define AC_ERROR_MISMATCHED_DIR_STRUCTURE 0xC0140063L

//
// MessageId: AC_ERROR_MSDE_NOT_INSTALLED
//
// MessageText:
//
//  Unable to retrieve information because Application Center Event and Performance Logging is not installed.
//
#define AC_ERROR_MSDE_NOT_INSTALLED      0xC0140064L

//
// MessageId: AC_ERROR_NO_APP_ON_SOURCE
//
// MessageText:
//
//  The source server does not have any applications to deploy. There must be at least one application on the source server to deploy.
//
#define AC_ERROR_NO_APP_ON_SOURCE        0xC0140065L

//	This is backwards compatibility problems with future versions.
//
// MessageId: AC_ERROR_VERSION_NOT_COMPATIBLE
//
// MessageText:
//
//  The Application Center cluster that you are trying to administer is not compatible with the version of the Administrative client you are using.
//
#define AC_ERROR_VERSION_NOT_COMPATIBLE  0xC0140066L

//
// MessageId: AC_ERROR_MAX_MEMBER_NUM
//
// MessageText:
//
//  The maximum number of members allowed for this cluster has been reached.
//
#define AC_ERROR_MAX_MEMBER_NUM          0xC0140067L

//
// MessageId: AC_ERROR_CLUSTERSERVICE_START_FAILURE
//
// MessageText:
//
//  The Application Center Cluster service could not be started. For more details, see the Windows Event log.
//
#define AC_ERROR_CLUSTERSERVICE_START_FAILURE 0xC0140068L

//
// MessageId: AC_ERROR_CONTROLLER_RENAMED
//
// MessageText:
//
//  The cluster controller has been renamed. If you experience problems connecting to the cluster, you must disconnect from the controller, rename it back to what it was, and then reconnect to the controller.
//
#define AC_ERROR_CONTROLLER_RENAMED      0xC0140069L

//
// MessageId: AC_ERROR_MACHINE_RENAMED
//
// MessageText:
//
//  The server has been renamed.
//
#define AC_ERROR_MACHINE_RENAMED         0xC014006AL

//
// MessageId: AC_ERROR_OVERLAPPING_NIC_GUIDS
//
// MessageText:
//
//  The management and load-balanced network cards cannot be the same.
//
#define AC_ERROR_OVERLAPPING_NIC_GUIDS   0xC014006BL

//
// MessageId: AC_ERROR_RELICATIONSERVICE_START_FAILURE
//
// MessageText:
//
//  The Application Center Replication service could not be started. For more details, see the Windows Event log.
//
#define AC_ERROR_RELICATIONSERVICE_START_FAILURE 0xC014006CL

//
// MessageId: AC_ERROR_ASAI_START_FAILURE
//
// MessageText:
//
//  The Application Center Administration service could not be started. For more details, see the Windows Event log.
//
#define AC_ERROR_ASAI_START_FAILURE      0xC014006DL

//
// MessageId: AC_ERROR_NAMERES_START_FAILURE
//
// MessageText:
//
//  The Application Center Name Resolution service could not be started. For more details, see the Windows Event log.
//
#define AC_ERROR_NAMERES_START_FAILURE   0xC014006EL

//
// MessageId: AC_ERROR_LQH_START_FAILURE
//
// MessageText:
//
//  The Application Center Log Query service could not be started. For more details, see the Windows Event log.
//
#define AC_ERROR_LQH_START_FAILURE       0xC014006FL

//
// MessageId: AC_ERROR_IISADMINSERVICE_START_FAILURE
//
// MessageText:
//
//  The Internet Information Services (IIS) Admin service could not be started. For more details, see the Windows Event log.
//
#define AC_ERROR_IISADMINSERVICE_START_FAILURE 0xC0140070L

//
// MessageId: AC_ERROR_REPLICATE_TO_SELF
//
// MessageText:
//
//  A deployment can not deploy to the source server.
//
#define AC_ERROR_REPLICATE_TO_SELF       0xC0140071L

//
// MessageId: AC_ERROR_NO_RESOURCES_TO_DEPLOY
//
// MessageText:
//
//  The deployment does not reference any applications with resources.
//
#define AC_ERROR_NO_RESOURCES_TO_DEPLOY  0xC0140072L

//	This is backwards compatibility problems with future versions.
//
// MessageId: AC_ERROR_BACKWARDS_COMPATIBILITY
//
// MessageText:
//
//  The operation cannot complete because it is being performed between incompatible versions of Application Center.
//
#define AC_ERROR_BACKWARDS_COMPATIBILITY 0xC0140073L

//
// MessageId: AC_ERROR_NOT_SUPPORTED_ON_CONTROLLER
//
// MessageText:
//
//  This operation is not allowed on the cluster controller.
//
#define AC_ERROR_NOT_SUPPORTED_ON_CONTROLLER 0xC0140074L

//
// MessageId: AC_ERROR_NOT_SUPPORTED_IN_CLUSTER
//
// MessageText:
//
//  This operation is not supported in this cluster.
//
#define AC_ERROR_NOT_SUPPORTED_IN_CLUSTER 0xC0140075L

//
// MessageId: AC_ERROR_NLB_OPERATIONS_SUSPENDED
//
// MessageText:
//
//  Network Load Balancing (NLB) is suspended on this server. The operation cannot be performed until NLB is resumed.
//
#define AC_ERROR_NLB_OPERATIONS_SUSPENDED 0xC0140076L

//
// MessageId: AC_ERROR_NLB_LEADING_NUMERICS_NOT_SUPPORTED
//
// MessageText:
//
//  Network Load Balancing (NLB) does not support server names starting with a number.
//
#define AC_ERROR_NLB_LEADING_NUMERICS_NOT_SUPPORTED 0xC0140077L

//
// MessageId: AC_ERROR_CREDENTIALS_NOT_ALLOWED
//
// MessageText:
//
//  Credentials cannot be used on the local server.
//
#define AC_ERROR_CREDENTIALS_NOT_ALLOWED 0xC0140078L

//
// MessageId: AC_ERROR_INVALID_DISPLAYNAME
//
// MessageText:
//
//  The name entered contains invalid characters. A name must contain at least one character, cannot only contain spaces and cannot contain any of these special characters: < > \" ' , + & % [ ].";
//
#define AC_ERROR_INVALID_DISPLAYNAME     0xC0140079L

//
// MessageId: AC_ERROR_CANNOT_DISBAND
//
// MessageText:
//
//  The cluster cannot be disbanded when cluster members (other than the controller) exist.  To disband the cluster, you must first remove all cluster members.
//
#define AC_ERROR_CANNOT_DISBAND          0xC014007AL

//
// MessageId: AC_ERROR_PRODUCT_EXPIRED
//
// MessageText:
//
//  The 120 day evaluation period has expired.  Application Center will no longer work.  You must purchase a copy of Application Center.
//
#define AC_ERROR_PRODUCT_EXPIRED         0xC014007BL

//
// MessageId: AC_ERROR_EXCEED_DEV_CLUSTER_SIZE
//
// MessageText:
//
//  You cannot add more than two servers to a cluster in the developer version of Application Center.
//
#define AC_ERROR_EXCEED_DEV_CLUSTER_SIZE 0xC014007CL

//
// MessageId: AC_ERROR_INVALID_INSTALL
//
// MessageText:
//
//  The required installation settings are incorrect or could not be read. Application Center may need to be reinstalled.
//
#define AC_ERROR_INVALID_INSTALL         0xC014007DL

//
// MessageId: AC_ERROR_OEM_SETUP_INCOMPLETE
//
// MessageText:
//
//  The OEM has pre-installed Application Center 2000 but mini-setup has not been run.
//
#define AC_ERROR_OEM_SETUP_INCOMPLETE    0xC014007EL



///////////////////////////
//                       //
//   Web Admin Errors    //
//                       //
///////////////////////////


//
// MessageId: AS_WEBADMIN_ERROR_WRONG_OS
//
// MessageText:
//
//  The operating system is not the correct version. You must be using Windows 98, Windows NT 4.0, or Windows 2000. You must be running Microsoft Internet Explorer 5 or later.
//
#define AS_WEBADMIN_ERROR_WRONG_OS       0xC0140200L

//
// MessageId: AS_WEBADMIN_ERROR_WRONG_BROWSER
//
// MessageText:
//
//  The browser is not the correct type. You must use Microsoft Internet Explorer 5 or later.
//
#define AS_WEBADMIN_ERROR_WRONG_BROWSER  0xC0140202L

//
// MessageId: AS_WEBADMIN_ERROR_WRONG_BROWSER_VER
//
// MessageText:
//
//  The browser is not the correct type. You must use Microsoft Internet Explorer 5 or later.
//
#define AS_WEBADMIN_ERROR_WRONG_BROWSER_VER 0xC0140203L

//
// MessageId: AS_WEBADMIN_ERROR_IP_CONFLICT
//
// MessageText:
//
//  One or more of your IP addresses has a conflict. Please correct this problem by adjusting your IP settings on the load balanced network adapter using the Windows Network Connection Properties dialog.
//
#define AS_WEBADMIN_ERROR_IP_CONFLICT    0xC0140204L

//
// MessageId: AS_WEBADMIN_ERROR_SINGLE_MEMBER
//
// MessageText:
//
//  There are no other members in the cluster.
//
#define AS_WEBADMIN_ERROR_SINGLE_MEMBER  0xC0140205L

// replication events
//
// MessageId: AS_REPLM_EV
//
// MessageText:
//
//  %1
//
#define AS_REPLM_EV                      0x40140301L

//****************************************************************************
//AppCenter WMI Events that are written to the event log
//generated from cmt.vbs
//
//
// MessageId: 0xC0141772L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141776L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141777L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141778L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141779L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014177AL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014178AL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014178BL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014178CL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141795L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141796L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141798L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141799L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x8014179BL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x8014179CL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014177FL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141780L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141782L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141783L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141784L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141785L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141786L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141787L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141788L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141789L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014179DL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014179EL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014178FL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141790L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x8014179AL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141792L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141797L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141794L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F49L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F4AL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F4BL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F4CL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F4DL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141F4EL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F4FL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F53L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F54L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F56L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141F5AL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141F5BL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141F59L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FB3L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FB4L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FB5L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FB6L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FB7L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FAAL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FABL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FC8L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FC9L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FCBL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FCDL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FC2L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FC3L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FAFL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FB0L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FB1L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80140FB2L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FC4L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FC5L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141034L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141035L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014101EL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014101FL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141020L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141021L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FC0L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FCAL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0140FCCL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141023L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141027L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141028L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141029L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014103FL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413F8L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413F9L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141399L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141410L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141402L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014139BL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014139DL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014139FL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413E1L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413A3L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413A6L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413A7L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413A9L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x801413ABL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413ACL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x801413ADL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413AEL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x801413AFL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413E0L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014140CL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014140DL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141406L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141408L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141413L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141414L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141415L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141416L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141417L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141418L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014141AL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014141BL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014141DL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413ECL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413F2L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413B7L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413B9L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141403L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x80141404L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413BFL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x801413C0L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x801413C4L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413C5L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413BAL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413BBL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413C8L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413DFL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413FEL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413D6L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413D7L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0x801413D8L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413DAL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141400L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141401L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC014141CL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413CEL (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC01413D4L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: 0xC0141411L (No symbolic name defined)
//
// MessageText:
//
//  %1%0
//


//
// MessageId: AC_INSTALL_EXPIRED_MSG_ID
//
// MessageText:
//
//  %1%0
//
#define AC_INSTALL_EXPIRED_MSG_ID        0xC014157CL

//
// MessageId: AC_INSTALL_EXPIRATION_WARNING_MSG_ID
//
// MessageText:
//
//  %1%0
//
#define AC_INSTALL_EXPIRATION_WARNING_MSG_ID 0x8014157DL

//
// MessageId: AC_INSTALL_INVALID_DATA_MSG_ID
//
// MessageText:
//
//  %1%0
//
#define AC_INSTALL_INVALID_DATA_MSG_ID   0x8014157EL

//End of output generated from cmt.vbs
//****************************************************************************
//        Override errors
//  jmorey: 9/19/2000 These errors strings are used by CAcError to look up extended errors
//  for more generic Windows errors that appear in Application Center 1.0. The MessageID
//  and Facility need to match that of the generic error.
//
//	This is for ERROR_PATH_BUSY - This is a failure because the access to
//
// MessageId: AC_ERROR_RESOURCE_UNAVAILABLE
//
// MessageText:
//
//  Could not access a resource. Either the Web service is paused or off, or some other process has a lock on the resource. Restart the Web service and try the task again.
//
#define AC_ERROR_RESOURCE_UNAVAILABLE    0xC0070094L

//	This is for RPC_S_SERVER_UNAVAILABLE - RPC server is unavailable
//
// MessageId: AC_ERROR_SERVER_UNAVAILABLE
//
// MessageText:
//
//  Could not connect to the server. Verify that the server exists, that it is part of an Application Center cluster, that it has the correct network and DNS settings, and that the credentials supplied have administrative privileges on the server.
//
#define AC_ERROR_SERVER_UNAVAILABLE      0xC00706BAL

//	This is for NERR_GroupNotFound - The group name could not be found
//
// MessageId: AC_ERROR_GROUPNOTFOUND
//
// MessageText:
//
//  Unable to locate the domain for the credentials provided. Try a different set of credentials.
//
#define AC_ERROR_GROUPNOTFOUND           0xC00708ACL

//	This is for E_NOINTERFACE - No such interface supported
//
// MessageId: AC_ERROR_NOINTERFACE
//
// MessageText:
//
//  Could not connect to the server. Verify that the server has Application Center installed on it.
//
#define AC_ERROR_NOINTERFACE             0xC0074002L

//	This is for REGDB_E_CLASSNOTREG - Class not registered
//
// MessageId: AC_ERROR_CLASSNOTREG
//
// MessageText:
//
//  Could not connect to the server. Verify that the server has a full installation of Application Center on it. You cannot connect to a computer with only the Administration Client installed on it.
//
#define AC_ERROR_CLASSNOTREG             0xC0040154L

//	This is for ERROR_INVALID_PARAMETER - The parameter is incorrect
//
// MessageId: AC_ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  One or more parameters or arguments are incorrect.
//
#define AC_ERROR_INVALID_PARAMETER       0xC0070057L

//	This is for ERROR_RESOURCE_NOT_AVAILABLE - The cluster resource is not available
//
// MessageId: AC_ERROR_CONTROLLER_NOT_AVAILABLE
//
// MessageText:
//
//  Could not connect to the cluster controller for the specified server. Verify that the cluster controller is available.
//
#define AC_ERROR_CONTROLLER_NOT_AVAILABLE 0xC007138EL

//	This is for AS_ERROR_MACHINE_IN_CLUSTER - Used by Acseccfg. Do not change user account and permissions
// if the machine is a cluster member
//
// MessageId: AS_ERROR_MACHINE_IN_CLUSTER
//
// MessageText:
//
//  Could not complete the operation. The machine is already a member of a cluster. Remove the machine from the cluster and try again.
//
#define AS_ERROR_MACHINE_IN_CLUSTER      0xC007138FL


// Metabase errors
// dantra: 1/7/2000 The HRESULT's returned by IMSAdminBase and related IIS metabase interfaces
// do not resolve using FormatMessage().  The following entries define the text for the range of
// HRESULTS returned by IIS5.
// NOTE 1: These HRESULTS are in the Internet facility.  I am using Metabase
// as an alias to the Internet facility for the scope of this message file.
// NOTE 2: To prevent name conflicts between the defines in this file and IIS's mdmsg.h,
// I have prefixed all MD_ERROR_XXXX defines with ACS_.
// NOTE 3: All messages have a severity set to Error to allow us to lookup the message
// for any metabase error. This means you should set the severity to Error on the HRESULT
// before calling FormatMessage
//
// MessageId: AS_MD_ERROR_NOT_INITIALIZED
//
// MessageText:
//
//  Some data in the metabase was not initialized. The data must be initialized before use.
//
#define AS_MD_ERROR_NOT_INITIALIZED      0xC00CC800L

//
// MessageId: AS_MD_ERROR_DATA_NOT_FOUND
//
// MessageText:
//
//  The specified data was not found in the metabase.
//
#define AS_MD_ERROR_DATA_NOT_FOUND       0xC00CC801L

//
// MessageId: AS_MD_ERROR_INVALID_VERSION
//
// MessageText:
//
//  The version specified in the metabase data was not recognized.
//
#define AS_MD_ERROR_INVALID_VERSION      0xC00CC802L

//
// MessageId: AS_MD_WARNING_PATH_NOT_FOUND
//
// MessageText:
//
//  A specified metabase object path was not found. The object and associated metabase data was ignored.
//
#define AS_MD_WARNING_PATH_NOT_FOUND     0xC00CC803L

//
// MessageId: AS_MD_WARNING_DUP_NAME
//
// MessageText:
//
//  Metabase data was specified more than once. The duplicate was ignored.
//
#define AS_MD_WARNING_DUP_NAME           0xC00CC804L

//
// MessageId: AS_MD_WARNING_INVALID_DATA
//
// MessageText:
//
//  The metabase data specified is not valid. The data was ignored.
//
#define AS_MD_WARNING_INVALID_DATA       0xC00CC805L

//
// MessageId: AS_MD_ERROR_SECURE_CHANNEL_FAILURE
//
// MessageText:
//
//  A secure communications channel could not be established with the target server.
//
#define AS_MD_ERROR_SECURE_CHANNEL_FAILURE 0xC00CC806L

//
// MessageId: AS_MD_WARNING_PATH_NOT_INSERTED
//
// MessageText:
//
//  The path was not inserted into the string as requested. The probable cause is that the data is in an object at a higher level than the specified object handle.
//
#define AS_MD_WARNING_PATH_NOT_INSERTED  0xC00CC807L

//
// MessageId: AS_MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE
//
// MessageText:
//
//  The METADATA_SECURE attribute cannot be removed from a data item by using the GetData method. Use the DeleteData method to remove the secure data.
//
#define AS_MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE 0xC00CC808L

//
// MessageId: AS_MD_WARNING_SAVE_FAILED
//
// MessageText:
//
//  The current metabase data could not be saved prior to backup. The previous version of the data was backed up.
//
#define AS_MD_WARNING_SAVE_FAILED        0xC00CC809L

//
// MessageId: AS_MD_ERROR_IISAO_INVALID_SCHEMA
//
// MessageText:
//
//  The schema information could not be loaded. A required key or property is missing from the metabase.
//
#define AS_MD_ERROR_IISAO_INVALID_SCHEMA 0xC00CC810L

// First and last metabase status code defined in this message dll
// These are used to determine if message text for an Internet facility HRESULT should
// be loaded from this message dll

#define AS_MD_FIRST AS_MD_ERROR_NOT_INITIALIZED
#define AS_MD_LAST AS_MD_ERROR_IISAO_INVALID_SCHEMA

// Macro for determining if an HRESULT is a metabase error
#define IS_METABASE_HRESULT(a) (HRESULT_FACILITY(a) == HRESULT_FACILITY(AS_MD_FIRST) && HRESULT_CODE(a) >= HRESULT_CODE(AS_MD_FIRST) && HRESULT_CODE(a) <= HRESULT_CODE(AS_MD_LAST))

#endif  // _ACSERRMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acsiputil.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    acsiputil.h

    Header file containing declarations for utility functions used to retrieve "live" 
    IP addresses etc 

    FILE HISTORY:
        AMallet     29-Jan-1999     Created
*/

#ifndef _ACSIPUTIL_H_
#define _ACSIPUTIL_H_

#if !defined(dllexp)
#define dllexp  __declspec(dllexport)
#endif // !defined(dllexp) 


#if !defined(RETURNCODETOHRESULT)

//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

#endif //!defined(RETURNCODETOHRESULT)

dllexp
HRESULT QueryNICIPAddresses( IN LPWSTR pwszServer,
                             IN LPWSTR pwszUser,
                             IN LPWSTR pwszDomain,
                             IN LPWSTR pwszPwd,
                             IN BOOL fOn, 
                             IN LPWSTR pwszNICGuid,
                             OUT BSTR **ppbstrIPAddresses,
                             OUT DWORD *pdwNumIPAddresses );


dllexp
HRESULT QueryLocalIPAddresses( OUT BSTR **ppbstrLocalAddresses,
                               OUT DWORD *pdwNumAddresses );

dllexp
HRESULT QueryNonNLBIPAddresses( OUT BSTR **ppbstrIPAddresses,
                                OUT DWORD *pdwIPAddresses );

dllexp
HRESULT FindLiveBackEndIpAddress( IN LPWSTR pwszServer,
                                  IN LPWSTR pwszUser,
                                  IN LPWSTR pwszDomain,
                                  IN LPWSTR pwszPwd, 
                                  OUT LPWSTR pwszIPAddress );

dllexp
HRESULT SetHighInterfaceMetric( IN LPWSTR pwszNicGuid );

dllexp
HRESULT CheckBackEndDefaultGW( IN LPWSTR pwszNlbNic,
                               IN LPWSTR *ppwszBackEndNics,
                               IN DWORD cBackEndNics );

#endif // _ACSIPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acsecurebstr.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

      acsecurebstr.h

   Abstract :

    Encapsulates an OLE BSTR.  When this BSTR is not in use, the
    data is stored encrypted in memory.  This memory is also wiped
    before freeing.  This class provides methods to access the plaintext
    buffer in a secure way.  CAcSecureBstr is similar to CAcBstr, but
    a CAcSecureBstr cannot be accessed from a CAcBstr.  Unlike CAcBstr,
    this class does not have a default buffer, because CryptProtectData
    allocates memory.

    This class was not included in acbstr.h to avoid the dependency on 
    the crypto api.

   Author :

      Jon Rowlett (jrowlett)

   Project :

      Application Center

   Revision History:
   05/30/2000 jrowlett created
   06/13/2000 jrowlett moved to acsrtl from appsrvadmlib
   08/22/2000 jrowlett added ClearBSTRContents function

--*/

#ifndef __ACSECUREBSTR_H__
#define __ACSECUREBSTR_H__

#include <wtypes.h>
#include <wincrypt.h>
#include "impexp.h"

class CLASS_DECLSPEC CAcSecureBstr;

class CLASS_DECLSPEC CAcSecureBstr
{
public:
    CAcSecureBstr();
    virtual ~CAcSecureBstr();

    //
    // Usage Inhibitors (not implemented)
    //
    CAcSecureBstr(const CAcSecureBstr& );
    CAcSecureBstr& operator =(const CAcSecureBstr& );

    //
    // Modifier functions
    //
    HRESULT Assign(IN LPCWSTR psz);
    HRESULT Assign(IN const CAcSecureBstr& secbstr);
    HRESULT AssignBSTR(IN BSTR bstr);

    HRESULT Append(IN LPCWSTR psz, DWORD cch = 0);
    HRESULT Append(IN const CAcSecureBstr& secbstr);
    HRESULT AppendBSTR(IN BSTR bstr);

    HRESULT Empty();

    HRESULT ExchangeWindowText(HWND hwnd, bool fUpdateData = true, bool fClearWindow = true);

    //
    // Accessor functions
    //
    HRESULT GetBSTR(OUT BSTR* pbstr);
    ULONG   ReleaseBSTR(IN BSTR bstr);

    //
    // Utility Functions
    //
    static HRESULT CAcSecureBstr::CompareNoCase(IN const CAcSecureBstr& secbstr1,
                                                IN const CAcSecureBstr& secbstr2,
                                                OUT long& rlResult);
    static void ClearBSTRContents(IN OUT BSTR bstr);

protected:
    //
    // Data Members
    //
    DATA_BLOB    m_blobEncryptedBSTR;
    DWORD        m_dwTempBSTRRefCount;
    DATA_BLOB    m_blobTempDecryptedBSTR;
    DWORD        m_dwTickCount;

    //
    // Buffer Access
    //
    static BSTR    AllocLen(DWORD cbBufferSize);
    static void    FreeTempBSTR(BSTR bstr);
    static DWORD   GetTotalBSTRBufferSize(BSTR bstr);
    HRESULT SaveBSTR(IN OUT BSTR bstr, bool bClear = true);

private:
    //
    // Instrumentation and Debugging (referenced by CHK build only)
    //
    DWORD        m_dwContentionCount;
};

inline DWORD CAcSecureBstr::GetTotalBSTRBufferSize(BSTR bstr)
/*++
 
        returns the size of the buffer of the BSTR including the
        NULL terminator

  Arguments :
  
        cbBufferSize - size of the *STRING* buffer in BYTES 
            including NULL terminator, 
            not including the BSTR size information it stores.

  Returns:
 
     BSTR Fake BSTR to play with 
--*/
{
    return bstr ?
        *((DWORD*)bstr - 1) + sizeof(WCHAR) :
        0;
}

inline void    CAcSecureBstr::FreeTempBSTR(BSTR bstr)
/*++
 
    Wipes and frees a fake BSTR allocated with AllocLen

  Arguments :
  
     BSTR bstr

  Returns:
 
     None 
--*/
{
    DWORD cbSize = GetTotalBSTRBufferSize(bstr);

    if(cbSize)
    {
        memset(bstr, 0, cbSize);
        LocalFree((DWORD*)bstr - 1);
    }
}

inline void CAcSecureBstr::ClearBSTRContents(IN OUT BSTR bstr)
/*++
 
    Wipes the string data content of the bstr while preserving 
    the actual buffer and buffer size prefix

  Arguments :
  
     BSTR bstr

  Returns:
 
     None 
--*/
{
    DWORD cbSize = GetTotalBSTRBufferSize(bstr);

    if(cbSize)
    {
        memset(bstr, 0, cbSize);
    }
}

#endif /* __ACSECUREBSTR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acskuinfo.h ===
/*++

  Copyright 1999-2000 Microsoft Corporation

  Abstract:

    Helper exports for accessing AC product information
    in the registry and creating the product cookie.

  Author:

    Roger Sprague (rogers)

  History:

    11/11/2000 Roger Sprague (rogers)
        Added interface properties for scripting support.

  Notes:
    
    Refer to \private\appsrv\ui\AcProductInfo.

--*/

// AcSkuInfo.h : Declaration of exported functions in .
#ifndef __ACSKUINFO_H__
#define __ACSKUINFO_H__

#include <acsmacro.h>



//
// AcProductInfo SKU types
// Data structure for determining the type of SKU.
//

typedef enum _AcSkuType
{
    SKU_INTERNALBUILD,
    SKU_RETAILBUILD, 
	SKU_OEMOPK,   
    SKU_OEMBUILD,       // like RETAILBUILD but needs PID at customer mini-setup time
    SKU_DEVBUILD,       // dev install 2 machine maximum
    SKU_TIMEBOMBBUILD   // timebombed version
} AcSkuType;

// 
// Global function types
//

// Accessor type for calling GetSkuInfo
#define GETSKUINFO "GetSkuInfo"
typedef HRESULT ( __stdcall *PFNGETSKUINFO) (OUT AcSkuType* peSkuType ,OUT DWORD* pdwDaysToRun);


// Accessor type for calling SetCookie
#define SETCOOKIE "SetCookie"
typedef HRESULT ( __stdcall *PFNSETCOOKIE) ();

#define ACPRODUCTINFO "AcProductInfo.dll"

#endif /* __ACSKUINFO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acsmacro.h ===
/*++


Copyright (c) 1999  Microsoft Corporation

Module Name:

    acsmacro.h

Abstract:

    Contains macros used by the Application Center Server project.

    PLEASE NOTIFY THE ACS DEVELOPMENT TEAM BEFORE YOU ADD ANYTHING TO THIS
    FILE.  he purpose of this file is to have a consistent, coherent set of
    macros to be used throughout the ACS project.  Please don't litter.

    Easiest way to use this file is to #include it in your stdafx.h (pre-
    compiled header file)

Author:

    Jeff Miller (jeffmill)      06-Nov-99

Revision History:

    removed hr from the debug output part of the error handling macros to
    avoid a situation where  CLEANUPONFAILURE( hres = func() ) would evaluate
    func() twice.

--*/

#ifndef ACSMACRO_H
#define ACSMACRO_H

//
// Product name
// This is currently used by setup to identify the eventing COM+ application's
// creator.  This should NOT be localized, nor should it be used for any UI.
//

#define ACS_PRODUCT_NAME    L"Microsoft Application Center 2000"

// ----------------------------------------------------------------------------
//
// Standard strings
//
// As a hint to the user include _A_ for ASCII strings.
//
// ----------------------------------------------------------------------------

// Services names
#define AC_CLUSTER_SVC_NAME         L"ACCLUSTER"
#define AC_CLUSTER_SVC_EXE          AC_CLUSTER_SVC_NAME L".EXE"
#define ACS_REPL_SVC_SHORTNAME      L"acsrepl"
#define AC_REPL_SVC_EXE             ACS_REPL_SVC_SHORTNAME L".exe"
#define AC_NAMERES_SVC_NAME         L"acnameres"
#define AC_NAMERES_SVC_EXE          AC_NAMERES_SVC_NAME L".exe"
#define ACS_IISADMIN_SVC_NAME       L"inetinfo"
#define ACS_IISADMIN_SVC_EXE        ACS_IISADMIN_SVC_NAME L".exe"
#define ACS_COM_LB_SVC_NAME         L"comlbsvc"
#define ACS_COM_LB_SVC_EXE          L"comlb.exe"
#define AC_ACADMIN_SVC_NAME         L"acadmin"

// Strings used for calculating the size of buffers
#define ACS_A_MAXQWORD          "18446744073709551616"
#define ACS_A_MAXDWORD          "4294967296"
#define ACS_A_MAXWORD           "65536"
#define ACS_A_IP_STRING         "255.255.255.255"

// XML Version 1.0 start string
#define ACS_XML_START           L"<?xml version=\"1.0\"?>\n"

// Location of ACS registry strings
#define ACS_REG_BASE            TEXT("SOFTWARE\\Microsoft\\")
#define ACS_REG_NAME            ACS_REG_BASE TEXT("Application Center Server")
#define ACS_REG_PATH            ACS_REG_NAME TEXT("\\1.0")
#define ACS_REG_PID_PATH        ACS_REG_PATH TEXT("\\Registration\\ProductID")
#define ACS_REG_DIGIPID_PATH    ACS_REG_PATH TEXT("\\Registration\\DigitalProductID")
#define ACS_REG_UNISTALL        ACS_REG_BASE TEXT("Windows\\CurrentVersion\\Uninstall\\{20F95200-47D6-4CAC-92FF-5F6B29C78F88}")
#define ACS_INSTALL_DIR         TEXT("InstallationDirectory")

#define ACS_MSATQ_REG_NAME      ACS_REG_NAME TEXT("\\ATQ")
#define ACS_REPLSIG_REG_NAME    TEXT("ReplSig")

// AC registry product value names
#define ACS_REG_OWNER            TEXT("RegOwner")
#define ACS_REG_COMPANY          TEXT("RegCompany")
#define ACS_REG_DISPLAY_VERSION  TEXT("DisplayVersion")
#define ACS_REG_COOKIE           TEXT("Cookie")
#define ACS_REG_SKU_TYPE         TEXT("SkuType")
#define ACS_REG_PRODUCT_ID       TEXT("ProductID")

//
// Registry keys
//
#define SZ_SOFTWARE L"Software"
#define SZ_CLASSES  L"Classes"
#define SZ_CLSID    L"CLSID"
#define SZ_APPID    L"AppID"
#define SZ_TYPELIB  L"TypeLib"

#define SZ_SOFTWARE_CLASSES_PATH  SZ_SOFTWARE L"\\" SZ_CLASSES L"\\"
#define SZ_SOFTWARE_CLSID_PATH    SZ_SOFTWARE L"\\" SZ_CLASSES L"\\" SZ_CLSID L"\\"


// ----------------------------------------------------------------------------
//
// Standard defines
//
// ----------------------------------------------------------------------------

// The following define is used by strings that might end up containing either 
// an IP number or a server name. This generally happens when retrieving a
// server name from the metabase where the user could just as easily have added
// an IP number as a name
// Note: UNCLEN is the same as DNSLEN so I have not included DNSLEN here
#define ACS_SERVER_NAME_SIZE            MAX(sizeof(ACS_A_IP_STRING), (UNCLEN+1))

// The maximum size a user name. password and NT domain can be
#define ACS_CLUSTERUSER_NAME_LEN        (LM20_UNLEN + 1)
#define ACS_CLUSTERUSER_PWD_LEN         (LM20_PWLEN + 1)
#define ACS_CLUSTERUSER_DOMAIN_LEN      32

// A sample GUID used for string calculations
#define ACS_A_SAMPLE_GUID               "{54639a3f-ebbb-4f1a-88a7-a0ea0e82d99a}"
#define ACS_W_SAMPLE_GUID               L"{54639a3f-ebbb-4f1a-88a7-a0ea0e82d99a}"

// The size of a GUID, including and not including the trailing NULL
#define ACS_GUID_SIZE                   (sizeof(ACS_A_SAMPLE_GUID))
#define ACS_GUID_LENGTH                 (lengthof(ACS_A_SAMPLE_GUID))

// Special IP port numbers
#define IP_INVALID_PORT_NUMBER          0       // Protocol-specific default
#define IP_DEFAULT_HTTP_PORT            80      // Default port for HTTP
#define IP_DEFAULT_HTTPS_PORT           443     // Default port for HTTPS

// Common strings
#define AC_INVALID_FILE_EXT             L"./:*?\\\"<>|"
#define AC_DEFAULT_ADMIN_PORT           L":4242"
#define AC_LOCALHOST_STRING             L"localhost"

// ----------------------------------------------------------------------------
//
// General purpose macros
//
// ----------------------------------------------------------------------------

#define ARRAYELEMENTS(array) (sizeof(array)/sizeof(array[0]))

#ifdef DOBREAK
#    define DEBUGBREAK DebugBreak()
#else
#    define DEBUGBREAK
#endif

// MAX Macro used to determine which of two values is the larger
#ifndef MAX
#define MAX(a, b)                       (((a) > (b)) ? (a) : (b))
#endif

// sizofw is for getting the number of characters in a UNICODE variable
// lengthofw is for getting the number of characters in a UNICODE string not
// including the trailing NULL
#define sizeofw(param)                  (sizeof(param) / sizeof(WCHAR))
#define lengthofw(param)                (sizeofw(param) - 1)

// lengthof is for getting the number of characters in an ASCII string not
// including the trailing NULL
#define lengthof(param)                 (sizeof(param) - 1)

#ifndef SAFERELEASE

#define SAFERELEASE( p )  \
if ( p ) \
{ \
    long lTemp = p->Release(); \
    IF_DEBUG(ADDRELEASE) { \
        DBGINFO((DBG_CONTEXT, "release = %d\n", lTemp)); \
    } \
    p = NULL; \
}

#endif

// ----------------------------------------------------------------------------
//
// Error handling
// (for use with smart pointers &  do...while (0) logic
//
// ----------------------------------------------------------------------------

#define BREAKONFAILURE(hr, msg) \
{ \
    if (FAILED((hr))) \
    { \
        DBGERROR((DBG_CONTEXT, "*** HRESULT FAILED: " msg " ***\n")); \
        DEBUGBREAK; \
        break; \
    } \
}

#define RETURNONFAILURE(hr, msg) \
{ \
    if (FAILED((hr))) \
    { \
        DBGERROR((DBG_CONTEXT, "*** HRESULT FAILED: " msg " ***\n")); \
        DEBUGBREAK; \
        return hr; \
    } \
}

#define CONTINUEONFAILURE(hr, msg) \
{ \
    if (FAILED(hr)) \
    { \
        DBGWARNW(msg); \
        continue; \
    } \
}

#define BREAKONFAILUREEX(hr, msg) \
{ \
    if (FAILED((hr))) \
    { \
        DBGERRORW(msg); \
        break; \
    } \
}

#define BREAKONNTFAILURE( uResult, msg ) \
{ \
    if ( (uResult) != ERROR_SUCCESS ) \
    { \
        DBGERROR((DBG_CONTEXT, "*** NT API FAILED: " msg " ***\n")); \
        DEBUGBREAK; \
        break; \
    } \
}

#define RETURNONNTFAILURE( uResult, msg ) \
{ \
    if ( (uResult) != ERROR_SUCCESS ) \
    { \
        DBGERROR((DBG_CONTEXT, "*** NT API FAILED: " msg " ***\n")); \
        DEBUGBREAK; \
        return uResult; \
    } \
}


// ----------------------------------------------------------------------------
//
// Error handling
// (for use with a "Cleanup:" label
//
// ----------------------------------------------------------------------------

#define CLEANUPONFAILUREEX(hr, msg) \
{ \
    if ( FAILED(hr) ) \
    { \
        DBGERRORW(msg); \
        DEBUGBREAK; \
        goto Cleanup; \
    } \
}

#if DBG

#define CLEANUPONFAILURE(hr) \
{ \
    HRESULT hrTEMPORARY = hr; \
    if ( FAILED(hrTEMPORARY) ) \
    { \
        DBGERROR((DBG_CONTEXT, "*** HRESULT FAILED! hr: %X, statement: '%s'\n", \
                               hrTEMPORARY, #hr )); \
        DEBUGBREAK; \
        goto Cleanup; \
    } \
}

#define CLEANUPONFAILUREF(hr) \
{ \
    HRESULT hrTEMPORARY = hr; \
    if ( FAILED(hrTEMPORARY) ) \
    { \
        DBGERROR((DBG_CONTEXT, "*** HRESULT FAILED! hr: %X, statement: '%s'\n", \
                               hrTEMPORARY, #hr )); \
        DEBUGBREAK; \
        goto FinalCleanup; \
    } \
}


#define CLEANUPONFAILUREEXF(hr, msg) \
{ \
    if ( FAILED(hr) ) \
    { \
        DBGERRORW(msg); \
        DEBUGBREAK; \
        goto FinalCleanup; \
    } \
}

#define CLEANUPONBOOLFAILURE(a) \
{ \
    if ( !(a) ) \
    { \
        DBGERRORW((DBG_CONTEXT, L"*** BOOL FAILURE ***\n")); \
        DEBUGBREAK; \
        hres = RETURNCODETOHRESULT(GetLastError()); \
        goto Cleanup; \
    } \
}

#else

#define CLEANUPONFAILURE(hr) \
{ \
    if ( FAILED(hr) ) \
    { \
        goto Cleanup; \
    } \
}

#define CLEANUPONFAILUREF(hr) \
{ \
    if ( FAILED(hr) ) \
    { \
        goto FinalCleanup; \
    } \
}

#define CLEANUPONFAILUREEXF(hr, msg) \
{ \
    if ( FAILED(hr) ) \
    { \
        goto FinalCleanup; \
    } \
}

#define CLEANUPONBOOLFAILURE(a) \
{ \
    if ( !(a) ) \
    { \
        hres = RETURNCODETOHRESULT(GetLastError()); \
        goto Cleanup; \
    } \
}

#endif

#define CHECKHRES(a) \
{ \
    a; \
    if (FAILED(hres)) \
    { \
        goto Cleanup; \
    } \
}


// ----------------------------------------------------------------------------
//
// Warn-on-error stuff
//
// ----------------------------------------------------------------------------

#define WARNONFAILURE(hr, b) \
{ \
    if ( FAILED(hr) ) \
    { \
        DBGERRORW(b); \
    } \
}

#define INFOONFAILURE(hr, b) \
{ \
    if ( FAILED(hr) ) \
    { \
        DBGINFOW(b); \
    } \
}


// ----------------------------------------------------------------------------
//
// Win32 error code related
//
// ----------------------------------------------------------------------------

// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.

#define RETURNCODETOHRESULT(rc) \
    (((rc) < 0x10000) ? HRESULT_FROM_WIN32(rc) : (rc))

#define GETERRORSTATUS(a) \
    ( GetLastError() != ERROR_SUCCESS ? \
      RETURNCODETOHRESULT(GetLastError()) : (a) )

#define NTFAILED(a) (a) != ERROR_SUCCESS

#ifndef HRESULTTOWIN32
//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))
#endif

// ----------------------------------------------------------------------------
//
// Heap Checking
//
// ----------------------------------------------------------------------------

#define CHECK_HEAP DBG_ASSERT( HeapValidate( GetProcessHeap(), 0, NULL ) );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acsrtl.h ===
/*++



Copyright (c) 1999  Microsoft Corporation

Module Name:

    acsrtl.h

Abstract:

     Contains function declarations for acsrtl dll

Author:

    AMallet        23-Nov-99

--*/

#ifndef _ACSRTL_H_
#define _ACSRTL_H_

#include <objbase.h>
#include <lmcons.h>

// Standard defines
#include "acsmacro.h"

// Import/Export declspecs
#include "impexp.h"

//
// task list structure
//
#define TITLE_SIZE          64
#define PROCESS_SIZE        MAX_PATH

typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    BOOL        flags;
    HANDLE      hwnd;
    TCHAR       ProcessName[PROCESS_SIZE];
    TCHAR       WindowTitle[TITLE_SIZE];
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;

//
// Module enumerator.
//

typedef struct _MODULE_INFO {
    ULONG_PTR DllBase;
    ULONG_PTR EntryPoint;
    ULONG SizeOfImage;
    CHAR BaseName[MAX_PATH];
    CHAR FullName[MAX_PATH];
} MODULE_INFO, *PMODULE_INFO;

typedef
BOOLEAN
(CALLBACK * PFN_ENUMMODULES)(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    );

//
// Function pointer types for accessing platform-specific functions
//
typedef HRESULT (*LPGetTaskList)(PTASK_LIST, DWORD, LPTSTR, LPDWORD, BOOL, LPSTR);
typedef BOOL  (*LPEnableDebugPriv)(VOID);



// Exported support functions available in this run time library
API_DECLSPEC unsigned long inet_addrW( IN WCHAR *wcp );

API_DECLSPEC HRESULT GetServiceProcessInfo(IN WCHAR *pszwServiceName,
                                           OUT DWORD *pdwProcessID);

API_DECLSPEC HRESULT GetProcessId( IN LPWSTR pwszProcessName,
                                   OUT DWORD *pdwProcessId );

API_DECLSPEC HRESULT GetProcessIdEx( IN LPWSTR pwszProcessName,
                                     IN DWORD dwAfterProcessId,
                                     OUT DWORD *pdwProcessId );

API_DECLSPEC HRESULT IsProcessRunning( IN LPWSTR pwszProcessName,
                                       OUT BOOL *pfIsRunning );

API_DECLSPEC HRESULT GetTaskListNT( PTASK_LIST  pTask,
                                    DWORD       dwNumTasks,
                                    LPTSTR      pName,
                                    LPDWORD     pdwNumTasks,
                                    BOOL        fKill,
                                    LPSTR       pszMandatoryModule );

API_DECLSPEC HRESULT KillProcess( IN PTASK_LIST ptlist,
                                  IN BOOL fForce );

API_DECLSPEC HRESULT IsDllInProcess( DWORD   dwProcessId,
                                     LPSTR   pszName,
                                     LPBOOL  pfFound );

API_DECLSPEC VOID GetPidFromTitle( LPDWORD     pdwPid,
                                   HWND*       phwnd,
                                   LPCTSTR     pExeName );


API_DECLSPEC BOOL EnableDebugPrivNT( VOID );


API_DECLSPEC HRESULT RetrieveClusterUser( OUT LPWSTR pwszClusterUser,
                                          OUT LPWSTR pwszUserPwd,
                                          OUT LPWSTR pwszDomain );

API_DECLSPEC HRESULT IsLocalMachine( IN LPCWSTR pwszServer,
                                     OUT BOOL *pfMatches );

API_DECLSPEC BOOL DoesServerNameMatchFQDN( IN LPCWSTR pwszFQDN,
                                           IN LPCWSTR pwszName );


// dantra: 03/11/00 allow linking to devstudio project (uses __cdecl by default)
API_DECLSPEC HRESULT __stdcall GetInterfacePtr( IN LPWSTR pwszServer,
                                                IN COSERVERINFO *pcsi,
                                                BOOL fImpersonate, 
                                                IN CLSID  clsid, 
                                                IN REFIID refiid, 
                                                IN LONG lNameResSvcFlags, 
                                                OUT IUnknown **ppIUnknown,
                                                OUT LPWSTR pwszIPUsed );

API_DECLSPEC HRESULT FindAllLiveIPAddresses( IN LPWSTR pwszServerName,
                                             IN LONG lNameResSvcFlags, 
                                             OUT LPWSTR **pppwszIPAddresses,
                                             OUT DWORD *pdwNumAddresses );

API_DECLSPEC HRESULT FindLiveIPAddress( IN LPWSTR pwszServerName,
                                        IN LONG lNameResSvcFlags, 
                                        OUT LPWSTR pwszIPAddress );


// bohrhe: 04/19/00 allow linking to devstudio project (uses __cdecl by default)
API_DECLSPEC HRESULT __stdcall AcValidateName( IN LPWSTR pwszName );

API_DECLSPEC HRESULT AcInitializeCriticalSection( OUT BOOL *pfGoodCS,
                                                  OUT CRITICAL_SECTION *pCS );


#endif // _ACSRTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\cluscmmn.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    cluscmmn.h 

    Header file containing declarations for utility functions etc 

    FILE HISTORY:
        AMallet     29-Jan-1999     Created
*/


#ifndef _CLUSCMMN_H_
#define _CLUSCMMN_H_

#include <mbx.hxx>
#include <acsiputil.h>
#include <acsmacro.h>
#include <acskuinfo.h>

#define MAX_GUID_LENGTH 64

#define MAX_SERVER_NAME_LENGTH 256

#define NETCFG_LOCK_TIMEOUT ( 2 * 60 * 1000 )

#define IP_ADDRESS_LENGTH 32

#define ACS_DEFAULT_BUFFER_SIZE 256

enum MEMBERSHIP_TYPE 
{ 
    STANDALONE_SERVER = 0, 
    WORKGROUP_SERVER, 
    DOMAIN_SERVER };

//
// Enum defining the various types of loadbalancing we support
//
enum eAC_LB_TYPE
{
   eAC_LB_TYPE_NONE = 0,
   eAC_LB_TYPE_NLB,
   eAC_LB_TYPE_CLB,
   eAC_LB_TYPE_THIRD_PARTY
};

#define WSZ_AC_LB_TYPE_NONE L"NONE"
#define WSZ_AC_LB_TYPE_NLB  L"NLB"
#define WSZ_AC_LB_TYPE_CLB  L"CLB"
#define WSZ_AC_LB_TYPE_THIRD_PARTY L"THIRD_PARTY"


#define PARTITION_NAME L"Partition 0"
#define PARTITION_DESCRIPTION L"Default Web Partition"


#define IIS_REGISTRY_PATH  L"System\\CurrentControlSet\\Services\\W3SVC\\Parameters"

#define SZ_MASTER_CHANGING L"MASTER_CHANGING"
#define SZ_MASTER_UNKNOWN L"MASTER_UNKNOWN"

#define WSZ_WEB_SVC L"W3SVC"
#define WSZ_WINMGMT_SVC L"WINMGMT"
#define WSZ_IISADMIN_SVC L"IISADMIN"

#define WSZ_NLB_AFFINITY_NONE L"NONE"
#define WSZ_NLB_AFFINITY_SINGLE L"SINGLE"
#define WSZ_NLB_AFFINITY_CLASS_C L"CLASSC"
#define WSZ_NLB_AFFINITY_INVALID L"INVALID"

#define WSZ_MULTICAST L"MULTICAST"
#define WSZ_UNICAST L"UNICAST"

#define WSZ_DUMMY_DEDICATED_IP L"0.0.0.0"
#define WSZ_DUMMY_DED_IP_SUBNET L"0.0.0.0"

#define WSZ_DEFAULT_CLUSTER_IP L"0.0.0.0"

#define COMPONENT_NAME_WLBS L"WLBS"

#define WSZ_TRUE   L"TRUE"
#define WSZ_FALSE  L"FALSE"

#if DBG
#define PRINT_IMPERSONATED_USER_INFO      \
{ \
   HRESULT hRes = S_OK; \
   BOOL fIsAdmin = FALSE; \
   WCHAR awchUser[UNLEN + 1]; \
   CoImpersonateClient(); \
   if ( GetCurrentUser( awchUser, UNLEN, TRUE ) ) \
   { \
   if ( SUCCEEDED( hRes = IsCurrentUserAdmin( &fIsAdmin ) ) ) \
       { \
         if ( fIsAdmin ) \
         { \
         DBGINFO((DBG_CONTEXT, "Impersonated user %s is an admin\n", W2A(awchUser))); \
         } \
         else \
         { \
             DBGINFO((DBG_CONTEXT, "Impersonated user %s is not an admin\n",W2A(awchUser))); \
         } \
       } \
       else \
       { \
          DBGINFO((DBG_CONTEXT, "IsCurrentUserAdmin failed : 0x%x\n", hRes)); \
       } \
  } \
  CoRevertToSelf(); \
} 
#else
#define PRINT_IMPERSONATED_USER_INFO 
#endif 


#define SAFEFREEBSTR( s ) \
if ( s ) \
{ \
  SysFreeString( s ); \
  s = NULL; \
}

//
// Macro used to compensate for the IXMLDOM objects annoying habit of returning S_FALSE ...
//
#define TRANSFORMSFALSE( hRes ) \
{ \
   if ( hRes == S_FALSE ) \
     hRes = E_FAIL; \
}


typedef BOOL (*CHECK_NODE_TYPE_FNC) ( MB *pMB,
                                      LPWSTR pwszPath,
                                      LPWSTR pwszNode );


#define CONSTANT_SERVER_WEIGHT 50
#define INVALID_SERVER_WEIGHT 0xFFFFFFFF
#define PORT_RULE_SIZE sizeof(CVY_RULE)

//
// Bitmasks used to represent permanent server configuration
//
#define PERSISTENT_STATE_SERVER_IN_LB         0x00000001 //server should be LB if healthy
#define PERSISTENT_STATE_SERVER_IN_REPL_LOOP  0x00000002 //server is part of replication loop
#define PERSISTENT_STATE_SYNC_ON_START       0x00000004 //wait for full sync before serving pages
                                                        //on startup, if part of load-balancing 

//
// Bitmasks for LB capabilities bits
//
#define MD_AC_LB_CAPABILITY_SUPPORTS_NONE              0x00000000
#define MD_AC_LB_CAPABILITY_SUPPORTS_ONLINE            0x00000001
#define MD_AC_LB_CAPABILITY_SUPPORTS_DRAIN             0x00000002
#define MD_AC_LB_CAPABILITY_SUPPORTS_STATUS            0x00000004

//////////////////////////////////////////////////////////////////////////////////
//
// Verbose tracing definitions
//
//////////////////////////////////////////////////////////////////////////////////

// STATUS           Outputs location information during lengthy processes
#define DEBUG_CL_STATUS                 0x00000001 
#define DEBUG_CCI                       0x00000002 //debug CoCreateInstance calls
#define DEBUG_NAMERES                   0x00000004 //debug name resolution calls 


//
// Structure/class declarations
//
#define MAX_FS_DRIVES 256
#define DRIVE_SPEC_SIZE ( 3 * sizeof(WCHAR) )   //size in bytes of eg "c:\", without trailing
                                                //NULL character
#define FULL_DRIVE_SPEC_SIZE ( 4 * sizeof(WCHAR) ) //size in bytes of eg "c:\", with trailing
                                                   //NULL character
#define DRIVE_SPEC_LEN 3  //length in characters of eg "c:\"

typedef struct dllexp _MACHINE_PATH_INFO
{
    WCHAR awchWindowsDir[MAX_PATH + 1];
    WCHAR awchProgFilesDir[MAX_PATH + 1];
    WCHAR awchACInstallDir[MAX_PATH + 1];
} MACHINE_PATH_INFO, *PMACHINE_PATH_INFO;


//////////////////////////////////////////////////////////////////////////////////
//
// Function declarations
//
//////////////////////////////////////////////////////////////////////////////////

dllexp HRESULT InitializeCluscmmnDll();

dllexp HRESULT UninitializeCluscmmnDll();


dllexp HRESULT DiscoverClusterMaster( IN BOOL fIgnoreLocalMachine,
                                      OUT LPWSTR *ppwszClusterMaster );

dllexp HRESULT DiscoverClusterMaster( IN BOOL fIgnoreLocalMachine,
                                      OUT LPWSTR *ppwszClusterMaster,
                                      OUT DWORD *pdwTopologyVersion );

dllexp HRESULT IsLocalMachineStillInCluster( OUT BOOL *pfInCluster );

dllexp HRESULT StartSvc( IN LPWSTR pwszSvcName );

dllexp HRESULT StopSvc( IN LPWSTR pwszSvcName,
                        IN DWORD dwTimeout = 0 );

dllexp HRESULT RestartSvc( IN LPWSTR pwszSvcName );

dllexp HRESULT StopAcsServices( IN BOOL fIISSvcs,
                                IN DWORD dwTimeout = 0 );

dllexp HRESULT IsSvcRunning( IN LPWSTR pwszSvcName,
                             OUT BOOL *pfIsRunning );

dllexp HRESULT QuerySvcsInExecutable( IN LPWSTR pwszExeName,
                                      IN DWORD dwSvcState,
                                      IN DWORD cMaxSvcs,
                                      OUT LPWSTR *ppwszRunningSvcs,
                                      OUT DWORD *pdwRunningSvcs );


dllexp BOOL GetCurrentUser( OUT WCHAR *pwszUser,
                            IN DWORD cbUserSize,
                            IN BOOL fImpersonated );


dllexp HRESULT IsCurrentUserAdmin( OUT BOOL *pfIsAdmin );

dllexp
HRESULT UpdateMBStringList( IN LPWSTR pwszMBPath,
                            IN DWORD dwMBID,
                            IN BOOL fAdd,
                            IN LPWSTR pwszString,
                            IN WCHAR awchSeparator );

dllexp
HRESULT GetMBData( IN IMSAdminBase *pMB,
                   IN METADATA_HANDLE hmd,
                   IN LPWSTR pwszPath,
                   IN METADATA_RECORD *pmdr,
                   OUT BYTE **ppbData,
                   OUT DWORD *pcbSize,
                   IN DWORD dwExtraBytes = 0);

dllexp
HRESULT SetMBData( IN LPWSTR pwszPath,
                   IN METADATA_RECORD *pmdr );


dllexp
HRESULT GetAllVSiteBindings( OUT DWORD *pdwSiteBindings,
                             OUT LPWSTR **pppwszSitBindings );


dllexp
HRESULT CreateIPAddressesFromSiteBindings();

dllexp 
BOOL MBKeyExists( IN MB *pMB,
                  IN LPWSTR pwszPath );


dllexp 
HRESULT ByteBufferToHexString( IN PBYTE pbHexBuffer,
                               IN DWORD cbBytes,
                               OUT LPWSTR *ppwszString );

dllexp
HRESULT HexStringToByteBuffer( IN LPWSTR pwszString,
                               OUT DWORD *pcbBytes,
                               OUT PBYTE *ppbHexBuffer );
                               
dllexp
HRESULT GenerateStringGuid( OUT BSTR *pbstrGuid );

dllexp
HRESULT UpdateStringList( IN BOOL fAdd,
                          IN LPWSTR pwszList,
                          IN LPWSTR pwszItem,
                          IN WCHAR awchSeparator,
                          OUT LPWSTR pwszUpdatedList,
                          IN BOOL fCaseSensitive = FALSE );
                          
dllexp
HRESULT AllocateBSTR( OUT BSTR *pbstrOut,
                      IN LPWSTR pwszIn );


dllexp
HRESULT GenerateLocalInterfacePointer( IN CLSID clsid,
                                       IN REFIID riid,
                                       OUT void **ppv );


dllexp 
HRESULT FindNICToBindNLBTo( IN BSTR bstrClusterIP,
                            IN BSTR bstrClusterIPSubnet,
                            IN BSTR bstrDedicatedIP,
                            IN BSTR bstrDedicatedIPSubnet,
                            BOOL fConsiderDHCP,
                            OUT BSTR *pbstrNICGuid );

dllexp 
BOOL GetPortNumberFromBinding( IN LPWSTR pwszBinding,
                               OUT DWORD *pdwPort );

dllexp
BOOL GetIPAddressFromBinding( IN LPWSTR pwszBinding,
                              OUT LPWSTR pwszIPAddress );

dllexp
HRESULT RetrieveNonNlbNicGuids( OUT LPWSTR **pppwszNicGuids,
                                OUT DWORD *pdwNumNicGuids );

dllexp 
HRESULT SetBackEndNicGuidList( IN LPWSTR *ppwszNicGuids,
                               IN DWORD cNics );

dllexp
HRESULT RetrieveBackEndNicGuids( OUT LPWSTR **pppwszNicGuids,
                                 OUT DWORD *pdwNumNicGuids );


dllexp
HRESULT RetrieveBackEndNicGuidsFromMB( OUT LPWSTR **pppwszNicGuids,
                                       OUT DWORD *pdwNumNicGuids );

dllexp
HRESULT RetrieveBackEndIps( OUT BSTR **ppbstrIps,
                            OUT DWORD *pdwNumIps );

dllexp
HRESULT RetrieveIpsOnNics( IN LPWSTR *ppwszNicGuids,
                           IN DWORD cNics,
                           OUT BSTR **ppbstrIps,
                           OUT DWORD *pdwNumIps );

dllexp
HRESULT CheckAndEnableNetBT( IN LPWSTR *ppwszNicGuids,
                             IN DWORD cNics,
                             IN BOOL fFireEvent );

dllexp
HRESULT GetMachinePathInfo( OUT PMACHINE_PATH_INFO pmpi );

dllexp
BOOL DoesLocalMachinePathInfoMatch( IN PMACHINE_PATH_INFO pmpi,
                                    IN PMACHINE_PATH_INFO pmpiLocal );

dllexp
HRESULT RunRemoteAsyncCmd( IN LPWSTR pwszCLSID,
                           IN LPWSTR pwszServer,
                           IN LPWSTR pwszInput,
                           IN LPWSTR pwszUser,
                           IN LPWSTR pwszDomain,
                           IN LPWSTR pwszPwd,
                           IN DWORD dwTimeout,
                           OUT BSTR *pbstrOutputXML,
                           OUT HRESULT *phrResult );

dllexp
VOID SetCOMAuthInfo( IN OUT COAUTHINFO *pcoaiAuthInfo,
                     IN OUT COAUTHIDENTITY *pcoaiAuthId,
                     IN BOOL fLocalMachine,
                     IN LPWSTR pwszAdminAcct,
                     IN LPWSTR pwszAdminPwd,
                     IN LPWSTR pwszDomain );


dllexp
BOOL IsNullOrEmpty( IN LPWSTR pwszStr );

dllexp
BOOL WellFormedCredentials( IN LPWSTR pwszUser,
                            IN LPWSTR pwszDomain,
                            IN LPWSTR pwszPwd );

dllexp
HRESULT ExtractBSTRArrayFromVARIANT( IN VARIANT *pvar,
                                     OUT BSTR **ppbstrStrings,
                                     OUT DWORD *pdwNumStrings );


dllexp 
HRESULT ExtractWordArrayFromVARIANT( IN VARIANT *pvar,
                                     IN BOOL fDwordArray,
                                     IN PVOID pvArray,
                                     OUT DWORD *pdwNumElements );

dllexp
HRESULT SetTimeClientSettings( IN LPWSTR pwszNTPServer,
                               IN BOOL fRestartSvc );

dllexp
HRESULT SetTimeServerSettings( IN BOOL fRestartSvc );

dllexp HRESULT RetrieveSkuData( OUT AcSkuType *peSkuType,
                                OUT DWORD *pdwDaysToRun );
//
// XML manipulation functions
//

dllexp
HRESULT CreateASXMLDocument( IN LPWSTR pwszDocType,
                             OUT IXMLDOMDocument **ppASXMLDoc,
                             OUT IXMLDOMNode **ppASXMLDocNode );

dllexp
HRESULT GetDocumentType( IN IXMLDOMDocument *pIXMLDocument,
                         OUT BSTR *pbstrType );

dllexp
HRESULT ExtractNodeAttribute( IN IXMLDOMNode *pNode,
                              IN BSTR bstrAttributeName,
                              OUT BSTR *pbstrAttributeValue );

dllexp
HRESULT AddTextNode( IN OUT IXMLDOMNode *pParentNode,
                     IN LPWSTR pwszNodeName, 
                     IN LPWSTR pwszNodeValue );

dllexp
VOID ExtractXMLParseErrorInfo( IN IXMLDOMDocument *pIXMLDocument );

dllexp
HRESULT SanitizeXMLString( IN LPWSTR pwszString,
                           OUT LPWSTR *ppwszCleanString );

dllexp HRESULT LoadXML( OUT IXMLDOMDocument **ppIXMLDocument,
                        IN BSTR bstrXML );


dllexp HRESULT GetTagText( IN IXMLDOMDocument *pIXMLDocument,
                           IN BSTR bstrTagName,
                           OUT BSTR *pbstrTagText );

dllexp BOOL ContainsTag( IN IXMLDOMDocument *pIXMLDocument,
                         IN BSTR bstrTagName,
                         OUT IXMLDOMNodeList **ppINodeList );

dllexp HRESULT GetNodeAttribute( IN IXMLDOMNode *pNode,
                                 IN LPWSTR pwszAttribName,
                                 OUT BSTR *pbstrAttribValue );

dllexp
HRESULT GetNthNamedNode( IN IXMLDOMDocument *pDoc,
                         IN BSTR bstrNodeName,
                         IN LONG lIndex,
                         OUT IXMLDOMNode **ppNode );

dllexp
HRESULT GetNthChildNode( IN IXMLDOMNode *pParentNode,
                         IN LONG lIndex,
                         OUT IXMLDOMNode **pChildNode );




#endif //_CLUSCMMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\appsrvadmlib.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

      appsrvadmlib.h

   Abstract :

        Light weight wrapper for CComModule used in all ASAI components

        1: Handles intializeing and terminating traceing

   Author :

      Dan Travison (dantra)

   Project :

      Application Center Server

   Revision History:

--*/

#ifndef _AppSrvLib_H_
#define _AppSrvLib_H_
#include <AcError.h>
#include <AcBstr.h>
#include <MetaUtil.h>

class CAppSrvAdmModule : public CComModule
	{
	public:
        CAppSrvAdmModule(bool bIsProcess = false) 
            : CComModule(), 
            m_bIsProcess(bIsProcess),
            m_dwThreadID(0),
            m_hEventShutdown(NULL),
            m_bShutdown(false),
            m_hMonitorThread(NULL)
            {
            }

		LONG Unlock();
        LONG Lock();

		DWORD   m_dwThreadID;
		HANDLE  m_hEventShutdown;
        HANDLE  m_hMonitorThread;

		void    MonitorRun();
		HRESULT StartMonitor();
        void    StopMonitor();
		bool    m_bActivity;
        bool    m_bShutdown;

        // define and initilialize these static members in your main .cpp file.
        static const GUID   m_ModuleTraceGuid;
        static const LPCSTR m_pszModuleName;

        // update this non-static member if you are a process
        bool                m_bIsProcess;

        // override Init() to handle initializing tracing
        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
            {
            m_dwThreadID = GetCurrentThreadId();
            CAcError::InitializeTracing (m_pszModuleName, m_ModuleTraceGuid, m_bIsProcess);

            return CComModule::Init (p, h, plibid);
            }

        // override Term() to handle tracing cleanup
        void Term()
            {
            CComModule::Term();
            CAcError::TerminateTracing (m_bIsProcess);
            }
        
        typedef unsigned int (__stdcall * ThreadEntry) ( IN void * pParam );
        // dantra - 03/28/2000 added
        static HRESULT StartThread 
            (
            IN ThreadEntry pAddr,           // thread proc
            IN void * pParam,               // thread parameter
            OUT HANDLE & hThread,           // returned thread handle
            OUT HANDLE & hSignalEvent,      // created event handle (to signal thread)
            OUT DWORD * pdwThreadId = NULL  // optionally return the thread id
            );
        
        // dantra - 03/28/2000 added
        static HRESULT StopThread 
            (
            IN HANDLE & hThread,            // thread handle
            IN HANDLE & hSignal,            // event to signal thread shutdown (Can be NULL)
                                            // if non-null - event is deleted
            IN DWORD dwTimeout = INFINITE   // timeout to wait for thread
            );

    protected:
        static CMetaUtil    m_mu;
    };

// macro to define the modules tracing guid and name
// place this macro in your .CPP file where you define your AppSrvAdmModule
// name - the name used for tracing output as defined in GUIDS.TXT
// w1...w11 are the components of your tracing guid you would normally pass to 
// DEFINE_GUID  (see GUIDS.TXT)
#define DECLARE_ASAI_TRACING(name, w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11)\
const GUID CAppSrvAdmModule::m_ModuleTraceGuid = {w1,w2,w3,{w4,w5,w6,w7,w8,w9,w10,w11}};\
const LPCSTR CAppSrvAdmModule::m_pszModuleName = name;

extern CAppSrvAdmModule _Module;

/*-------------------------------------------
 Function name      : template<class ObjClass, class TInterface>TCreateInstance
 Description        : Create an instance of the specified ASAI Object/Collection interface
 Return type        : HRESULT
 Argument           : IN const ObjClass &
 Argument           : OUT TInterface * & pNewInstance
 -------------------------------------------
 dantra 6/17/2000   : Initial implementation - support function
                    : Note: I ran into link problems with my original approach and would get incorrect linkage
                    : when I made the first template paramater the target class (e.g., CAcApplicationObj).
                    : In short, at link time, I was seeing all calls to TCreateInstance mapping
                    : to a single class instead of the intended class. The workaround involved
                    : passing a CComObjClass<foo> as the first template parameter, defining an instance
                    : of CComObject<foo> as a stack variable, then referencing TCreateInstance
                    : relative to the stack variable
                    :   CComObject<CAcApplicationObj> tmp;
                    :   return  TCreateInstance<CComObject<CAcApplicationObj>, IAppCenterObj>(tmp, &pObj);
-------------------------------------------*/
template <class ComObjClass, class AsaiInterface>
HRESULT TCreateInstance (IN const ComObjClass &, OUT AsaiInterface ** ppNewInstance)
    {
    HRESULT hr;

    ComObjClass * pInstance = NULL;

    hr = ComObjClass::CreateInstance (&pInstance);

    if (SUCCEEDED (hr))
        {
        // addref so we can always release (e.g., not have to know about delete)
        pInstance->AddRef();

        hr = pInstance->QueryInterface (ppNewInstance);

        pInstance->Release();
        }

    if (FAILED(hr))
        {
        *ppNewInstance = NULL;
        }

    return hr;
    }

#endif //_AppSrvLib_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\acsmb.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

     acsmb.h

Abstract:

    Contains the MB properties and paths for the AppCenter Server project.


Author:

    Alex Mallet (AMallet)      12-Oct-1999

Revision History:

--*/


#ifndef _ACSMB_H_
#define _ACSMB_H_

#define IIS_MD_UT_WEBCLUSTER 200
#define IIS_MD_UT_WEBPARTITION 201

//
// The range 0x0000E000 - 0x0000EFFF is reserved for AppCenter Server. All AppCenter Server
// MB property IDs should be in this range
//
// JasAndre: I have increased the start to E038, which is 57400, so that it is
// easier to work out ID's with tools like metaedit
//
#define ACS_MB_ID_START    0x0000E038
#define ACS_MB_ID_END      0x0000EFFF

//
// Each area [WebCluster svc, Request Forwarding, Replication etc] has a range of MB IDs
// allocated to it. If you need to add a new range, insert the base property here and then
// use offsets from the base property.
//
#define WEBCLUSTER_BASE               (ACS_MB_ID_START)
#define RF_BASE                       (ACS_MB_ID_START + 200)
#define ICR_MD_BASE_PROP              (ACS_MB_ID_START + 400)
#define ASAI_BASE_PROP                (ACS_MB_ID_START + 600)
#define ACCOUNTS_BASE_PROP            (ACS_MB_ID_START + 800)


//
// Metabase properties and paths for WebCluster Services
//
#define LM_PATH                         L"/LM"
#define W3SVC_NODE                      L"/W3SVC"
#define W3SVC_PATH                      LM_PATH W3SVC_NODE
#define FILTER_NODE                     L"Filters"
#define FILTER_PATH                     W3SVC_PATH L"/" FILTER_NODE
#define APPCENTER_NODE                  L"/AppCenter"
#define APPCENTER_PATH                  LM_PATH APPCENTER_NODE
#define APPCENTER_LOCAL_DATA_PATH       APPCENTER_PATH L"/Server"
#define CLUSTER_NODE                    L"/Cluster"
#define CMDRESULT_NODE                  L"/CmdResults"
#define CLUSTER_PATH                    APPCENTER_PATH CLUSTER_NODE
#define CLUSTER_DIRECTORY_PATH          APPCENTER_PATH CLUSTER_NODE L"/ClusterDirectory"
#define CLUSTER_SERVERS_PATH            APPCENTER_PATH CLUSTER_NODE L"/ClusterDirectory/Servers"
#define PARTITION_PATH                  APPCENTER_PATH CLUSTER_NODE L"/Partitions"
#define REPLICATION_RESOURCE_PATH       APPCENTER_PATH CLUSTER_NODE L"/ReplicationResourceTypes"
#define REPLICATION_DEFINITION_PATH     APPCENTER_PATH CLUSTER_NODE L"/Replications"
#define CLSTRCMD_RESULT_PATH            APPCENTER_LOCAL_DATA_PATH CMDRESULT_NODE
#define FIRST_START_PATH                APPCENTER_PATH L"/FirstStart"

#define MD_WEBCLUSTER_GUID                                 (WEBCLUSTER_BASE + 0)
#define MD_WEBCLUSTER_NAME                                 (WEBCLUSTER_BASE + 1)
#define MD_WEBCLUSTER_DESCRIPTION                          (WEBCLUSTER_BASE + 2)
#define MD_WEBCLUSTER_USER                                 (WEBCLUSTER_BASE + 3)
#define MD_WEBCLUSTER_USERPWD                              (WEBCLUSTER_BASE + 4)
#define MD_WEBCLUSTER_MASTER                               (WEBCLUSTER_BASE + 5)
#define MD_WEBPARTITION_NAME                               (WEBCLUSTER_BASE + 6)
#define MD_WEBPARTITION_DESCRIPTION                        (WEBCLUSTER_BASE + 7)
#define MD_WEBPARTITION_MASTER                             (WEBCLUSTER_BASE + 8)
#define MD_WEBPARTITION_USER                               (WEBCLUSTER_BASE + 9)
#define MD_WEBPARTITION_USERPWD                            (WEBCLUSTER_BASE + 10)
#define MD_WEBPARTITION_LBTYPE                             (WEBCLUSTER_BASE + 11)
#define MD_WEBPARTITION_GUID                               (WEBCLUSTER_BASE + 12)
#define MD_WEBCLUSTER_KEYSEED                              (WEBCLUSTER_BASE + 13)
#define MD_WEBCLUSTER_CLUSTERIP                            (WEBCLUSTER_BASE + 14)
#define MD_WEBCLUSTER_DEDICATEDIP                          (WEBCLUSTER_BASE + 15)
#define MD_WEBCLUSTER_DEDIP_SUBNETMASK                     (WEBCLUSTER_BASE + 16)
#define MD_WEBCLUSTER_CLUSTERIP_SUBNETMASK                 (WEBCLUSTER_BASE + 17)
#define MD_WEBCLUSTER_LBTYPE                               (WEBCLUSTER_BASE + 18)
#define MD_WEBCLUSTER_WLBS_AFFINITY                        (WEBCLUSTER_BASE + 19)
#define MD_WEBCLUSTER_WLBS_MULTICAST                       (WEBCLUSTER_BASE + 20)
#define MD_WEBCLUSTER_SERVER_BINDINGS                      (WEBCLUSTER_BASE + 21)
#define MD_WEBCLUSTER_SECURE_BINDINGS                      (WEBCLUSTER_BASE + 22)
#define MD_WEBCLUSTER_WLBS_WEIGHT                          (WEBCLUSTER_BASE + 23)
#define MD_WEBCLUSTER_WLBS_PRIORITY                        (WEBCLUSTER_BASE + 24)
#define MD_WEBCLUSTER_WLBS_ASSIGNED_PRIORITIES             (WEBCLUSTER_BASE + 25)
#define MD_WEBCLUSTER_SERVER_PERSISTENT_STATE              (WEBCLUSTER_BASE + 26)
#define MD_WEBCLUSTER_CONTENT_REPL_DEFN_ID                 (WEBCLUSTER_BASE + 27)
#define MD_WEBCLUSTER_DEFAULT_PARTITION                    (WEBCLUSTER_BASE + 28)
#define MD_WEBCLUSTER_CLEANUP_DATA                         (WEBCLUSTER_BASE + 29)
#define MD_WEBCLUSTER_CONFIG_REPL_DEFN_ID                  (WEBCLUSTER_BASE + 30)
#define MD_WEBCLUSTER_SERVER_GUID                          (WEBCLUSTER_BASE + 31)
#define MD_WEBCLUSTER_LOCALHOST_NAME                       (WEBCLUSTER_BASE + 32)
#define MD_WEBCLUSTER_LOCALHOST_GUID                       (WEBCLUSTER_BASE + 33)
#define MD_WEBCLUSTER_TOPOLOGY_VERSION                     (WEBCLUSTER_BASE + 35)
#define MD_WEBCLUSTER_NETCFG_REPL_DEFN_ID                  (WEBCLUSTER_BASE + 37)
#define MD_WEBCLUSTER_FULLSYNC_REPL_DEFN_ID                (WEBCLUSTER_BASE + 38)
#define MD_WEBCLUSTER_DO_TIME_SYNC                         (WEBCLUSTER_BASE + 39)
#define MD_WEBCLUSTER_CLB_CLUSTER_LIST                     (WEBCLUSTER_BASE + 40)
#define MD_WEBCLUSTER_CLB_POLLING_INTERVAL                 (WEBCLUSTER_BASE + 41)
#define MD_WEBCLUSTER_CMD_HRESULT                          (WEBCLUSTER_BASE + 42)
#define MD_WEBCLUSTER_CMD_OUTPUT                           (WEBCLUSTER_BASE + 43)
#define MD_WEBCLUSTER_MSDE_INSTALLED                       (WEBCLUSTER_BASE + 44)
#define MD_WEBCLUSTER_USE_NETBT_NAMERES                    (WEBCLUSTER_BASE + 45)
#define MD_WEBCLUSTER_NTEVENTLOG_FILTER                    (WEBCLUSTER_BASE + 46)
#define MD_WEBCLUSTER_BACKEND_NIC_LIST                     (WEBCLUSTER_BASE + 47)
#define MD_WEBCLUSTER_HOSTS_MUNGE_INTERVAL                 (WEBCLUSTER_BASE + 48)
#define MD_WEBCLUSTER_MUNGE_HOSTS                          (WEBCLUSTER_BASE + 49)
#define MD_WEBCLUSTER_TURN_OFF_NIC_ADDR_REG                (WEBCLUSTER_BASE + 50)
#define MD_WEBCLUSTER_GET_COM_APPS_ON_START                (WEBCLUSTER_BASE + 51)
#define MD_WEBCLUSTER_MAX_CLUSTER_SVC_SYNC_CALLS           (WEBCLUSTER_BASE + 52)
#define MD_WEBCLUSTER_MAX_CLUSTER_SVC_ASYNC_WORK_ITEMS     (WEBCLUSTER_BASE + 53)
#define MD_WEBCLUSTER_MAX_NAMERES_SVC_CALLS                (WEBCLUSTER_BASE + 54)
#define MD_AC_LB_CAPABILITIES                              (WEBCLUSTER_BASE + 55)
#define MD_WEBCLUSTER_CLUSTER_SVC_STARTUP_CODE             (WEBCLUSTER_BASE + 56)
#define MD_WEBCLUSTER_NAMERES_SVC_STARTUP_CODE             (WEBCLUSTER_BASE + 57)
#define MD_WEBCLUSTER_CMDRESULT_LOWDATETIME                (WEBCLUSTER_BASE + 58)
#define MD_WEBCLUSTER_CMDRESULT_HIGHDATETIME               (WEBCLUSTER_BASE + 59)
#define MD_WEBCLUSTER_MAX_CLUSTER_SIZE                     (WEBCLUSTER_BASE + 60)

//
// Metabase properties and paths for Replication
//
#define REPLMD(a) ICR_MD_##a
#define ICR_MD_UTYPE                IIS_MD_UT_WEBCLUSTER

#define ICR_MD_CLUSTER_GLOBALS      _T("/LM/AppCenter/Cluster")
#define ICR_MD_REPL_GLOBALS         _T("/LM/WebReplication")
#define ICR_MD_SUB_DRIVERS          _T("ReplicationResourceTypes")
#define ICR_MD_SUB_REPLICATIONS     _T("Replications")
#define ICR_MD_SUB_LOCAL            _T("Local")
#define ICR_MD_SUB_PARTITIONS       _T("Partitions")
#define ICR_MD_REPL_LOCALS          ICR_MD_REPL_GLOBALS _T("/") ICR_MD_SUB_LOCAL
// dantra - 11/2/2000 51992 - move replication definitions out of system app
#define ICR_MD_REPLICATIONS         _T("/LM/AppCenter/") ICR_MD_SUB_REPLICATIONS
#define ICR_MD_DRIVERS              ICR_MD_REPL_LOCALS _T("/") ICR_MD_SUB_DRIVERS
#define ICR_MD_PARTITIONS           ICR_MD_CLUSTER_GLOBALS _T("/") ICR_MD_SUB_PARTITIONS

#define MD_WCR_DRIVER_CLSID         (REPLMD(BASE_PROP)+0)   // in drivers
#define MD_WCR_SERVERLIST           (REPLMD(BASE_PROP)+1)   // in replications
#define MD_WCR_AUTHCTXT             (REPLMD(BASE_PROP)+2)
#define MD_WCR_CONTENTDESC          (REPLMD(BASE_PROP)+3)
#define MD_WCR_FLAGS                (REPLMD(BASE_PROP)+4)
#define MD_WCR_STOREROOT            (REPLMD(BASE_PROP)+5)
#define MD_WCR_DEFSTOREROOT         (REPLMD(BASE_PROP)+6)   // in globals
#define MD_WCR_FRIENDLYNAME         (REPLMD(BASE_PROP)+7)   // in replications
#define MD_WCR_FLAGS2               (REPLMD(BASE_PROP)+8)
#define MD_WCR_DRIVER_FLAGS         (REPLMD(BASE_PROP)+9)   // in drivers

#define MD_APP_WAM_CREATOR_CLSID    (REPLMD(BASE_PROP)+10)  // in MB driver
#define MD_APP_WAM_SYNC_CLSID       (REPLMD(BASE_PROP)+11)  // in MB driver
#define MD_PARTITION_ID             (REPLMD(BASE_PROP)+12)  // in IIS driver
#define MD_REPL_RESOURCES           (REPLMD(BASE_PROP)+13)  // in IIS driver

#define MD_WCR_HTTP_PORTNO          (REPLMD(BASE_PROP)+14)  // in REPL_GLOBALS
#define MD_WCR_GLOBAL_FLAGS         (REPLMD(BASE_PROP)+15)  // in REPL_GLOBALS
#define MD_WCR_DRIVER_ORDER         (REPLMD(BASE_PROP)+16)  // in REPL_GLOBALS

#define MD_WCR_ATTR_VALUE           (REPLMD(BASE_PROP)+17)  // for admin UI
#define MD_WCR_SYSTEMDEF            (REPLMD(BASE_PROP)+18)  // in globals

#define MD_WCR_RPC_PORTNO           (REPLMD(BASE_PROP)+19)  // in REPL_GLOBALS
#define MD_WCR_RESCHED_PERIOD       (REPLMD(BASE_PROP)+20)  // in REPL_GLOBALS
#define MD_WCR_LOG_FLAGS            (REPLMD(BASE_PROP)+21)  // in REPL_GLOBALS
#define MD_WCR_SDOWN_SVC            (REPLMD(BASE_PROP)+22)  // in REPL_GLOBALS
#define MD_WCR_MAX_QUEUED_AUTO_LIST (REPLMD(BASE_PROP)+23)  // in REPL_GLOBALS
#define MD_WCR_EXCLUSION_LIST       (REPLMD(BASE_PROP)+24)  // in REPL_GLOBALS

#define MD_WCR_DRIVER_CHANGE_BUFFER_SIZE (REPLMD(BASE_PROP)+25)   // in drivers
#define MD_WCR_LASTJOBSTATS         (REPLMD(BASE_PROP)+26)  // in replications

#define MD_WCR_VSITECHECK           (REPLMD(BASE_PROP)+27)  // in REPL_GLOBALS
//
// Metabase properties for Request Forwarding
//
#define MD_RF_ENABLE_FP_FORWARDING                          (RF_BASE + 0)
#define MD_RF_ENABLE_DAV_FORWARDING                         (RF_BASE + 1)
#define MD_RF_ENABLE_HTMLA_FORWARDING                       (RF_BASE + 2)
#define MD_RF_ALWAYS_SEND_COOKIES                           (RF_BASE + 3)
#define MD_RF_IGNORE_ASP_SESSION_STATE                      (RF_BASE + 4)
#define MD_RF_FORWARDING_ENABLED_FOR_VSITE                  (RF_BASE + 5)
#define MD_RF_REUSE_LIMIT                                   (RF_BASE + 6)
#define MD_RF_HIDE_ORIGINAL_USER_INFO                       (RF_BASE + 7)
#define MD_RF_MAX_FORWARDING_HOPS                           (RF_BASE + 8)
#define MD_RF_CONNECT_TIMEOUT                               (RF_BASE + 9)
#define MD_RF_SENDRECV_TIMEOUT                              (RF_BASE + 10)
#define MD_RF_STICKY_OCF_SERVERS                            (RF_BASE + 11)
#define MD_RF_FP_PUBLISHING_RULES                           (RF_BASE + 12)
#define MD_RF_DAV_PUBLISHING_RULES                          (RF_BASE + 13)
#define MD_RF_STATIC_FILE_RULES                             (RF_BASE + 14)
#define MD_RF_CUSTOM_ERROR_FILES                            (RF_BASE + 15)
#define MD_RF_FREE_LIST_LIMIT                               (RF_BASE + 16)
#define MD_RF_REQUEST_FORWARDING_ENABLED                    (RF_BASE + 17)
#define MD_RF_ENABLE_ACWEBADMIN_FORWARDING                  (RF_BASE + 18)
#define MD_RF_ASYNC_POLLING_INTERVAL                        (RF_BASE + 19)
#define MD_RF_CLUSTER_STATE_POLLING_INTERVAL                (RF_BASE + 20)
#define MD_RF_CACHE_CLEARING_INTERVAL                       (RF_BASE + 21)
#define MD_RF_CONCURRENT_FORWARDS_LIMIT                     (RF_BASE + 22)
#define MD_RF_HEADERS_SAVE_LIST                             (RF_BASE + 23)

#define RF_DEFAULT_ENABLE_FP_FORWARDING                     FALSE
#define RF_DEFAULT_ENABLE_DAV_FORWARDING                    FALSE

//
// Default values for published Request Forwarding properties
//
#define RF_DEFAULT_IGNORE_ASP_SESSION_STATE                 FALSE
#define RF_DEFAULT_ALWAYS_COOKIE                            FALSE
#define RF_DEFAULT_RF_ENABLED_STATE                         TRUE
#define RF_DEFAULT_ACAS_ENABLED_STATE                       FALSE


// General Metabase properties (ASAI, etal)

// port for the ACS Admin site
#define MD_ASAI_ADMIN_PORT                                  (ASAI_BASE_PROP + 0)

// used for storing modified date/time stamp.  This is store as a
// Value - VT_DATE in intel, i386 byte order
// Format = BINARY_METADATA
#define MD_ASAI_DATE                                        (ASAI_BASE_PROP + 1)

// Name string (e.g., applications, projects, etc).
// Format = STRING_METADATA
#define MD_ASAI_NAME                                        (ASAI_BASE_PROP + 2)

// Description string (e.g., applications, projects, etc).
// Format = STRING_METADATA
#define MD_ASAI_DESCRIPTION                                 (ASAI_BASE_PROP + 3)

// Guid string (e.g., applications, projects, deployments etc) - used for ObjectId persistence
// where the value is a guid.  This will be the same value as the node
// name for applications, projects, and deployments
// Format = STRING_METADATA
#define MD_ASAI_GUID                                        (ASAI_BASE_PROP + 4)

// bool System attribute - used for Applications, Projects, Deployments, etc)
// Value = 0 (default) or 1
// Format = DWORD_METADATA
#define MD_ASAI_SYSTEM                                      (ASAI_BASE_PROP + 5)

// bool Hidden attribute - used for Applications, Projects, Deployments, etc)
// stored as 0,1 value using DWORD_METADATA
// Value = 0 (default) or 1
// Format = DWORD_METADATA
#define MD_ASAI_HIDDEN                                      (ASAI_BASE_PROP + 6)

// collection of strings resoruce URNs
// Format = MULTISZ_METADATA
#define MD_ASAI_RESOURCES                                   (ASAI_BASE_PROP + 7)

// flag set after applications are generated for each IIS Site
// Format = DWORD_METADATA
// Value 1 = initialized, 0 or not set = uninitialized
#define MD_ASAI_INITIALIZED                                 (ASAI_BASE_PROP + 8)

// flag set to indicate a metabase node should not be deleted
// Format = DWORD_METADATA
// Value 0 or unitialized = allow delete, non-zero = don't allow delete
#define MD_ASAI_PREVENTDELETE                               (ASAI_BASE_PROP + 9)

// path to content for AppCenter Admin site - set by install and used by ASAI to create
// the site at RegServer time. This will be used by the ASAI to recreate the Admin
// site
// Format = STRING_METADATA
// Value = Local drive path
#define MD_ASAI_WEB_PATH                                    (ASAI_BASE_PROP + 10)

// list of application guids.
// (e.g., used by the deploy object for storing applications to deploy)
// Format = MULTISZ_METADATA
// Value = 0 or more Application guids
#define MD_ASAI_APPLICATIONS                                (ASAI_BASE_PROP + 11)

// list of zero or more server names/ip addresses
// (e.g., used by the Deploy object for storing the target server list)
// Format = MULTISZ_METADATA
// Value = zero or more computernames (or ipaddresses)
#define MD_ASAI_SERVERS                                     (ASAI_BASE_PROP + 12)

// flag to indicate a deployment object should be 'persisted'.  Set to zero
// to cause a deployment object node to be automatically garbage collected.
// Format = DWORD_METADATA
// Value = 0 or 1
#define MD_ASAI_PERSIST                                     (ASAI_BASE_PROP + 13)

// value is a DWORD indicating the site number for the AppCenterAdmin site.
// This value is set under /LM/AppCenter at site creation time.
// It is used later to verify that the site still exists.
// Format = DWORD_METADATA
// Value = site number
#define MD_ASAI_SITENUMBER                                  (ASAI_BASE_PROP + 14)

// username for admin account created by the ASAI.  Stored under /LM/AppCenter/Server
// Format = STRING_METADATA
// Value = string
// Attributes: METADATA_SECURE
#define MD_ASAI_ACCOUNTNAME                                 (ASAI_BASE_PROP + 15)

// password for admin account created by the ASAI.  Stored under /LM/AppCenter/Server
// Format = STRING_METADATA
// Value = string
// Attributes: METADATA_SECURE
#define MD_ASAI_PASSWORD                                    (ASAI_BASE_PROP + 16)

// deployment object bool values.
// Attributes: METADATA_NO_ATTRIBUTE
// Format: DWORD_METADATA
// Value: 0 or 1
#define MD_ASAI_REPLICATEACLS                               (ASAI_BASE_PROP + 17)
#define MD_ASAI_TRANSLATEACLS                               (ASAI_BASE_PROP + 18)

// Guid string for storing a deployment object's related replication definition
// Format = STRING_METADATA
// Attributes: METADATA_NO_ATTRIBUTE
#define MD_ASAI_REPLICATIONDEF                              (ASAI_BASE_PROP + 19)

// Guid string for storing a deployment object's related replication job
// Format = STRING_METADATA
// Attributes: METADATA_NO_ATTRIBUTE
#define MD_ASAI_REPLICATIONJOB                              (ASAI_BASE_PROP + 20)

// deployment object
// Attributes: METADATA_NO_ATTRIBUTE
// Format: DWORD_METADATA
// Value: 0 or 1
#define MD_ASAI_DEPLOYALL                                   (ASAI_BASE_PROP + 21)

// deployment object
// Attributes: METADATA_NO_ATTRIBUTE
// Format: DWORD_METADATA
// Value: 0 or 1
#define MD_ASAI_STAGE                                       (ASAI_BASE_PROP + 22)

// deployment object
// Attributes: METADATA_NO_ATTRIBUTE
// Format: DWORD_METADATA
// Value: 0 or 1
#define MD_ASAI_AUTOSCHEDULE                                (ASAI_BASE_PROP + 23)

// deployment object - include complus resources in the deployment
// Attributes: METADATA_NO_ATTRIBUTE
// Format: DWORD_METADATA
// Value: 0 or 1
// Default: 0
#define MD_ASAI_DEPLOYCOMPLUS                               (ASAI_BASE_PROP + 24)

// deployment object - only include complus resources in the deployment
// Attributes: METADATA_NO_ATTRIBUTE
// Format: DWORD_METADATA
// Value: 0 or 1
// Default: 0
#define MD_ASAI_DEPLOYONLYCOMPLUS                           (ASAI_BASE_PROP + 25)

// deployment object - last time the replicaton job was manually started
// Attributes: METADATA_NO_ATTRIBUTE
// Value - VT_DATE in intel, i386 byte order
// Format - BINARY_METADATA
// Default - 0
#define MD_ASAI_LASTDEPLOYED                                (ASAI_BASE_PROP + 26)

// used for storing create date/time stamp.
// Value - VT_DATE in intel, i386 byte order
// Format = BINARY_METADATA
#define MD_ASAI_CREATED                                     (ASAI_BASE_PROP + 27)

// used for storing the deployment type
// Format: DWORD_METADATA
// Value: 0:custom, 1:cluster, 2:member, 3:application
// Default: 0
#define MD_ASAI_DEPLOYTYPE                                  (ASAI_BASE_PROP + 28)

// owner of this node - e.g., for deployment - cluster guid or server guid or NULL
// Format = STRING_METADATA
// Value = Owner id
#define MD_ASAI_OWNER                                       (ASAI_BASE_PROP + 29)

// CLB mode of the cluster
// loc: /LM/AppCenter/Cluster
// Format: DWORD_METADATA
// Value: 0 : No CLB, 1 : COM+ cluster, 2 : DCOM routing cluster
#define MD_ASAI_CLBMODE                                     (ASAI_BASE_PROP + 30)

// dantra - 03/26/2000
// Temporary deployment timeout (in minutes)
// How long temporary deployments should be kept around without activity.
// Stored under /LM/AppCenter/Deployments
// Format: DWORD_METADATA
// Value: Minutes
#define MD_ASAI_DEPLOYLATENCY                               (ASAI_BASE_PROP + 31)

// dantra: 03/28/00
// Idle processing timeout (minutes)
// Idle time between deployment object garbage collection
// Stored under /LM/AppCenter/Deployments
// Format: DWORD_METADATA
// Value: Minutes
#define MD_ASAI_DEPLOYCLEANUPTIMEOUT                        (ASAI_BASE_PROP + 32)

// jrowlett: 04/10/2000
// default drain time (minutes)
// Stored under /LM/AppCenter/Cluster
// Format: DWORD_METADATA
// Value: Minutes
#define MD_ASAI_DEFAULTDRAINTIME                            (ASAI_BASE_PROP + 33)

// jrowlett: 04/27/2000
// flag to replicate ACLs by default (1 - on, 0 - off)
// Stored under /LM/AppCenter/Cluster
// Format: DWORD_METADATA
// Value: 0 - do not replicate ACLs by default, 1 - Replicate ACLs by default
#define MD_ASAI_CLUSTERREPLICATEACLS                        (ASAI_BASE_PROP + 34)

// dantra: 12/08/00 - added
// flag to enable/disable replication of IPBinding for 3rd party load balancing
// Stored under /LM/AppCenter
// Format: DWORD_METADATA
// Value: 0 - do not replicate IPBindings, 1 - replicate IP Bindings
#define MD_ASAI_REPLICATEIPBINDINGS                         (ASAI_BASE_PROP + 35)

//
// Default values for published ASAI properties
//

// jrowlett: 04/10/2000
// default for MD_ASAI_DEFAULTDRAINTIME
#define MD_ASAI_DEFAULT_DEFAULTDRAINTIME                    20
// jrowlett: 04/27/2000
// default for MD_ASAI_REPLICATEACLS
#define MD_ASAI_DEFAULT_CLUSTERREPLICATEACLS                1

//ACCOUNTS_BASE_PROP local account and group

#define MD_ACCOUNTS_LOCAL_ACNT_NAME                     (ACCOUNTS_BASE_PROP +  0)
#define MD_ACCOUNTS_LOCAL_ACNT_PASSWORD                 (ACCOUNTS_BASE_PROP +  1)
#define MD_ACCOUNTS_ADMIN_GROUP                         (ACCOUNTS_BASE_PROP +  2)



#endif // _ACSMB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\extclustercmd.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* at Thu May 03 10:59:31 2001
 */
/* Compiler settings for .\extclustercmd.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __extclustercmd_h__
#define __extclustercmd_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IExtensibleClusterCmd_FWD_DEFINED__
#define __IExtensibleClusterCmd_FWD_DEFINED__
typedef interface IExtensibleClusterCmd IExtensibleClusterCmd;
#endif 	/* __IExtensibleClusterCmd_FWD_DEFINED__ */


#ifndef __ExtensibleClusterCmd_FWD_DEFINED__
#define __ExtensibleClusterCmd_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExtensibleClusterCmd ExtensibleClusterCmd;
#else
typedef struct ExtensibleClusterCmd ExtensibleClusterCmd;
#endif /* __cplusplus */

#endif 	/* __ExtensibleClusterCmd_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_extclustercmd_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation
                                                                                
Module Name: clustercmd.h
                                                                                
    Extensible Web Cluster Command Interfaces
                                                                                
--*/
#ifndef _EXTCLUSTERCMD_H_
#define _EXTCLUSTERCMD_H_
DEFINE_GUID(IID_IExtensibleClusterCmd, 0x1637e570, 0xfc42, 0x11d2, 0xbc, 0x1c, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
DEFINE_GUID(CLSID_ExtensibleClusterCmd, 0x677c4d2a, 0xfc42, 0x11d2, 0xbc, 0x1c, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
DEFINE_GUID(LIBID_EXTCLUSTERCMDLib, 0xad3dda5e, 0xfc42, 0x11d2, 0xbc, 0x1c, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);


extern RPC_IF_HANDLE __MIDL_itf_extclustercmd_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_extclustercmd_0000_v0_0_s_ifspec;

#ifndef __IExtensibleClusterCmd_INTERFACE_DEFINED__
#define __IExtensibleClusterCmd_INTERFACE_DEFINED__

/* interface IExtensibleClusterCmd */
/* [unique][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IExtensibleClusterCmd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1637E570-FC42-11d2-BC1C-00C04F72D7BE")
    IExtensibleClusterCmd : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ LONG lCompletionFlags,
            /* [in] */ BSTR bstrCLSID,
            /* [in] */ BSTR bstrEventServer,
            /* [in] */ BSTR bstrEventGuid,
            /* [in] */ BSTR bstrInput,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrPwd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtensibleClusterCmdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExtensibleClusterCmd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExtensibleClusterCmd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExtensibleClusterCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IExtensibleClusterCmd * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IExtensibleClusterCmd * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IExtensibleClusterCmd * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IExtensibleClusterCmd * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IExtensibleClusterCmd * This,
            /* [in] */ LONG lCompletionFlags,
            /* [in] */ BSTR bstrCLSID,
            /* [in] */ BSTR bstrEventServer,
            /* [in] */ BSTR bstrEventGuid,
            /* [in] */ BSTR bstrInput,
            /* [in] */ BSTR bstrUser,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrPwd);
        
        END_INTERFACE
    } IExtensibleClusterCmdVtbl;

    interface IExtensibleClusterCmd
    {
        CONST_VTBL struct IExtensibleClusterCmdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtensibleClusterCmd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtensibleClusterCmd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtensibleClusterCmd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtensibleClusterCmd_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExtensibleClusterCmd_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExtensibleClusterCmd_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExtensibleClusterCmd_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExtensibleClusterCmd_Execute(This,lCompletionFlags,bstrCLSID,bstrEventServer,bstrEventGuid,bstrInput,bstrUser,bstrDomain,bstrPwd)	\
    (This)->lpVtbl -> Execute(This,lCompletionFlags,bstrCLSID,bstrEventServer,bstrEventGuid,bstrInput,bstrUser,bstrDomain,bstrPwd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IExtensibleClusterCmd_Execute_Proxy( 
    IExtensibleClusterCmd * This,
    /* [in] */ LONG lCompletionFlags,
    /* [in] */ BSTR bstrCLSID,
    /* [in] */ BSTR bstrEventServer,
    /* [in] */ BSTR bstrEventGuid,
    /* [in] */ BSTR bstrInput,
    /* [in] */ BSTR bstrUser,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IExtensibleClusterCmd_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtensibleClusterCmd_INTERFACE_DEFINED__ */



#ifndef __EXTCLUSTERCMDLib_LIBRARY_DEFINED__
#define __EXTCLUSTERCMDLib_LIBRARY_DEFINED__

/* library EXTCLUSTERCMDLib */
/* [helpstring][hidden][version][uuid] */ 


EXTERN_C const IID LIBID_EXTCLUSTERCMDLib;

EXTERN_C const CLSID CLSID_ExtensibleClusterCmd;

#ifdef __cplusplus

class DECLSPEC_UUID("677C4D2A-FC42-11d2-BC1C-00C04F72D7BE")
ExtensibleClusterCmd;
#endif
#endif /* __EXTCLUSTERCMDLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_extclustercmd_0250 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_extclustercmd_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_extclustercmd_0250_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\cpppragmas.h ===
#ifndef _CppPragmas_H_

#define  _CppPragmas_H_
#define WARNING_STATE disable

#else

#undef WARNING_STATE
#define WARNING_STATE default
#undef _CppPragmas_H_

#endif

/*----------------------------------------------------------------
 warnings disabled for windows sdk files
----------------------------------------------------------------*/
#pragma warning(WARNING_STATE:4201)	// nonstandard extension used : zero-sized array in struct/union
#pragma warning(WARNING_STATE:4100)	//'identifier' : unreferenced formal parameter
// <comdef.h> paragmas
#pragma warning(WARNING_STATE:4310) // cast truncates constant value
#pragma warning(WARNING_STATE:4244) // conversion from 'int' to 'unsigned short', possible loss of data
#pragma warning(WARNING_STATE:4510) // '__unnamed' : default constructor could not be generated
#pragma warning(WARNING_STATE:4610) // union '__unnamed' can never be instantiated - user defined constructor required
/*----------------------------------------------------------------
 Pragma's that are disabled globally
----------------------------------------------------------------*/
#pragma warning (disable:4514)		// unreferenced inline/local function has been removed
#pragma warning (disable:4505)		// 'function' : unreferenced local function has been removed
#pragma warning (disable:4290)		// C++ Exception Specification ignored


#undef WARNING_STATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\iadm.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    iadm.h

    Defunct file.
    All clients should use iadmw.h.
*/
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\webclussvc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* at Thu May 03 10:59:36 2001
 */
/* Compiler settings for .\webclussvc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __webclussvc_h__
#define __webclussvc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWebCluster_FWD_DEFINED__
#define __IWebCluster_FWD_DEFINED__
typedef interface IWebCluster IWebCluster;
#endif 	/* __IWebCluster_FWD_DEFINED__ */


#ifndef __IAsyncWebCluster_FWD_DEFINED__
#define __IAsyncWebCluster_FWD_DEFINED__
typedef interface IAsyncWebCluster IAsyncWebCluster;
#endif 	/* __IAsyncWebCluster_FWD_DEFINED__ */


#ifndef __IWebPartition_FWD_DEFINED__
#define __IWebPartition_FWD_DEFINED__
typedef interface IWebPartition IWebPartition;
#endif 	/* __IWebPartition_FWD_DEFINED__ */


#ifndef __IWebClusterCmd_FWD_DEFINED__
#define __IWebClusterCmd_FWD_DEFINED__
typedef interface IWebClusterCmd IWebClusterCmd;
#endif 	/* __IWebClusterCmd_FWD_DEFINED__ */


#ifndef __ILocalClusterInterface_FWD_DEFINED__
#define __ILocalClusterInterface_FWD_DEFINED__
typedef interface ILocalClusterInterface ILocalClusterInterface;
#endif 	/* __ILocalClusterInterface_FWD_DEFINED__ */


#ifndef __WebCluster_FWD_DEFINED__
#define __WebCluster_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebCluster WebCluster;
#else
typedef struct WebCluster WebCluster;
#endif /* __cplusplus */

#endif 	/* __WebCluster_FWD_DEFINED__ */


#ifndef __WebPartition_FWD_DEFINED__
#define __WebPartition_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebPartition WebPartition;
#else
typedef struct WebPartition WebPartition;
#endif /* __cplusplus */

#endif 	/* __WebPartition_FWD_DEFINED__ */


#ifndef __WebClusterCmd_FWD_DEFINED__
#define __WebClusterCmd_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebClusterCmd WebClusterCmd;
#else
typedef struct WebClusterCmd WebClusterCmd;
#endif /* __cplusplus */

#endif 	/* __WebClusterCmd_FWD_DEFINED__ */


#ifndef __LocalClusterInterface_FWD_DEFINED__
#define __LocalClusterInterface_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalClusterInterface LocalClusterInterface;
#else
typedef struct LocalClusterInterface LocalClusterInterface;
#endif /* __cplusplus */

#endif 	/* __LocalClusterInterface_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_webclussvc_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation
                                                                                
Module Name: webclussvc.h
                                                                                
    Web Cluster Interfaces
                                                                                
--*/
#ifndef _WEBCLUSSVC_H_
#define _WEBCLUSSVC_H_






//
// CLSIDs
//
//{812A96C6-B9F5-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(CLSID_WebCluster,0x812A96C6,0xB9F5,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
//{DED36CCF-3384-4e8d-A2C3-4B572CA01DA1}
DEFINE_GUID(CLSID_AsyncWebCluster, 0xded36ccf, 0x3384, 0x4e8d, 0xa2, 0xc3, 0x4b, 0x57, 0x2c, 0xa0, 0x1d, 0xa1);
//{9FD00EAA-B9F8-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(CLSID_WebPartition,0x9FD00EAA,0xB9F8,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
//{29122FFE-B9F9-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(CLSID_WebClusterCmd,0x29122FFE,0xB9F9,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
//{c7de3a43-17a4-4998-bb5c-da469ca28074}
DEFINE_GUID(CLSID_LocalClusterInterface, 0xc7de3a43, 0x17a4, 0x4998, 0xbb, 0x5c, 0xda, 0x46, 0x9c, 0xa2, 0x80, 0x74);


//
// IIDs
//
//{157A3FA8-B9F5-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(IID_IWebCluster,0x157A3FA8,0xB9F5,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
//{2A69813B-7DDC-4351-8F51-CA9789238431}
DEFINE_GUID(IID_IAsyncWebCluster, 0x2a69813b, 0x7ddc, 0x4351, 0x8f, 0x51, 0xca, 0x97, 0x89, 0x23, 0x84, 0x31);
//{96AF8E22-B9F8-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(IID_IWebPartition,0x96AF8E22,0xB9F8,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
//{21B6AE42-B9F9-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(IID_IWebClusterCmd, 0x21B6AE42,0xB9F9,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
//{fb9a59f1-bbd4-419d-b177-215965c2c99b}
DEFINE_GUID(IID_ILocalClusterInterface,0xfb9a59f1, 0xbbd4, 0x419d, 0xb1, 0x77, 0x21, 0x59, 0x65, 0xc2, 0xc9, 0x9b);


//
// LIBID
//
//{E05615A8-B9F4-11D2-BC09-00C04F72D7BE}
DEFINE_GUID(LIBID_WEBCLUSSVCLib, 0xE05615A8,0xB9F4,0x11D2,0xBC,0x09,0x00,0xC0,0x4F,0x72,0xD7,0xBE);


//
// Flags for server addition 
//
#define IWCF_SERVER_INITIALLY_NOT_IN_LB                       0x1
#define IWCF_SERVER_INITIALLY_NOT_IN_REPL                     0x2

//
// Flags for controller change
//
#define IWCF_CONTROLLER_CHANGE_DO_REPL                        0x1
#define IWCF_CONTROLLER_CHANGE_WAIT_FOR_REPL_COMPLETION       0x2

//
// Flags indicating online/offline state 
//
#define ACS_LB_STATE_OFFLINE                                  0x0
#define ACS_LB_STATE_ONLINE                                   0x1
#define ACS_LB_STATE_DRAINING                                 0x2
#define ACS_LB_STATE_UNKNOWN                                  0xFFFFFFFF

// Flags for how to indicate execution completion 
//
#define ACS_COMPLETION_FLAG_MB                                0x1
#define ACS_COMPLETION_FLAG_WMI_EVENT                         0x2
#define ACS_COMPLETION_FLAG_CLUSSVC                           0x4





extern RPC_IF_HANDLE __MIDL_itf_webclussvc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webclussvc_0000_v0_0_s_ifspec;

#ifndef __IWebCluster_INTERFACE_DEFINED__
#define __IWebCluster_INTERFACE_DEFINED__

/* interface IWebCluster */
/* [unique][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IWebCluster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("157A3FA8-B9F5-11D2-BC09-00C04F72D7BE")
    IWebCluster : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAsync( 
            /* [retval][out] */ IAsyncWebCluster **ppIAsyncWebCluster) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartition( 
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ IWebPartition **ppIWebPartition) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetServerList( 
            /* [retval][out] */ VARIANT *pvarServerList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionList( 
            /* [retval][out] */ VARIANT *pvarPartitionList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetClusterController( 
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebClusterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebCluster * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebCluster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebCluster * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWebCluster * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWebCluster * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWebCluster * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWebCluster * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAsync )( 
            IWebCluster * This,
            /* [retval][out] */ IAsyncWebCluster **ppIAsyncWebCluster);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartition )( 
            IWebCluster * This,
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ IWebPartition **ppIWebPartition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetServerList )( 
            IWebCluster * This,
            /* [retval][out] */ VARIANT *pvarServerList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionList )( 
            IWebCluster * This,
            /* [retval][out] */ VARIANT *pvarPartitionList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetClusterController )( 
            IWebCluster * This,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IWebClusterVtbl;

    interface IWebCluster
    {
        CONST_VTBL struct IWebClusterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebCluster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebCluster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebCluster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebCluster_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebCluster_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebCluster_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebCluster_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebCluster_GetAsync(This,ppIAsyncWebCluster)	\
    (This)->lpVtbl -> GetAsync(This,ppIAsyncWebCluster)

#define IWebCluster_GetPartition(This,bstrGUID,ppIWebPartition)	\
    (This)->lpVtbl -> GetPartition(This,bstrGUID,ppIWebPartition)

#define IWebCluster_GetServerList(This,pvarServerList)	\
    (This)->lpVtbl -> GetServerList(This,pvarServerList)

#define IWebCluster_GetPartitionList(This,pvarPartitionList)	\
    (This)->lpVtbl -> GetPartitionList(This,pvarPartitionList)

#define IWebCluster_SetClusterController(This,lFlags)	\
    (This)->lpVtbl -> SetClusterController(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebCluster_GetAsync_Proxy( 
    IWebCluster * This,
    /* [retval][out] */ IAsyncWebCluster **ppIAsyncWebCluster);


void __RPC_STUB IWebCluster_GetAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebCluster_GetPartition_Proxy( 
    IWebCluster * This,
    /* [in] */ BSTR bstrGUID,
    /* [retval][out] */ IWebPartition **ppIWebPartition);


void __RPC_STUB IWebCluster_GetPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebCluster_GetServerList_Proxy( 
    IWebCluster * This,
    /* [retval][out] */ VARIANT *pvarServerList);


void __RPC_STUB IWebCluster_GetServerList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebCluster_GetPartitionList_Proxy( 
    IWebCluster * This,
    /* [retval][out] */ VARIANT *pvarPartitionList);


void __RPC_STUB IWebCluster_GetPartitionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebCluster_SetClusterController_Proxy( 
    IWebCluster * This,
    /* [in] */ LONG lFlags);


void __RPC_STUB IWebCluster_SetClusterController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebCluster_INTERFACE_DEFINED__ */


#ifndef __IAsyncWebCluster_INTERFACE_DEFINED__
#define __IAsyncWebCluster_INTERFACE_DEFINED__

/* interface IAsyncWebCluster */
/* [unique][hidden][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAsyncWebCluster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A69813B-7DDC-4351-8F51-CA9789238431")
    IAsyncWebCluster : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LONG lCompletionFlags,
            /* [in] */ BSTR bstrEventServer,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrPwd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePartition( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrName,
            /* [defaultvalue][in] */ BSTR bstrDescription = L"") = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeletePartition( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrGUID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteAction( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrAction,
            /* [in] */ LONG lTimeoutInSecs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddServer( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrDedicatedIP,
            /* [in] */ BSTR bstrSubnetMask,
            /* [in] */ BSTR bstrLBNetCards,
            /* [in] */ BSTR bstrBackEndNetCards,
            /* [in] */ BSTR bstrAdminAcct,
            /* [in] */ BSTR bstrAdminPwd,
            /* [defaultvalue][in] */ BSTR bstrDomain = L"",
            /* [defaultvalue][in] */ LONG lFlags = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveServer( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrAdminAcct,
            /* [in] */ BSTR bstrAdminPwd,
            /* [defaultvalue][in] */ BSTR bstrDomain = L"",
            /* [defaultvalue][in] */ LONG lFlags = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetParameter( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrParamInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetParameter( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrParamInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetClusterController( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrNewController,
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOnlineStatus( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ VARIANT_BOOL fOnline,
            /* [in] */ VARIANT varServers,
            /* [defaultvalue][in] */ VARIANT_BOOL fDrainSessions = 0,
            /* [defaultvalue][in] */ LONG lDrainTime = 60) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncWebClusterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncWebCluster * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncWebCluster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncWebCluster * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAsyncWebCluster * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAsyncWebCluster * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAsyncWebCluster * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAsyncWebCluster * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAsyncWebCluster * This,
            /* [in] */ LONG lCompletionFlags,
            /* [in] */ BSTR bstrEventServer,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrPwd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePartition )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrName,
            /* [defaultvalue][in] */ BSTR bstrDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeletePartition )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrGUID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteAction )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrAction,
            /* [in] */ LONG lTimeoutInSecs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddServer )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrDedicatedIP,
            /* [in] */ BSTR bstrSubnetMask,
            /* [in] */ BSTR bstrLBNetCards,
            /* [in] */ BSTR bstrBackEndNetCards,
            /* [in] */ BSTR bstrAdminAcct,
            /* [in] */ BSTR bstrAdminPwd,
            /* [defaultvalue][in] */ BSTR bstrDomain,
            /* [defaultvalue][in] */ LONG lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveServer )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrAdminAcct,
            /* [in] */ BSTR bstrAdminPwd,
            /* [defaultvalue][in] */ BSTR bstrDomain,
            /* [defaultvalue][in] */ LONG lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetParameter )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrParamInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetParameter )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrParamInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetClusterController )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ BSTR bstrNewController,
            /* [in] */ LONG lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOnlineStatus )( 
            IAsyncWebCluster * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ VARIANT_BOOL fOnline,
            /* [in] */ VARIANT varServers,
            /* [defaultvalue][in] */ VARIANT_BOOL fDrainSessions,
            /* [defaultvalue][in] */ LONG lDrainTime);
        
        END_INTERFACE
    } IAsyncWebClusterVtbl;

    interface IAsyncWebCluster
    {
        CONST_VTBL struct IAsyncWebClusterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncWebCluster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncWebCluster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncWebCluster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncWebCluster_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAsyncWebCluster_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAsyncWebCluster_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAsyncWebCluster_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAsyncWebCluster_Initialize(This,lCompletionFlags,bstrEventServer,bstrUserName,bstrDomain,bstrPwd)	\
    (This)->lpVtbl -> Initialize(This,lCompletionFlags,bstrEventServer,bstrUserName,bstrDomain,bstrPwd)

#define IAsyncWebCluster_CreatePartition(This,bstrCompletionGuid,bstrName,bstrDescription)	\
    (This)->lpVtbl -> CreatePartition(This,bstrCompletionGuid,bstrName,bstrDescription)

#define IAsyncWebCluster_DeletePartition(This,bstrCompletionGuid,bstrGUID)	\
    (This)->lpVtbl -> DeletePartition(This,bstrCompletionGuid,bstrGUID)

#define IAsyncWebCluster_ExecuteAction(This,bstrCompletionGuid,bstrAction,lTimeoutInSecs)	\
    (This)->lpVtbl -> ExecuteAction(This,bstrCompletionGuid,bstrAction,lTimeoutInSecs)

#define IAsyncWebCluster_AddServer(This,bstrCompletionGuid,bstrServer,bstrDedicatedIP,bstrSubnetMask,bstrLBNetCards,bstrBackEndNetCards,bstrAdminAcct,bstrAdminPwd,bstrDomain,lFlags)	\
    (This)->lpVtbl -> AddServer(This,bstrCompletionGuid,bstrServer,bstrDedicatedIP,bstrSubnetMask,bstrLBNetCards,bstrBackEndNetCards,bstrAdminAcct,bstrAdminPwd,bstrDomain,lFlags)

#define IAsyncWebCluster_RemoveServer(This,bstrCompletionGuid,bstrServer,bstrAdminAcct,bstrAdminPwd,bstrDomain,lFlags)	\
    (This)->lpVtbl -> RemoveServer(This,bstrCompletionGuid,bstrServer,bstrAdminAcct,bstrAdminPwd,bstrDomain,lFlags)

#define IAsyncWebCluster_SetParameter(This,bstrCompletionGuid,bstrParamInfo)	\
    (This)->lpVtbl -> SetParameter(This,bstrCompletionGuid,bstrParamInfo)

#define IAsyncWebCluster_GetParameter(This,bstrCompletionGuid,bstrParamInfo)	\
    (This)->lpVtbl -> GetParameter(This,bstrCompletionGuid,bstrParamInfo)

#define IAsyncWebCluster_SetClusterController(This,bstrCompletionGuid,bstrNewController,lFlags)	\
    (This)->lpVtbl -> SetClusterController(This,bstrCompletionGuid,bstrNewController,lFlags)

#define IAsyncWebCluster_SetOnlineStatus(This,bstrCompletionGuid,fOnline,varServers,fDrainSessions,lDrainTime)	\
    (This)->lpVtbl -> SetOnlineStatus(This,bstrCompletionGuid,fOnline,varServers,fDrainSessions,lDrainTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_Initialize_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ LONG lCompletionFlags,
    /* [in] */ BSTR bstrEventServer,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IAsyncWebCluster_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_CreatePartition_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrName,
    /* [defaultvalue][in] */ BSTR bstrDescription);


void __RPC_STUB IAsyncWebCluster_CreatePartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_DeletePartition_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrGUID);


void __RPC_STUB IAsyncWebCluster_DeletePartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_ExecuteAction_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrAction,
    /* [in] */ LONG lTimeoutInSecs);


void __RPC_STUB IAsyncWebCluster_ExecuteAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_AddServer_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrDedicatedIP,
    /* [in] */ BSTR bstrSubnetMask,
    /* [in] */ BSTR bstrLBNetCards,
    /* [in] */ BSTR bstrBackEndNetCards,
    /* [in] */ BSTR bstrAdminAcct,
    /* [in] */ BSTR bstrAdminPwd,
    /* [defaultvalue][in] */ BSTR bstrDomain,
    /* [defaultvalue][in] */ LONG lFlags);


void __RPC_STUB IAsyncWebCluster_AddServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_RemoveServer_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrAdminAcct,
    /* [in] */ BSTR bstrAdminPwd,
    /* [defaultvalue][in] */ BSTR bstrDomain,
    /* [defaultvalue][in] */ LONG lFlags);


void __RPC_STUB IAsyncWebCluster_RemoveServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_SetParameter_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrParamInfo);


void __RPC_STUB IAsyncWebCluster_SetParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_GetParameter_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrParamInfo);


void __RPC_STUB IAsyncWebCluster_GetParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_SetClusterController_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ BSTR bstrNewController,
    /* [in] */ LONG lFlags);


void __RPC_STUB IAsyncWebCluster_SetClusterController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAsyncWebCluster_SetOnlineStatus_Proxy( 
    IAsyncWebCluster * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ VARIANT_BOOL fOnline,
    /* [in] */ VARIANT varServers,
    /* [defaultvalue][in] */ VARIANT_BOOL fDrainSessions,
    /* [defaultvalue][in] */ LONG lDrainTime);


void __RPC_STUB IAsyncWebCluster_SetOnlineStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAsyncWebCluster_INTERFACE_DEFINED__ */


#ifndef __IWebPartition_INTERFACE_DEFINED__
#define __IWebPartition_INTERFACE_DEFINED__

/* interface IWebPartition */
/* [unique][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IWebPartition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96AF8E22-B9F8-11D2-BC09-00C04F72D7BE")
    IWebPartition : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddServer( 
            /* [in] */ BSTR bstrServer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveServer( 
            /* [in] */ BSTR bstrServer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPartitionMaster( 
            /* [in] */ BSTR bstrMaster) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionMaster( 
            /* [retval][out] */ BSTR *pbstrMaster) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteAction( 
            /* [in] */ BSTR bstrAction,
            /* [in] */ LONG lTimeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetParameter( 
            /* [in] */ BSTR bstrParamInfo,
            /* [retval][out] */ VARIANT *pvarParam) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetParameter( 
            /* [in] */ BSTR bstrParam) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetServerList( 
            /* [retval][out] */ VARIANT *pvarServerList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOnlineStatus( 
            /* [in] */ VARIANT_BOOL fOnline,
            /* [in] */ VARIANT varServers,
            /* [defaultvalue][in] */ VARIANT_BOOL fDrainSessions = 0,
            /* [defaultvalue][in] */ LONG lDrainTime = 60) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebPartitionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebPartition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebPartition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebPartition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWebPartition * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWebPartition * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWebPartition * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWebPartition * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddServer )( 
            IWebPartition * This,
            /* [in] */ BSTR bstrServer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveServer )( 
            IWebPartition * This,
            /* [in] */ BSTR bstrServer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPartitionMaster )( 
            IWebPartition * This,
            /* [in] */ BSTR bstrMaster);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionMaster )( 
            IWebPartition * This,
            /* [retval][out] */ BSTR *pbstrMaster);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteAction )( 
            IWebPartition * This,
            /* [in] */ BSTR bstrAction,
            /* [in] */ LONG lTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetParameter )( 
            IWebPartition * This,
            /* [in] */ BSTR bstrParamInfo,
            /* [retval][out] */ VARIANT *pvarParam);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetParameter )( 
            IWebPartition * This,
            /* [in] */ BSTR bstrParam);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetServerList )( 
            IWebPartition * This,
            /* [retval][out] */ VARIANT *pvarServerList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOnlineStatus )( 
            IWebPartition * This,
            /* [in] */ VARIANT_BOOL fOnline,
            /* [in] */ VARIANT varServers,
            /* [defaultvalue][in] */ VARIANT_BOOL fDrainSessions,
            /* [defaultvalue][in] */ LONG lDrainTime);
        
        END_INTERFACE
    } IWebPartitionVtbl;

    interface IWebPartition
    {
        CONST_VTBL struct IWebPartitionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebPartition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebPartition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebPartition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebPartition_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebPartition_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebPartition_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebPartition_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebPartition_AddServer(This,bstrServer)	\
    (This)->lpVtbl -> AddServer(This,bstrServer)

#define IWebPartition_RemoveServer(This,bstrServer)	\
    (This)->lpVtbl -> RemoveServer(This,bstrServer)

#define IWebPartition_SetPartitionMaster(This,bstrMaster)	\
    (This)->lpVtbl -> SetPartitionMaster(This,bstrMaster)

#define IWebPartition_GetPartitionMaster(This,pbstrMaster)	\
    (This)->lpVtbl -> GetPartitionMaster(This,pbstrMaster)

#define IWebPartition_ExecuteAction(This,bstrAction,lTimeout)	\
    (This)->lpVtbl -> ExecuteAction(This,bstrAction,lTimeout)

#define IWebPartition_GetParameter(This,bstrParamInfo,pvarParam)	\
    (This)->lpVtbl -> GetParameter(This,bstrParamInfo,pvarParam)

#define IWebPartition_SetParameter(This,bstrParam)	\
    (This)->lpVtbl -> SetParameter(This,bstrParam)

#define IWebPartition_GetServerList(This,pvarServerList)	\
    (This)->lpVtbl -> GetServerList(This,pvarServerList)

#define IWebPartition_SetOnlineStatus(This,fOnline,varServers,fDrainSessions,lDrainTime)	\
    (This)->lpVtbl -> SetOnlineStatus(This,fOnline,varServers,fDrainSessions,lDrainTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_AddServer_Proxy( 
    IWebPartition * This,
    /* [in] */ BSTR bstrServer);


void __RPC_STUB IWebPartition_AddServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_RemoveServer_Proxy( 
    IWebPartition * This,
    /* [in] */ BSTR bstrServer);


void __RPC_STUB IWebPartition_RemoveServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_SetPartitionMaster_Proxy( 
    IWebPartition * This,
    /* [in] */ BSTR bstrMaster);


void __RPC_STUB IWebPartition_SetPartitionMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_GetPartitionMaster_Proxy( 
    IWebPartition * This,
    /* [retval][out] */ BSTR *pbstrMaster);


void __RPC_STUB IWebPartition_GetPartitionMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_ExecuteAction_Proxy( 
    IWebPartition * This,
    /* [in] */ BSTR bstrAction,
    /* [in] */ LONG lTimeout);


void __RPC_STUB IWebPartition_ExecuteAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_GetParameter_Proxy( 
    IWebPartition * This,
    /* [in] */ BSTR bstrParamInfo,
    /* [retval][out] */ VARIANT *pvarParam);


void __RPC_STUB IWebPartition_GetParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_SetParameter_Proxy( 
    IWebPartition * This,
    /* [in] */ BSTR bstrParam);


void __RPC_STUB IWebPartition_SetParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_GetServerList_Proxy( 
    IWebPartition * This,
    /* [retval][out] */ VARIANT *pvarServerList);


void __RPC_STUB IWebPartition_GetServerList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebPartition_SetOnlineStatus_Proxy( 
    IWebPartition * This,
    /* [in] */ VARIANT_BOOL fOnline,
    /* [in] */ VARIANT varServers,
    /* [defaultvalue][in] */ VARIANT_BOOL fDrainSessions,
    /* [defaultvalue][in] */ LONG lDrainTime);


void __RPC_STUB IWebPartition_SetOnlineStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebPartition_INTERFACE_DEFINED__ */


#ifndef __IWebClusterCmd_INTERFACE_DEFINED__
#define __IWebClusterCmd_INTERFACE_DEFINED__

/* interface IWebClusterCmd */
/* [unique][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IWebClusterCmd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21B6AE42-B9F9-11D2-BC09-00C04F72D7BE")
    IWebClusterCmd : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ LONG lCompletionFlags,
            /* [in] */ BSTR bstrInputArg,
            /* [in] */ BSTR bstrEventServer,
            /* [in] */ BSTR bstrEventGuid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Complete( 
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ LONG lOutputHres,
            /* [in] */ BSTR bstrOutputString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebClusterCmdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebClusterCmd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebClusterCmd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebClusterCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWebClusterCmd * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWebClusterCmd * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWebClusterCmd * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWebClusterCmd * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWebClusterCmd * This,
            /* [in] */ LONG lCompletionFlags,
            /* [in] */ BSTR bstrInputArg,
            /* [in] */ BSTR bstrEventServer,
            /* [in] */ BSTR bstrEventGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Complete )( 
            IWebClusterCmd * This,
            /* [in] */ BSTR bstrCompletionGuid,
            /* [in] */ LONG lOutputHres,
            /* [in] */ BSTR bstrOutputString);
        
        END_INTERFACE
    } IWebClusterCmdVtbl;

    interface IWebClusterCmd
    {
        CONST_VTBL struct IWebClusterCmdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebClusterCmd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebClusterCmd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebClusterCmd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebClusterCmd_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebClusterCmd_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebClusterCmd_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebClusterCmd_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebClusterCmd_Execute(This,lCompletionFlags,bstrInputArg,bstrEventServer,bstrEventGuid)	\
    (This)->lpVtbl -> Execute(This,lCompletionFlags,bstrInputArg,bstrEventServer,bstrEventGuid)

#define IWebClusterCmd_Complete(This,bstrCompletionGuid,lOutputHres,bstrOutputString)	\
    (This)->lpVtbl -> Complete(This,bstrCompletionGuid,lOutputHres,bstrOutputString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebClusterCmd_Execute_Proxy( 
    IWebClusterCmd * This,
    /* [in] */ LONG lCompletionFlags,
    /* [in] */ BSTR bstrInputArg,
    /* [in] */ BSTR bstrEventServer,
    /* [in] */ BSTR bstrEventGuid);


void __RPC_STUB IWebClusterCmd_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebClusterCmd_Complete_Proxy( 
    IWebClusterCmd * This,
    /* [in] */ BSTR bstrCompletionGuid,
    /* [in] */ LONG lOutputHres,
    /* [in] */ BSTR bstrOutputString);


void __RPC_STUB IWebClusterCmd_Complete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebClusterCmd_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_webclussvc_0253 */
/* [local] */ 



#define ACS_LOCAL_CFG_QUERY_CONTROLLER         L"CONTROLLERDATA" 
#define ACS_LOCAL_CFG_QUERY_LOCAL_NAME         L"LOCALNAME" 
#define ACS_LOCAL_CFG_QUERY_LOCAL_GUID         L"LOCALGUID" 
#define ACS_LOCAL_CFG_QUERY_CLUSTER_GUID       L"CLUSTERGUID" 
#define ACS_LOCAL_CFG_QUERY_LB_TYPE            L"LBTYPE" 

#define ACS_LB_FLAG_CHECK_MONITORS                  0x00000001



extern RPC_IF_HANDLE __MIDL_itf_webclussvc_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webclussvc_0253_v0_0_s_ifspec;

#ifndef __ILocalClusterInterface_INTERFACE_DEFINED__
#define __ILocalClusterInterface_INTERFACE_DEFINED__

/* interface ILocalClusterInterface */
/* [unique][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_ILocalClusterInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB9A59F1-BBD4-419D-B177-215965C2C99B")
    ILocalClusterInterface : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLocalCfg( 
            /* [in] */ BSTR bstrQuery,
            /* [in] */ BOOL fRequireCurrentConfig,
            /* [out] */ BSTR *pbstrInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOnlineStatus( 
            /* [in] */ VARIANT_BOOL fOnline,
            /* [in] */ LONG lDrainTimeInSecs,
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetOnlineStatus( 
            /* [out] */ LONG *plOnlineStatus,
            /* [defaultvalue][in] */ VARIANT_BOOL fRefresh = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMonitorStatus( 
            /* [out] */ LONG *plMonitorStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocalClusterInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILocalClusterInterface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILocalClusterInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILocalClusterInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILocalClusterInterface * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILocalClusterInterface * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILocalClusterInterface * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILocalClusterInterface * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLocalCfg )( 
            ILocalClusterInterface * This,
            /* [in] */ BSTR bstrQuery,
            /* [in] */ BOOL fRequireCurrentConfig,
            /* [out] */ BSTR *pbstrInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOnlineStatus )( 
            ILocalClusterInterface * This,
            /* [in] */ VARIANT_BOOL fOnline,
            /* [in] */ LONG lDrainTimeInSecs,
            /* [in] */ LONG lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetOnlineStatus )( 
            ILocalClusterInterface * This,
            /* [out] */ LONG *plOnlineStatus,
            /* [defaultvalue][in] */ VARIANT_BOOL fRefresh);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMonitorStatus )( 
            ILocalClusterInterface * This,
            /* [out] */ LONG *plMonitorStatus);
        
        END_INTERFACE
    } ILocalClusterInterfaceVtbl;

    interface ILocalClusterInterface
    {
        CONST_VTBL struct ILocalClusterInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocalClusterInterface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILocalClusterInterface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILocalClusterInterface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILocalClusterInterface_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILocalClusterInterface_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILocalClusterInterface_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILocalClusterInterface_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILocalClusterInterface_GetLocalCfg(This,bstrQuery,fRequireCurrentConfig,pbstrInfo)	\
    (This)->lpVtbl -> GetLocalCfg(This,bstrQuery,fRequireCurrentConfig,pbstrInfo)

#define ILocalClusterInterface_SetOnlineStatus(This,fOnline,lDrainTimeInSecs,lFlags)	\
    (This)->lpVtbl -> SetOnlineStatus(This,fOnline,lDrainTimeInSecs,lFlags)

#define ILocalClusterInterface_GetOnlineStatus(This,plOnlineStatus,fRefresh)	\
    (This)->lpVtbl -> GetOnlineStatus(This,plOnlineStatus,fRefresh)

#define ILocalClusterInterface_GetMonitorStatus(This,plMonitorStatus)	\
    (This)->lpVtbl -> GetMonitorStatus(This,plMonitorStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalClusterInterface_GetLocalCfg_Proxy( 
    ILocalClusterInterface * This,
    /* [in] */ BSTR bstrQuery,
    /* [in] */ BOOL fRequireCurrentConfig,
    /* [out] */ BSTR *pbstrInfo);


void __RPC_STUB ILocalClusterInterface_GetLocalCfg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalClusterInterface_SetOnlineStatus_Proxy( 
    ILocalClusterInterface * This,
    /* [in] */ VARIANT_BOOL fOnline,
    /* [in] */ LONG lDrainTimeInSecs,
    /* [in] */ LONG lFlags);


void __RPC_STUB ILocalClusterInterface_SetOnlineStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalClusterInterface_GetOnlineStatus_Proxy( 
    ILocalClusterInterface * This,
    /* [out] */ LONG *plOnlineStatus,
    /* [defaultvalue][in] */ VARIANT_BOOL fRefresh);


void __RPC_STUB ILocalClusterInterface_GetOnlineStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalClusterInterface_GetMonitorStatus_Proxy( 
    ILocalClusterInterface * This,
    /* [out] */ LONG *plMonitorStatus);


void __RPC_STUB ILocalClusterInterface_GetMonitorStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILocalClusterInterface_INTERFACE_DEFINED__ */



#ifndef __WEBCLUSSVCLib_LIBRARY_DEFINED__
#define __WEBCLUSSVCLib_LIBRARY_DEFINED__

/* library WEBCLUSSVCLib */
/* [helpstring][hidden][version][uuid] */ 


EXTERN_C const IID LIBID_WEBCLUSSVCLib;

EXTERN_C const CLSID CLSID_WebCluster;

#ifdef __cplusplus

class DECLSPEC_UUID("812A96C6-B9F5-11D2-BC09-00C04F72D7BE")
WebCluster;
#endif

EXTERN_C const CLSID CLSID_WebPartition;

#ifdef __cplusplus

class DECLSPEC_UUID("9FD00EAA-B9F8-11D2-BC09-00C04F72D7BE")
WebPartition;
#endif

EXTERN_C const CLSID CLSID_WebClusterCmd;

#ifdef __cplusplus

class DECLSPEC_UUID("29122FFE-B9F9-11D2-BC09-00C04F72D7BE")
WebClusterCmd;
#endif

EXTERN_C const CLSID CLSID_LocalClusterInterface;

#ifdef __cplusplus

class DECLSPEC_UUID("C7DE3A43-17A4-4998-BB5C-DA469CA28074")
LocalClusterInterface;
#endif
#endif /* __WEBCLUSSVCLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_webclussvc_0254 */
/* [local] */ 

#endif // _WEBCCLUSSVC_H_


extern RPC_IF_HANDLE __MIDL_itf_webclussvc_0254_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webclussvc_0254_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\impexp.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    impexp.h

Abstract:

    This file makes it convenient to import and export
    classes, apis or data.

    Client code which includes this header (or any header
    which includes this header should NOT have EXPORTING
    defined!)

    Add -DACS_STATIC_LIB to the C Defines in your project to link in classes
    defined in sacsrtl.lib, otherwise when you link your project it looks for
    dll imports.
    
Author:

    Jeff Miller (jeffmill)  05-Nov-99

Revision History:

    05-Feb-2001 jrowlett 
        fixup for projects linking with static version
        
--*/

#ifndef _IMPEXP_H_
#define _IMPEXP_H_

#ifdef ACS_STATIC_LIB

#   define CLASS_DECLSPEC
#   define API_DECLSPEC
#   define DATA_DECLSPEC

#else /* ACS_STATIC_LIB */

#   ifdef EXPORTING

#       define CLASS_DECLSPEC __declspec(dllexport)
#       define API_DECLSPEC   __declspec(dllexport)
#       define DATA_DECLSPEC  __declspec(dllexport)

#   else /* EXPORTING */


#       define CLASS_DECLSPEC __declspec(dllimport)
#       define API_DECLSPEC   __declspec(dllimport)
#       define DATA_DECLSPEC  __declspec(dllimport)

#   endif /* EXPORTING */

#endif /* ACS_STATIC_LIB */

#endif /* _IMPEXP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\metautil.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

      MetaUtil.h

   Abstract : 

		Simple wrapper class for local metabase access

		NOTE: All paths are fully qualified

   Author :

      Dan Travison (dantra)

   Project :

      Application Server

   Revision History:

--*/

// MetaUtil.h: interface for the CMetaUtil class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_METAUTIL_H__A2A24BF4_D3DD_4248_9B4A_BCBC1C36B8D9__INCLUDED_)
#define AFX_METAUTIL_H__A2A24BF4_D3DD_4248_9B4A_BCBC1C36B8D9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <iadmw.h>
#define IADM_PBYTE
#include <iiscnfg.h>
#include <AcBstr.h>

#include <acsmb.h>

#include "acauthutil.h"

class CMetaUtil  
	{
	public:
		CMetaUtil();
		virtual ~CMetaUtil();

//02/03/2000 jrowlett added
        // call this before calling Open to do a remote connection
        HRESULT Connect(CAcAuthUtil& auth, bool bSetInterfaceSecurity = true);
        // abeyer: 7/17/2000 - A wrapper around Open() to check if a path exists
        HRESULT Exists (LPCTSTR pszPath);
		HRESULT	Close();
        // create a fully qualified key
		HRESULT	CreateKey (LPCTSTR pszPath);
		// delete the specific key
		HRESULT	DeleteKey (LPCTSTR pszPath, LPCTSTR pszKey);

		HRESULT	Get (IN LPCTSTR pszPath, IN DWORD dwId, IN DWORD dwDataType, IN LPVOID lpData, IN DWORD dwLen, IN DWORD dwUserType = IIS_MD_UT_WEBCLUSTER, IN DWORD dwAttr = METADATA_NO_ATTRIBUTES);
		HRESULT	Get (IN LPCTSTR pszPath, IN DWORD dwId, IN DWORD dwDataType, IN LPVOID lpData, IN DWORD * pdwDataLen, IN DWORD dwUserType = IIS_MD_UT_WEBCLUSTER, IN DWORD dwAttr = METADATA_NO_ATTRIBUTES);

        // 05/02/2000 jrowlett added
        // only works with METADATA_STRING
        HRESULT Get (IN LPCTSTR pszPath, IN DWORD dwId, OUT CAcBstr& acbstr, IN DWORD dwUserType = IIS_MD_UT_WEBCLUSTER, IN DWORD dwAttr = METADATA_NO_ATTRIBUTES);

		HRESULT	Set (IN LPCTSTR pszPath, IN DWORD dwId, IN DWORD dwDataType, IN LPVOID lpData, IN DWORD dwDataLen, IN DWORD dwUserType = IIS_MD_UT_WEBCLUSTER, IN DWORD dwAttr = METADATA_NO_ATTRIBUTES);

		HRESULT	Set (IN LPCTSTR pszPath, IN DWORD dwId, IN DWORD dwData, IN DWORD dwUserType = IIS_MD_UT_WEBCLUSTER, IN DWORD dwAttr = METADATA_NO_ATTRIBUTES);
		HRESULT	Set (IN LPCTSTR pszPath, IN DWORD dwId, IN LPCTSTR pszData, IN DWORD dwUserType = IIS_MD_UT_WEBCLUSTER, IN DWORD dwAttr = METADATA_NO_ATTRIBUTES);

		// get the last modified date/time for an MB Node
		HRESULT	GetModified 
						(
						IN LPCTSTR pszPath,	// FQN path (if not open) or Relative path (if open)
						OUT DATE & date		// returned date value of LastChangeTime
						);

		// Call IWamAdmin::AppCreate
		static HRESULT	AppCreate (LPCTSTR pszPath, BOOL bInProc);

		// Call IWamAdmin::AppCreate
		static HRESULT	AppDelete (LPCTSTR pszPath, BOOL bRecursive = true);

		// metabase node enumeration

		class POSITION
			{
			protected:
				DWORD				dwIndex;
				HRESULT			hrError;
				CAcBstr			bstrPath;

			public:
				POSITION() : dwIndex(0), hrError (E_HANDLE)	{}			

			friend CMetaUtil;
			};

		HRESULT	NodeHead(IN LPCTSTR pszPath, OUT POSITION & pos);
		HRESULT	NodeNext (IN OUT CMetaUtil::POSITION &pos, OUT CAcBstr & bstrKeyName);

        bool IsOpen();

	protected:

		HRESULT	Connect ();
		HRESULT	Disconnect();
        // abeyer: 7/17/2000 Open() will be called internally by methods that need it, so it has become protected
        //  to prevent anyone outside from mucking with our relative path base.
        HRESULT	Open (DWORD dwAccess, LPCTSTR pszPath = _T(""));
        // abeyer: 7/17/2000 - CreateSubKey() moved from public to protected since it isn't usable from outside now
        //  that Open() is protected.
        // create a key relative to an open path (must have METADATA_PERMISSION_WRITE)
        HRESULT CreateSubKey (LPCTSTR pszPath);


		IMSAdminBase *		m_pMB;
		METADATA_HANDLE	    m_hMD;
		DWORD				m_dwPermissions;
		CAcBstr				m_bstrPath;

        #define METADATA_NO_HANDLE      ((METADATA_HANDLE)0xFFFFFFFF)


	private:

		// prevent copying
		CMetaUtil(const CMetaUtil&);	// note: no implemenation	
		// prevent copying
		void operator=(CMetaUtil&);	// note: no implemenation
	};

// dantra: 12/21/1999
inline bool CMetaUtil::IsOpen ()
    {
    return (m_pMB != NULL && m_hMD != METADATA_NO_HANDLE);
    }

inline HRESULT CMetaUtil::Set (IN LPCTSTR pszPath, IN DWORD dwId, IN DWORD dwData, IN DWORD dwUserType, IN DWORD dwAttr)
	{
	return Set (pszPath, dwId, DWORD_METADATA, & dwData, sizeof (DWORD), dwUserType, dwAttr);
	}

inline HRESULT CMetaUtil::Set (IN LPCTSTR pszPath, IN DWORD dwId, IN LPCTSTR pszData, IN DWORD dwUserType, IN DWORD dwAttr)
	{
	return Set 
				(
				pszPath, 
				dwId, 
				STRING_METADATA,
				(void *) pszData,
				((DWORD)_tcslen (pszData) + 1) * sizeof (TCHAR),
				dwUserType,
				dwAttr
				);
	}

#endif // !defined(AFX_METAUTIL_H__A2A24BF4_D3DD_4248_9B4A_BCBC1C36B8D9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\findmaster.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* at Thu May 03 10:59:34 2001
 */
/* Compiler settings for .\findmaster.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __findmaster_h__
#define __findmaster_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWebClusterDiscoverMaster_FWD_DEFINED__
#define __IWebClusterDiscoverMaster_FWD_DEFINED__
typedef interface IWebClusterDiscoverMaster IWebClusterDiscoverMaster;
#endif 	/* __IWebClusterDiscoverMaster_FWD_DEFINED__ */


#ifndef __DiscoverMaster_FWD_DEFINED__
#define __DiscoverMaster_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiscoverMaster DiscoverMaster;
#else
typedef struct DiscoverMaster DiscoverMaster;
#endif /* __cplusplus */

#endif 	/* __DiscoverMaster_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_findmaster_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation
                                                                                
Module Name: findmaster.h
                                                                                
    Web Cluster Master Discovery Interfaces
                                                                                
--*/
#ifndef _FINDMASTER_H_
#define _FINDMASTER_H_
DEFINE_GUID(IID_IWebClusterDiscoverMaster,0x177250AC,0xF410,0x11D2,0xBC,0x19,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
DEFINE_GUID(LIBID_WCFINDMASTERLib,0xED4B7D84,0xF40F,0x11D2,0xBC,0x19,0x00,0xC0,0x4F,0x72,0xD7,0xBE);
DEFINE_GUID(CLSID_WebClusterDiscoverMaster,0x96BAFB7A,0xF410,0x11D2,0xBC,0x19,0x00,0xC0,0x4F,0x72,0xD7,0xBE);


extern RPC_IF_HANDLE __MIDL_itf_findmaster_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_findmaster_0000_v0_0_s_ifspec;

#ifndef __IWebClusterDiscoverMaster_INTERFACE_DEFINED__
#define __IWebClusterDiscoverMaster_INTERFACE_DEFINED__

/* interface IWebClusterDiscoverMaster */
/* [unique][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IWebClusterDiscoverMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("177250AC-F410-11D2-BC19-00C04F72D7BE")
    IWebClusterDiscoverMaster : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DiscoverClusterMaster( 
            /* [defaultvalue][in] */ LONG lRetries,
            /* [defaultvalue][in] */ LONG lInterval,
            /* [retval][out] */ BSTR *pbstrCurrentMaster) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DiscoverPartitionMaster( 
            /* [in] */ BSTR bstrGuid,
            /* [defaultvalue][in] */ LONG lRetries,
            /* [defaultvalue][in] */ LONG lInterval,
            /* [retval][out] */ BSTR *pbstrPartitionMaster) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebClusterDiscoverMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWebClusterDiscoverMaster * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWebClusterDiscoverMaster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWebClusterDiscoverMaster * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWebClusterDiscoverMaster * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWebClusterDiscoverMaster * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWebClusterDiscoverMaster * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWebClusterDiscoverMaster * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DiscoverClusterMaster )( 
            IWebClusterDiscoverMaster * This,
            /* [defaultvalue][in] */ LONG lRetries,
            /* [defaultvalue][in] */ LONG lInterval,
            /* [retval][out] */ BSTR *pbstrCurrentMaster);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DiscoverPartitionMaster )( 
            IWebClusterDiscoverMaster * This,
            /* [in] */ BSTR bstrGuid,
            /* [defaultvalue][in] */ LONG lRetries,
            /* [defaultvalue][in] */ LONG lInterval,
            /* [retval][out] */ BSTR *pbstrPartitionMaster);
        
        END_INTERFACE
    } IWebClusterDiscoverMasterVtbl;

    interface IWebClusterDiscoverMaster
    {
        CONST_VTBL struct IWebClusterDiscoverMasterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebClusterDiscoverMaster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebClusterDiscoverMaster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebClusterDiscoverMaster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebClusterDiscoverMaster_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebClusterDiscoverMaster_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebClusterDiscoverMaster_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebClusterDiscoverMaster_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebClusterDiscoverMaster_DiscoverClusterMaster(This,lRetries,lInterval,pbstrCurrentMaster)	\
    (This)->lpVtbl -> DiscoverClusterMaster(This,lRetries,lInterval,pbstrCurrentMaster)

#define IWebClusterDiscoverMaster_DiscoverPartitionMaster(This,bstrGuid,lRetries,lInterval,pbstrPartitionMaster)	\
    (This)->lpVtbl -> DiscoverPartitionMaster(This,bstrGuid,lRetries,lInterval,pbstrPartitionMaster)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebClusterDiscoverMaster_DiscoverClusterMaster_Proxy( 
    IWebClusterDiscoverMaster * This,
    /* [defaultvalue][in] */ LONG lRetries,
    /* [defaultvalue][in] */ LONG lInterval,
    /* [retval][out] */ BSTR *pbstrCurrentMaster);


void __RPC_STUB IWebClusterDiscoverMaster_DiscoverClusterMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebClusterDiscoverMaster_DiscoverPartitionMaster_Proxy( 
    IWebClusterDiscoverMaster * This,
    /* [in] */ BSTR bstrGuid,
    /* [defaultvalue][in] */ LONG lRetries,
    /* [defaultvalue][in] */ LONG lInterval,
    /* [retval][out] */ BSTR *pbstrPartitionMaster);


void __RPC_STUB IWebClusterDiscoverMaster_DiscoverPartitionMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebClusterDiscoverMaster_INTERFACE_DEFINED__ */



#ifndef __WCFINDMASTERLib_LIBRARY_DEFINED__
#define __WCFINDMASTERLib_LIBRARY_DEFINED__

/* library WCFINDMASTERLib */
/* [helpstring][hidden][version][uuid] */ 


EXTERN_C const IID LIBID_WCFINDMASTERLib;

EXTERN_C const CLSID CLSID_DiscoverMaster;

#ifdef __cplusplus

class DECLSPEC_UUID("96BAFB7A-F410-11D2-BC19-00C04F72D7BE")
DiscoverMaster;
#endif
#endif /* __WCFINDMASTERLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_findmaster_0250 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_findmaster_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_findmaster_0250_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\workerclsids.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    workerclsids.h

    Contains the CLSIDs of components implementing IClusterWork that are used to perform
    various tasks
    

    FILE HISTORY:
        AMallet     27- April-1999     Created
*/

#ifndef _WORKERCLSIDS_H_
#define _WORKERCLSIDS_H_

// 
// CLSID of object implementing IClusterWork that is used to create all cluster-related
// settings on a machine
//
// {9659314C-FCB4-11d2-BC1C-00C04F72D7BE}
//
DEFINE_GUID(CLSID_MachineSetup, 0x9659314c, 0xfcb4, 0x11d2, 0xbc, 0x1c, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
#define SZ_CLSID_MachineSetup L"9659314C-FCB4-11d2-BC1C-00C04F72D7BE"

// 
// CLSID of object implementing IClusterWork that is used to delete all cluster-related
// settings on a machine
//
// {92E6D282-FCD5-11d2-BC1C-00C04F72D7BE}
// 
DEFINE_GUID(CLSID_MachineCleanup, 0x92e6d282, 0xfcd5, 0x11d2, 0xbc, 0x1c, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
#define SZ_CLSID_MachineCleanup L"92E6D282-FCD5-11d2-BC1C-00C04F72D7BE"


//
// CLSID of object implementing IClusterWork that is used to start svcs necessary for cluster
//
// {F391E834-0314-11d3-8764-00C04F72D7BE}
// 
DEFINE_GUID(CLSID_SvcStart, 0xf391e834, 0x314, 0x11d3, 0x87, 0x64, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
#define SZ_CLSID_SvcStart L"F391E834-0314-11d3-8764-00C04F72D7BE"


//
// CLSID of object implementing IClusterWork that is used to add/remove IP addresses
//
// CLSID :{2923FABC-25CC-11d3-876B-00C04F72D7BE}
//
DEFINE_GUID(CLSID_IPMANIP, 
0x2923fabc, 0x25cc, 0x11d3, 0x87, 0x6b, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
#define SZ_CLSID_IPManip L"2923FABC-25CC-11d3-876B-00C04F72D7BE"

//
// CLSID of object implementing IClusterWork that is used to return non-NLB IP addresses
//
// CLSID : {E512C31D-3002-11d3-876C-00C04F72D7BE}
//
DEFINE_GUID(CLSID_IPRESOLVE, 
0xe512c31d, 0x3002, 0x11d3, 0x87, 0x6c, 0x0, 0xc0, 0x4f, 0x72, 0xd7, 0xbe);
#define SZ_CLSID_IPResolve L"E512C31D-3002-11d3-876C-00C04F72D7BE"


//
// CLSID of object implementing IClusterWork that is used to help with Master Discovery 
//
// {FB61E991-BFC9-4f66-9A82-5AD645471438}
//
DEFINE_GUID(CLSID_FINDMASTERHELP, 
0xfb61e991, 0xbfc9, 0x4f66, 0x9a, 0x82, 0x5a, 0xd6, 0x45, 0x47, 0x14, 0x38);
#define SZ_CLSID_FindMasterHelp L"FB61E991-BFC9-4f66-9A82-5AD645471438"

//
// CLSID of object implementing IClusterWork that is used to determine current transient
// state of a server
//
// {F1E65758-71FC-4f87-9687-0623BC6886A1}
//
DEFINE_GUID(CLSID_CHECKSTATE, 
0xf1e65758, 0x71fc, 0x4f87, 0x96, 0x87, 0x6, 0x23, 0xbc, 0x68, 0x86, 0xa1);
#define SZ_CLSID_CheckState L"F1E65758-71FC-4f87-9687-0623BC6886A1"

#endif // _WORKERCLSIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\cfgquery.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgquery.h

$Header: $

Abstract:
	Configuration Query Class

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGQUERY_H__
#define __CFGQUERY_H__

#pragma once

#include "catalog.h"
#include <atlbase.h>

class CConfigTableMeta;
class CConfigRecord;

/**************************************************************************++
Class Name:
    CConfigQuery

Class Description:
    Configuration Query Class. This is the class that interacts directly with the
	catalog, and all calls to the catalog go via this class. The class returns CConfigRecords
	which abstract the 'read-only' pointers from the catalog from the user

--*************************************************************************/
class CConfigQuery
{
public:
	CConfigQuery ();
	~CConfigQuery ();
	HRESULT   Init (LPCWSTR i_wszDatabase,
					LPCWSTR i_wszTableName,
					LPCWSTR i_wszSelector,
					ISimpleTableDispenser2 *i_pDispenser);

	HRESULT Execute (CConfigRecord *pRecord, bool i_fOnlyPKs, bool i_fWriteAccess);

	ULONG GetRowCount ();
	HRESULT GetColumnValues (ULONG i_idx, CConfigRecord& io_record);
	HRESULT GetEmptyConfigRecord (CConfigRecord& io_record);
	HRESULT GetPKRow (CConfigRecord& i_record, ULONG* o_pcRow);
	HRESULT GetRowBySearch (ULONG iStartIdx, CConfigRecord& i_record, ULONG* o_pcRow);

	HRESULT DeleteRow (ULONG i_idx);
	HRESULT UpdateRow (ULONG i_idx, CConfigRecord& i_record, long lFlags);
	HRESULT Save ();	// use for multi-row save
	HRESULT SaveSingleRow (); // use for single row save
	HRESULT GetDetailedErrorCount (ULONG *pCount);
	HRESULT GetDetailedError (ULONG idx, STErr* pErrInfo);
private:
	HRESULT GetSingleDetailedError (HRESULT * pDetailedHr);

	CComPtr<ISimpleTableDispenser2> m_spDispenser;  // table dispenser
	CComPtr<ISimpleTableWrite2> m_spWrite;			// table pointer
	bool						m_fInitialized;		// are we initialized?
	ULONG						m_cNrRows;			// number of rows in the table
	LPVOID *					m_ppvValues;		// values (perf optimization)
	CConfigTableMeta *			m_pTableMeta;		// table meta information

	LPWSTR						m_wszDatabase;
	LPWSTR						m_wszTable;
	LPWSTR						m_wszSelector;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\wmicommon.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    wmicommon.h

    Contains the declaration of the utility functions used in dealing with WMI 


    FILE HISTORY:
        AMallet     May-9-1999     Created
*/


#ifndef _WMICOMMON_H_
#define _WMICOMMON_H_

#include <wbemcli.h>

#if !defined(dllexp)
#define dllexp  __declspec(dllexport)
#endif // !defined(dllexp) 


DEFINE_GUID(IID_IWbemObjectSink, 0x7c857801, 0x7381, 0x11cf, 0x88, 0x4d, 0x00, 0xaa, 0x00, 0x4b, 
            0x2e, 0x24);

DEFINE_GUID(IID_IWbemLocator, 0xdc12a687, 0x737f, 0x11cf, 0x88, 0x4d, 0x00, 0xaa, 0x00, 0x4b, 0x2e,
            0x24);

DEFINE_GUID(CLSID_WbemLocator, 0x4590f811, 0x1d3a, 0x11d0, 0x89, 0x1f, 0x00, 0xaa, 0x00, 0x4b,
0x2e, 0x24);

DEFINE_GUID(IID_IWbemClassObject, 0xdc12a681, 0x737f, 0x11cf, 0x88,0x4d, 0x00, 0xaa, 0x00, 0x4b,
            0x2e, 0x24);


#define WMI_PATH_PROP             L"__PATH"
#define WMI_REL_PATH_PROP         L"__RELPATH"

#define LOCAL_CIMV2_NAMESPACE L"\\\\.\\ROOT\\CIMV2"
#define CIMV2_NAMESPACE  L"ROOT\\CIMV2"

#define WMI_GETOBJECT_TIMEOUT  ( 10 * 1000 ) 
#define WMI_EXECMETHOD_TIMEOUT ( 45 * 1000 )
#define WMI_SINGLETON_ENUM_TIMEOUT ( 5 * 1000 )
#define WMI_ENUM_TIMEOUT       ( 2 * 1000 )
#define WMI_MAX_ENUM_TIMEOUTS  20

typedef struct _WMI_PROPERTY_BAG
{
    LPWSTR pwszPropName;
    VARTYPE vtPropType;
    PVOID pvPropValue;
} WMI_PROPERTY_BAG, *PWMI_PROPERTY_BAG; 

typedef struct _WMI_ASSOCIATION_ELEMENT
{
    LPWSTR pwszAssociationKey;
    LPWSTR pwszClassName;
    LPWSTR pwszClassKeyName;
    LPWSTR pwszClassKeyValue;
} WMI_ASSOCIATION_ELEMENT, *PWMI_ASSOCIATION_ELEMENT;

dllexp
HRESULT GetWMINameSpacePointer( IN LPWSTR pwszNameSpace,
                                OUT IWbemServices **ppIWbemServices );

dllexp
HRESULT GetWMINameSpacePointer( IN LPWSTR pwszServer,
                                IN LPWSTR pwszNameSpace,
                                IN LPWSTR pwszUser,
                                IN LPWSTR pwszDomain,
                                IN LPWSTR pwszPwd,
                                OUT IWbemServices **ppIWbemServices );


dllexp
HRESULT GetWMIInstanceProperty( IN LPWSTR pwszNameSpace,
                                IN LPWSTR pwszInstancePath,
                                IN LPWSTR pwszPropertyName,
                                OUT VARIANT *pvarProperty );

dllexp
HRESULT DeleteWMIInstances( IN IWbemServices *pIWbemServices,
                            IN LPWSTR pwszClassName );

dllexp
HRESULT QueryWMIInstances( IN IWbemServices *pIWbemServices,
                           IN LPWSTR pwszClassName,
                           OUT IEnumWbemClassObject **ppIEnumWbemClassObject );

dllexp
HRESULT QueryWMIAssociation( IN IWbemServices *pIWbemServices,
                             IN LPWSTR pwszAssociationClass,
                             IN PWMI_ASSOCIATION_ELEMENT pwaeFirstClass,
                             IN PWMI_ASSOCIATION_ELEMENT pwaeSecondClass,
                             OUT IWbemClassObject **ppIWbemClassObject );

dllexp HRESULT GetNthWMIObject( IN IEnumWbemClassObject *pIEnumWbemClassObject,
                                IN DWORD dwIndex,
                                OUT IWbemClassObject **ppClassObject );

dllexp
HRESULT CountWMIInstances( IN IEnumWbemClassObject *pIEnumWbemClassObject,
                           OUT DWORD *pdwNumObjects );

dllexp
HRESULT GetWMIInstanceProperty( IN IWbemClassObject *pIWbemClassObject,
                                IN LPWSTR pwszPropertyName,
                                OUT VARIANT *pvarProperty,
                                IN BOOL fAllowNull = FALSE );


dllexp
HRESULT ExecuteWMIQuery( IN IWbemServices *pNameSpace,
                         IN LPWSTR pwszQuery,
                         OUT IEnumWbemClassObject **ppIEnumWbemClassObject );

dllexp 
HRESULT ExecuteWMIQuery( IN LPWSTR pwszNameSpace,
                         IN LPWSTR pwszQuery,
                         OUT IEnumWbemClassObject **ppIEnumWbemClassObject );

dllexp 
HRESULT ExecuteWMIQuery( IN LPWSTR pwszServer,
                         IN LPWSTR pwszNameSpace,
                         IN LPWSTR pwszUser,
                         IN LPWSTR pwszDomain,
                         IN LPWSTR pwszPwd, 
                         IN LPWSTR pwszQuery,
                         OUT IEnumWbemClassObject **ppIEnumWbemClassObject );

dllexp
HRESULT ExecuteWMIMethod( IN LPWSTR pwszNameSpace,
                          IN LPWSTR pwszObjectClass,
                          IN LPWSTR pwszInstancePath,
                          IN LPWSTR pwszMethodName,
                          IN VARIANT **ppvarArguments,
                          IN LPWSTR *ppwszArgumentNames,
                          IN DWORD cNumArguments,
                          OUT IWbemClassObject **ppOutputArgs,
                          OUT LONG *plReturnValue ); 

dllexp
HRESULT SetWMIProperty( IN IWbemClassObject *pClassObject,
                        IN PWMI_PROPERTY_BAG pwpbBag );


dllexp
HRESULT SetWMIProperty( IN IWbemServices *pIWbemServices,
                        IN IWbemClassObject *pIWbemClassObject,
                        IN LPWSTR pwszPropertyName,
                        IN VARIANT *pvarProp,
                        IN BOOL fWriteInstance );

dllexp 
HRESULT SpawnNewWMIInstance( IN IWbemServices *pIWbemServices,
                             IN LPWSTR pwszClassName,
                             OUT IWbemClassObject **ppIWbemClassObjectNewInstance );


dllexp HRESULT GetWMIClassObjectAsync( IN IWbemServices *pIWbemServices,
                                       IN LPWSTR pwszObjectPath,
                                       OUT IWbemClassObject **ppIWbemClassObject );


dllexp
HRESULT ExtractArrayPropFromWbemObject( IN IWbemClassObject *pIWbemClassObject,
                                        IN LPWSTR pwszPropName,
                                        IN DWORD dwPropType,
                                        OUT VOID *pvArray,
                                        OUT DWORD *pdwNumElements );

#endif // _WMICOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\inc\xmltags.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    xmltags.h 

    Contains the XML tags used in the XML that is used for web cluster operation 


    FILE HISTORY:
        AMallet     1-March-1999     Created
*/


#ifndef _IIS_XMLTAGS_H_
#define _IIS_XMLTAGS_H_

//
// XML tags
//

#define AS_XML_DOC_TAG L"AS_XML_DOCUMENT"

#define AS_XML_DOC_VERSION_TAG L"1.0"

#define AS_XML_DOC_VERSION_ATTR_TAG L"AS_VERSION"

#define AS_XML_DOC_TYPE_TAG L"AS_XML_DOC_TYPE"

#define BEGIN_ACTION_TEMPLATE L"<WEBCLUSTERACTION VERSION=\"1.0\">"
#define END_ACTION_TEMPLATE L"</WEBCLUSTERACTION>"

#define ACTION_ID_TAG L"ACTION_ID"
#define BEGIN_ACTION_ID L"<ACTION_ID>"
#define END_ACTION_ID L"</ACTION_ID>"

#define ACTION_INFO_TAG L"ACTION_INFO"
#define BEGIN_ACTION_INFO L"<ACTIONINFO>"
#define END_ACTION_INFO L"</ACTIONINFO>"

#define ACTION_TYPE_TAG L"ACTION_TYPE"
#define BEGIN_ACTION_TYPE L"<ACTION_TYPE>"
#define END_ACTION_TYPE L"</ACTION_TYPE>"

#define SERVER_DRAIN_TAG L"SERVER_DRAIN"
#define BEGIN_SERVER_DRAIN L"<SERVER_DRAIN>"
#define END_SERVER_DRAIN L"</SERVER_DRAIN>"

#define CLUSTER_TAG L"CLUSTER"
#define BEGIN_CLUSTER L"<CLUSTER>"
#define END_CLUSTER L"</CLUSTER>"

#define CLUSTER_MEMBER_TAG L"CLUSTER_MEMBER"
#define BEGIN_CLUSTER_MEMBER L"<CLUSTER_MEMBER>"
#define END_CLUSTER_MEMBER L"</CLUSTER_MEMBER>"

#define SERVER_DRAIN_TIME_TAG L"SERVER_DRAINTIME"
#define BEGIN_SERVER_DRAIN_TIME L"<SERVER_DRAINTIME>"
#define END_SERVER_DRAIN_TIME L"</SERVER_DRAINTIME>"

#define CLUSTER_SETUP_TAG L"CLUSTER_SETUP"
#define BEGIN_CLUSTER_SETUP_TAG L"CLUSTER_SETUP VERSION=\"1.0\""
#define BEGIN_CLUSTER_SETUP L"<CLUSTER_SETUP VERSION=\"1.0\">"
#define END_CLUSTER_SETUP L"</CLUSTER_SETUP>"

#define CLUSTER_MACHINE_SETUP_TAG L"CLUSTER_MACHINE_SETUP"
#define BEGIN_CLUSTER_MACHINE_SETUP L"<CLUSTER_MACHINE_SETUP VERSION=\"1.0\">"
#define END_CLUSTER_MACHINE_SETUP L"</CLUSTER_MACHINE_SETUP>"

#define CLUSTER_SETUP_INFO_TAG L"CLUSTER_SETUP_INFO"
#define BEGIN_CLUSTER_SETUP_INFO L"<CLUSTER_SETUP_INFO>"
#define END_CLUSTER_SETUP_INFO L"</CLUSTER_SETUP_INFO>"

#define NAME_TAG L"NAME"
#define BEGIN_NAME L"<NAME>"
#define END_NAME L"</NAME>"

#define CLUSTER_GUID_TAG L"CLUSTER_GUID"
#define BEGIN_CLUSTER_GUID L"<CLUSTER_GUID>"
#define END_CLUSTER_GUID L"</CLUSTER_GUID>"

#define DESCRIPTION_TAG L"DESCRIPTION"
#define BEGIN_DESCRIPTION L"<DESCRIPTION>"
#define END_DESCRIPTION L"</DESCRIPTION>"

#define CLUSTER_LB_TAG L"CLUSTER_LB"
#define BEGIN_CLUSTER_LB L"<CLUSTER_LB>"
#define END_CLUSTER_LB L"</CLUSTER_LB>"

#define WLBS_TAG L"WLBS"
#define BEGIN_WLBS L"<WLBS>"
#define END_WLBS L"</WLBS>"

#define LB_TYPE_TAG L"LB_TYPE"
#define BEGIN_LB_TYPE L"<LB_TYPE>"
#define END_LB_TYPE L"</LB_TYPE>"

#define MANAGEMENT_NIC_GUIDS_TAG L"MANAGEMENT_NIC_GUIDS"
#define BEGIN_MANAGEMENT_NIC_GUIDS L"<MANAGEMENT_NIC_GUIDS>"
#define END_MANAGEMENT_NIC_GUIDS L"</MANAGEMENT_NIC_GUIDS>"

#define LB_NIC_GUIDS_TAG L"LB_NIC_GUIDS"
#define BEGIN_LB_NIC_GUIDS L"<LB_NIC_GUIDS>"
#define END_LB_NIC_GUIDS L"</LB_NIC_GUIDS>"

#define MANAGED_MODE_TAG L"MANAGED_MODE"
#define BEGIN_MANAGED_MODE L"<MANAGED_MODE>"
#define END_MANAGED_MODE L"</MANAGED_MODE>"

#define KEEP_SETTINGS_TAG L"KEEP_SETTINGS"
#define BEGIN_KEEP_SETTINGS L"<KEEP_SETTINGS>"
#define END_KEEP_SETTINGS L"</KEEP_SETTINGS>"

#define MSDE_TAG L"MSDE"
#define BEGIN_MSDE L"<MSDE>"
#define END_MSDE L"</MSDE>"

#define CLBLIST_TAG L"CLBLIST"
#define BEGIN_CLBLIST L"<CLBLIST>"
#define END_CLBLIST L"</CLBLIST>"

#define CLUSTER_IP_TAG L"CLUSTER_IP"
#define BEGIN_CLUSTER_IP L"<CLUSTER_IP>"
#define END_CLUSTER_IP L"</CLUSTER_IP>"

#define CLUSTER_IP_SUBNET_MASK_TAG L"CLUSTER_IP_SUBNET_MASK"
#define BEGIN_CLUSTER_IP_SUBNET_MASK L"<CLUSTER_IP_SUBNET_MASK>"
#define END_CLUSTER_IP_SUBNET_MASK L"</CLUSTER_IP_SUBNET_MASK>"

#define DEDICATED_IP_TAG L"DEDICATED_IP"
#define BEGIN_DEDICATED_IP L"<DEDICATED_IP>"
#define END_DEDICATED_IP L"</DEDICATED_IP>"

#define DEDIP_SUBNET_MASK_TAG L"DEDIP_SUBNET_MASK"
#define BEGIN_DEDIP_SUBNET_MASK L"<DEDIP_SUBNET_MASK>"
#define END_DEDIP_SUBNET_MASK L"</DEDIP_SUBNET_MASK>"

#define CLUSTER_MASTER_TAG L"CLUSTER_MASTER"
#define BEGIN_CLUSTER_MASTER L"<CLUSTER_MASTER>"
#define END_CLUSTER_MASTER L"</CLUSTER_MASTER>"

#define CLUSTER_USER_TAG L"CLUSTER_USER"
#define BEGIN_CLUSTER_USER L"<CLUSTER_USER>"
#define END_CLUSTER_USER L"</CLUSTER_USER>"

#define CLUSTER_PWD_TAG L"CLUSTER_PWD"
#define BEGIN_CLUSTER_PWD L"<CLUSTER_PWD>"
#define END_CLUSTER_PWD L"</CLUSTER_PWD>"

#define CLUSTER_ANON_USER_TAG L"CLUSTER_ANON_USER"
#define BEGIN_CLUSTER_ANON_USER L"<CLUSTER_ANON_USER>"
#define END_CLUSTER_ANON_USER L"</CLUSTER_ANON_USER>"

#define CLUSTER_ANON_USER_PWD_TAG L"CLUSTER_ANON_USER_PWD"
#define BEGIN_CLUSTER_ANON_USER_PWD L"<CLUSTER_ANON_USER_PWD>"
#define END_CLUSTER_ANON_USER_PWD L"</CLUSTER_ANON_USER_PWD>"

#define CLUSTER_DOMAIN_NAME_TAG L"CLUSTER_DOMAIN_NAME"
#define BEGIN_CLUSTER_DOMAIN_NAME L"<CLUSTER_DOMAIN_NAME>"
#define END_CLUSTER_DOMAIN_NAME L"</CLUSTER_DOMAIN_NAME>"

#define CLUSTER_WORKGROUP_NAME_TAG L"CLUSTER_WORKGROUP_NAME"
#define BEGIN_CLUSTER_WORKGROUP_NAME L"<CLUSTER_WORKGROUP_NAME>"
#define END_CLUSTER_WORKGROUP_NAME L"</CLUSTER_WORKGROUP_NAME>"

#define CLUSTER_KEYSEED_TAG L"CLUSTER_KEYSEED"
#define BEGIN_CLUSTER_KEYSEED L"<CLUSTER_KEYSEED>"
#define END_CLUSTER_KEYSEED L"</CLUSTER_KEYSEED>"

#define AFFINITY_TAG L"AFFINITY"
#define BEGIN_AFFINITY L"<AFFINITY>"
#define END_AFFINITY L"</AFFINITY>"

#define MULTICAST_TAG L"MULTICAST"
#define BEGIN_MULTICAST L"<MULTICAST>"
#define END_MULTICAST L"</MULTICAST>"

#define HOST_PRIORITY_TAG L"HOST_PRIORITY"
#define BEGIN_HOST_PRIORITY L"<HOST_PRIORITY>"
#define END_HOST_PRIORITY L"</HOST_PRIORITY>"

#define NETCARD_GUID_TAG L"NETCARD_GUID"
#define BEGIN_NETCARD_GUID L"<NETCARD_GUID>"
#define END_NETCARD_GUID L"</NETCARD_GUID>"

#define EVENT_GUID_TAG L"EVENT_GUID"
#define BEGIN_EVENT_GUID L"<EVENT_GUID>"
#define END_EVENT_GUID L"</EVENT_GUID>"

#define SERVER_NAME_TAG L"SERVER_NAME"
#define BEGIN_SERVER_NAME L"<SERVER_NAME>"
#define END_SERVER_NAME L"</SERVER_NAME>"

#define WEIGHT_TAG L"WEIGHT"
#define BEGIN_WEIGHT L"<WEIGHT>"
#define END_WEIGHT L"</WEIGHT>"

#define EVENT_SERVER_TAG L"EVENT_SERVER"
#define BEGIN_EVENT_SERVER L"<EVENT_SERVER>"
#define END_EVENT_SERVER L"</EVENT_SERVER>"

#define PARTITION_GUID_TAG L"PARTITION_GUID"
#define BEGIN_PARTITION_GUID L"<PARTITION_GUID>"
#define END_PARTITION_GUID L"</PARTITION_GUID>"

#define AS_PARAMETERS_TAG L"AS_PARAMETERS"
#define BEGIN_AS_PARAMETERS L"<AS_PARAMEERS>"
#define END_AS_PARAMETERS L"</AS_PARAMETERS>"

#define SERVER_IDS_TAG L"SERVER_IDS"
#define BEGIN_SERVER_IDS L"<SERVER_IDS>"
#define END_SERVER_IDS L"</SERVER_IDS>"

#define SERVER_ID_TAG L"SERVER_ID"
#define BEGIN_SERVER_ID L"<SERVER_ID>"
#define END_SERVER_ID L"</SERVER_ID>"

#define PARAMETER_ID_TAG L"PARAMETER_ID"
#define BEGIN_PARAMETER_ID L"<PARAMETER_ID>"
#define END_PARAMETER_ID L"</PARAMETER_ID>"

#define SERVER_TRANSIENT_STATE L"SERVER_TRANSIENT_STATE"
#define BEGIN_SERVER_TRANSIENT_STATE L"<SERVER_TRANSIENT_STATE>"
#define END_SERVER_TRANSIENT_STATE L"</SERVER_TRANSIENT_STATE>"

#define SERVER_PERSISTENT_STATE L"SERVER_PERSISTENT_STATE"
#define BEGIN_SERVER_PERSISTENT_STATE L"<SERVER_PERSISTENT_STATE>"
#define END_SERVER_PERSISTENT_STATE L"</SERVER_PERSISTENT_STATE>"

#define SYNC_SPEC_TAG L"SYNC_SPEC"
#define BEGIN_SYNC_SPEC L"<SYNC_SPEC>"
#define END_SYNC_SPEC L"</SYNC_SPEC>"

#define CLUSTER_CONFIG_REPL_DEFN_ID_TAG L"CLUSTER_CONFIG_REPL_DEFN_ID"
#define BEGIN_CLUSTER_CONFIG_REPL_DEFN_ID L"<CLUSTER_CONFIG_REPL_DEFN_ID>"
#define END_CLUSTER_CONFIG_REPL_DEFN_ID L"</CLUSTER_CONFIG_REPL_DEFN_ID>"

#define NETCFG_REPL_DEFN_ID_TAG  L"NETCFG_REPL_DEFN_ID"
#define BEGIN_NETCFG_REPL_DEFN_ID L"<NETCFG_REPL_DEFN_ID>"
#define END_NETCFG_REPL_DEFN_ID   L"</NETCFG_REPL_DEFN_ID>"

#define SERVER_GUID_TAG L"SERVER_GUID"
#define BEGIN_SERVER_GUID L"<SERVER_GUID>"
#define END_SERVER_GUID L"</SERVER_GUID>"

#define ONLINE_TAG L"ONLINE"
#define BEGIN_ONLINE L"<ONLINE>"
#define END_ONLINE L"</ONLINE>"

#define UNKNOWN_TAG L"UNKNOWN"
#define BEGIN_UNKNOWN L"<UNKNOWN>"
#define END_UNKNOWN L"</UNKNOWN>"

#define IN_REPL_LOOP_TAG L"IN_REPL_LOOP"
#define BEGIN_IN_REPL_LOOP L"<IN_REPL_LOOP>"
#define END_IN_REPL_LOOP L"</IN_REPL_LOOP>"

#define DOWN_TAG L"DOWN"
#define BEGIN_DOWN L"<DOWN>"
#define END_DOWN L"</DOWN>"

#define DRAINING_TAG L"DRAINING"
#define BEGIN_DRAINING L"<DRAINING>"
#define END_DRAINING L"</DRAINING>"

#define GUID_TAG L"GUID"
#define BEGIN_GUID L"<GUID>"
#define END_GUID L"</GUID>"

#define SERVER_CONFIG_FLAGS_TAG L"SERVER_CONFIG_FLAGS"
#define BEGIN_SERVER_CONFIG_FLAGS L"<SERVER_CONFIG_FLAGS>"
#define END_SERVER_CONFIG_FLAGS L"</SERVER_CONFIG_FLAGS>"

#define WINDIR_PATH_TAG L"WINDIR_PATH"
#define BEGIN_WINDIR_PATH L"<WINDIR_PATH>"
#define END_WINDIR_PATH L"</WINDIR_PATH>"

#define PROGFILES_PATH_TAG L"PROGFILES_PATH"
#define BEGIN_PROGFILES_PATH L"<PROGFILES_PATH>"
#define END_PROGFILES_PATH L"</PROGFILES_PATH>"

#define AC_INSTALL_PATH_TAG  L"AC_INSTALL_PATH"
#define BEGIN_AC_INSTALL_PATH L"<AC_INSTALL_PATH>"
#define END_AC_INSTALL_PATH L"</AC_INSTALL_PATH>"

#define IN_LOADBALANCING_TAG L"IN_LOADBALANCING"
#define ALIVE_TAG L"ALIVE"
#define CONTROLLER_TAG L"CONTROLLER"
#define REPLICATING_TAG L"REPLICATING"
#define MONITOR_STATUS_TAG L"MONITOR_STATUS"
#define TOPOLOGY_VERSION_TAG L"TOPOLOGY_VERSION"
#define CONTROLLER_TIME_TAG  L"CONTROLLER_TIME"
#define SYNC_FLAGS_TAG L"SYNC_FLAGS"
#define USER_TAG  L"USER"
#define PASSWORD_TAG L"PASSWORD"
#define DOMAIN_TAG   L"DOMAIN"
#define PERMISSIONS_TAG L"PERMISSIONS"
#define HAS_PERMISSIONS_TAG L"HAS_PERMISSIONS"

#define SVCXMLTAGLIST \
SVCTAGPROCESS( AS_XML_DOC ) \
SVCTAGPROCESS( AS_XML_DOC_VERSION ) \
SVCTAGPROCESS( AS_XML_DOC_VERSION_ATTR ) \
SVCTAGPROCESS( AS_XML_DOC_TYPE ) \
SVCTAGPROCESS( IN_LOADBALANCING ) \
SVCTAGPROCESS( ALIVE ) \
SVCTAGPROCESS( ACTION_ID) \
SVCTAGPROCESS( SERVER_DRAIN ) \
SVCTAGPROCESS( SERVER_DRAIN_TIME )\
SVCTAGPROCESS( CLUSTER ) \
SVCTAGPROCESS( CLUSTER_MEMBER ) \
SVCTAGPROCESS( CLUSTER_SETUP ) \
SVCTAGPROCESS( CLUSTER_MACHINE_SETUP ) \
SVCTAGPROCESS( CLUSTER_SETUP_INFO ) \
SVCTAGPROCESS( NAME ) \
SVCTAGPROCESS( CLUSTER_GUID ) \
SVCTAGPROCESS( DESCRIPTION ) \
SVCTAGPROCESS( CLUSTER_LB ) \
SVCTAGPROCESS( WLBS ) \
SVCTAGPROCESS( LB_TYPE ) \
SVCTAGPROCESS( MANAGEMENT_NIC_GUIDS ) \
SVCTAGPROCESS( LB_NIC_GUIDS ) \
SVCTAGPROCESS( MSDE ) \
SVCTAGPROCESS( CLBLIST ) \
SVCTAGPROCESS( CLUSTER_IP ) \
SVCTAGPROCESS( CLUSTER_IP_SUBNET_MASK ) \
SVCTAGPROCESS( DEDICATED_IP ) \
SVCTAGPROCESS( DEDIP_SUBNET_MASK ) \
SVCTAGPROCESS( CLUSTER_MASTER ) \
SVCTAGPROCESS( CLUSTER_USER ) \
SVCTAGPROCESS( CLUSTER_PWD ) \
SVCTAGPROCESS( CLUSTER_ANON_USER ) \
SVCTAGPROCESS( CLUSTER_ANON_USER_PWD ) \
SVCTAGPROCESS( CLUSTER_DOMAIN_NAME ) \
SVCTAGPROCESS( CLUSTER_WORKGROUP_NAME ) \
SVCTAGPROCESS( CLUSTER_KEYSEED ) \
SVCTAGPROCESS( AFFINITY ) \
SVCTAGPROCESS( MULTICAST ) \
SVCTAGPROCESS( HOST_PRIORITY ) \
SVCTAGPROCESS( NETCARD_GUID ) \
SVCTAGPROCESS( EVENT_GUID ) \
SVCTAGPROCESS( SERVER_NAME ) \
SVCTAGPROCESS( EVENT_SERVER ) \
SVCTAGPROCESS( PARTITION_GUID ) \
SVCTAGPROCESS( WEIGHT ) \
SVCTAGPROCESS( SERVER_IDS ) \
SVCTAGPROCESS( SERVER_ID ) \
SVCTAGPROCESS( AS_PARAMETERS ) \
SVCTAGPROCESS( PARAMETER_ID ) \
SVCTAGPROCESS( SYNC_SPEC ) \
SVCTAGPROCESS( CLUSTER_CONFIG_REPL_DEFN_ID ) \
SVCTAGPROCESS( NETCFG_REPL_DEFN_ID ) \
SVCTAGPROCESS( SERVER_GUID ) \
SVCTAGPROCESS( GUID ) \
SVCTAGPROCESS( ONLINE ) \
SVCTAGPROCESS( IN_REPL_LOOP ) \
SVCTAGPROCESS( DRAINING ) \
SVCTAGPROCESS( CONTROLLER ) \
SVCTAGPROCESS( REPLICATING ) \
SVCTAGPROCESS( MONITOR_STATUS ) \
SVCTAGPROCESS( TOPOLOGY_VERSION ) \
SVCTAGPROCESS( MANAGED_MODE ) \
SVCTAGPROCESS( KEEP_SETTINGS ) \
SVCTAGPROCESS( CONTROLLER_TIME ) \
SVCTAGPROCESS( SYNC_FLAGS) \
SVCTAGPROCESS( SERVER_CONFIG_FLAGS ) \
SVCTAGPROCESS( USER ) \
SVCTAGPROCESS( PASSWORD ) \
SVCTAGPROCESS( DOMAIN ) \
SVCTAGPROCESS( PERMISSIONS ) \
SVCTAGPROCESS( HAS_PERMISSIONS ) \
SVCTAGPROCESS( WINDIR_PATH ) \
SVCTAGPROCESS( PROGFILES_PATH ) \
SVCTAGPROCESS( AC_INSTALL_PATH )

#endif // _IIS_XMLTAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\cfgquery.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgquery.cpp

$Header: $

Abstract:
	Configuration Query Class Implementation

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include <comdef.h>
#include "wbemcli.h"
#include "cfgquery.h"
#include "cfgtablemeta.h"
#include "cfgrecord.h"
#include "smartpointer.h"

//=================================================================================
// Function: CConfigQuery::CConfigQuery
//
// Synopsis: Default Constructor
//=================================================================================
CConfigQuery::CConfigQuery ()
{
	m_cNrRows		= 0;
	m_ppvValues		= 0;
	m_pTableMeta	= 0;
	m_fInitialized  = false;
	m_wszDatabase	= 0;
	m_wszTable		= 0;
	m_wszSelector	= 0;
}

//=================================================================================
// Function: CConfigQuery::~CConfigQuery
//
// Synopsis: Destructor
//=================================================================================
CConfigQuery::~CConfigQuery ()
{
	delete [] m_ppvValues;
	m_ppvValues = 0;

	delete m_pTableMeta;
	m_pTableMeta = 0;

	delete [] m_wszDatabase;
	m_wszDatabase = 0;

	delete [] m_wszTable;
	m_wszTable = 0;

	delete [] m_wszSelector;
	m_wszSelector = 0;
}

//=================================================================================
// Function: CConfigQuery::Init
//
// Synopsis: Initializes a configuration query. It calls GetTable for the
//           specified database, table and selector. This means that the cache
//           will be populated at this point
//
// Arguments: [i_wszDatabase] - Database name
//            [i_wszTableName] - Table name
//            [i_wszSelector] - selector string
//            [i_pDispenser] - dispenser
//            
// Return Value: S_OK, no errors, non-S_OK errors
//=================================================================================
HRESULT
CConfigQuery::Init (LPCWSTR i_wszDatabase,
					LPCWSTR i_wszTableName,
					LPCWSTR i_wszSelector,
					ISimpleTableDispenser2 *i_pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (i_wszTableName != 0);
	ASSERT (i_pDispenser != 0);
	ASSERT (i_wszDatabase != 0);
//	ASSERT (i_wszSelector != 0);

	HRESULT hr = S_OK;

	m_spDispenser = i_pDispenser;

	m_wszDatabase = new WCHAR [wcslen(i_wszDatabase) + 1];
	if (m_wszDatabase == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszDatabase, i_wszDatabase);

	m_wszTable = new WCHAR [wcslen(i_wszTableName) + 1];
	if (m_wszTable == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszTable, i_wszTableName);

    if ( NULL != i_wszSelector )
    {
	    m_wszSelector = new WCHAR [wcslen(i_wszSelector) + 1];
	    if (m_wszSelector == 0)
	    {
		    return E_OUTOFMEMORY;
	    }
	    wcscpy (m_wszSelector, i_wszSelector);
    }

	// get the table meta information
	
	m_pTableMeta = new CConfigTableMeta (m_wszTable, i_pDispenser);
	if (m_pTableMeta == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	hr = m_pTableMeta->Init ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get table meta information for table %s", i_wszTableName));
		return hr;
	}


	return hr;
}

//=================================================================================
// Function: CConfigQuery::Execute
//
// Synopsis: Executes the config query (i.e. does the GetTable). 
//
// Arguments: [pRecord] - Contains possible column values that need to be considered
//                        during GetTable execution. Note that this parameter can be null
//                        if you want to retrieve all records for a table without specifying
//                        any column values
//            [i_fOnlyPKs] - only use PK column values in the GetTable query
//            [i_fWriteAccess] - do we need write access? Default is read-only access
//=================================================================================
HRESULT 
CConfigQuery::Execute (CConfigRecord *pRecord, bool i_fOnlyPKs, bool i_fWriteAccess)
{
	HRESULT hr = S_OK;

	ULONG cNrCols = 0;
	if (pRecord != 0)
	{
		cNrCols = pRecord->ColumnCount ();
	}

	// number of column + selector
	TSmartPointerArray<STQueryCell> aCells = new STQueryCell[cNrCols + 1];
	if (aCells == 0)
	{
		return E_OUTOFMEMORY;
	}

	aCells[0].pData = (void *) m_wszSelector;
	aCells[0].eOperator = eST_OP_EQUAL;
	aCells[0].iCell = iST_CELL_SELECTOR;
	aCells[0].dbType = DBTYPE_WSTR;
	aCells[0].cbSize = 0;

	ULONG cNrCells = 1;

	if (pRecord != 0)
	{
		ULONG cTotalCells;
		hr = pRecord->AsQueryCell (aCells + 1, &cTotalCells, i_fOnlyPKs);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to convert record to query cell"));
			return hr;
		}

		cNrCells += cTotalCells;
	}

	DWORD dwLOS = 0;
	if (i_fWriteAccess)
	{
		dwLOS = fST_LOS_READWRITE;
	}

	hr = m_spDispenser->GetTable(m_wszDatabase, 
								 m_wszTable, 
								 aCells, 
								 &cNrCells, 
								 eST_QUERYFORMAT_CELLS, 
								 dwLOS, 
								 (void **)&m_spWrite);
	if (FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get table. Database=%s, Table=%s, Selector=%s",
			   m_wszDatabase, m_wszTable, m_wszSelector));
		return hr;
	}
	
	// and get the numbers of rows

	hr = m_spWrite->GetTableMeta (0, 0, &m_cNrRows, 0);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get Table meta"));
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetColumnValues
//
// Synopsis: Get column value information for the row with index idx. This is
//           a simple forward to IST->GetColumnValues, but the function takes
//           care of converting the record to the correct types
//
// Arguments: [i_idx] - index of row to retrieve
//            [io_record] - information will be stored in here
//=================================================================================
HRESULT
CConfigQuery::GetColumnValues (ULONG i_idx, CConfigRecord& io_record)
{
	ASSERT (m_fInitialized );
	ASSERT (i_idx >= 0 && i_idx < m_cNrRows);
	
	HRESULT hr = io_record.Init (m_pTableMeta);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization of config record failed"));
		return hr;
	}

	hr = m_spWrite->GetColumnValues (i_idx, 
									 m_pTableMeta->ColumnCount (),
									 0,
									 io_record.GetSizes (),
									 io_record.GetValues ());
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get column values"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetRowCount
//
// Synopsis: Returns the number of rows that are return from the query
//=================================================================================
ULONG
CConfigQuery::GetRowCount ()
{
	ASSERT (m_fInitialized);
	
	return m_cNrRows;
}

//=================================================================================
// Function: CConfigQuery::GetEmptyConfigRecord
//
// Synopsis: Initializes an empty config record by attaching the correct table
//           meta information
//
// Arguments: [io_record] - record to be initialized
//=================================================================================
HRESULT
CConfigQuery::GetEmptyConfigRecord (CConfigRecord& io_record)
{
	ASSERT (m_pTableMeta != 0);

	HRESULT hr = io_record.Init (m_pTableMeta);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization of configrecord failed"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetPKRow
//
// Synopsis: Get a single row based on Primary Key information. The record that is
//           passed in contains the values for the columns that make up the primary
//           key. We query the IST and if we find a match, we return the index of that
//           particular row in o_pcRow
//
// Arguments: [i_record] - record with PK information filled out
//            [o_pcRow] - index of row that contains PK, -1 if not found
//            
// Return Value: S_OK, no error, non-S_OK else
//=================================================================================
HRESULT 
CConfigQuery::GetPKRow (CConfigRecord& i_record, ULONG *o_pcRow)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcRow != 0);

	HRESULT hr = i_record.SyncValues ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to sync values"));
		return hr;
	}

	// special case singletons
	if (m_pTableMeta->PKCount () == 0)
	{
		if (m_cNrRows == 1)
		{
			*o_pcRow = 0;
		}
		else
		{
			hr = E_ST_NOMOREROWS;
		}
	}
	else
	{
		hr = m_spWrite->GetRowIndexBySearch (0,
											 m_pTableMeta->PKCount(), 
											 m_pTableMeta->GetPKInfo (), 
											 i_record.GetSizes (), 
											 i_record.GetValues (), 
											 o_pcRow);
		if (FAILED (hr))
		{
			// no tracing, because this is common code path
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetRowBySearch
//
// Synopsis: Returns the index of a row by searching for certain column values. The
//           columns that are needed for the search are specified as non-empty values
//           in the record that is passed into this function. The function simply forwards
//           to IST
//
// Arguments: [i_StartingRow] - Row to start searching from
//            [i_record] - record with column information that is used for the search
//            [o_pcRow] - index of found row, -1 if nothing found
//=================================================================================
HRESULT 
CConfigQuery::GetRowBySearch (ULONG i_StartingRow, CConfigRecord& i_record, ULONG *o_pcRow)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcRow != 0);

	HRESULT hr = i_record.SyncValues ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to sync values"));
		return hr;
	}

	// Build an array with indexes of columns that are relavant to the search. We skip
	// all columns that have 0 values;

	ULONG cNrRelevantCols = 0;
	TSmartPointerArray<ULONG> aColIndex = new ULONG[m_pTableMeta->ColumnCount()];
	if (aColIndex == 0)
	{
		return E_OUTOFMEMORY;
	}

	// skip over null columns
	LPVOID * aValues = i_record.GetValues ();
	for (ULONG idx=0; idx < m_pTableMeta->ColumnCount(); ++idx)
	{
		if (aValues[idx] != 0)
		{
			aColIndex[cNrRelevantCols++] = idx;
		}
	}

	// special case singleton

	if (cNrRelevantCols == 0)
	{
		if (i_StartingRow < m_cNrRows)
		{
			*o_pcRow = i_StartingRow;
		}
		else
		{
			return E_ST_NOMOREROWS;
		}
	}
	else
	{
		hr = m_spWrite->GetRowIndexBySearch (i_StartingRow,
												 cNrRelevantCols, 
												 aColIndex, 
												 i_record.GetSizes (), 
												 i_record.GetValues (), 
												 o_pcRow);
		if (FAILED (hr) && hr != E_ST_NOMOREROWS)
		{
			// no tracing, because this is common code path
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::UpdateRow
//
// Synopsis: Updates a record in the catalog. It first checks if the row exists. If the
//           row exists, it only has to update columns that are not PK values, else the
//           XML interceptor will return an error. If the row doesn't exist, an insert
//           is done instead.
//
// Arguments: [i_cReadRow] index of row to update (-1 if not exist)
//			  [i_record] - record to update/insert
//=================================================================================
HRESULT
CConfigQuery::UpdateRow (ULONG i_cReadRow, CConfigRecord& i_record, long lFlags)
{
	ASSERT (m_fInitialized);

	// does the row exist?
	HRESULT hr = S_OK;
	ULONG cWriteRow;

	if (i_cReadRow != -1)
	{
		if (lFlags == WBEM_FLAG_CREATE_ONLY)
		{
			DBGINFOW((DBG_CONTEXT, L"Trying to update while WBEM_FLAG_CREATE_ONLY is specified"));
			return WBEM_E_ALREADY_EXISTS;
		}
		// we have to update an existing row
		// we have to separte insert and update, because we cannot overwrite primary
		// key values (the XML interceptor will return an error in this case). When we
		// do update, we take out the primary key values, so that they don't get 
		// updated.
		ULONG cUpdateableCols = m_pTableMeta->ColumnCount () - m_pTableMeta->PKCount ();
		if (cUpdateableCols > 0)
		{
			hr = m_spWrite->AddRowForUpdate (i_cReadRow, &cWriteRow);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"Unable to add row for update"));
				return hr;
			}


			// figure out which columns are not primary key columns so we can update
			// these.
			TSmartPointerArray<ULONG> spaColIdx = new ULONG [cUpdateableCols];
			if (spaColIdx == 0)
			{
				return E_OUTOFMEMORY;
			}

			ULONG updateIdx = 0;
			for (ULONG idx=0; idx < m_pTableMeta->ColumnCount (); ++idx)
			{
				if (!(*m_pTableMeta->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_PRIMARYKEY))
				{
					spaColIdx[updateIdx++] = idx;
				}
			}

			// BUGBUG(marcelv) HACKHACKHACKHACKHACKHACK
			// Because of a bug in the fastcache, we need to special case the code
			// in case we have to update a single column. When we want to update a single
			// column, SetWriteColumnValues expects the value to be in m_ppvValues[0], which
			// screws us in this case because we are passing in an array of values. By special
			// casing we work around the problem, however, it still needs to be fixed
			// in the fast cache to avoid problems in the future.

			if (updateIdx == 1)
			{
				ULONG cIdxUpdateCol = spaColIdx[0];
				hr = m_spWrite->SetWriteColumnValues (cWriteRow, 
													  1,
													  spaColIdx,
													  i_record.GetSizes (),
													  &i_record.GetValues ()[cIdxUpdateCol]);

			}
			else
			{
				hr = m_spWrite->SetWriteColumnValues (cWriteRow, 
													  updateIdx,
													  spaColIdx,
													  i_record.GetSizes (),
													  i_record.GetValues ());
			}
		}
	}
	else 
	{
		if (lFlags == WBEM_FLAG_UPDATE_ONLY)
		{
			DBGINFOW((DBG_CONTEXT, L"Trying to insert new row, while WBEM_FLAG_UPDATE_ONLY is specified"));
			return WBEM_E_NOT_FOUND;
		}

		// record doesn't exist, so do insert instead
		hr = m_spWrite->AddRowForInsert (&cWriteRow);

		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to add row for insert"));
			return hr;
		}

		hr = m_spWrite->SetWriteColumnValues (cWriteRow, 
									  m_pTableMeta->ColumnCount (),
									  0,
									  i_record.GetSizes (),
									  i_record.GetValues ());
	}

	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to update row"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::DeleteRow
//
// Synopsis: Delete the row with index i_idx
//
// Arguments: [i_idx] - index of row that will be deleted
//=================================================================================
HRESULT
CConfigQuery::DeleteRow (ULONG i_idx)
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >=0 && i_idx < m_cNrRows);

	HRESULT hr = m_spWrite->AddRowForDelete (i_idx);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"AddRowForDelete failed"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::Save
//
// Synopsis: Save the updates to the configuration store
//=================================================================================
HRESULT 
CConfigQuery::Save ()
{
	ASSERT (m_fInitialized);
	HRESULT hr = m_spWrite->UpdateStore ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"UpdateStore failed"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::SaveSingleRow
//
// Synopsis: Calls updateStore for a single row in the write cache. This should be used
//           when a WMI::Put is called for a single instance, and not used for batch updates
//=================================================================================
HRESULT 
CConfigQuery::SaveSingleRow ()
{
	ASSERT (m_fInitialized);
	HRESULT hr = m_spWrite->UpdateStore ();

	if (hr == E_ST_DETAILEDERRS)
	{
		// try to get the detailed error
		HRESULT hrDetailed = 0;
		GetSingleDetailedError (&hrDetailed); // ignore errors from this function

		if (hrDetailed != 0)
		{
			hr = hrDetailed;
		}
	}
	
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"UpdateStore failed"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetSingleDetailedError
//
// Synopsis: Gets the detailed error when we were updating a single row
//
// Arguments: [pDetailedHr] - hr of detailed error
//=================================================================================
HRESULT
CConfigQuery::GetSingleDetailedError (HRESULT * pDetailedHr)
{
	ASSERT (m_fInitialized);
	ASSERT (pDetailedHr != 0);
	ASSERT (*pDetailedHr == 0);

    CComPtr<ISimpleTableController> spISTController;
 
    HRESULT hr = m_spWrite->QueryInterface(IID_ISimpleTableController, (void **)&spISTController);

    if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get IID_ISimpleTableController interface"));
        return hr;
	}

	ULONG cNrErrors = 0;
    hr = spISTController->GetDetailedErrorCount(&cNrErrors);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get error count"));
		return hr;
	}

	ASSERT (cNrErrors == 1);

	STErr err;
	hr = spISTController->GetDetailedError(0, &err);
	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get detailed error"));
		return hr;
	}

	*pDetailedHr = err.hr;

	return S_OK;
}

HRESULT
CConfigQuery::GetDetailedErrorCount (ULONG *pCount)
{
	ASSERT (m_fInitialized);
	ASSERT (pCount != 0);
	*pCount = 0;

	CComPtr<ISimpleTableController> spISTController;
    HRESULT hr = m_spWrite->QueryInterface(IID_ISimpleTableController, (void **)&spISTController);
    if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get IID_ISimpleTableController interface"));
        return hr;
	}

    hr = spISTController->GetDetailedErrorCount(pCount);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get error count"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetDetailedError
//
// Synopsis: Get a detailed error
//
// Arguments: [idx] - index of detailed error
//            [pErrInfo] - error information will be stored here
//=================================================================================
HRESULT
CConfigQuery::GetDetailedError (ULONG idx, STErr* pErrInfo)
{
	ASSERT (m_fInitialized);
	ASSERT (pErrInfo != 0);
	
	CComPtr<ISimpleTableController> spISTController;
    HRESULT hr = m_spWrite->QueryInterface(IID_ISimpleTableController, (void **)&spISTController);
    if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get IID_ISimpleTableController interface"));
        return hr;
	}

	hr = spISTController->GetDetailedError(idx, pErrInfo);
	if(FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get detailed error"));
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\cfgrecord.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgrecord.h

$Header: $

Abstract:

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGRECORD_H__
#define __CFGRECORD_H__

#pragma once

#include "catalog.h"
#include <comdef.h>

class CConfigTableMeta;

class CConfigRecord
{
public:
	CConfigRecord ();
	~CConfigRecord ();

	HRESULT Init (const CConfigTableMeta *i_pTableInfo);

	//const _variant_t operator[] (LPCWSTR i_wszPropName) const;
	
	HRESULT GetValue (LPCWSTR i_wszPropName, _variant_t& o_varValue) const;
	HRESULT GetValue (ULONG i_idx, _variant_t& o_varValue) const;

	HRESULT SetValue (LPCWSTR i_wszPropName, LPCWSTR i_wszValue);
	HRESULT SetValue (LPCWSTR i_wszPropName, const _variant_t& i_varValue);

	HRESULT SyncValues ();
	HRESULT AsQueryCell (STQueryCell *io_aCells, ULONG* io_pcTotalCells, bool fOnlyPKs);

	LPVOID * GetValues () const;
	ULONG * GetSizes () const;

	HRESULT AsObjectPath (LPCWSTR wszSelector, _variant_t& o_varResult);

	ULONG ColumnCount () const;
	LPCWSTR GetColumnName (ULONG idx) const;
	LPCWSTR GetPublicTableName () const;
	bool IsPersistableColumn (ULONG idx) const;

private:
	HRESULT ValueToVariant (LPVOID pValue, ULONG iSize, int iType, BOOL i_fIsMultiString, _variant_t& o_varResult) const;
	HRESULT VariantToValue (_variant_t& varValue, int iType, ULONG *piSize, BOOL i_fIsMultiString, LPVOID& o_lpValue) const;

	CConfigTableMeta *	m_pTableInfo;		// table meta information
	LPVOID *			m_ppvValues;		// array with catalog values
	ULONG *				m_acbSizes;			// array with catalog sizes
	_variant_t *		m_avarValues;		// array with variant values
	bool				m_fInitialized;		// are we initialized?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\cfgrecord.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgrecord.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include "cfgrecord.h"
#include "cfgtablemeta.h"
#include "smartpointer.h"
#include "stringutil.h"

//=================================================================================
// Function: CConfigRecord::CConfigRecord
//
// Synopsis: Default constructor
//=================================================================================
CConfigRecord::CConfigRecord ()
{
	m_ppvValues		= 0;
	m_acbSizes		= 0;
	m_avarValues	= 0;
	m_pTableInfo	= 0;
	m_fInitialized  = false;
}

//=================================================================================
// Function: CConfigRecord::~CConfigRecord
//
// Synopsis: Destructor, releases the memory
//=================================================================================
CConfigRecord::~CConfigRecord ()
{
	delete [] m_avarValues;
	m_avarValues = 0;

	delete [] m_ppvValues;
	m_ppvValues = 0;

	delete [] m_acbSizes;
	m_acbSizes = 0;
}


//=================================================================================
// Function: CConfigRecord::Init
//
// Synopsis: Initializes a configuration record by allocating memory for column
//           values and assigning the TableMeta information
//
// Arguments: [i_pTableInfo] - table meta information
//=================================================================================
HRESULT
CConfigRecord::Init (const CConfigTableMeta * i_pTableInfo)
{
	ASSERT (i_pTableInfo != 0);
	ASSERT (i_pTableInfo->ColumnCount () > 0);

	m_ppvValues	= new LPVOID [i_pTableInfo->ColumnCount ()];
	if (m_ppvValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_acbSizes = new ULONG [i_pTableInfo->ColumnCount ()];
	if (m_acbSizes == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_avarValues = new _variant_t[i_pTableInfo->ColumnCount()];
	if (m_avarValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_pTableInfo	= const_cast<CConfigTableMeta *>(i_pTableInfo);
	m_fInitialized	= true;

	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::GetPublicTableName
//
// Synopsis: Gets the public table name from the record
//=================================================================================
LPCWSTR
CConfigRecord::GetPublicTableName () const
{
	ASSERT (m_fInitialized);

	return m_pTableInfo->GetPublicTableName ();
}


//=================================================================================
// Function: CConfigRecord::ColumnCount
//
// Synopsis: Returns the number of columns in the record
//=================================================================================
ULONG
CConfigRecord::ColumnCount () const
{
	ASSERT (m_fInitialized);

	return m_pTableInfo->ColumnCount ();
}

//=================================================================================
// Function: CConfigRecord::GetColumnName
//
// Synopsis: Returns the name of the column
//
// Arguments: [idx] - index of column to get name 
//            
// Return Value: 
//=================================================================================
LPCWSTR
CConfigRecord::GetColumnName (ULONG idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (idx >=0 && idx < ColumnCount());

	return m_pTableInfo->GetColumnName (idx);
}

//=================================================================================
// Function: CConfigRecord::IsPersistableColumn
//
// Synopsis: Is the column markes as NOTPERSISTABLE or not	
//
// Arguments: [idx] - index of column for which we want to determine if persistable or not
//            
// Return Value: true, column is persistable, false, column is not persistable
//=================================================================================
bool 
CConfigRecord::IsPersistableColumn (ULONG idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (idx >=0 && idx < ColumnCount ());

	if (*m_pTableInfo->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//=================================================================================
// Function: CConfigRecord::GetValues
//
// Synopsis: Get values in catalog format
//
// Return Value: pointer to array with columns values in catalog format. Should be
//               treated as read-only by the caller
//=================================================================================
LPVOID *
CConfigRecord::GetValues () const
{
	ASSERT (m_fInitialized);

	return m_ppvValues;
}

//=================================================================================
// Function: CConfigRecord::GetSizes
//
// Synopsis: Get sizes of values
//
// Return Value: array of sizes. Should be treated as read-only by the caller
//=================================================================================
ULONG *
CConfigRecord::GetSizes () const
{
	ASSERT (m_fInitialized);

	return m_acbSizes;
}

//=================================================================================
// Function: CConfigRecord::SyncValues
//
// Synopsis: The record contains two array's: one in catalog format (void pointers) and
//           one in variant_t format. The reason for this is to make it easy to convert
//           from WMI format (variant_t) to catalog format and vice versa. This function
//           does the conversion from WMI format to catalog format
//=================================================================================
HRESULT
CConfigRecord::SyncValues ()
{
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;
	for (ULONG idx=0; idx < m_pTableInfo->ColumnCount(); ++idx)
	{
		tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (idx);
		hr = VariantToValue (m_avarValues[idx], *ColMeta.pType, &m_acbSizes[idx], *ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING, m_ppvValues[idx]);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"VariantToValue failed"));
			return hr;
		}
	}
	return hr;
}

//=================================================================================
// Function: CConfigRecord::GetValue
//
// Synopsis: Get the value for the column with name 'i_wszColumnName'
//
// Arguments: [i_wszColumnName] - name of column to get value for
//            [o_varResult] - result will be stored here
//=================================================================================
HRESULT
CConfigRecord::GetValue (LPCWSTR i_wszColumnName, _variant_t& o_varResult) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszColumnName != 0);

	ULONG idx = m_pTableInfo->GetColumnIndex (i_wszColumnName);
	ASSERT (idx != -1);

	tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (idx);

	return ValueToVariant (m_ppvValues[idx], 
		                   m_acbSizes[idx], 
						   *ColMeta.pType, 
						   *ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING,
						   o_varResult);
}

//=================================================================================
// Function: CConfigRecord::GetValue
//
// Synopsis: Gets the column value of column with index i_idx.
//
// Arguments: [i_idx] - index of column to search for
//            [o_varResult] - result will be stored in here
//=================================================================================
HRESULT
CConfigRecord::GetValue (ULONG i_idx, _variant_t& o_varResult) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >= 0 && i_idx < m_pTableInfo->ColumnCount ());

	tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (i_idx);

	return ValueToVariant (m_ppvValues[i_idx], 
		                   m_acbSizes[i_idx], 
						   *ColMeta.pType, 
						   *ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING,
						   o_varResult);
}
	
//=================================================================================
// Function: CConfigRecord::SetValue
//
// Synopsis: Set the value for a particular column/property. The value is a string
//           value, but dependent on the type, it needs to be converted.
//
// Arguments: [i_wszPropName] - Property name
//            [i_wszValue] - 
//            
// Return Value: 
//=================================================================================
HRESULT 
CConfigRecord::SetValue (LPCWSTR i_wszPropName, LPCWSTR i_wszValue)
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszPropName != 0);
	ASSERT (i_wszValue != 0);

	ULONG idx = m_pTableInfo->GetColumnIndex (i_wszPropName);
	if (idx == -1)
	{
		return E_INVALIDARG;
	}
	tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (idx);

	switch (*ColMeta.pType)
	{
	case DBTYPE_WSTR:
		m_avarValues[idx] = i_wszValue;
		break;

	case DBTYPE_UI4:

		// when we convert a boolean, we get values "0" and "false for false and "1" and "true" for true
		// we need to special case this here, because else wtol will always return 0;
		if (*ColMeta.pMetaFlags & fCOLUMNMETA_BOOL)
		{
			if ((wcscmp (L"0", i_wszValue) == 0) || (_wcsicmp(L"false", i_wszValue) == 0))
			{
				m_avarValues[idx] = 0L;
			}
			else
			{
				m_avarValues[idx] = 1L;
			}
		}
		else
		{
			m_avarValues[idx] = _wtol(i_wszValue);
		}
		break;

	case DBTYPE_BYTES:
		ASSERT (!L"NYI");
		break;

	default:
		ASSERT (false);
		break;
	}

	return S_OK;
}

HRESULT 
CConfigRecord::SetValue (LPCWSTR i_wszPropName, const _variant_t& i_varValue)
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszPropName != 0);

	ULONG idx = m_pTableInfo->GetColumnIndex (i_wszPropName);
	if (idx == -1)
	{
		return E_INVALIDARG;
	}

	m_avarValues[idx] = i_varValue;

	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::AsObjectPath
//
// Synopsis: Converts a configuration record to a valid object path. It uses the PK
//           information to figure out what columns should be part of the object path,
//           and creates the object path accordingly
//
// Arguments: [wszSelector] - selector property that is part of the object path. Only
//                            add this when wszSelector != 0
//            [o_varResult] - object path will be stored here
//=================================================================================
HRESULT
CConfigRecord::AsObjectPath (LPCWSTR wszSelector, _variant_t& o_varResult)
{
	ASSERT (m_fInitialized);

	// ASSERT that the values are sync'd up

	_bstr_t bstrResult = m_pTableInfo->GetPublicTableName ();
	
	ULONG * aPKInfo = m_pTableInfo->GetPKInfo ();
	for (ULONG idx=0; idx < m_pTableInfo->PKCount (); ++idx)
	{
		if (idx == 0)
		{
			bstrResult += L".";
		}
		else
		{
			bstrResult += L",";
		}
	
		ULONG PKIdx = aPKInfo[idx];
		tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (PKIdx);

		bstrResult += ColMeta.pPublicName;
		bstrResult += L"=";

		switch (*ColMeta.pType)
		{
		case DBTYPE_WSTR:
			// we don't have multi-string PK, so assert that we don't have multi-string
			ASSERT ((*ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING) == 0);
			bstrResult += "\"";
			bstrResult += (LPCWSTR) m_ppvValues[PKIdx];
			bstrResult += "\"";
			break;

		case DBTYPE_UI4:
			WCHAR wszNr[20];
			_snwprintf (wszNr, 20, L"%ld", *((ULONG *)m_ppvValues[PKIdx]));
			bstrResult += wszNr;
			break;

		case DBTYPE_BYTES:
			ASSERT (!L"NYI");
			break;

		default:
			ASSERT (false);
			break;
		}
	}

	// and add the selector. If we don't have any PK information yet, we need to
	// add a dot instead of comma

	if (m_pTableInfo->PKCount () == 0)
	{
		bstrResult += ".";
	}
	else
	{
		bstrResult += ",";
	}

	// add selector in case it is needed
	if (wszSelector != 0)
	{
		TSmartPointerArray<WCHAR> saSelector = CWMIStringUtil::AddBackSlashes (wszSelector);
		if (saSelector == 0)
		{
			return E_OUTOFMEMORY;
		}

		bstrResult += "Selector=\"";
		bstrResult += (LPWSTR) saSelector;
		bstrResult += "\"";
	}

	o_varResult = bstrResult;
	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::ValueToVariant
//
// Synopsis: Converts a (catalog) value to a variant
//
// Arguments: [i_pValue] - value to convert
//            [i_iSize] - size of the value
//            [i_iType] - type of the value
//            [i_fIsMultiString] - is it a multistring or not
//            [o_varResult] - result of value (as variant)
//=================================================================================
HRESULT
CConfigRecord::ValueToVariant (LPVOID i_pValue, ULONG i_iSize, int i_iType, BOOL i_fIsMultiString, _variant_t& o_varResult) const
{
	static VARIANT varNull = {VT_NULL, 0};
	HRESULT hr = S_OK;

	if (i_pValue == 0)
	{
		o_varResult = varNull;
		return S_OK;
	}

	switch (i_iType)
	{
	case DBTYPE_WSTR:

		if (!i_fIsMultiString)
		{
			o_varResult = (LPWSTR) i_pValue;
		}
		else
		{
			// count number of elements

			ULONG iNrElems = 0;
			for (LPCWSTR pCur = (LPCWSTR) i_pValue; *pCur != L'\0'; pCur += wcslen (pCur) + 1)
			 {
				iNrElems++;
			 }
			// create variant array
			SAFEARRAYBOUND safeArrayBounds[1];
			safeArrayBounds[0].lLbound = 0;
			safeArrayBounds[0].cElements = iNrElems;
			SAFEARRAY *safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
			if (safeArray == 0)
			{
				return E_OUTOFMEMORY;
			}

			// copy only first one for the moment

			LPCWSTR pCurString = (LPWSTR) i_pValue;
			for (ULONG idx=0; idx < iNrElems; ++idx)
			{
				BSTR bstrVal = SysAllocString ((LPWSTR) pCurString);
				if (bstrVal == 0)
				{
					return E_OUTOFMEMORY;
				}
				hr = SafeArrayPutElement (safeArray, (LONG *)&idx, bstrVal);
				SysFreeString (bstrVal); // free first to avoid leak
				if (FAILED (hr))
				{
					DBGINFOW((DBG_CONTEXT, L"SafeArrayPutElement failed in ValueToVariant"));
					return hr;
				}
				pCurString += wcslen (pCurString) + 1;
			}

			o_varResult.vt = VT_BSTR | VT_ARRAY;
			o_varResult.parray = safeArray;
		}
		break;

	case DBTYPE_UI4:
		o_varResult = (long) *(ULONG *)i_pValue;
		break;

	case DBTYPE_BYTES:
		{
			SAFEARRAYBOUND safeArrayBounds[1];
			safeArrayBounds[0].lLbound = 0;
			safeArrayBounds[0].cElements = i_iSize;
			SAFEARRAY *safeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
			if (safeArray == 0)
			{
				return E_OUTOFMEMORY;
			}

			for (ULONG idx=0; idx < i_iSize; ++idx)
			{
				hr = SafeArrayPutElement (safeArray, (LONG *)&idx , (LPBYTE)i_pValue + idx);
				if (FAILED (hr))
				{
					DBGINFOW((DBG_CONTEXT, L"SafeArrayPutElement failed in ValueToVariant"));
					return hr;
				}
			}

			o_varResult.vt = VT_UI1 | VT_ARRAY;
			o_varResult.parray = safeArray;
		}
		break;

	default:
		ASSERT (false);
		o_varResult = varNull;
		break;
	}

	return hr;
}

//=================================================================================
// Function: CConfigRecord::VariantToValue
//
// Synopsis: Convert a variant to a (catalog) value
//
// Arguments: [io_varValue] - variant to convert
//            [iType] - type to convert to
//            [piSize] - size of new value
//            [i_fIsMultiString] - do we have multistring
//            [o_lpValue] - resulting value after conversion
//=================================================================================
HRESULT
CConfigRecord::VariantToValue (_variant_t& io_varValue, int iType, ULONG *piSize, BOOL i_fIsMultiString, LPVOID& o_lpValue) const
{
	ASSERT (piSize != 0);

	*piSize = 0;

	if (io_varValue.vt == VT_NULL || io_varValue.vt == VT_EMPTY)
	{
		o_lpValue = 0;
		return S_OK;
	}

	HRESULT hr = S_OK;

	switch (iType)
	{
	case DBTYPE_WSTR:
		if (i_fIsMultiString)
		{
			ASSERT (io_varValue.vt == (VT_BSTR | VT_ARRAY));
			SAFEARRAY *safeArray = io_varValue.parray;
			*piSize = safeArray->rgsabound[0].cElements ;
			if (*piSize == 0)
			{
				o_lpValue = 0;
				return S_OK;
			}

			LPWSTR *aObjects;
			
			hr = SafeArrayAccessData (safeArray, (void **) &aObjects);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"SafeArrayAccessData failed"));
				return hr;
			}
			
			hr = SafeArrayUnaccessData (safeArray);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"SafeArrayUnAccessData failed"));
				return hr;
			}

			SIZE_T iTotalLen = 0;
			for (ULONG idx=0; idx < *piSize; ++idx)
			{
				iTotalLen += wcslen ((LPWSTR)aObjects[idx]) + 1;
			}
			iTotalLen++;

			BSTR bstrResult = SysAllocStringByteLen (0, (ULONG) (iTotalLen * sizeof(WCHAR)));
			if (bstrResult == 0)
			{
				return E_OUTOFMEMORY;
			}

			SIZE_T iStartPos = 0;
			for (idx=0; idx < *piSize; ++idx)
			{
				SIZE_T iCurLen = wcslen ((LPWSTR) aObjects[idx]) + 1; // for null terminator
				memcpy (bstrResult + iStartPos, aObjects[idx], iCurLen * sizeof (WCHAR));
				iStartPos += iCurLen;
			}

			bstrResult[iStartPos] = L'\0';

			io_varValue.Clear ();
			io_varValue.vt		 = VT_BSTR;
			io_varValue.bstrVal = bstrResult;

			o_lpValue = io_varValue.bstrVal;
		}
		else
		{
			ASSERT (io_varValue.vt == VT_BSTR);
			o_lpValue = io_varValue.bstrVal;
		}
		break;

	case DBTYPE_UI4:
		{
			// a VT_BOOL variant only contains one byte (boolVal) to represent the boolean.
			// The catalog expect booleans to be 4 bytes. Because the three unused bytes in
			// the variant are garbage, we need to convert the variant to a UI4, so that we
			// can fill out the long variable with 0 (false) or 1 (true). This way, both the
			// catalog and the variant deal with the same number of bytes, and everything works
			// fine.
			if (io_varValue.vt == VT_BOOL)
			{
				// convert the bool to long
				
				if (io_varValue.boolVal == 0)
				{
					io_varValue.Clear ();
					io_varValue = 0L;
				}
				else
				{
					io_varValue.Clear ();
					io_varValue = 1L;
				}
			}

			ASSERT (io_varValue.vt == VT_I4);
			o_lpValue = &io_varValue.lVal;
		}
		break;

	case DBTYPE_BYTES:
		{
			ASSERT (io_varValue.vt == (VT_UI1 | VT_ARRAY));
			SAFEARRAY *safeArray = io_varValue.parray;
			*piSize = safeArray->rgsabound[0].cElements ;
			o_lpValue = safeArray->pvData;
		}

		break;

	default:
		ASSERT (false && "Unknown datatype specified");
		break;
	}

	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::AsQueryCell
//
// Synopsis: Converts a config record to a query cell array. This is used to quickly
//           search by primary key values. 
//
// Arguments: [io_aCells] - array of query cells
//            [io_pcTotalCells] - total number of query cells in array
//            [i_fOnlyPKs] - only consider PKs, not any other columns
//=================================================================================
HRESULT
CConfigRecord::AsQueryCell (STQueryCell *io_aCells, ULONG *io_pcTotalCells, bool i_fOnlyPKs)
{
	ASSERT (io_aCells != 0);
	ASSERT (io_pcTotalCells != 0);

	HRESULT hr = SyncValues ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to sync values"));
		return hr;
	}

	ULONG insertIdx = 0;
	for (ULONG idx=0; idx < ColumnCount(); ++idx)
	{
		// if we are interested in just the primary keys, skip all columns that are not PK
		if (i_fOnlyPKs && !(*m_pTableInfo->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_PRIMARYKEY))
		{
			continue;
		}

		if (m_ppvValues[idx] != 0)
		{
			switch (*m_pTableInfo->GetColumnMeta(idx).pType)
			{
			case DBTYPE_WSTR:
				// we don't support multistrings
				ASSERT (!(*m_pTableInfo->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_MULTISTRING));
				io_aCells[insertIdx].pData		= (void *) m_ppvValues[idx];
				io_aCells[insertIdx].eOperator	= eST_OP_EQUAL;
				io_aCells[insertIdx].iCell		= idx;
				io_aCells[insertIdx].dbType		= DBTYPE_WSTR;
				io_aCells[insertIdx].cbSize		= 0;
				insertIdx++;
				break;

			case DBTYPE_UI4:
				io_aCells[insertIdx].pData		= (void *) m_ppvValues[idx];
				io_aCells[insertIdx].eOperator	= eST_OP_EQUAL;
				io_aCells[insertIdx].iCell		= idx;
				io_aCells[insertIdx].dbType		= DBTYPE_UI4;
				io_aCells[insertIdx].cbSize		= 0;
				insertIdx++;
				break;

			case DBTYPE_BYTES:
				ASSERT (false && "NYI for bytes");
				// we don't handle bytes
				break;

			default:
				ASSERT (false && "Unknown datatype specified");
				break;
			}

		}
	}

	*io_pcTotalCells = insertIdx;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\classfactory.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    ClassFactory.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CLASSFACTORY_H__
#define __CLASSFACTORY_H__

#pragma once

#include <comdef.h>

class CClassFactory : public IClassFactory
{
public:
	static LONG m_LockCount;

    CClassFactory (int iFactoryType) ;
    ~CClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );
    STDMETHODIMP LockServer ( BOOL ) ;

private:
    long m_RefCount;
	int m_iFactoryType;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\cfgtablemeta.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgtablemeta.h

$Header: $

Abstract:
	Table Meta information implementation

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGTABLEMETA_H__
#define __CFGTABLEMETA_H__

#pragma once

#include "catalog.h"
#include "catmacros.h"
#include "catmeta.h"

class CConfigTableMeta
{
public:
	CConfigTableMeta (LPCWSTR i_wszTableName, 
					  ISimpleTableDispenser2 *i_pDispenser);
	~CConfigTableMeta ();

	HRESULT Init ();

	ULONG   GetColumnIndex (LPCWSTR i_wszColumnName) const;
	LPCWSTR GetColumnName  (ULONG i_idx) const;
	const tCOLUMNMETARow& GetColumnMeta (ULONG i_idx);
	LPCWSTR GetPublicTableName () const;

	ULONG	ColumnCount () const;
	ULONG	PKCount     () const;
	ULONG * GetPKInfo   () const;
private:
	HRESULT GetColumnInfo ();
	
	WCHAR *				m_pTableName;	// table name
	tTABLEMETARow		m_TableMeta;	// table meta information
	tCOLUMNMETARow *	m_paColumnMeta;	// column meta information
	ULONG *				m_paPKInfo;	    // primary key indexes
	ULONG				m_cNrPKs;		// number of primary keys

	CComPtr<ISimpleTableRead2>      m_spISTTableMeta; // table meta read pointer
	CComPtr<ISimpleTableRead2>      m_spISTColumnMeta; // column meta read pointer
	CComPtr<ISimpleTableDispenser2> m_spDispenser;	// table dispenser

	bool m_fInitialized;  // is the class initialized
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\classfactory.cpp ===
//***************************************************************************
//
//  ClassFactory.cpp
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************


#pragma warning( disable : 4786 )

#include "classfactory.h"
#include "instanceprovider.h"


LONG CClassFactory :: m_LockCount = 0 ;

//***************************************************************************
//
// Constructin / Destruction
//
//***************************************************************************

CClassFactory::CClassFactory ( int iFactoryType )
{
	m_RefCount = 0 ;
	
	ASSERT(iFactoryType==2) 

	m_iFactoryType = iFactoryType;
}

CClassFactory::~CClassFactory ()
{

}

//***************************************************************************
//
// 
//
//***************************************************************************

STDMETHODIMP CClassFactory::QueryInterface ( REFIID iid , 
											LPVOID FAR *iplpv ) 
{
	HRESULT hRes;
	*iplpv = NULL ;

	try	
	{
		if ( iid == IID_IUnknown )
			*iplpv = dynamic_cast<IUnknown*> (this);
		
		else if ( iid == IID_IClassFactory )
			*iplpv = dynamic_cast<IClassFactory*> (this);		

		if ( *iplpv )
		{
			( static_cast<IUnknown*> (*iplpv) )->AddRef () ;

			hRes = S_OK;
		}
		else
		{
			hRes = E_NOINTERFACE;
		}
	}
	catch( ... )
	{
		
		hRes = E_NOINTERFACE;
	}

	return hRes;
}


STDMETHODIMP_(ULONG) CClassFactory :: AddRef ()
{
	return InterlockedIncrement ( &m_RefCount ) ;
}

STDMETHODIMP_(ULONG) CClassFactory :: Release ()
{	
	LONG ref ;

	if ( ( ref = InterlockedDecrement ( & m_RefCount ) ) == 0 )
	{
		delete this ;
	}
	return ref ;
}

//***************************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & m_LockCount ) ;
	}
	else
	{
		InterlockedDecrement ( & m_LockCount ) ;
	}

	return S_OK	;
}

//***************************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
											 REFIID riid,
											 LPVOID FAR * ppvObject )
{
	HRESULT hRes = E_FAIL;

	if ( pUnkOuter )
	{
		return CLASS_E_NOAGGREGATION;
	}
		
	switch (m_iFactoryType)
	{
	case 2:
		{
			CInstanceProvider * pInstanceProvider = new CInstanceProvider ;
			if ( pInstanceProvider == NULL )
			{
				hRes = E_OUTOFMEMORY;
				break;
			}
			hRes = pInstanceProvider->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( hRes ) )
			{
				DBGINFOW((DBG_CONTEXT, L"Queryinterface failed inside CClassFactory::CreateInstance"));
				delete pInstanceProvider ;
			}
		}
	break;

	default:
		ASSERT(false && "Unknown factory type specified");
	break;
	}

	return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\cfgtablemeta.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgtablemeta.cpp

$Header: $

Abstract:
	Implementation of TableMeta class. Holds meta information for table and all 
	columns in that particular table.
Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include "cfgtablemeta.h"

//=================================================================================
// Function: CConfigTableMeta::CConfigTableMeta
//
// Synopsis: Constructor. Stores table name and dispenser information, but does not
//           initialize the object yet. You have to call Init to fully initialize the
//           object
//
// Arguments: [wszTableName] - Name of the table for which we want meta information
//            [pDispenser] - Dispenser to use
//=================================================================================
CConfigTableMeta::CConfigTableMeta (LPCWSTR i_wszTableName, 
									ISimpleTableDispenser2 *i_pDispenser)
{
	ASSERT (i_wszTableName != 0);
	ASSERT (i_pDispenser != 0);

	m_pTableName	= const_cast<LPWSTR>(i_wszTableName);
	m_spDispenser	= i_pDispenser;
	m_paColumnMeta	= 0;
	m_paPKInfo		= 0;
	m_cNrPKs		= 0;
	m_fInitialized	= false;
	memset (&m_TableMeta, 0x00, sizeof (tTABLEMETARow));
}

//=================================================================================
// Function: CConfigTableMeta::~CConfigTableMeta
//
// Synopsis: Destructor, releases memory
//=================================================================================
CConfigTableMeta::~CConfigTableMeta ()
{
	delete [] m_paColumnMeta;
	m_paColumnMeta = 0;

	delete [] m_paPKInfo;
	m_paPKInfo = 0;
}

//=================================================================================
// Function: CConfigTableMeta::Init
//
// Synopsis: Initializes the table meta information by retrieving the table meta
//           and column meta information for each column in the table. It also keeps
//           track of primary key information
//
// Return Value: S_OK, everything ok, non-S_OK else
//=================================================================================
HRESULT
CConfigTableMeta::Init ()
{
	ASSERT (!m_fInitialized);
	ASSERT (m_pTableName != 0);
	ASSERT (m_spDispenser != 0);

	// get table meta

	HRESULT hr = S_OK;
	
	STQueryCell cell;
	cell.pData		= (void *) m_pTableName;
	cell.eOperator	= eST_OP_EQUAL;
	cell.iCell		= iTABLEMETA_InternalName;
	cell.dbType		= DBTYPE_WSTR;
	cell.cbSize		= 0;
	ULONG cCell		= 1;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA,
								  &cell, (void *)&cCell, eST_QUERYFORMAT_CELLS, 0, (void **)&m_spISTTableMeta);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Failed to retrieve meta information for table %s", m_pTableName));
		return hr;
	}

	hr = m_spISTTableMeta->GetColumnValues (0, cTABLEMETA_NumberOfColumns, 0, 0, (void **) &m_TableMeta);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Failed to retrieve meta information for table %s", m_pTableName)); 
		return hr;
	}
	// get column meta

	hr = GetColumnInfo ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Failed to get column meta information for table %s", m_pTableName));
		return hr;
	}
	
	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CConfigTableMeta::GetColumnInfo
//
// Synopsis: Get column meta information for each column in the table
//=================================================================================
HRESULT 
CConfigTableMeta::GetColumnInfo ()
{
	ASSERT (!m_fInitialized);
	ASSERT (m_paColumnMeta == 0);
	ASSERT (m_paPKInfo == 0);
	ASSERT (m_cNrPKs == 0);

	// bail out when we don't need column information
	ULONG iColCount = *(m_TableMeta.pCountOfColumns);
	if (iColCount == 0)
	{
		// no columns, so nothing to retrieve
		return S_OK;
	}

	m_paColumnMeta = new tCOLUMNMETARow[iColCount];
	if (m_paColumnMeta == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_paPKInfo = new ULONG [iColCount];
	if (m_paPKInfo == 0)
	{
		return E_OUTOFMEMORY;
	}

	STQueryCell cell;
	cell.pData = (void *) m_TableMeta.pInternalName;
	cell.eOperator = eST_OP_EQUAL;
	cell.iCell = iCOLUMNMETA_Table;
	cell.dbType = DBTYPE_WSTR;
	cell.cbSize = 0;
	ULONG cCell = 1;

	HRESULT hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA,
								  &cell, (void *)&cCell, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTColumnMeta);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Failed to get column meta for table %s", m_TableMeta.pInternalName));
		return hr;
	}

	for (ULONG idx=0; idx < iColCount; ++idx)
	{
		hr = m_spISTColumnMeta->GetColumnValues (idx, cCOLUMNMETA_NumberOfColumns, 0, 0, (void **) &m_paColumnMeta[idx]);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Failed to get column meta for table %s", m_TableMeta.pInternalName));
			return hr;
		}
		ASSERT (idx == *m_paColumnMeta[idx].pIndex);

		// only count non_persistable columns
		if ((*m_paColumnMeta[idx].pMetaFlags & fCOLUMNMETA_PRIMARYKEY) &&
			!(*m_paColumnMeta[idx].pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE))
		{
			m_paPKInfo[m_cNrPKs++] = idx;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigTableMeta::ColumnCount
//
// Synopsis: Returns the number of columns in the table
//=================================================================================
ULONG
CConfigTableMeta::ColumnCount () const
{
	ASSERT (m_fInitialized);

	return *(m_TableMeta.pCountOfColumns);
}

LPCWSTR
CConfigTableMeta::GetPublicTableName () const
{
	ASSERT (m_fInitialized);

	return m_TableMeta.pPublicName;
}

//=================================================================================
// Function: CConfigTableMeta::PKCount
//
// Synopsis: Returns the number of primary key columns in the table
//=================================================================================
ULONG
CConfigTableMeta::PKCount () const
{
	ASSERT (m_fInitialized);

	return m_cNrPKs;
}

//=================================================================================
// Function: CConfigTableMeta::GetPKInfo
//
// Synopsis: Get primary key index information. This array should be treated as read-only
//           by the caller
//
// Return Value: array with primary key index information
//=================================================================================
ULONG *
CConfigTableMeta::GetPKInfo () const
{
	ASSERT (m_fInitialized);

	return m_paPKInfo;
}

//=================================================================================
// Function: CConfigTableMeta::GetColumnIndex
//
// Synopsis: Get the index of a column by searching by public name of the column.
//           A case insensitive search is done because WMI is case intensitive.
//
// Arguments: [wszColumnName] - Name of column to get index for
//            
// Return Value: column index if found, -1 if not found
//=================================================================================
ULONG
CConfigTableMeta::GetColumnIndex (LPCWSTR i_wszColumnName) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszColumnName != 0);

	for (ULONG idx=0; idx<ColumnCount (); ++idx)
	{
		if (_wcsicmp (m_paColumnMeta[idx].pPublicName, i_wszColumnName) == 0)
		{
			return idx;
		}
	}

	return (ULONG) -1;
}


//=================================================================================
// Function: CConfigTableMeta::GetColumnName
//
// Synopsis: Get the name of a column for a particular index
//
// Arguments: [idx] - column index for which we want the column name
//            
// Return Value: public column name
//=================================================================================
LPCWSTR
CConfigTableMeta::GetColumnName (ULONG i_idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >=0 && i_idx < ColumnCount());

	return m_paColumnMeta[i_idx].pPublicName;
}
	
//=================================================================================
// Function: CConfigTableMeta::GetColumnMeta
//
// Synopsis: Get column meta information for a particular column
//
// Arguments: [idx] - index of the column we want meta information for
//            
// Return Value: read only reference to column meta information
//=================================================================================
const tCOLUMNMETARow& 
CConfigTableMeta::GetColumnMeta (ULONG i_idx)
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >=0 && i_idx < ColumnCount());

	return m_paColumnMeta[i_idx];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\enumbase.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    enumbase.h

$Header: $

Abstract:
	Enumeration Helper. Makes it easy to enumerate instances of a class.

Author:
    murate 	05/01/2001		Initial Release

Revision History:

--**************************************************************************/

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "wmiobjectpathparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"

/**************************************************************************++
Class Name:
    CEnumBase

Class Description:
    Helper to create/delete/update single class instances

Constraints:

--*************************************************************************/
class CEnumBase
{
public:
	CEnumBase ();
	virtual ~CEnumBase ();

	HRESULT Init (const BSTR				i_bstrClass,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser);

	HRESULT CreateInstances();

    virtual HRESULT GetDatabaseAndTableName(IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName);

	HRESULT CreateAssociations ();

	bool IsAssociation () const;
	virtual bool HasDBQualifier () const;

protected:

	CEnumBase (const CEnumBase& );
	CEnumBase& operator= (const CEnumBase& );
    HRESULT CreateSingleInstance (const CConfigRecord& i_record, IWbemClassObject ** o_pInstance);

	_bstr_t 				        m_bstrClass;		    // class name.
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemObjectSink>		m_spResponseHandler;    // response handler for async notification
	CComPtr<IWbemClassObject>		m_spClassObject;        // class we're dealing with
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CConfigQuery					m_cfgQuery;				// query for the class
	long							m_lFlags;				// objectpath flags
	bool							m_fIsAssociation;		// are we association class?
	bool							m_fInitialized;			// are we initialized?
	bool							m_fHasDBQualifier;		// does the class has a DB Qualifer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\enumbase.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    enumbase.cpp

$Header: $

Abstract:

Author:
    murate 	05/01/2001		Initial Release

Revision History:

--**************************************************************************/

#include "enumbase.h"
#include "localconstants.h"
#include "stringutil.h"
#include "smartpointer.h"
#include "wmihelper.h"

//=================================================================================
// Function: CEnumBase::CEnumBase
//
// Synopsis: Default constructor
//=================================================================================
CEnumBase::CEnumBase ()
{
    m_lFlags            = 0;
	m_fIsAssociation	= false;
	m_fHasDBQualifier	= false;
	m_fInitialized		= false;
}

//=================================================================================
// Function: CEnumBase::~CEnumBase
//
// Synopsis: Default Destructor
//=================================================================================
CEnumBase::~CEnumBase ()
{
}

//=================================================================================
// Function: CEnumBase::Init
//
// Synopsis: Initializes the instance helper. Needs to be called before any other
//           functions defined for the InstanceHelper class.
//
// Arguments: [i_ObjectPath] - WMI Object path
//            [i_lFlags] - Flags 
//            [i_pCtx] - WMI Context
//            [i_pResponseHandler] - WMI Response handler for async response 
//            [i_pNamespace] - WMI Namespace
//            [i_pDispenser] - Catalog dispenser
//            
// Return Value: S_OK everything ok, non-S_OK error
//=================================================================================
HRESULT
CEnumBase::Init (const BSTR i_bstrClass, 
					   long i_lFlags,
					   IWbemContext *i_pCtx,
					   IWbemObjectSink * i_pResponseHandler,
					   IWbemServices * i_pNamespace,
					   ISimpleTableDispenser2 * i_pDispenser)
{
    HRESULT hr = S_OK;

	ASSERT (!m_fInitialized);
	ASSERT (i_bstrClass != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pDispenser != 0);

    m_bstrClass         = i_bstrClass;
	m_spCtx				= i_pCtx;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_spDispenser		= i_pDispenser;
	m_lFlags			= i_lFlags;
	
	hr = m_spNamespace->GetObject((LPWSTR)  i_bstrClass, 
											0, 
											m_spCtx, 
											&m_spClassObject, 
											0); 
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get class object for class %s", m_bstrClass));
		return hr;
	}

	CComPtr<IWbemQualifierSet> spQualifierSet;
	hr = m_spClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get Qualifier set for class %s", m_bstrClass));
		return hr;
	}
		
	_variant_t varAssoc;
	hr = spQualifierSet->Get (L"Association", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fIsAssociation = true;
	}
	else
	{
		hr = S_OK;
	}

	_variant_t varDB;
	hr = spQualifierSet->Get (L"Database", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fHasDBQualifier = true;
	}
	else
	{
		hr = S_OK;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CEnumBase::CreateInstances
//
// Synopsis: Creates all WMI Instances of a certain class.
//
// Arguments: [ppNewInst] - instance is returned in this parameter
//            
// Return Value: 
//=================================================================================
HRESULT
CEnumBase::CreateInstances ()
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;

	HRESULT hr = GetDatabaseAndTableName (m_spClassObject, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get database name and table name for class %s", m_bstrClass));
		return hr;
	}

	CConfigQuery cfgQuery;

	hr = cfgQuery.Init (bstrDBName,	bstrTableName, NULL, m_spDispenser);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to initialize Query"));
		return hr;
	}

	hr = cfgQuery.Execute (0, false, false);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Query Execution failed"));
		return hr;
	}

	for (ULONG idx=0; idx < cfgQuery.GetRowCount (); ++idx)
	{
		CConfigRecord record;
		hr = cfgQuery.GetColumnValues (idx, record);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to get column values for class %s", m_bstrClass));
			return hr;
		}

		CComPtr<IWbemClassObject> spNewInst;

		hr = CreateSingleInstance (record, &spNewInst);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to create single instance for class %s", m_bstrClass));
			return hr;
		}

		IWbemClassObject* pNewInstRaw = spNewInst;
		hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"WMI Indicate failed"));
		}
	}

	return hr;
}

HRESULT
CEnumBase::CreateSingleInstance (const CConfigRecord& i_record, IWbemClassObject ** o_pInstance)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pInstance != 0);

	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, o_pInstance);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create new instance for class %s", m_bstrClass));
		return hr;
	}

	for (ULONG idx=0; idx<i_record.ColumnCount(); ++idx)
	{
		// only persistable columns appear as properties, so we should only update
		// these properties
		if (i_record.IsPersistableColumn (idx))
		{
			LPCWSTR wszColName = i_record.GetColumnName (idx);

			_variant_t varValue;
			hr = i_record.GetValue (idx, varValue);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"Unable to get value for column %s", wszColName));
				return hr;
			}
			hr = (*o_pInstance)->Put((_bstr_t)wszColName, 0, &varValue, 0);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"WMI Put property of %s", wszColName));
				return hr;
			}
		}
	}

	return hr;
}

//=================================================================================
// Function: CEnumBase::IsAssociation
//
// Synopsis: Returns true if the instance is an association, false if not
//=================================================================================
bool
CEnumBase::IsAssociation () const
{
	ASSERT (m_fInitialized);

	return m_fIsAssociation;
}


//=================================================================================
// Function: CEnumBase::CreateAssociation
//
// Synopsis: Creates an association. Simple copy the input information to the output
//           information.
//
// Return Value: 
//=================================================================================
HRESULT
CEnumBase::CreateAssociations ()
{
	ASSERT (m_fInitialized);
	
	return S_OK;
}

//=================================================================================
// Function: CEnumBase::GetDatabaseAndTableName
//
// Synopsis: Retrieve the config database and table name that corresponds to this 
//              WMI class.
//
// Return Value: 
//=================================================================================
HRESULT CEnumBase::GetDatabaseAndTableName(IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName)
{
    i_bstrDBName = wszDATABASE_AppCenter;
    i_bstrTableName = m_bstrClass;

	return S_OK;
}

bool 
CEnumBase::HasDBQualifier () const
{
	ASSERT (m_fInitialized);

	return m_fHasDBQualifier;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\impersonate.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    impersonate.h

$Header: $

Abstract:
	Helper class for CoImpersonateClient and CoRevertToSelf. These functions don't work
	on Win9X/WinME, but we need to check for them in NT. This class wraps the functionality, so
	that you can safely call them from both NT and 9X.

Author:
    marcelv 	2/22/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __IMPERSONATE_H__
#define __IMPERSONATE_H__

#pragma once

#include "catmacros.h"

class CImpersonator
{
public:
	CImpersonator ();
	~CImpersonator ();

	HRESULT ImpersonateClient () const;
private:
	CImpersonator(const CImpersonator& );
	CImpersonator& operator= (const CImpersonator&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\instanceprovider.h ===
//***************************************************************************
//
//  InstanceProvider.h
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _COMPLUS_InstanceProvider_H
#define _COMPLUS_InstanceProvider_H

#include <atlbase.h>
#include <comutil.h>
#include "catmacros.h"
#include "catalog.h"
#include <wbemidl.h>

//***************************************************************************
//
//This clas represents the Instance Provider implemented in this DLL 
//
//***************************************************************************
class CInstanceProvider : public IWbemServices, public IWbemProviderInit
{
public:
	static	LONG m_ObjCount;

private:
	CComPtr<IWbemServices>			m_spNamespace;
	CComPtr<ISimpleTableDispenser2> m_spDispenser;
	LONG m_RefCount;

public:

	CInstanceProvider();
	~CInstanceProvider(); 

	//interface methods
	//==================

	/* IUnknown methods */

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	/* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

    HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pNamespace,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink   // For init signals
			);

private:
    HRESULT InternalGetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler) ;

	HRESULT InternalExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) ;
   
	HRESULT InternalDeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler) ;
    
	HRESULT InternalPutInstanceAsync( 
            /* [in] */ IWbemClassObject  *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler) ;

	HRESULT InternalExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE InternalCreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

	void SetStatus(
			/* [in] */ HRESULT hrReturn,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler );

	_variant_t GetDescrForHr (HRESULT hr) const;
};

#endif //_COMPLUS_InstanceProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\impersonate.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    impersonate.cpp

$Header: $

Abstract:

Author:
    marcelv 	2/22/2001		Initial Release

Revision History:

--**************************************************************************/

#include "impersonate.h"

static bool g_fOnNT		= false; // are we on NT or not
static bool g_fChecked	= false; // did we already check if we are on NT?

//=================================================================================
// Function: CImpersonator::CImpersonator
//
// Synopsis: Constructor. Do nothing
//
//=================================================================================
CImpersonator::CImpersonator ()
{
}

//=================================================================================
// Function: CImpersonator::~CImpersonator
//
// Synopsis: RevertToSelf in case we are on NT
//
//=================================================================================
CImpersonator::~CImpersonator ()
{
	if (g_fOnNT)
	{
		HRESULT hr = CoRevertToSelf ();
		if (FAILED (hr))
		{
			// we can only trace .. no point to return error message at this point
			DBGINFOW((DBG_CONTEXT, L"CoRevertToSelf failed"));
		}
	}
}

//=================================================================================
// Function: CImpersonator::ImpersonateClient
//
// Synopsis: If we are on NT, Call CoImpersonateClient.
//
// Return Value: 
//=================================================================================
HRESULT
CImpersonator::ImpersonateClient () const
{
	HRESULT hr = S_OK;

	// check if we are on NT. We only do this once, because if we know if we are on NT, we
	// don't have to check all the time. 
	if (!g_fChecked)
	{
		OSVERSIONINFO versionInfo;
		versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);

		BOOL fSuccess = GetVersionEx (&versionInfo);
		if (!fSuccess)
		{
			DBGINFOW((DBG_CONTEXT, L"GetVersionEx failed"));
			hr = HRESULT_FROM_WIN32(GetLastError());
			return hr;
		}

		if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			g_fOnNT = true;
		}

		g_fChecked = true;
	}

	if (g_fOnNT)
	{
		hr = CoImpersonateClient ();
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"CoImpersonateClient failed"));
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Purpose: Contains the gloabal DLL functions
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "catmacros.h"
#include <initguid.h>
#include "providerguids.h"
#include "classfactory.h"
#include "atlimpl.cpp"
#include "localconstants.h"
#include "instanceprovider.h"

// This is already in appsrvadmlib.lib
// DECLARE_DEBUG_PRINTS_OBJECT();

BOOL SetKeyAndValue( 
		/*[in]*/ const wchar_t* pszKey, 
		/*[in]*/ const wchar_t* pszSubkey, 
		/*[in]*/ const wchar_t* pszValueName, 
		/*[in]*/ const wchar_t* pszValue );

//Exports ( with "maindll.def" ) 
STDAPI DllGetClassObject ( REFCLSID rclsid , REFIID riid, void **ppv );
STDAPI DllCanUnloadNow (void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);

//Also Implements
BOOL APIENTRY DllMain ( HINSTANCE hInstance, ULONG ulReason , LPVOID pvReserved );

//We need this global
HINSTANCE   g_hInst = NULL;
HMODULE		g_hModule = NULL;

//Strings used during self registeration
static LPCWSTR HKEYCLASSES_STR		  =	L"SOFTWARE\\Classes\\";
static LPCWSTR REG_FORMAT2_STR        =	L"%s%s";
static LPCWSTR REG_FORMAT3_STR        =   L"%s%s\\%s";
static LPCWSTR VER_IND_STR            =   L"VersionIndependentProgID";
static LPCWSTR NOT_INTERT_STR         =   L"NotInsertable";
static LPCWSTR INPROC32_STR           =   L"InprocServer32";
static LPCWSTR PROGID_STR             =   L"ProgID";
static LPCWSTR THREADING_MODULE_STR   =   L"ThreadingModel";
static LPCWSTR APARTMENT_STR          =   L"Both";
static LPCWSTR CLSID_STR              =   L"CLSID\\";

//***************************************************************************
//
// DllMain
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (	HINSTANCE hInstance, ULONG ulReason , LPVOID /*pvReserved */)
{
	switch(ulReason) {

	case DLL_PROCESS_ATTACH:
		g_hInst=hInstance;
		DisableThreadLibraryCalls(hInstance);
		CREATE_DEBUG_PRINT_OBJECT("NetProvider", CLSID_CProvider);
		break;
	
	case DLL_PROCESS_DETACH:
		DELETE_DEBUG_PRINT_OBJECT();
		break;
	}
	
	return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by COM when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//  The two COM classes implemented here are ClassProvider and InstanceProvider
//  They require exactly the same type of class factory. Therefore I am using
//  a single class which implements IClassFactory interface ...
//
//***************************************************************************

STDAPI DllGetClassObject ( REFCLSID rclsid, REFIID riid, void **ppv )
{
	HRESULT hRes=S_OK;
    CClassFactory *pObj=NULL;

	*ppv = 0;

	if ( rclsid == CLSID_CProvider )
	{
		pObj=new CClassFactory( 2 );
		if (pObj == 0)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
	   return CLASS_E_CLASSNOTAVAILABLE;
	}

    hRes=pObj->QueryInterface(riid, ppv);

    if ( FAILED(hRes) )
        delete pObj;

    return hRes;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by COM in order to determine if the
//          DLL can be freed.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow (void)
{	
	if (CInstanceProvider::m_ObjCount != 0 || CClassFactory::m_LockCount != 0 )
	{
		return S_FALSE;
	}

	return S_OK;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer(void)
{

	TCHAR szModule[MAX_PATH + 1];
	GetModuleFileName(g_hInst,(LPTSTR) szModule, MAX_PATH + 1);
	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	//register the instance provider 
	StringFromGUID2(CLSID_CProvider, szProviderClassID, 128);
	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);
	//
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_LONGNAME))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL, (wchar_t*) _bstr_t(szModule) ))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK ;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	wchar_t szTemp[512];
	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	//unregister the instance provider 
	StringFromGUID2(CLSID_CProvider, szProviderClassID, 128);
	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);
	//
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, PROVIDER_CVER);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, PROVIDER_CLSID);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, PROVIDER);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	//
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, PROVIDER_VER_CLSID);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, PROVIDER_VER);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	//
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, PROGID_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, VER_IND_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, NOT_INTERT_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, szProviderCLSIDClassID);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);

	return S_OK ;
 }

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          the name of the key
 *  pszSubkey       the name of a subkey
 *  pszValueName	the name of the  value
 *  pszValue        the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 *
 * Remark
 *  Unicode specific ...
 *
 ***************************************************************************/

BOOL SetKeyAndValue( 
		/*[in]*/ const wchar_t* pszKey, 
		/*[in]*/ const wchar_t* pszSubkey, 
		/*[in]*/ const wchar_t* pszValueName, 
		/*[in]*/ const wchar_t* pszValue )
{

    HKEY        hKey;
    wchar_t     szKey[256];
	BOOL		bResult = TRUE;

	wcscpy(szKey, HKEYCLASSES_STR);
    wcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
										 (LPCTSTR) _bstr_t(szKey), 
										 0, NULL, REG_OPTION_NON_VOLATILE, 
										 KEY_ALL_ACCESS, NULL, 
										 &hKey, 
										 NULL) )
	{
        bResult = FALSE;
	}
	else
	{
		if (NULL != pszValue)
		{
			DWORD cbData;

			cbData = ( 1+ _bstr_t(pszValue).length() ) * sizeof(TCHAR);

			if ( ERROR_SUCCESS != RegSetValueEx( hKey, 
												 (LPCTSTR) _bstr_t( pszValueName ), 
												 0, 
												 REG_SZ, 
												 (BYTE *) (LPCTSTR) _bstr_t(pszValue),
												 cbData) )
			bResult = FALSE;
		}

		RegCloseKey(hKey);
	}

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\instancebase.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    instancehelper.h

$Header: $

Abstract:
	Instance Helper. Makes it easy to create/update/delete single class instances

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __INSTANCEBASE_H__
#define __INSTANCEBASE_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "wmiobjectpathparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"

/**************************************************************************++
Class Name:
    CInstanceBase

Class Description:
    Helper to create/delete/update single class instances

Constraints:

--*************************************************************************/
class CInstanceBase
{
public:
	CInstanceBase ();
	virtual ~CInstanceBase ();

	HRESULT Init (const BSTR				i_ObjectPath,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser);

	HRESULT CreateInstance (IWbemClassObject **pNewInst);
	HRESULT DeleteInstance ();
	HRESULT PutInstance (IWbemClassObject * i_pInst);

    virtual HRESULT GetDatabaseAndTableName(IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName);

//	HRESULT CreateStaticInstance ();

//	HRESULT CreateWebApp ();
//	HRESULT DeleteWebApp ();
//	HRESULT PutInstanceWebApp (IWbemClassObject *pInst);

	HRESULT CreateAssociation ();

	bool IsAssociation () const;
	virtual bool HasDBQualifier () const;

protected:
	HRESULT CreateSingleInstance (const CConfigRecord& i_record,
								  IWbemClassObject **ppNewInst);
	HRESULT GetSingleRecord (ULONG *o_pcRow, bool i_fWriteAccess);
//	HRESULT CreateConfigurationFile ();
	HRESULT PopulateConfigRecord (IWbemClassObject * i_pInst, CConfigRecord& record);

	// SPECIAL CASE FOR SINGLE CLASS
//	HRESULT CreateCodeGroupInstance (const CConfigRecord& record, IWbemClassObject **o_ppNewInst);
//	HRESULT PopulateCodeGroupRecord (IWbemClassObject * i_pInst, CConfigRecord& record);

	CInstanceBase (const CInstanceBase& );
	CInstanceBase& operator= (const CInstanceBase& );

	CObjectPathParser				m_objPathParser;		// object path parser
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemObjectSink>		m_spResponseHandler;    // response handler for async notification
	CComPtr<IWbemClassObject>		m_spClassObject;        // class we're dealing with
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CConfigQuery					m_cfgQuery;				// query for the class
	long							m_lFlags;				// objectpath flags
	bool							m_fIsAssociation;		// are we association class?
	bool							m_fInitialized;			// are we initialized?
	bool							m_fHasDBQualifier;		// does the class has a DB Qualifer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\instancebase.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    instancehelper.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#include "instancebase.h"
#include "localconstants.h"
#include "stringutil.h"
#include "smartpointer.h"
#include "wmihelper.h"
//#include "webapphelper.h"

//#include "codegrouphelper.h"

//=================================================================================
// Function: CInstanceBase::CInstanceBase
//
// Synopsis: Default constructor
//=================================================================================
CInstanceBase::CInstanceBase ()
{
	m_fIsAssociation	= false;
	m_fHasDBQualifier	= false;
	m_fInitialized		= false;
}

//=================================================================================
// Function: CInstanceBase::~CInstanceBase
//
// Synopsis: Default Destructor
//=================================================================================
CInstanceBase::~CInstanceBase ()
{
}

//=================================================================================
// Function: CInstanceBase::Init
//
// Synopsis: Initializes the instance helper. Needs to be called before any other
//           functions defined for the InstanceHelper class.
//
// Arguments: [i_ObjectPath] - WMI Object path
//            [i_lFlags] - Flags 
//            [i_pCtx] - WMI Context
//            [i_pResponseHandler] - WMI Response handler for async response 
//            [i_pNamespace] - WMI Namespace
//            [i_pDispenser] - Catalog dispenser
//            
// Return Value: S_OK everything ok, non-S_OK error
//=================================================================================
HRESULT
CInstanceBase::Init (const BSTR i_ObjectPath, 
					   long i_lFlags,
					   IWbemContext *i_pCtx,
					   IWbemObjectSink * i_pResponseHandler,
					   IWbemServices * i_pNamespace,
					   ISimpleTableDispenser2 * i_pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (i_ObjectPath != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pDispenser != 0);

	m_spCtx				= i_pCtx;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_spDispenser		= i_pDispenser;
	m_lFlags			= i_lFlags;
	
	HRESULT hr = m_objPathParser.Parse (i_ObjectPath);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Parsing of object path %s failed", i_ObjectPath));
		return hr;
	}

	ASSERT (m_objPathParser.GetClass () != 0);

	hr = m_spNamespace->GetObject((LPWSTR) m_objPathParser.GetClass (), 
											0, 
											m_spCtx, 
											&m_spClassObject, 
											0); 
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get class object for class %s", m_objPathParser.GetClass ()));
		return hr;
	}

	CComPtr<IWbemQualifierSet> spQualifierSet;
	hr = m_spClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get Qualifier set for class %s", m_objPathParser.GetClass ()));
		return hr;
	}
		
	_variant_t varAssoc;
	hr = spQualifierSet->Get (L"Association", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fIsAssociation = true;
	}
	else
	{
		hr = S_OK;
	}

	_variant_t varDB;
	hr = spQualifierSet->Get (L"Database", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fHasDBQualifier = true;
	}
	else
	{
		hr = S_OK;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CInstanceBase::CreateInstance
//
// Synopsis: Creates a single WMI Instance
//
// Arguments: [ppNewInst] - instance is returned in this parameter
//            
// Return Value: 
//=================================================================================
HRESULT
CInstanceBase::CreateInstance (IWbemClassObject **o_ppNewInst)
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);
	ASSERT (o_ppNewInst != 0);

	*o_ppNewInst = 0;

	// getSingleRecord initilizes m_cfgQuery and gets the record from the catalog.
	// if the record does not exist, GetSingleRecord will fail.

	ULONG cRowIdx; //index of record found
	HRESULT hr = GetSingleRecord (&cRowIdx, false);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get single record from catalog"));
		if (hr == E_ST_NOMOREROWS)
		{
			hr = WBEM_E_NOT_FOUND;
		}
		return hr;
	}

	// we found the record. Retrieve the actual column values, and create a WMI
	// instance of the record

	CConfigRecord record;
	hr = m_cfgQuery.GetColumnValues (cRowIdx, record);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get column values for record %ld", cRowIdx));
		return hr;
	}
/*
	//////////// SPECIAL CASE CODEGROUPS //////
	//// 

	if (_wcsicmp (m_objPathParser.GetClass (), WSZCODEGROUP) == 0)
	{
		return CreateCodeGroupInstance (record, o_ppNewInst);
	}

*/
	hr = CreateSingleInstance (record, o_ppNewInst);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create single instance"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceBase::CreateSingleInstance
//
// Synopsis: Create a WMI Instance from a configuration record
//
// Arguments: [record] - record to convert to WMI Instance
//            [o_ppNewInst] - new WMI Instance will be stored here
//=================================================================================
HRESULT
CInstanceBase::CreateSingleInstance (const CConfigRecord& i_record,
									   IWbemClassObject **o_ppNewInst)
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);
	ASSERT (o_ppNewInst != 0);
	
	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, o_ppNewInst);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create new instance for class %s", m_objPathParser.GetClass ()));
		return hr;
	}

	// add all the individual properties
	for (ULONG idx=0; idx<i_record.ColumnCount(); ++idx)
	{
		if (i_record.IsPersistableColumn (idx))
		{
			LPCWSTR wszColName	= i_record.GetColumnName (idx);
			_variant_t varValue;
			hr = i_record.GetValue (idx, varValue);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"Unable to get value for column %s", wszColName));
				return hr;
			}

			hr = (*o_ppNewInst)->Put((_bstr_t)wszColName, 0, &varValue, 0);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"WMI Put property of %s and value %s failed",
					   wszColName, (LPWSTR)((_bstr_t) varValue)));
				return hr;
			}
		}
	}

	// and add the selector
	const CWMIProperty *pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	_variant_t varSelector = pSelector->GetValue ();
	hr = (*o_ppNewInst)->Put ((_bstr_t)WSZSELECTOR, 0, &varSelector, 0);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"WMI Put Property of selector failed (value = %s)", pSelector->GetValue ()));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceBase::DeleteInstance
//
// Synopsis: Delete a single WMI INstance from the configuration store
//=================================================================================
HRESULT
CInstanceBase::DeleteInstance ()
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);

	// getSingleRecord initilizes m_cfgQuery. And figures out if the record does
	// actually exist in the configuration store
	
	ULONG cRowIdx; //index of record found

	HRESULT hr = GetSingleRecord (&cRowIdx, true);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get instance record from catalog"));
		return hr;
	}

	hr = m_cfgQuery.DeleteRow (cRowIdx);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to delete row"));
		return hr;
	}

	hr = m_cfgQuery.SaveSingleRow ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to save"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceBase::PutInstance
//
// Synopsis: Creates a new record in the configuration store from a WMI instance
//
// Arguments: [i_pInst] - WMI Instance to create config record for
//=================================================================================
HRESULT
CInstanceBase::PutInstance (IWbemClassObject * i_pInst)
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);
	ASSERT (i_pInst != 0);

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;
	HRESULT hr = CWMIHelper::GetClassInfo (m_spClassObject, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get database name and table name for %s", m_objPathParser.GetClass ()));
		return hr;
	}

	_variant_t varSelector;
	hr = i_pInst->Get(WSZSELECTOR, 0, &varSelector, 0 , 0);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get selector property"));
		return hr;
	}

	hr = m_cfgQuery.Init (bstrDBName, bstrTableName, _bstr_t (varSelector), m_spDispenser);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) bstrDBName, (LPWSTR) bstrTableName));
		return hr;
	}

	CConfigRecord record;
	hr = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get empty configuration record"));
		return hr;
	}

/*	//////////// SPECIAL CODE FOR CodeGroup //////////////////////
	if (_wcsicmp (m_objPathParser.GetClass (), WSZCODEGROUP) == 0)
	{
		hr = PopulateCodeGroupRecord (i_pInst, record);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to populate codegroup record"));
			return hr;
		}
	}
	else
*/	{
		hr = PopulateConfigRecord (i_pInst, record);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to populate codegroup record"));
			return hr;
		}
	}


	hr = m_cfgQuery.Execute (&record, true, true);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Execution of query failed"));
		return hr;
	}

	ULONG cReadRow = (ULONG) -1;
	if (m_cfgQuery.GetRowCount () != 0)
	{
		ASSERT (m_cfgQuery.GetRowCount () == 1);
		cReadRow = 0;
	}
	
	hr = m_cfgQuery.UpdateRow (cReadRow, record, m_lFlags);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"UpdateRow failed"));
		return hr;
	}

	hr = m_cfgQuery.SaveSingleRow ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Save failed"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceBase::IsAssociation
//
// Synopsis: Returns true if the instance is an association, false if not
//=================================================================================
bool
CInstanceBase::IsAssociation () const
{
	ASSERT (m_fInitialized);

	return m_fIsAssociation;
}

//=================================================================================
// Function: CInstanceBase::GetSingleRecord
//
// Synopsis: Get a single record from the config store. o_record contains the primary
//           key column values so that the record can be retrieved
//
// Arguments: [o_pcRow] - index of record that was found
//            
// Return Value: 
//=================================================================================
HRESULT
CInstanceBase::GetSingleRecord (ULONG *o_pcRow, bool i_fWriteAccess)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcRow != 0);
	ASSERT (!m_fIsAssociation);

	*o_pcRow = (ULONG) -1;

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;
	HRESULT hr = GetDatabaseAndTableName (m_spClassObject, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get DBName and TableName"));
		return hr;
	}

/*	const CWMIProperty * pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		DBGINFOW((DBG_CONTEXT, L"Objectpath without Selector"));
		return E_INVALIDARG;
	}

*/	hr = m_cfgQuery.Init (bstrDBName, bstrTableName, NULL, m_spDispenser);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Query Initialization failed"));
		return hr;
	}
	
	CConfigRecord record;
	
	hr  = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get empty configuration record"));
		return hr;
	}

	for (ULONG idx=0; idx != m_objPathParser.GetPropCount (); ++idx)
	{
		const CWMIProperty * pProp = m_objPathParser.GetProperty (idx);
		record.SetValue (pProp->GetName (), pProp->GetValue()); // ignore errors
	}

	hr = m_cfgQuery.Execute (&record, true, i_fWriteAccess);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Query Execution failed"));
		return hr;
	}

	// at this point, we either found a single row or nothing. So check how many rows
	// we have. If we don't have any rows, we return an error, else we return a pointer
	// to the single row

	if (m_cfgQuery.GetRowCount () != 1)
	{
		ASSERT (m_cfgQuery.GetRowCount () == 0);
		return E_ST_NOMOREROWS;
	}

	*o_pcRow = 0;


	return hr;
}

//=================================================================================
// Function: CInstanceBase::CreateAssociation
//
// Synopsis: Creates an association. Simple copy the input information to the output
//           information.
//
// Return Value: 
//=================================================================================
HRESULT
CInstanceBase::CreateAssociation ()
{
	ASSERT (m_fInitialized);
	
	CComPtr<IWbemClassObject> spNewInst;

	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create new instance for class %s", m_objPathParser.GetClass ()));
		return hr;
	}

	// copy each property to the new instance
	for (ULONG idx=0; idx < m_objPathParser.GetPropCount (); ++idx)
	{
		const CWMIProperty * pProp = m_objPathParser.GetProperty (idx);
		_variant_t varValue = pProp->GetValue ();

		hr = spNewInst->Put(pProp->GetName (), 0, &varValue, 0);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Put failed when creating WMI Assocation"));
			return hr;
		}
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);

	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"WMI Indicate failed"));
	}

	return hr;
}

//=================================================================================
// Function: CInstanceBase::CreateAssociation
//
// Synopsis: Retrieve the config database and table name that corresponds to this 
//              WMI class.
//
// Return Value: 
//=================================================================================
HRESULT CInstanceBase::GetDatabaseAndTableName(IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName)
{
	return CWMIHelper::GetClassInfo (m_spClassObject, i_bstrDBName, i_bstrTableName);
}

/*
HRESULT CInstanceBase::CreateStaticInstance ()
{
	HRESULT hr = S_OK;
	if (_wcsicmp (m_objPathParser.GetClass (), L"WebApplication") == 0)
	{
		// probably other class.
		hr = CreateWebApp ();
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Error while creating web app instance"));
			return hr;
		}
	}
	else if (_wcsicmp (m_objPathParser.GetClass (), L"ConfigurationFile") == 0)
	{
		hr = CreateConfigurationFile ();
		if (FAILED (hr))
		{
			return hr;
		}
	}
	else
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create configuration class: %s", m_objPathParser.GetClass ()));
	}

	return hr;
}

HRESULT
CInstanceBase::CreateWebApp ()
{
	if (_wcsicmp (m_objPathParser.GetClass (), L"WebApplication") != 0)
	{
		return S_OK;
	}

	HRESULT hr = S_OK;
	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		return hr;
	}

	const CWMIProperty * pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		DBGINFOW((DBG_CONTEXT, L"Object path doesn't have selector"));
		return E_INVALIDARG;
	}

	hr = webAppHelper.CreateSingleInstance (pSelector->GetValue ());
	if (FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"CreateSingleInstance of webAppHelper failed"));
		return hr;
	}

	return hr;
}

HRESULT
CInstanceBase::CreateConfigurationFile ()
{
	ASSERT (m_fInitialized);
	
	CComPtr<IWbemClassObject> spNewInst;

	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create new instance for class %s", m_objPathParser.GetClass ()));
		return hr;
	}

	// copy each property to the new instance
	for (ULONG idx=0; idx < m_objPathParser.GetPropCount (); ++idx)
	{
		const CWMIProperty * pProp = m_objPathParser.GetProperty (idx);
		_variant_t varValue = pProp->GetValue ();

		hr = spNewInst->Put(pProp->GetName (), 0, &varValue, 0);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Put failed when creating WMI Assocation"));
			return hr;
		}
	}

	// and add the path property
	const CWMIProperty * pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get Selector property"));
		return E_INVALIDARG;
	}

	LPCWSTR wszSelector = pSelector->GetValue ();

	// only set path if selector starts with 'file://"
	static LPCWSTR wszFileProtocol = L"file://";
	static SIZE_T cLenFileProtocol = wcslen (wszFileProtocol);

	if (wcsncmp (wszSelector, wszFileProtocol, cLenFileProtocol) == 0)
	{
		_variant_t varPath = wszSelector + cLenFileProtocol;
		hr = spNewInst->Put (L"Path", 0, &varPath, 0);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to set 'Path' property"));
			return hr;
		}
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);

	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"WMI Indicate failed"));
	}

	return hr;
}



HRESULT
CInstanceBase::DeleteWebApp ()
{
	if (_wcsicmp (m_objPathParser.GetClass (), L"WebApplication") != 0)
	{
		return S_OK;
	}

	HRESULT hr = S_OK;
	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to initialize web application"));
		return hr;
	}

	hr = webAppHelper.Delete (m_objPathParser);
	if (FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to delete webapplication"));
		return hr;
	}

	return hr;
}

HRESULT
CInstanceBase::PutInstanceWebApp (IWbemClassObject *pInst)
{
	ASSERT (pInst != 0);

	// only handle WebApplication class
	_variant_t varClassName;
	HRESULT hr = pInst->Get(L"__class", 0, &varClassName, 0 , 0);
	if (_wcsicmp (varClassName.bstrVal, L"WebApplication") != 0)
	{
		return S_OK;
	}

	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to initialize web application"));
		return hr;
	}

	hr = webAppHelper.PutInstance (pInst);
	if (FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create webapplication"));
		return hr;
	}

	return hr;
}
*/
bool 
CInstanceBase::HasDBQualifier () const
{
	ASSERT (m_fInitialized);

	return m_fHasDBQualifier;
}

//=================================================================================
// Function: CInstanceBase::PopulateConfigRecord
//
// Synopsis: Populate a config record from a WMI instance. Simply walk through all the
//           properties, and assign the to the properties in the config record
//
// Arguments: [i_pInst] - WMI instance to be converted
//            [record] - record that is going to contain the new information
//=================================================================================
HRESULT
CInstanceBase::PopulateConfigRecord (IWbemClassObject * i_pInst, CConfigRecord& record)
{
	ASSERT (i_pInst != 0);

	// loop through all values in the object, and save to the record
	HRESULT hr = m_spClassObject->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY);
	if (FAILED(hr))
	{
		DBGINFOW((DBG_CONTEXT, L"BeginEnumeration failed for class %s", m_objPathParser.GetClass ()));
		return hr;
	}


	hr = 0;
	while (SUCCEEDED (hr))
	{
		CComBSTR bstrName;
		hr = m_spClassObject->Next (0, &bstrName, 0, 0, 0);
		if (hr == WBEM_S_NO_MORE_DATA)
		{
			// we went over all properties
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"IWbemClassObject::Next failed in PutInstance"));
			return hr;
		}
	
		_variant_t varValue;
		hr = i_pInst->Get(bstrName, 0, &varValue, 0, 0);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to get WMI value for %s", bstrName));
			return hr;
		}

		record.SetValue (bstrName, varValue); // ignore errors because properties might not be present
	}

	// release resources
	hr = m_spClassObject->EndEnumeration ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"EndEnumeration failed"));
		return hr;
	}

	return hr;
}

/*
///////////////// SPECIAL CASE for code groups//////////////////////////////

//=================================================================================
// Function: CInstanceBase::CreateCodeGroupInstance
//
// Synopsis: Creates an instance of class CodeGroup from a configrecord. This class needs
//           special casing because codegroup information is written as an XML BLob to the
//           xml file.
//
// Arguments: [record] - record that contains XML BLOB that needs to be converted to
//                       WMI Instance
//            [o_ppNewInst] - new instance to be created
//            
// Return Value: 
//=================================================================================
HRESULT 
CInstanceBase::CreateCodeGroupInstance (const CConfigRecord& record, IWbemClassObject **o_ppNewInst)
{
	ASSERT (o_ppNewInst != 0);

	CCodeGroupHelper codegroupHelper;

	HRESULT hr = codegroupHelper.Init (m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Init of codegroupHelper failed"));
		return hr;
	}

	const CWMIProperty *pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	hr = codegroupHelper.CreateInstance (record, pSelector->GetValue (), o_ppNewInst);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create codegroup instance"));
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceBase::PopulateCodeGroupRecord
//
// Synopsis: Populates a config record from a WMI Instance. Special casing for CodeGroup
//           class
//
// Arguments: [i_pInst] - instance with codegroup information
//            [record] - record to be populated
//            
// Return Value: 
//=================================================================================
HRESULT
CInstanceBase::PopulateCodeGroupRecord (IWbemClassObject *i_pInst, CConfigRecord& record)
{
	ASSERT (i_pInst != 0);

	CCodeGroupHelper codegroupHelper;

	HRESULT hr = codegroupHelper.Init (m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Init of codegroupHelper failed"));
		return hr;
	}

	hr = codegroupHelper.PutInstance (i_pInst, record);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to create codegroup instance"));
		return hr;
	}

	return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\instanceprovider.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    InstanceProvider.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#pragma warning(disable: 4100)  //unreferenced formal parameter

#include "InstanceProvider.h"
#include <comutil.h>
#include "wmiobjectpathparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"
#include "wqlparser.h"
//#include "instancehelper.h"
//#include "queryhelper.h"
//#include "methodhelper.h"
#include "localconstants.h"
#include "resource.h"
//#include "webapphelper.h"
#include "impersonate.h"

//Define the static prop.
LONG CInstanceProvider :: m_ObjCount = 0 ;

static LPWSTR g_wszProductID = L"NetFrameworkv1";
extern HINSTANCE   g_hInst;

//***************************************************************************
//
// Constructor
//
//*************************************************************************** 
CInstanceProvider::CInstanceProvider()
{
	m_RefCount = 0;
	InterlockedIncrement(&m_ObjCount);
}


//***************************************************************************
//
// Destructor
//
//*************************************************************************** 
CInstanceProvider::~CInstanceProvider()
{
	InterlockedDecrement(&m_ObjCount);
}


//***************************************************************************
//
// IUnknown methods 
//
//*************************************************************************** 
STDMETHODIMP_( ULONG ) CInstanceProvider::AddRef()
{

	ULONG nNewCount = InterlockedIncrement ( &m_RefCount ) ;
	return nNewCount;
}


//***************************************************************************
//
// 
//
//*************************************************************************** 
STDMETHODIMP_(ULONG) CInstanceProvider::Release()
{

	
	ULONG nNewCount = InterlockedDecrement((long *)&m_RefCount);
    if (0L == nNewCount)
	{
        delete this;
		// unload the dispenser DLL (catalog.dll), because we have only a single
		// provider. In case we have multiple providers in this DLL we have to
		// mode the UnloadDispenserDll function to somewhere else to avoid crashes
		// Also, the UnloadDispenserDLL need to be called after delete this (and not 
		// in the destructor, because the smartpointer for the Dispenser is deleted
		// after the code in the desctructor is executed. If UnloadDispenserDll would
		// be in the destructor, it would unload the DLL before called Release on the
		// dispenser, causing the dll to blow up.
		UnloadDispenserDll (g_wszProductID);
	}
	
	return nNewCount;
}

//***************************************************************************
//
// 
//
//*************************************************************************** 
STDMETHODIMP CInstanceProvider::QueryInterface(REFIID riid, PVOID* ppv)
{

		*ppv = NULL;

		if (IID_IUnknown == riid)
		{
			*ppv=(IWbemServices*)this;
		}
		else if (IID_IWbemProviderInit == riid)
		{
			*ppv= (IWbemProviderInit*)this;
		}
		else if (IID_IWbemServices == riid)
		{
			*ppv= (IWbemServices*)this;
		}
		else
		{
			return E_NOINTERFACE;
		}

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();	
		return NOERROR;
}
//***************************************************************************
//
// CInstanceProvider::Initialize [IInstanceProviderInit]
//
// Purpose: Performs the provider's initialization
//
//***************************************************************************  
STDMETHODIMP CInstanceProvider::Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pNamespace,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink   // For init signals
				)
{
	ASSERT (pNamespace != 0);
	ASSERT (pInitSink != 0);
	ASSERT (pCtx != 0);

	DBGINFOW((DBG_CONTEXT, L"Initializing Provider"));

	CImpersonator impersonator;
	HRESULT hr = impersonator.ImpersonateClient ();
	if (SUCCEEDED (hr))
	{
		m_spNamespace = pNamespace;

		// namespace is of form root/<namespacename>. We need to get rid of the root part
		// to query for the correct dispenser
		LPCWSTR pszNSStart = wcsrchr (pszNamespace, L'\\');
		if (pszNSStart != 0)
		{
			pszNSStart++;
		}
		else
		{
			pszNSStart = pszNamespace;
		}

//		hr = GetSimpleTableDispenser ((LPWSTR)pszNSStart, 0, &m_spDispenser);
	}

	//attempt failed ... or succeeded ?!
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization of NET Provider failed !!! hr=0x%08x", hr));
		hr=WBEM_E_FAILED;
		//Let CIMOM know we have failed
		pInitSink->SetStatus(WBEM_E_FAILED,0);
	}
	else
	{
		//Let CIMOM know we are initialized
		pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
	}

    return hr;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;

	DBGINFOW((DBG_CONTEXT, L"WMI::GetObjectAsync, objpath=%s", ObjectPath));
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to Impersonate"));
		return hr;
	}

	try
	{
		hr = InternalGetObjectAsync(ObjectPath, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		DBGINFOW((DBG_CONTEXT, L"Exception thrown in GetObjectAsync: %s", err.Description ()));
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CInstanceProvider::CreateInstanceEnumAsync [IWbemServices]
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
		HRESULT hr = S_OK;

	DBGINFOW((DBG_CONTEXT, L"WMI::CreateInstanceEnumAsync, class=%s", Class));
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to Impersonate"));
		return hr;
	}

	try
	{
		hr = InternalCreateInstanceEnumAsync(Class, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		DBGINFOW((DBG_CONTEXT, L"Exception thrown in GetObjectAsync: %s", err.Description ()));
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}

void CInstanceProvider::SetStatus(
		/* [in] */HRESULT hAny,
		/* [in] */IWbemContext *pCtx,
        /* [in] */IWbemObjectSink *pResponseHandler )
{
	ASSERT (pCtx != 0);
	ASSERT (pResponseHandler != 0);

	HRESULT hr;
	CComPtr<IWbemClassObject> spClassObj;
	CComPtr<IWbemClassObject> spInst;
	_variant_t varValue;

	if (SUCCEEDED (hAny))
	{
		// ignore errors, because we cannot do anything anyway
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, S_OK, 0, 0);
	}
	else
	{
		DBGINFOW((DBG_CONTEXT, L"Setting status: Function failed. hr=0x%08x", hAny));
		// set extended status
		hr = m_spNamespace->GetObject(L"__ExtendedStatus", 0 ,pCtx, &spClassObj, NULL);

		if (SUCCEEDED(hr))
		{
			hr = spClassObj->SpawnInstance(0,&spInst);

			if (SUCCEEDED(hr))
			{
				varValue = GetDescrForHr (hAny);
				hr = spInst->Put(L"Description", 0, &varValue, 0);

				varValue = hAny;
				hr = spInst->Put(L"StatusCode", 0, &varValue, 0);

				varValue = PROVIDER_LONGNAME;
				spInst->Put(L"ProviderName", 0, &varValue, 0);
				
				hr = pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, 0, spInst);
			}
		}
	}
}

_variant_t
CInstanceProvider::GetDescrForHr (HRESULT hrLast) const
{
	_variant_t varResult = L"";

	ASSERT (g_hInst != 0);

	CComPtr<IErrorInfo> spErrorInfo;

	HRESULT hr = GetErrorInfo (0, &spErrorInfo);
	if (hr == S_OK) // GetErrorInfo returns S_FALSE when there is no error object to return
	{
		CComPtr<ISimpleTableRead2> spRead;
		hr = spErrorInfo->QueryInterface (IID_ISimpleTableRead2, (void **) &spRead);
		if (SUCCEEDED (hr))
		{
			_bstr_t bstrDescrMultiLine;
			for (ULONG iRow=0;;++iRow)
			{
				tDETAILEDERRORSRow ErrorInfo;
				hr = spRead->GetColumnValues (iRow, cASSOC_META_NumberOfColumns, 0, 0, (void **)&ErrorInfo);
				if (hr == E_ST_NOMOREROWS)
				{
					hr = S_OK;
					break;
				}
				if (FAILED (hr))
				{
					wprintf (L"GetColumnValues failed\n");
					break;
				}

				bstrDescrMultiLine += ErrorInfo.pDescription;
			}
			varResult = bstrDescrMultiLine;
		}
		else
		{
			CComBSTR bstrDescription;
			hr = spErrorInfo->GetDescription (&bstrDescription);
			if (SUCCEEDED (hr))
			{
				varResult = bstrDescription;
			}
		}
	}

	if (varResult.bstrVal[0] == L'\0')
	{
		WCHAR wszBuffer[512];
		wszBuffer[0] = L'\0';
		int iResult = LoadString(g_hInst, IDS_UNKNOWN_ERROR, wszBuffer, sizeof(wszBuffer)/sizeof(WCHAR));
		if (iResult == 0)
		{
			DBGINFOW((DBG_CONTEXT, L"String with ID %d does not exist in resource file", IDS_UNKNOWN_ERROR));
		}
		else
		{
			varResult = wszBuffer;
		}
	}

	return varResult;
}


//***************************************************************************
//
// CInstanceProvider::PutInstanceAsync  [IWbemServices]
//
// 
//
//*************************************************************************** 
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DBGINFOW((DBG_CONTEXT, L"WMI::PutInstanceAsync"));
	
	HRESULT hr = S_OK;

	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to Impersonate"));
		return hr;
	}

	try
	{
		hr = InternalPutInstanceAsync (pInst, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		DBGINFOW((DBG_CONTEXT, L"Exception thrown in PutInstanceAsync: %s", err.Description ()));
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CInstanceProvider::DeleteInstanceAsync  [IWbemServices]
//
// 
//
//*************************************************************************** 
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DBGINFOW((DBG_CONTEXT, L"WMI::DeleteInstanceAsync, objpath=%s", ObjectPath));

	HRESULT hr = S_OK;

	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to Impersonate"));
		return hr;
	}

	try
	{
		hr = InternalDeleteInstanceAsync(ObjectPath, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		DBGINFOW((DBG_CONTEXT, L"Exception thrown in DeleteInstanceAsync: %s", err.Description ()));
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );

	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}


/***************************************************************************
// CInstanceProvider::DeleteInstanceAsync  [IWbemServices]
//***************************************************************************/
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DBGINFOW((DBG_CONTEXT, L"WMI::ExecQueryAsync, query=%s", bstrQuery));
	HRESULT hr = S_OK;
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to Impersonate"));
		return hr;
	}

	try
	{
		hr = InternalExecQueryAsync(bstrQueryLanguage, bstrQuery, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		DBGINFOW((DBG_CONTEXT, L"Exception thrown in ExecQueryAsync: %s", err.Description ()));
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to Impersonate"));
		return hr;
	}

	try
	{
		hr = InternalExecMethodAsync(ObjectPath, MethodName, lFlags, pCtx, pInParams,  pResponseHandler);
	}
	catch (_com_error& err)
	{
		DBGINFOW((DBG_CONTEXT, L"Exception thrown in ExecMethodAsync: %s", err.Description ()));
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	

	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
} 

HRESULT 
CInstanceProvider::InternalGetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler)
{
	ASSERT (ObjectPath != 0);
	ASSERT (pCtx != 0);
	ASSERT (pResponseHandler != 0);

	HRESULT hr = S_OK;
/*	CInstanceHelper instHelper;

	HRESULT hr = instHelper.Init (ObjectPath,
		                          lFlags,
								  pCtx, 
								  pResponseHandler,
								  m_spNamespace,
								  m_spDispenser);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization of instance helper failed"));
		return hr;
	}

	if (instHelper.IsAssociation ())
	{
		hr = instHelper.CreateAssociation ();
	}
	else if (instHelper.HasDBQualifier ())
	{
		CComPtr<IWbemClassObject> spNewInstance;
		hr = instHelper.CreateInstance (&spNewInstance);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Instance creation failed"));
			return hr;
		}

		// tell WMI that the new instance is created. We have to do this outside the
		// createinstance function, because createInstance is used by batch Retrieve
		// as well, and the first thing that you return via indicate will be the
		// result value.

		IWbemClassObject* pNewInstRaw = spNewInstance;
		hr = pResponseHandler->Indicate(1,&pNewInstRaw);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"WMI Indicate failed"));
			return hr;
		}
	}
	else
	{
		hr = instHelper.CreateStaticInstance ();
		if (FAILED (hr))
		{
			return hr;
		}
	}
*/		
	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);

	return WBEM_S_NO_ERROR;
}

HRESULT 
CInstanceProvider::InternalExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
{
	HRESULT hr = S_OK;
/*	CQueryHelper queryHelper;
	HRESULT hr = queryHelper.Init (bstrQuery, 
								   lFlags, 
								   pCtx, 
								   pResponseHandler, 
								   m_spNamespace, 
								   m_spDispenser);

	if (FAILED (hr))
	{
		return hr;
	}



	if (queryHelper.IsAssociation ())
	{
		hr = queryHelper.CreateAssociations ();
	}
	else if (queryHelper.HasDBQualifier ())
	{
		hr = queryHelper.CreateInstances ();
	}
	else
	{
		hr = queryHelper.CreateAppInstances ();
	}

	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"InternalExecQueryAsync failed"));
		return hr;
	}
*/	
	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);
	
	return hr;
}

HRESULT 
CInstanceProvider::InternalPutInstanceAsync( 
        /* [in] */ IWbemClassObject  *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext* pCtx,
        /* [in] */ IWbemObjectSink* pResponseHandler) 
{
	ASSERT (pInst != 0);
	ASSERT (pCtx != 0);
	ASSERT (pResponseHandler != 0);

	_variant_t varClassName;
	HRESULT hr = pInst->Get(L"__class", 0, &varClassName, 0 , 0);
	if (FAILED (hr))
	{
		return hr;
	}

	DBGINFOW((DBG_CONTEXT, L"PutInstance for class %s", LPWSTR (varClassName.bstrVal)));

/*	CInstanceHelper instHelper;

	hr = instHelper.Init (_bstr_t (varClassName), lFlags, pCtx, pResponseHandler, m_spNamespace, m_spDispenser);
	if (FAILED (hr))
	{
		return hr;
	}

	if (instHelper.IsAssociation ())
	{
		return WBEM_E_INVALID_OPERATION;
	}
	else if (instHelper.HasDBQualifier ())
	{
		hr = instHelper.PutInstance  (pInst);
	}
	else
	{
		hr = instHelper.PutInstanceWebApp (pInst);
	}

	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"PutInstance Failed"));
		return hr;
	}
*/
	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);

	return hr;
}

HRESULT 
CInstanceProvider::InternalDeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
{
	HRESULT hr = S_OK;
/*	CInstanceHelper instHelper;

	HRESULT hr = instHelper.Init (ObjectPath,
		                          lFlags,
								  pCtx, 
								  pResponseHandler,
								  m_spNamespace,
								  m_spDispenser);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization failed"));
		return hr;
	}

	if (instHelper.IsAssociation ())
	{
		return WBEM_E_INVALID_OPERATION;
	}
	else if (instHelper.HasDBQualifier ())
	{
		hr = instHelper.DeleteInstance  ();
	}
	else
	{
		hr = instHelper.DeleteWebApp ();
	}
	
	if (FAILED (hr))
	{
		return hr;
	}

*/	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);

	return hr;
}

//=================================================================================
// Function: CInstanceProvider::InternalExecMethodAsync
//
// Synopsis: Executes a method asynchronously. Uses the method helper to do 
//           all the work
//
// Arguments: [ObjectPath] - object path of class on which to invoke method
//            [MethodName] - method to invoke
//            [lFlags] - flags
//            [pCtx] - context to call back into WMI
//            [pInParams] - in parameters
//            [pResponseHandler] - callback interface into WMI for status
//=================================================================================
HRESULT 
CInstanceProvider::InternalExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;
/*	CMethodHelper methodHelper;
	HRESULT hr = methodHelper.Init (ObjectPath,
									MethodName,
									lFlags,
									pCtx,
									pInParams,
									pResponseHandler,
									m_spNamespace,
									m_spDispenser);
	
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Initialization of method helper failed"));
		return hr;
	}

	hr = methodHelper.ExecMethod ();

	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Method Execution failed"));
		return hr;
	}
*/
	return hr;
}

HRESULT STDMETHODCALLTYPE 
CInstanceProvider::InternalCreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;
/*	if (_wcsicmp (Class, L"WebApplication") == 0)
	{
		CWebAppHelper webAppHelper;
		hr = webAppHelper.Init (Class, lFlags, pCtx, pResponseHandler, m_spNamespace);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to initialize webapphelper"));
			return hr;
		}

		hr = webAppHelper.EnumInstances ();
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to enumerate instances of webapplication"));
			return hr;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
*/
	return hr;
}
//***************************************************************************
//
// The following methods [IWbemServices] are not supported !
//
//*************************************************************************** 

HRESULT STDMETHODCALLTYPE CInstanceProvider::OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

        
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

        
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

        
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\maindll.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    maindll.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __MAINDLL_H__
#define __MAINDLL_H__

#pragma once



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\methodhelper.h ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    methodhelper.h
 
Abstract:
 
    This file contains the definition of class CMethodHelper
 
Author:
 
    Suzana Canuto (suzanac)        04/10/01
 
Revision History:
 
--********************************************************************/
#pragma once

#include <wbemidl.h>

//
// Maximum number of arguments
//
#define PROV_MAX_PARAMS 10


/********************************************************************++
 
Class Name:
 
    CMethodHelper
 
Class Description:
 
    Abstract base class whose purpose is to help a WMI provider execute 
    its exposed methods.

--********************************************************************/

class CMethodHelper
{
public:   

    CMethodHelper();
    virtual ~CMethodHelper();

    typedef HRESULT (CMethodHelper::*PMethodFunc) ();

    struct METHOD_INFO
    {
        LPCWSTR pwszClass;
        LPCWSTR pwszMethod;
        PMethodFunc pImpl;
    };

    struct PARAM_INFO
    {
        LPCWSTR pwszClass;
        LPCWSTR pwszMethod;
        LPCWSTR pwszParam;
        BOOL fRequired;
    };
    
    HRESULT 
    ExecMethodAsync(  
        const BSTR ObjectPath,
        const BSTR MethodName,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemClassObject __RPC_FAR *pInParams,
        IWbemObjectSink __RPC_FAR *pResponseHandler
        ); 

    virtual HRESULT Initialize() = 0;    

protected:    

    //
    // This array will be filled in the derived class with the 
    // methods that the specific provider implements
    //
    static const METHOD_INFO sm_rgMethodInfo[];

    //
    // This array will be filled in the derived class with the 
    // parameters for the methods of the specific provider
    //    
    static const PARAM_INFO sm_rgParamInfo[];

    //
    // Attention: this variable *MUST* be set in the Initialize()
    // of the derived class with 
    // m_cMethods = sizeof(m_rMethodInfo)/sizeof(m_rMethodInfo[0]);
    // This is needed so that ExecMethod defined in this base class
    // can loop through the array
    // in the base class and have the array be only filled in the
    // derived class.
    //
    int m_cMethods;
    
    //
    // Attention: this variable *MUST* be set in the Initialize()
    // of the derived class with 
    // m_cParams = sizeof(m_rParamInfo)/sizeof(m_rParamInfo[0]);
    // This is needed so that FillArgs defined in this base class
    // can loop through the array
    // in the base class and have the array be only filled in the
    // derived class.
    //
    int m_cParams;   

    //
    // This variable *HAS* to be set when Initialize is called. We have to guarantee
    // that it is called before calling ExecMethodAsync, but we just need 
    // to call it once.
    //
    bool m_fInitialized;

    VARIANT rgvarArgs[PROV_MAX_PARAMS];

private:    

    HRESULT 
    FindMethod(
        BSTR bstrClass, 
        BSTR bstrMethod, 
        PMethodFunc *ppmethod
        );

    HRESULT 
    LoadArgs(
        BSTR bstrClass, 
        BSTR bstrMethod
        );

    HRESULT 
    CallMemberFunction(
        PMethodFunc pfunc
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\stringutil.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    stringutil.cpp

$Header: $

Abstract:
	String Helper functions for .NET WMI provider

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#include "stringutil.h"

//=================================================================================
// Function: CWMIStringUtil::Trim
//
// Synopsis: Trims the character i_wcTrim from front and back of the string. The string
//           that is passed in i_wsz is changed by this !!!
//
// Arguments: [i_wsz] - string to be trimmed
//            [i_wcTrim] - character to trim from front and back
//            
// Return Value: pointer to trimmed string
//=================================================================================
LPWSTR
CWMIStringUtil::Trim (LPWSTR i_wsz, WCHAR i_wcTrim)
{
	ASSERT (i_wsz != 0);
	LPWSTR pTemp = LTrim (i_wsz, i_wcTrim);
	pTemp = RTrim (pTemp, i_wcTrim);
	return pTemp;
}

//=================================================================================
// Function: CWMIStringUtil::LTrim
//
// Synopsis: Trims characters from the beginning of the string.
//
// Arguments: [i_wsz] - string to be trimmed
//            [i_wcTrim] - character to trim from the beginning
//            
// Return Value: pointer to LTrimmed string
//=================================================================================
LPWSTR
CWMIStringUtil::LTrim (LPWSTR i_wsz, WCHAR i_wcTrim)
{	
	ASSERT (i_wsz != 0);
	LPWSTR pTemp = i_wsz;
	while (*pTemp == i_wcTrim)
	{
		pTemp++;
	}
	return pTemp;
}

//=================================================================================
// Function: CWMIStringUtil::RTrim
//
// Synopsis: Trims characters at the end of the string. The i_wsz string is changed
//           by this function
//
// Arguments: [i_wsz] - string to be RTrimmed
//            [i_wcTrim] - character to trim from the end
//            
// Return Value: pointer to RTrimmed string
//=================================================================================
LPWSTR
CWMIStringUtil::RTrim (LPWSTR i_wsz, WCHAR i_wcTrim)
{
	ASSERT (i_wsz != 0);
	SIZE_T iLen = wcslen (i_wsz);

	for (SIZE_T idx=iLen-1; idx >= 0; --idx)
	{
		if (i_wsz[idx] == i_wcTrim)
		{
			i_wsz[idx] = L'\0';
		}
		else
		{
			break;
		}
	}

	return i_wsz;
}

//=================================================================================
// Function: CWMIStringUtil::StrToLower
//
// Synopsis: Converts a string to lower case by ignoring the strings that are placed
//           inside quotes or double quotes
//
// Arguments: [i_wszStr] - String to be converted
//            
// Return Value: pointer to converted string
//=================================================================================
LPWSTR
CWMIStringUtil::StrToLower (LPCWSTR io_wszStr)
{
	ASSERT (io_wszStr != 0);

	LPWSTR wszRet = new WCHAR [wcslen(io_wszStr) + 1];
	if (wszRet == 0)
	{
		return 0;
	}

	bool fInSingleQuotes = false;
	bool fInDoubleQuotes = false;
	bool fDoubleBackSlash = false;
	ULONG iCopyIdx = 0;

	WCHAR cLastChar = 0;

	for (LPCWSTR pFinder = io_wszStr; *pFinder != L'\0'; ++pFinder)
	{
		switch (*pFinder)
		{
		case L'\"':
			if (!fInSingleQuotes && cLastChar != '\\')
			{
				fInDoubleQuotes = !fInDoubleQuotes;
			}
			break;

		case L'\'':
			if (!fInDoubleQuotes && cLastChar != '\\')
			{
				fInSingleQuotes = !fInSingleQuotes;
			}
			break;

		case L'\\':
			if (fInSingleQuotes || fInDoubleQuotes)
			{
				if (cLastChar == L'\\') 
				{
					fDoubleBackSlash = true;
				}	
			}

		default:
			// do nothing
			break;
		}

		if (!fInSingleQuotes && !fInDoubleQuotes)
		{
			wszRet[iCopyIdx] = towlower(*pFinder);
		}
		else
		{
			wszRet[iCopyIdx] = *pFinder;
		}
		iCopyIdx++;
		if (fDoubleBackSlash)
		{
			fDoubleBackSlash = false;
			cLastChar = 0;
		}
		else
		{
			cLastChar = *pFinder;
		}
	}

	wszRet[iCopyIdx] = L'\0';

	ASSERT (!fInSingleQuotes);
	ASSERT (!fInDoubleQuotes);
		
	return wszRet;
}

//=================================================================================
// Function: CWMIStringUtil::FindChar
//
// Synopsis: Find a specific character in a string. The character is skipped if it is
//           found inside a section that is embraced by ""
//
// Arguments: [wszString] - String to search in
//            [wchr] - Character to search for
//            
// Return Value: pointer to first character wchr inside wszString if found, NULL otherwise
//=================================================================================
LPWSTR
CWMIStringUtil::FindChar (LPWSTR i_wszString, LPCWSTR i_aChars)
{
	ASSERT (i_wszString != 0);
	// we don't support searching for single quote, double quote and backslash
	ASSERT (wcschr (i_aChars, L'\'') == 0);
	ASSERT (wcschr (i_aChars, L'\"') == 0);
	ASSERT (wcschr (i_aChars, L'\\') == 0);

	bool fInDoubleQuotes = false;
	bool fInSingleQuotes = false;
	for (LPWSTR pFinder = i_wszString; *pFinder != L'\0'; ++pFinder)
	{
		if (*pFinder == L'\"')
		{
			if (!fInSingleQuotes)
			{
				fInDoubleQuotes = !fInDoubleQuotes;
			}
		}
		else if (*pFinder == L'\'')
		{
			if (!fInDoubleQuotes)
			{
				fInSingleQuotes = !fInSingleQuotes;
			}
		}
		else if (*pFinder == L'\\')
		{
			// skip over next char
			pFinder++;
		}

		if (!fInDoubleQuotes && !fInSingleQuotes && wcschr(i_aChars,*pFinder) != 0)
		{
			return pFinder;
		}
	}

	return 0;
}

//=================================================================================
// Function: CWMIStringUtil::FindStr
//
// Synopsis: Finds a substring inside a string, and ignores strings that are enclosed
//           inside quotes/double quotes. This makes it easy to do WQL query searching
//           and ignoring the properties that are inside quotes
//
// Arguments: [i_wszStr] - String to search in
//            [i_wszSubStr] - String to search for
//            
// Return Value: pointer to first occurence of i_wszSubStr in i_wszStr, or NULL if not
//               found
//=================================================================================
LPWSTR
CWMIStringUtil::FindStr (LPWSTR i_wszStr, LPCWSTR i_wszSubStr)
{
	ASSERT (i_wszStr != 0);
	ASSERT (i_wszSubStr != 0);

	// we don't support strings with quotes, double quotes and backslashes
	ASSERT (wcschr (i_wszSubStr, L'\'') == 0);
	ASSERT (wcschr (i_wszSubStr, L'\"') == 0);
	ASSERT (wcschr (i_wszSubStr, L'\\') == 0);

	
	if (i_wszSubStr[0] == L'\0')
	{
		return 0;
	}

	bool fInSingleQuotes = false;
	bool fInDoubleQuotes = false;

	SIZE_T idx = 0;
	SIZE_T iSize = wcslen (i_wszSubStr);
	LPWSTR pStart = 0;

	for (LPWSTR pFinder = (LPWSTR) i_wszStr; *pFinder != L'\0'; ++pFinder)
	{
		 if (*pFinder == L'\"')
		 {
			 if (!fInSingleQuotes)
			 {
				 fInDoubleQuotes = !fInDoubleQuotes;
				 idx = 0;
			 }
		 }
		 else if (*pFinder == L'\'')
		 {
			 if (!fInDoubleQuotes)
			 {
				 fInSingleQuotes = !fInSingleQuotes;
				 idx = 0;
			 }
		 }
		 else if (*pFinder == L'\\')
		 {
				// skip over next char
				pFinder++;
		 }
		 else
		 {
			 if (!fInDoubleQuotes && !fInSingleQuotes)
			 {
				 if (*pFinder == i_wszSubStr[idx])
				 {
					 if (idx == 0)
					 {
						 pStart = pFinder;
					 }
					 else if (idx == iSize - 1)
					 {
						 return pStart;
					 }
					 ++idx;
				 }
				 else
				 {
					 idx = 0;
				 }
			 }
		 }
	 }

	 return 0;
}

LPWSTR
CWMIStringUtil::StrToObjectPath (LPCWSTR wszString)
{
	SIZE_T iLen = wcslen (wszString);

	LPWSTR wszNewValue = new WCHAR[iLen+1];
	if (wszNewValue == 0)
	{
		return 0;
	}

	wcscpy (wszNewValue, wszString);

	return wszNewValue;
}

LPWSTR
CWMIStringUtil::AddBackSlashes (LPCWSTR i_wszStr)
{
	ASSERT (i_wszStr != 0);
	SIZE_T iLen = wcslen (i_wszStr);
	LPWSTR wszResult = new WCHAR [2*iLen + 1];
	if (wszResult == 0)
	{
		return 0;
	}

	ULONG jdx = 0;
	for (ULONG idx=0; idx<iLen; ++idx)
	{
		if (i_wszStr[idx] == L'\\')
		{
			wszResult[jdx++] = L'\\';
		}
		wszResult[jdx++] = i_wszStr[idx];
	}

	wszResult[jdx] = L'\0';
	
	return wszResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\wmihelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmihelper.cpp

$Header: $

Abstract:
	Some helper functions that are used in several places

Author:
    marcelv 	12/6/2000		Initial Release

Revision History:

--**************************************************************************/

#include "wmihelper.h"
#include "localconstants.h"

//=================================================================================
// Function: CWMIHelper::GetClassInfo
//
// Synopsis: Retrieves database and internal name qualifiers for a particular class
//
// Arguments: [pClassObject] - pointer to valid class object
//            [i_bstrDBName] - database name will be stored in here
//            [i_bstrTableName] - table name will be stored in here
//=================================================================================
HRESULT 
CWMIHelper::GetClassInfo (IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName)
{
	ASSERT (pClassObject != 0);

	CComPtr<IWbemQualifierSet> spQualifierSet;
	HRESULT hr = pClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get Qualifier set"));
		return hr;
	}
		
	_variant_t varDBName;
	_variant_t varInternalName;

	hr = spQualifierSet->Get (WSZDATABASE, 0, &varDBName, 0);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get Database Qualifier"));
		return hr;
	}

	hr = spQualifierSet->Get (WSZINTERNALNAME, 0, &varInternalName, 0);
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to get InternalName Qualifier"));
		return hr;
	}

	i_bstrDBName		= varDBName;
	i_bstrTableName		= varInternalName;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\stringutil.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    stringutil.h

$Header: $

Abstract:

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __STRINGUTIL_H__
#define __STRINGUTIL_H__

#pragma once

#include "catmacros.h"

class CWMIStringUtil
{
public:
	static LPWSTR Trim (LPWSTR i_wsz, WCHAR i_wcTrim);
	static LPWSTR LTrim (LPWSTR i_wsz, WCHAR i_wcTrim);
	static LPWSTR RTrim (LPWSTR i_wsz, WCHAR i_wcTrim);
	static LPWSTR StrToLower (LPCWSTR io_wszStr);
	static LPWSTR FindChar (LPWSTR i_wszString, LPCWSTR i_aChars);
	static LPWSTR FindStr (LPWSTR i_wszStr, LPCWSTR i_wszSubStr);
	static LPWSTR StrToObjectPath (LPCWSTR wszString);
	static LPWSTR AddBackSlashes (LPCWSTR i_wszStr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\wmihelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmihelper.h

$Header: $

Abstract:

Author:
    marcelv 	12/6/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIHELPER_H__
#define __WMIHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catmacros.h"

class CWMIHelper
{
public:
	static HRESULT GetClassInfo (IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\methodhelper.cpp ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    methodhelper.cpp
 
Abstract:
 
    This file contains the implementation of class CMethodHelper
 
Author:
 
    Suzana Canuto (suzanac)        04/10/01
 
Revision History:
 
--********************************************************************/

#include "methodhelper.h"
#include "dbgutil.h"


/********************************************************************++
 
Routine Description:
 
    CMethodHelper Constructor
 
Arguments:
 
    NONE 
Return Value:
 
    NONE
 
--********************************************************************/
CMethodHelper::CMethodHelper() :
m_fInitialized(FALSE)
{

}


/********************************************************************++
 
Routine Description:
 
    CMethodHelper Destructor
 
Arguments:
 
    NONE 
Return Value:
 
    NONE
 
--********************************************************************/
CMethodHelper::~CMethodHelper()
{

}



/********************************************************************++
 
Routine Description:
 
    Using the method schema, figures out which function (method) should
    be called and performs some basic parameter validation, based on 
    the class and method names received from WMI
 
Arguments:
 
    bstrObjectPath   - Object path of class that implements the method
    bstrMethodName   - Name of the method to execute
    lFlags           - Flags
    pCtx             - Context for calling back into WMI
    pInParams        - In parameters
    pResponseHandler - Response callback interface to give info back to WMI    

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT 
CMethodHelper::ExecMethodAsync(
    IN const BSTR bstrObjectPath,
    IN const BSTR bstrMethodName,
    IN long lFlags,
    IN IWbemContext __RPC_FAR *pCtx,
    IN IWbemClassObject __RPC_FAR *pInParams,
    IN IWbemObjectSink __RPC_FAR *pResponseHandler    
    )
{
    HRESULT hr = S_OK;
    PMethodFunc pmethod = NULL;
    BSTR bstrClass = NULL;

    DBGINFO((DBG_CONTEXT, "ExecMethodAsync starting...\n"));

    //
    // Verifying if Initialize needs to be called
    //
    if ( !m_fInitialized )
    {
        hr = Initialize();
        if ( FAILED( hr ) )
        {
            DBGERROR((DBG_CONTEXT, "Initilize failed [0x%x]\n", hr));
            goto Cleanup;
        }     
    }    
    
    // TODO: Parse the path appropriately
    bstrClass = bstrObjectPath;

    //
    // Find the implementation of the requested method
    //
    hr = FindMethod( bstrClass, bstrMethodName, &pmethod );
    if ( FAILED( hr ) ) 
    {        
        DBGERROR((DBG_CONTEXT, "FindMethod failed [0x%x]\n", hr));
        goto Cleanup;
    }
 
    DBG_ASSERT(pmethod);
    
    // TODO: Validate Parameters
    
    //
    // Execute the requested method
    //
    hr = CallMemberFunction(pmethod);
    if ( FAILED( hr ) ) 
    {       
        DBGERRORW((DBG_CONTEXT, 
                   L"Execution of method %s, class %s failed [0x%x]\n",
                   bstrMethodName,
                   bstrClass,
                   hr));                   
        goto Cleanup;
    }
    
Cleanup:
    DBGINFO((DBG_CONTEXT, "ExecMethodAsync ending...\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Using the method schema, figures out which function (method) should
    be called and calls a function to perform basic parameter validation, 
    based on the class and method names received from WMI
 
Arguments:
 
    bstrClass  - Name of the WMI class that exposes the method
    bstrMethod - Name of the method in the WMI schema
    ppmethod   - Receives the pointer to the method implementation

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT 
CMethodHelper::FindMethod(
    IN BSTR bstrClass, 
    IN BSTR bstrMethod, 
    OUT PMethodFunc *ppmethod
    )
{
    HRESULT hr = S_OK;
    PMethodFunc pmethod = NULL;
    BOOL fMethodFound = FALSE;

    //
    // loop through the table of methods
    // we could alternatively put the info in a hash table
    // but we decided not to do at least that for now
    //
    for ( int i = 0; i < m_cMethods; i++ )
    {   
        //
        // if the class and method's name match
        //
        if ( !_wcsicmp( ( LPCWSTR ) bstrMethod, sm_rgMethodInfo[i].pwszMethod ) &&
             !_wcsicmp( ( LPCWSTR ) bstrClass, sm_rgMethodInfo[i].pwszClass ) )
        {
            //
            // get the pointer to the implementation of the desired method
            //
            pmethod = sm_rgMethodInfo[i].pImpl;            
            fMethodFound = TRUE;
            break;
        }      
    }
   
    if ( !fMethodFound )
    {
        DBGERRORW((DBG_CONTEXT, L"Method %s of class %s not found\n",
                  bstrMethod,
                  bstrClass));
        // TODO hr = What should be the hresult for method not found?
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
Cleanup:
    *ppmethod = pmethod;
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Using the method schema, figures out the parameters to the corresponding
    method, retrieves them from WMI to store in an array of variants and
    performs some basic validation.
 
Arguments:
 
    bstrClass  - Name of the WMI class that exposes the method
    bstrMethod - Name of the method in the WMI schema

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT 
CMethodHelper::LoadArgs(
    IN BSTR bstrClass, 
    IN BSTR bstrMethod
    )
{

    HRESULT hr = S_OK;
    int i = 0;  
    
    //
    // Loop through the table of parameters
    // while the name of the class OR the name of the method doesn't match AND
    // and we still haven't reached the end of the array, 
    // keep searching
    //
    while ( ( _wcsicmp( ( LPCWSTR ) bstrMethod, sm_rgParamInfo[i].pwszMethod ) ||
              _wcsicmp( ( LPCWSTR ) bstrClass, sm_rgParamInfo[i].pwszClass ) ) &&       
            ( i < m_cParams ) )            
    {
        i++;
    }

    if ( i >= m_cMethods )
    {        
        DBGERRORW( ( DBG_CONTEXT, L"Method %s, class %s not found\n",
                   bstrClass,
                   bstrMethod ) );
        //TODO See if there's a better hresult for method not found
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    // TODO Finish this function
Cleanup:
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Executes a method using a pointer to it
 
Arguments:
 
    pfunc - Pointer to the method implementation

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT
CMethodHelper::CallMemberFunction(
    IN PMethodFunc pfunc
    )
{
    HRESULT hr = S_OK;

    hr = ( this->*pfunc )();
    if ( FAILED( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "CallMemberFunction failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\wmiobjectpathparser.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmiobjectpathparser.cpp

$Header: $

Abstract:
	WMI Object Path Parser

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include "wmiobjectpathparser.h"
#include "stringutil.h"
#include "localconstants.h"

//=================================================================================
// Function: CObjectPathParser::CObjectPathParser
//
// Synopsis: Default constructor. Initiliazes all local variables
//=================================================================================
CObjectPathParser::CObjectPathParser ()
{
	m_pComputer			= 0;
	m_pNamespace		= 0;
	m_pClass			= 0;
	m_aWMIProperties	= 0;
	m_cNrProps			= 0;
	m_fParsed			= false;
	m_wszObjectPath		= 0;
}

//=================================================================================
// Function: CObjectPathParser::~CObjectPathParser
//
// Synopsis: Default Destructor
//=================================================================================
CObjectPathParser::~CObjectPathParser ()
{
	delete [] m_wszObjectPath;
	m_wszObjectPath = 0;

	delete [] m_aWMIProperties;
	m_aWMIProperties	= 0;
}

//=================================================================================
// Function: CObjectPathParser::Parse
//
// Synopsis: Parser a WMI Object path. The format of the path is
//           \\computer\namespace:class.prop1="val1",prop2="val2",prop3="val3"
//
// Arguments: [wszObjectPath] - Object path to be parsed
//            
// Return Value: S_OK if everything went ok, non-S_OK if error occurred.
//=================================================================================
HRESULT
CObjectPathParser::Parse (LPCWSTR wszObjectPath)
{
	ASSERT (wszObjectPath != 0);
	ASSERT (!m_fParsed)
	ASSERT (m_pComputer == 0);
	ASSERT (m_pNamespace == 0);
	ASSERT (m_pClass == 0);
	ASSERT (m_aWMIProperties == 0);

	HRESULT hr = S_OK;

	// copy to private variable so that we can change the string (i.e. replace certain characters
	// with null-terminators
	m_wszObjectPath = CWMIStringUtil::StrToLower (wszObjectPath);
	if (m_wszObjectPath == 0)
	{
		return E_OUTOFMEMORY;
	}

	// find the colon to see if we have computer/namespace information. If no colon is found, we
	// do not have computer and namespace information, and immediately know where the class name
	// starts

	WCHAR *pColon = CWMIStringUtil::FindChar(m_wszObjectPath, L":");
	if (pColon != 0)
	{
		// we have computer namespace information. See if there is a computer name by searching for
		// \\compname.
		m_pClass = pColon + 1;
		*pColon = L'\0';

		if (m_wszObjectPath[0] == '\\' && m_wszObjectPath[1] == '\\')
		{
			m_pComputer = m_wszObjectPath + 2; // skip over '\\'

			WCHAR * pNSSlash = wcschr (m_pComputer, L'\\');
			if (pNSSlash != 0)
			{
				*pNSSlash = L'\0';
				m_pNamespace = pNSSlash + 1;
			}
		}
		else
		{
			// no computer info found, so everything is the namespace
			m_pNamespace = m_wszObjectPath;
		}
	}
	else
	{
		// don't have computer and namespace
		m_pClass = m_wszObjectPath;
	}
		
	WCHAR *pDot = CWMIStringUtil::FindChar (m_pClass, L".");
	if (pDot != 0)
	{
		// we found a dot, so we have properties. Count the number of properties so that we
		// can allocate enough memory by counting the number of comma's
		*pDot = '\0';
		m_cNrProps = 1;
		WCHAR *pPropStart = pDot + 1;

		// find number of , not inclosed in Brackets
		for (LPWSTR pFinder = CWMIStringUtil::FindChar (pPropStart, L","); 
			 pFinder != 0;
			 pFinder = CWMIStringUtil::FindChar (pFinder + 1, L","))
			 {
				 m_cNrProps++;
			 }

		ASSERT (m_cNrProps > 0);
		m_aWMIProperties = new CWMIProperty[m_cNrProps];
		if (m_aWMIProperties == 0)
		{
			return E_OUTOFMEMORY;
		}

		// each property is of format name="value". So search for equals sign to find the
		// place where name ends and value starts, and find comma's to find the end of the 
		// property information
		for (ULONG iPropIdx = 0; iPropIdx < m_cNrProps; ++iPropIdx)
		{
			pFinder = CWMIStringUtil::FindChar (pPropStart, L",");
			if (pFinder != 0)
			{
				// replace comma with end of string char
				*pFinder = '\0';
			}
			
			LPWSTR pEqualStart = CWMIStringUtil::FindChar (pPropStart, L"=");
			ASSERT (pEqualStart != 0);
			*pEqualStart  = L'\0';

			hr = m_aWMIProperties[iPropIdx].SetName (pPropStart);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"Unable to set property name"));
				return hr;
			}

			hr = m_aWMIProperties[iPropIdx].SetValue (pEqualStart+ 1);
			if (FAILED (hr))
			{
				DBGINFOW((DBG_CONTEXT, L"Unable to set property value"));
				return hr;
			}
			pPropStart = pFinder + 1;
		}
	}

	// we need to check for the case CLASS="Value". If we have this case, we have
	// a class with a single primary key. Because SELECTOR is always part of the
	// primary key, the only key will be set as the SELECTOR property
	LPWSTR pEqualSign = CWMIStringUtil::FindChar (m_pClass, L"=");
	if (pEqualSign != 0)
	{
		*pEqualSign = L'\0';
		// we have one key property, the selector
		m_aWMIProperties = new CWMIProperty[1];
		if (m_aWMIProperties == 0)
		{
			return E_OUTOFMEMORY;
		}

		hr = m_aWMIProperties[0].SetName (WSZSELECTOR);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to set property name"));
			return hr;
		}

		hr = m_aWMIProperties[0].SetValue (pEqualSign + 1);
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Unable to set property value"));
			return hr;
		}
	}
	

	// we need to have valid class name here
	ASSERT (m_pClass != 0);

	m_fParsed = true;

	return hr;
}

//=================================================================================
// Function: CObjectPathParser::GetComputer
//
// Synopsis: Returns the name of the computer in the object path string, or empty string
//           if computer was not found
//=================================================================================
LPCWSTR
CObjectPathParser::GetComputer () const
{
	ASSERT (m_fParsed);

	if (m_pComputer == 0)
	{
		return L"";
	}
	else
	{
		return m_pComputer;
	}
}

//=================================================================================
// Function: CObjectPathParser::GetNamespace
//
// Synopsis: Return namespace name in the object path string of empty string if nothing found
//=================================================================================
LPCWSTR
CObjectPathParser::GetNamespace () const
{
	ASSERT (m_fParsed);

	if (m_pNamespace == 0)
	{
		return L"";
	}
	else
	{
		return m_pNamespace;
	}
}

//=================================================================================
// Function: CObjectPathParser::GetClass
//
// Synopsis: returns the name of the class in the object path string
//=================================================================================
LPCWSTR
CObjectPathParser::GetClass () const
{
	ASSERT (m_fParsed);
	ASSERT (m_pClass != 0);

	return m_pClass;
}

//=================================================================================
// Function: CObjectPathParser::GetPropCount
//
// Synopsis: returns number of properties in the object path string
//=================================================================================
ULONG
CObjectPathParser::GetPropCount () const
{
	ASSERT (m_fParsed);

	return m_cNrProps;
}

//=================================================================================
// Function: CObjectPathParser::GetProperty
//
// Synopsis: returns a property from the object path string
//
// Arguments: [idx] - index of property that we want to have information for. needs to
//                    be in between 0 and GetPropCount() -1
//=================================================================================
const CWMIProperty *
CObjectPathParser::GetProperty (ULONG idx) const
{
	ASSERT (m_fParsed);
	ASSERT (m_aWMIProperties != 0);
	ASSERT (idx >= 0 && idx < m_cNrProps);

	return &m_aWMIProperties[idx];
}

//=================================================================================
// Function: CObjectPathParser::GetPropertyByName
//
// Synopsis: Find a property by name. 
//
// Arguments: [i_wszPropName] - property name to search for
//            [io_Property] - property values will be filled out here
//            
// Return Value: true, property found, false: property not found
//=================================================================================
const CWMIProperty *
CObjectPathParser::GetPropertyByName (LPCWSTR i_wszPropName) const
{
	ASSERT (m_fParsed);
	ASSERT (i_wszPropName != 0);

	for (ULONG idx=0; idx<m_cNrProps; ++idx)
	{
		if (_wcsicmp(m_aWMIProperties[idx].GetName (), i_wszPropName) == 0)
		{
			return &m_aWMIProperties[idx];
			break;
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\wmiobjectpathparser.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmiobjectpathparser.h

$Header: $

Abstract:
	WMI Object Path Parser

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIOBJECTPATHPARSER_H__
#define __WMIOBJECTPATHPARSER_H__

#pragma once

//#include <windows.h>
#include "catmacros.h"
#include "localconstants.h"


/**************************************************************************++
Struct Name:
    CWMIProperty

Structure Description:
	Helper structure to store property name and property values together
--*************************************************************************/
struct CWMIProperty
{
	CWMIProperty () 
	{ 
		pName=0; 
		pValue=0;
	}

	~CWMIProperty () 
	{ 
		delete [] pValue;
		pValue=0;
		delete [] pName;
		pName = 0;
	}

	LPWSTR GetName () const
	{
		return pName;
	}

	HRESULT SetName (LPCWSTR wszName)
	{
		ASSERT (wszName != 0);
		ASSERT (pName == 0);
		pName = new WCHAR [wcslen (wszName) + 1];
		if (pName == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (pName, wszName);

		return S_OK;
	}

	LPWSTR GetValue () const
	{
		return pValue;
	}
		
	HRESULT SetValue (LPCWSTR wszValue)
	{
		ASSERT (wszValue != 0);
		ASSERT (pValue == 0);
		ASSERT (pName != 0);

		SIZE_T	 iLen = wcslen (wszValue);
		pValue = new WCHAR [iLen + 1];
		if (pValue == 0)
		{
			return E_OUTOFMEMORY;
		}

		ULONG iInsertIdx = 0;
		for (ULONG idx=0; idx <iLen; ++idx)
		{
			switch (wszValue[idx])
			{
				// skip backslashes
				case '\\':
					if (wszValue[idx+1] == L'\"' ||
						wszValue[idx+1] == L'\'')
					{
						continue;
					}

					if (wszValue[idx+1] == L'\\')
					{
						// skip on of the backslashes
						idx++;
					}
					break;

		    // ignore quotes and single quotes at beginning and end of string
			case '\"': // fallthrough
			case '\'':
				if (idx==0 || idx==iLen-1)
					continue;
				break;

				default:
					break;
			}
			pValue[iInsertIdx++] = wszValue[idx];
		}

		pValue[iInsertIdx] = L'\0';

		return S_OK;
	}



private:
	// don't allow copies
	CWMIProperty& operator=(const CWMIProperty&); 
	CWMIProperty (const CWMIProperty&);

	LPWSTR pValue;
	LPWSTR pName;
};

/**************************************************************************++
Class Name:
    CObjectPathParser

Class Description:
    Parses a WMI object path.

Constraints:
	Can only be used for single parsing. If you need multiple parsing, use multiple
	CObjectPathParser objects
--*************************************************************************/
class CObjectPathParser
{
public:
	CObjectPathParser ();
	~CObjectPathParser ();

	HRESULT Parse (LPCWSTR wszObjectPath);

	LPCWSTR GetComputer () const;
	LPCWSTR GetNamespace () const;
	LPCWSTR GetClass () const;

	ULONG GetPropCount () const;
	const CWMIProperty * GetProperty (ULONG idx) const;
	const CWMIProperty * GetPropertyByName (LPCWSTR i_wszPropName) const;

private:
	// don't allow copies
	CObjectPathParser (const CObjectPathParser& );
	CObjectPathParser& operator=(const CObjectPathParser& );

	LPWSTR m_wszObjectPath;			// full object path that needs to be parsed
	LPWSTR m_pComputer;				// pointer to computer name
	LPWSTR m_pNamespace;			// pointer to namespace
	LPWSTR m_pClass;				// pointer to classname
	CWMIProperty *m_aWMIProperties; // array of property values
	ULONG m_cNrProps;				// number of properties
	bool m_fParsed;					// Did we do parsing already?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\wqlparser.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wqlparser.h

$Header: $

Abstract:
	WQL parser and WQL Property helper classes

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WQLPARSER_H__
#define __WQLPARSER_H__

#pragma once

#include "catmacros.h"

/**************************************************************************++
Class Name:
    CWQLProperty

Class Description:
    WQL Property helper class. Contains name, value and operator for a single
	WQL condition (i.e. prop1=val1)
--*************************************************************************/
class CWQLProperty
{
public:
	CWQLProperty ();
	~CWQLProperty ();

	LPCWSTR GetValue () const;
	LPCWSTR GetName () const;
	LPCWSTR GetOperator () const;

	HRESULT SetName (LPCWSTR wszName);
	HRESULT SetValue (LPCWSTR wszValue);
	HRESULT SetOperator (LPWSTR wszOperator);
	
private:
	// don't allow copies 
	CWQLProperty& operator=(const CWQLProperty&); 
	CWQLProperty (const CWQLProperty&);

	LPWSTR m_wszValue;		// value
	LPWSTR m_wszName;		// name
	LPWSTR m_wszOperator;	// operator
};

/**************************************************************************++
Class Name:
    CWQLParser

Class Description:
    WQL parser class.
--*************************************************************************/
class CWQLParser
{
public:
	CWQLParser ();
	~CWQLParser ();

	HRESULT Parse (LPCWSTR i_wszQuery);

	LPCWSTR GetClass () const;

	ULONG GetPropCount () const;
	const CWQLProperty * GetProperty (ULONG i_idx) const;
	const CWQLProperty * GetPropertyByName (LPCWSTR i_wszPropName);
private:
	CWQLParser (const CWQLParser& );
	CWQLParser& operator= (const CWQLParser& );

	HRESULT PostValidateQuery ();
	HRESULT ReformatQuery ();
	void RemoveUnwantedProperties ();

	LPWSTR m_wszQuery;				// full query that needs to be parsed
	LPWSTR m_pClass;				// pointer to classname
	CWQLProperty *m_aWQLProperties; // array of property values
	ULONG m_cNrProps;				// number of properties
	bool m_fParsed;					// Did we do parsing already?

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\wqlparser.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wqlparser.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#include "wqlparser.h"
#include "stringutil.h"
#include "localconstants.h"
#include <wbemidl.h>
	
static LPCWSTR wszSelect	= L"select ";
static const SIZE_T cSelect	= wcslen (wszSelect);
static LPCWSTR wszFrom		= L" from ";
static const SIZE_T cFrom	= wcslen (wszFrom);
static LPCWSTR wszWhere		= L" where ";
static const SIZE_T cWhere	= wcslen (wszWhere);
static LPCWSTR wszAnd		= L" and ";
static const SIZE_T cAnd	= wcslen (wszAnd);
static LPCWSTR wszOr		= L" or ";
static const SIZE_T cOr		= wcslen (wszOr);
static LPCWSTR wszSelector  = L"selector";
static const SIZE_T cSelector= wcslen (wszSelector);

//=================================================================================
// Function: CWQLProperty::CWQLProperty
//
// Synopsis: Constructor
//=================================================================================
CWQLProperty::CWQLProperty () 
{ 
	m_wszName		= 0; 
	m_wszValue		= 0;
	m_wszOperator	= 0;
}

//=================================================================================
// Function: CWQLProperty::~CWQLProperty
//
// Synopsis: Destructor
//=================================================================================
CWQLProperty::~CWQLProperty () 
{
	delete [] m_wszOperator;
	m_wszOperator = 0;

	delete [] m_wszName;
	m_wszName = 0;

	delete [] m_wszValue;
	m_wszValue = 0;
}

//=================================================================================
// Function: CWQLProperty::GetValue
//
// Synopsis: Gets a property value
//=================================================================================
LPCWSTR 
CWQLProperty::GetValue () const
{
	ASSERT (m_wszValue != 0);
	return m_wszValue;
}

//=================================================================================
// Function: CWQLProperty::GetName
//
// Synopsis: Gets a property name
//=================================================================================
LPCWSTR 
CWQLProperty::GetName () const
{
	ASSERT (m_wszName != 0);
	return m_wszName;
}

//=================================================================================
// Function: CWQLProperty::GetOperator
//
// Synopsis: Get an operator (=,<,>, etc) used in a property condition
//=================================================================================
LPCWSTR 
CWQLProperty::GetOperator () const
{
	ASSERT (m_wszOperator != 0);
	return m_wszOperator;
}

//=================================================================================
// Function: CWQLProperty::SetName
//
// Synopsis: Set the name of a property. The name that is passed in contains
//           some garbage (opening,closing brackets), that will be stripped off.
//
// Arguments: [wszName] - name to set property name to
//=================================================================================
HRESULT 
CWQLProperty::SetName (LPCWSTR wszName)
{
	ASSERT (wszName != 0);

	SIZE_T iLen = wcslen (wszName);
	m_wszName = new WCHAR [iLen + 1];
	if (m_wszName == 0)
	{
		return E_OUTOFMEMORY;
	}

	ULONG iInsertIdx = 0;
	for (ULONG idx=0; idx < iLen; ++idx)
	{
		switch (wszName[idx])
		{
		case L' ':  // skip spaces
			break;
		case L'(':	// skip opening bracket
			break;
		case L')':	// skip closing bracket
			break;
		default:
			m_wszName[iInsertIdx++] = wszName[idx];
			break;
		}
	}

	m_wszName[iInsertIdx] = L'\0';

	return S_OK;
}

//=================================================================================
// Function: CWQLProperty::SetValue
//
// Synopsis: Set the value of a property. The value that is passed in contains garbage
//           like opening/closing brackets, beginning/ending double quotes that will
//           be removed
//
// Arguments: [wszValue] - value to set property value to
//=================================================================================
HRESULT 
CWQLProperty::SetValue (LPCWSTR wszValue) 
{
	ASSERT (wszValue != 0);
	ASSERT (m_wszName != 0);

	SIZE_T iLen = wcslen (wszValue);
	m_wszValue = new WCHAR [iLen + 1];
	if (m_wszValue == 0)
	{
		return E_OUTOFMEMORY;
	}

	if ((wszValue[0] == L'\"') ||(wszValue[0] == L'\''))
	{
		wcscpy (m_wszValue, wszValue +1);
		iLen--;
	}
	else
	{
		wcscpy (m_wszValue, wszValue);
	}

	// get rid of closing bracket
	if (m_wszValue[iLen-1] == L')')
	{
		m_wszValue[iLen-1] = L'\0';
		iLen--;
	}

	// get rid of ending single or double quote
	if (m_wszValue[iLen-1] == L'\"' || m_wszValue[iLen-1] == L'\'')
	{
		m_wszValue[iLen-1] = L'\0';
		iLen--;
	}

	// get rid of escape characters
	ULONG jdx = 0;
	for (ULONG idx=0; idx < iLen; ++idx)
	{
		if (m_wszValue[idx] == L'\\')
		{
			idx++;
		}
		m_wszValue[jdx++] = m_wszValue[idx];
	}
	m_wszValue[jdx] = L'\0';

	return S_OK;
}

//=================================================================================
// Function: CWQLProperty::SetOperator
//
// Synopsis: Sets the value of a property operator
//
// Arguments: [wszOperator] - value to set propety operator to
//=================================================================================
HRESULT 
CWQLProperty::SetOperator (LPWSTR wszOperator)
{
	ASSERT (wszOperator != 0);

	m_wszOperator = new WCHAR [wcslen (wszOperator) + 1];
	if (m_wszOperator == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszOperator, wszOperator);

	return S_OK;
}

//=================================================================================
// Function: CWQLParser::CWQLParser
//
// Synopsis: Default Constructor
//=================================================================================
CWQLParser::CWQLParser ()
{
	m_wszQuery			= 0;
	m_pClass			= 0;
	m_aWQLProperties	= 0;
	m_cNrProps			= 0;		
	m_fParsed			= false;
}

//=================================================================================
// Function: CWQLParser::~CWQLParser
//
// Synopsis: Default Destructor
//=================================================================================
CWQLParser::~CWQLParser ()
{
	delete [] m_wszQuery;
	m_wszQuery = 0;

	delete [] m_aWQLProperties;
	m_aWQLProperties = 0;
}

//=================================================================================
// Function: CWQLParser::Parse
//
// Synopsis: Parser a WQL query. 
//			 The currently supported format is
//
//           SELECT * FROM <className>
//			 WHERE <prop1> = "<val1>"
//           AND   <prop2> = <val2>
//           AND   <prop3> = "<val3>"
//
// Arguments: [i_wszQuery] - query to parser	
//            
// Return Value: S_OK if query parsed ok, error else
//=================================================================================
HRESULT
CWQLParser::Parse (LPCWSTR i_wszQuery)
{
	ASSERT (!m_fParsed);
	ASSERT (i_wszQuery != 0);

	HRESULT hr = S_OK;

	// and convert to lower case and remove double slashes to make searching for key-words easier.
	m_wszQuery = CWMIStringUtil::StrToLower (i_wszQuery);
	if (m_wszQuery == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	// we do not fully support OR queries. In case we find an OR, we are going to reformat
	// the query to remove everything in the where clause and only keep the selector property
	// there
	if (CWMIStringUtil::FindStr (m_wszQuery, wszOr) != 0)
	{
		hr = ReformatQuery ();
		if (FAILED (hr))
		{
			DBGINFOW((DBG_CONTEXT, L"Reformatting of query failed (OR clause found)"));
			return hr;
		}
	}

	// WMI assures that we start with SELECT
	ASSERT (wcsncmp (m_wszQuery, wszSelect, cSelect) == 0);

	// find from to find out where the classname starts
	LPWSTR pFromStart = CWMIStringUtil::FindStr (m_wszQuery, wszFrom);
	ASSERT (pFromStart != 0);

	m_pClass = pFromStart + cFrom;
	LPWSTR pClassEnd = wcschr(m_pClass, L' ');
	if (pClassEnd != 0)
	{
		// we have where/and clause that we need to handle
		
		LPWSTR pWhereStart = CWMIStringUtil::FindStr (pClassEnd, wszWhere);
		*pClassEnd = L'\0'; // set to null after searching, else search will fail
		if (pWhereStart != 0)
		{
			// we have a where clause. Count the number of conditions so that we
			// can allocate enough memory
			m_cNrProps = 1;

			pWhereStart += cWhere;
			for (LPWSTR pFinder = CWMIStringUtil::FindStr (pWhereStart, wszAnd);
			     pFinder != 0;
				 pFinder = CWMIStringUtil::FindStr (pFinder + cAnd, wszAnd))
				 {
					 ++m_cNrProps;
				 }

			m_aWQLProperties = new CWQLProperty [m_cNrProps];
			if (m_aWQLProperties == 0)
			{
				return E_OUTOFMEMORY;
			}

			// Go over all the conditions and extract the property values
			LPWSTR pStart = pWhereStart;
			for (ULONG idx=0; idx < m_cNrProps; ++idx)
			{
				LPWSTR pEqual = CWMIStringUtil::FindChar (pStart, L"=<>");
				ASSERT (pEqual != 0);

				LPWSTR pEqualEnd = pEqual + 1;
				while (wcschr(L"=<>", *pEqualEnd) != 0)
				{
					++pEqualEnd;
				}

				WCHAR wcTmp = *pEqualEnd;
				*pEqualEnd = L'\0';
				m_aWQLProperties[idx].SetOperator (pEqual);
				*pEqualEnd = wcTmp;

				*pEqual = L'\0';

				LPWSTR pFindAnd = CWMIStringUtil::FindStr (pEqualEnd, wszAnd);
				if (pFindAnd != 0)
				{
					*pFindAnd = L'\0';
				}

				hr = m_aWQLProperties[idx].SetName (pStart);
				if (FAILED (hr))
				{
					DBGINFOW((DBG_CONTEXT, L"Unable to set property name %s", pStart));
					return hr;
				}
				
				hr = m_aWQLProperties[idx].SetValue (CWMIStringUtil::Trim (pEqualEnd, L' '));
				if (FAILED (hr))
				{
					DBGINFOW((DBG_CONTEXT, L"Unable to set property value %s", pEqualEnd));
					return hr;
				}

				pStart = pFindAnd + cAnd;
			}
		}
	}

	RemoveUnwantedProperties ();

	hr = PostValidateQuery ();
	if (FAILED (hr))
	{
		DBGINFOW((DBG_CONTEXT, L"Post validation of query failed"));
		return hr;
	}

	m_fParsed = true;

	return hr;
}

//=================================================================================
// Function: CObjectPathParser::GetClass
//
// Synopsis: returns the name of the class in the object path string
//=================================================================================
LPCWSTR
CWQLParser::GetClass () const
{
	ASSERT (m_fParsed);
	ASSERT (m_pClass != 0);

	return m_pClass;
}

//=================================================================================
// Function: CWQLParser::GetPropCount
//
// Synopsis: returns number of conditions in the where clause
//=================================================================================
ULONG
CWQLParser::GetPropCount () const
{
	ASSERT (m_fParsed);

	return m_cNrProps;
}

//=================================================================================
// Function: CWQLParser::GetProperty
//
// Synopsis: returns a property from the object path string
//
// Arguments: [idx] - index of property that we want to have information for. needs to
//                    be in between 0 and GetPropCount() -1
//=================================================================================
const CWQLProperty *
CWQLParser::GetProperty (ULONG i_idx) const
{
	ASSERT (m_fParsed);
	ASSERT (m_aWQLProperties != 0);
	ASSERT (i_idx >= 0 && i_idx < m_cNrProps);

	return &m_aWQLProperties[i_idx];
}

//=================================================================================
// Function: CWQLParser::GetPropertyByName
//
// Synopsis: Find a property by name. 
//
// Arguments: [i_wszPropName] - property name to search for
//            [io_Property] - property values will be filled out here
//            
// Return Value: true, property found, false: property not found
//=================================================================================

const CWQLProperty *
CWQLParser::GetPropertyByName (LPCWSTR i_wszPropName)
{
	ASSERT (m_fParsed);
	ASSERT (i_wszPropName != 0);

	for (ULONG idx=0; idx<m_cNrProps; ++idx)
	{
		if (_wcsicmp(m_aWQLProperties[idx].GetName (), i_wszPropName) == 0)
		{
			return &m_aWQLProperties[idx];
			break;
		}
	}

	return 0;
}

//=================================================================================
// Function: CWQLParser::PostValidateQuery
//
// Synopsis: Validates that the query has at the most a single selector property. In
//           case multiple selector properties are found, an error is returned.
//=================================================================================
HRESULT
CWQLParser::PostValidateQuery ()
{
	ASSERT (m_wszQuery != 0);

	// verify that there is one and only one selector property

	bool fSelectorPropertyFound = false;
	for (ULONG idx=0; idx < m_cNrProps; ++idx)
	{
		if (_wcsicmp(m_aWQLProperties[idx].GetName (), WSZSELECTOR) == 0)
		{
			if (fSelectorPropertyFound)
			{
				DBGINFOW((DBG_CONTEXT, L"Multiple selector properties found in single query"));
				return E_INVALIDARG;
			}
			fSelectorPropertyFound = true;
		}
	}

	return S_OK;
}

//=================================================================================
// Function: CWQLParser::RemoveUnwantedProperties
//
// Synopsis: We remove all properties that do not use '=' as operator sign. This is
//           safe to do, because WMI will filter results for us anyway. We loop through
//           all the properties, and if the operator is not '=', we will move the element
//           to the end of the array. Note that we cannot delete elements at this point
//           because elese the delete of the array will blow up. Also, we have to use
//           memcpy to avoid calling the destructor of CWQLProperty.
//=================================================================================
void
CWQLParser::RemoveUnwantedProperties ()
{
	bool fFoundLastValid = false;
	ULONG cLastValidIdx = 0;
	for (LONG idx= m_cNrProps - 1; idx >= 0; --idx)
	{
		if (wcscmp (m_aWQLProperties[idx].GetOperator (), L"=") == 0)
		{
			if (!fFoundLastValid)
			{
				fFoundLastValid = true;
				cLastValidIdx = idx;
			}
		}
		else
		{
			if (fFoundLastValid)
			{
				// swap them around

				BYTE tmpProp[sizeof(CWQLProperty)];
				memcpy (&tmpProp, m_aWQLProperties + idx, sizeof (CWQLProperty));
				memcpy (m_aWQLProperties + idx, m_aWQLProperties + cLastValidIdx, sizeof(CWQLProperty));
				memcpy (m_aWQLProperties + cLastValidIdx, &tmpProp, sizeof(CWQLProperty));
				cLastValidIdx--;
			}
			m_cNrProps--;
		}
	}
}

//=================================================================================
// Function: CWQLParser::ReformatQuery
//
// Synopsis: This function gets invoked when a query contains an OR clause. In this 
//           case all conditions except the condition that containts the SELECTOR 
//           property will be stripped from the WHERE clause.
//=================================================================================
HRESULT 
CWQLParser::ReformatQuery ()
{
	ASSERT (m_wszQuery != 0);

	HRESULT hr = S_OK;
	// find where start

	LPWSTR pWhereStart = CWMIStringUtil::FindStr (m_wszQuery, wszWhere);
	ASSERT (pWhereStart != 0); // we shouldn't be here without where

	LPWSTR pSelectorStart = CWMIStringUtil::FindStr (pWhereStart + cWhere, wszSelector);
	if (pSelectorStart == 0)
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to find selector property"));
		return E_INVALIDARG;
	}

	// see if we have two selectors. If so, we bail out, because the query is too complex
	LPWSTR pSecondSelector = CWMIStringUtil::FindStr (pSelectorStart + cSelector, wszSelector);
	if (pSecondSelector != 0)
	{
		DBGINFOW((DBG_CONTEXT, L"Unable to handle queries with two OR statements"));
		return E_INVALIDARG;
	}

	// next we need to find the end of the selector condition. Search for both
	// AND and OR, and stop at the one that occurs first. If no AND or OR is found
	// we have to stop at the end of the string.

	LPWSTR pAndStart = CWMIStringUtil::FindStr (pSelectorStart + cSelector, wszAnd);
	LPWSTR pOrStart = CWMIStringUtil::FindStr (pSelectorStart + cSelector, wszOr);

	if (pAndStart == 0)
	{
		if (pOrStart == 0)
		{
			// no AND, no OR, wo stop at END of string (pAndStart points to this)
			SIZE_T iLen = wcslen (pSelectorStart);
			pAndStart = pSelectorStart + iLen;
		}
		else
		{
			// no AND, but found an OR
			pAndStart = pOrStart;
		}
	}
	else
	{
		// We found an AND. If we have OR, and OR is before AND, use that instead
		if ((pOrStart != 0) && (pOrStart < pAndStart))
		{
			pAndStart = pOrStart;
		}
	}
	
	ASSERT (pAndStart != 0);
	ASSERT (pAndStart > pSelectorStart);

	// and copy all characters to beginning of where clause
	
	LPWSTR pStartCopy = pWhereStart + cWhere;
	ULONG idx=0;
	for (LPWSTR pCurElem = pSelectorStart; pCurElem != pAndStart; ++pCurElem)
	{
		 pStartCopy[idx++]= *pCurElem;
	 }

    pStartCopy[idx] = L'\0';

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\instanceappcenter.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    instanceAppCenter.h

$Header: $

Abstract:
	Instance Helper for Aplication Center WMI classes. Makes it easy to 
    create/update/delete single class instances

Author:
    murate 	04/30/2001		Initial Release

Revision History:

--**************************************************************************/

#pragma once

#include "instancebase.h"

/**************************************************************************++
Class Name:
    CAppCenterInstance

Class Description:
    Helper to create/delete/update single class instances

Constraints:

--*************************************************************************/
class CAppCenterInstance : public CInstanceBase
{
public:
	CAppCenterInstance ();
	~CAppCenterInstance ();

	bool HasDBQualifier () const;
    HRESULT GetDatabaseAndTableName(IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName);
private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\clustersvcswr.h ===
/****************************************************************************++

Copyright (c) 2001  Microsoft Corporation

Module Name:

     clustersvcswr.h

Abstract:

       Wrapper for cluster svcs 

Author:

      Suzana Canuto         May, 3, 2000

Revision History:

--****************************************************************************/


#pragma once
#include <atlbase.h>
#include <wbemcli.h>

#include "cluscmmn.h"
#include "webclussvc.h"
#include "extclustercmd.h"
#include "appsrvadmlib.h"


#include "acauthutil.h"
#include "acsecurebstr.h"

#define OPERATION_ONLINE            0x00000001
#define OPERATION_DRAIN             0x00000002

//==========================================================

#define FIRST_STAGE_SERVER_ADD_TIMEOUT ( 15 * 60 * 1000 )
#define SECOND_STAGE_SERVER_ADD_TIMEOUT ( 20 * 60 * 1000 )

#define TOTAL_SERVER_ADD_TIMEOUT ( FIRST_STAGE_SERVER_ADD_TIMEOUT + SECOND_STAGE_SERVER_ADD_TIMEOUT )
#define SERVER_REMOVAL_TIMEOUT ( 20 * 60 * 1000 )

//=============================================================


//
// Metabase default poll count 
//
const int MBPOLLUTIL_DEFAULT_POLL_COUNT = 100;

//
// Metabase default poll interval
//
const int MBPOLLUTIL_POLL_INTERVAL = 5000;

//
// Maximum number of chars in the Description of a cluster
//
const int MAX_DESCRIPTION_CHARS = 256;

const LPWSTR XML_CLUSTER_MEMBER_START = L"<CLUSTER_MEMBER GUID=";


const LPWSTR g_pwszNicInfoQuery = L"select settingID, DHCPEnabled from Win32_NetworkAdapterConfiguration where index = ";
const LPWSTR g_pwszNicQueryComplement = L" or index = ";

const LPWSTR g_pwszSettingIDProperty = L"SettingID";
const LPWSTR g_pwszDHCPEnabledProperty = L"DHCPEnabled";

const LPWSTR g_pwszNoRemoveIps = L"NoRemoveIPs";

const LPWSTR g_pwszInvalidDescriptionChars = L"<&>\t\r\n\f";

BOOL 
IsValidValue( LPWSTR pwszValue, 
              LPWSTR ppwszValidValues[]);

HRESULT 
ValidateName( LPWSTR pwszName, 
              LPWSTR pwszInvalidChars, 
              BOOL fVerifyLen = FALSE,
              UINT iMaxLen = 0
              );

HRESULT 
GetGuidWithoutBrackets( LPWSTR pwszGuid,
                        WCHAR  wszGuidWithoutBrackets[] );


class CClusterSvcsUtil
{
   public:

        CClusterSvcsUtil();
        ~CClusterSvcsUtil();               

        HRESULT 
        SetOnline(
            BSTR bstrMember,
            BOOL fIgnoreHealthMonStatus
            );

        HRESULT 
        SetOffline(
            BSTR bstrMember,
            LONG lDrainTime = 0
            );

        HRESULT
        SetController(
            BSTR bstrMember,
            BOOL fForce = FALSE            
            );

        HRESULT 
        DeleteCluster(
            BSTR bstrMember,
            BOOL fKeepExistingIPAddresses
            );    

        HRESULT
        CleanServer(
            BSTR bstrMember,
            BOOL fKeepExistingIPAddresses
            );

        HRESULT
        RemoveMember(
            BSTR bstrMember,
            BSTR bstrController
            );
        
        HRESULT
        AddMember(
            BSTR bstrMember,
            BSTR bstrController,
            BSTR bstrManagementNics,
            BOOL fSynchronize = TRUE,
            BOOL fBringOnline = TRUE
            );

        HRESULT
        CreateCluster(
            BSTR bstrController,
            BSTR bstrClusterName,
            BSTR bstrClusterDescription,
            BSTR bstrClusterType,
            BSTR bstrManagementNics
            );

        HRESULT 
        SetNLBAdditionParameters(            
            BSTR bstrLBNics,
            BSTR bstrDedicatedIP = NULL,
            BSTR bstrDedicatedIPSubnetMask = NULL
            );

        HRESULT 
        SetNLBCreationParameters(
            BOOL fKeepExistingNLBSettings,
            BSTR bstrLBNics = NULL,
            BSTR bstrClusterIP = NULL,
            BSTR bstrClusterIPSubnetMask = NULL,
            BSTR bstrDedicatedIP = NULL,
            BSTR bstrDedicatedIPSubnetMask = NULL,
            BSTR bstrAffinity = NULL,
            BOOL fUnicastMode = TRUE
            );

        HRESULT
        FindController(
            BSTR bstrMember,
            BSTR *pbstrController
            );                
        
        HRESULT SetAuth(
            BSTR bstrUser,
            BSTR bstrDomain,
            CAcSecureBstr *psecbstrPwd
            );

        HRESULT
        SetContext( IWbemContext *pCtx );
        
    private:     

        HRESULT
        RemoveMember(
            BSTR bstrMember,
            BOOL fForceRemove
            );

        HRESULT 
        GetNumberOfMembers(
            CAcAuthUtil *pAuth,
            int *pnMembers
            );

        HRESULT
        SetDedicatedIPAndSubnetMask(
            BSTR bstrDedIP = NULL,
            BSTR bstrSubnetMask = NULL
            );

        HRESULT
        SetClusterIPAndSubnetMask(
            BSTR bstrDedIP = NULL,
            BSTR bstrSubnetMask = NULL
            );

        HRESULT
        SetManagementNicsIndex(
            BSTR bstrManagementNics
            );

        HRESULT
        SetLBNicIndex(           
            BSTR bstrLBNics
            );

        HRESULT 
        QueryLBNicGuid(
            BSTR bstrServer,
            BOOL fCheckStaticIP = FALSE
        );

        HRESULT 
        CheckNicHasStaticIP(
            IEnumWbemClassObject *pIEnumWbemClassObject
            );

        HRESULT 
        QueryManagementNicGuids(
            IN BSTR bstrServer
        );

        HRESULT 
        BuildManagementNicGuidQuery(
            OUT LPWSTR *ppwszQuery
            );

        HRESULT
        BuildManagementNicGuidsList(
            VARIANT *pvarProps,
            IN DWORD dwProps
            );

        HRESULT
        SetClusterNameAndDescription(
            BSTR bstrName,
            BSTR bstrDescription
            );

        HRESULT
        SetClusterLBType(
            BSTR bstrLBType
            );        

        HRESULT
        SetClusterAffinity(
            BSTR bstrAffinity = NULL
            );  

        HRESULT 
        GetLocalClusterItf(
            CAcAuthUtil *pAuth,
            ILocalClusterInterface **pILocalClusterInterface
            );

        HRESULT 
        GetWebClusterItfs(
            CAcAuthUtil *pAuth,           
            BOOL fGetAsync,
            IWebCluster **ppIWebCluster,
            IAsyncWebCluster **pIAsyncWebCluster            
            );

        HRESULT 
        GetIAsyncWebCluster(
            IWebCluster *pIWebCluster,
            CAcAuthUtil *pAuth, 
            IAsyncWebCluster **ppIAsyncWebCluster
            );

        HRESULT 
        GetExtensibleClusterCmdItf(
            CAcAuthUtil *pAuth,
            IExtensibleClusterCmd **ppIExtensibleClusterCmd
            );

        HRESULT 
        CallSetOnlineStatus(
            BSTR bstrMember,
            BOOL fOnline,  
            LONG lDrainTime = 0,
            LONG lFlags = 0
            );

        HRESULT
        ValidateLBOperation(
            CAcAuthUtil *pAuth,
            DWORD dwOperations
            );

        HRESULT
        LocalSetController(
            BSTR bstrMember
            );        

        HRESULT
        ChangeControllerAsync(
            BSTR bstrNewController,
            BSTR bstrOldController
            );        

        HRESULT 
        ExecuteClusterCmd( 
            CAcAuthUtil *pAuth,
            LPCWSTR pwszAction,                                    
            LPCWSTR pwszInput,
            BSTR *pbstrEventGuid);

        HRESULT 
        MachineCleanup( 
            CAcAuthUtil *pAuth,
            BOOL fKeepExistingIPAddresses
            );

        HRESULT 
        CreateAuth(
            BSTR bstrServer,
            CAcAuthUtil **ppAuth
            );   
        
        HRESULT 
        GetAppendedUserDomain(
            LPWSTR *ppwszUserDomain
            );

        HRESULT 
        GetNicInfo(
            int nNicId,
            LPWSTR *ppwszNicGuid,
            BOOL fDHCPEnabled
            );

        HRESULT
        QueryWmiObjects(
            LPWSTR pwszServer,
            LPWSTR pwszQuery,
            IEnumWbemClassObject **ppIEnumWbemClassObject
            );

        HRESULT
        QueryWmiObjects(
            LPWSTR pwszServer,
            LPWSTR pwszQuery,
            IWbemContext *pCtx,
            IEnumWbemClassObject **ppIEnumWbemClassObject
            );

        HRESULT
        QueryWmiProperties(
            IEnumWbemClassObject *pIEnumWbemClassObject,
            LPWSTR pwszProperties,
            VARIANT **ppvarProperties,
            DWORD *dwInstances
        );


        HRESULT
        BuildXmlInputForCreate(   
            BSTR *pbstrXmlInput
            );

        HRESULT 
        InsertLBInfoXml(
            );
        
        HRESULT
        SetAndValidateCreateParams(
            BSTR bstrServer,
            BSTR bstrClusterName,
            BSTR bstrClusterDescription,
            BSTR bstrClusterType,
            BSTR bstrManagementNics
            );

        HRESULT
        ValidateAddParams(
            BSTR bstrServer            
            );

            
        TSTRBUFFER m_tstrXmlInput;
        BOOL m_fAuthSet;
        
        //
        // Credentials info 
        //
        BSTR m_bstrUser;
        BSTR m_bstrDomain;
        CAcSecureBstr *m_psecbstrPwd;

        //
        // Cluster creation (generic) info
        //
        BSTR m_bstrClusterName;
        BSTR m_bstrClusterDescription;
        BSTR m_bstrClusterLBType;
        BOOL m_fNLBCreationParamsSet;

        //
        // Cluster creation (NLB) info
        //
        BSTR m_bstrClusterIP;
        BSTR m_bstrClusterIPSubnetMask;  
        BSTR m_bstrClusterAffinity;
        BSTR m_fKeepExistingNLBSettings;
        BOOL m_fUnicastMode;

        //
        // Member addition and Cluster creation (NLB) info
        //
        BSTR m_bstrDedicatedIP;
        BSTR m_bstrDedicatedIPSubnetMask;        
        BSTR m_bstrLBNicIndex;
        BSTR m_bstrLBNicGuid;
        BSTR m_bstrManagementNicIndexes;        
        BSTR m_bstrManagementNicGuids;   
        
        //
        // Member addition (generic) info
        //
        LONG m_lAddServerFlags;  
        BOOL m_fNLBAdditionParamsSet;    
        

        IWbemContext *m_pCtx;
};


class CAcMBPollUtil
{

public:
    CAcMBPollUtil();
    ~CAcMBPollUtil();

    HRESULT 
    MBPoll(
        CAcAuthUtil *pAuth,
        BSTR bstrEventGuid,
        int cPolls = MBPOLLUTIL_DEFAULT_POLL_COUNT,
        int nInterval = MBPOLLUTIL_POLL_INTERVAL
        );       

private:

    HRESULT 
    MBRead(
        CAcAuthUtil *pAuth,        
        HRESULT *phrMB
        );

    HRESULT 
    SetPath(
        LPCWSTR pwszPath
        );
    
    HRESULT 
    SetKey(
        LPCWSTR pwszKey
        );
    
    HRESULT 
    SetCompletePath(
        );   

    LPWSTR m_pwszPath;
    LPWSTR m_pwszKey;
    LPWSTR m_pwszCompletePath;    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\instanceappcenter.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    instanceAppCenter.cpp

$Header: $

Abstract:
	Instance Helper for Aplication Center WMI classes. Makes it easy to 
    create/update/delete single class instances

Author:
    murate 	04/30/2001		Initial Release

Revision History:

--**************************************************************************/

#include "instanceAppCenter.h"


CAppCenterInstance::CAppCenterInstance ()
{
}

CAppCenterInstance::~CAppCenterInstance ()
{
}

bool 
CAppCenterInstance::HasDBQualifier () const
{
	ASSERT (m_fInitialized);

	return TRUE;
}

//=================================================================================
// Function: CAppCenterInstance::CreateAssociation
//
// Synopsis: Retrieve the config database and table name that corresponds to this 
//              WMI class.
//
// Return Value: 
//=================================================================================
HRESULT 
CAppCenterInstance::GetDatabaseAndTableName(IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName)
{
    i_bstrDBName = wszDATABASE_AppCenter;
    i_bstrTableName = m_objPathParser.GetClass();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\clustersvcswr.cpp ===
/****************************************************************************++

Copyright (c) 2001  Microsoft Corporation

Module Name:

     clstrsvcswr.cpp

Abstract:

       Wrapper for cluster svcs 

Author:

      Suzana Canuto     May, 3, 2000

Revision History:

--****************************************************************************/

#include "clustersvcswr.h"
#include "xmltags.h"

#include "findmaster.h"
#include "workerclsids.h"
#include "wmicommon.h"

class CAppSrvAdmModule  _Module; // to pass the link with appsrvadmlib


/********************************************************************++
 
Routine Description:
     
    Constructor
      
Arguments:
    
    None
 
Return Value:
 
    None
    
--********************************************************************/
CClusterSvcsUtil::CClusterSvcsUtil() :
m_bstrUser( NULL ),
m_bstrDomain( NULL ),
m_psecbstrPwd( NULL ),
m_bstrClusterIP( NULL ),
m_bstrClusterIPSubnetMask( NULL ),
m_bstrDedicatedIP( NULL ),
m_bstrDedicatedIPSubnetMask( NULL ),
m_bstrLBNicIndex( NULL ),
m_bstrLBNicGuid( NULL ),
m_bstrManagementNicIndexes( NULL ),
m_bstrManagementNicGuids( NULL ),
m_bstrClusterName( NULL ),
m_bstrClusterDescription( NULL ),
m_bstrClusterLBType( NULL ),
m_bstrClusterAffinity( NULL ),
m_fKeepExistingNLBSettings( FALSE ),
m_fAuthSet( FALSE ),
m_fNLBAdditionParamsSet( FALSE ),
m_fNLBCreationParamsSet( FALSE ),
m_fUnicastMode( TRUE ),
m_pCtx( NULL ),
m_lAddServerFlags( 0 )
{

}


/********************************************************************++
 
Routine Description:
     
    Destructor

Arguments:
    
    None
 
Return Value:
 
    None
    
--********************************************************************/
CClusterSvcsUtil::~CClusterSvcsUtil()
{                
    SAFEFREEBSTR( m_bstrUser );
    SAFEFREEBSTR( m_bstrDomain );
    SAFEFREEBSTR( m_bstrClusterIP );
    SAFEFREEBSTR( m_bstrClusterIPSubnetMask );
    SAFEFREEBSTR( m_bstrDedicatedIP );
    SAFEFREEBSTR( m_bstrDedicatedIPSubnetMask );
    SAFEFREEBSTR( m_bstrLBNicIndex );
    SAFEFREEBSTR( m_bstrLBNicGuid );
    SAFEFREEBSTR( m_bstrManagementNicIndexes );
    SAFEFREEBSTR( m_bstrManagementNicGuids );
    SAFEFREEBSTR( m_bstrClusterName );
    SAFEFREEBSTR( m_bstrClusterDescription );
    SAFEFREEBSTR( m_bstrClusterLBType );
    SAFEFREEBSTR( m_bstrClusterAffinity );

    SAFERELEASE( m_pCtx );

    if ( m_psecbstrPwd )
    {
        delete m_psecbstrPwd;
        m_psecbstrPwd = NULL;
    }
}


LPWSTR g_ppwszValidLBTypes[] = 
{
    WSZ_AC_LB_TYPE_NLB,
    WSZ_AC_LB_TYPE_CLB,
    WSZ_AC_LB_TYPE_NONE,
    WSZ_AC_LB_TYPE_THIRD_PARTY
};

LPWSTR g_ppwszValidAffinity[] = 
{
    WSZ_NLB_AFFINITY_CLASS_C,
    WSZ_NLB_AFFINITY_SINGLE,
    WSZ_NLB_AFFINITY_NONE
};


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::SetOnline(
    IN BSTR bstrMember,
    IN BOOL fIgnoreHealthMonStatus 
    )
{
    HRESULT hr = S_OK;    
    LONG lFlags = 0;

    if ( !bstrMember )
    {
        DBGERROR(( DBG_CONTEXT, "Error: bstrMember null\n"));
        return E_INVALIDARG;        
    }

    if ( !fIgnoreHealthMonStatus )
    {
        lFlags = 1;
    }

    hr = CallSetOnlineStatus( bstrMember,
                              TRUE,
                              0,
                              lFlags );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, "CallSetOnlineStatus failed [0x%x]\n", hr));
        goto Cleanup;
    }

    
Cleanup:
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::SetOffline(
    IN BSTR bstrMember,
    IN LONG lDrainTime    
    )
{
    HRESULT hr = S_OK;
    
    if ( !bstrMember || ( lDrainTime < 0 ) ) 
    {
        DBGERROR((DBG_CONTEXT, "bstrMember null or invalid drain time\n"));
        return E_INVALIDARG;                
    }
    
    hr = CallSetOnlineStatus( bstrMember,
                              FALSE,
                              lDrainTime );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, "CallSetOnlineStatus failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:
            
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetController(
    IN BSTR bstrMember,
    IN BOOL fForce
    )
{
    HRESULT hr = S_OK;
    BSTR bstrController = NULL;

    if ( !bstrMember )
    {
        DBGERROR(( DBG_CONTEXT, "Error: bstrMember null\n"));
        return E_INVALIDARG;        
    }
    
    //
    // Try to find out the old controller
    //

    hr = FindController( bstrMember,
                         &bstrController );
  
    //
    // If we succeeded, make the change through the old controller
    //

    if ( SUCCEEDED ( hr ) )
    {
        DBGINFO((DBG_CONTEXT, "Controller is reachable, will change async\n"));
    
        hr = ChangeControllerAsync ( bstrMember, bstrController );
    }
    else 
    {
        if ( fForce )
        {
            //
            // If we could not find the old controller, but Force was specified
            // we will use the local interface to go ahead and set a new controller
            //
        
            DBGWARN(( DBG_CONTEXT, "FindController failed [0x%x], but Force "
                                   "was set,try to change controller locally\n",
                                   hr ));
            hr = LocalSetController ( bstrMember );
        }
        else
        {
            //
            // If force was not specified, we just give up on the controller change
            //
        
            DBGERROR(( DBG_CONTEXT, "FindController failed [0x%x], "
                                    "Force was not specified\n", 
                                    hr ));
        }
    }

    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "Controller change failed [0x%x]\n" ));
    }
  
    SAFEFREEBSTR( bstrController );

    return hr;
}



/********************************************************************++
 
Routine Description:
     
        Cleans the cluster info from a server

Arguments:
    
        bstrMember               - name of member to be cleaned

        fKeepExistingIPAddresses - whether to keep or not the currently 
                                   assigned IP addresses
                                   
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::CleanServer(
    IN BSTR bstrMember,
    IN BOOL fKeepExistingIPAddresses
    )
{
    HRESULT hr = S_OK;     
    CAcAuthUtil *pMemberAuth = NULL;

    if ( !bstrMember )
    {
        DBGERROR(( DBG_CONTEXT, "Error: bstrMember null\n"));
        return E_INVALIDARG;        
    }    

    hr = CreateAuth( bstrMember, &pMemberAuth );
    if ( FAILED ( hr ) ) 
    {
        DBGERROR(( DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }


    hr = MachineCleanup( pMemberAuth,
                         fKeepExistingIPAddresses );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "MachineCleanup failed [0x%x]\n", hr));
        goto Cleanup;        
    }
    
  
    DBGINFO(( DBG_CONTEXT, "CleanServer succeeded\n"));


Cleanup:

    if ( pMemberAuth )
    {
        delete pMemberAuth;
        pMemberAuth = NULL;
    }

    return hr;
}



/********************************************************************++
 
Routine Description:
     
        Disbands a cluster

Arguments:

        bstrMember               - name of the member (controller) of 
                                   the cluster to be disbanded

        fKeepExistingIPAddresses - whether to keep or not the currently 
                                   assigned IP addresses
        
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT CClusterSvcsUtil::DeleteCluster(
    IN BSTR bstrMember,
    IN BOOL fKeepExistingIPAddresses
    )
{   
    HRESULT hr = S_OK;
    CAcAuthUtil *pMemberAuth = NULL;
    int nMembers = 0;    

    if ( !bstrMember )
    {
        DBGERROR(( DBG_CONTEXT, "Error: bstrMember null\n"));
        return E_INVALIDARG;        
    }    

    hr = CreateAuth( bstrMember,
                     &pMemberAuth );
    if ( FAILED ( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }   
    
    //
    // Verify how many members are left in this cluster
    //
    hr = GetNumberOfMembers( pMemberAuth,
                             &nMembers );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "GetNumberOfMembers failed [0x%x]\n", hr));
        goto Cleanup;        
    }   

    //
    // We can only disband clusters that have one member left
    //
    if ( nMembers > 1 )
    {
        DBGERROR(( DBG_CONTEXT, "Can not disband cluster with more than one member\n"));
        //
        // TODO: Assign correct hresult
        //
        hr = E_INVALIDARG;
        goto Cleanup;
    }    

    hr = MachineCleanup( pMemberAuth,
                         fKeepExistingIPAddresses );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "MachineCleanup failed [0x%x]\n", hr));
        goto Cleanup;        
    }    

Cleanup:

    if ( pMemberAuth )
    {
        delete pMemberAuth;
        pMemberAuth = NULL;
    }
  
    return hr;
}


/********************************************************************++
 
Routine Description:
     
       Removes a member from a cluster. If the controller can not be
       reached and flag fForceRemove is specified, the function will
       try to remove the member locally (i.e. clean the member)
 
Arguments:
    
        bstrMember   - Name of member to be removed
        
        fForceRemove - Whether to remove the member locally (i.e. clean)
                       if the controller can not be found

NOTES:

       I am making this function private for now because it seems it doesn't
       make any sense to have this force flag anymore, so the overloaded 
       RemoveMember that receives the member and the controller name 
       should be enough, ar least for the provider. If we ever change the
       provider behavior (if we can get the Cluster instance from a member)
       then we may need this function, that's why I will keep it as
       private.

Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::RemoveMember(
    IN BSTR bstrMember,
    IN BOOL fForceRemove
    )
{
    HRESULT hr = S_OK;
    BSTR bstrController = NULL;
    
    if ( !bstrMember )
    {
        DBGERROR(( DBG_CONTEXT, "Error: bstrMember null\n"));
        return E_INVALIDARG;        
    }    

    //
    // Remove requires credentials to be set
    //
    if ( !m_fAuthSet )
    {
        DBGERROR(( DBG_CONTEXT, "Need to call SetAuth before calling RemoveMember\n"));
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }   
    
    //
    // Try to identify the controller of the cluster to which bstrMember belongs
    //

    hr = FindController( bstrMember,
                         &bstrController );
    if ( FAILED ( hr ) )
    {
        if ( fForceRemove )
        {            
            //
            // Controller could not be found, but forceRemove was specified,
            // so we will try to clean the member
            //

            DBGWARN(( DBG_CONTEXT,
                      "FindController failed [0x%x], trying to clean",
                      hr ));

            hr = CleanServer( bstrMember, FALSE );
            
            if ( FAILED( hr ) )
            {
                DBGERROR(( DBG_CONTEXT, "CleanServer failed [0x%x]\n", hr));
                goto Cleanup;
            }

            //
            // BUGBUG: If the member was previously cleaned and RemoveMember is 
            // called with the intention of removing it from the controller, the
            // command will succeed, because clean will be called and succeed (even though 
            // it was already cleaned), but the member will not be removed from
            // the cluster. Should we try to get the controller name from the 
            // provider and try to remove it from there when FindMaster fails with
            // PATH_NOT_FOUND ( 0x80070003 ) ?
            //
        }
        else 
        {
            //
            // Controller could not be found, forceRemove was not specified,
            // so we simply give up and fail
            //
            
            DBGERROR(( DBG_CONTEXT, 
                       "FindController failed [0x%x] and force not specified\n",
                       hr ));
            
            goto Cleanup;
        }        
    }
    else
    {
        //
        // Controller could be found, so we will try to remove the member
        // through the controller using IAsyncWebCluster
        //

        hr = RemoveMember( bstrMember,
                           bstrController );
        if ( FAILED( hr ))
        {
            DBGERROR(( DBG_CONTEXT, "RemoveMemberAsync failed [0x%x]\n", hr));
            goto Cleanup;        
        }
    }
        
Cleanup:
        
    SAFEFREEBSTR( bstrController );

    return hr;
}



/********************************************************************++
 
Routine Description:
     
    Adds a member to a cluster.
    
Arguments:
 
    bstrServer     - Machine to be added to cluster
    bstrController - Name of controller of the cluster to which the machine
                     will be added
    fSynchronize   - If the machine should be synchronized after addition
    fBringOnline   - If the machine should be brought online after addition

Note:

    If the cluster is NLB, SetNLBAdditionParameters should be called 
    first.

Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::AddMember(
     IN BSTR bstrServer,
     IN BSTR bstrController,
     IN BSTR bstrManagementNics,
     IN BOOL fSynchronize,
     IN BOOL fBringOnline
    )
{
    HRESULT hr = S_OK;
    
    BSTR bstrEventGuid = NULL;
    BSTR bstrPwd = NULL;
    CAcAuthUtil *pControllerAuth = NULL;
    IWebCluster *pIWebCluster = NULL;
    IAsyncWebCluster *pIAsyncWebCluster = NULL;
    CAcMBPollUtil mbPollUtil;

    if ( !bstrServer || !bstrController || !bstrManagementNics )
    {
        DBGERROR((DBG_CONTEXT,"Error: null server, controller or managnic\n"));
        return E_INVALIDARG;        
    }
        
    if ( !m_fAuthSet )
    {
        DBGERROR(( DBG_CONTEXT, "Need to call SetAuth before calling AddMember\n"));
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }
        
    hr = SetManagementNicsIndex( bstrManagementNics );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetManagementNicsIndex failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = ValidateAddParams( bstrServer );
    if ( FAILED ( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "ValidateAddParams failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = CreateAuth( bstrController,
                     &pControllerAuth);
    if ( FAILED ( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }
    
    hr = GetWebClusterItfs( pControllerAuth, 
                            TRUE,
                            &pIWebCluster,
                            &pIAsyncWebCluster );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "GetWebClusterItfs failed [0x%x]\n", hr));
        goto Cleanup;        
    }

    hr = GenerateStringGuid( &bstrEventGuid );
    if (FAILED(hr))
    {
       DBGERROR((DBG_CONTEXT, "GenerateStringGuid failed [0x%x]\n", hr));
       goto Cleanup;
    }

    if ( m_psecbstrPwd )
    {
        hr = m_psecbstrPwd->GetBSTR( &bstrPwd );
        if ( FAILED( hr ))
        {
            DBGERROR((DBG_CONTEXT, "CAcSecureBstr::GetBSTR failed 0x%x\n", hr));
            goto Cleanup;
        }
    }
  
    hr = pIAsyncWebCluster->AddServer( bstrEventGuid,
                                       bstrServer,
                                       m_bstrDedicatedIP,
                                       m_bstrDedicatedIPSubnetMask,
                                       m_bstrLBNicGuid,
                                       m_bstrManagementNicGuids,
                                       m_bstrUser,
                                       bstrPwd,
                                       m_bstrDomain,
                                       m_lAddServerFlags );
    m_psecbstrPwd->ReleaseBSTR( bstrPwd );

    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "AddServer failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = mbPollUtil.MBPoll( pControllerAuth, 
                            bstrEventGuid,
                            TOTAL_SERVER_ADD_TIMEOUT / MBPOLLUTIL_POLL_INTERVAL );
    if ( FAILED ( hr ))
    {
        DBGERROR((DBG_CONTEXT, "MBPoll failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:

    if ( pControllerAuth )
    {
        delete pControllerAuth;
        pControllerAuth = NULL;
    }
    
    SAFERELEASE( pIAsyncWebCluster );
    SAFERELEASE( pIWebCluster );    
    SAFEFREEBSTR( bstrEventGuid );
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 

Note:
        If the cluster is NLB, SetNLBCreationParameters should be called
        before the call to this function.
    
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::CreateCluster(
    IN BSTR bstrController,
    IN BSTR bstrClusterName,
    IN BSTR bstrClusterDescription,
    IN BSTR bstrClusterType,
    IN BSTR bstrManagementNics
    )
{
    HRESULT hr = S_OK;
    CAcAuthUtil *pControllerAuth = NULL;
    BSTR bstrEventGuid = NULL;
    BSTR bstrXmlInput = NULL;
    CAcMBPollUtil mbPollUtil;

    DBGINFO((DBG_CONTEXT, "CreateCluster\n"));

    if ( !bstrController  || !bstrClusterName   || 
         !bstrClusterType || !bstrManagementNics )
    {
        DBGERROR(( DBG_CONTEXT, "Null controller, name, type or manag nic\n"));
        return E_INVALIDARG;        
    }

    //
    // Validate parameters
    //
    hr = SetAndValidateCreateParams( bstrController,
                                     bstrClusterName, 
                                     bstrClusterDescription,
                                     bstrClusterType,
                                     bstrManagementNics );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "ValidateCreateParams failed [0x%x]\n", hr));
        goto Cleanup;
    }

    DBGINFO((DBG_CONTEXT, "CreateCluster2\n"));

    //
    // Build input XML
    //
    hr = BuildXmlInputForCreate( &bstrXmlInput );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "BuildXmlInputForCreate failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    DBGINFO((DBG_CONTEXT, "CreateCluster3\n"));

    DBGINFOW(( DBG_CONTEXT, L"XML: %s\n", const_cast<LPWSTR>( m_tstrXmlInput.QueryStr() ) ) );

    //
    // Create authentication object
    //
    hr = CreateAuth( bstrController,
                     &pControllerAuth);
    if ( FAILED ( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }
   
    DBGINFO((DBG_CONTEXT, "CreateCluster4\n"));
    //
    // Call Execute
    //
    hr = ExecuteClusterCmd( pControllerAuth,
                            SZ_CLSID_MachineSetup,                        
                            bstrXmlInput,
                            &bstrEventGuid
                           );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "ExecuteClusterCmd failed [0x%x]\n", hr));
        goto Cleanup;
    }
    
    //
    // Poll metabase to get the result of the operation
    //
    hr = mbPollUtil.MBPoll( pControllerAuth, 
                            bstrEventGuid,
                            TOTAL_SERVER_ADD_TIMEOUT / MBPOLLUTIL_POLL_INTERVAL );
    if ( FAILED ( hr ))
    {
        DBGERROR((DBG_CONTEXT, "MBPoll failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:

    if ( pControllerAuth )
    {
        delete pControllerAuth;
        pControllerAuth = NULL;
    }
    
    SAFEFREEBSTR( bstrEventGuid ); 
    SAFEFREEBSTR( bstrXmlInput );

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetAndValidateCreateParams( 
    IN BSTR bstrServer,
    IN BSTR bstrClusterName,
    IN BSTR bstrClusterDescription,
    IN BSTR bstrClusterType,
    IN BSTR bstrManagementNics
    )
{
    HRESULT hr = S_OK;      

    DBG_ASSERT( bstrServer );
    DBG_ASSERT( bstrClusterName );
    DBG_ASSERT( bstrClusterType );
    DBG_ASSERT( bstrManagementNics );

    if ( !bstrServer || !bstrClusterName || !bstrClusterType || !bstrManagementNics )
    {
        return E_INVALIDARG;
    }

    hr = SetClusterNameAndDescription( bstrClusterName,
                                       bstrClusterDescription );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetClusterNameAndDescription failed [0x%x]\n", hr ));
        goto Cleanup;
    }
           
    hr = SetClusterLBType( bstrClusterType );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetClusterLBType failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    //
    // *TODO* Restore the below
    //
// /*    
    if ( !_wcsicmp( bstrClusterType, WSZ_AC_LB_TYPE_NLB) )
    {
        if ( !m_fNLBCreationParamsSet )
        {
            DBGERROR(( DBG_CONTEXT, "Error: NLB params were not set\n"));
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = QueryLBNicGuid( bstrServer,
                           TRUE );
        if ( FAILED( hr ))
        {
            DBGERROR(( DBG_CONTEXT, "QueryLBNicGuid failed [0x%x]\n", hr ));
            goto Cleanup;
        }
    }

    hr = SetManagementNicsIndex( bstrManagementNics );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "  failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = QueryManagementNicGuids( bstrServer );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryManagementNicGuids failed [0x%x]\n", hr ));
        goto Cleanup;
    }
// */

/*
    m_bstrLBNicGuid = SysAllocString(L"11AE9840-04D2-4391-AE9B-9830F560BD8A");
    if ( !m_bstrLBNicGuid ) 
    {
        DBGERROR((DBG_CONTEXT, "Out fo memory!\n"));
        hr = E_OUTOFMEMORY;
    }

    m_bstrManagementNicGuids = SysAllocString(L"EEC52C52-16B8-4F82-A62C-FE645F5A487D");
    if ( !m_bstrManagementNicGuids ) 
    {
        DBGERROR((DBG_CONTEXT, "Out fo memory!\n"));
        hr = E_OUTOFMEMORY;
    }
*/

Cleanup:

    return hr;
}



/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::ValidateAddParams(
    IN BSTR bstrServer
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( bstrServer );

    if ( !bstrServer )
    {
        return E_INVALIDARG;
    }

    //
    // TODO: Need to get the type of LB of the cluster and verify that 
    // for that LB type, the correct parameters were passed. 
    // I will leave that to be done through the provider, once it's ready.
    //
    /*
    
    hr = GetLBType( &pwszLBType );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, GetLBType failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    if ( !_wcsicmp( pwszLBType, WSZ_AC_LB_TYPE_NLB) )
    {
        if ( !m_fNLBAdditionParamsSet )
        {
            DBGERROR(( DBG_CONTEXT, "Need to set NLB params first\n"));
            hr = E_INVALIDARG;
            goto Cleanup;            
        }   

        ( *** )
    }
    
    */

    // TODO Put this inside the check for NLB ( *** )
    hr = QueryLBNicGuid( bstrServer );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryLBNicGuid failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = QueryManagementNicGuids( bstrServer );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryManagementNicGuids failed [0x%x]\n", hr ));
        goto Cleanup;
    }    

Cleanup:

    return hr;
}




/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetClusterLBType(  
    BSTR bstrClusterLBType  
    )
{
    HRESULT hr = S_OK;  

    DBG_ASSERT( bstrClusterLBType );

    if ( !bstrClusterLBType )
    {
        return E_INVALIDARG;
    }

    //
    // Verify that the type provided is valid
    //
    if ( !IsValidValue( (LPWSTR) bstrClusterLBType, g_ppwszValidLBTypes ))
    {
        DBGERROR(( DBG_CONTEXT, "Invalid Loadbalancing %s\n", bstrClusterLBType ));
        hr = E_INVALIDARG;
        goto Cleanup;
    }    

    m_bstrClusterLBType = SysAllocString( bstrClusterLBType );
    if ( !m_bstrClusterLBType )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    if ( !_wcsicmp( m_bstrClusterLBType, WSZ_AC_LB_TYPE_NLB ) )
    {
        //
        // If cluster to be created is NLB, verify that the NLB parameters
        // were set previously. 
        //
        if ( !m_fNLBCreationParamsSet )
        {
            DBGERROR(( DBG_CONTEXT, "Need to set NLB params first\n"));
            hr = E_INVALIDARG;
            goto Cleanup;            
        }        
    }    


Cleanup:

    return hr;
}

/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetClusterAffinity(  
    IN BSTR bstrAffinity
    )
{
    HRESULT hr = S_OK;  

    if ( IsNullOrEmpty( bstrAffinity ) )
    {
        //
        // If a value was not provided we will use the default: single
        //
        m_bstrClusterAffinity = SysAllocString( WSZ_NLB_AFFINITY_SINGLE );
    }
    else
    {
        //
        // If an affinity was provided, verify it's a valid value
        //            
        if ( !IsValidValue( bstrAffinity, g_ppwszValidAffinity ) )
        {
                DBGERRORW(( DBG_CONTEXT, L"Invalid affinity %s\n", bstrAffinity ));
                hr = E_INVALIDARG;
                goto Cleanup;
        }

        m_bstrClusterAffinity = SysAllocString( bstrAffinity );
    }
    
    if ( !m_bstrClusterAffinity )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory\n" ));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return hr;
}

/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::BuildXmlInputForCreate(  
    OUT BSTR *pbstrXmlInput
    )
{

    HRESULT hr = S_OK;  
    
    DBG_ASSERT( m_bstrClusterName );
    DBG_ASSERT( m_bstrManagementNicGuids );    

    m_tstrXmlInput.Reset();    
    
    //
    // Insert generic header and cluster name
    //
    if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_CLUSTER_SETUP ) )      ||
         FAILED( hr = m_tstrXmlInput.Append( BEGIN_CLUSTER_SETUP_INFO ) ) ||
         FAILED( hr = m_tstrXmlInput.Append( BEGIN_NAME) )          ||
         FAILED( hr = m_tstrXmlInput.Append( m_bstrClusterName ) )  ||
         FAILED( hr = m_tstrXmlInput.Append( END_NAME ) )
       )
    {
        DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    //
    // Inserting cluster description, if provided
    //
    if ( m_bstrClusterDescription ) 
    {
        if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_DESCRIPTION ) ) ||
             FAILED( hr = m_tstrXmlInput.Append( m_bstrClusterDescription ) ) ||
             FAILED( hr = m_tstrXmlInput.Append( END_DESCRIPTION ) )   
           )
        {
            DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
            goto Cleanup;
        }
    }        
    
    hr = InsertLBInfoXml();
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    if ( FAILED ( hr = m_tstrXmlInput.Append( BEGIN_MANAGEMENT_NIC_GUIDS )) ||
         FAILED ( hr = m_tstrXmlInput.Append( m_bstrManagementNicGuids )) ||         
         FAILED ( hr = m_tstrXmlInput.Append( END_MANAGEMENT_NIC_GUIDS ))
        )
    {
        DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
        goto Cleanup;
    }
    
    //
    // Insert generic closing tags
    //    
    if ( FAILED( hr = m_tstrXmlInput.Append( END_CLUSTER_SETUP_INFO )) ||
         FAILED( hr = m_tstrXmlInput.Append( END_CLUSTER_SETUP ))) 
    {
        DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
        goto Cleanup;
    }
    
    (*pbstrXmlInput) = SysAllocString( m_tstrXmlInput.QueryStr() );
    if ( !(*pbstrXmlInput) )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    DBGINFOW(( DBG_CONTEXT, L"xml(BSTR): %s\n", (*pbstrXmlInput) ))

Cleanup:

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::InsertLBInfoXml(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( m_bstrClusterLBType );

    //
    // Insert Start of LB information
    //
    if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_CLUSTER_LB ))   ||
         FAILED( hr = m_tstrXmlInput.Append( BEGIN_LB_TYPE ))      ||
         FAILED( hr = m_tstrXmlInput.Append( m_bstrClusterLBType ))||
         FAILED( hr = m_tstrXmlInput.Append( END_LB_TYPE )) 
       )
    {
        DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
        goto Cleanup;
    }
    
    //
    // If LB is NLB, insert NLB info
    //
    if ( !_wcsicmp( m_bstrClusterLBType, WSZ_AC_LB_TYPE_NLB ) )
    {           
        if ( m_fKeepExistingNLBSettings )
        {
            //
            // Insert KeepSettings = TRUE
            //
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_KEEP_SETTINGS )) ||
                 FAILED( hr = m_tstrXmlInput.Append( WSZ_TRUE ))            ||
                 FAILED( hr = m_tstrXmlInput.Append( END_KEEP_SETTINGS ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }        
        }
        else
        {
            //
            // At this point, all the bstrs below have to be set with a value
            //
            DBG_ASSERT( m_bstrClusterIP );
            DBG_ASSERT( m_bstrClusterIPSubnetMask );
            DBG_ASSERT( m_bstrDedicatedIP );
            DBG_ASSERT( m_bstrDedicatedIPSubnetMask );
            DBG_ASSERT( m_bstrLBNicGuid );
            DBG_ASSERT( m_bstrClusterAffinity );

            //
            // Insert KeepSettings = FALSE
            //
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_KEEP_SETTINGS )) ||
                 FAILED( hr = m_tstrXmlInput.Append( WSZ_FALSE ))           ||
                 FAILED( hr = m_tstrXmlInput.Append( END_KEEP_SETTINGS ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }

            //
            // Insert ClusterIP And ClusterSubnetMask
            //
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_CLUSTER_IP )) ||
                 FAILED( hr = m_tstrXmlInput.Append( m_bstrClusterIP ))  ||
                 FAILED( hr = m_tstrXmlInput.Append( END_CLUSTER_IP ))   ||
                 FAILED( hr = m_tstrXmlInput.Append( BEGIN_CLUSTER_IP_SUBNET_MASK )) ||
                 FAILED( hr = m_tstrXmlInput.Append( m_bstrClusterIPSubnetMask ))    ||
                 FAILED( hr = m_tstrXmlInput.Append( END_CLUSTER_IP_SUBNET_MASK ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }
            
            //
            // Insert DedicatedIP And DedicatedIPSubnetMask
            //
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_DEDICATED_IP )) ||
                 FAILED( hr = m_tstrXmlInput.Append( m_bstrDedicatedIP ))  ||
                 FAILED( hr = m_tstrXmlInput.Append( END_DEDICATED_IP ))   ||
                 FAILED( hr = m_tstrXmlInput.Append( BEGIN_DEDIP_SUBNET_MASK )) ||
                 FAILED( hr = m_tstrXmlInput.Append( m_bstrDedicatedIPSubnetMask ))    ||
                 FAILED( hr = m_tstrXmlInput.Append( END_DEDIP_SUBNET_MASK ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }

            //
            // Insert LB Nics
            //            
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_LB_NIC_GUIDS )) ||
                 FAILED( hr = m_tstrXmlInput.Append( m_bstrLBNicGuid )) ||                  
                 FAILED( hr = m_tstrXmlInput.Append( END_LB_NIC_GUIDS ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }
            
            //
            // Insert Affinity
            //            
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_AFFINITY))         ||
                 FAILED( hr = m_tstrXmlInput.Append( m_bstrClusterAffinity )) ||
                 FAILED( hr = m_tstrXmlInput.Append( END_AFFINITY ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }
            
            //
            // Insert Multicast
            //            
            if ( FAILED( hr = m_tstrXmlInput.Append( BEGIN_MULTICAST ))         ||
                 FAILED( hr = m_tstrXmlInput.Append( m_fUnicastMode ? WSZ_FALSE : WSZ_TRUE )) ||
                 FAILED( hr = m_tstrXmlInput.Append( END_MULTICAST ))
               )
            {
                DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
                goto Cleanup;
            }           
        }
    }

    //
    // Insert End of LB information
    //    
    if ( FAILED( hr = m_tstrXmlInput.Append( END_CLUSTER_LB )))       
    {
        DBGERROR(( DBG_CONTEXT, "TSTRBUFFER::Append failed [0x%x]\n", hr ));
        goto Cleanup;
    }

Cleanup:

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetClusterNameAndDescription(
    IN BSTR bstrName,
    IN BSTR bstrDescription
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( bstrName );
   
    hr = AcValidateName( bstrName );
    if ( FAILED( hr ))
    {        
        DBGERRORW(( DBG_CONTEXT, L"Invalid Cluster Name: %s [0x%x]\n", bstrName, hr ));        
        goto Cleanup;
    }

    m_bstrClusterName = SysAllocString( bstrName );
    if ( !m_bstrClusterName )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( !IsNullOrEmpty( bstrDescription ) )
    {
        hr = ValidateName( bstrDescription,
                           g_pwszInvalidDescriptionChars,
                           TRUE,
                           MAX_DESCRIPTION_CHARS );
        if ( FAILED ( hr ) )
        {
            DBGERROR(( DBG_CONTEXT, "Description validation failed [0x%x]\n"));
            goto Cleanup;
        }

        m_bstrClusterDescription = SysAllocString( bstrDescription );

        if ( !m_bstrClusterDescription )
        {
            DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

Cleanup:

    return hr;
}
/********************************************************************++
 
Routine Description:
     
       Sets a member as the new controller using IWebCluster interface
       locally (and not through the old controller )
 
Arguments:
 
        BSTR bstrMember - The new controller

Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::LocalSetController(
    IN BSTR bstrMember
    )
{
    HRESULT hr = S_OK;
    CAcAuthUtil *pMemberAuth = NULL;
    IWebCluster *pIWebCluster = NULL;   
    
    if ( !bstrMember )
    {
        DBGERROR(( DBG_CONTEXT, "Error: null bstrMember\n"));
        return E_INVALIDARG;
    }
    
    //
    // Create the authentication object
    //
    hr = CreateAuth( bstrMember, &pMemberAuth );
    if ( FAILED ( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Get IWebClusterInterface 
    //
    hr = GetWebClusterItfs( pMemberAuth, 
                            FALSE,
                            &pIWebCluster,
                            NULL );
    if ( FAILED (hr) )
    {        
        DBGERROR((DBG_CONTEXT, "GetWebClusterItfs failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Set the member as the new controller
    //
    hr = pIWebCluster->SetClusterController( 0 );
    if (FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "SetClusterController (local) failed [0x%x]\n"));
        goto Cleanup;
    }

Cleanup:
    
    if ( pMemberAuth )
    {
        delete pMemberAuth;
        pMemberAuth = NULL;
    }

    SAFERELEASE( pIWebCluster );
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
        Uses IAsyncWebCluster to change the controller (via the old
        controller )
 
Arguments:
 
        BSTR bstrNewController - The name of the new controller
        BSTR bstrNewController - The name of the old (current) controller

Return Value:
 
    HRESULT
    
--********************************************************************/

HRESULT
CClusterSvcsUtil::ChangeControllerAsync(
    IN BSTR bstrNewController,
    IN BSTR bstrOldController    
    )
{
    HRESULT hr = S_OK;
    CAcMBPollUtil mbPollUtil;
    BSTR bstrEventGuid = NULL;
    CAcAuthUtil *pControllerAuth = NULL;
    IWebCluster *pIWebCluster = NULL;
    IAsyncWebCluster *pIAsyncWebCluster = NULL;

    if ( !bstrNewController || !bstrOldController )
    {
        DBGERROR(( DBG_CONTEXT, "Error: oldcontroller or newcontroller null\n"));
        return E_INVALIDARG;
    }
    
    //
    // Create the authentication object.
    //
    hr = CreateAuth( bstrOldController, &pControllerAuth );
    if ( FAILED ( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Get IAsyncWebCluster
    //  
    hr = GetWebClusterItfs( pControllerAuth,
                            TRUE,
                            &pIWebCluster,
                            &pIAsyncWebCluster );
    if ( FAILED ( hr ) )
    {        
        DBGERROR((DBG_CONTEXT, "GetWebClusterItfs failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = GenerateStringGuid( &bstrEventGuid );
    if (FAILED(hr))
    {
       DBGERROR((DBG_CONTEXT, "GenerateStringGuid failed [0x%x]\n", hr));
       goto Cleanup;
    }
    
    hr = pIAsyncWebCluster->SetClusterController( bstrEventGuid,
                                                  bstrNewController,
                                                  0 );
    if ( FAILED( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, 
                  "SetClusterController async failed, Error 0x%x\n",
                  hr));
        goto Cleanup;
    }
     
    hr = mbPollUtil.MBPoll( pControllerAuth, bstrEventGuid );
    if ( FAILED ( hr ))
    {
        DBGERROR((DBG_CONTEXT, "MBPoll failed [0x%x]\n", hr));
        goto Cleanup;
    }

    DBGINFO(( DBG_CONTEXT, "ChangeControllerAsync succeeded\n"));


Cleanup:

    if ( pControllerAuth )
    {
        delete pControllerAuth;
        pControllerAuth = NULL;
    }

    SAFERELEASE( pIWebCluster );
    SAFERELEASE( pIAsyncWebCluster );
    SAFEFREEBSTR( bstrEventGuid );

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::RemoveMember(
    IN BSTR bstrMember,
    IN BSTR bstrController
    )
{
    HRESULT hr = S_OK;

    BSTR bstrEventGuid = NULL;
    BSTR bstrPwd = NULL;
    CAcAuthUtil *pControllerAuth = NULL;
    IWebCluster *pIWebCluster = NULL;
    IAsyncWebCluster *pIAsyncWebCluster = NULL;    
    CAcMBPollUtil mbPollUtil;

    if ( !bstrMember || !bstrController )
    {
        DBGERROR(( DBG_CONTEXT, "Error: null member or controller\n"));
        return E_INVALIDARG;
    }

    //
    // Remove requires credentials to be set
    //
    if ( !m_fAuthSet )
    {
        DBGERROR(( DBG_CONTEXT, "Need to call SetAuth before calling RemoveMember\n"));
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }   

    hr = CreateAuth( bstrController,
                     &pControllerAuth);
    if ( FAILED ( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = GetWebClusterItfs( pControllerAuth, 
                            TRUE,
                            &pIWebCluster,
                            &pIAsyncWebCluster );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "GetWebClusterItfs failed [0x%x]\n", hr));
        goto Cleanup;        
    }

    hr = GenerateStringGuid( &bstrEventGuid );
    if ( FAILED( hr ))
    {
       DBGERROR((DBG_CONTEXT, "GenerateStringGuid failed [0x%x]\n", hr));
       goto Cleanup;
    }

    if( m_psecbstrPwd )
    {
        hr = m_psecbstrPwd->GetBSTR( &bstrPwd );
        if ( FAILED( hr ))
        {
            DBGERROR((DBG_CONTEXT, "CAcSecureBstr::GetBSTR failed 0x%x\n", hr));
            goto Cleanup;
        }
    }

    hr = pIAsyncWebCluster->RemoveServer ( bstrEventGuid,
                                           bstrMember,
                                           m_bstrUser,
                                           bstrPwd,
                                           m_bstrDomain,
                                           0 );
    m_psecbstrPwd->ReleaseBSTR( bstrPwd );

    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "RemoveServer failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = mbPollUtil.MBPoll( pControllerAuth, 
                            bstrEventGuid,
                            SERVER_REMOVAL_TIMEOUT / MBPOLLUTIL_POLL_INTERVAL );
    if ( FAILED ( hr ))
    {
        DBGERROR((DBG_CONTEXT, "MBPoll failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:

    if ( pControllerAuth )
    {
        delete pControllerAuth;
        pControllerAuth = NULL;
    }

    SAFERELEASE( pIAsyncWebCluster );
    SAFERELEASE( pIWebCluster );
    SAFEFREEBSTR( bstrEventGuid );

    return hr;

}
/********************************************************************++
 
Routine Description:
     
        Figures out which member is the cluster controller
 
Arguments:
 
        pbstrController - Returns the controller name

Return Value:
 
    HRESULT
    
--********************************************************************/

HRESULT
CClusterSvcsUtil::FindController(
    IN BSTR bstrMember,
    OUT BSTR *pbstrController
    )
{

    HRESULT hr = S_OK;
    IWebClusterDiscoverMaster *pIDiscoverMaster = NULL;   
    CAcAuthUtil *pMemberAuth = NULL;

    DBG_ASSERT( pbstrController );
    DBG_ASSERT( bstrMember );

    if ( !bstrMember || !pbstrController )
    {
        return E_INVALIDARG;
    }

    *pbstrController = NULL;
    
    hr = CreateAuth( bstrMember, &pMemberAuth );
    if ( FAILED ( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }
    
    hr = pMemberAuth->CreateInstance( CLSID_WebClusterDiscoverMaster,
                                      NULL,                    
                                      IID_IWebClusterDiscoverMaster,
                                      (void **) &pIDiscoverMaster );        
    if ( FAILED( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, 
                  "CoCreateInstance failed, Error = 0x%x\n", 
                  hr));
        goto Cleanup;     
    }

    hr = pIDiscoverMaster->DiscoverClusterMaster( 1, 
                                                  30000, 
                                                  pbstrController );
    if ( FAILED( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, 
                  "DiscoverClusterMaster failed, Error = 0x%x\n",
                  hr));
        goto Cleanup;
    }        

    DBGINFOW(( DBG_CONTEXT, L"Cluster Controller: %s\n", *pbstrController ));

Cleanup:    
    
    SAFERELEASE( pIDiscoverMaster );
    
    if ( pMemberAuth )
    {
        delete pMemberAuth;
        pMemberAuth = NULL;
    }

    return hr;
}


/********************************************************************++
 
Routine Description:
     
        Sets authentication info
 
Arguments:
 
        bstrUser    - User name 
        bstrDomain  - Domain 
        psecbstrPwd - Pointer to a secure BSTR with the password
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetAuth(
    IN BSTR bstrUser,
    IN BSTR bstrDomain,
    IN CAcSecureBstr *psecbstrPwd
    )
{
    HRESULT hr = S_OK;

    if ( IsNullOrEmpty( bstrUser ) )
    {
        DBGERROR(( DBG_CONTEXT, "User cannot be NULL or empty\n"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else
    {
        m_bstrUser = SysAllocString(bstrUser);
        if ( !m_bstrUser )
        {
            DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if ( bstrDomain )
    {
        m_bstrDomain = SysAllocString(bstrDomain);
        if ( !m_bstrDomain )
        {
            DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }    

    if ( psecbstrPwd )
    {
        m_psecbstrPwd = new CAcSecureBstr();
        if ( !m_psecbstrPwd )
        {
            DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = m_psecbstrPwd->Assign( (*psecbstrPwd) );
        if ( FAILED( hr ) )
        {
            DBGERROR(( DBG_CONTEXT, "CAcSecureBstr.Assign failed [0x%x]\n"));
            goto Cleanup;
        }
    }

    m_fAuthSet = TRUE;

Cleanup:

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::SetNLBAdditionParameters(
    IN BSTR bstrLBNic,
    IN BSTR bstrDedicatedIP,
    IN BSTR bstrDedicatedIPSubnetMask
    )
{
    HRESULT hr = S_OK;        

    hr = SetLBNicIndex( bstrLBNic );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetLBNicIndex failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = SetDedicatedIPAndSubnetMask( bstrDedicatedIP,
                                      bstrDedicatedIPSubnetMask
                                     );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetLBNicIndex failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    m_fNLBAdditionParamsSet = TRUE;

Cleanup:

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::SetNLBCreationParameters(
    IN BOOL fKeepExistingNLBSettings,
    IN BSTR bstrLBNics,
    IN BSTR bstrClusterIP,
    IN BSTR bstrClusterIPSubnetMask,
    IN BSTR bstrDedicatedIP,
    IN BSTR bstrDedicatedIPSubnetMask,
    IN BSTR bstrAffinity,
    IN BOOL fUnicastMode
    )
{
    HRESULT hr = S_OK;

    BOOL fbstrLBNics = !IsNullOrEmpty( bstrLBNics );
    BOOL fbstrClusterIP = !IsNullOrEmpty( bstrClusterIP );
    BOOL fbstrClusterIPSubnetMask = !IsNullOrEmpty( bstrClusterIPSubnetMask );
    BOOL fbstrDedicatedIP = !IsNullOrEmpty( bstrDedicatedIP );
    BOOL fbstrDedicatedIPSubnetMask = !IsNullOrEmpty( bstrDedicatedIPSubnetMask );
    BOOL fbstrAffinity = !IsNullOrEmpty( bstrAffinity );

    //
    // Check that if KeepExistingNLBSettings is set, none of the
    // other NLB parameters are also set
    //
    if ( fKeepExistingNLBSettings )
    {
        if ( fbstrLBNics                ||
             fbstrClusterIP             ||
             fbstrClusterIPSubnetMask   ||
             fbstrDedicatedIP           ||
             fbstrDedicatedIPSubnetMask ||
             fbstrAffinity )
        {
            DBGERROR((DBG_CONTEXT, "KeepExistingNLBSettings is set, so cannot "
                                   "accept any other NLB parameter\n"));
            hr = E_INVALIDARG;
            goto Cleanup;
                                  
        }
        else
        {
            DBGINFO(( DBG_CONTEXT, "KeepExistingNLBSettings is set\n" ));
            goto Cleanup;
        }
    }

    //
    // If we are here, it's because we are "clean installing" NLB, i.e.
    // we are not keeping existing settings, we have to configure it from
    // scratch. We will check that the required params were provided. 
    // The others have default values and can be NULL
    //

    if ( !fbstrLBNics              ||
         !fbstrClusterIP           ||
         !fbstrClusterIPSubnetMask )
    {
        DBGERROR(( DBG_CONTEXT, "LB Nic, Cluster IP and Subnet can't be NULL"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = SetLBNicIndex( bstrLBNics );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetLBNicIndex failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = SetClusterIPAndSubnetMask( bstrClusterIP,
                                    bstrClusterIPSubnetMask );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetClusterIPAndSubnetMask failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = SetDedicatedIPAndSubnetMask( bstrDedicatedIP,
                                      bstrDedicatedIPSubnetMask );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetDedicatedIPAndSubnetMask failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    hr = SetClusterAffinity( bstrAffinity );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "SetClusterAffinity failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    m_fUnicastMode = fUnicastMode;

    m_fNLBCreationParamsSet = TRUE;

Cleanup:

     return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetDedicatedIPAndSubnetMask(
    IN BSTR bstrDedIP,
    IN BSTR bstrSubnetMask
    )
{
    HRESULT hr = S_OK;

    if ( IsNullOrEmpty( bstrDedIP ) !=
         IsNullOrEmpty( bstrSubnetMask ) 
       )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Have to set both or none DedIP & SubnetMask\n" ));
        return E_INVALIDARG;        
    }    
 
    if ( IsNullOrEmpty( bstrDedIP ) )
    {
        m_bstrDedicatedIP = SysAllocString( WSZ_DUMMY_DEDICATED_IP );
        m_bstrDedicatedIPSubnetMask = SysAllocString( WSZ_DUMMY_DED_IP_SUBNET );            
    }
    else 
    {        
        m_bstrDedicatedIP = SysAllocString( bstrDedIP );
        m_bstrDedicatedIPSubnetMask = SysAllocString( bstrSubnetMask );        
    }

    if ( !m_bstrDedicatedIP  ||
         !m_bstrDedicatedIPSubnetMask)
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


Cleanup:
    return hr;
}



/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetClusterIPAndSubnetMask(
    IN BSTR bstrClusterIP,
    IN BSTR bstrClusterIPSubnetMask
    )
{
    HRESULT hr = S_OK;

    if ( IsNullOrEmpty( bstrClusterIP )           ||
         IsNullOrEmpty( bstrClusterIPSubnetMask )
       )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Have to set Cluster IP AND SubnetMask\n" ));
        return  E_INVALIDARG;        
    }    

    m_bstrClusterIP = SysAllocString( bstrClusterIP );
    if ( !m_bstrClusterIP )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    m_bstrClusterIPSubnetMask = SysAllocString( bstrClusterIPSubnetMask );
    if ( !m_bstrClusterIPSubnetMask )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    return hr;
}



/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetManagementNicsIndex(
    IN BSTR bstrManagementNicIndexes
    )
{        
    HRESULT hr = S_OK;

    if ( IsNullOrEmpty(bstrManagementNicIndexes) )
    {
        DBGERROR(( DBG_CONTEXT, "Error: management nic NULL or empty\n"));
        return E_INVALIDARG;
        goto Cleanup;
    }
    
    m_bstrManagementNicIndexes = SysAllocString( bstrManagementNicIndexes );

    if ( !m_bstrManagementNicIndexes )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;    
    }

Cleanup:
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::SetLBNicIndex(  
    IN BSTR bstrLBNicIndex
    )
{    

    HRESULT hr = S_OK;

    if ( IsNullOrEmpty( bstrLBNicIndex ))
    {        
        DBGERROR(( DBG_CONTEXT, "Error: LB Nic NULL or empty\n" ));
        return E_INVALIDARG;
        goto Cleanup;
    }
    
    m_bstrLBNicIndex = SysAllocString( bstrLBNicIndex );

    if ( !m_bstrLBNicIndex )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory! \n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    
    }

Cleanup:

    return hr;
}



/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::QueryLBNicGuid(
    IN BSTR bstrServer,
    IN BOOL fCheckStaticIP
    )
{    

    HRESULT hr = S_OK;
    IEnumWbemClassObject *pIEnumWbemClassObject = NULL;    
    LPWSTR pwszQuery = NULL;
    VARIANT *pvarProperty = NULL; 
    DWORD dwInstances = 0;
    WCHAR wszTmpGuid[ MAX_GUID_LENGTH ];
    
    DBG_ASSERT( bstrServer );

    if ( !bstrServer )
    {
        return E_INVALIDARG;
    }

    pwszQuery = new WCHAR[ wcslen( g_pwszNicInfoQuery ) + wcslen( m_bstrLBNicIndex ) + 1];
    if ( !pwszQuery )
    {
        DBGERROR(( DBG_CONTEXT, "Out of memory!\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    wcscpy( pwszQuery, g_pwszNicInfoQuery );
    wcscat( pwszQuery, m_bstrLBNicIndex );

    hr = QueryWmiObjects( bstrServer,
                          pwszQuery,
                          &pIEnumWbemClassObject );          
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryWmiObjects failed [0x%x]\n", hr )); 
        goto Cleanup;
    }    

    if ( fCheckStaticIP )
    {
        hr = CheckNicHasStaticIP( pIEnumWbemClassObject );                                 
        if (FAILED ( hr ))
        {
            DBGERROR(( DBG_CONTEXT, "CheckNicHasStaticIP failed [0x%x]\n", hr )); 
            goto Cleanup;
        }        
    }

    hr = QueryWmiProperties( pIEnumWbemClassObject,
                             g_pwszSettingIDProperty,
                             &pvarProperty,
                             &dwInstances );
    if (FAILED ( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryWmiProperties failed [0x%x]\n", hr )); 
        goto Cleanup;
    }

    if ( ( dwInstances != 1 ) || ( pvarProperty[0].vt != VT_BSTR ) )
    {
        DBGERROR(( DBG_CONTEXT, "Retrieved invalid %d properties\n", dwInstances ));
        hr = E_INVALIDARG;
        goto Cleanup;
    }        

    hr = GetGuidWithoutBrackets( (LPWSTR) pvarProperty[0].bstrVal,
                                 wszTmpGuid );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "GetGuidWithoutBrackets failed[0x%x]\n", hr ));
        goto Cleanup;
    }

    m_bstrLBNicGuid = SysAllocString( wszTmpGuid );
    if ( !m_bstrLBNicGuid )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Out of memory! \n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    
    }        

Cleanup:

    if ( pvarProperty )
    {        
        for (DWORD dw = 0; dw < dwInstances; dw++)
        {
            VariantClear( &( pvarProperty[dw] ) );
        }

        delete [] pvarProperty;
    }

    if ( pwszQuery )
    {
        delete [] pwszQuery;    
    }
    
    SAFERELEASE( pIEnumWbemClassObject );
    return hr;
}


/********************************************************************++
 
Routine Description:
     
    Returns S_OK if property DHCPEnabled of the WMI instance of a NIC
    is FALSE, E_INVALIDARG otherwise
 
Arguments:
    
    pIEnumWbemClassObject - Enumeration object that should contain
                            one instance of Win32_NetworkAdapterConfiguration
                            ( retrieved in function QueryLBNicGuid )
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::CheckNicHasStaticIP(
    IN IEnumWbemClassObject *pIEnumWbemClassObject
    )
{
    HRESULT hr = S_OK;

    VARIANT *pvarProperty = NULL; 
    DWORD dwInstances = 0;

    DBG_ASSERT( pIEnumWbemClassObject );
    if ( !pIEnumWbemClassObject )
    {
        return E_INVALIDARG;
    }

    hr = QueryWmiProperties( pIEnumWbemClassObject,
                             g_pwszDHCPEnabledProperty,
                             &pvarProperty,
                             &dwInstances);
    if (FAILED ( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryWmiProperties failed [0x%x]\n", hr )); 
        goto Cleanup;
    }

    //
    // Check that we received one instance, and the type is correct
    //
    if ( ( dwInstances != 1 ) || ( pvarProperty[0].vt != VT_BOOL) )
    {
        DBGERROR(( DBG_CONTEXT, "Received %d invalid property(ies) \n", dwInstances )); 
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if ( pvarProperty[0].boolVal == VARIANT_TRUE )
    {
        DBGERROR((DBG_CONTEXT,
                  "Error: Specified LB Nic doesn't have static IP\n"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else
    {        
        DBGINFO(( DBG_CONTEXT, "Specified LB Nic has static IP\n"));
    }    

Cleanup:

    if ( pvarProperty )
    {
        for ( DWORD dw = 0; dw < dwInstances; dw++ )
        {
            VariantClear( &( pvarProperty[dw]) );
        }

        delete [] pvarProperty;
    }

    return hr;
}



/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::QueryManagementNicGuids(
    IN BSTR bstrServer
    )
{

    HRESULT hr = S_OK;
    IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
    DWORD dwInstances = 0;
    VARIANT *pvarGuids = NULL; 
    LPWSTR pwszQuery = NULL;

    DBG_ASSERT( bstrServer );

    if ( !bstrServer )
    {
        return E_INVALIDARG;
    }

    hr = BuildManagementNicGuidQuery( &pwszQuery );
    if ( FAILED( hr ))
    {
        DBGERROR((DBG_CONTEXT,"BuildManagementNicGuidQuery failed [0x%x]\n",hr));
        goto Cleanup;
    }

    DBGINFOW(( DBG_CONTEXT, L"Query: %s\n", pwszQuery ));

    hr = QueryWmiObjects( bstrServer,
                          pwszQuery,
                          &pIEnumWbemClassObject);
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryWmiObjects failed [0x%x]\n", hr ));        
       goto Cleanup;
    }
   

    hr = QueryWmiProperties(pIEnumWbemClassObject,
                            g_pwszSettingIDProperty,
                            &pvarGuids,
                            &dwInstances);
    if (FAILED ( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "QueryWmiProperties failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    if ( dwInstances <= 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = BuildManagementNicGuidsList( pvarGuids,
                                      dwInstances );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "BuildManagementNicGuidsList failed [0x%x]\n",hr));
        goto Cleanup;
    }


Cleanup:

    if ( pvarGuids )
    {
        for ( DWORD dw = 0; dw < dwInstances; dw++ )
        {
            VariantClear( &( pvarGuids[dw]) );
        }

        delete [] pvarGuids;
    }
   
    if ( pwszQuery )
    {
        delete [] pwszQuery;
    }

    SAFERELEASE( pIEnumWbemClassObject );

    return hr;

}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 

Notes:
        
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::BuildManagementNicGuidQuery(
    OUT LPWSTR *ppwszQuery
    )
{
    HRESULT hr = S_OK;    
    LPWSTR pwszToken = NULL;   
    LPWSTR pwszQuery = NULL;
    int nApproximateNics = 0;

    DBG_ASSERT( m_bstrManagementNicIndexes );
    DBG_ASSERT( ppwszQuery );

    if ( !m_bstrManagementNicIndexes || !ppwszQuery )
    {
        return E_INVALIDARG;
    }

    // TODO Comment
    nApproximateNics = ( wcslen( m_bstrManagementNicIndexes ) + 1 ) / 2;

    // TODO Comment
    pwszQuery = new WCHAR[ 
                         wcslen( g_pwszNicInfoQuery ) +
                         nApproximateNics + 1 +
                       ( nApproximateNics * wcslen( g_pwszNicQueryComplement ) )
                         ];
    if ( !pwszQuery )
    {
        DBGERROR(( DBG_CONTEXT, "Out of memory\n" ));        
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    wcscpy( pwszQuery, g_pwszNicInfoQuery );

    // TODO comment
    pwszToken = wcstok( m_bstrManagementNicIndexes, L"," );

    if ( !pwszToken )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Null pwszToken\n"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // TODO comment
    wcscat( pwszQuery, pwszToken );
    
    // TODO comment
    pwszToken = wcstok( NULL, L"," );

    while ( pwszToken != NULL )
    {                
        wcscat( pwszQuery, g_pwszNicQueryComplement );
        wcscat( pwszQuery, pwszToken );

        pwszToken = wcstok( NULL, L"," );
    }    

Cleanup:

    if ( FAILED( hr ) )
    {
        if ( pwszQuery )
        {
            delete [] pwszQuery;
            pwszQuery = NULL;
        }
    }

    *ppwszQuery = pwszQuery;

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 

Notes:
        
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::BuildManagementNicGuidsList(
            VARIANT *pvarProperty,
            IN DWORD dwInstances
            )
{
    HRESULT hr = S_OK;

    LPWSTR pwszListOfGuids = NULL;
    WCHAR wszTmpGuid[ MAX_GUID_LENGTH ];  
    DWORD dw = 0;

    DBG_ASSERT( pvarProperty );
    if ( !pvarProperty )
    {
        return E_INVALIDARG;
    }

    // TODO Comment this size
    pwszListOfGuids = new WCHAR[ (MAX_GUID_LENGTH * dwInstances ) + dwInstances ];
    if ( !pwszListOfGuids )
    {
        DBGERROR(( DBG_CONTEXT, "Out of memory\n" ));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    wcscpy(pwszListOfGuids, L"");
    
    for ( dw = 0 ; dw < dwInstances - 1; dw++)
    {       
        hr = GetGuidWithoutBrackets( (LPWSTR) pvarProperty[dw].bstrVal,
                                     wszTmpGuid );
        if ( FAILED( hr ))
        {
            DBGERROR(( DBG_CONTEXT, "GetGuidWithoutBrackets failed[0x%x]\n", hr ));
            goto Cleanup;
        }

        wcscat( pwszListOfGuids, wszTmpGuid );
        wcscat( pwszListOfGuids, L"," );
    }
    
    hr = GetGuidWithoutBrackets( (LPWSTR) pvarProperty[dw].bstrVal,
                                 wszTmpGuid );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "GetGuidWithoutBrackets failed[0x%x]\n", hr ));
        goto Cleanup;
    }

    wcscat( pwszListOfGuids, wszTmpGuid );
    
    m_bstrManagementNicGuids = SysAllocString( pwszListOfGuids );
    if ( !m_bstrManagementNicGuids )
    {
        DBGERROR(( DBG_CONTEXT, "Out of memory\n" ));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    if ( pwszListOfGuids )
    {
        delete [] pwszListOfGuids;
        pwszListOfGuids = NULL;
    }

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::QueryWmiObjects(
    IN LPWSTR pwszServer,
    IN LPWSTR pwszQuery,
    OUT IEnumWbemClassObject **ppIEnumWbemClassObject
    )
{
    HRESULT hr = S_OK;
    BOOL fIsLocalMachine = FALSE;

    DBG_ASSERT( pwszServer );
    DBG_ASSERT( pwszQuery );
    DBG_ASSERT( ppIEnumWbemClassObject );

    if ( !pwszServer || !pwszQuery || !ppIEnumWbemClassObject)
    {
        DBGERROR(( DBG_CONTEXT, "Null server, query or out param\n"));
        return E_INVALIDARG;
    }

    *ppIEnumWbemClassObject = NULL;
    
    hr = IsLocalMachine( pwszServer, &fIsLocalMachine );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT,"IsLocalMachine failed : 0x%x\n", hr));
        goto Cleanup;
    }

    DBGINFOW((DBG_CONTEXT, L"Server: %s \nQuery: %s\n", pwszServer, pwszQuery));

    //    
    // If we are in the machine we are querying
    //
    if ( fIsLocalMachine )
    {   
        //
        // Execute local query
        //

        DBGINFO((DBG_CONTEXT, "Executing local query\n"));
        
        hr = ExecuteWMIQuery( LOCAL_CIMV2_NAMESPACE,
                              pwszQuery,
                              ppIEnumWbemClassObject);  
    }
    else 
    {   
        //
        // Execute remote query  
        //

        BSTR bstrPwd = NULL;        
        
        //
        // Verify if a pwd was provided. If so, we need to get it from the securebstr
        //
        if ( m_psecbstrPwd )
        {
            hr = m_psecbstrPwd->GetBSTR( &bstrPwd );
            if ( FAILED( hr ))
            {
                DBGERROR((DBG_CONTEXT, "CAcSecureBSTR::GetBSTR failed 0x%x\n", hr));
                goto Cleanup;
            }
        }

        DBGINFO((DBG_CONTEXT, "Executing remote query\n"));
        
        hr = ExecuteWMIQuery( pwszServer,
                              CIMV2_NAMESPACE,
                              m_bstrUser,
                              m_bstrDomain,
                              bstrPwd,
                              pwszQuery,
                              ppIEnumWbemClassObject );
        //
        // Release the plain text password
        //
        if ( bstrPwd )
        {
            m_psecbstrPwd->ReleaseBSTR( bstrPwd );
        }
    }

    if ( FAILED( hr ))
    {
        DBGERRORW((DBG_CONTEXT, L"Error executing query, Error 0x%x\n",hr));        
        goto Cleanup;
    }

Cleanup:

    if ( FAILED( hr ) )
    {
        SAFERELEASE( ( *ppIEnumWbemClassObject ) );
    }

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 

Notes:
    
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT
CClusterSvcsUtil::QueryWmiProperties(
    IN IEnumWbemClassObject *pIEnumWbemClassObject,
    IN LPWSTR pwszPropertyName,
    OUT VARIANT **ppvarProperties,
    OUT DWORD *pdwInstances
    )
{

    HRESULT hr = S_OK;
    DWORD dwInstances = 0;
    VARIANT *pvarProperties = NULL;
    IWbemClassObject *pIWbemClassObject = NULL;
    int i = 0;
    int nLastInitialized = 0;

    DBG_ASSERT( pIEnumWbemClassObject );
    DBG_ASSERT( pwszPropertyName );
    DBG_ASSERT( ppvarProperties );
    DBG_ASSERT( pdwInstances );


    if ( !pIEnumWbemClassObject || !pwszPropertyName || 
         !ppvarProperties       || !pdwInstances      )
    {
        return E_INVALIDARG;
    }

    hr = CountWMIInstances( pIEnumWbemClassObject, 
                            &dwInstances );
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "CountWMIInstances failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    if ( dwInstances <= 0 )
    {
        DBGERROR(( DBG_CONTEXT, "Error: dwInstances = %d\n", dwInstances ));
        hr = E_INVALIDARG;
        goto Cleanup;
    }
   
    pvarProperties = new VARIANT[dwInstances];
    if ( !pvarProperties )
    {
        DBGERROR((DBG_CONTEXT, "Out of memory\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for (DWORD dw = 0; dw < dwInstances; dw++)
    {   
        SAFERELEASE( pIWbemClassObject );

        VariantInit( &( pvarProperties[dw] ) );        

        nLastInitialized = dw;

        hr = GetNthWMIObject( pIEnumWbemClassObject,
                              dw,
                              &pIWbemClassObject );
        if ( FAILED( hr ))
        {
            DBGERROR(( DBG_CONTEXT, "GetNthWMIObject failed [0x%x]\n", hr ));
            goto Cleanup;
        }

        hr = GetWMIInstanceProperty( pIWbemClassObject,
                                     pwszPropertyName,
                                     &( pvarProperties[dw] ),
                                     FALSE );
        if ( FAILED( hr ))
        {
            DBGERROR(( DBG_CONTEXT, "GetNthWMIObject failed [0x%x]\n", hr ));
            goto Cleanup;
        }
    }

Cleanup:

    if ( FAILED( hr ) )
    {
        if ( pvarProperties )
        {
            for ( int i = nLastInitialized ; i >= 0 ; i-- )
            {
                VariantClear( &( pvarProperties[i] ) );
            }        

            delete [] pvarProperties;

            pvarProperties = NULL;
        }

        dwInstances = 0;
    }

    *pdwInstances = dwInstances;

    *ppvarProperties = pvarProperties;

    SAFERELEASE( pIWbemClassObject ); 
    return hr;

}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::MachineCleanup( 
    IN CAcAuthUtil *pAuth,
    IN BOOL fKeepExistingIPAddresses
    )
{
    HRESULT hr = S_OK;    
    BSTR bstrEventGuid = NULL;    
    CAcMBPollUtil mbPollUtil;

    DBG_ASSERT( pAuth );   

    if ( !pAuth )
    {
        return E_INVALIDARG;
    }
    
    hr = ExecuteClusterCmd( pAuth,
                            SZ_CLSID_MachineCleanup,                      
                            fKeepExistingIPAddresses ? g_pwszNoRemoveIps : NULL,
                            &bstrEventGuid);
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "ExecuteClusterCmd failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = mbPollUtil.MBPoll( pAuth, 
                            bstrEventGuid,
                            SERVER_REMOVAL_TIMEOUT / MBPOLLUTIL_POLL_INTERVAL );
    if ( FAILED ( hr ))
    {
        DBGERROR((DBG_CONTEXT, "MBPoll failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:

    SAFEFREEBSTR( bstrEventGuid );    
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::GetNumberOfMembers(
    IN CAcAuthUtil *pAuth,
    OUT int *pnMembers
)
{
    HRESULT hr = S_OK;
    IWebCluster *pIWebCluster = NULL;
    LPWSTR  pwszMembersList = NULL;    
    VARIANT varMembersList;
    int nMembers = 0;    

    DBG_ASSERT( pAuth );
    DBG_ASSERT( pnMembers );

    if ( !pAuth || !pnMembers )
    {
        return E_INVALIDARG;
    }

    VariantInit( &varMembersList );

    hr = GetWebClusterItfs( pAuth, 
                            FALSE,
                            &pIWebCluster,
                            NULL );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "GetWebClusterItfs failed [0x%x]\n", hr));
        goto Cleanup;        
    }    

    hr = pIWebCluster->GetServerList( &varMembersList );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT,
                  "IWebCluster::GetServerList failed, Error = 0x%x\n",
                  hr));
        goto Cleanup;
    }

    DBG_ASSERT( varMembersList.vt == VT_BSTR );
        
    if ( !varMembersList.bstrVal )
    {
        DBGERROR((DBG_CONTEXT, "Error: MemberList is NULL"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    pwszMembersList = const_cast<LPWSTR>(varMembersList.bstrVal);

    //
    // Count the number of members by verifying how many times
    // the tag <CLUSTER_MEMBER GUID= is present
    //
    while (pwszMembersList = wcsstr( pwszMembersList, XML_CLUSTER_MEMBER_START ) )
    {
        pwszMembersList++;
        nMembers++;    
    }    

Cleanup:

    SAFERELEASE( pIWebCluster );
    VariantClear( &varMembersList );
    
    *pnMembers = nMembers;
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::ExecuteClusterCmd(
    IN CAcAuthUtil *pAuth,
    IN LPCWSTR pwszAction,     
    IN LPCWSTR pwszInput, 
    OUT BSTR *pbstrEventGuid
    )
{
    HRESULT hr = S_OK;
    
    IExtensibleClusterCmd *pIExtensibleClusterCmd = NULL;
    BSTR bstrAction = NULL;
    BSTR bstrInput = NULL;    

    //
    // pwszInput can be NULL, the other parameters can't
    //

    DBG_ASSERT( pAuth );
    DBG_ASSERT( pwszAction );  
    DBG_ASSERT( pbstrEventGuid );

    if ( !pAuth || !pwszAction || !pbstrEventGuid )
    {
        return E_INVALIDARG;
    }

    *pbstrEventGuid = NULL;

    hr = GetExtensibleClusterCmdItf( pAuth,
                                     &pIExtensibleClusterCmd );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "GetExtensibleClusterCmdItf failed [0x%x]\n", hr));
        goto Cleanup;
    }
    
    hr = GenerateStringGuid( pbstrEventGuid );
    if (FAILED(hr))
    {
       DBGERROR((DBG_CONTEXT, "GenerateStringGuid failed [0x%x]\n", hr));
       goto Cleanup;
    }
    //
    // There has to be an action (see ASSERT above)
    //
    bstrAction = SysAllocString( pwszAction );
    if (NULL == bstrAction) 
    {
        DBGERROR((DBG_CONTEXT, "Error: Out of memory!\n"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // pwszInput can be NULL, so we test here if there's an input that we need
    // to pass or not
    //
    if ( pwszInput )
    {
        bstrInput = SysAllocString( pwszInput );
        if ( NULL == bstrInput )
        {
            DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // Call Execute
    hr = pIExtensibleClusterCmd->Execute( ACS_COMPLETION_FLAG_MB,
                                            bstrAction,
                                            L"", //asbstrEmpty,
                                            (*pbstrEventGuid),
                                            bstrInput,
                                            L"", //asbstrEmpty,
                                            L"", //asbstrEmpty,
                                            L""); //asbstrEmpty);
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "Execute failed [0x%x]\n", hr ));
        goto Cleanup;
    }

Cleanup:
    
    SAFERELEASE( pIExtensibleClusterCmd );
    SAFEFREEBSTR( bstrAction );
    SAFEFREEBSTR( bstrInput );

    if ( FAILED( hr ))
    {
        SAFEFREEBSTR( (*pbstrEventGuid) );
    }
        
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT CClusterSvcsUtil::CallSetOnlineStatus( 
    IN BSTR bstrMember,
    IN BOOL fOnline,  
    IN LONG lDrainTime,
    IN LONG lFlags)
{
    HRESULT hr = S_OK;    
    CAcAuthUtil *pMemberAuth = NULL;
    ILocalClusterInterface *pILocalClusterInterface = NULL;
    DWORD dwOperations = OPERATION_ONLINE;

    if ( !bstrMember )
    {
        return E_INVALIDARG;
    }

    hr = CreateAuth( bstrMember, &pMemberAuth );
    if ( FAILED ( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "CreateAuth failed [0x%x]\n", hr));
        goto Cleanup;
    }

    if ( lDrainTime )
    {
        dwOperations |= OPERATION_DRAIN;
    }

    hr = ValidateLBOperation( pMemberAuth,
                              dwOperations);
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, "ValidateLBOperation failed [0x%x]\n", hr ));
        goto Cleanup;
    }
                              

    hr = GetLocalClusterItf( pMemberAuth,
                             &pILocalClusterInterface);
    if ( FAILED( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "InitializeLocalClusterItf failed [0x%x]\n", hr));
        goto Cleanup;
    }
    
    hr = pILocalClusterInterface->SetOnlineStatus( fOnline ? VARIANT_TRUE : VARIANT_FALSE,
                                                   lDrainTime,
                                                   lFlags);
    if ( FAILED( hr ))
    {
        DBGERROR(( DBG_CONTEXT, 
                   "ILocalClusterIntf::SetOnlineStatus failed [0x%x]\n",
                   hr));
        goto Cleanup;
    }

Cleanup:

    if ( pMemberAuth )
    {
        delete pMemberAuth;
        pMemberAuth = NULL;
    }

    SAFERELEASE( pILocalClusterInterface );
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::ValidateLBOperation(
    IN CAcAuthUtil *pAuth,
    IN DWORD dwOperations            
    )
{
    HRESULT hr = S_OK;    
    CMetaUtil mu;
    DWORD dwCapabilities;

    DBG_ASSERT( pAuth );   

    if ( !pAuth )
    {        
        return E_INVALIDARG;
    }

    hr = mu.Connect( *pAuth );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, "mu.connect failed [0x%x]\n", hr ));
        goto Cleanup;
    }       

    hr = mu.Get( CLUSTER_PATH, 
                 MD_AC_LB_CAPABILITIES,
                 DWORD_METADATA, 
                 &dwCapabilities, 
                 sizeof(DWORD));
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "mu.Get failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    if ( ( dwOperations & OPERATION_ONLINE ) &&
        !( dwCapabilities & MD_AC_LB_CAPABILITY_SUPPORTS_ONLINE ) )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Online/offline not supported\n"));
        hr = AC_ERROR_NOT_SUPPORTED_IN_CLUSTER;
        goto Cleanup;
    }

    if ( ( dwOperations & OPERATION_DRAIN ) &&
        !( dwCapabilities & MD_AC_LB_CAPABILITY_SUPPORTS_DRAIN ) )
    {
        DBGERROR(( DBG_CONTEXT, "Error: Drain not supported\n"));
        hr = AC_ERROR_NOT_SUPPORTED_IN_CLUSTER;
        goto Cleanup;
    }    

Cleanup:    

    return hr;

}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::CreateAuth(
    IN BSTR bstrServer,
    OUT CAcAuthUtil **ppAuth    
    )
{
    HRESULT hr = S_OK;
    CAcAuthUtil *pAuth = NULL;
    LPWSTR pwszUserDomain = NULL;
    BSTR bstrUserDomain = NULL;

    DBG_ASSERT( ppAuth );        
    DBG_ASSERT( bstrServer ); 

    if ( !bstrServer || !ppAuth )
    {
        return E_INVALIDARG;
    }
    
    if ( !m_bstrUser )
    {
        hr = E_INVALIDARG;
        DBGERROR((DBG_CONTEXT, "Invalid credentials: no user\n"));
        goto Cleanup;
    }

    pAuth = new CAcAuthUtil();
    if ( !pAuth )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR( ( DBG_CONTEXT, "Error: Out of memory!\n" ) );
        goto Cleanup;
    }

    //
    // Create and CreateEx require format domain\username, so we need to append
    //    
    hr = GetAppendedUserDomain( &pwszUserDomain );
    if ( FAILED( hr ) )
    {
        DBGERROR(( DBG_CONTEXT, "GetAppendedUserDomain failed [0x%x]\n", hr ));
        goto Cleanup;
    }

    //
    // If a password was specified, we need to call CreateEx because 
    // it requires a SecureBSTR
    //
    if ( m_psecbstrPwd )
    {
        hr = pAuth->CreateEx( (LPCWSTR) bstrServer,
                              pwszUserDomain,
                              ( *m_psecbstrPwd ) );
    }
    //
    // Otherwise we call a method Create
    //
    else
    {   
        //
        // Create requires the parameters as BSTRs, so we will convert pwszUserDomain
        //
        if ( pwszUserDomain )
        {
            bstrUserDomain = SysAllocString( pwszUserDomain );
        
            if ( !bstrUserDomain )
            {            
                DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n" ));
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }        

        hr = pAuth->Create( bstrServer,
                            bstrUserDomain,
                            NULL );
    }

    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, "CAcAuthUtil::Create failed [0x%x]\n", hr));        
        goto Cleanup;
    }

Cleanup:

    if ( FAILED( hr ) && pAuth ) 
    {
        delete pAuth;
        pAuth = NULL;
    }

    if ( pwszUserDomain )
    {
        delete [] pwszUserDomain;
    }

    SAFEFREEBSTR( bstrUserDomain );
    *ppAuth = pAuth;

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::GetAppendedUserDomain(
    OUT LPWSTR *ppwszUserDomain
    )
{
    HRESULT hr = S_OK;
    LPWSTR pwszUserDomain = NULL;    
    int nLenUser = 0;
    int nLenDomain = 0;

    DBG_ASSERT( ppwszUserDomain );    

    if ( !ppwszUserDomain )
    {
        return E_INVALIDARG;
    }

    nLenUser += (m_bstrUser ? wcslen( m_bstrUser ) : 0);
    nLenDomain += (m_bstrDomain ? wcslen( m_bstrDomain ) : 0);
    
    if ( ( nLenUser + nLenDomain ) > 0 )
    {
        pwszUserDomain = new WCHAR [ nLenUser + nLenDomain + 2];
        if ( !pwszUserDomain )
        {
            hr = E_OUTOFMEMORY;
            DBGERROR(( DBG_CONTEXT, "Error: Out of memory!\n"));
            goto Cleanup;
        }

        wcscpy( pwszUserDomain, L"" );
        
        if ( nLenDomain )
        {
            wcscat( pwszUserDomain, (LPCWSTR) m_bstrDomain );            
            wcscat( pwszUserDomain, L"\\" );            
        }

        wcscat( pwszUserDomain, (LPCWSTR) m_bstrUser );
        DBGINFOW(( DBG_CONTEXT, L"UserDomain: %s\n", pwszUserDomain));
    }

Cleanup:

    if ( FAILED( hr ) && pwszUserDomain )
    {
        delete [] pwszUserDomain;
        pwszUserDomain = NULL;
    }

    *ppwszUserDomain = pwszUserDomain;

    return hr;
}

/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT CClusterSvcsUtil::GetLocalClusterItf(
    IN CAcAuthUtil *pAuth,
    OUT ILocalClusterInterface **ppILocalClusterInterface
    )
{
    HRESULT hr = S_OK;
    ILocalClusterInterface *pILocalClusterInterface = NULL;

    DBG_ASSERT( pAuth );
    DBG_ASSERT( ppILocalClusterInterface )

    if ( !pAuth || !ppILocalClusterInterface )
    {
        return E_INVALIDARG;
    }

    hr = pAuth->CreateInstance( CLSID_LocalClusterInterface,
                                0,
                                IID_ILocalClusterInterface, 
                                (void **) &pILocalClusterInterface
    );

    if (FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "Create ILocalClusterIntrf failed [0x%x]\n", hr));        
        goto Cleanup;
    }

Cleanup:

    if ( FAILED( hr ) )
    {
        SAFERELEASE( pILocalClusterInterface );
    }

    *ppILocalClusterInterface = pILocalClusterInterface;

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT CClusterSvcsUtil::GetExtensibleClusterCmdItf(
    IN CAcAuthUtil *pAuth,
    OUT IExtensibleClusterCmd **ppIExtensibleClusterCmd
    )
{
    HRESULT hr = S_OK;
    IExtensibleClusterCmd *pIExtensibleClusterCmd = NULL;

    DBG_ASSERT( pAuth );
    DBG_ASSERT( ppIExtensibleClusterCmd );

    if ( !pAuth || !ppIExtensibleClusterCmd )
    {
        return E_INVALIDARG;
    }

    hr = pAuth->CreateInstance( CLSID_ExtensibleClusterCmd,
                                0,                
                                IID_IExtensibleClusterCmd,
                                (void **) &pIExtensibleClusterCmd);
    if ( FAILED( hr ))
    {
        DBGERROR((DBG_CONTEXT, "CoCI IExtensibleClusterCmd failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:

    if ( FAILED( hr ) )
    {
        SAFERELEASE( pIExtensibleClusterCmd );        
    }

    *ppIExtensibleClusterCmd = pIExtensibleClusterCmd;

    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::GetWebClusterItfs(
    IN CAcAuthUtil *pAuth,           
    IN BOOL fGetAsync,
    OUT IWebCluster **ppIWebCluster,
    OUT IAsyncWebCluster **ppIAsyncWebCluster
    )
{
    HRESULT hr = S_OK;
    IWebCluster *pIWebCluster = NULL;
    IAsyncWebCluster *pIAsyncWebCluster = NULL;

    DBG_ASSERT( pAuth );
    DBG_ASSERT( ppIWebCluster );

    if ( !pAuth || !ppIWebCluster || ( fGetAsync && !ppIAsyncWebCluster ) )
    {
        return E_INVALIDARG;
    }    

    hr = pAuth->CreateInstance( CLSID_WebCluster,
                                0,
                                IID_IWebCluster,
                                (void**) &pIWebCluster );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, 
                  "AcAuthUtil::CreateInstance failed, Error = 0x%x\n",
                   hr));
        goto Cleanup;
    }

    //
    // If AsyncWebCluster is required, get it
    //
    if ( fGetAsync )
    {
        DBG_ASSERT( ppIAsyncWebCluster );

        hr = GetIAsyncWebCluster( pIWebCluster,
                                  pAuth,
                                  &pIAsyncWebCluster );
        if ( FAILED( hr ) )
        {
            DBGERROR((DBG_CONTEXT, 
                  "AcAuthUtil::CreateInstance failed, Error = 0x%x\n",
                   hr));

            SAFERELEASE( pIAsyncWebCluster );
        }

        *ppIAsyncWebCluster = pIAsyncWebCluster;
    }

    
Cleanup:
    
    if ( FAILED( hr ) )
    {
        SAFERELEASE( pIWebCluster );        
    }

    *ppIWebCluster = pIWebCluster;

    return hr;
}




/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CClusterSvcsUtil::GetIAsyncWebCluster(
    IN IWebCluster *pIWebCluster,
    IN CAcAuthUtil *pAuth,
    OUT IAsyncWebCluster **ppIAsyncWebCluster
    )
{
    HRESULT hr = S_OK;
    IAsyncWebCluster *pIAsyncWebCluster = NULL;

    DBG_ASSERT( pIWebCluster );
    DBG_ASSERT( ppIAsyncWebCluster );
    DBG_ASSERT( pAuth );

    if ( !pIWebCluster || !pAuth || !ppIAsyncWebCluster )
    {
        return E_INVALIDARG;
    }
    
    hr = pIWebCluster->GetAsync( &pIAsyncWebCluster );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, "GetAsync failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Set the security as we didn't get through the wrapper
    //
    hr = pAuth->SetInterfaceSecurity( ( IUnknown *) pIAsyncWebCluster );
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, 
                  "AcAuthUtil::SetInterfaceSecurity failed, Error = 0x%x\n",
                  hr));   
        goto Cleanup;
    }

    hr = pIAsyncWebCluster->Initialize( ACS_COMPLETION_FLAG_MB,
                                        NULL,                                         
                                        NULL,
                                        NULL,
                                        NULL);
    if ( FAILED( hr ) )
    {
        DBGERROR((DBG_CONTEXT, 
                  "IAsyncWebCluster::Initialize failed, Error = 0x%x\n",
                  hr));
        goto Cleanup;
    }        
    
Cleanup:
    
    if ( FAILED( hr ) )
    {
        SAFERELEASE( pIAsyncWebCluster );
    }

    *ppIAsyncWebCluster = pIAsyncWebCluster;

    return hr;   
}

/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    None
    
--********************************************************************/
CAcMBPollUtil::CAcMBPollUtil() :
m_pwszPath( NULL ),
m_pwszKey( NULL ),
m_pwszCompletePath( NULL )
{
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    None
    
--********************************************************************/
CAcMBPollUtil::~CAcMBPollUtil()
{
    if ( m_pwszPath )
    {
        delete [] m_pwszPath;
    }

    if ( m_pwszKey )
    {
        delete [] m_pwszKey;
    }

    if ( m_pwszCompletePath )
    {
        delete [] m_pwszCompletePath;
    }
   
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT CAcMBPollUtil::MBPoll(
    IN CAcAuthUtil *pAuth,
    IN BSTR bstrEventGuid,
    IN int cPolls,
    IN int nInterval
    )
{
    HRESULT hr = S_OK;
    HRESULT hrMB = S_OK;
    int i = 1;

    if ( !pAuth || !bstrEventGuid )
    {
        DBGERROR(( DBG_CONTEXT, "Error: NULL pAuth or EventGuid\n"));
        return E_INVALIDARG;
    }

    if ( ( cPolls <= 0 ) || ( nInterval <= 0 ) )
    {
        DBGERROR(( DBG_CONTEXT, "Error: cPolls or nInterval < 0\n"));
        return E_INVALIDARG;
    }

    if ( FAILED ( hr = SetPath( CLSTRCMD_RESULT_PATH )) ||
         FAILED ( hr = SetKey( bstrEventGuid )) ||
         FAILED ( hr = SetCompletePath ()))
    {
        DBGERROR((DBG_CONTEXT, "Error setting MB path [0x%x]\n", hr));
        return hr;
    }

    DBGINFO(( DBG_CONTEXT, "Poll interval: %d Max polls: %d\n", nInterval, cPolls ));

    while ( i <= cPolls )
    {
        DBGINFO(( DBG_CONTEXT, "MB Poll #%d\n", i ));

        hr = MBRead( pAuth,                     
                     &hrMB );
        if ( FAILED ( hr ) )
        {
            DBGINFO((DBG_CONTEXT, "MB poll not ready [0x%x]\n", hr));

        }
        else 
        {
            if ( FAILED (hrMB ) )
            {
                DBGERROR(( DBG_CONTEXT, "Read Failure out of MB [0x%x]\n", hrMB));
            }

            break;
        }

        Sleep( nInterval );

        i++;
    }

    if ( i >= cPolls)
    {
        DBGERROR((DBG_CONTEXT, "MetabaseRead timed out\n"));                    
        hrMB = RETURNCODETOHRESULT( ERROR_TIMEOUT );
    }    
   
    return hrMB;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT CAcMBPollUtil::MBRead(
    IN CAcAuthUtil *pAuth,    
    OUT HRESULT *phrMB
    )
{
    HRESULT hr = S_OK;
    HRESULT hrMB = S_OK; 
    HRESULT hrTemp = S_OK; 
    TSTRBUFFER tstrPollingResult;
    CMetaUtil mbutil;

    tstrPollingResult.Reset();
        
    DBG_ASSERT( pAuth );   
    DBG_ASSERT( phrMB );
    
    hr = mbutil.Connect( *pAuth );
    if ( FAILED( hr ) ) 
    {
        DBGERROR((DBG_CONTEXT, "CMetaUtil::Connect failed[0x%x]\n", hr));
        goto Cleanup;
    }
       
    hr = mbutil.Get(m_pwszCompletePath,
                    MD_WEBCLUSTER_CMD_HRESULT,
                    DWORD_METADATA,
                    &hrMB,
                    sizeof(phrMB));
    if ( FAILED( hr ))
    {
        DBGERROR((DBG_CONTEXT, "MB.Get failed [0x%x]\n", hr));
        goto Cleanup;
    }

    if ( SUCCEEDED( hrMB ))    
    {
        CAcBstr acbstrResult;          
        hr = mbutil.Get ( m_pwszCompletePath,
                      MD_WEBCLUSTER_CMD_OUTPUT,
                      acbstrResult);
        if ( FAILED( hr ))
        {                       
            if (hr == MD_ERROR_DATA_NOT_FOUND)   
            {
                //
                // Not an error, just there's no output
                //
                DBGWARN((DBG_CONTEXT, "GetData returns no output, 0x%x\n",
                                       hr));
                hr = S_OK;
            }            
            else
            {
                //
                // MetabaseRead failed
                //
                DBGERROR((DBG_CONTEXT,
                          "Unexpected error in MetabaseRead of output, "
                          "Error = 0x%x\n",
                          hr));
                goto Cleanup;
            }                
        }
        else 
        {
            hr = tstrPollingResult.Copy((BSTR)acbstrResult);
            if ( FAILED( hr ))
            {
                DBGERROR((DBG_CONTEXT, "m_tstrPollingResult.Copy failed\n"));
                 
            }
            else 
            {
                DBGWARNW((DBG_CONTEXT, L"GetData returns an output %s\n",
                                       tstrPollingResult.QueryStr()));
            }
        }
            
    }

    //
    // We do not need to fail the whole operation because
    // deleteKey failed, but it's good to know there's something
    // wrong with it.
    //
    hrTemp = mbutil.DeleteKey(m_pwszPath, m_pwszKey);
    if ( FAILED( hrTemp ))
    {
        DBGWARN((DBG_CONTEXT, "mu.DeleteKey failed 0x%x\n", hrTemp));
        goto Cleanup;
    }

Cleanup:
    *phrMB = hrMB;

    return hr;
}






/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CAcMBPollUtil::SetPath(
    IN LPCWSTR pwszPath
    )
{
    HRESULT hr = S_OK;

    m_pwszPath = new WCHAR [ wcslen (pwszPath) + 1];
    if (!m_pwszPath)
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "Error: Out of memory!\n"));
        goto Cleanup;
    }

    wcscpy(m_pwszPath, pwszPath);

    DBGINFOW((DBG_CONTEXT, L"MB Path: %s\n", m_pwszPath));
    
Cleanup:
    return hr;
}
    

/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CAcMBPollUtil::SetKey(
    IN LPCWSTR pwszKey
    )
{   
    HRESULT hr = S_OK;

    m_pwszKey = new WCHAR [ wcslen (pwszKey) + 1];
    if (!m_pwszKey)
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "Error: Out of memory!\n"));
        goto Cleanup;
    }

    wcscpy(m_pwszKey, pwszKey);

    DBGINFOW((DBG_CONTEXT, L"MB Key: %s\n", m_pwszKey));

Cleanup:
    return hr;
}



/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT 
CAcMBPollUtil::SetCompletePath()
{
    HRESULT hr = S_OK;

    DBG_ASSERT(m_pwszPath);
    DBG_ASSERT(m_pwszKey);

    m_pwszCompletePath = new WCHAR [ wcslen( m_pwszPath ) + wcslen( m_pwszKey ) + 2];
    if (!m_pwszCompletePath)
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "Error: Out of memory!\n"));
        goto Cleanup;
    }

    wcscpy(m_pwszCompletePath, m_pwszPath);
    wcscat(m_pwszCompletePath, L"/");
    wcscat(m_pwszCompletePath, m_pwszKey);

    DBGINFOW((DBG_CONTEXT, L"MB CompletePath: %s\n", m_pwszCompletePath));

Cleanup:
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/
BOOL IsValidValue(LPWSTR pwszValue, LPWSTR *ppwszValidValues)
{

    // TODO Put in a separate file
    BOOL fValidValue = FALSE;

    if ( !pwszValue || !ppwszValidValues )
    {
        goto Cleanup;
    }
        
    // Iterate through the valid cluster types to see if the user
    // provided one of the valid values present in the array
    for ( int i = 0; 
          sizeof( ppwszValidValues ) / sizeof( ppwszValidValues[0] ); 
          i++
        )
    {
        if ( !_wcsicmp( pwszValue,
                        ppwszValidValues[i] ))
        {
            fValidValue = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
        
    return fValidValue;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Notes:

    Assumes that wszGuidWithoutBrackets is an array big enough to hold
    a GUID.

Return Value:
 
    HRESULT
    
--********************************************************************/
HRESULT GetGuidWithoutBrackets( IN LPWSTR pwszGuid,
                                OUT WCHAR  wszGuidWithoutBrackets[] )
{
    HRESULT hr = S_OK;

    int nLen; 

    DBGINFO((DBG_CONTEXT, "getguid\n"));

    if ( !pwszGuid || !wszGuidWithoutBrackets)
    {
        hr = E_INVALIDARG;   
        goto Cleanup;
    }

    nLen = wcslen( pwszGuid );

    if ( ( pwszGuid[0] != L'{')  || 
         ( pwszGuid[nLen - 1] != L'}' )
       )
    {
        DBGWARN((DBG_CONTEXT, "No brackets in guid, returning\n"));
        hr = S_FALSE;
        goto Cleanup;
    }

    wcsncpy(wszGuidWithoutBrackets, pwszGuid + 1, nLen - 2 );
    wszGuidWithoutBrackets[ nLen - 2 ] = L'\0';

Cleanup:
    
    return hr;
}


/********************************************************************++
 
Routine Description:
     
 
Arguments:
 
 
Return Value:
 
    HRESULT
    
--********************************************************************/

HRESULT 
ValidateName( LPWSTR pwszName, 
              LPWSTR pwszInvalidChars, 
              BOOL fVerifyLen,
              UINT iMaxLen
              )
{
    HRESULT hr = S_OK;
    
    if (!pwszName || !pwszInvalidChars)
    {
        DBGERROR(( DBG_CONTEXT, "Name or invalichar NULL\n"));
        return E_INVALIDARG;        
    }

    if ( fVerifyLen )
    {
        // Verifying the length
        if ( wcslen( pwszName ) > iMaxLen )
        {
            DBGINFOW((DBG_CONTEXT, L"Error: Name %s longer than maxlen %d\n",
                      pwszName,
                      iMaxLen));
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // Verifying if the name contains any invalid character
    if ( wcslen( pwszName ) != wcscspn( pwszName, pwszInvalidChars ))
    {
        DBGINFOW((DBG_CONTEXT, 
                  L"Name %s contains one or more of the invalid chars:%s\n",
                  pwszName,
                  pwszInvalidChars));        
        hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\providerguids.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    netframeworkprov.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __NETFRAMEWORKPROV_H__
#define __NETFRAMEWORKPROV_H__

#pragma once

#include "catmacros.h"

// {4EAEB44E-BA24-4f5a-8F89-8D656E4600F9}
DEFINE_GUID(CLSID_CProvider, 
0x4eaeb44e, 0xba24, 0x4f5a, 0x8f, 0x89, 0x8d, 0x65, 0x6e, 0x46, 0x0, 0xf9);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\methodprov.cpp ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    methodprov.cpp
 
Abstract:
 
    This file contains the implementation of the Application Center
    WMI Provider methods.
 
Author:
 
    Suzana Canuto (suzanac)        04/10/01
 
Revision History:
 
--********************************************************************/
#include "methodprov.h"
#include "dbgutil.h"


//
// Table that contains information about the methods implemented by 
// this provider. It has, for each AC WMI method, the name of the wmi class,
// the name of the wmi method and a pointer to the corresponding implementation.
//
const CMethodHelper::METHOD_INFO CAcMethodProv::sm_rgMethodInfo[] =
{ 
    //
    // MicrosoftAC_Cluster methods
    //
    {L"MicrosoftAC_Cluster",       L"Create",          (PMethodFunc)CAcMethodProv::Cluster_Create},
    {L"MicrosoftAC_Cluster",       L"Delete",          (PMethodFunc)CAcMethodProv::Cluster_Delete},
    {L"MicrosoftAC_Cluster",       L"AddMember",       (PMethodFunc)CAcMethodProv::Cluster_AddMember},
    {L"MicrosoftAC_Cluster",       L"RemoveMember",    (PMethodFunc)CAcMethodProv::Cluster_RemoveMember},
    
    //
    // MicrosoftAC_ClusterMember methods
    //    
    {L"MicrosoftAC_ClusterMember", L"SetAsController", (PMethodFunc)CAcMethodProv::Member_SetAsController},
    {L"MicrosoftAC_ClusterMember", L"SetOnline",       (PMethodFunc)CAcMethodProv::Member_SetOnline},
    {L"MicrosoftAC_ClusterMember", L"SetOffline",      (PMethodFunc)CAcMethodProv::Member_SetOffline},
    {L"MicrosoftAC_ClusterMember", L"Clean",           (PMethodFunc)CAcMethodProv::Member_Clean},
        
    //
    // MicrosoftAC_DeploymentJob methods
    //    
    {L"MicrosoftAC_DeploymentJob", L"Deploy",          (PMethodFunc)CAcMethodProv::Dummy},
    {L"MicrosoftAC_DeploymentJob", L"Terminate",       (PMethodFunc)CAcMethodProv::Dummy},
};


//
// Table that contains information about the parameters for the methods
// exposed by this provider. It has, for each AC WMI parameter, the name 
// of the class, the name of the method, the name of the parameter and a
// BOOL stating whether the parameter is required or not.
//
const CMethodHelper::PARAM_INFO CAcMethodProv::sm_rgParamInfo[] =
{ 
    //
    // WMI Class                   WMI Method          WMI ParamName                       Required?
    //
    {L"MicrosoftAC_Cluster",       L"Create",          L"ClusterName",                     TRUE},
    {L"MicrosoftAC_Cluster",       L"Create",          L"ClusterDescription",              FALSE},
    {L"MicrosoftAC_Cluster",       L"Create",          L"ControllerComputerName",          TRUE},
    {L"MicrosoftAC_Cluster",       L"Create",          L"Credentials",                     FALSE},
    {L"MicrosoftAC_Cluster",       L"Create",          L"ClusterCreationParameters",       TRUE},

    {L"MicrosoftAC_Cluster",       L"Delete",          L"UserCredentials",                 FALSE},
    {L"MicrosoftAC_Cluster",       L"Delete",          L"ClusterDeletionParameters",       FALSE},

    {L"MicrosoftAC_Cluster",       L"AddMember",       L"MemberComputerName",              TRUE},
    {L"MicrosoftAC_Cluster",       L"AddMember",       L"UserCredentials",                 TRUE},
    {L"MicrosoftAC_Cluster",       L"AddMember",       L"ClusterMemberAdditionParameters", TRUE},

    {L"MicrosoftAC_Cluster",       L"RemoveMember",    L"MemberComputerName",              TRUE},
    {L"MicrosoftAC_Cluster",       L"RemoveMember",    L"UserCredentials"               ,  TRUE},
    {L"MicrosoftAC_Cluster",       L"RemoveMember",    L"ClusterMemberRemovalParameters",  TRUE},
    
    {L"MicrosoftAC_ClusterMember", L"SetAsController", L"Force",                           TRUE},

    {L"MicrosoftAC_ClusterMember", L"SetOnline",       L"IgnoreHealthMonStatus",           FALSE},

    {L"MicrosoftAC_ClusterMember", L"SetOffline",      L"DrainTime",                       FALSE},
        
    {L"MicrosoftAC_ClusterMember", L"Clean",           L"MemberRemovalParameters",         FALSE},
       
    {L"MicrosoftAC_DeploymentJob", L"Deploy",          L"UserCredentials",                 FALSE},

    {L"MicrosoftAC_DeploymentJob", L"Terminate",       L"UserCredentials",                 FALSE},
};

/********************************************************************++
 
Routine Description:
 
    This function performs some initialization required for the methods
    implemented in the base class to run correctly.
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Initialize()
{
    HRESULT hr = S_OK;
    m_cMethods = sizeof(sm_rgMethodInfo)/sizeof(sm_rgMethodInfo[0]);    
    m_cParams = sizeof(sm_rgParamInfo)/sizeof(sm_rgParamInfo[0]);    
    m_fInitialized = TRUE;
    return hr;
}   


/********************************************************************++
 
Routine Description:
 
    Changes the cluster controller. The new controller will be the
    one whose corresponding instance the "SetAsController" method
    was called on 
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Member_SetAsController()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "SetAsController\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Brings the member online. The member is the one whose corresponding 
    instance the "SetOnline" method was called on 
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Member_SetOnline()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "SetOnline\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Brings the member offline. The member is the one whose corresponding 
    instance the "SetOffline" method was called on 
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Member_SetOffline()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "SetOffline\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Cleans all the cluster information from the member. The member is the 
    one whose corresponding instance the "Clean" method was called on 
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Member_Clean()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "Clean\n"));
    return hr;
}

HRESULT CAcMethodProv::Dummy()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "Dummy\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Creates a cluster.
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Cluster_Create()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "Create\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Deletes a cluster. The cluster that will be deleted is the one that
    is represented by the instance on which method "Delete" was called.
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Cluster_Delete()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "Delete\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Adds a member to a cluster.
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Cluster_AddMember()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "AddMember\n"));
    return hr;
}


/********************************************************************++
 
Routine Description:
 
    Removes a member from the cluster.
      
Arguments:
 
    NONE

Return Value:
 
    HRESULT
 
--********************************************************************/
HRESULT CAcMethodProv::Cluster_RemoveMember()
{
    HRESULT hr = E_NOTIMPL;
    DBGINFO((DBG_CONTEXT, "RemoveMember\n"));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\methodprov.h ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    methodprov.h
 
Abstract:
 
    This file contains definition of class CAcMethodProv
 
Author:
 
    Suzana Canuto (suzanac)        04/10/01
 
Revision History:
 
--********************************************************************/
#pragma once

#include "methodhelper.h"


/********************************************************************++
 
Class Name:
 
    CAcMethodProv
 
Class Description:
 
    Implements the methods of AC WMI provider. Inherits from CMethodHelper.
     
--********************************************************************/
class CAcMethodProv: public CMethodHelper
{

public:       
    HRESULT Member_SetAsController();
    HRESULT Member_SetOnline();
    HRESULT Member_SetOffline();
    HRESULT Member_Clean();

    HRESULT Cluster_Create();
    HRESULT Cluster_Delete();
    HRESULT Cluster_AddMember();
    HRESULT Cluster_RemoveMember();

    //
    // *TODO*: Remove this when all methods are implemented.
    //
    HRESULT Dummy();

    HRESULT Initialize();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\localconstants.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    LocalConstants.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __LOCALCONSTANTS_H__
#define __LOCALCONSTANTS_H__

#include "catmacros.h"

#pragma once

//
#define FACTORYTYPE_CLASS		1
#define FACTORYTYPE_INSTANCE	2

#define PROVIDER_LONGNAME	     L"Microsoft Application Center 2.0 WMI Provider"
#define PROVIDER			     L"WMI.ApplicationCenterv2.PROVIDER"
#define PROVIDER_CVER		     L"WMI.ApplicationCenterv2.PROVIDER\\CurVer"
#define PROVIDER_CLSID		     L"WMI.ApplicationCenterv2.PROVIDER\\CLSID"
#define PROVIDER_VER_CLSID	     L"WMI.ApplicationCenterv2.PROVIDER.0\\CLSID"
#define PROVIDER_VER		     L"WMI.ApplicationCenterv2.PROVIDER.0"

#define WSZSELECTOR				 L"selector"
#define WSZINTERNALNAME			 L"InternalName"
#define WSZDATABASE				 L"Database"

#define WSZCODEGROUP			 L"CodeGroup"
#define WSZIMEMBERSHIPCONDITION  L"IMembershipCondition"

#define WSZFILESELECTOR			 L"file://"
#define WSZLOCATION				 L"location"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\coreschemaextern.h ===
//*****************************************************************************
// CoreSchemaExtern.h
//
// This header file declares external linkage to the hard coded core schema
// definitions.  $stgdb compiles with references to these.  The actual data
// is supplied by the code which links with stgdb.lib (mscorclb and pagedump).
// The values are unknown for pagedump which provides a set of dummy values.
// After pagedump is created, it generates CoreSchema.h which then supplies
// mscorclb with the real values to link with.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#pragma once

extern const COMPLIBSCHEMABLOB SymSchemaBlob;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\common\acprov\resource.h ===
//***************************************************************************
//
//  resource.h
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Purpose: 
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//#ifndef _COMPLUS_resource_H
//#define _COMPLUS_resource_H


#define IDS_STRING1					101
#define IDS_STRING2					102

//wbem
#define IDS_OPERATION_CANCELED      103
#define IDS_GETOBJECT_FAILED		104
#define IDS_GETQUALIFIERSET_FAILED  105
#define IDS_OBJECT_NOT_FOUND        106
#define IDS_SPAWNINSTANCE_FAILED    107
#define IDS_BEGINENUMERATION_FAILED 108
#define IDS_BADQUERY				109

//catalog
#define IDS_RELATION_NOT_FOUND		201
#define IDS_GETTABLEMETA_FAILED		202
#define IDS_GETTABLE_FAILED			203
#define IDS_CATALOG_THROWS_HRES		204 
#define IDS_CATALOG_THROWS			205 
#define IDS_UNABLE_TO_PROCEED		206 
#define IDS_TABLE_NOT_FOUND		    207 
#define IDS_NONCONSISTENT_RECORD    208
#define IDS_RECORD_NOT_FOUND        209
#define IDS_FORMATS_DONT_MATCH      210
#define IDS_UNKNOWN_BASIC_TYPE		211
#define IDS_TYPE_MISMATCH			212
#define IDS_ADDROWFORDELETE_FAILED  213
#define IDS_DISPENSER_NOT_SET       214
#define IDS_GETCOLUMNVALUES_FAILED  215


//common
#define IDS_OUT_OF_MEMORY			301
#define IDS_CATALOG_DETAILED_ERRORS 302
#define IDS_UNKNOWN_ERROR           303

//#endif //_COMPLUS_resource_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\corhdr.h ===
//*****************************************************************************
// File: COR.H
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// Microsoft Confidential.
//*****************************************************************************
#ifndef __CORHDR_H__
#define __CORHDR_H__

// COM+ Header entry point flags.
#define COMIMAGE_FLAGS_ILONLY				0x00000001
#define COMIMAGE_FLAGS_32BITREQUIRED		0x00000002
#define COMIMAGE_FLAGS_TRACKDEBUGDATA		0x00010000

// Directory entry macro for COM+ data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
#define IMAGE_DIRECTORY_ENTRY_COMHEADER 	14
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER


#ifndef __IMAGE_COR_HEADER_DEFINED__
#define __IMAGE_COR_HEADER_DEFINED__

// COM+ 1.0 header structure.
#define COR_VERSION_MAJOR_V1		1
typedef struct _IMAGE_COR_HEADER
{
	DWORD					cb; 			 
	WORD					MajorRuntimeVersion;
	WORD					MinorRuntimeVersion;
	IMAGE_DATA_DIRECTORY	MetaData;		 
} IMAGE_COR_HEADER;

#endif // __IMAGE_COR_HEADER_DEFINED__


#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

// COM+ 2.0 header structure.
#define COR_VERSION_MAJOR_V2		2
typedef struct _IMAGE_COR20_HEADER                  
{
	DWORD					cb; 			 
	WORD					MajorRuntimeVersion;
	WORD					MinorRuntimeVersion;
	IMAGE_DATA_DIRECTORY	MetaData;		 
	DWORD					Flags;			 
	DWORD					EntryPointToken;
	IMAGE_DATA_DIRECTORY	IPMap;
	IMAGE_DATA_DIRECTORY	CodeManagerTable;

	IMAGE_DATA_DIRECTORY	TocManagedVCall;
	IMAGE_DATA_DIRECTORY	TocManagedCall;
	IMAGE_DATA_DIRECTORY	TocHelper;
	IMAGE_DATA_DIRECTORY	TocUnmanagedVCall;
	IMAGE_DATA_DIRECTORY	TocUnmanagedCall;

} IMAGE_COR20_HEADER;

#endif // __IMAGE_COR20_HEADER_DEFINED__

// The most recent version.
#define COR_VERSION_MAJOR			COR_VERSION_MAJOR_V2
#define COR_VERSION_MINOR			0


#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\appcenter\wmi\mofgen\acmofgen.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    main.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/27/2000		Initial Release

Revision History:

--**************************************************************************/
#include "generator.h"
#include <initguid.h>

HMODULE g_hModule = 0;                  // Module handle, needed for catalog

// Debugging stuff
// {D3B7C685-16E4-4b26-9FD7-C047199C4A60}
DEFINE_GUID(Cat2MofGuid, 
0xd3b7c685, 0x16e4, 0x4b26, 0x9f, 0xd7, 0xc0, 0x47, 0x19, 0x9c, 0x4a, 0x60);
DECLARE_DEBUG_PRINTS_OBJECT();

class CDebugInit
{
public:
    CDebugInit(LPCSTR szProd, const GUID* pGuid)
    {
        CREATE_DEBUG_PRINT_OBJECT(szProd, *pGuid);
    }
    ~CDebugInit()
    {
        DELETE_DEBUG_PRINT_OBJECT();
    }
};

extern "C" 
int __cdecl wmain( int argc, wchar_t *argv[])
{
	CDebugInit dbgInit("Cat2Mof", &Cat2MofGuid);
	CMofGenerator mofGen;
	bool fSuccess = mofGen.ParseCmdLine (argc, argv);
	if (!fSuccess)
	{
		mofGen.PrintUsage ();
		return -1;
	}

	HRESULT hr = mofGen.GenerateIt ();
	if (FAILED (hr))
	{
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\dbschema.h ===
//*****************************************************************************
// DBSchema.h
//
// Definitions used for the persistent object schema.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __DBSCHEMA_H__
#define __DBSCHEMA_H__

#include "Tigger.h"						// Public helper code.
#include "UtilCode.h"					// Internal helper code.
#include "PageDef.h"					// Data type declarations.

#define BINDING(ord, obv, obl, obs, dwp, cbmax, wtype) { ord, obv, obl, obs, 0, 0, 0, dwp, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM, cbmax, 0, wtype, 0, 0 }

#endif // __DBSCHEMA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\crtwrap.h ===
//*****************************************************************************
// CrtWrap.h
//
// Wrapper code for the C runtime library.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __CrtWrap_h__
#define __CrtWrap_h__


//*****************************************************************************
// The following macros may be used to free memory which is typically always
// allocated and used until process shut down.  Use only in cases where
// the data will never get freed except on process cleanup, and you want to
// avoid the add'l overhead of freeing data on shut down.  For example,
// allocating and leaking a large heap you plan to suballocate from might be
// useful to speed up process unload.  The macros are here so that in debug
// mode, or memory checking mode, leak tools can be used to find errors in
// code logic without polluting the list with a bunch of "known" leaks.
//*****************************************************************************
#if defined(_DEBUG) || defined(_CHECK_MEM)
#define _FREE_OPTIONAL(func, ptr) func(ptr)
#define FREE_OPTIONAL(ptr) _FREE_OPTIONAL(free, ptr)
#define DELETE_OPTIONAL(ptr) delete ptr
#define DELETE_ARRAY_OPTIONAL(ptr) delete [] ptr
#else
#define _FREE_OPTIONAL(func, ptr) ((void) 0)
#define FREE_OPTIONAL(ptr) ((void) 0)
#define DELETE_OPTIONAL(ptr) ((void) 0)
#define DELETE_ARRAY_OPTIONAL(ptr) ((void) 0)
#endif


//*****************************************************************************
// If the CRT is allowed in the current compiland, then just include the
// correct CRT header files.
//*****************************************************************************
#ifndef NO_CRT

#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include <atlbase.h>
#include "CatMacros.h"
#include <stdlib.h>
#include <malloc.h>
#include <stdio.h>

//*****************************************************************************
// Else no CRT references are allowed.	Provide stubs and macros for common
// functionality, and otherwise abstract the CRT from the user.
//*****************************************************************************
#else // NO_CRT

// Fake out include directive on stdlib.h.
#ifdef _INC_STDLIB
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_STDLIB
#define _INC_STDLIB

#ifdef _INC_MALLOC
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_MALLOC
#define _INC_MALLOC

#ifdef _INC_TIME
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_TIME
#define _INC_TIME

//@todo: remove this macro as soon as ceegen et al remove their crt refs
//#ifndef _TODO_REMOVE_CRT_
#ifdef _INC_STDIO
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_STDIO
#define _INC_STDIO




//@todo: this can go away once all msvcrt imports are removed.
#if !defined( _CRTBLD ) && defined( _DLL )
#define _CRTIMP_TODO __declspec(dllimport)
#else
#define _CRTIMP_TODO
#endif



// ---------------------------------------------------------------- //
//																	//
// $$  $$  $$	$$ $$$$$   $$$$$$$ $$$$$$			 $$$$  $$$$$$$	//
// $$  $$  $$$	$$	$$ $$	$$	 $	$$	$$			$$	$$	$$	 $	//
// $$  $$  $$$$ $$	$$	$$	$$ $	$$	$$		   $$		$$ $	//
// $$  $$  $$ $$$$	$$	$$	$$$$	$$$$$		   $$		$$$$	//
// $$  $$  $$  $$$	$$	$$	$$ $	$$ $$		   $$		$$ $	//
// $$  $$  $$	$$	$$ $$	$$	 $	$$	$$			$$	$$	$$	 $	//
// $$$$$$  $$	$$ $$$$$   $$$$$$$ $$$	$$ $$$$$$$	 $$$$  $$$$$$$	//
//																	//
// ---------------------------------------------------------------- //

#ifdef UNDER_CE

#ifndef _SIZE_T_DEFINED
#	define _SIZE_T_DEFINED
	typedef unsigned int size_t ;
#endif//_SIZE_T_DEFINED

#ifndef _WCHAR_T_DEFINED
#	define _WCHAR_T_DEFINED
	typedef unsigned short wchar_t;
#endif//_WCHAR_T_DEFINED


#ifndef _CRTIMP
#if defined(COREDLL) || !defined(UNDER_CE)
#define _CRTIMP
#else
#define _CRTIMP __declspec(dllimport)
#endif
#endif

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif

typedef struct _EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;

typedef wchar_t        wint_t;

typedef char *va_list;
// @TODO - Multi-Platform, This is only the x86 version
#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)		( ap = (va_list)0 )

// Limits originally from LIMITS.H
#define CHAR_BIT	 8		  /* number of bits in a char */
#define SCHAR_MIN	 (-128) 	   /* minimum signed char value */
#define SCHAR_MAX	 127		/* maximum signed char value */
#define UCHAR_MAX	 0xff		 /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	 /* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	 /* maximum char value */
#else
#define CHAR_MIN	0
#define CHAR_MAX	UCHAR_MAX
#endif	  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX	2		 /* max. # bytes in multibyte char */
#define SHRT_MIN	(-32768)	/* minimum (signed) short value */
#define SHRT_MAX	32767	  /* maximum (signed) short value */
#define USHRT_MAX	0xffff	  /* maximum unsigned short value */
#define INT_MIN 	(-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX 	2147483647	  /* maximum (signed) int value */
#define UINT_MAX	0xffffffff	  /* maximum unsigned int value */
#define LONG_MIN	(-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX	2147483647L    /* maximum (signed) long value */
#define ULONG_MAX	0xffffffffUL	/* maximum unsigned long value */

// @TODO - These will cause a linkage problem.	Need to get a real wrapper for the wcs funcs
#ifdef __cplusplus
extern "C"{
#endif 

// Extended logical Ops functions, STDLIB.H
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
unsigned int  __cdecl _rotl(unsigned int, int);
unsigned int  __cdecl _rotr(unsigned int, int);

// ANSI String formatting functions
_CRTIMP int    __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int    __cdecl sprintf(char *, const char *, ...);
_CRTIMP int    __cdecl vsprintf(char *, const char *, va_list);

size_t __cdecl strlen(const char *);
int    __cdecl strcmp(const char *, const char *);
char * __cdecl strcat(char *, const char *);
char * __cdecl strcpy(char *, const char *);

_CRTIMP char * __cdecl strchr(const char *, int);
_CRTIMP size_t __cdecl strcspn(const char *, const char *);
_CRTIMP char * __cdecl strncat(char *, const char *, size_t);
_CRTIMP int    __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl strstr(const char *, const char *);
_CRTIMP char * __cdecl strtok(char *, const char *);

_CRTIMP size_t	  __cdecl wcslen(const wchar_t *); 
_CRTIMP int 	  __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *string, wchar_t c);
_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP int 	  __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int 	  __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);

int    __cdecl _finite(double);
int    __cdecl _isnan(double);
double	  __cdecl fmod(double, double);

// Mem functions, originally from MEMORY.H
int    __cdecl memcmp(const void *, const void *, size_t);
void * __cdecl memcpy(void *, const void *, size_t);
void * __cdecl memset(void *, int, size_t);

_CRTIMP void * __cdecl memchr(const void *, int, size_t);
_CRTIMP int    __cdecl _memicmp(const void *, const void *, unsigned int);
_CRTIMP void * __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void * __cdecl memmove(void *, const void *, size_t);

// Bit masks used by iswXXX macros, CTYPE.H
#define _UPPER		0x1    /* upper case letter */
#define _LOWER		0x2    /* lower case letter */
#define _DIGIT		0x4    /* digit[0-9] */
#define _SPACE		0x8    /* tab, carriage return, newline, */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	  /* alphabetic character */
#define islower(_c) 	 ( iswlower(_c) )
#define iswlower(_c)	 ( iswctype(_c,_LOWER) )
_CRTIMP int 	iswctype(wchar_t, wchar_t);
_CRTIMP int    __cdecl tolower(int);
_CRTIMP int    __cdecl toupper(int);

//@todo (billev) remove/move to winfix.h
char *	__cdecl strrchr(const char *, int);
// _CRTIMP char * __cdecl strchr(const char *, int);
int 	__cdecl _stricmp(const char *, const char *);
// _CRTIMP int	   __cdecl _strnicmp(const char *, const char *, size_t);

// FILE is an opaque handle in Win CE. Users have no access to the internals
#ifndef _FILE_DEFINED
typedef void FILE;
#define _FILE_DEFINED
#endif

// functions for general buffered file handling in either ANSI or Wide
_CRTIMP FILE*  __cdecl _getstdfilex(int);

// Std handle defns
#define stdin  _getstdfilex(0)
#define stdout _getstdfilex(1)
#define stderr _getstdfilex(2)

// Used by the GetStdHandle macro in winwrap.h
_CRTIMP void*  __cdecl _fileno(FILE *);

#ifdef __cplusplus
}
#endif 

//	$$$$  $$  $ $$$ 	 $$  $$$$
//	$	  $$  $ $  $	$  $ $
//	$$$   $ $ $ $	$	$	 $$$
//	$	  $  $$ $  $	$  $ $
//	$$$$  $  $$ $$$ 	 $$  $$$$

#endif // UNDER_CE

#include <windows.h>
#include <objbase.h>
#include <intrinsic.h>
#include "CatMacros.h"



/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#ifndef _MAC
#define _MAX_PATH	260 /* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256 /* max. length of path component */
#define _MAX_FNAME	256 /* max. length of file name component */
#define _MAX_EXT	256 /* max. length of extension component */
#else	/* def _MAC */
#define _MAX_PATH	256 /* max. length of full pathname */
#define _MAX_DIR	32	/* max. length of path component */
#define _MAX_FNAME	64	/* max. length of file name component */
#endif	/* _MAC */


#ifndef __min
#define __min(x, y) ((x) < (y) ? (x) : (y))
#endif
#ifndef __max
#define __max(x, y) ((x) > (y) ? (x) : (y))
#endif


//@todo: remove this macro as soon as ceegen et al remove their crt refs
//#ifndef _TODO_REMOVE_CRT_

#ifndef UNDER_CE
// UNICODE wrappers to Win32 api's
//@todo: Win '9x support:	#define wcslen		(size_t) lstrlenW
//@todo: Win '9x support:	#define wcscpy		lstrcpyW
//@todo: Win '9x support:	#define wcscat		lstrcatW
#endif // UNDER_CE

#define wcsncpy(s1, s2, slen)	memcpy(s1, s2, (slen) * sizeof(wchar_t))
//@todo: Win '9x support:	#define wcscmp		lstrcmpW
//@todo: Win '9x support:	#define _wcsicmp	lstrcmpiW
#define wcsncmp(s1, s2, slen)	memcmp(s1, s2, (slen) * sizeof(wchar_t))
//@todo: Win '9x support:	#define swprintf	wsprintfW
//@todo: Win '9x support:	#define _wcsnicmp(s1, s2, slen) (CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE, s1, slen, s2, slen) - 2)

// Type specific mappings
#ifndef UNDER_CE

// ANSI wrappers to Win32 api's
#define strncpy(s1, s2, slen)	memcpy(s1, s2, slen)
#define _stricmp	lstrcmpiA
#define strncmp(s1, s2, slen)	memcmp(s1, s2, (slen))
#define sprintf 	wsprintfA
#define vsprintf	wvsprintfA
#define _strnicmp(s1, s2, slen) (CompareStringA(LOCALE_USER_DEFAULT, NORM_IGNORECASE, s1, slen, s2, slen) - 2)

#if defined(UNICODE) || defined(_UNICODE)

#define _tcscat 	wcscat
#define _tcslen 	wcslen
#define _tcscmp 	wcscmp
#define _tcsicmp	wcsicmp
#define _tcsncmp(s1, s2, slen)	memcmp(s1, s2, (slen) * sizeof(wchar_t))
#define _tcsnccmp(s1, s2, slen)   memcmp(s1, s2, (slen) * sizeof(wchar_t))
#define _tcsnicmp	_wcsnicmp
#define _tcsncicmp	_wcsnicmp
#define _tprintf	wprintf
#define _stprintf	swprintf
#define _tcscpy 	wcscpy
#define _tcsncpy(s1, s2, slen)	memcpy(s1, s2, (slen) * sizeof(wchar_t))

#else	// Note: you really are supposed to be using UNICODE here

#define _tcscat 	strcat
#define _tcslen 	strlen
#define _tcscmp 	strcmp
#define _tcsicmp	stricmp
#define _tcsncmp(s1, s2, slen)	memcmp(s1, s2, (slen))
#define _tcsnccmp(s1, s2, slen)   memcmp(s1, s2, (slen))
#define _tcsnicmp	_strnicmp
#define _tcsncicmp	_strnicmp
#define _tprintf	printf
#define _stprintf	sprintf
#define _tcscpy 	strcpy
#define _tcsncpy(s1, s2, slen)	memcpy(s1, s2, slen)

#endif
#endif // UNDER_CE

//#endif // @todo: _TODO_REMOVE_CRT_

#ifdef __cplusplus
extern "C"{
#endif 


// Memory.
void	__cdecl free(void *);
void *	__cdecl malloc(size_t);
void *	__cdecl realloc(void *, size_t);
void *	__cdecl _alloca(size_t);
size_t	__cdecl _msize(void *);
void *	__cdecl _expand(void *, size_t);
void * __cdecl calloc(size_t num, size_t size);


#if !__STDC__
/* Non-ANSI names for compatibility */
#define alloca	_alloca
#endif	/* !__STDC__ */

#if defined (_M_MRX000) || defined (_M_PPC) || defined (_M_ALPHA)
#pragma intrinsic(_alloca)
#endif	/* defined (_M_MRX000) || defined (_M_PPC) || defined (_M_ALPHA) */


// Time.

#ifndef _TIME_T_DEFINED
typedef long time_t;		/* time value */
#define _TIME_T_DEFINED 	/* avoid multiple def's of time_t */
#endif

// 4 byte time, no check for daylight savings
_CRTIMP time_t __cdecl time(time_t *timeptr);


// Strings.
_CRTIMP int __cdecl _vsnwprintf(wchar_t *szOutput, size_t iSize, const wchar_t *szFormat, va_list args);
_CRTIMP int __cdecl wprintf(const wchar_t *format, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *szOutput, size_t iSize, const wchar_t *szFormat, ...);
_CRTIMP int __cdecl _snprintf(char *szOutput, size_t iSize, const char *szFormat, ...);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t * string, wchar_t ch);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t * wcs1, const wchar_t * wcs2);
_CRTIMP int __cdecl swprintf(wchar_t *szOutput, const wchar_t *szFormat, ...);


//@todo: remove this macro as soon as ceegen et al remove their crt refs
//#ifndef _TODO_REMOVE_CRT_
_CRTIMP int __cdecl _vsnprintf(char *szOutput, size_t iSize, const char *szFormat, va_list args);
_CRTIMP int __cdecl printf(const char *, ...);
//#endif // @todo: _TODO_REMOVE_CRT_


// Utilities.
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);

_CRTIMP long __cdecl atol(const char *nptr);
_CRTIMP int __cdecl atoi(const char *nptr);
_CRTIMP __int64 __cdecl _atoi64(const char *nptr);
_CRTIMP char *__cdecl _ltoa( long value, char *string, int radix );

_CRTIMP void __cdecl qsort(void *base, unsigned num, unsigned width,
	int (__cdecl *comp)(const void *, const void *));




//*****************************************************************************
//!!!!!!!! CAN'T USE THE CRT FILE FUNCTIONS IN THE SHIPPING PRODUCT
// @todo: THIS CODE NEEDS TO GO AWAY
#ifdef _TODO_REMOVE_CRT_

#define EOF 	(-1)

#ifndef UNDER_CE // CE has its own definition of FILE, stdin, etc.

#ifndef _FILE_DEFINED
struct _iobuf {
		char *_ptr;
		int   _cnt;
		char *_base;
		int   _flag;
		int   _file;
		int   _charbuf;
		int   _bufsiz;
		char *_tmpfname;
		};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

#define _IOB_ENTRIES 20

#ifndef _STDIO_DEFINED
_CRTIMP_TODO extern FILE _iob[];
#endif	/* _STDIO_DEFINED */

#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])

#endif // UNDER_CE

_CRTIMP_TODO FILE * __cdecl fopen(const char *, const char *);
_CRTIMP_TODO FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP_TODO size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP_TODO long __cdecl ftell(FILE *);
_CRTIMP_TODO int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP_TODO int __cdecl fflush(FILE *);


#endif // _TODO_REMOVE_CRT_
//!!!!!!!! CAN'T USE THE CRT FILE FUNCTIONS IN THE SHIPPING PRODUCT
//*****************************************************************************


#ifdef __cplusplus
}
#endif 



#ifdef __cplusplus

void* __cdecl operator new(size_t cb);
void __cdecl operator delete(void *p);

#endif // __cplusplus




/*
 *
 * Template helpers.
 *
 */

#ifdef __cplusplus

#ifndef _HELPER_TEMPLATES_
#define _HELPER_TEMPLATES_

#ifndef ATLASSERT
#define ATLASSERT _ASSERTE
#endif



/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

inline IUnknown* AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

inline IUnknown* AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}


template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr()
	{
		p=NULL;
	}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return (T*)p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.	If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
#if _MSC_VER >= 1200 // VC60 change
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp) const
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
#endif
	T* p;
};


/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	/*explicit*/ CComBSTR(int nSize)
	{
		m_str = ::SysAllocStringLen(NULL, nSize);
	}
	/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	/*explicit*/ CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	/*explicit*/ CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	/*explicit*/ CComBSTR(REFGUID src)
	{
		LPOLESTR szGuid;
		StringFromCLSID(src, &szGuid);
		m_str = ::SysAllocString(szGuid);
		CoTaskMemFree(szGuid);
	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			if (m_str)
				::SysFreeString(m_str);
			m_str = src.Copy();
		}
		return *this;
	}

	CComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = ::SysAllocString(pSrc);
		return *this;
	}

	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	HRESULT CopyTo(BSTR* pbstr)
	{
		ATLASSERT(pbstr != NULL);
		if (pbstr == NULL)
			return E_POINTER;
		*pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
		if (*pbstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}
	void Attach(BSTR src)
	{
		ATLASSERT(m_str == NULL);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const
	{
		return (m_str == NULL);
	}
	HRESULT Append(const CComBSTR& bstrSrc)
	{
		return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
	}
	HRESULT Append(LPCOLESTR lpsz)
	{
		return Append(lpsz, (int)wcslen(lpsz));
	}
	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p)
	{
		return Append(p, SysStringLen(p));
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen)
	{
		int n1 = Length();
		BSTR b;
		b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
			return E_OUTOFMEMORY;
		memcpy(b, m_str, n1*sizeof(OLECHAR));
		memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}
#if 0
	HRESULT ToLower()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharLower(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	HRESULT ToUpper()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharUpper(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	bool LoadString(HINSTANCE hInst, UINT nID)
	{
		USES_CONVERSION;
		TCHAR sz[512];
		UINT nLen = ::LoadString(hInst, nID, sz, 512);
		ATLASSERT(nLen < 511);
		SysFreeString(m_str);
		m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
		return (nLen != 0);
	}
	bool LoadString(UINT nID)
	{
		return LoadString(_pModule->m_hInstResource, nID);
	}
	CComBSTR& operator+=(const CComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
	bool operator<(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return false;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) < 0;
		return m_str == NULL;
	}
	bool operator==(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return true;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) == 0;
		return false;
	}
	bool operator<(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return false;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) < 0;
		return m_str == NULL;
	}
	bool operator==(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return true;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) == 0;
		return false;
	}
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc)
	{
		m_str = A2WBSTR(pSrc);
	}

	CComBSTR(int nSize, LPCSTR sz)
	{
		m_str = A2WBSTR(sz, nSize);
	}

	void Append(LPCSTR lpsz)
	{
		USES_CONVERSION;
		LPCOLESTR lpo = A2COLE(lpsz);
		Append(lpo, wcslen(lpo));
	}

	CComBSTR& operator=(LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		return *this;
	}
#endif
#endif
	HRESULT WriteToStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ULONG cb;
		ULONG cbStrLen = (ULONG)(m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0);
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
			return hr;
		return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
	}
	HRESULT ReadFromStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ATLASSERT(m_str == NULL); // should be empty
		ULONG cbStrLen = 0;
		HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
		if ((hr == S_OK) && (cbStrLen != 0))
		{
			//subtract size for terminating NULL which we wrote out
			//since SysAllocStringByteLen overallocates for the NULL
			m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
			if (m_str == NULL)
				hr = E_OUTOFMEMORY;
			else
				hr = pStream->Read((void*) m_str, cbStrLen, NULL);
		}
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant()
	{
		vt = VT_EMPTY;
	}
	~CComVariant()
	{
		Clear();
	}

	CComVariant(const VARIANT& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(const CComVariant& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(BSTR bstrSrc)
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	CComVariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

#if 0
#ifndef OLE2ANSI
	CComVariant(LPCSTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
#endif
#endif

	CComVariant(bool bSrc)
	{
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}

	CComVariant(int nSrc)
	{
		vt = VT_I4;
		lVal = nSrc;
	}
	CComVariant(BYTE nSrc)
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(short nSrc)
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		vt = vtSrc;
		lVal = nSrc;
	}
	CComVariant(float fltSrc)
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(double dblSrc)
	{
		vt = VT_R8;
		dblVal = dblSrc;
	}
	CComVariant(CY cySrc)
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(IDispatch* pSrc)
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(IUnknown* pSrc)
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	CComVariant& operator=(const CComVariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(BSTR bstrSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(bstrSrc);
		if (bstrVal == NULL && bstrSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	CComVariant& operator=(LPCOLESTR lpszSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

#if 0
	#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpszSrc)
	{
		USES_CONVERSION;
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE(lpszSrc));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}
	#endif
#endif

	CComVariant& operator=(bool bSrc)
	{
		if (vt != VT_BOOL)
		{
			InternalClear();
			vt = VT_BOOL;
		}
	#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
	#pragma warning(default: 4310) // cast truncates constant value
		return *this;
	}

	CComVariant& operator=(int nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;

		return *this;
	}

	CComVariant& operator=(BYTE nSrc)
	{
		if (vt != VT_UI1)
		{
			InternalClear();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	CComVariant& operator=(short nSrc)
	{
		if (vt != VT_I2)
		{
			InternalClear();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	CComVariant& operator=(long nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(float fltSrc)
	{
		if (vt != VT_R4)
		{
			InternalClear();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	CComVariant& operator=(double dblSrc)
	{
		if (vt != VT_R8)
		{
			InternalClear();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	CComVariant& operator=(CY cySrc)
	{
		if (vt != VT_CY)
		{
			InternalClear();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	CComVariant& operator=(IDispatch* pSrc)
	{
		InternalClear();
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	CComVariant& operator=(IUnknown* pSrc)
	{
		InternalClear();
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}


// Comparison Operators
public:
	bool operator==(const VARIANT& varSrc) const
	{
		if (this == &varSrc)
			return true;

		// Variants not equal if types don't match
		if (vt != varSrc.vt)
			return false;

		// Check type specific values
		switch (vt)
		{
			case VT_EMPTY:
			case VT_NULL:
				return true;

			case VT_BOOL:
				return boolVal == varSrc.boolVal;

			case VT_UI1:
				return bVal == varSrc.bVal;

			case VT_I2:
				return iVal == varSrc.iVal;

			case VT_I4:
				return lVal == varSrc.lVal;

			case VT_R4:
				return fltVal == varSrc.fltVal;

			case VT_R8:
				return dblVal == varSrc.dblVal;

			case VT_BSTR:
				return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
						(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

			case VT_ERROR:
				return scode == varSrc.scode;

			case VT_DISPATCH:
				return pdispVal == varSrc.pdispVal;

			case VT_UNKNOWN:
				return punkVal == varSrc.punkVal;

			default:
				ATLASSERT(false);
				// fall through
		}

		return false;
	}
	bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
#ifndef UNDER_CE // Ask Jason about VarCmp
//	bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_LT;}
//	bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_GT;}
#endif // UNDER_CE

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc)
	{
		// Clear out the variant
		HRESULT hr = Clear();
		if (!FAILED(hr))
		{
			// Copy the contents and give control to CComVariant
			memcpy(this, pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(VARIANT* pDest)
	{
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from CComVariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
		return hr;
	}

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return OleSaveToStream(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	ATLASSERT(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (hr == S_FALSE)
		hr = E_FAIL;
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = OleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
				(void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
	{
		hr = pStream->Read((void*) &bVal, cbRead, NULL);
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}


#endif	// _HELPER_TEMPLATES_

#endif // __cplusplus

#endif // NO_CRT

#endif // __CrtWrap_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\internaldebug.h ===
//*****************************************************************************
// InternalDebug.h
//
// This is internal code for debug mode which will turn on memory dump checking
// and other settings.  Call the api's according to:
//		_DbgInit		On startup to init the system.
//		_DbgRecord		Call this when you are sure you want dump checking.
//		_DbgUninit		Call at process shutdown to force the dump.
//
// The reason not to enable dumping under all circumstance is one might want
// to pre-empt the dump when you hit Ctrl+C or otherwise terminate the process.
// This is actually pretty common while unit testing code, and seeing a dump
// when you obviously did not free resources is annoying.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __InternalDebug_h__
#define __InternalDebug_h__


#ifdef _DEBUG

// Internal support for debugging the EE.
void _DbgInit(HINSTANCE hInstance);
void _DbgRecord();
void _DbgUninit();

#else

#define _DbgInit(p)
#define _DbgRecord()
#define _DbgUninit()

#endif

#endif // __InternalDebug_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\exports.h ===
//*****************************************************************************
// stdafx.h
//
// Import functions and code from the storage engine.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#pragma once


// This macro is used to export functions from MSCORCLB.DLL and have them
// imported by the linker for client code.
#if defined(__STGDB_CODE__)
#define CORCLBIMPORT __declspec(dllexport)
#else
#define CORCLBIMPORT __declspec(dllimport)
#endif

#if defined(__STGDB_CODE__)
#define EXPORTCLASS __declspec(dllexport)
#else
#define EXPORTCLASS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\debugmacros.h ===
//*****************************************************************************
// DebugMacros.h
//
// Wrappers for Debugging purposes.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __DebugMacros_h__
#define __DebugMacros_h__

#if 0

#undef _ASSERTE
#undef VERIFY

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// A macro to execute a statement only in _DEBUG.
#ifdef _DEBUG

#define DEBUG_STMT(stmt)    stmt
int _cdecl DbgWrite(LPCTSTR szFmt, ...);
int _cdecl DbgWriteEx(LPCTSTR szFmt, ...);
#define BAD_FOOD    ((void *)0x0df0adba) // 0xbaadf00d
int _DbgBreakCheck(LPCSTR szFile, int iLine, LPCSTR szExpr);

#if     defined(_M_IX86)
#define _DbgBreak() __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

#define _ASSERTE(expr) \
        do { if (!(expr) && \
                (1 == _DbgBreakCheck(__FILE__, __LINE__, #expr))) \
             _DbgBreak(); } while (0)

#define VERIFY(stmt) _ASSERTE((stmt))

extern VOID DebBreak();

#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { DebBreak(); goto LABEL; } } while (0)

#define IfFailRet(EXPR) \
do { hr = (EXPR); if(FAILED(hr)) { DebBreak(); return (hr); } } while (0)

#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)

#else // _DEBUG

#define DEBUG_STMT(stmt)
#define BAD_FOOD
#define _ASSERTE(expr) ((void)0)
#define VERIFY(stmt) (stmt)

#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)

#define IfFailRet(EXPR) \
do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)

#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)

#endif // _DEBUG


#ifdef __cplusplus
}
#endif // __cplusplus


#undef assert
#define assert _ASSERTE
#undef _ASSERT
#define _ASSERT _ASSERTE

#endif //0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\intrinsic.h ===
//*****************************************************************************
// Intrinsic.h
//
// Force several very useful functions to be intrinsic, which means that the
// compiler will generate code inline for the functions instead of generating
// a call to the function.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __intrinsic_h__
#define __intrinsic_h__

#ifndef UNDER_CE
#pragma intrinsic(memcmp)
#pragma intrinsic(memcpy)
#pragma intrinsic(memset)
#pragma intrinsic(strcmp)
#pragma intrinsic(strcpy)
#pragma intrinsic(strlen)
#endif // UNDER_CE

#endif // __intrinsic_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\rotate.h ===
//*****************************************************************************
// rotate.h
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************

#ifndef __ROTATE_H__
#define __ROTATE_H__

#ifdef _DEBUG

inline void RotateUSHORT(USHORT &iHash)
{
	USHORT iRotate = iHash & 0x8000;
	iHash <<= 1;
	if (iRotate) iHash += 1;
}

inline void RotateLong(long &iHash)
{
	long iRotate = iHash & 0x80000000;
	iHash <<= 1;
	if (iRotate) iHash += 1;
}

#else

#ifdef	_M_IX86

#define RotateUSHORT(iHash) \
	__asm \
	{ \
		rol		WORD PTR iHash, 1 \
	}

#define RotateLong(iHash) \
	__asm \
	{ \
		rol		DWORD PTR iHash, 1 \
	}

#else

#define RotateUSHORT(iHash) \
	{ \
	USHORT iRotate = iHash & 0x8000; \
	iHash <<= 1; \
	if (iRotate) iHash += 1; \
	}

#define RotateLong(iHash) \
	{ \
	long iRotate = iHash & 0x80000000; \
	iHash <<= 1; \
	if (iRotate) iHash += 1; \
	}

#endif

#endif // _DEBUG

#endif //__ROTATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\tigger.h ===
//*****************************************************************************
// Tigger.h
//
// Helper functions for using the Tigger data store.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __Tigger_h__
#define __Tigger_h__

#include "CompLib.h"					// Interface definitions.

// @todo: Stolen copy from dbschema.h, consolodate to one if we keep this.
#ifndef __PROVIDERDATA_DEFINED__
#define __PROVIDERDATA_DEFINED__
struct PROVIDERDATA
{
	void		*pData;				// Pointer to provider data.
	ULONG		iLength;			// Length of data.
	ULONG		iStatus;			// Status of the row.
};
#endif // __PROVIDERDATA_DEFINED__


//*****************************************************************************
// These interfaces are useful when implementing a persistent object in ATL.
//*****************************************************************************

#define PERSIST_DB_IFACES(pclsid, pfnInstall) public CPersistDBStorage< pclsid > , public CPersistDBStorageSchema< pfnInstall >, public CObjWithSite
#define PERSIST_DB_IFACESDIRECT(pclsid, pfnInstall) public CPersistDBStorageDirect< pclsid > , public CPersistDBStorageSchema< pfnInstall >, public CObjWithSite

#define PERSIST_DB_COM_INTERFACES() \
	COM_INTERFACE_ENTRY(IPersistDBStorage) \
	COM_INTERFACE_ENTRY(IPersistDBStorageSchema) \
	COM_INTERFACE_ENTRY(IObjectWithSite)




//
//
// This section contains a set of macros that can be used to describe your schema.
//
//

//*****************************************************************************
// Structures used by the schema definition code.
//
// This describes an index.
#ifndef __INDEXDESC_DEFINED__
#define __INDEXDESC_DEFINED__

struct INDEXDESC 
{
	ULONG		fIndexType;
	LPCWSTR		szColName;
	LPCWSTR		szIndexName;
	union 
	{
		struct 
		{
			short		iMaxCollisions;
			long		iBuckets; 
		} HASHDATA;
		struct
		{
			short		fOrder;			// 
			BYTE		rcPad[4];
		} SORTDATA;
	};
	bool		bUnique;
	bool		bPrimary;
	short		iRowThreshold;
};
#endif // __INDEXDESC_DEFINED__

// This relates a table's name, columns, and inidices
#ifndef __TABLEDESC_DEFINED__
#define __TABLEDESC_DEFINED__
enum DBCOL_FLAGS
{
	DBCF_NULL		= 0x0001,			// Column allows nulls.
	DBCF_PK			= 0x0002,			// Column is primary key.
	DBCF_RID		= 0x0004			// Column is a record id.
};

enum DBTABLE_FLAGS
{
	DBTF_NORMAL		= 0x0000,			// No special behavior.
	DBTF_DROPEMPTY	= 0x0001			// Drop table on save if empty.
};

struct DBCOLDESC
{
	LPCWSTR		szTypeName;
	LPCWSTR		szColName;
	ULONG		ulColumnSize;
	DBTYPE		wType;
	USHORT		fFlags;
};

struct TABLEDESC 
{
	LPCWSTR		szTableName;
	const DBCOLDESC *pColumnDesc;
	const INDEXDESC	*pIndexDesc;
	char		iNumColumns;
	char		iNumIndices;
	USHORT		iStartRowID;
	ULONG		fFlags;
};
#endif // __TABLEDESC_DEFINED__

//*****************************************************************************
// defines for column definition

#define MAX_NAME_LENGTH 1024
#define MAX_DESCRIPTION_LENGTH 1024

// Generic column description
#ifdef _DEFINE_SCHEMA_TABLES_
	#define __COLUMN(szType, iSize, Name, iDbType) \
		{ szType, L#Name, iSize, iDbType, 0 },
	#define __COLUMN_PROPS(szType, iSize, Name, iDbType, Flags) \
		{ szType, L#Name, iSize, iDbType, Flags },
#else
	#define __COLUMN(szType, iSize, Name, iDbType) 
	#define __COLUMN_PROPS(szType, iSize, Name, iDbType, Flags)
#endif

// Specializations for various types
#define _OID_COLUMNPK(Name)	__COLUMN_PROPS(L"OID", sizeof(OID), Name, DBTYPE_OID, DBCF_PK)
#define I8_COLUMNPK(Name)	__COLUMN_PROPS(L"bigint", 8, Name, DBTYPE_I8, DBCF_PK)
#define WSTR_COLUMNPK(Name, uSize) __COLUMN_PROPS(L"wide varchar", uSize, Name, DBTYPE_WSTR, DBCF_PK)
#define _OID_COLUMN(Name)	__COLUMN(L"OID", sizeof(OID), Name, DBTYPE_OID)
#define I1_COLUMN(Name)		__COLUMN(L"tinyint", sizeof(char), Name, DBTYPE_I1)
#define UI1_COLUMN(Name)	__COLUMN(L"unsigned tinyint", sizeof(unsigned char), Name, DBTYPE_UI1)
#define I2_COLUMN(Name)		__COLUMN(L"short", sizeof(short), Name, DBTYPE_I2)
#define UI2_COLUMN(Name)	__COLUMN(L"unsigned short", sizeof(unsigned short), Name, DBTYPE_UI2)
#define I4_COLUMN(Name)		__COLUMN(L"long", sizeof(long), Name, DBTYPE_I4)
#define UI4_COLUMN(Name)	__COLUMN(L"unsigned long", sizeof(unsigned long), Name, DBTYPE_UI4)
#define BOOL_COLUMN(Name)	__COLUMN(L"bool", sizeof(VARIANT_BOOL), Name, DBTYPE_BOOL)
#define GUID_COLUMN(Name)	__COLUMN(L"GUID", sizeof(GUID), Name, DBTYPE_GUID)
#define WSTR_COLUMN(Name, uSize) __COLUMN(L"wide varchar", uSize, Name, DBTYPE_WSTR)
#define VARIANT_COLUMN(Name) __COLUMN(L"variant", sizeof(VARIANT), Name, DBTYPE_VARIANT)
#define BLOB_COLUMN(Name, uSize) __COLUMN(L"varbinary", uSize, Name, DBTYPE_BYTES)
#define ENUM_COLUMN(Name)	I1_COLUMN(Name)
#define FLAGS_COLUMN(Name)	I2_COLUMN(Name)
#define I8_COLUMN(Name)		__COLUMN(L"bigint", 8, Name, DBTYPE_I8)


#define _OID_COLUMN_FLAGS(Name, flags)	__COLUMN_PROPS(L"OID", sizeof(OID), Name, DBTYPE_OID, flags)
#define I1_COLUMN_FLAGS(Name, flags)		__COLUMN_PROPS(L"tinyint", sizeof(char), Name, DBTYPE_I1, flags)
#define UI1_COLUMN_FLAGS(Name, flags)	__COLUMN_PROPS(L"unsigned tinyint", sizeof(unsigned char), Name, DBTYPE_UI1, flags)
#define I2_COLUMN_FLAGS(Name, flags)		__COLUMN_PROPS(L"short", sizeof(short), Name, DBTYPE_I2, flags)
#define UI2_COLUMN_FLAGS(Name, flags)	__COLUMN_PROPS(L"unsigned short", sizeof(unsigned short), Name, DBTYPE_UI2, flags)
#define I4_COLUMN_FLAGS(Name, flags)		__COLUMN_PROPS(L"long", sizeof(long), Name, DBTYPE_I4, flags)
#define UI4_COLUMN_FLAGS(Name, flags)	__COLUMN_PROPS(L"unsigned long", sizeof(unsigned long), Name, DBTYPE_UI4, flags)
#define BOOL_COLUMN_FLAGS(Name, flags)	__COLUMN_PROPS(L"bool", sizeof(VARIANT_BOOL), Name, DBTYPE_BOOL, flags)
#define GUID_COLUMN_FLAGS(Name, flags)	__COLUMN_PROPS(L"GUID", sizeof(GUID), Name, DBTYPE_GUID, flags)
#define WSTR_COLUMN_FLAGS(Name, uSize, flags) __COLUMN_PROPS(L"wide varchar", uSize, Name, DBTYPE_WSTR, flags)
#define VARIANT_COLUMN_FLAGS(Name, flags) __COLUMN_PROPS(L"variant", sizeof(VARIANT), Name, DBTYPE_VARIANT, flags)
#define BLOB_COLUMN_FLAGS(Name, uSize, flags) __COLUMN_PROPS(L"varbinary", uSize, Name, DBTYPE_BYTES, flags)
#define ENUM_COLUMN_FLAGS(Name, flags)	I1_COLUMN_FLAGS(Name, flags)
#define FLAGS_COLUMN_FLAGS(Name, flags)	I2_COLUMN_FLAGS(Name, flags)
#define I8_COLUMN_FLAGS(Name, flags)		__COLUMN_PROPS(L"bigint", 8, Name, DBTYPE_I8, flags)


// Types of strings, based on WSTR_COLUMN
#define NAME_COLUMN(Name) WSTR_COLUMN(Name, MAX_NAME_LENGTH)
#define FILE_COLUMN(Name) WSTR_COLUMN(Name, _MAX_PATH)
#define DESC_COLUMN(Name) WSTR_COLUMN(Name, MAX_DESCRIPTION_LENGTH)

// OIDs and KLSIDs are system-defined column types
#define _KLSID_COLUMN(Name) _OID_COLUMN(Name)

#define VECTOR_COLUMN(Name) _OID_COLUMN(Name)
#define OBJECT_COLUMN(Name) _OID_COLUMN(Name)

// Some columns which are common among many tables
#define _FLAGS_COLUMN(Name) I4_COLUMN(Name)

//*****************************************************************************
// defines for table definitions
#undef BEGIN_TABLE
#undef BEGIN_INDICES_PART
#undef HASHINDEX
#undef BEGIN_OIDCOLUMNS_PART
#undef OIDCOLUMN
#undef END_TABLE
#undef BEGIN_SCHEMA_TABLES
#undef SCHEMA_TABLE
#undef END_SCHEMA_TABLES

#ifdef _DEFINE_SCHEMA_TABLES_
	#if !defined(NumItems) 
		#define NumItems(x) (sizeof(x)/sizeof(x[0]))
	#endif

	// Columns in a table.
	#define BEGIN_TABLE(TblName)												\
		const TCHAR gsz##TblName[] = L#TblName; \
		const DBCOLDESC	TblName##_COLUMNS[] = {

	// Inidices in a table.
	#define BEGIN_INDICES_PART(TblName)	};								\
		INDEXDESC TblName##_INDEXCOLUMNS[] = { 

	#define DEFAULT_ROW_THRESHOLD 16
	#define DEFAULT_MAX_COLLISIONS 7
	#define HASHINDEX(ColumnName, lBuckets, bUnique, bPrimary)			\
		{ IT_HASHED, L#ColumnName, L#ColumnName L"_dex", {lBuckets, DEFAULT_MAX_COLLISIONS}, bUnique, bPrimary, DEFAULT_ROW_THRESHOLD},
	#define HASHINDEXFULL(ColumnName, lBuckets, bUnique, bPrimary, iRowThreshold, iMaxCollisions)			\
		{ IT_HASHED, L#ColumnName, L#ColumnName L"_dex", {lBuckets, iMaxCollisions}, bUnique, bPrimary, iRowThreshold},
	#define SORTEDINDEX(ColumnName, fOrder, lBuckets, bUnique, bPrimary)			\
		{ IT_SORTED, L#ColumnName, L#ColumnName L"_sdex", {fOrder, 0xff}, bUnique, bPrimary, DEFAULT_ROW_THRESHOLD},
	
	#define END_INDICES_PART()

	// Oid columns in a table (other than _oid)
	#define BEGIN_OIDCOLUMNS_PART(TblName) };							\
		wchar_t *(TblName##_OIDCOLUMNS[]) = { L""

	#define OIDCOLUMN(Column)	L#Column,

	#define END_TABLE() };

	// Tables, columns, and indices.
	#define BEGIN_SCHEMA_TABLES(SchemaName)								\
		const TABLEDESC rgSchemaDef##SchemaName[] = {						
																	
	#define SCHEMA_TABLE(TblName, fFlags)								\
		{gsz##TblName,													\
			TblName##_COLUMNS, 											\
			TblName##_INDEXCOLUMNS,										\
			NumItems(TblName##_COLUMNS),								\
			NumItems(TblName##_INDEXCOLUMNS), 0, fFlags},	

	#define SCHEMA_TABLE_RID(TblName, RecordStartID, fFlags)			\
		{gsz##TblName,													\
			TblName##_COLUMNS, 											\
			TblName##_INDEXCOLUMNS,										\
			NumItems(TblName##_COLUMNS),								\
			NumItems(TblName##_INDEXCOLUMNS), RecordStartID, fFlags},	
																	
	#define SCHEMA_TABLE_NODEX(TblName, fFlags)							\
		{gsz##TblName,													\
			TblName##_COLUMNS, 0,										\
			NumItems(TblName##_COLUMNS),								\
			0, 0, fFlags},	
																	
	#define SCHEMA_TABLE_NODEX_RID(TblName, RecordStartID, fFlags)		\
		{gsz##TblName,													\
			TblName##_COLUMNS, 0, NumItems(TblName##_COLUMNS),			\
			0, RecordStartID, fFlags},	

	#define END_SCHEMA_TABLES() };

#else																
																	
	// Columns in a table.											
	#define BEGIN_TABLE(TblName)										\
		extern LPCTSTR gsz##TblName;									\
		extern const DBCOLUMNDESC	TblName##_COLUMNS[];					
																	
	// Inidices in a table.											
	#define BEGIN_INDICES_PART(TblName)									\
		extern const INDEXDESC TblName##_INDEXCOLUMNS[];					
																	
	#define HASHINDEX(ColumnName, lBuckets, bUnique, bPrimary)				
	#define HASHINDEXFULL(ColumnName, lBuckets, bUnique, bPrimary, iRowThreshold, iMaxCollisions)
	#define SORTEDINDEX(ColumnName, lBuckets, bUnique, bPrimary)				
	#define END_INDICES_PART()
																	
	// Oid columns in a table (other than _oid)						
	#define BEGIN_OIDCOLUMNS_PART(TblName)								\
		extern wchar_t *(TblName##_OIDCOLUMNS[]);					
																	
	#define OIDCOLUMN(Column)										
																	
	#define END_TABLE()												
																	
																	
																	
	// Tables, columns, and indices.								
	#define BEGIN_SCHEMA_TABLES(SchemaName)								\
		extern TABLEDESC rgSchemaDef##SchemaName[];					
																	
	#define SCHEMA_TABLE(TblName, fFlags)
																	
	#define END_SCHEMA_TABLES() 

#endif

	


// The next section contains wrappers and helpers for using OLE/DB.
#if defined( __oledb_h__ ) && defined( __cplusplus )

//*****************************************************************************
// This helper class constructs a DBID using ctor's and the like.
// @BUGBUG:  There have been cases where taking the address of an AutoDBID 
// automatic variable in a call have caused bugs.  For example:
//		foo(&AutoDBID("column"))
// foo gets a bogus DBID.  Recommend you always declare an instance and take
// the address of that.  This only happens with optimizations.
//*****************************************************************************
class AutoDBID : public DBID
{
public:
	AutoDBID(LPCTSTR szName)
	{
		eKind = DBKIND_NAME;
		uName.pwszName = (LPTSTR) szName;
	}

	DBID * operator&()
	{ return (this); }
};


//*****************************************************************************
// The following are helper functions for filling out the relevant parts of
// a binding structure.
//*****************************************************************************

inline HRESULT BindCol(
	DBBINDING	*p,						// The binding struct to fill out.
	ULONG		iCol,					// Column to bind.
	ULONG		obValue,				// Offset to data.
	ULONG		cbMaxLen,				// Size of buffer.
	DBTYPE		wType)					// Type of data.
{
	memset(p, 0, sizeof(DBBINDING));
	p->iOrdinal = iCol;
	p->dwPart = DBPART_VALUE;
	p->obValue = obValue;
	p->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
	p->eParamIO = DBPARAMIO_NOTPARAM;
	p->cbMaxLen = cbMaxLen;
	p->wType = wType;
	return (S_OK);
}

inline HRESULT BindCol(
	DBBINDING	*p,						// The binding struct to fill out.
	ULONG		iCol,					// Column to bind.
	ULONG		obValue,				// Offset to data.
	ULONG		obLength,				// Offset of length data.
	ULONG		cbMaxLen,				// Size of buffer.
	DBTYPE		wType)					// Type of data.
{
	memset(p, 0, sizeof(DBBINDING));
	p->iOrdinal = iCol;
	p->dwPart = DBPART_VALUE | DBPART_LENGTH;
	p->obValue = obValue;
	p->obLength = obLength;
	p->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
	p->eParamIO = DBPARAMIO_NOTPARAM;
	p->cbMaxLen = cbMaxLen;
	p->wType = wType;
	return (S_OK);
}

inline HRESULT BindCol(
	DBBINDING	*p,						// The binding struct to fill out.
	ULONG		iCol,					// Column to bind.
	ULONG		obValue,				// Offset to data.
	ULONG		obLength,				// Offset of length data.
	ULONG		obStatus,				// Offset of status.
	ULONG		cbMaxLen,				// Size of buffer.
	DBTYPE		wType)					// Type of data.
{
	memset(p, 0, sizeof(DBBINDING));
	p->iOrdinal = iCol;
	p->dwPart = DBPART_VALUE | DBPART_STATUS | DBPART_LENGTH;
	p->obValue = obValue;
	p->obLength = obLength;
	p->obStatus = obStatus;
	p->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
	p->eParamIO = DBPARAMIO_NOTPARAM;
	p->cbMaxLen = cbMaxLen;
	p->wType = wType;
	return (S_OK);
}


//*****************************************************************************
// This is a helper class to create a set of bindings through function calls
// instead of have to inline the assignments and defaults.
//@todo: The engine version of this will dynamically allocate the binding
// structs, we should consider making that the only version of this class.
//*****************************************************************************
class CBindingList
{
public:
	CBindingList(int iCount, DBBINDING rgBinding[]) :
		m_iCount(iCount),
		m_rgBinding(rgBinding)
	{
	}

	inline HRESULT BindCol(
		ULONG		iCol,					// Column to bind.
		ULONG		obValue,				// Offset to data.
		ULONG		cbMaxLen,				// Size of buffer.
		DBTYPE		wType)					// Type of data.
	{
		return (::BindCol(&m_rgBinding[iCol], iCol, obValue, cbMaxLen, wType));
	}

	inline HRESULT BindCol(
		ULONG		iCol,					// Column to bind.
		ULONG		obValue,				// Offset to data.
		ULONG		obLength,				// Offset of length data.
		ULONG		cbMaxLen,				// Size of buffer.
		DBTYPE		wType)					// Type of data.
	{
		return (::BindCol(&m_rgBinding[iCol], iCol, obValue, obLength, cbMaxLen, wType));
	}

	inline HRESULT BindCol(
		ULONG		iCol,					// Column to bind.
		ULONG		obValue,				// Offset to data.
		ULONG		obLength,				// Offset of length data.
		ULONG		obStatus,				// Offset of status.
		ULONG		cbMaxLen,				// Size of buffer.
		DBTYPE		wType)					// Type of data.
	{
		return (::BindCol(&m_rgBinding[iCol], iCol, obValue, obLength, 
				obStatus, cbMaxLen, wType));
	}

	inline ULONG Count()
		{ return (m_iCount); }
	DBBINDING &operator[](long iIndex)
		{ return (m_rgBinding[iIndex]); }
	inline DBBINDING *Ptr()
		{ return (&m_rgBinding[0]); }

public:
	ULONG		m_iCount;				// How many bindings.
	DBBINDING	*m_rgBinding;			// Array of bindings.
};

#endif // __oledb_h__

#endif // __Tigger_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\services.h ===
//*****************************************************************************
// Services.h
//
// Helper classes which load standard OLE/DB services we delegate to.  For
// example data type conversion code.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __SERVICES_H__
#define __SERVICES_H__


// CLSID_OLEDB_CONVERSIONLIBRARY
#include <msdaguid.h>



//*****************************************************************************
// This helper class will load the service named and dole out referenced
// pointers to it when required.  If you ask for a pointer, it is addref'd for
// you, but the caller must release it when done.  This code will not load
// the service unless you ask for it, and will then load only one for this
// whole process.
//*****************************************************************************
class CGetDataConversion
{
public:
	
	// If true, then we can load msdadc to do conversions.  If false, only
	// conversion that can be done inline are allowed, and GetDataConversion
	// will fail when called.
	virtual int AllowLoad(int bAllowLoad);

	HRESULT GetIDataConversion(IDataConvert **ppIDataConvert);

	// This has to be called while OLE is still init'd.
	void ShutDown();

private:
	static IDataConvert *m_pIDataConvert;			// One service object per instance.
	static int			m_bAllowLoad;				// If false, we reject load request.
};

CORCLBIMPORT CGetDataConversion *GetDataConvertObject();
CORCLBIMPORT HRESULT GetDataConversion(IDataConvert **ppIDataConvert);
CORCLBIMPORT void ShutDownDataConversion();

//*****************************************************************************
// This is a wrapper function for the msdadc conversion code.  It will demand
// load the conversion service interface, and do some easy and common conversions
// itself, thus avoiding the working set hit of a dll load.  The documentation
// for this function can be found in the OLE DB SDK Guide.
//*****************************************************************************
CORCLBIMPORT HRESULT DataConvert( 
	DBTYPE		wSrcType,
	DBTYPE		wDstType,
	ULONG		cbSrcLength,
	ULONG		*pcbDstLength,
	void		*pSrc,
	void		*pDst,
	ULONG		cbDstMaxLength,
	DBSTATUS	dbsSrcStatus,
	DBSTATUS	*pdbsStatus,
	BYTE		bPrecision,
	BYTE		bScale,
	DBDATACONVERT dwFlags);

//*****************************************************************************
// This is a wrapper function for the msdadc conversion code.  It will demand
// load the conversion service interface then call the GetConversionSize
// function.
//*****************************************************************************
HRESULT GetConversionSize( 
    DBTYPE		wSrcType,
    DBTYPE		wDstType,
    ULONG		*pcbSrcLength,
    ULONG		*pcbDstLength,
    void		*pSrc);



#endif // __SERVICES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\stgapi.h ===
//*****************************************************************************
// StgApi.h
//
// This module contains data structures and definitions required for external
// customers of the Stg* api's to work.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef _STGAPI_H_
#define _STGAPI_H_

#pragma once

#include "UtilCode.h"					// Array helpers.

class RECORDLIST : public CDynArray<void *> 
{
};

class CRCURSOR
{
public:
	RECORDLIST sRecords;
	int		iIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\utilcode.h ===
//*****************************************************************************
// UtilCode.h
//
// Utility functions implemented in UtilCode.lib.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __UtilCode_h__
#define __UtilCode_h__

#include "CrtWrap.h"
#include "WinWrap.h"
#include <stdio.h>
#include <malloc.h>
#include <ctype.h>
#include <ole2.h>
#include "rotate.h"
#include "CatMacros.h"
#include "safecs.h"

typedef LPCSTR	LPCUTF8;
typedef LPSTR	LPUTF8;

// used by HashiString
// CharToUpper is defined in ComUtilNative.h
// WENJUN: Can't find ComUtilNative.h, I'm going to use towupper from msvcrt instead.
extern WCHAR CharToUpper(WCHAR);

/*// This is for WinCE
#ifdef VERIFY
#undef VERIFY
#endif

#ifdef _ASSERTE
#undef _ASSERTE
#endif
*/


//********** Macros. **********************************************************
#ifndef FORCEINLINE
 #if defined( UNDER_CE ) || _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif


#ifndef offsetof
#define offsetof(s,m)	  (size_t)&(((s *)0)->m)
#endif

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif



#ifdef _DEBUG
#define UNREACHABLE do {_ASSERTE(!"How did we get here?"); __assume(0);} while(0)
#else
#define UNREACHABLE __assume(0)
#endif

// Helper will 4 byte align a value, rounding up.
#define ALIGN4BYTE(val) (((val) + 3) & ~0x3)

// These macros can be used to cast a pointer to a derived/base class to the
// opposite object.  You can do this in a template using a normal cast, but
// the compiler will generate 4 extra insructions to keep a null pointer null
// through the adjustment.	The problem is if it is contained it can never be
// null and those 4 instructions are dead code.
#define INNER_TO_OUTER(p, I, O) ((O *) ((char *) p - (int) ((char *) ((I *) ((O *) 8)) - 8)))
#define OUTER_TO_INNER(p, I, O) ((I *) ((char *) p + (int) ((char *) ((I *) ((O *) 8)) - 8)))

//=--------------------------------------------------------------------------=
// string helpers.

//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//	...
//	LPSTR pszA;
//	pszA = MyGetAnsiStringRoutine();
//	MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//	MyUseWideStringRoutine(pwsz);
//	...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// @TODO: is this the right code page?
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
	long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(char); \
	CQuickBytes __CQuickBytes##ptrname; \
	__CQuickBytes##ptrname.Alloc(__l##ptrname); \
	WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__CQuickBytes##ptrname.Ptr(), __l##ptrname, NULL, NULL); \
	LPSTR ptrname = (LPSTR)__CQuickBytes##ptrname.Ptr()

#if 0
#define MAKE_UTF8PTR_FROMWIDE(ptrname, widestr) \
	long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(char); \
	CQuickBytes __CQuickBytes##ptrname; \
	__CQuickBytes##ptrname.Alloc(__l##ptrname); \
	WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__CQuickBytes##ptrname.Ptr(), __l##ptrname, NULL, NULL); \
	LPSTR ptrname = (LPSTR)__CQuickBytes##ptrname.Ptr()
#endif
#define MAKE_UTF8PTR_FROMWIDE(ptrname, widestr) \
	long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(char); \
	LPSTR ptrname = (LPSTR)alloca(__l##ptrname); \
	WideCharToMultiByte(CP_ACP, 0, widestr, -1, ptrname, __l##ptrname, NULL, NULL);

#define MAKE_WIDEPTR_FROMUTF8(ptrname, utf8str) \
	long __l##ptrname; \
	LPWSTR ptrname; \
	__l##ptrname = WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, 0, 0); \
	ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));	\
	WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, ptrname, __l##ptrname); \

#define MAKE_FULLY_QUALIFIED_NAME(pszFullyQualifiedName, pszNameSpace, pszName) \
{ \
	pszFullyQualifiedName = (char*) _alloca((strlen(pszName) + strlen(pszNameSpace) + 2) * sizeof(char)); \
	if (pszFullyQualifiedName) { \
	strcpy(pszFullyQualifiedName,pszNameSpace); \
	strcat(pszFullyQualifiedName,"/"); \
	strcat(pszFullyQualifiedName,pszName); \
	} \
}

//*****************************************************************************
// Placement new is used to new and object at an exact location.  The pointer
// is simply returned to the caller without actually using the heap.  The
// advantage here is that you cause the ctor() code for the object to be run.
// This is ideal for heaps of C++ objects that need to get init'd multiple times.
// Example:
//		void		*pMem = GetMemFromSomePlace();
//		Foo *p = new (pMem) Foo;
//		DoSomething(p);
//		p->~Foo();
//*****************************************************************************
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
{
	return (_P);
}
#endif __PLACEMENT_NEW_INLINE

#ifdef _DEBUG
HRESULT _OutOfMemory(LPCSTR szFile, int iLine);
#define OutOfMemory() _OutOfMemory(__FILE__, __LINE__)
#else
inline HRESULT OutOfMemory()
{
	return (E_OUTOFMEMORY);
}
#endif

inline HRESULT BadError(HRESULT hr)
{
	_ASSERTE(!"Serious Error");
	return (hr);
}

#define TESTANDRETURN(test, hrVal)				\
	_ASSERTE(test); 							\
	if (! (test))								\
		return hrVal;							\

#define TESTANDRETURNPOINTER(pointer)			\
	TESTANDRETURN(pointer!=NULL, E_POINTER)

#define TESTANDRETURNMEMORY(pointer)			\
	TESTANDRETURN(pointer!=NULL, E_OUTOFMEMORY)

#define TESTANDRETURNHR(hr) 		\
	TESTANDRETURN(SUCCEEDED(hr), hr)

#define TESTANDRETURNARG(argtest)			\
	TESTANDRETURN(argtest, E_INVALIDARG)

// The following is designed to be used within a __try/__finally to test a	
// condition, set hr in the enclosing scope value if failed, and leave the try
#define TESTANDLEAVE(test, hrVal)				\
	_ASSERTE(test); 							\
	if (! (test)) { 							\
		hr = hrVal; 							\
		__leave;								\
	}

// The following is designed to be used within a while loop to test a  
// condition, set hr in the enclosing scope value if failed, and leave the block
#define TESTANDBREAK(test, hrVal)				\
	_ASSERTE(test); 							\
	if (! (test)) { 							\
		hr = hrVal; 							\
		break;									\
	}

#define TESTANDBREAKHR(hr)						\
	TESTANDBREAK(SUCCEEDED(hr), hr)

#define TESTANDLEAVEHR(hr)						\
	TESTANDLEAVE(SUCCEEDED(hr), hr)

#define TESTANDLEAVEMEMORY(pointer) 			\
	TESTANDLEAVE(pointer!=NULL, E_OUTOFMEMORY)

// Count the bits in a value in order iBits time.
inline int CountBits(int iNum)
{
	for (int iBits=0;  iNum;  iBits++)
		iNum = iNum & (iNum - 1);
	return (iBits);
}


// Turn a bit in a mask into TRUE or FALSE
template<class T, class U> inline VARIANT_BOOL GetBitFlag(T flags, U bit)
{
	if ((flags & bit) != 0)
		return VARIANT_TRUE;
	return VARIANT_FALSE;
}

// Set or clear a bit in a mask, depending on a BOOL.
template<class T, class U> inline void PutBitFlag(T &flags, U bit, VARIANT_BOOL bValue)
{
	if (bValue)
		flags |= bit;
	else
		flags &= ~(bit);
}


// prototype for a function to print formatted string to stdout.

int _cdecl PrintfStdOut(LPCWSTR szFmt, ...);


//*****************************************************************************
//
// Paths functions. Use these instead of the CRT.
//
//*****************************************************************************
void	SplitPath(const WCHAR *, WCHAR *, WCHAR *, WCHAR *, WCHAR *);
void	MakePath(register WCHAR *path, const WCHAR *drive, const WCHAR *dir, const WCHAR *fname, const WCHAR *ext);
WCHAR * FullPath(WCHAR *UserBuf, const WCHAR *path, size_t maxlen);




#define 	CQUICKBYTES_BASE_SIZE			512
#define 	CQUICKBYTES_INCREMENTAL_SIZE	128

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.	This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
class CQuickBytes
{
public:
	CQuickBytes() :
		pbBuff(0),
		iSize(0),
		cbTotal(CQUICKBYTES_BASE_SIZE)
	{ }

	~CQuickBytes()
	{
		if (pbBuff)
			free(pbBuff);
	}

	void *Alloc(int iItems)
	{
		iSize = iItems;
		if (iItems <= CQUICKBYTES_BASE_SIZE)
			return (&rgData[0]);
		else
		{
			pbBuff = malloc(iItems);
			return (pbBuff);
		}
	}

	HRESULT ReSize(int iItems)
	{
		void *pbBuffNew;
		if (iItems <= cbTotal)
		{
			iSize = iItems;
			return NOERROR;
		}

		pbBuffNew = malloc(iItems + CQUICKBYTES_INCREMENTAL_SIZE);
		if (!pbBuffNew)
			return E_OUTOFMEMORY;
		if (pbBuff) 
		{
			memcpy(pbBuffNew, pbBuff, cbTotal);
			free(pbBuff);
		}
		else
		{
			_ASSERTE(cbTotal == CQUICKBYTES_BASE_SIZE);
			memcpy(pbBuffNew, rgData, cbTotal);
		}
		cbTotal = iItems + CQUICKBYTES_INCREMENTAL_SIZE;
		iSize = iItems;
		pbBuff = pbBuffNew;
		return NOERROR;
		
	}
	operator PVOID()
	{ return ((pbBuff) ? pbBuff : &rgData[0]); }

	void *Ptr()
	{ return ((pbBuff) ? pbBuff : &rgData[0]); }

	int Size()
	{ return (iSize); }

	void		*pbBuff;
	int 		iSize;				// number of bytes used
	int 		cbTotal;			// total bytes allocated in the buffer
	BYTE		rgData[512];
};

//*************************************************************************
// Class to provide QuickBytes behaviour for typed arrays.
//*************************************************************************
template<class T> class CQuickArray : CQuickBytes
{
public:
	T* Alloc(int iItems) 
		{ return (T*)CQuickBytes::Alloc(iItems * sizeof(T)); }
	HRESULT ReSize(int iItems) 
		{ return CQuickBytes::ReSize(iItems * sizeof(T)); }
	T* Ptr() 
		{ return (T*) CQuickBytes::Ptr(); }
	size_t Size()
		{ return CQuickBytes::Size() / sizeof(T); }
	size_t MaxSize()
		{ return CQuickBytes::cbTotal / sizeof(T); }
	T& operator[] (unsigned int ix)
	{ _ASSERTE(ix < static_cast<unsigned int>(Size()));
		return *(Ptr() + ix);
	}
};


//*****************************************************************************
//
// **** REGUTIL - Static helper functions for reading/writing to Windows registry.
//
//*****************************************************************************
class REGUTIL
{
public:
//*****************************************************************************
// Open's the given key and returns the value desired.	If the key or value is
// not found, then the default is returned.
//*****************************************************************************
	static long GetLong(					// Return value from registry or default.
		LPCTSTR 	szName, 				// Name of value to get.
		long		iDefault,				// Default value to return if not found.
		LPCTSTR 	szKey=NULL, 			// Name of key, NULL==default.
		HKEY		hKey=HKEY_LOCAL_MACHINE);// What key to work on.

//*****************************************************************************
// Open's the given key and returns the value desired.	If the key or value is
// not found, then the default is returned.
//*****************************************************************************
	static long SetLong(					// Return value from registry or default.
		LPCTSTR 	szName, 				// Name of value to get.
		long		iValue,					// Value to set.
		LPCTSTR 	szKey=NULL, 			// Name of key, NULL==default.
		HKEY		hKey=HKEY_LOCAL_MACHINE);// What key to work on.

//*****************************************************************************
// Open's the given key and returns the value desired.	If the value is not
// in the key, or the key does not exist, then the default is copied to the
// output buffer.
//*****************************************************************************
	static LPCTSTR GetString(				// Pointer to user's buffer.
		LPCTSTR 	szName, 				// Name of value to get.
		LPCTSTR 	szDefault,				// Default value if not found.
		LPTSTR		szBuff, 				// User's buffer to write to.
		ULONG		iMaxBuff,				// Size of user's buffer.
		LPCTSTR 	szKey=NULL, 			// Name of key, NULL=default.
		int 		*pbFound=NULL, 			// Found in registry?
		HKEY		hKey=HKEY_LOCAL_MACHINE);// What key to work on.

//*****************************************************************************
// Does standard registration of a CoClass with a progid.
//*****************************************************************************
	static HRESULT RegisterCOMClass(		// Return code.
		REFCLSID	rclsid, 				// Class ID.
		LPCTSTR 	szDesc, 				// Description of the class.
		LPCTSTR 	szProgIDPrefix, 		// Prefix for progid.
		int 		iVersion,				// Version # for progid.
		LPCTSTR 	szClassProgID,			// Class progid.
		LPCTSTR 	szThreadingModel,		// What threading model to use.
		LPCTSTR 	szModule);				// Path to class.

//*****************************************************************************
// Unregister the basic information in the system registry for a given object
// class.
//*****************************************************************************
	static HRESULT UnregisterCOMClass(		// Return code.
		REFCLSID	rclsid, 				// Class ID we are registering.
		LPCTSTR 	szProgIDPrefix, 		// Prefix for progid.
		int 		iVersion,				// Version # for progid.
		LPCTSTR 	szClassProgID); 		// Class progid.

//*****************************************************************************
// Register a type library.
//*****************************************************************************
	static HRESULT RegisterTypeLib( 		// Return code.
		REFGUID 	rtlbid, 				// TypeLib ID we are registering.
		int 		iVersion,				// Typelib version.
		LPCTSTR 	szDesc, 				// TypeLib description.
		LPCTSTR 	szModule);				// Path to the typelib.

//*****************************************************************************
// Remove the registry keys for a type library.
//*****************************************************************************
	static HRESULT UnregisterTypeLib(		// Return code.
		REFGUID 	rtlbid, 				// TypeLib ID we are registering.
		int 		iVersion);				// Typelib version.

//*****************************************************************************
// Set an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey = szValue.	If szSubkey or szValue are
// NULL, omit them from the above expression.
//*****************************************************************************
	static BOOL SetKeyAndValue( 			// TRUE or FALSE.
		LPCTSTR 	szKey,					// Name of the reg key to set.
		LPCTSTR 	szSubkey,				// Optional subkey of szKey.
		LPCTSTR 	szValue);				// Optional value for szKey\szSubkey.

//*****************************************************************************
// Delete an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey.
//*****************************************************************************
	static BOOL DeleteKey(					// TRUE or FALSE.
		LPCTSTR 	szKey,					// Name of the reg key to set.
		LPCTSTR 	szSubkey);				// Subkey of szKey.

//*****************************************************************************
// Open the key, create a new keyword and value pair under it.
//*****************************************************************************
	static BOOL SetRegValue(				// Return status.
		LPCTSTR 	szKeyName,				// Name of full key.
		LPCTSTR 	szKeyword,				// Name of keyword.
		LPCTSTR 	szValue);				// Value of keyword.

private:
//*****************************************************************************
// Register the basics for a in proc server.
//*****************************************************************************
	static HRESULT RegisterClassBase(		// Return code.
		REFCLSID	rclsid, 				// Class ID we are registering.
		LPCTSTR 	szDesc, 				// Class description.
		LPCTSTR 	szProgID,				// Class prog ID.
		LPCTSTR 	szIndepProgID,			// Class version independant prog ID.
		LPTSTR		szOutCLSID);			// CLSID formatted in character form.

//*****************************************************************************
// Delete the basic settings for an inproc server.
//*****************************************************************************
	static HRESULT UnregisterClassBase( 	// Return code.
		REFCLSID	rclsid, 				// Class ID we are registering.
		LPCTSTR 	szProgID,				// Class prog ID.
		LPCTSTR 	szIndepProgID,			// Class version independant prog ID.
		LPTSTR		szOutCLSID);			// Return formatted class ID here.
};



//*****************************************************************************
// Returns TRUE if and only if you are running on Win95.
//*****************************************************************************
inline BOOL RunningOnWin95()
{
//@todo: when everyone ports to the wrappers, take out this ANSI code
#if defined( __TODO_PORT_TO_WRAPPERS__ ) && !defined( UNICODE )
	OSVERSIONINFOA	sVer;
	sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionExA(&sVer);
#else
	OSVERSIONINFOW	 sVer;
	sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	WszGetVersionEx(&sVer);
#endif
	return (sVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}


//*****************************************************************************
// Returns TRUE if and only if you are running on WinNT.
//*****************************************************************************
inline BOOL RunningOnWinNT()
{
//@todo: when everyone ports to the wrappers, take out this ANSI code
#if defined( __TODO_PORT_TO_WRAPPERS__ ) && !defined( UNICODE )
	OSVERSIONINFOA	sVer;
	sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionExA(&sVer);
#else
	OSVERSIONINFOW	 sVer;
	sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	WszGetVersionEx(&sVer);
#endif
	return (sVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


//*****************************************************************************
// This class exists to get an increasing low resolution counter value fast.
//*****************************************************************************
class CTimeCounter
{
	static DWORD m_iTickCount;			// Last tick count value.
	static ULONG m_iTime;				// Current count.

public:
	enum { TICKSPERSEC = 10 };

//*****************************************************************************
// Get the current time for use in the aging algorithm.
//*****************************************************************************
	static ULONG GetCurrentCounter()	// The current time.
	{
		return (m_iTime);
	}

//*****************************************************************************
// Set the current time for use in the aging algorithm.
//*****************************************************************************
	static void UpdateTime()
	{
		DWORD		iTickCount; 		// New tick count.

		// Determine the delta since the last update.
		m_iTime += (((iTickCount = GetTickCount()) - m_iTickCount) + 50) / 100;
		m_iTickCount = iTickCount;
	}

//*****************************************************************************
// Calculate refresh age.
//*****************************************************************************
	static USHORT RefreshAge(long iMilliseconds)
	{
		// Figure out the age to allow.
		return ((USHORT)(iMilliseconds / (1000 / TICKSPERSEC)));
	}
};


//*****************************************************************************
// Return != 0 if the bit at the specified index in the array is on and 0 if
// it is off.
//*****************************************************************************
inline int GetBit(const BYTE *pcBits,int iBit)
{
	return (pcBits[iBit>>3] & (1 << (iBit & 0x7)));
}

//*****************************************************************************
// Set the state of the bit at the specified index based on the value of bOn.
//*****************************************************************************
inline void SetBit(BYTE *pcBits,int iBit,int bOn)
{
	if (bOn)
		pcBits[iBit>>3] |= (1 << (iBit & 0x7));
	else
		pcBits[iBit>>3] &= ~(1 << (iBit & 0x7));
}


//*****************************************************************************
// This class implements a dynamic array of structures for which the order of
// the elements is unimportant.  This means that any item placed in the list
// may be swapped to any other location in the list at any time.  If the order
// of the items you place in the array is important, then use the CStructArray
// class.
//*****************************************************************************
template <class T,int iGrowInc>
class CUnorderedArray
{
	USHORT		m_iCount;				// # of elements used in the list.
	USHORT		m_iSize;				// # of elements allocated in the list.
public:
	T			*m_pTable;				// Pointer to the list of elements.

public:
	CUnorderedArray() :
		m_pTable(NULL),
		m_iCount(0),
		m_iSize(0)
	{ }
	~CUnorderedArray()
	{
		// Free the chunk of memory.
		if (m_pTable != NULL)
			free (m_pTable);
	}

	void Clear()
	{
        T       *pTable = NULL;
		m_iCount = 0;
		if (m_iSize > iGrowInc)
		{
			pTable = (T *) realloc(m_pTable, iGrowInc * sizeof(T));
            if (pTable)
            {
    			m_iSize = iGrowInc;
                m_pTable = pTable;
            }
		}
	}

	void Clear(int iFirst, int iCount)
	{
        T       *pTable = NULL;
		int 	iSize;

		if (iFirst + iCount < m_iCount)
			memmove(&m_pTable[iFirst], &m_pTable[iFirst + iCount], sizeof(T) * (m_iCount - (iFirst + iCount)));
       
    		m_iCount -= iCount;

		iSize = ((m_iCount / iGrowInc) * iGrowInc) + ((m_iCount % iGrowInc != 0) ? iGrowInc : 0);
		if (m_iSize > iGrowInc && iSize < m_iSize)
		{
			pTable = (T *) realloc(m_pTable, iSize * sizeof(T));
            if (pTable)
            {
			    m_iSize = iSize;
                m_pTable = pTable;
            }
		}
		_ASSERTE(m_iCount <= m_iSize);
	}

	T *Table()
	{ return (m_pTable); }

	USHORT Count()
	{ return (m_iCount); }

	T *Append()
	{
		// The array should grow, if we can't fit one more element into the array.
		if (m_iSize <= m_iCount && Grow() == NULL)
			return (NULL);
		return (&m_pTable[m_iCount++]);
	}

	void Delete(const T &Entry)
	{
		--m_iCount;
		for (int i=0; i <= m_iCount; ++i)
			if (m_pTable[i] == Entry)
			{
				m_pTable[i] = m_pTable[m_iCount];
				return;
			}

		// Just in case we didn't find it.
		++m_iCount;
	}

	void DeleteByIndex(int i)
	{
		--m_iCount;
		m_pTable[i] = m_pTable[m_iCount];
	}

	void Swap(int i,int j)
	{
		T		tmp;

		if (i == j)
			return;
		tmp = m_pTable[i];
		m_pTable[i] = m_pTable[j];
		m_pTable[j] = tmp;
	}

private:
	T *Grow();
};


//*****************************************************************************
// Increase the size of the array.
//*****************************************************************************
template <class T,int iGrowInc>
T *CUnorderedArray<T,iGrowInc>::Grow()	// NULL if can't grow.
{
	T		*pTemp;

	// try to allocate memory for reallocation.
	if ((pTemp = (T *) realloc(m_pTable, (m_iSize+iGrowInc) * sizeof(T))) == NULL)
		return (NULL);
	m_pTable = pTemp;
	m_iSize += iGrowInc;
	return (pTemp);
}


//*****************************************************************************
// This class implements a dynamic array of structures for which the insert
// order is important.	Inserts will slide all elements after the location
// down, deletes slide all values over the deleted item.  If the order of the
// items in the array is unimportant to you, then CUnorderedArray may provide
// the same feature set at lower cost.
//*****************************************************************************
class CStructArray
{
	short		m_iElemSize;			// Size of an array element.
	short		m_iGrowInc; 			// Growth increment.
	int 		m_iCount;				// # of elements used in the list.
	int 		m_iSize;				// # of elements allocated in the list.
	bool		m_bFree;				// true if data is automatically maintained.
    // this should be alligned to 8 bytes boundaries on 64 bits
    void		*m_pList;				// Pointer to the list of elements.

public:
	CStructArray(short iElemSize, short iGrowInc = 1) :
		m_iElemSize(iElemSize),
		m_iGrowInc(iGrowInc),
		m_pList(NULL),
		m_iCount(0),
		m_iSize(0),
		m_bFree(true)
	{ }
	~CStructArray()
	{
		Clear();
	}

	void *Insert(int iIndex);
	void *Append();
	int AllocateBlock(int iCount);
	void Delete(int iIndex);
	void *Ptr()
	{ return (m_pList); }
	void *Get(long iIndex)
	{ _ASSERTE(iIndex < m_iCount);
		return ((void *) ((INT_PTR) Ptr() + (iIndex * m_iElemSize))); }
	int Size()
	{ return (m_iCount * m_iElemSize); }
	int Count()
	{ return (m_iCount); }
	void Clear();
	void ClearCount()
	{ m_iCount = 0; }

	void InitOnMem(short iElemSize, void *pList, int iCount, int iSize, int iGrowInc=1)
	{
		m_iElemSize = iElemSize;
		m_iGrowInc = iGrowInc;
		m_pList = pList;
		m_iCount = iCount;
		m_iSize = iSize;
		m_bFree = false;
	}

private:
	int Grow(int iCount);
};


//*****************************************************************************
// This template simplifies access to a CStructArray by removing void * and
// adding some operator overloads.
//*****************************************************************************
template <class T> class CDynArray : public CStructArray
{
public:
	CDynArray(int iGrowInc=16) :
		CStructArray(sizeof(T), iGrowInc)
	{ }
	T *Insert(long iIndex)
		{ return ((T *)CStructArray::Insert((int)iIndex)); }
	T *Append()
		{ return ((T *)CStructArray::Append()); }
	T *Ptr()
		{ return ((T *)CStructArray::Ptr()); }
	T *Get(long iIndex)
		{ return (Ptr() + iIndex); }
	T &operator[](long iIndex)
		{ return (*(Ptr() + iIndex)); }
	int ItemIndex(T *p)
		{ return (int)(((INT_PTR) p - (INT_PTR) Ptr()) / sizeof(T)); }
	void Move(int iFrom, int iTo)
	{
		T		tmp;

		_ASSERTE(iFrom >= 0 && iFrom < Count() &&
				 iTo >= 0 && iTo < Count());

		tmp = *(Ptr() + iFrom);
		if (iTo > iFrom)
			memmove(Ptr() + iFrom, Ptr() + iFrom + 1, (iTo - iFrom) * sizeof(T));
		else
			memmove(Ptr() + iFrom + 1, Ptr() + iFrom, (iTo - iFrom) * sizeof(T));
		*(Ptr() + iTo) = tmp;
	}
};

// Some common arrays.
typedef CDynArray<int> INTARRAY;
typedef CDynArray<short> SHORTARRAY;
typedef CDynArray<long> LONGARRAY;
typedef CDynArray<USHORT> USHORTARRAY;
typedef CDynArray<ULONG> ULONGARRAY;
typedef CDynArray<BYTE> BYTEARRAY;

template <class T> class CStackArray : public CStructArray
{
public:
	CStackArray(int iGrowInc=4) :
		CStructArray(iGrowInc),
		m_curPos(0)
	{ }

	void Push(T p)
	{
		T *pT = (T *)CStructArray::Insert(m_curPos++);
		_ASSERTE(pT != NULL);
		*pT = p;
	}

	T * Pop()
	{
		T * retPtr;

		_ASSERTE(m_curPos > 0);

		retPtr = (T *)CStructArray::Get(m_curPos-1);
		CStructArray::Delete(m_curPos--);

		return (retPtr);
	}

	int Count()
	{
		return(m_curPos);
	}

private:
	int m_curPos;
};

//*****************************************************************************
// This class implements a storage system for strings.	It stores a bunch of
// strings in a single large chunk of memory and returns an index to the stored
// string.
//*****************************************************************************
class CStringSet
{
	void		*m_pStrings;			// Chunk of memory holding the strings.
	int 		m_iUsed;				// Amount of the chunk that is used.
	int 		m_iSize;				// Size of the memory chunk.
	int 		m_iGrowInc;

public:
	CStringSet(int iGrowInc = 256) :
		m_pStrings(NULL),
		m_iUsed(0),
		m_iSize(0),
		m_iGrowInc(iGrowInc)
	{ }
	~CStringSet();

	int Delete(int iStr);
	int Shrink();
	int Save(LPCTSTR szStr);
	PVOID Ptr()
	{ return (m_pStrings); }
	int Size()
	{ return (m_iUsed); }
};



//*****************************************************************************
// This template manages a list of free entries by their 0 based offset.  By
// making it a template, you can use whatever size free chain will match your
// maximum count of items.	-1 is reserved.
//*****************************************************************************
template <class T> class TFreeList
{
public:
	void Init(
		T			*rgList,
		int 		iCount)
	{
		// Save off values.
		m_rgList = rgList;
		m_iCount = iCount;
		m_iNext = 0;

		// Init free list.
		for (int i=0;  i<iCount - 1;  i++)
			m_rgList[i] = i + 1;
		m_rgList[i] = (T) -1;
	}

	T GetFreeEntry()						// Index of free item, or -1.
	{
		T			iNext;

		if (m_iNext == (T) -1)
			return (-1);

		iNext = m_iNext;
		m_iNext = m_rgList[m_iNext];
		return (iNext);
	}

	void DelFreeEntry(T iEntry)
	{
		_ASSERTE(iEntry < m_iCount);
		m_rgList[iEntry] = m_iNext;
		m_iNext = iEntry;
	}

	// This function can only be used when it is guaranteed that the free
	// array is contigous, for example, right after creation to quickly
	// get a range of items from the heap.
	void ReserveRange(int iCount)
	{
		_ASSERTE(iCount < m_iCount);
		_ASSERTE(m_iNext == 0);
		m_iNext = iCount;
	}

private:
	T			*m_rgList;				// List of free info.
	int 		m_iCount;				// How many entries to manage.
	T			m_iNext;				// Next item to get.
};


//*****************************************************************************
// This template will manage a pre allocated pool of fixed sized items.
//*****************************************************************************
template <class T, int iMax, class TFree> class TItemHeap
{
public:
	TItemHeap() :
		m_rgList(0),
		m_iCount(0)
	{ }

	~TItemHeap()
	{
		Clear();
	}

	// Retrieve the index of an item that lives in the heap.  Will not work
	// for items that didn't come from this heap.
	TFree ItemIndex(T *p)
	{ _ASSERTE(p >= &m_rgList[0] && p <= &m_rgList[m_iCount - 1]);
		_ASSERTE(((ULONG_PTR) p - (ULONG_PTR) m_rgList) % sizeof(T) == 0);
		return ((TFree) ((ULONG_PTR) p - (ULONG_PTR) m_rgList) / sizeof(T)); }

	// Retrieve an item that lives in the heap itself.	Overflow items
	// cannot be retrieved using this method.
	T *GetAt(int i)
	{	_ASSERTE(i < m_iCount);
		return (&m_rgList[i]); }

	T *AddEntry()
	{
		// Allocate first time.
		if (!InitList())
			return (0);

		// Get an entry from the free list.  If we don't have any left to give
		// out, then simply allocate a single item from the heap.
		TFree		iEntry;
		if ((iEntry = m_Free.GetFreeEntry()) == (TFree) -1)
			return (new T);

		// Run placement new on the heap entry to init it.
		return (new (&m_rgList[iEntry]) T);
	}

	// Free the entry if it belongs to us, if we allocated it from the heap
	// then delete it for real.
	void DelEntry(T *p)
	{
		if (p >= &m_rgList[0] && p <= &m_rgList[iMax - 1])
		{
			p->~T();
			m_Free.DelFreeEntry(ItemIndex(p));
		}
		else
			delete p;
	}

	// Reserve a range of items from an empty list.
	T *ReserveRange(int iCount)
	{
		// Don't use on existing list.
		_ASSERTE(m_rgList == 0);
		if (!InitList())
			return (0);

		// Heap must have been created large enough to work.
		_ASSERTE(iCount < m_iCount);

		// Mark the range as used, run new on each item, then return first.
		m_Free.ReserveRange(iCount);
		while (iCount--)
			new (&m_rgList[iCount]) T;
		return (&m_rgList[0]);
	}

	void Clear()
	{
		if (m_rgList)
			free(m_rgList);
		m_rgList = 0;
	}

private:
	int InitList()
	{
		if (m_rgList == 0)
		{
			int 		iSize = (iMax * sizeof(T)) + (iMax * sizeof(TFree));
			if ((m_rgList = (T *) malloc(iSize)) == 0)
				return (false);
			m_iCount = iMax;
			m_Free.Init((TFree *) &m_rgList[iMax], iMax);
		}
		return (true);
	}

private:
	T			*m_rgList;				// Array of objects to manage.
	int 		m_iCount;				// How many items do we have now.
	TFreeList<TFree> m_Free;			// Free list.
};




//*****************************************************************************
//*****************************************************************************
template <class T> class CQuickSort
{
private:
	T			*m_pBase;					// Base of array to sort.
	int 		m_iCount;					// How many items in array.
	int 		m_iElemSize;				// Size of one element.

public:
	CQuickSort(
		T			*pBase, 				// Address of first element.
		int 		iCount) :				// How many there are.
		m_pBase(pBase),
		m_iCount(iCount),
		m_iElemSize(sizeof(T))
	{}

//*****************************************************************************
// Call to sort the array.
//*****************************************************************************
	inline void Sort()
		{ SortRange(0, m_iCount - 1); }

//*****************************************************************************
// Override this function to do the comparison.
//*****************************************************************************
	virtual int Compare(					// -1, 0, or 1
		T			*psFirst,				// First item to compare.
		T			*psSecond)				// Second item to compare.
	{
		return (memcmp(psFirst, psSecond, sizeof(T)));
//		return (::Compare(*psFirst, *psSecond));
	}

private:
	inline void SortRange(
		int 		iLeft,
		int 		iRight)
	{
		int 		iLast;
		int 		i;						// loop variable.

		// if less than two elements you're done.
		if (iLeft >= iRight)
			return;

		// The mid-element is the pivot, move it to the left.
		Swap(iLeft, (iLeft+iRight)/2);
		iLast = iLeft;

		// move everything that is smaller than the pivot to the left.
		for(i = iLeft+1; i <= iRight; i++)
			if (Compare(&m_pBase[i], &m_pBase[iLeft]) < 0)
				Swap(i, ++iLast);

		// Put the pivot to the point where it is in between smaller and larger elements.
		Swap(iLeft, iLast);

		// Sort the each partition.
		SortRange(iLeft, iLast-1);
		SortRange(iLast+1, iRight);
	}

	inline void Swap(
		int 		iFirst,
		int 		iSecond)
	{
		T			sTemp;
		if (iFirst == iSecond) return;
		sTemp = m_pBase[iFirst];
		m_pBase[iFirst] = m_pBase[iSecond];
		m_pBase[iSecond] = sTemp;
	}

};


//*****************************************************************************
// This template encapsulates a binary search algorithm on the given type
// of data.
//*****************************************************************************
template <class T> class CBinarySearch
{
private:
	const T 	*m_pBase;					// Base of array to sort.
	int 		m_iCount;					// How many items in array.

public:
	CBinarySearch(
		const T 	*pBase, 				// Address of first element.
		int 		iCount) :				// Value to find.
		m_pBase(pBase),
		m_iCount(iCount)
	{}

//*****************************************************************************
// Searches for the item passed to ctor.
//*****************************************************************************
	const T *Find(							// Pointer to found item in array.
		const T 	*psFind,				// The key to find.
		int 		*piInsert = NULL)		// Index to insert at.
	{
		int 		iMid, iFirst, iLast;	// Loop control.
		int 		iCmp;					// Comparison.

		iFirst = 0;
		iLast = m_iCount - 1;
		while (iFirst <= iLast)
		{
			iMid = (iLast + iFirst) / 2;
			iCmp = Compare(psFind, &m_pBase[iMid]);
			if (iCmp == 0)
			{
				if (piInsert != NULL)
					*piInsert = iMid;
				return (&m_pBase[iMid]);
			}
			else if (iCmp < 0)
				iLast = iMid - 1;
			else
				iFirst = iMid + 1;
		}
		if (piInsert != NULL)
			*piInsert = iFirst;
		return (NULL);
	}

//*****************************************************************************
// Override this function to do the comparison if a comparison operator is
// not valid for your data type (such as a struct).
//*****************************************************************************
	virtual int Compare(					// -1, 0, or 1
		const T 	*psFirst,				// Key you are looking for.
		const T 	*psSecond)				// Item to compare to.
	{
		return (memcmp(psFirst, psSecond, sizeof(T)));
//		return (::Compare(*psFirst, *psSecond));
	}
};


//*****************************************************************************
// This class manages a bit vector. Allocation is done implicity through the
// template declaration, so no init code is required.  Due to this design,
// one should keep the max items reasonable (eg: be aware of stack size and
// other limitations).	The intrinsic size used to store the bit vector can
// be set when instantiating the vector.  The FindFree method will search
// using sizeof(T) for free slots, so pick a size that works well on your
// platform.
//*****************************************************************************
template <class T, int iMaxItems> class CBitVector
{
	T		m_bits[((iMaxItems/(sizeof(T)*8)) + ((iMaxItems%(sizeof(T)*8)) ? 1 : 0))];
	T		m_Used;

public:
	CBitVector()
	{
		memset(&m_bits[0], 0, sizeof(m_bits));
		memset(&m_Used, 0xff, sizeof(m_Used));
	}

//*****************************************************************************
// Get or Set the given bit.
//*****************************************************************************
	int GetBit(int iBit)
	{
		return (m_bits[iBit/(sizeof(T)*8)] & (1 << (iBit & ((sizeof(T) * 8) - 1))));
	}

	void SetBit(int iBit, int bOn)
	{
		if (bOn)
			m_bits[iBit/(sizeof(T)*8)] |= (1 << (iBit & ((sizeof(T) * 8) - 1)));
		else
			m_bits[iBit/(sizeof(T)*8)] &= ~(1 << (iBit & ((sizeof(T) * 8) - 1)));
	}

//*****************************************************************************
// Find the first free slot and return its index.
//*****************************************************************************
	int FindFree()							// Index or -1.
	{
		int 		i,j;					// Loop control.

		// Check a byte at a time.
		for (i=0;  i<sizeof(m_bits);  i++)
		{
			// Look for the first byte with an open slot.
			if (m_bits[i] != m_Used)
			{
				// Walk each bit in the first free byte.
				for (j=i * sizeof(T) * 8;  j<iMaxItems;  j++)
				{
					// Use first open one.
					if (GetBit(j) == 0)
					{
						SetBit(j, 1);
						return (j);
					}
				}
			}
		}

		// No slots open.
		return (-1);
	}
};

//*****************************************************************************
// This class manages a bit vector. Internally, this class uses CQuickBytes, which
// automatically allocates 512 bytes on the stack. So this overhead must be kept in
// mind while using it.
// This class has to be explicitly initialized.
// @todo: add Methods on this class to get first set bit and next set bit.
//*****************************************************************************
class CDynBitVector
{
	BYTE	*m_bits;
	BYTE	m_Used;
	int 	m_iMaxItem;
	int 	m_iBitsSet;
	CQuickBytes m_Bytes;

public:
	CDynBitVector() :
		m_bits(NULL),
		m_iMaxItem(0)
	{}

	HRESULT Init(int MaxItems)
	{
		int actualSize = (MaxItems/8) + ((MaxItems%8) ? 1 : 0);

		actualSize = ALIGN4BYTE(actualSize);

		m_Bytes.Alloc(actualSize);
		if(!m_Bytes)
		{
			return(E_OUTOFMEMORY);
		}

		m_bits = (BYTE *) m_Bytes.Ptr();

		m_iMaxItem = MaxItems;
		m_iBitsSet = 0;

		memset(m_bits, 0, m_Bytes.Size());
		memset(&m_Used, 0xff, sizeof(m_Used));
		return(S_OK);
	}

//*****************************************************************************
// Get, Set the given bit.
//*****************************************************************************
	int GetBit(int iBit)
	{
		return (m_bits[iBit/8] & (1 << (iBit & 7)));
	}

	void SetBit(int iBit, int bOn)
	{
		if (bOn)
		{
			m_bits[iBit/8] |= (1 << (iBit & 7));
			m_iBitsSet++;
		}
		else
		{
			m_bits[iBit/8] &= ~(1 << (iBit & 7));
			m_iBitsSet--;
		}
	}

//******************************************************************************
// Not all the bits.
//******************************************************************************
	void NotBits()
	{
		ULONG *pCurrent = (ULONG *)m_bits;
		int iSize = Size()/4;
		int iBitsSet;

		m_iBitsSet = 0;

		for(int i=0; i<iSize; i++, pCurrent++)
		{
			iBitsSet = CountBits(*pCurrent);
			m_iBitsSet += (8 - iBitsSet);
			*pCurrent = ~(*pCurrent);
		}
	}

	BYTE * Ptr()
	{ return(m_bits); }

	int Size()
	{ return(m_Bytes.Size()); }

	int BitsSet()
	{ return(m_iBitsSet);}
};

//*****************************************************************************
// This is a generic class used to manage an array of items of fixed size.
// It exposes methods allow the size of the array and bulk reads and writes
// to be performed, making it good for cursor fetching.  Memory usage is not
// very bright, using the CRT.	You should only use this class when the overall
// size of the memory must be controlled externally, as is the case when you
// are doing bulk database fetches from a cursor.  Use CStructArray or
// CUnorderedArray for all other cases.
//*****************************************************************************
template <class T> class CDynFetchArray
{
public:
//*****************************************************************************
// ctor inits all values.
//*****************************************************************************
	CDynFetchArray(int iGrowInc) :
		m_pList(NULL),
		m_iCount(0),
		m_iMax(0),
		m_iGrowInc(iGrowInc)
	{
	}

//*****************************************************************************
// Clear any memory allocated.
//*****************************************************************************
	~CDynFetchArray()
	{
		Clear();
	}

	ULONG Count()
		{ return (m_iCount); }

	void SetCount(ULONG iCount)
		{ m_iCount = iCount; }

	ULONG MaxCount()
		{ return (m_iMax); }

	T *GetAt(ULONG i)
		{ return (&m_pList[i]); }

//*****************************************************************************
// Allow for ad-hoc appending of values.  This will grow as required.
//*****************************************************************************
	T *Append(T *pval=NULL)
	{
		T		*pItem;
		if (m_iCount + 1 > m_iMax && Grow() == NULL)
			return (NULL);
		pItem = GetAt(m_iCount++);
		if (pval) *pItem = *pval;
		return (pItem);
	}

//*****************************************************************************
// Grow the internal list by the number of pages (1 set of grow inc size)
// desired. This may move the pointer, invalidating any previously fetched values.
//*****************************************************************************
	T *Grow(ULONG iNewPages=1)
	{
		T		*pList;
		DWORD	dwNewSize;

		// Figure out size required.
		dwNewSize = (m_iMax + (iNewPages * m_iGrowInc)) * sizeof(T);

		// Realloc/alloc a block for the new max.
		if (m_pList)
			pList = (T *)HeapReAlloc(GetProcessHeap(), 0, m_pList, dwNewSize);
		else
			pList = (T *)HeapAlloc(GetProcessHeap(), 0, dwNewSize);
		if (!pList)
			return (NULL);

		// If successful, save off the values and return the first item on the
		// new page.
		m_pList = pList;
		m_iMax += (iNewPages * m_iGrowInc);
		return (GetAt(m_iMax - (iNewPages * m_iGrowInc)));
	}

//*****************************************************************************
// Reduce the internal array down to just the size required by count.
//*****************************************************************************
	void Shrink()
	{
		T		*pList;

		if (m_iMax == m_iCount)
			return;

		if (m_iCount == 0)
		{
			Clear();
			return;
		}

		pList = (T *)HeapReAlloc(GetProcessHeap(), 0, m_pList, m_iCount * sizeof(T));
		_ASSERTE(pList);
		if (pList)
		{
			m_pList = pList;
			m_iMax = m_iCount;
		}
	}

//*****************************************************************************
// Free up all memory.
//*****************************************************************************
	void Clear()
	{
		if (m_pList)
			HeapFree(GetProcessHeap(), 0, m_pList);
		m_pList = NULL;
		m_iCount = m_iMax = 0;
	};

private:
	T			*m_pList;				// The list of items.
	ULONG		m_iCount;				// How many items do we have.
	ULONG		m_iMax; 				// How many could we have.
	int 		m_iGrowInc; 			// Grow by this many elements.
};


//*****************************************************************************
// The information that the hash table implementation stores at the beginning
// of every record that can be but in the hash table.
//*****************************************************************************
struct HASHENTRY
{
	USHORT		iPrev;					// Previous bucket in the chain.
	USHORT		iNext;					// Next bucket in the chain.
};

struct FREEHASHENTRY : HASHENTRY
{
	USHORT		iFree;
};

//*****************************************************************************
// Used by the FindFirst/FindNextEntry functions.  These api's allow you to
// do a sequential scan of all entries.
//*****************************************************************************
struct HASHFIND
{
	USHORT		iBucket;			// The next bucket to look in.
	USHORT		iNext;
};


//*****************************************************************************
// This is a class that implements a chain and bucket hash table.  The table
// is actually supplied as an array of structures by the user of this class
// and this maintains the chains in a HASHENTRY structure that must be at the
// beginning of every structure placed in the hash table.  Immediately
// following the HASHENTRY must be the key used to hash the structure.
//*****************************************************************************
class CHashTable
{
protected:
	BYTE		*m_pcEntries;			// Pointer to the array of structs.
	USHORT		m_iEntrySize;			// Size of the structs.
	USHORT		m_iBuckets; 			// # of chains we are hashing into.
	USHORT		*m_piBuckets;			// Ptr to the array of bucket chains.

	HASHENTRY *EntryPtr(USHORT iEntry)
	{ return ((HASHENTRY *) (m_pcEntries + (iEntry * m_iEntrySize))); }

	USHORT	   ItemIndex(HASHENTRY *p)
	{
		//
		// The following Index calculation is not safe on 64-bit platforms,
		// so we'll assert a range check in debug, which will catch SOME
		// offensive usages.  It also seems, to my eye, not to be safe on 
		// 32-bit platforms, but the 32-bit compilers don't seem to complain
		// about it.  Perhaps our warning levels are set too low? 
		//
		// [[@TODO: brianbec]]
		//
		
#		pragma warning(disable:4244)

		_ASSERTE( (( ( ((BYTE*)p) - m_pcEntries ) / m_iEntrySize ) & (~0xFFFF)) == 0 ) ;

		return (((BYTE *) p - m_pcEntries) / m_iEntrySize);

#		pragma warning(default:4244)
	}
	

public:
	CHashTable(
		USHORT		iBuckets) : 		// # of chains we are hashing into.
		m_iBuckets(iBuckets),
		m_piBuckets(NULL),
		m_pcEntries(NULL)
	{
		_ASSERTE(iBuckets < 0xffff);
	}
	~CHashTable()
	{
		if (m_piBuckets != NULL)
		{
			delete [] m_piBuckets;
			m_piBuckets = NULL;
		}
	}

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
	HRESULT NewInit(					// Return status.
		BYTE		*pcEntries, 		// Array of structs we are managing.
		USHORT		iEntrySize);		// Size of the entries.

//*****************************************************************************
// Return a boolean indicating whether or not this hash table has been inited.
//*****************************************************************************
	int IsInited()
	{ return (m_piBuckets != NULL); }

//*****************************************************************************
// This can be called to change the pointer to the table that the hash table
// is managing.  You might call this if (for example) you realloc the size
// of the table and its pointer is different.
//*****************************************************************************
	void SetTable(
		BYTE		*pcEntries) 		// Array of structs we are managing.
	{
		m_pcEntries = pcEntries;
	}

//*****************************************************************************
// Clear the hash table as if there were nothing in it.
//*****************************************************************************
	void Clear()
	{
		_ASSERTE(m_piBuckets != NULL);
		memset(m_piBuckets, 0xff, m_iBuckets * sizeof(USHORT));
	}

//*****************************************************************************
// Add the struct at the specified index in m_pcEntries to the hash chains.
//*****************************************************************************
	BYTE *Add(							// New entry.
		USHORT		iHash,				// Hash value of entry to add.
		USHORT		iIndex);			// Index of struct in m_pcEntries.

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
	void Delete(
		USHORT		iHash,				// Hash value of entry to delete.
		USHORT		iIndex);			// Index of struct in m_pcEntries.

	void Delete(
		USHORT		iHash,				// Hash value of entry to delete.
		HASHENTRY	*psEntry);			// The struct to delete.

//*****************************************************************************
// The item at the specified index has been moved, update the previous and
// next item.
//*****************************************************************************
	void Move(
		USHORT		iHash,				// Hash value for the item.
		USHORT		iNew);				// New location.

//*****************************************************************************
// Search the hash table for an entry with the specified key value.
//*****************************************************************************
	BYTE *Find( 						// Index of struct in m_pcEntries.
		USHORT		iHash,				// Hash value of the item.
		BYTE		*pcKey);			// The key to match.

//*****************************************************************************
// Search the hash table for the next entry with the specified key value.
//*****************************************************************************
	USHORT FindNext(					// Index of struct in m_pcEntries.
		BYTE		*pcKey, 			// The key to match.
		USHORT		iIndex);			// Index of previous match.

//*****************************************************************************
// Returns the first entry in the first hash bucket and inits the search
// struct.	Use the FindNextEntry function to continue walking the list.  The
// return order is not gauranteed.
//*****************************************************************************
	BYTE *FindFirstEntry(				// First entry found, or 0.
		HASHFIND	*psSrch)			// Search object.
	{
		if (m_piBuckets == 0)
			return (0);
		psSrch->iBucket = 1;
		psSrch->iNext = m_piBuckets[0];
		return (FindNextEntry(psSrch));
	}

//*****************************************************************************
// Returns the next entry in the list.
//*****************************************************************************
	BYTE *FindNextEntry(				// The next entry, or0 for end of list.
		HASHFIND	*psSrch);			// Search object.

protected:
	virtual inline BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2) = 0;
};


//*****************************************************************************
// Allocater classes for the CHashTableAndData class.  One is for VirtualAlloc
// and the other for malloc.
//*****************************************************************************
class CVMemData
{
public:
	static BYTE *Alloc(int iSize, int iMaxSize)
	{
		BYTE		*pPtr;

		_ASSERTE((iSize & 4095) == 0);
		_ASSERTE((iMaxSize & 4095) == 0);
		if ((pPtr = (BYTE *) VirtualAlloc(NULL, iMaxSize,
										MEM_RESERVE, PAGE_NOACCESS)) == NULL ||
			VirtualAlloc(pPtr, iSize, MEM_COMMIT, PAGE_READWRITE) == NULL)
		{
			VirtualFree(pPtr, 0, MEM_RELEASE);
			return (NULL);
		}
		return (pPtr);
	}
	static void Free(BYTE *pPtr, int iSize)
	{
		_ASSERTE((iSize & 4095) == 0);
		VirtualFree(pPtr, iSize, MEM_DECOMMIT);
		VirtualFree(pPtr, 0, MEM_RELEASE);
	}
	static BYTE *Grow(BYTE *pPtr, int iCurSize)
	{
		_ASSERTE((iCurSize & 4095) == 0);
		return ((BYTE *) VirtualAlloc(pPtr + iCurSize, GrowSize(), MEM_COMMIT, PAGE_READWRITE));
	}
	static int RoundSize(int iSize)
	{
		return ((iSize + 4095) & ~4095);
	}
	static int GrowSize()
	{
		return (4096);
	}
};

class CNewData
{
public:
	static BYTE *Alloc(int iSize, int iMaxSize)
	{
		return ((BYTE *) malloc(iSize));
	}
	static void Free(BYTE *pPtr, int iSize)
	{
		free(pPtr);
	}
	static BYTE *Grow(BYTE *&pPtr, int iCurSize)
	{
		void *p = realloc(pPtr, iCurSize + GrowSize());
		if (p == 0) return (0);
		return (pPtr = (BYTE *) p);
	}
	static int RoundSize(int iSize)
	{
		return (iSize);
	}
	static int GrowSize()
	{
		return (256);
	}
};


//*****************************************************************************
// This simple code handles a contiguous piece of memory.  Growth is done via
// realloc, so pointers can move.  This class just cleans up the amount of code
// required in every function that uses this type of data structure.
//*****************************************************************************
class CMemChunk
{
public:
	CMemChunk() : m_pbData(0), m_cbSize(0), m_cbNext(0) { }
	~CMemChunk()
	{
		Clear();
	}

	BYTE *GetChunk(int cbSize)
	{
		BYTE *p;
		if (m_cbSize - m_cbNext < cbSize)
		{
			int cbNew = max(cbSize, 512);
			p = (BYTE *) realloc(m_pbData, m_cbSize + cbNew);
			if (!p) return (0);
			m_pbData = p;
			m_cbSize += cbNew;
		}
		p = m_pbData + m_cbNext;
		m_cbNext += cbSize;
		return (p);
	}

	// Can only delete the last unused chunk.  no free list.
	void DelChunk(BYTE *p, int cbSize)
	{
		_ASSERTE(p >= m_pbData && p < m_pbData + m_cbNext);
		if (p + cbSize	== m_pbData + m_cbNext)
			m_cbNext -= cbSize;
	}

	int Size()
	{ return (m_cbSize); }

	int Offset()
	{ return (m_cbNext); }

	BYTE *Ptr(int cbOffset = 0)
	{
		_ASSERTE(m_pbData && m_cbSize);
		_ASSERTE(cbOffset < m_cbSize);
		return (m_pbData + cbOffset);
	}

	void Clear()
	{
		if (m_pbData)
			free(m_pbData);
		m_pbData = 0;
		m_cbSize = m_cbNext = 0;
	}

private:
	BYTE		*m_pbData;				// Data pointer.
	int 		m_cbSize;				// Size of current data.
	int 		m_cbNext;				// Next place to write.
};


//*****************************************************************************
// This implements a hash table and the allocation and management of the
// records that are being hashed.
//*****************************************************************************
template <class M>
class CHashTableAndData : protected CHashTable
{
	USHORT		m_iFree;
	USHORT		m_iEntries;

public:
	CHashTableAndData(
		USHORT		iBuckets) : 		// # of chains we are hashing into.
		CHashTable(iBuckets)
	{}
	~CHashTableAndData()
	{
		if (m_pcEntries != NULL)
			M::Free(m_pcEntries, M::RoundSize(m_iEntries * m_iEntrySize));
	}

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
	HRESULT NewInit(					// Return status.
		USHORT		iEntries,			// # of entries.
		USHORT		iEntrySize, 		// Size of the entries.
		int 		iMaxSize);			// Max size of data.

//*****************************************************************************
// Clear the hash table as if there were nothing in it.
//*****************************************************************************
	void Clear()
	{
		m_iFree = 0;
		InitFreeChain(0, m_iEntries);
		CHashTable::Clear();
	}

//*****************************************************************************
//*****************************************************************************
	BYTE *Add(
		USHORT		iHash)				// Hash value of entry to add.
	{
		FREEHASHENTRY *psEntry;

		// Make the table bigger if necessary.
		if (m_iFree == 0xffff && !Grow())
			return (NULL);

		// Add the first entry from the free list to the hash chain.
		psEntry = (FREEHASHENTRY *) CHashTable::Add(iHash, m_iFree);
		m_iFree = psEntry->iFree;
		return ((BYTE *) psEntry);
	}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
	void Delete(
		USHORT		iHash,				// Hash value of entry to delete.
		USHORT		iIndex) 			// Index of struct in m_pcEntries.
	{
		CHashTable::Delete(iHash, iIndex);
		((FREEHASHENTRY *) EntryPtr(iIndex))->iFree = m_iFree;
		m_iFree = iIndex;
	}

	void Delete(
		USHORT		iHash,				// Hash value of entry to delete.
		HASHENTRY	*psEntry)			// The struct to delete.
	{
		CHashTable::Delete(iHash, psEntry);
		((FREEHASHENTRY *) psEntry)->iFree = m_iFree;
		m_iFree = ItemIndex(psEntry);
	}

private:
	void InitFreeChain(USHORT iStart,USHORT iEnd);
	int Grow();
};


//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
template<class M>
HRESULT CHashTableAndData<M>::NewInit(// Return status.
	USHORT		iEntries,				// # of entries.
	USHORT		iEntrySize, 			// Size of the entries.
	int 		iMaxSize)				// Max size of data.
{
	BYTE		*pcEntries;
	HRESULT 	hr;

	// Allocate the memory for the entries.
	if ((pcEntries = M::Alloc(M::RoundSize(iEntries * iEntrySize),
								M::RoundSize(iMaxSize))) == 0)
		return (E_OUTOFMEMORY);
	m_iEntries = iEntries;

	// Init the base table.
	if (FAILED(hr = CHashTable::NewInit(pcEntries, iEntrySize)))
		M::Free(pcEntries, M::RoundSize(iEntries * iEntrySize));
	else
	{
		// Init the free chain.
		m_iFree = 0;
		InitFreeChain(0, iEntries);
	}
	return (hr);
}

//*****************************************************************************
// Initialize a range of records such that they are linked together to be put
// on the free chain.
//*****************************************************************************
template<class M>
void CHashTableAndData<M>::InitFreeChain(
	USHORT		iStart, 				// Index to start initializing.
	USHORT		iEnd)					// Index to stop initializing
{
	BYTE		*pcPtr;
	_ASSERTE(iEnd > iStart);

	pcPtr = m_pcEntries + iStart * m_iEntrySize;
	for (++iStart; iStart < iEnd; ++iStart)
	{
		((FREEHASHENTRY *) pcPtr)->iFree = iStart;
		pcPtr += m_iEntrySize;
	}
	((FREEHASHENTRY *) pcPtr)->iFree = 0xffff;
}

//*****************************************************************************
// Attempt to increase the amount of space available for the record heap.
//*****************************************************************************
template<class M>
int CHashTableAndData<M>::Grow()		// 1 if successful, 0 if not.
{
	int 		iCurSize;				// Current size in bytes.
	int 		iEntries;				// New # of entries.

	_ASSERTE(m_pcEntries != NULL);
	_ASSERTE(m_iFree == 0xffff);

	// Compute the current size and new # of entries.
	iCurSize = M::RoundSize(m_iEntries * m_iEntrySize);
	iEntries = (iCurSize + M::GrowSize()) / m_iEntrySize;

	// Make sure we stay below 0xffff.
	if (iEntries >= 0xffff) return (0);

	// Try to expand the array.
	if (M::Grow(m_pcEntries, iCurSize) == 0)
		return (0);

	// Init the newly allocated space.
	InitFreeChain(m_iEntries, iEntries);
	m_iFree = m_iEntries;
	m_iEntries = iEntries;
	return (1);
}

inline ULONG HashBytes(BYTE const *pbData, int iSize)
{
	ULONG	hash = 5381;

	while (--iSize >= 0)
	{
		hash = ((hash << 5) + hash) ^ *pbData;
		++pbData;
	}
	return hash;
}

// Helper function for hashing a string char by char.
inline ULONG HashStringA(LPCSTR szStr)
{
	ULONG	hash = 5381;
	int 	c;

	while ((c = *szStr) != 0)
	{
		hash = ((hash << 5) + hash) ^ c;
		++szStr;
	}
	return hash;
}

inline ULONG HashString(LPCWSTR szStr)
{
	ULONG	hash = 5381;
	int 	c;

	while ((c = *szStr) != 0)
	{
		hash = ((hash << 5) + hash) ^ c;
		++szStr;
	}
	return hash;
}

// Case-insensitive string hash function.
inline ULONG HashiString(LPCWSTR szStr)
{
	ULONG	hash = 5381;
	int 	c;

	while ((c = *szStr) != 0)
	{
		hash = ((hash << 5) + hash) ^ towupper(c);
		++szStr;
	}
	return hash;
}

// // //  
// // //  See $\src\utilcode\Debug.cpp for "Binomial (K, M, N)", which 
// // //  computes the binomial distribution, with which to compare your
// // //  hash-table statistics.  
// // //



#if defined(_UNICODE) || defined(UNICODE)
#define _tHashString(szStr) HashString(szStr)
#else
#define _tHashString(szStr) HashStringA(szStr)
#endif



//*****************************************************************************
// This helper template is used by the TStringMap to track an item by its
// character name.
//*****************************************************************************
template <class T> class TStringMapItem : HASHENTRY
{
public:
	TStringMapItem() :
		m_szString(0)
	{ }
	~TStringMapItem()
	{
		delete [] m_szString;
	}

	HRESULT SetString(LPCTSTR szValue)
	{
		int 		iLen = _tcslen(szValue) + 1;
		if ((m_szString = new TCHAR[iLen]) == 0)
			return (OutOfMemory());
		_tcscpy(m_szString, szValue);
		return (S_OK);
	}

public:
	LPTSTR		m_szString; 			// Key data.
	T			m_value;				// Value for this key.
};


//*****************************************************************************
// This template provides a map from string to item, determined by the template
// type passed in.
//*****************************************************************************
template <class T, int iBuckets=17, class TAllocator=CNewData, int iMaxSize=4096>
class TStringMap :
	protected CHashTableAndData<TAllocator>
{
	typedef CHashTableAndData<TAllocator> Super;

public:
	typedef TStringMapItem<T> TItemType;
	typedef TStringMapItem<long> TOffsetType;

	TStringMap() :
		CHashTableAndData<TAllocator>(iBuckets)
	{
	}

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
	HRESULT NewInit()					// Return status.
	{
		return (CHashTableAndData<TAllocator>::NewInit(
									(USHORT)CNewData::GrowSize()/sizeof(TItemType),
									(USHORT)sizeof(TItemType),
									iMaxSize));
	}

//*****************************************************************************
// For each item still allocated, invoke its dtor so it frees up anything it
// holds onto.
//*****************************************************************************
	void Clear()
	{
		HASHFIND	sSrch;
		TItemType	*p = (TItemType *) FindFirstEntry(&sSrch);

		while (p != 0)
		{
			// Call dtor on the item, since m_value is contained the scalar
			// dtor will get called.
			p->~TStringMapItem();
			p = (TItemType *) FindNextEntry(&sSrch);
		}
		CHashTableAndData<TAllocator>::Clear();
	}

//*****************************************************************************
// Retrieve an item by name.
//*****************************************************************************
	T *GetItem( 						// Null or object.
		LPCTSTR 	szKey)				// What to do the lookup on.
	{
		TItemType	sInfo;
		TItemType	*ptr;				// Working pointer.

		// Create a key.
		sInfo.m_szString = (LPTSTR) szKey;

		// Look it up in the hash table.
		ptr = (TItemType *) Find((USHORT) HashString(szKey), (BYTE *) &sInfo);

		// Don't let dtor free our string.
		sInfo.m_szString = 0;

		// If pointer found, return to caller.	To handle T's that have
		// an operator &(), find raw address without going through &m_value.
		if (ptr)
			return ((T *) ((BYTE *) ptr + offsetof(TOffsetType, m_value)));
		else
			return (0);
	}

//*****************************************************************************
// Initialize an iterator and return the first item.
//*****************************************************************************
	TItemType *FindFirstEntry(
		HASHFIND *psSrch)
	{
		TItemType	*ptr = (TItemType *) Super::FindFirstEntry(psSrch);

		return (ptr);
	}

//*****************************************************************************
// Return the next item, via an iterator.
//*****************************************************************************
	TItemType *FindNextEntry(
		HASHFIND *psSrch)
	{
		TItemType	*ptr = (TItemType *) Super::FindNextEntry(psSrch);

		return (ptr);
	}

//*****************************************************************************
// Add an item to the list.
//*****************************************************************************
	HRESULT AddItem(					// S_OK, or S_FALSE.
		LPCTSTR 	szKey,				// The key value for the item.
		T			&item)				// Thing to add.
	{
		TItemType	*ptr;				// Working pointer.

		// Allocate an entry in the hash table.
		if ((ptr = (TItemType *) Add((USHORT) HashString(szKey))) == 0)
			return (OutOfMemory());

		// Fill the record.
		if (ptr->SetString(szKey) < 0)
		{
			DelItem(ptr);
			return (OutOfMemory());
		}

		// Call the placement new operator on the item so it can init itself.
		// To handle T's that have an operator &(), find raw address without
		// going through &m_value.
		T *p = new ((void *) ((BYTE *) ptr + offsetof(TOffsetType, m_value))) T;
		if (p == 0)
		{
			return (OutOfMemory());
		}
		*p = item;
		return (S_OK);
	}

//*****************************************************************************
// Delete an item.
//*****************************************************************************
	void DelItem(
		LPCTSTR 	szKey)					// What to delete.
	{
		TItemType	sInfo;
		TItemType	*ptr;				// Working pointer.

		// Create a key.
		sInfo.m_szString = (LPTSTR) szKey;

		// Look it up in the hash table.
		ptr = (TItemType *) Find((USHORT) HashString(szKey), (BYTE *) &sInfo);

		// Don't let dtor free our string.
		sInfo.m_szString = 0;

		// If found, delete.
		if (ptr)
			DelItem(ptr);
	}

//*****************************************************************************
// Compare the keys for two collections.
//*****************************************************************************
	BOOL Cmp(								// 0 or != 0.
		const BYTE	*pData, 				// Raw key data on lookup.
		const HASHENTRY *pElement)			// The element to compare data against.
	{
		TItemType	*p = (TItemType *) (INT_PTR) pElement;
		return (_tcscmp(((TItemType *) pData)->m_szString, p->m_szString));
	}

private:
	void DelItem(
		TItemType	*pItem) 			// Entry to delete.
	{
		// Need to destruct this item.
		pItem->~TStringMapItem();
		Delete((USHORT) HashString(pItem->m_szString), (HASHENTRY *) (INT_PTR) pItem);
	}
};



//*****************************************************************************
// This class implements a closed hashing table.  Values are hashed to a bucket,
// and if that bucket is full already, then the value is placed in the next
// free bucket starting after the desired target (with wrap around).  If the
// table becomes 75% full, it is grown and rehashed to reduce lookups.	This
// class is best used in a reltively small lookup table where hashing is
// not going to cause many collisions.	By not having the collision chain
// logic, a lot of memory is saved.
//
// The user of the template is required to supply several methods which decide
// how each element can be marked as free, deleted, or used.  It would have
// been possible to write this with more internal logic, but that would require
// either (a) more overhead to add status on top of elements, or (b) hard
// coded types like one for strings, one for ints, etc... This gives you the
// flexibility of adding logic to your type.
//*****************************************************************************
class CClosedHashBase
{
	BYTE *EntryPtr(int iEntry)
	{ return (m_rgData + (iEntry * m_iEntrySize)); }
	BYTE *EntryPtr(int iEntry, BYTE *rgData)
	{ return (rgData + (iEntry * m_iEntrySize)); }

public:
	enum ELEMENTSTATUS
	{
		FREE,								// Item is not in use right now.
		DELETED,							// Item is deleted.
		USED								// Item is in use.
	};

	CClosedHashBase(
		int 		iBuckets,				// How many buckets should we start with.
		int 		iEntrySize, 			// Size of an entry.
		bool		bPerfect) : 			// true if bucket size will hash with no collisions.
		m_bPerfect(bPerfect),
		m_iBuckets(iBuckets),
		m_iEntrySize(iEntrySize),
		m_iCount(0),
		m_iCollisions(0),
		m_rgData(0)
	{
		m_iSize = iBuckets + 7;
	}

	~CClosedHashBase()
	{
		Clear();
	}

	virtual void Clear()
	{
		delete [] m_rgData;
		m_iCount = 0;
		m_iCollisions = 0;
		m_rgData = 0;
	}

//*****************************************************************************
// Accessors for getting at the underlying data.  Be careful to use Count()
// only when you want the number of buckets actually used.
//*****************************************************************************

	int Count()
	{ return (m_iCount); }

	int Collisions()
	{ return (m_iCollisions); }

	int Buckets()
	{ return (m_iBuckets); }

	void SetBuckets(int iBuckets, bool bPerfect=false)
	{
		_ASSERTE(m_rgData == 0);
		m_iBuckets = iBuckets;
		m_iSize = m_iBuckets + 7;
		m_bPerfect = bPerfect;
	}

	BYTE *Data()
	{ return (m_rgData); }

//*****************************************************************************
// Add a new item to hash table given the key value.  If this new entry
// exceeds maximum size, then the table will grow and be re-hashed, which
// may cause a memory error.
//*****************************************************************************
	BYTE *Add(								// New item to fill out on success.
		void		*pData) 				// The value to hash on.
	{
		// If we haven't allocated any memory, or it is too small, fix it.
		if (!m_rgData || ((m_iCount + 1) > (m_iSize * 3 / 4) && !m_bPerfect))
		{
			if (!ReHash())
				return (0);
		}

		return (DoAdd(pData, m_rgData, m_iBuckets, m_iSize, m_iCollisions, m_iCount));
	}

//*****************************************************************************
// Delete the given value.	This will simply mark the entry as deleted (in
// order to keep the collision chain intact).  There is an optimization that
// consecutive deleted entries leading up to a free entry are themselves freed
// to reduce collisions later on.
//*****************************************************************************
	void Delete(
		void		*pData);				// Key value to delete.


//*****************************************************************************
//	Callback function passed to DeleteLoop.
//*****************************************************************************
	typedef BOOL (* DELETELOOPFUNC)(		// Delete current item?
		 BYTE *pEntry,						// Bucket entry to evaluate
		 void *pCustomizer);				// User-defined value

//*****************************************************************************
// Iterates over all active values, passing each one to pDeleteLoopFunc.
// If pDeleteLoopFunc returns TRUE, the entry is deleted. This is safer
// and faster than using FindNext() and Delete().
//*****************************************************************************
	void DeleteLoop(
		DELETELOOPFUNC pDeleteLoopFunc, 	// Decides whether to delete item
		void *pCustomizer); 				// Extra value passed to deletefunc.


//*****************************************************************************
// Lookup a key value and return a pointer to the element if found.
//*****************************************************************************
	BYTE *Find( 							// The item if found, 0 if not.
		void		*pData);				// The key to lookup.

//*****************************************************************************
// Look for an item in the table.  If it isn't found, then create a new one and
// return that.
//*****************************************************************************
	BYTE *FindOrAdd(						// The item if found, 0 if not.
		void		*pData, 				// The key to lookup.
		bool		&bNew); 				// true if created.

//*****************************************************************************
// The following functions are used to traverse each used entry.  This code
// will skip over deleted and free entries freeing the caller up from such
// logic.
//*****************************************************************************
	BYTE *GetFirst()						// The first entry, 0 if none.
	{
		int 		i;						// Loop control.

		// If we've never allocated the table there can't be any to get.
		if (m_rgData == 0)
			return (0);

		// Find the first one.
		for (i=0;  i<m_iSize;  i++)
		{
			if (Status(EntryPtr(i)) != FREE && Status(EntryPtr(i)) != DELETED)
				return (EntryPtr(i));
		}
		return (0);
	}

	BYTE *GetNext(BYTE *Prev)				// The next entry, 0 if done.
	{
		int 		i;						// Loop control.

		for (i = ((int)( Prev - (BYTE *)&m_rgData[0]) / m_iEntrySize) + 1; i<m_iSize;  i++)
		{
			if (Status(EntryPtr(i)) != FREE && Status(EntryPtr(i)) != DELETED)
				return (EntryPtr(i));
		}
		return (0);
	}

private:
//*****************************************************************************
// Hash is called with a pointer to an element in the table.  You must override
// this method and provide a hash algorithm for your element type.
//*****************************************************************************
	virtual unsigned long Hash( 			// The key value.
		void const	*pData)=0;				// Raw data to hash.

//*****************************************************************************
// Compare is used in the typical memcmp way, 0 is eqaulity, -1/1 indicate
// direction of miscompare.  In this system everything is always equal or not.
//*****************************************************************************
	virtual unsigned long Compare(			// 0, -1, or 1.
		void const	*pData, 				// Raw key data on lookup.
		BYTE		*pElement)=0;			// The element to compare data against.

//*****************************************************************************
// Return true if the element is free to be used.
//*****************************************************************************
	virtual ELEMENTSTATUS Status(			// The status of the entry.
		BYTE		*pElement)=0;			// The element to check.

//*****************************************************************************
// Sets the status of the given element.
//*****************************************************************************
	virtual void SetStatus(
		BYTE		*pElement,				// The element to set status for.
		ELEMENTSTATUS eStatus)=0;			// New status.

//*****************************************************************************
// Returns the internal key value for an element.
//*****************************************************************************
	virtual void *GetKey(					// The data to hash on.
		BYTE		*pElement)=0;			// The element to return data ptr for.

//*****************************************************************************
// This helper actually does the add for you.
//*****************************************************************************
	BYTE *DoAdd(void *pData, BYTE *rgData, int &iBuckets, int iSize,
				int &iCollisions, int &iCount);

//*****************************************************************************
// This function is called either to init the table in the first place, or
// to rehash the table if we ran out of room.
//*****************************************************************************
	bool ReHash();							// true if successful.

//*****************************************************************************
// Walk each item in the table and mark it free.
//*****************************************************************************
	void InitFree(BYTE *ptr, int iSize)
	{
		int 		i;
		for (i=0;  i<iSize;  i++, ptr += m_iEntrySize)
			SetStatus(ptr, FREE);
	}

private:
	bool		m_bPerfect; 				// true if the table size guarantees
											//	no collisions.
	int 		m_iBuckets; 				// How many buckets do we have.
	int 		m_iEntrySize;				// Size of an entry.
	int 		m_iSize;					// How many elements can we have.
	int 		m_iCount;					// How many items are used.
	int 		m_iCollisions;				// How many have we had.
	BYTE		*m_rgData;					// Data element list.
};

template <class T> class CClosedHash : public CClosedHashBase
{
public:
	CClosedHash(
		int 		iBuckets,				// How many buckets should we start with.
		bool		bPerfect=false) :		// true if bucket size will hash with no collisions.
		CClosedHashBase(iBuckets, sizeof(T), bPerfect)
	{
	}

	T &operator[](long iIndex)
	{ return ((T &) *(Data() + (iIndex * sizeof(T)))); }


//*****************************************************************************
// Add a new item to hash table given the key value.  If this new entry
// exceeds maximum size, then the table will grow and be re-hashed, which
// may cause a memory error.
//*****************************************************************************
	T *Add( 								// New item to fill out on success.
		void		*pData) 				// The value to hash on.
	{
		return ((T *) CClosedHashBase::Add(pData));
	}

//*****************************************************************************
// Lookup a key value and return a pointer to the element if found.
//*****************************************************************************
	T *Find(								// The item if found, 0 if not.
		void		*pData) 				// The key to lookup.
	{
		return ((T *) CClosedHashBase::Find(pData));
	}

//*****************************************************************************
// Look for an item in the table.  If it isn't found, then create a new one and
// return that.
//*****************************************************************************
	T *FindOrAdd(							// The item if found, 0 if not.
		void		*pData, 				// The key to lookup.
		bool		&bNew)					// true if created.
	{
		return ((T *) CClosedHashBase::FindOrAdd(pData, bNew));
	}


//*****************************************************************************
// The following functions are used to traverse each used entry.  This code
// will skip over deleted and free entries freeing the caller up from such
// logic.
//*****************************************************************************
	T *GetFirst()							// The first entry, 0 if none.
	{
		return ((T *) CClosedHashBase::GetFirst());
	}

	T *GetNext(T *Prev) 					// The next entry, 0 if done.
	{
		return ((T *) CClosedHashBase::GetNext((BYTE *) Prev));
	}
};




//*****************************************************************************
// This template is another form of a closed hash table.  It handles collisions
// through a linked chain.	To use it, derive your hashed item from HASHLINK
// and implement the virtual functions required.  1.5 * ibuckets will be
// allocated, with the extra .5 used for collisions.  If you add to the point
// where no free nodes are available, the entire table is grown to make room.
// The advantage to this system is that collisions are always directly known,
// there either is one or there isn't.
//*****************************************************************************
struct HASHLINK
{
	ULONG		iNext;					// Offset for next entry.
};

template <class T> class CChainedHash
{
public:
	CChainedHash(int iBuckets=32) :
		m_iBuckets(iBuckets),
		m_rgData(0),
		m_iFree(0),
		m_iCount(0)
	{
		m_iSize = iBuckets + (iBuckets / 2);
	}

	~CChainedHash()
	{
		if (m_rgData)
			free(m_rgData);
	}

	void SetBuckets(int iBuckets)
	{
		_ASSERTE(m_rgData == 0);
		m_iBuckets = iBuckets;
		m_iSize = iBuckets + (iBuckets / 2);
	}

	T *Add(void const *pData)
	{
		ULONG		iHash;
		int 		iBucket;
		T			*pItem;

		// Build the list if required.
		if (m_rgData == 0 || m_iFree == 0xffffffff)
		{
			if (!ReHash())
				return (0);
		}

		// Hash the item and pick a bucket.
		iHash = Hash(pData);
		iBucket = iHash % m_iBuckets;

		// Use the bucket if it is free.
		if (InUse(&m_rgData[iBucket]) == false)
		{
			pItem = &m_rgData[iBucket];
			pItem->iNext = 0xffffffff;
		}
		// Else take one off of the free list for use.
		else
		{
			ULONG		iEntry;

			// Pull an item from the free list.
			iEntry = m_iFree;
			pItem = &m_rgData[m_iFree];
			m_iFree = pItem->iNext;

			// Link the new node in after the bucket.
			pItem->iNext = m_rgData[iBucket].iNext;
			m_rgData[iBucket].iNext = iEntry;
		}
		++m_iCount;
		return (pItem);
	}

	T *Find(void const *pData, bool bAddIfNew=false)
	{
		ULONG		iHash;
		int 		iBucket;
		T			*pItem;

		// Check states for lookup.
		if (m_rgData == 0)
		{
			// If we won't be adding, then we are through.
			if (bAddIfNew == false)
				return (0);

			// Otherwise, create the table.
			if (!ReHash())
				return (0);
		}

		// Hash the item and pick a bucket.
		iHash = Hash(pData);
		iBucket = iHash % m_iBuckets;

		// If it isn't in use, then there it wasn't found.
		if (!InUse(&m_rgData[iBucket]))
		{
			if (bAddIfNew == false)
				pItem = 0;
			else
			{
				pItem = &m_rgData[iBucket];
				pItem->iNext = 0xffffffff;
				++m_iCount;
			}
		}
		// Scan the list for the one we want.
		else
		{
			for (pItem=(T *) &m_rgData[iBucket];  pItem;  pItem=GetNext(pItem))
			{
				if (Cmp(pData, pItem) == 0)
					break;
			}

			if (!pItem && bAddIfNew)
			{
				ULONG		iEntry;

				// Now need more room.
				if (m_iFree == 0xffffffff)
				{
					if (!ReHash())
						return (0);
				}

				// Pull an item from the free list.
				iEntry = m_iFree;
				pItem = &m_rgData[m_iFree];
				m_iFree = pItem->iNext;

				// Link the new node in after the bucket.
				pItem->iNext = m_rgData[iBucket].iNext;
				m_rgData[iBucket].iNext = iEntry;
			}
		}
		return (pItem);
	}

	int Count()
	{ return (m_iCount); }

	virtual void Clear()
	{
		// Free up the memory.
		if (m_rgData)
		{
			free(m_rgData);
			m_rgData = 0;
		}

		m_rgData = 0;
		m_iFree = 0;
		m_iCount = 0;
	}

	virtual bool InUse(T *pItem)=0;
	virtual void SetFree(T *pItem)=0;
	virtual ULONG Hash(void const *pData)=0;
	virtual int Cmp(void const *pData, void *pItem)=0;
private:
	inline T *GetNext(T *pItem)
	{
		if (pItem->iNext != 0xffffffff)
			return ((T *) &m_rgData[pItem->iNext]);
		return (0);
	}

	bool ReHash()
	{
		T			*rgTemp;
		int 		iNewSize;

		// If this is a first time allocation, then just malloc it.
		if (!m_rgData)
		{
			if ((m_rgData = (T *) malloc(m_iSize * sizeof(T))) == 0)
				return (false);

			for (int i=0;  i<m_iSize;  i++)
				SetFree(&m_rgData[i]);

			m_iFree = m_iBuckets;
			for (i=m_iBuckets;	i<m_iSize;	i++)
				((T *) &m_rgData[i])->iNext = i + 1;
			((T *) &m_rgData[m_iSize - 1])->iNext = 0xffffffff;
			return (true);
		}

		// Otherwise we need more room on the free chain, so allocate some.
		iNewSize = m_iSize + (m_iSize / 2);

		// Allocate/realloc memory.
		if ((rgTemp = (T *) realloc(m_rgData, iNewSize * sizeof(T))) == 0)
			return (false);

		// Init new entries, save the new free chain, and reset internals.
		m_iFree = m_iSize;
		for (int i=m_iFree;  i<iNewSize;  i++)
		{
			SetFree(&rgTemp[i]);
			((T *) &rgTemp[i])->iNext = i + 1;
		}
		((T *) &rgTemp[iNewSize - 1])->iNext = 0xffffffff;

		m_rgData = rgTemp;
		m_iSize = iNewSize;
		return (true);
	}

private:
	int 		m_iBuckets; 			// How many buckets we want.
	int 		m_iSize;				// How many are allocated.
	int 		m_iCount;				// How many are we using.
	T			*m_rgData;				// Data to store items in.
	ULONG		m_iFree;				// Free chain.
};




//*****************************************************************************
//
//********** String helper functions.
//
//*****************************************************************************

// This macro returns max chars in UNICODE, or bytes in ANSI.
#define _tsizeof(str) (sizeof(str) / sizeof(TCHAR))



//*****************************************************************************
// Clean up the name including removal of trailing blanks.
//*****************************************************************************
HRESULT ValidateName(					// Return status.
	LPCTSTR 	szName, 				// User string to clean.
	LPTSTR		szOutName,				// Output for string.
	int 		iMaxName);				// Maximum size of output buffer.

//*****************************************************************************
// This is a hack for case insensitive _tcsstr.
//*****************************************************************************
LPCTSTR StriStr(						// Pointer to String2 within String1 or NULL.
	LPCTSTR 	szString1,				// String we do the search on.
	LPCTSTR 	szString2); 			// String we are looking for.

//
// String manipulating functions that handle DBCS.
//
inline const char *NextChar(			// Pointer to next char string.
	const char	*szStr) 				// Starting point.
{
	if (!IsDBCSLeadByte(*szStr))
		return (szStr + 1);
	else
		return (szStr + 2);
}

inline char *NextChar(					// Pointer to next char string.
	char		*szStr) 				// Starting point.
{
	if (!IsDBCSLeadByte(*szStr))
		return (szStr + 1);
	else
		return (szStr + 2);
}

//*****************************************************************************
// Case insensitive string compare using locale-specific information.
//*****************************************************************************
inline int StrICmp(
	LPCTSTR 	szString1,				// String to compare.
	LPCTSTR 	szString2)				// String to compare.
{
   return (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, szString1, -1, szString2, -1) - 2);
}

//*****************************************************************************
// Case sensitive string compare using locale-specific information.
//*****************************************************************************
inline int StrCmp(
	LPCTSTR 	szString1,				// String to compare.
	LPCTSTR 	szString2)				// String to compare.
{
   return (CompareString(LOCALE_USER_DEFAULT, 0, szString1, -1, szString2, -1) - 2);
}


//*****************************************************************************
// Make sure the byte that pc1 is pointing is not a trail byte.
//*****************************************************************************
inline int IsDBCSSafe(
	LPCTSTR 	pc1,					// Byte we are checking.
	LPCTSTR 	pcBegin)				// Begining of the string.
{
#ifdef UNICODE
	return (true);
#else
	LPCTSTR 	pcSaved = pc1;

	// Find the first non-lead byte.
	while (pc1-- > pcBegin && IsDBCSLeadByte (*pc1));

	// Return if we are safe.
	return ((int) (pcSaved - pc1) & 0x1);
#endif
}

//*****************************************************************************
// Make sure the byte that pc1 is pointing is not a trail byte.
//*****************************************************************************
inline void SetSafeNull(
	LPTSTR		pc1,					// Byte we are checking.
	LPTSTR		pcBegin)				// Begining of the string.
{
#ifdef _UNICODE
	*pc1 = '\0';
#else
	if (IsDBCSSafe(pc1, pcBegin))
		*pc1 = '\0';
	else
		*(pc1 - 1) = '\0';
#endif
}


//*****************************************************************************
// strncpy and put a NULL at the end of the buffer.
//*****************************************************************************
inline LPTSTR StrNCpy(					// The destination string.
	LPTSTR		szDest, 				// Destination string.
	LPCTSTR 	szSource,				// Source string.
	int 		iCopy)					// Number of bytes to copy.
{
#ifdef UNICODE
	Wszlstrcpyn(szDest, szSource, iCopy);
#else
	lstrcpynA(szDest, szSource, iCopy);
#endif
	SetSafeNull(&szDest[iCopy], szDest);
	return (szDest);
}


//*****************************************************************************
// Returns the number of bytes to copy if we were to copy this string to an
// iMax size buffer (Does not include terminating NULL).
//*****************************************************************************
inline int StrNSize(
	LPCTSTR 	szString,				// String to test.
	int 		iMax)					// return value should not exceed iMax.
{
	int 	iLen;
#ifdef UNICODE
	iLen = (int)Wszlstrlen(szString);
#else
	iLen = strlen(szString);
#endif
	if (iLen < iMax)
		return (iLen);
	else
	{
#ifndef UNICODE
		if (IsDBCSSafe(&szString[iMax-1], szString) && IsDBCSLeadByte(szString[iMax-1]))
			return(iMax-1);
		else
			return(iMax);
#else
		return (iMax);
#endif
	}
}

//*****************************************************************************
// Size of a char.
//*****************************************************************************
inline int CharSize(
	const TCHAR *pc1)
{
#ifdef _UNICODE
	return 1;
#else
	if (IsDBCSLeadByte (*pc1))
		return 2;
	return 1;
#endif
}

//*****************************************************************************
// Gets rid of the trailing blanks at the end of a string..
//*****************************************************************************
inline void StripTrailBlanks(
	LPTSTR		szString)
{
	LPTSTR		szBlankStart=NULL;		// Beginng of the trailing blanks.
	WORD		iType;					// Type of the character.

	while (*szString != NULL)
	{
		GetStringTypeEx (LOCALE_USER_DEFAULT, CT_CTYPE1, szString,
				CharSize(szString), &iType);
		if (iType & C1_SPACE)
		{
			if (!szBlankStart)
				szBlankStart = szString;
		}
		else
		{
			if (szBlankStart)
				szBlankStart = NULL;
		}

		szString += CharSize(szString);
	}
	if (szBlankStart)
		*szBlankStart = '\0';
}

//*****************************************************************************
// Parse a string that is a list of strings separated by the specified
// character.  This eliminates both leading and trailing whitespace.  Two
// important notes: This modifies the supplied buffer and changes the szEnv
// parameter to point to the location to start searching for the next token.
// This also skips empty tokens (e.g. two adjacent separators).  szEnv will be
// set to NULL when no tokens remain.  NULL may also be returned if no tokens
// exist in the string.
//*****************************************************************************
char *StrTok(							// Returned token.
	char		*&szEnv,				// Location to start searching.
	char		ch);					// Separator character.


//*****************************************************************************
// Return the length portion of a BSTR which is a ULONG before the start of
// the null terminated string.
//*****************************************************************************
inline int GetBstrLen(BSTR bstr)
{
	return *((ULONG *) bstr - 1);
}


//*****************************************************************************
// Smart Pointers for use with COM Objects.  
//
// Based on the CSmartInterface class in Dale Rogerson's technical
// article "Calling COM Objects with Smart Interface Pointers" on MSDN.
//*****************************************************************************

template <class I>
class CIfacePtr
{
public:
//*****************************************************************************
// Construction - Note that it does not AddRef the pointer.  The caller must
// hand this class a reference.
//*****************************************************************************
	CIfacePtr(
		I			*pI = NULL) 		// Interface ptr to store.
	:	m_pI(pI)
	{
	}

//*****************************************************************************
// Copy Constructor
//*****************************************************************************
	CIfacePtr(
		const CIfacePtr<I>& rSI)		// Interface ptr to copy.
	:	m_pI(rSI.m_pI)
	{
		if (m_pI != NULL)
			m_pI->AddRef();
	}
   
//*****************************************************************************
// Destruction
//*****************************************************************************
	~CIfacePtr()
	{
		if (m_pI != NULL)
			m_pI->Release();
	}

//*****************************************************************************
// Assignment Operator for a plain interface pointer.  Note that it does not
// AddRef the pointer.	Making this assignment hands a reference count to this
// class.
//*****************************************************************************
	CIfacePtr<I>& operator=(			// Reference to this class.
		I			*pI)				// Interface pointer.
	{
		if (m_pI != NULL)
			m_pI->Release();
		m_pI = pI;
		return (*this);
	}

//*****************************************************************************
// Assignment Operator for a CIfacePtr class.  Note this releases the reference
// on the current ptr and AddRefs the new one.
//*****************************************************************************
	CIfacePtr<I>& operator=(			// Reference to this class.
		const CIfacePtr<I>& rSI)
	{
		// Only need to AddRef/Release if difference
		if (m_pI != rSI.m_pI)
		{
			if (m_pI != NULL)
				m_pI->Release();

			if ((m_pI = rSI.m_pI) != NULL)
				m_pI->AddRef();
		}
		return (*this);
	}

//*****************************************************************************
// Conversion to a normal interface pointer.
//*****************************************************************************
	operator I*()						// The contained interface ptr.
	{
		return (m_pI);
	}

//*****************************************************************************
// Deref
//*****************************************************************************
	I* operator->() 					// The contained interface ptr.
	{
		_ASSERTE(m_pI != NULL);
		return (m_pI);
	}

//*****************************************************************************
// Address of
//*****************************************************************************
	I** operator&() 					// Address of the contained iface ptr.
	{
		return (&m_pI);
	}

//*****************************************************************************
// Equality
//*****************************************************************************
	BOOL operator==(					// TRUE or FALSE.
		I			*pI) const			// An interface ptr to cmp against.
	{
		return (m_pI == pI);
	}

//*****************************************************************************
// In-equality
//*****************************************************************************
	BOOL operator!=(					// TRUE or FALSE.
		I			*pI) const			// An interface ptr to cmp against.
	{
		return (m_pI != pI);
	}

//*****************************************************************************
// Negation
//*****************************************************************************
	BOOL operator!() const				// TRUE if NULL, FALSE otherwise.
	{
		return (!m_pI);
	}

protected:
	I			*m_pI;					// The actual interface Ptr.
};



//
//
// Support for VARIANT's using C++
//
//
#include <math.h>
#include <time.h>
#define MIN_DATE				(-657434L)	// about year 100
#define MAX_DATE				2958465L	// about year 9999
// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
static int rgMonthDays[13] =
	{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};



//*****************************************************************************
// This is a utility function to allocate a SafeArray.
//*****************************************************************************
inline SAFEARRAY *AllocSafeArrayLen(	// Return status.
	BYTE		*pData, 				// Data to be placed in the array.
	size_t		iSize)					// Size of data.
{
	SAFEARRAYBOUND sBound;				// Used to fill out the bounds.
	SAFEARRAY	*pArray;				// Ptr to the new array.

	sBound.cElements = (int)iSize;
	sBound.lLbound = 0;
	if ((pArray = SafeArrayCreate(VT_UI1, 1, &sBound)) != NULL)
		memcpy(pArray->pvData, (void *) pData, iSize);
	return (pArray);
}


//*****************************************************************************
// Get the # of bytes in the safe array.
//*****************************************************************************
inline int SafeArrayGetDatasize(		// Size of the SafeArray data.
	SAFEARRAY	*psArray)				// Pointer to the SafeArray.
{
	int 		iElems = 1; 			// # of elements in the array.
	int 		i;						// Loop control.

	// Compute the # of elements in the array.
	for (i=0; i < psArray->cDims; ++i)
		iElems *= psArray->rgsabound[i].cElements;

	// Return the size.
	return (iElems * psArray->cbElements);
}


//*****************************************************************************
// Convert a UTF8 string into a wide string and build a BSTR.
//*****************************************************************************
inline BSTR Utf8StringToBstr(			// The new BSTR.
	LPCSTR		szStr,					// The string to turn into a BSTR.
	int 		iSize=-1)				// Size of string without 0, or -1 for default.
{
	BSTR		bstrVal;
	int 		iReq;					// Chars required for string.

	// Account for terminating 0.
	if (iSize != -1)
		++iSize;

	// How big a buffer is needed?
	if ((iReq = WszMultiByteToWideChar(CP_UTF8, 0, szStr, iSize, 0, 0)) == 0)
		return (0);

	// Allocate the BSTR.
	if ((bstrVal = ::SysAllocStringLen(0, iReq)) == 0)
		return (0);

	// Convert into the buffer.
	if (WszMultiByteToWideChar(CP_UTF8, 0, szStr, iSize, bstrVal, iReq) == 0)
	{	// Failed, so clean up.
		_ASSERTE(!"Unexpected MultiByteToWideChar() failure");
		::SysFreeString(bstrVal);
		return 0;
	}

	return (bstrVal);
}

//*****************************************************************************
// Convert an Ansi string into a wide string and build a BSTR.
//*****************************************************************************
inline BSTR AnsiStringToBstr(			// The new BSTR.
	LPCSTR		szStr,					// The string to turn into a BSTR.
	int 		iSize)					// Size of string without null.
{
	LPWSTR		szUStr;
	BSTR		bstrVal;

	if ((szUStr = (LPWSTR)_alloca((iSize + 1) * sizeof(WCHAR))) == NULL ||
		WszMultiByteToWideChar(CP_ACP, 0, szStr, iSize + 1, szUStr, iSize + 1) == 0 ||
		(bstrVal = ::SysAllocString(szUStr)) == NULL)
		return (0);
	return (bstrVal);
}

inline HRESULT BstrToAnsiStr(BSTR bstrVal, LPSTR szOut, int iSize)
{
	if (!WszWideCharToMultiByte(CP_ACP, 0, bstrVal, -1, 
					szOut, iSize, 0, 0))
		return (E_INVALIDARG);
	return (S_OK);
}


//*****************************************************************************
// Convert a pointer to a string into a GUID.
//*****************************************************************************
HRESULT LPCSTRToGuid(					// Return status.
	LPCSTR		szGuid, 				// String to convert.
	GUID		*psGuid);				// Buffer for converted GUID.


//*****************************************************************************
// If your application is using exception handling, then define both of the
// macros here to do whatever you need.  Any components of CVariant that can
// fail (which will always be out of memory) will throw using this macro.
//*****************************************************************************
#ifndef __REPOS_EXCEPTIONS__
#define THROW_REPOS_EXCEPTION()
#endif


#if 0
//*****************************************************************************
// Helper class for working with variant values.  This class is broken up
// into:
// * ctor's of every type which automatically set the variant with the right values.
// * assignment operators which will fill out a variant.
// * access operators to easily return certain types.
//*****************************************************************************
class CVariant : public VARIANT
{
public:

//*****************************************************************************
// Default ctor simply marks the variant as empty.
//*****************************************************************************
	CVariant()
	{
		::VariantInit(this);
	}

//*****************************************************************************
// Dtor will free the variant releasing memory and pointers.
//*****************************************************************************
	~CVariant()
	{
		::VariantClear(this);
	}

//*****************************************************************************
// Integer family.
//*****************************************************************************
	CVariant(BYTE byte)
	{
		::VariantInit(this);
		this->vt = VT_I1;
		this->bVal = byte;
	}

	CVariant(short val)
	{
		::VariantInit(this);
		this->vt = VT_I2;
		this->iVal = val;
	}

	CVariant(long lValNew)
	{
		::VariantInit(this);
		this->vt = VT_I4;
		this->lVal = lValNew;
	}

	CVariant(const int lValNew)
	{
		::VariantInit(this);
		this->vt = VT_I4;
		this->lVal = lValNew;
	}

	CVariant(unsigned short val)
	{
		::VariantInit(this);
		this->vt = VT_UI2;
		this->iVal = val;
	}

	CVariant(unsigned long lValNew)
	{
		::VariantInit(this);
		this->vt = VT_UI4;
		this->lVal = lValNew;
	}


//*****************************************************************************
// Float family.
//*****************************************************************************
	CVariant(float fltVal)
	{
		::VariantInit(this);
		this->vt = VT_R4;
		this->fltVal = fltVal;
	}

	CVariant(double dblVal)
	{
		::VariantInit(this);
		this->vt = VT_R8;
		this->dblVal = dblVal;
	}

#if 0
	CVariant(SYSTEMTIME stDate)
	{
		::VariantInit(this);
		this->vt = VT_DATE;
		if (FAILED(SystemTimeToDate(stDate, &this->date)))
			this->vt = VT_EMPTY;
	}

	CVariant(FILETIME ftDate)
	{
		SYSTEMTIME	stDate;

		::VariantInit(this);
		this->vt = VT_DATE;
		if (FAILED(FileTimeToSystemTime(&ftDate, &stDate)) ||
			FAILED(SystemTimeToDate(stDate, &this->date)))
			this->vt = VT_EMPTY;
	}

	CVariant(TIMESTAMP_STRUCT tstmpDate)
	{
		::VariantInit(this);
		this->vt = VT_DATE;
		if (FAILED(TimeStampToDate(tstmpDate, &this->date)))
			this->vt = VT_EMPTY;
	}
#endif

//*****************************************************************************
// String family.  These will allocate a BSTR internally.  To be safe, you
// need to check for vt != VT_EMPTY to make sure a string was allocated.
//*****************************************************************************
#ifdef UNICODE
	CVariant(LPCTSTR szString)
	{
		::VariantInit(this);
		if (!szString)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else if ((this->bstrVal = ::SysAllocString(szString)) != NULL)
			this->vt = VT_BSTR;
		else
		{
			this->vt = VT_EMPTY;
			THROW_REPOS_EXCEPTION();
		}
	}
#else
	CVariant(LPCTSTR szString)
	{
		::VariantInit(this);
		if (!szString)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else
		{
			LPWSTR		szUStr;
			int iSize = strlen(szString);
	
			if ((szUStr = new WCHAR[iSize + 1]) == NULL ||
				WszMultiByteToWideChar(CP_ACP, 0, szString, iSize + 1, szUStr, iSize + 1) == FALSE ||
				(this->bstrVal = ::SysAllocString(szUStr)) == NULL)
			{
				this->vt = VT_EMPTY;
				THROW_REPOS_EXCEPTION();
			}
			else
				this->vt = VT_BSTR;
			delete [] szUStr;
		}
	}
#endif

	CVariant(BSTR bstr)
	{
		::VariantInit(this);
		if (!bstr)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else if ((this->bstrVal = ::SysAllocString(bstr)) != NULL)
			this->vt = VT_BSTR;
		else
		{
			this->vt = VT_EMPTY;
			THROW_REPOS_EXCEPTION();
		}
	}

	CVariant(BYTE *pbBuff, size_t iSize)
	{
		::VariantInit(this);
		if (!pbBuff)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else 
			InitSafeArrayLen(pbBuff, iSize);
	}


//*****************************************************************************
// Assignment operators.
//*****************************************************************************

	const CVariant &operator=(BYTE byte)
	{
		::VariantClear(this);
		this->vt = VT_I1;
		this->bVal = byte;
		return (*this);
	}

	const CVariant &operator=(short val)
	{
		::VariantClear(this);
		this->vt = VT_I2;
		this->iVal = val;
		return (*this);
	}

	const CVariant &operator=(long lValNew)
	{
		::VariantClear(this);
		this->vt = VT_I4;
		this->lVal = lValNew;
		return (*this);
	}

	const CVariant &operator=(int lValNew)
	{
		::VariantClear(this);
		this->vt = VT_I4;
		this->lVal = lValNew;
		return (*this);
	}

	const CVariant &operator=(unsigned short val)
	{
		::VariantClear(this);
		this->vt = VT_UI2;
		this->iVal = val;
		return (*this);
	}

	const CVariant &operator=(unsigned long lValNew)
	{
		::VariantClear(this);
		this->vt = VT_UI4;
		this->lVal = lValNew;
		return (*this);
	}

	const CVariant &operator=(float fltVal)
	{
		::VariantClear(this);
		this->vt = VT_R4;
		this->fltVal = fltVal;
		return (*this);
	}

	const CVariant &operator=(double dblVal)
	{
		::VariantClear(this);
		this->vt = VT_R8;
		this->dblVal = dblVal;
		return (*this);
	}

	const CVariant &operator=(SYSTEMTIME stDate)
	{
		::VariantClear(this);
		this->vt = VT_DATE;
		if (FAILED(SystemTimeToDate(stDate, &this->date)))
			this->vt = VT_EMPTY;
		return (*this);
	}

	const CVariant &operator=(FILETIME ftDate)
	{
		SYSTEMTIME	stDate;

		::VariantClear(this);
		this->vt = VT_DATE;
		if (FAILED(FileTimeToSystemTime(&ftDate, &stDate)) ||
			FAILED(SystemTimeToDate(stDate, &this->date)))
			this->vt = VT_EMPTY;
		return (*this);
	}

#if 0
	const CVariant &operator=(TIMESTAMP_STRUCT tstmpDate)
	{
		::VariantClear(this);
		this->vt = VT_DATE;
		if (FAILED(TimeStampToDate(tstmpDate, &this->date)))
			this->vt = VT_EMPTY;
		return (*this);
	}
#endif

#ifdef UNICODE
	const CVariant &operator=(LPCTSTR szString)
	{
		::VariantClear(this);
		if (!szString)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else if ((this->bstrVal = SysAllocString(szString)) != NULL)
			this->vt = VT_BSTR;
		else
		{
			this->vt = VT_EMPTY;
			THROW_REPOS_EXCEPTION();
		}
		return (*this);
	}
#else
	const CVariant &operator=(LPCTSTR szString)
	{
		::VariantClear(this);
		if (!szString)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else
		{
			LPWSTR		szUStr;
			int iSize = strlen(szString);
	
			if ((szUStr = new WCHAR[iSize + 1]) == NULL ||
				WszMultiByteToWideChar(CP_ACP, 0, szString, iSize + 1, szUStr, iSize + 1) == FALSE ||
				(this->bstrVal = SysAllocString(szUStr)) == NULL)
			{
				this->vt = VT_EMPTY;
				THROW_REPOS_EXCEPTION();
			}
			else
				this->vt = VT_BSTR;
			delete [] szUStr;
		}
		return (*this);
	}
#endif

	const CVariant &operator=(BSTR bstr)
	{
		::VariantClear(this);
		if (!bstr)
		{
			this->vt = VT_NULL;
			this->bstrVal = NULL;
		}
		else if ((this->bstrVal = ::SysAllocString(bstr)) != NULL)
			this->vt = VT_BSTR;
		else
		{
			this->vt = VT_EMPTY;
			THROW_REPOS_EXCEPTION();
		}
		return (*this);
	}


//*****************************************************************************
// Conversion functions.
// @future: These should handle things like fraction, millisecond, and DayOfWeek.
//*****************************************************************************

#if 0
	static BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
		WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
	{
		// Validate year and month (ignore day of week and milliseconds)
		if (wYear > 9999 || wMonth < 1 || wMonth > 12)
			return FALSE;

		//	Check for leap year and set the number of days in the month
		BOOL bLeapYear = ((wYear & 3) == 0) &&
			((wYear % 100) != 0 || (wYear % 400) == 0);

		int nDaysInMonth =
			rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
			((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

		// Finish validating the date
		if (wDay < 1 || wDay > nDaysInMonth ||
			wHour > 23 || wMinute > 59 ||
			wSecond > 59)
		{
			return FALSE;
		}

		// Cache the date in days and time in fractional days
		long nDate;
		double dblTime;

		//It is a valid date; make Jan 1, 1AD be 1
		nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
			rgMonthDays[wMonth-1] + wDay;

		//	If leap year and it's before March, subtract 1:
		if (wMonth <= 2 && bLeapYear)
			--nDate;

		//	Offset so that 12/30/1899 is 0
		nDate -= 693959L;

		dblTime = (((long)wHour * 3600L) +	// hrs in seconds
			((long)wMinute * 60L) +  // mins in seconds
			((long)wSecond)) / 86400.;

		dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

		return TRUE;
	}

	static BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest)
	{
		// The legal range does not actually span year 0 to 9999.
		if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
			return FALSE;

		long nDays; 			// Number of days since Dec. 30, 1899
		long nDaysAbsolute; 	// Number of days since 1/1/0
		long nSecsInDay;		// Time in seconds since midnight
		long nMinutesInDay; 	// Minutes in day

		long n400Years; 		// Number of 400 year increments since 1/1/0
		long n400Century;		// Century within 400 year block (0,1,2 or 3)
		long n4Years;			// Number of 4 year increments since 1/1/0
		long n4Day; 			// Day within 4 year block
								//	(0 is 1/1/yr1, 1460 is 12/31/yr4)
		long n4Yr;				// Year within 4 year block (0,1,2 or 3)
		BOOL bLeap4 = TRUE; 	// TRUE if 4 year block includes leap year

		double dblDate = dtSrc; // tempory serial date

		// If a valid date, then this conversion should not overflow
		nDays = (long)dblDate;

		// Round to the second
		dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

		nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

		dblDate = fabs(dblDate);
		nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

		// Calculate the day of week (sun=1, mon=2...)
		//	 -1 because 1/1/0 is Sat.  +1 because we want 1-based
		tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

		// Leap years every 4 yrs except centuries not multiples of 400.
		n400Years = (long)(nDaysAbsolute / 146097L);

		// Set nDaysAbsolute to day within 400-year block
		nDaysAbsolute %= 146097L;

		// -1 because first century has extra day
		n400Century = (long)((nDaysAbsolute - 1) / 36524L);

		// Non-leap century
		if (n400Century != 0)
		{
			// Set nDaysAbsolute to day within century
			nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

			// +1 because 1st 4 year increment has 1460 days
			n4Years = (long)((nDaysAbsolute + 1) / 1461L);

			if (n4Years != 0)
				n4Day = (long)((nDaysAbsolute + 1) % 1461L);
			else
			{
				bLeap4 = FALSE;
				n4Day = (long)nDaysAbsolute;
			}
		}
		else
		{
			// Leap century - not special case!
			n4Years = (long)(nDaysAbsolute / 1461L);
			n4Day = (long)(nDaysAbsolute % 1461L);
		}

		if (bLeap4)
		{
			// -1 because first year has 366 days
			n4Yr = (n4Day - 1) / 365;

			if (n4Yr != 0)
				n4Day = (n4Day - 1) % 365;
		}
		else
		{
			n4Yr = n4Day / 365;
			n4Day %= 365;
		}

		// n4Day is now 0-based day of year. Save 1-based day of year, year number
		tmDest.tm_yday = (int)n4Day + 1;
		tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

		// Handle leap year: before, on, and after Feb. 29.
		if (n4Yr == 0 && bLeap4)
		{
			// Leap Year
			if (n4Day == 59)
			{
				/* Feb. 29 */
				tmDest.tm_mon = 2;
				tmDest.tm_mday = 29;
				goto DoTime;
			}

			// Pretend it's not a leap year for month/day comp.
			if (n4Day >= 60)
				--n4Day;
		}

		// Make n4DaY a 1-based day of non-leap year and compute
		//	month/day for everything but Feb. 29.
		++n4Day;

		// Month number always >= n/32, so save some loop time */
		for (tmDest.tm_mon = (n4Day >> 5) + 1;
			n4Day > rgMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

		tmDest.tm_mday = (int)(n4Day - rgMonthDays[tmDest.tm_mon-1]);

	DoTime:
		if (nSecsInDay == 0)
			tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
		else
		{
			tmDest.tm_sec = (int)nSecsInDay % 60L;
			nMinutesInDay = nSecsInDay / 60L;
			tmDest.tm_min = (int)nMinutesInDay % 60;
			tmDest.tm_hour = (int)nMinutesInDay / 60;
		}

		return TRUE;
	}

	static HRESULT SystemTimeToDate(		
		SYSTEMTIME	&stDate,				
		DATE		*pdtDate)			
	{
		if (OleDateFromTm(stDate.wYear, stDate.wMonth, stDate.wDay, stDate.wHour, 
				stDate.wMinute, stDate.wSecond, *pdtDate))
			return (S_OK);

		return (BadError(E_FAIL));
	}

	static HRESULT TimeStampToDate( 	
		TIMESTAMP_STRUCT &tstmpDate,				
		DATE		*pdtDate)			
	{
		if (OleDateFromTm(tstmpDate.year, tstmpDate.month, tstmpDate.day, tstmpDate.hour, 
				tstmpDate.minute, tstmpDate.second, *pdtDate))
			return (S_OK);

		return (BadError(E_FAIL));
	}
#endif

	static HRESULT DateToSystemTime(
		DATE		date,		
		SYSTEMTIME	*pstDate)			
	{
		tm	tmDate;

		if (!TmFromOleDate(date, tmDate))
			return (BadError(E_FAIL));

		pstDate->wYear = tmDate.tm_year;
		pstDate->wMonth = tmDate.tm_mon;
		pstDate->wDayOfWeek = 0; 
		pstDate->wDay = tmDate.tm_mday; 
		pstDate->wHour = tmDate.tm_hour;
		pstDate->wMinute = tmDate.tm_min;
		pstDate->wSecond = tmDate.tm_sec;
		pstDate->wMilliseconds = 0;
		
		return (S_OK);
	}

#if 0
	static HRESULT DateToTimeStamp(
		DATE		date,		
		TIMESTAMP_STRUCT *ptstmpDate)			
	{
		tm	tmDate;

		if (!TmFromOleDate(date, tmDate))
			return (BadError(E_FAIL));

		ptstmpDate->year = tmDate.tm_year;
		ptstmpDate->month = tmDate.tm_mon;
		ptstmpDate->day = tmDate.tm_mday; 
		ptstmpDate->hour = tmDate.tm_hour;
		ptstmpDate->minute = tmDate.tm_min;
		ptstmpDate->second = tmDate.tm_sec;
		ptstmpDate->fraction = 0;
		
		return (S_OK);
	}
#endif

//*****************************************************************************
// This one is a little misleading, for example it won't compare the contents
// of two BSTR's to see if they match, you'd have to have the same BSTR used
// into two values.  This is consistent with MFC, however.
//*****************************************************************************
	BOOL operator==(const VARIANT& varSrc) const
	{
		return (vt == varSrc.vt &&
				memcmp(((BYTE *) this) + 8, ((BYTE *) &varSrc) + 8,
							sizeof(VARIANT) - 8) == 0);
	}

	BOOL operator!=(const VARIANT&varSrc) const
	{
		return (!(*this == varSrc));
	}


//*****************************************************************************
// Access operators.
//*****************************************************************************

	BOOL IsEmpty()
	{ return (this->vt == VT_EMPTY); }

	operator int()
	{
		_ASSERTE(this->vt == VT_I2 || this->vt == VT_I4 || this->vt == VT_BOOL);
		if (this->vt == VT_I2) 
			return (this->iVal);
		else if (this->vt == VT_BOOL)
			return (this->boolVal);
		return (this->lVal);
	}

	operator unsigned int()
	{
		_ASSERTE(this->vt == VT_UI1 || this->vt == VT_UI2 || this->vt == VT_UI4 || this->vt == VT_BOOL);
		if (this->vt == VT_UI4)
			return (this->lVal);
		else if (this->vt == VT_UI1)
			return (this->bVal);
		else if (this->vt == VT_UI2) 
			return (this->iVal);
		return ((unsigned int) this->boolVal);
	}

	operator float()
	{
		_ASSERTE(this->vt == VT_R4);
		return (this->fltVal);
	}

	operator double()
	{
		_ASSERTE(this->vt == VT_R4 || this->vt == VT_R8);
		if (this->vt == VT_R4) 
			return (this->fltVal);
		return (this->dblVal);
	}

	operator BSTR()
	{
		_ASSERTE(this->vt == VT_BSTR || this->vt == VT_NULL);
		return (this->bstrVal);
	}

//*****************************************************************************
// Conversion functions for wide/multi-byte.
//*****************************************************************************
	HRESULT GetString(LPSTR szOut, int iMax)
	{
		if (this->vt == VT_NULL)
			*szOut = '\0';
		else if (WszWideCharToMultiByte(CP_ACP, 0, this->bstrVal , -1, szOut, iMax,
									NULL, NULL) == FALSE)
			return (BadError(E_FAIL));
		return (S_OK);
	}

	HRESULT GetString(LPWSTR szOut, int iMax)
	{
		int 		iLen = min(iMax, *(long *)(this->bstrVal - sizeof(DWORD)));
		wcsncpy(szOut, this->bstrVal, iLen);
		szOut[iLen] = '\0';
		return (S_OK);
	}

//*****************************************************************************
// Conversion functions for SYSTEMTIME and TIMESTAMP_STRUCT.
//*****************************************************************************
	HRESULT GetDate(SYSTEMTIME *pstDate)
	{
		if ((vt != VT_DATE) ||
				FAILED(DateToSystemTime(date, pstDate)))
			return (BadError(E_FAIL));
		return (S_OK);
	}

#if 0
	HRESULT GetDate(TIMESTAMP_STRUCT *ptstmpDate)
	{
		if ((vt != VT_DATE) ||
				FAILED(DateToTimeStamp(date, ptstmpDate)))
			return (BadError(E_FAIL));
		return (S_OK);
	}
#endif

//*****************************************************************************
// Clear the variant.
//*****************************************************************************
	void Clear()
	{
		::VariantClear(this);
	}

//*****************************************************************************
// Helper function to init a safe array.  This will leave the vt value
// as VT_EMPTY if the function fails.
//*****************************************************************************
	SAFEARRAY * InitSafeArrayLen(BYTE *pData, size_t iSize)
	{
		if ((this->parray = AllocSafeArrayLen(pData, iSize)) != NULL)
			this->vt = VT_UI1 | VT_ARRAY;
		else
		{
			this->vt = VT_EMPTY;
			THROW_REPOS_EXCEPTION();
		}
		return (this->parray);
	}
};
#endif


// # bytes to leave between allocations in debug mode
// Set to a > 0 boundary to debug problems - I've made this zero, otherwise a 1 byte allocation becomes
// a (1 + LOADER_HEAP_DEBUG_BOUNDARY) allocation
#define LOADER_HEAP_DEBUG_BOUNDARY	0

struct LoaderHeapBlock
{
	struct LoaderHeapBlock *pNext;
	void *					pVirtualAddress;
	DWORD					dwVirtualSize;
};


class UnlockedLoaderHeap
{
private:
	// Linked list of VirtualAlloc'd pages
	LoaderHeapBlock *	m_pFirstBlock;

	// Allocation pointer in current block
	BYTE *				m_pAllocPtr;

	// Points to the end of the committed region in the current block
	BYTE *				m_pPtrToEndOfCommittedRegion;
	BYTE *				m_pEndReservedRegion;

	LoaderHeapBlock *	m_pCurBlock;

	// When we need to VirtualAlloc() MEM_RESERVE a new set of pages, number of bytes to reserve
	DWORD				m_dwReserveBlockSize;

	// When we need to commit pages from our reserved list, number of bytes to commit at a time
	DWORD				m_dwCommitBlockSize;

	// Created by in-place new?
	BOOL				m_fInPlace;

public:
#ifdef _DEBUG
	DWORD				m_dwDebugTotalAlloc;
	DWORD				m_dwDebugWastedBytes;
#endif

#ifdef _DEBUG
	DWORD DebugGetWastedBytes()
	{
		return m_dwDebugWastedBytes + GetBytesAvailCommittedRegion();
	}
#endif

public:
	// Regular new
	void *operator new(size_t size)
	{
		void *pResult = new BYTE[size];

		if (pResult != NULL)
			((UnlockedLoaderHeap *) pResult)->m_fInPlace = FALSE;

		return pResult;
	}

	// In-place new
	void *operator new(size_t size, void *pInPlace)
	{
		((UnlockedLoaderHeap *) pInPlace)->m_fInPlace = TRUE;
		return pInPlace;
	}

	void operator delete(void *p)
	{
		if (p != NULL)
		{
			if (((UnlockedLoaderHeap *) p)->m_fInPlace == FALSE)
				::delete(p);
		}
	}

	UnlockedLoaderHeap(DWORD dwReserveBlockSize, DWORD dwCommitBlockSize);
	~UnlockedLoaderHeap();
   DWORD GetBytesAvailCommittedRegion();

	// Get some more committed pages - either commit some more in the current reserved region, or, if it
	// has run out, reserve another set of pages
	BOOL GetMoreCommittedPages(DWORD dwMinSize, BOOL bGrowHeap);

	// In debug mode, allocate an extra LOADER_HEAP_DEBUG_BOUNDARY bytes and fill it with invalid data.  The reason we
	// do this is that when we're allocating vtables out of the heap, it is very easy for code to
	// get careless, and end up reading from memory that it doesn't own - but since it will be
	// reading some other allocation's vtable, no crash will occur.  By keeping a gap between
	// allocations, it is more likely that these errors will be encountered.
	void *UnlockedAllocMem(DWORD dwSize, BOOL bGrowHeap = TRUE);

#if 0
	void DebugGuardHeap();
#endif

#ifdef _DEBUG
	void *UnlockedAllocMemHelper(DWORD dwSize,BOOL bGrowHeap = TRUE);
#endif
};


class LoaderHeap : public UnlockedLoaderHeap
{
private:
	CSafeAutoCriticalSection	m_SACriticalSection;

public:
	LoaderHeap(DWORD dwReserveBlockSize, DWORD dwCommitBlockSize) : UnlockedLoaderHeap(dwReserveBlockSize, dwCommitBlockSize)
	{
	}

	~LoaderHeap()
	{
	}

#ifdef _DEBUG
#pragma warning(disable:4318) //LOADER_HEAP_DEBUG_BOUNDARY is 0 so memset complains, but we might change it
	void *AllocMem(DWORD dwSize, BOOL bGrowHeap = TRUE)
	{
		void *pMem = AllocMemHelper(dwSize + LOADER_HEAP_DEBUG_BOUNDARY, bGrowHeap);

		if (pMem == NULL)
			return pMem;

		// Don't fill the entire memory - we assume it is all zeroed -just the memory after our alloc
		memset((BYTE *) pMem + dwSize, 0xEE, LOADER_HEAP_DEBUG_BOUNDARY);

		return pMem;
	}
#endif

	// This is synchronised
#ifdef _DEBUG
	void *AllocMemHelper(DWORD dwSize, BOOL bGrowHeap = TRUE)
#else
	void *AllocMem(DWORD dwSize, BOOL bGrowHeap = TRUE)
#endif
	{
		void *pResult;

		CSafeLock memLock (&m_SACriticalSection);
		DWORD dwRes = memLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			// fail the memory allocation
		   return 0;
		}

		pResult = UnlockedAllocMem(dwSize, bGrowHeap);
		return pResult;
	}
};

#endif // __UtilCode_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\utsem.h ===
/* ----------------------------------------------------------------------------
Microsoft   D.T.C (Distributed Transaction Coordinator)

//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

@doc

@module UTSem.H  |

@devnote None

@rev    4   | 6th-Jun-1997  |   JimLyon     | Rewrote
@rev    3   | 1st-Aug-1996  |   GaganC      | Added the spin lock code and class
@rev    2   | 31-May-1996   |   GaganC      | Removed the special code for x86
@rev    1   | 18th Jan, 96  |   GaganC      | Special cased UTGuard for X86
@rev    0   | 4th Feb,95    |   GaganC      | Created
---------------------------------------------------------------------------- */
#ifndef __UTSEM_H__
#define __UTSEM_H__


// -------------------------------------------------------------
//              INCLUDES
// -------------------------------------------------------------
#include "utilcode.h"


// -------------------------------------------------------------
//              CONSTANTS AND TYPES
// -------------------------------------------------------------
typedef enum {SLC_WRITE, SLC_READWRITE, SLC_READWRITEPROMOTE}
             SYNCH_LOCK_CAPS;

typedef enum {SLT_READ, SLT_READPROMOTE, SLT_WRITE}
             SYNCH_LOCK_TYPE;

const int NUM_SYNCH_LOCK_TYPES = SLT_WRITE + 1;



// -------------------------------------------------------------
//              FORWARDS
// -------------------------------------------------------------
class RTSemExclusive;
class RTSemExclusiveSL;
class CLock;
class UTGuard;
class RTSemReadWrite;
class UTSemRWMgrRead;
class UTSemRWMgrWrite;


// -------------------------------------------------------------
//                  GLOBAL HELPER FUNCTIONS
// -------------------------------------------------------------


/* ----------------------------------------------------------------------------
 @func Description:<nl>

   Guarantees isolated increments of *pl.<nl><nl>

 Usage:<nl>
   Use instead of InterlockedIncrement for Win16/Win32 portability.<nl><nl>

 @rev 0 | 3/21/95 | Rcraig | Created.
---------------------------------------------------------------------------- */
inline LONG SafeIncrement ( LPLONG pl )
{
    return (InterlockedIncrement (pl));
} // SafeIncrement



/* ----------------------------------------------------------------------------
 @func Description:<nl>
   Win16/Win32 abstraction wrapper: 
   Guarantees isolated decrements of *pl.<nl><nl>

 Usage:<nl>
   Use instead of InterlockedDecrement for Win16/Win32 portability.<nl><nl>

 @rev 0 | 3/21/95 | Rcraig | Created.
---------------------------------------------------------------------------- */
inline LONG SafeDecrement ( LPLONG pl )
{
    return (InterlockedDecrement (pl));
} // SafeDecrement



/* ----------------------------------------------------------------------------
@class  UTGuard
    This object represents a guard that can be acquired or released. The 
    advantage with useing this instead of a critical section is that this
    is non blocking. If AcquireGuard fails, it will return false and will not
    block.

@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */
class UTGuard
{
private:
    long            m_lVal;

public:
    //@cmember Constructor
    UTGuard (void)                      { m_lVal = 0; }
    //@cmember Destructor
    ~UTGuard (void)                     {}

    //@cmember  Acquires the guard
    BOOL            AcquireGuard (void) { return 0 == InterlockedExchange (&m_lVal, 1); }
    //@cmember  Releases the guard
    void            ReleaseGuard (void) { m_lVal = 0; }
    
    //@cmember  Initializes the Guard
    void            Init (void)         { m_lVal = 0; }
} ; //End class UTGuard



/* ----------------------------------------------------------------------------
@class RTSemReadWrite

    An instance of class RTSemReadWrite provides multi-read XOR single-write
    (a.k.a. shared vs. exclusive) lock capabilities, with protection against
    writer starvation.

    A thread MUST NOT call any of the Lock methods if it already holds a Lock.
    (Doing so may result in a deadlock.)

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */
class RTSemReadWrite
{
public:
    RTSemReadWrite(unsigned long ulcSpinCount = 0,
            LPCSTR szSemaphoreName = NULL, LPCSTR szEventName = NULL); // Constructor
    ~RTSemReadWrite(void);                  // Destructor

    // This implementation supports Read and Write locks
    SYNCH_LOCK_CAPS GetCaps(void)   { return SLC_READWRITE; };

    void LockRead(void);                    // Lock the object for reading
    void LockWrite(void);                   // Lock the object for writing
    void UnlockRead(void);                  // Unlock the object for reading
    void UnlockWrite(void);                 // Unlock the object for writing

    // This object is valid if it was initialized
    BOOL IsValid(void)              { return TRUE; }

    BOOL Lock(SYNCH_LOCK_TYPE t)            // Lock the object, mode specified by parameter
    {
        if (t == SLT_READ)
        {
            LockRead();
            return TRUE;
        }

        if (t == SLT_WRITE)
        {
            LockWrite();
            return TRUE;
        }
        return FALSE;
    }

    BOOL UnLock(SYNCH_LOCK_TYPE t)          // Unlock the object, mode specified by parameter
    {
        if (t == SLT_READ)
        {
            UnlockRead();
            return TRUE;
        }
        if (t == SLT_WRITE)
        {
            UnlockWrite();
            return TRUE;
        }
        return FALSE;
    }

private:
    virtual HANDLE GetReadWaiterSemaphore(void); // return Read Waiter Semaphore handle, creating if necessary
    virtual HANDLE GetWriteWaiterEvent (void); // return Write Waiter Event handle, creating if necessary

    unsigned long m_ulcSpinCount;           // spin counter
    volatile unsigned long m_dwFlag;        // internal state, see implementation
    HANDLE m_hReadWaiterSemaphore;          // semaphore for awakening read waiters
    HANDLE m_hWriteWaiterEvent;             // event for awakening write waiters
    LPCSTR m_szSemaphoreName;               // For cross process handle creation.
    LPCSTR m_szEventName;                   // For cross process handle creation.
};



/* ----------------------------------------------------------------------------
@class UTSemRWMgrRead

    An instance of this class represents the holding of a read lock on an instance
    of RTSemReadWrite. When this object is destroyed, the read lock will be
    automatically released.

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */

class UTSemRWMgrRead
{
public:
    UTSemRWMgrRead (RTSemReadWrite* pSemRW) { m_pSemRW = pSemRW; pSemRW->LockRead(); };
    ~UTSemRWMgrRead () { m_pSemRW->UnlockRead(); }

private:
    RTSemReadWrite* m_pSemRW;
};


/* ----------------------------------------------------------------------------
@class UTSemRWMgrWrite

    An instance of this class represents the holding of a write lock on an instance
    of RTSemReadWrite. When this object is destroyed, the write lock will be
    automatically released.

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */

class UTSemRWMgrWrite
{
public:
    inline UTSemRWMgrWrite (RTSemReadWrite* pSemRW) { m_pSemRW = pSemRW; pSemRW->LockWrite(); };
    inline ~UTSemRWMgrWrite () { m_pSemRW->UnlockWrite(); }

private:
    RTSemReadWrite* m_pSemRW;
};


/* ----------------------------------------------------------------------------
@class RTSemExclusive:

    An instance of this class represents an exclusive lock. If one thread calls
    Lock(), it will wait until any other thread that has called Lock() calls
    Unlock().

    A thread MAY call Lock multiple times.  It needs to call Unlock a matching
    number of times before the object is available to other threads.

    @rev    2   | 25, Mar 98 | JasonZ       | Added debug IsLocked code
    @rev    1   | 6th Jun 97 | JimLyon      | Added optional spin count
    @rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */
class RTSemExclusive
{
public:
    // Parameter to constructor is the maximum number of times to spin when
    // attempting to acquire the lock. The thread will sleep if the lock does
    // not become available in this period.
    RTSemExclusive (unsigned long ulcSpinCount = 0);
    ~RTSemExclusive (void)           { DeleteCriticalSection (&m_csx); }
    void Lock (void)                { EnterCriticalSection (&m_csx); _ASSERTE(++m_iLocks > 0);}
    void UnLock (void)              { _ASSERTE(--m_iLocks >= 0);  LeaveCriticalSection (&m_csx); }

#ifdef _DEBUG
    int IsLocked()                  { return (m_iLocks > 0); }
#endif

private:
    CRITICAL_SECTION m_csx;
#ifdef _DEBUG
    int             m_iLocks;           // Count of locks.
#endif
};  //end class RTSemExclusive





/* ----------------------------------------------------------------------------
@class RTSemExclusiveSL:

    A subclass of RTSemExclusive with a different default constructor.
    This subclass is appropriate for locks that are:
    *   Frequently Lock'd and Unlock'd, and
    *   Are held for very brief intervals.


    @rev    1   | 6th Jun 97 | JimLyon      | Rewritten to use RTSemExclusive
    @rev    0   | ???        | ???          | Created
---------------------------------------------------------------------------- */
class RTSemExclusiveSL : public RTSemExclusive
{
public:
    RTSemExclusiveSL (unsigned long ulcSpinCount = 400) : RTSemExclusive (ulcSpinCount) {}
};


/* ----------------------------------------------------------------------------
@class CLock

    An instance of this class represents the holding of a lock on an instance
    of RTSemExclusive. When this object is destroyed, the read lock will be
    automatically released.

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | ???        | ???          | Created
---------------------------------------------------------------------------- */

class CLock
{
public:
    CLock (RTSemExclusive* val) : m_pSem(val), m_locked(TRUE) {m_pSem->Lock();}
    CLock (RTSemExclusive& val) : m_pSem(&val), m_locked(TRUE) {m_pSem->Lock();}
    CLock (RTSemExclusive* val,BOOL fInitiallyLocked) : m_pSem(val), m_locked(fInitiallyLocked) {if (fInitiallyLocked) m_pSem->Lock();}
    ~CLock () { if (m_locked) m_pSem->UnLock(); }
    void Unlock () {m_pSem->UnLock(); m_locked = FALSE;}
    void Lock () {m_pSem->Lock(); m_locked = TRUE;}

private:
    BOOL m_locked;
    RTSemExclusive* m_pSem;
};


/* ----------------------------------------------------------------------------
Convenience #define's for use with RTSemExclusive and CLock

  These #define's assume that your object has a member named 'm_semCritical'.

  LOCK()        // locks m_semCritical; released at end of function if not sooner
  LOCKON(x)     // locks 'x', which is a RTSemExclusive
  UNLOCK()      // undo effect of LOCK(), LOCKON(x), or RELOCK()
  RELOCK()      // re-locks the object that UNLOCK() unlocks
  READYLOCK()   // allows use of RELOCK() and UNLOCK() to lock 'm_semCritical', but
                // does not grab the lock at this time.
  READYLOCKON(x)// allows use of RELOCK() and UNLOCK() to lock 'x', but does not
                // grab the lock at this time.

---------------------------------------------------------------------------- */


#define LOCKON(x)       CLock _ll1(x)
#define LOCK()          CLock _ll1(&m_semCritical)
#define READYLOCKON(x)  CLock _ll1(x, FALSE)
#define READYLOCK()     CLock _ll1(&m_semCritical, FALSE)
#define UNLOCK()        _ll1.Unlock()
#define RELOCK()        _ll1.Lock()

#define AUTO_CRIT_LOCK(plck) CLock __sLock(plck)
#define CRIT_LOCK(plck) plck->Lock()
#define CRIT_UNLOCK(plck) plck->Unlock()




#endif __UTSEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\comprc.cpp ===
//*****************************************************************************
// CompRC.cpp
//
// This module manages the resource dll for this code.	It is demand loaded
// only when you ask for something.  This makes startup performance much better.
// If the library is loaded during a run, it is intentionally leaked.  Windows
// will clean it up.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h" 					// Standard include.
#include "CompRC.h" 					// Resource dll.
#include "UtilCode.h"					// Win95 check.


//********** Globals. *********************************************************
CCompRC 		g_ResourceDll;			// Used for all clients in process.
HINSTANCE		CCompRC::m_hInst = 0;	// Init handle to 0.



//********** Code. ************************************************************



//*****************************************************************************
// Load the string and the library if required.
//*****************************************************************************
HRESULT CCompRC::LoadString(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet)
{
	HRESULT 	hr;

	// Load the library if required.
	if (m_hInst == 0 && (FAILED(hr = LoadRCLibrary())))
		return (hr);

	// Load the string we want.
	if (::W95LoadString(m_hInst, iResourceID, szBuffer, iMax) > 0)
		return (S_OK);
	
	// Allows caller to check for string not found without extra debug checking.
	if (bQuiet)
		return (E_FAIL);

	// Shouldn't be any reason for this condition but the case where we
	// used the wrong ID or didn't update the resource DLL.
	_ASSERTE(0);
	return (HRESULT_FROM_WIN32(GetLastError()));
}


//*****************************************************************************
// Load the library.
//*****************************************************************************
HRESULT CCompRC::LoadRCLibrary()
{
	WCHAR		rcPath[_MAX_PATH];		// Path to resource DLL.
	WCHAR		rcDrive[_MAX_DRIVE];	// Volume name.
	WCHAR		rcDir[_MAX_PATH];		// Directory.
	static bool	bLoaded = false;		// Only call this once.
	int 		iRet;
	_ASSERTE(m_hInst == NULL);

	// Don't try to load more than once.  If the dll is not found, then just
	// fail gracefully.
	if (bLoaded)
		return (E_FAIL);
	bLoaded = true;

	// Try first in the same directory as this dll.
	VERIFY(iRet = W95GetModuleFileName(GetModuleInst(), rcPath, NumItems(rcPath)));
	if ( iRet == 0 ) 
		return (HRESULT_FROM_WIN32(GetLastError()));
	SplitPath(rcPath, rcDrive, rcDir, 0, 0);
	swprintf(rcPath, L"%s%sMSCORRC.DLL", rcDrive, rcDir);

	// Feedback for debugging to eliminate unecessary loads.
	DEBUG_STMT(DbgWriteEx(L"Loading %s to load strings.\n", rcPath));

	// Load the resource library as a data file, so that the OS doesn't have
	// to allocate it as code.	This only works so long as the file contains
	// only strings.
	if ((m_hInst = WszLoadLibraryEx(rcPath, NULL, LOAD_LIBRARY_AS_DATAFILE)) == 0 &&
		(m_hInst = WszLoadLibraryEx(L"MSCORRC.DLL", NULL, LOAD_LIBRARY_AS_DATAFILE)) == 0)
	{
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}



CORCLBIMPORT HRESULT LoadStringRC(UINT iResourceID, LPWSTR szBuffer, 
		int iMax, int bQuiet)
{
	return (g_ResourceDll.LoadString(iResourceID, szBuffer, iMax, bQuiet));
}





#if defined(_DEBUG) || defined(_CHECK_MEM)

//*****************************************************************************
// Free the loaded library if we ever loaded it and only if we are not on
// Win 95 which has a known bug with DLL unloading (it randomly unloads a
// dll on shut down, not necessarily the one you asked for).  This is done
// only in debug mode to make coverage runs accurate.
//*****************************************************************************
CCompRC::~CCompRC()
{
	if (!RunningOnWin95() && m_hInst)
		::FreeLibrary(m_hInst);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\inc\oledbutil.h ===
//*****************************************************************************
// OleDBUtil.h
//
// Helper functions that are useful for an OLE/DB programmer.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __OLEDBUTIL_H__
#define __OLEDBUTIL_H__

#include "Tigger.h"
#include "UtilCode.h"
#include "Errors.h"


// This is an internal flag we set to know when to ignore the dictionary sort
// order.  This is handy for building internal data structures where a fast
// strcmp is the best.
#define DBCOMPAREOPS_OBEYLOCALE		0x8000


//*****************************************************************************
// Pull the name out of a DBID.
//*****************************************************************************
inline HRESULT GetNameFromDBID(const DBID *p, LPCWSTR &szName)
{
	// @todo: is this too strict?
	if (p->eKind != DBKIND_NAME)
		return (PostError(E_INVALIDARG));
	szName = p->uName.pwszName;
	return (S_OK);
}



//*****************************************************************************
// This is a helper class to create a set of bindings through function calls
// instead of have to inline the assignments and defaults.
//*****************************************************************************
class CBindingListAuto : public CDynArray<DBBINDING>
{
public:
	inline HRESULT BindCol(
		ULONG		iCol,					// Column to bind.
		ULONG		obValue,				// Offset to data.
		ULONG		cbMaxLen,				// Size of buffer.
		DBTYPE		wType)					// Type of data.
	{
		DBBINDING	*p;
		if ((p = Append()) == 0)
			return (OutOfMemory());
		return (::BindCol(p, iCol, obValue, cbMaxLen, wType));
	}

	inline HRESULT BindCol(
		ULONG		iCol,					// Column to bind.
		ULONG		obValue,				// Offset to data.
		ULONG		obLength,				// Offset of length data.
		ULONG		cbMaxLen,				// Size of buffer.
		DBTYPE		wType)					// Type of data.
	{
		DBBINDING	*p;
		if ((p = Append()) == 0)
			return (OutOfMemory());
		return (::BindCol(p, iCol, obValue, obLength, cbMaxLen, wType));
	}

	inline HRESULT BindCol(
		ULONG		iCol,					// Column to bind.
		ULONG		obValue,				// Offset to data.
		ULONG		obLength,				// Offset of length data.
		ULONG		obStatus,				// Offset of status.
		ULONG		cbMaxLen,				// Size of buffer.
		DBTYPE		wType)					// Type of data.
	{
		DBBINDING	*p;
		if ((p = Append()) == 0)
			return (OutOfMemory());
		return (::BindCol(p, iCol, obValue, obLength, obStatus, cbMaxLen, wType));
	}

};


// Returns the data portion of a user's binding.
inline BYTE *DataPart(const BYTE *pData, const DBBINDING *psBinding)
{
	_ASSERTE((psBinding->dwPart & DBPART_VALUE) != 0);
	if ((psBinding->wType & DBTYPE_BYREF) == 0)
		return ((BYTE *) pData + psBinding->obValue);
	return (*(BYTE **) (pData + psBinding->obValue));
}

// Returns the length value for a binding.
inline ULONG *LengthPartPtr(const BYTE *pData, const DBBINDING *psBinding)
{
	_ASSERTE((psBinding->dwPart & DBPART_LENGTH) != 0);
	return ((ULONG *) ((BYTE *) pData + psBinding->obLength));
}
ULONG LengthPart(const BYTE *pData, const DBBINDING *psBinding);

// Returns the status value for a binding.
inline DWORD *StatusPartPtr(const BYTE *pData, const DBBINDING *psBinding)
{
	_ASSERTE((psBinding->dwPart & DBPART_STATUS) != 0);
	return ((DWORD *) ((BYTE *) pData + psBinding->obStatus));
}
inline DWORD StatusPart(const BYTE *pData, const DBBINDING *psBinding)
{
	return (*StatusPartPtr(pData, psBinding));
}

inline void SetStatusPart(const BYTE *pData, const DBBINDING *psBinding, DBSTATUS dbStatus)
{
	if ((psBinding->dwPart & DBPART_STATUS) != 0)
		*StatusPartPtr(pData, psBinding) = S_OK;
}


// Return only the base data type of a binding, ignoring modifiers.
inline DBTYPE SafeDBType(const DBBINDING *psBinding)
{
	return (psBinding->wType & ~0xf000);
}

inline DBTYPE SafeDBType(DBTYPE dbType)
{
	return (dbType & ~0xf000);
}

inline DBCOMPAREOP SafeCompareOp(DBCOMPAREOP fComp)
{
	return (fComp & ~0xfffff000);
}


//*****************************************************************************
// Check a name to see if it meets size and character value requirements.
//*****************************************************************************
inline HRESULT CheckName(				// Return code.
	LPCWSTR		szName,					// Name of item.
	int			iMax)					// How big is max table name.
{
	if ((int) _tcslen(szName) + 1 >= iMax)
		return (PostError(CLDB_E_NAME_ERROR, szName));
	return (S_OK);
}



//*****************************************************************************
// Extracts a property value from a property set.  Handles type mismatch.
//@todo:
// (1) could handle data type conversions.
// (2) fill out remaining data types.
//*****************************************************************************
CORCLBIMPORT HRESULT GetPropValue(		// Return code.
	VARTYPE		vtType,					// Type of arguement expected.
	HRESULT		*phr,					// Return warnings here.
	void		*pData,					// where to copy data to.
	int			cbData,					// Max size of data.
	int			*pcbData,				// Out, size of actual data.
	DBPROP		&dbProp);				// The property value.


//*****************************************************************************
// Comparison function for two data types, returns -1, 0, or 1.
//*****************************************************************************
template <class T> 
int CompareNumbersEq(					// -1, 0, 1
	T			iVal1,					// First value.
	T			iVal2)					// Second value.
{
	if (iVal1 < iVal2)	return (-1);
	else if (iVal1 > iVal2) return (1);
	else return (0);
}


//*****************************************************************************
// Compares two pieces of data which are of the same type.  The return value
// is < 0 if p1 < p2, == 0 if the values are the same, or > 0 if p1 > p2.
// This routine, unlike memcmp, will work on integer formats that have 
// been little endian swapped.
//*****************************************************************************
int CmpData(							// -1, 0, 1, just like memcmp.
	DBTYPE		wType,					// Type of data we're comparing.
	void		*p1,					// First piece of data.
	void		*p2,					// Second piece of data.
	int			iSize1=-1,				// Size of p1, -1 for fixed.
	int			iSize2=-1);				// Size of p2, -1 for fixed.



//*****************************************************************************
// Compare two pieces of data using a particular comparison operator.  The
// data types must be compatible already, no conversion of the data will be
// done for you.  In addition, any null values must be resolved before calling
// this function, it is assumed there is data (it may be zero length data for
// variable type data).
//*****************************************************************************
int CompareData(						// true if data matches, false if not.
	DBTYPE		iSrcType,				// Type of source data for compare.
	BYTE		*pCellData,				// Source data buffer.
	ULONG		cbLen,					// Source buffer length.
	DBBINDING	*pBinding,				// User binding descriptor.
	BYTE		*pbData,				// User buffer.
	DBCOMPAREOP	fCompare);				// What type of comparison is desired.


#ifdef _DEBUG
class CRefTracker
{
public:
	CRefTracker() :
		m_cRef(0)
	{}
	~CRefTracker()
	{
		// If this assert fires, it means the the given object wasn't
		// fully released before the process went bye-bye.  This is a bug!!
		_ASSERTE(m_cRef == 0);
	}
	ULONG AddRef()
		{ return (++m_cRef); }
	ULONG Release()
		{ return (--m_cRef); }
	
	ULONG		m_cRef;
};

#define OLEDB_OBJ_CREATED(name) { extern CRefTracker g##name; g##name.AddRef(); } 
#define OLEDB_OBJ_DESTROYED(name) g##name.Release()

#else

#define OLEDB_OBJ_CREATED(name)
#define OLEDB_OBJ_DESTROYED(name)

#endif


#endif // __OLEDBUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\comprc.h ===
//*****************************************************************************
// CompRC.h
//
// This module manages the resource dll for this code.  It is demand loaded
// only when you ask for something.  This makes startup performance much better.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __CompRC_h__
#define __CompRC_h__


class CCompRC
{
public:
#if defined(_DEBUG) || defined(_CHECK_MEM)
	~CCompRC();
#endif

	HRESULT LoadString(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet=false);

	HRESULT LoadRCLibrary();

private:
	static HINSTANCE m_hInst;			// Instance handle when loaded.
};


CORCLBIMPORT HRESULT LoadStringRC(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet=false);

#endif //  __CompRC_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\makefile.inc ===
RunBBT:
	StgDBBBT $(MAKEDIR) $(O) $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT) $(TARGET_DIRECTORY)

LibGlobals: $(CORLIBS)\StgDB.lib $(O)\Globals.obj 
	lib /nologo /out:$(CORLIBS)\StgDB.lib $(CORLIBS)\StgDB.lib $(O)\Globals.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\errors.h ===
//*****************************************************************************
// Errors.h
//
// This module contains the error handling/posting code for the engine.  It
// is assumed that all methods may be called by a dispatch client, and therefore
// errors are always posted using IErrorInfo.  Additional support is given
// for posting OLE DB errors when required.
//
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __Errors_h__
#define __Errors_h__

#include "MetaErrors.h"					// List of errors for the engine.
#include "UtilCode.h"					// Utility helpers.


#define INITPUBLICMETHODFULL(piid, progid)	SSAutoEnter sSSAutoEnter(piid, progid)
#define INITPUBLICMETHOD(piid)	SSAutoEnter sSSAutoEnter(piid, _GetProgID())


// Index for this process for thread local storage.
extern DWORD g_iTlsIndex;




//*****************************************************************************
// Call at DLL startup to init the error system.
//*****************************************************************************
CORCLBIMPORT void InitErrors(DWORD *piTlsIndex);


//*****************************************************************************
// This function will post an error for the client.  If the LOWORD(hrRpt) can
// be found as a valid error message, then it is loaded and formatted with
// the arguments passed in.  If it cannot be found, then the error is checked
// against FormatMessage to see if it is a system error.  System errors are
// not formatted so no add'l parameters are required.  If any errors in this
// process occur, hrRpt is returned for the client with no error posted.
//*****************************************************************************
CORCLBIMPORT
HRESULT _cdecl PostError(				// Returned error.
	HRESULT		hrRpt,					// Reported error.
	...);								// Error arguments.


#endif // __Errors_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\errors.cpp ===
//*****************************************************************************
// Errors.cpp
//
// This module contains the error handling/posting code for the engine.  It
// is assumed that all methods may be called by a dispatch client, and therefore
// errors are always posted using IErrorInfo.  Additional support is given
// for posting OLE DB errors when required.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
#include "CompRC.h"                     // Resource dll help.
#include "UtilCode.h"                   // Utility helpers.
#include "Errors.h"                     // Error helper code.


// Global variables.
DWORD           g_iTlsIndex=0xffffffff; // Index for this process for thread local storage.

// Local prototypes.
HRESULT FillErrorInfo(LPCWSTR szMsg, DWORD dwHelpContext);


//*****************************************************************************
// Call at DLL startup to init the error system.
//*****************************************************************************
void InitErrors(DWORD *piTlsIndex)
{
    // Allocate a tls index for this process.
    if (g_iTlsIndex == 0xffffffff)
        VERIFY((g_iTlsIndex = TlsAlloc()) != 0xffffffff);

    // Give index to caller if they want it.
    if (piTlsIndex)
        *piTlsIndex = g_iTlsIndex;
}


//*****************************************************************************
// This function will post an error for the client.  If the LOWORD(hrRpt) can
// be found as a valid error message, then it is loaded and formatted with
// the arguments passed in.  If it cannot be found, then the error is checked
// against FormatMessage to see if it is a system error.  System errors are
// not formatted so no add'l parameters are required.  If any errors in this
// process occur, hrRpt is returned for the client with no error posted.
//*****************************************************************************
HRESULT _cdecl PostError(               // Returned error.
    HRESULT     hrRpt,                  // Reported error.
    ...)                                // Error arguments.
{
    WCHAR       rcBuf[512];             // Resource string.
    WCHAR       rcMsg[512];             // Error message.
    va_list     marker;                 // User text.
    long        *pcRef;                 // Ref count in tls.
    HRESULT     hr;

    // Return warnings without text.
    if (!FAILED(hrRpt))
        return (hrRpt);

	// If this is one of our errors, then grab the error from the rc file.
	if (HRESULT_FACILITY(hrRpt) == FACILITY_ITF)
	{
        hr = LoadStringRC(LOWORD(hrRpt), rcBuf, NumItems(rcBuf), true);
		if (hr == S_OK)
		{
			// Format the error.
			va_start(marker, hrRpt);
			wvsprintfW(rcMsg, rcBuf, marker);
			rcMsg[(sizeof(rcMsg) / sizeof(WCHAR)) - 1] = 0;
			va_end(marker);
		}
	}
	// Otherwise it isn't one of ours, so we need to see if the system can
	// find the text for it.
	else
	{
		if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
				0, hrRpt, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				rcMsg, NumItems(rcMsg), 0))
		{
			hr = S_OK;

	        // System messages contain a trailing \r\n, which we don't want normally.
            int iLen = lstrlenW(rcMsg);
            if (iLen > 3 && rcMsg[iLen - 2] == '\r' && rcMsg[iLen - 1] == '\n')
                rcMsg[iLen - 2] = '\0';
		}
		else
			hr = HRESULT_FROM_WIN32(GetLastError());
	}

	// If we failed to find the message anywhere, then issue a hard coded message.
	if (FAILED(hr))
	{
		swprintf(rcMsg, L"Runtime Internal error: 0x%08x", hrRpt);
		DEBUG_STMT(DbgWriteEx(rcMsg));
	}

    // Check for an old message and clear it.  Our public entry points do not do
    // a SetErrorInfo(0, 0) because it takes too long.
    IErrorInfo  *pIErrInfo;
    if (GetErrorInfo(0, &pIErrInfo) == S_OK)
        pIErrInfo->Release();

    // Turn the error into a posted error message.  If this fails, we still
    // return the original error message since a message caused by our error
    // handling system isn't going to give you a clue about the original error.
    VERIFY((hr = FillErrorInfo(rcMsg, LOWORD(hrRpt))) == S_OK);

    // Indicate in tls that an error occured.
    if ((pcRef = (long *) TlsGetValue(g_iTlsIndex)) != 0)
        *pcRef |= 0x80000000;
    return (hrRpt);
}


//*****************************************************************************
// Create, fill out and set an error info object.  Note that this does not fill
// out the IID for the error object; that is done elsewhere.
//*****************************************************************************
HRESULT FillErrorInfo(                  // Return status.
    LPCWSTR     szMsg,                  // Error message.
    DWORD       dwHelpContext)          // Help context.
{
    CComPtr<ICreateErrorInfo> pICreateErr;// Error info creation Iface pointer.
    CComPtr<IErrorInfo> pIErrInfo;      // The IErrorInfo interface.
    HRESULT     hr;                     // Return status.

    // Get the ICreateErrorInfo pointer.
    if (FAILED(hr = CreateErrorInfo(&pICreateErr)))
        return (hr);

    // Set message text description.
    if (FAILED(hr = pICreateErr->SetDescription((LPWSTR) szMsg)))
        return (hr);

    // Set the help file and help context.
//@todo: we don't have a help file yet.
    if (FAILED(hr = pICreateErr->SetHelpFile(L"complib.hlp")) ||
        FAILED(hr = pICreateErr->SetHelpContext(dwHelpContext)))
        return (hr);

    // Get the IErrorInfo pointer.
    if (FAILED(hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PVOID *) &pIErrInfo)))
        return (hr);

    // Save the error and release our local pointers.
    SetErrorInfo(0L, pIErrInfo);
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\msdaguid.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Implementation 
//  Copyright (C) 1994-2001 Microsoft Corporation.  All rights reserved.
//
// @doc
//
// @module MSDAGUID.H | Microsoft Data Access GUID defintions
//--------------------------------------------------------------------

#ifndef MSDAGUID
#define MSDAGUID

#undef OLEDBDECLSPEC
#if _MSC_VER >= 1100
#define OLEDBDECLSPEC __declspec(selectany)
#else
#define OLEDBDECLSPEC 
#endif //_MSC_VER

#ifdef DBINITCONSTANTS
EXTERN_C const OLEDBDECLSPEC GUID CLSID_OLEDB_ENUMERATOR = {0xc8b522d0L,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_EXTENDEDERRORINFO = {0xc8b522cfL,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_MSDAVTM = {0x0c733a8eL,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_OLEDB_CONVERSIONLIBRARY= {0xc8b522d1L,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_OLEDB_ROWPOSITIONLIBRARY= {0x2048eee6l,0x7fa2,0x11d0,{0x9e,0x6a,0x00,0xa0,0xc9,0x13,0x8c,0x29}};
EXTERN_C const OLEDBDECLSPEC GUID OLEDB_SVC_DSLPropertyPages = {0x51740c02,0x7e8e,0x11d2,{0xa0,0x2d,0x00,0xc0,0x4f,0xa3,0x73,0x48}};

#else
EXTERN_C const GUID CLSID_OLEDB_ENUMERATOR;
EXTERN_C const GUID CLSID_EXTENDEDERRORINFO;
EXTERN_C const GUID CLSID_MSDAVTM;
EXTERN_C const GUID CLSID_OLEDB_CONVERSIONLIBRARY;
EXTERN_C const GUID CLSID_OLEDB_ROWPOSITIONLIBRARY;
EXTERN_C const GUID OLEDB_SVC_DSLPropertyPages;
#endif

#endif // MSDAGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\globals.c ===
//*****************************************************************************
// Globals.c
//
// Place holder for global defines.  In many cases, the GUIDs have been extracted
// from their include files to keep our .rdata size down.  OLE DB defines a
// couple hundred GUIDs, few of which we actually need.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#define DBINITCONSTANTS
#define __TIGGER_PROP_SETS_ONLY__
#include <complib.h>					// Component library code.
#include "CompLib_i.c"					// Pull in GUIDs for linking.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\oledbutil.cpp ===
//*****************************************************************************
// OleDBUtil.cpp
//
// Helper functions that are useful for an OLE/DB programmer.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Precompiled header.
#include "OleDBUtil.h"                  // Our defines.

#include "Services.h"

// msdadc.h
const GUID CLSID_OLEDB_CONVERSIONLIBRARY = {0xc8b522d1L,0x5cf3,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d};

// const GUID IID_IDataConvert = {0x0c733a8dL,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d};
DEFINE_GUID(IID_IDataConvert,0x0c733a8dL,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);

#define DBCOMPAREOPS_MODIFIERMASK (DBCOMPAREOPS_CASESENSITIVE | DBCOMPAREOPS_CASEINSENSITIVE)


//*****************************************************************************
// This helper gets the correct length value for a binding.  This is only an
// issue for variable length data which can be defaulted to null terminated.
//*****************************************************************************
ULONG LengthPart(const BYTE *pData, const DBBINDING *psBinding)
{
    ULONG       cbLength = 0xffffffff;  // Return length value.

    // If the length is given, then get it from the binding.
    if (psBinding->dwPart & DBPART_LENGTH)
        cbLength = *LengthPartPtr(pData, psBinding);

    // Handle default to null terminated.
    if (cbLength == 0xffffffff)
    {
        switch (psBinding->wType & ~DBTYPE_BYREF)
        {
            // Count only bytes in string, not characters.
            case DBTYPE_STR:
            cbLength = (ULONG)strlen((const char *) DataPart(pData, psBinding));
            break;

            // Convert wide char count into bytes.
            case DBTYPE_WSTR:
            cbLength = (ULONG)lstrlenW((const WCHAR *) DataPart(pData, psBinding));
            cbLength *= sizeof(WCHAR);
            break;

            // Any other type, you must have bound length or don't make this call.
            default:
            _ASSERTE(psBinding->dwPart & DBPART_LENGTH);
            break;
        }
    }
    return (cbLength);
}



//*****************************************************************************
// Services code.
//*****************************************************************************

// Declare an instance to use for the whole process.
IDataConvert *CGetDataConversion::m_pIDataConvert = 0;
int			CGetDataConversion::m_bAllowLoad = false;


// If true, then we can load msdadc to do conversions.  If false, only
// conversion that can be done inline are allowed, and GetDataConversion
// will fail when called.
int CGetDataConversion::AllowLoad(int bAllowLoad)
{ 
	m_bAllowLoad = bAllowLoad;
	return (m_bAllowLoad);
}

HRESULT CGetDataConversion::GetIDataConversion(IDataConvert **ppIDataConvert)
{
	HRESULT		hr;
	if (m_pIDataConvert == 0)
	{
		if (!m_bAllowLoad)
			return (E_UNEXPECTED);

		if (FAILED(hr = CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY, 0, 
			CLSCTX_INPROC_SERVER, IID_IDataConvert, (PVOID *) &m_pIDataConvert)))
		return (hr);
	}
	*ppIDataConvert = m_pIDataConvert;
	m_pIDataConvert->AddRef();
	return (S_OK);
}

// This has to be called while OLE is still init'd.
void CGetDataConversion::ShutDown()
{
	if (m_pIDataConvert)
	{
		m_pIDataConvert->Release();
		m_pIDataConvert = 0;
	}
}


//*****************************************************************************
// These global helpers are used to provide an instance of the loader class.
//*****************************************************************************

BYTE		g_rgDataConversionBuffer[sizeof(CGetDataConversion)];
CGetDataConversion *g_pDataConversion = 0;

// This helper will init the global instance when we need it by running the
// ctor on the chunk of memory we allocated in the image.  This is done in this
// way to avoid a startup ctor call on dll load.
static void _InitDataConverBuffer()
{
	if (!g_pDataConversion)
	{
		new (g_rgDataConversionBuffer) CGetDataConversion;
		g_pDataConversion = (CGetDataConversion *) g_rgDataConversionBuffer;
	}
}

CORCLBIMPORT HRESULT GetDataConversion(IDataConvert **ppIDataConvert)
{
	_InitDataConverBuffer();
    return (g_pDataConversion->GetIDataConversion(ppIDataConvert));
}

CORCLBIMPORT void ShutDownDataConversion()
{
	_InitDataConverBuffer();
    g_pDataConversion->ShutDown();
}

CORCLBIMPORT CGetDataConversion *GetDataConvertObject()
{
	_InitDataConverBuffer();
    return (g_pDataConversion);
}


















//*****************************************************************************
// This is a wrapper function for the msdadc conversion code.  It will demand
// load the conversion service interface, and do some easy and common conversions
// itself, thus avoiding the working set hit of a dll load.  The documentation
// for this function can be found in the OLE DB SDK Guide.
//*****************************************************************************
HRESULT DataConvert( 
    DBTYPE wSrcType,
    DBTYPE wDstType,
    ULONG cbSrcLength,
    ULONG *pcbDstLength,
    void *pSrc,
    void *pDst,
    ULONG cbDstMaxLength,
    DBSTATUS dbsSrcStatus,
    DBSTATUS *pdbsStatus,
    BYTE bPrecision,
    BYTE bScale,
    DBDATACONVERT dwFlags)
{
    DWORD       dwErr;                  // Error handling.
    HRESULT     hr;

    // Handle certain conversions right in this code.  This avoids loading
    // the coverter for trivial things and avoids some bugs in msdadc.
    if (dwFlags == 0 && dbsSrcStatus == S_OK)
    {
        // Handle WSTR to STR internally; it is an easy conversion that is quite
        // common with the heap stored in ANSI.
        if (wSrcType == DBTYPE_WSTR && wDstType == DBTYPE_STR)
        {
            // Handle empty string as special case.
            if (cbSrcLength == 0)
            {
                *pcbDstLength = 0;
                *(LPSTR) pDst = 0;
                *pdbsStatus = S_OK;
                return (S_OK);
            }

            // OLE DB counts bytes, not chars.  Convert the input byte count
            // into a length.  In addition, if input string is null terminated,
            // the terminator is not counted.
            cbSrcLength /= 2;

            // Convert the string from input to output buffer.
            *pcbDstLength = ::W95WideCharToMultiByte(CP_ACP, 0, 
                    (LPCWSTR) pSrc, cbSrcLength,
                    (LPSTR) pDst, cbDstMaxLength, 0, 0);

            // If it worked, then record status.
            if (*pcbDstLength != 0)
            {
                *pdbsStatus = S_OK;

                // OLE DB doesn't count nulls, so they don't get converted.
                *((LPSTR) pDst + min(*pcbDstLength, cbDstMaxLength - 1)) = '\0';
            }
            // It failed and better be truncation.
            else
            {
                // Get the error for safety, it has to be truncation or it is a bug.
                VERIFY((dwErr = GetLastError()) == ERROR_INSUFFICIENT_BUFFER);

                if (dwErr == ERROR_INSUFFICIENT_BUFFER)
                {
                    // Mark status as truncated.
                    *pdbsStatus = DBSTATUS_S_TRUNCATED;

                    // Ask function to find out how big the buffer should have been.
                    *pcbDstLength = ::W95WideCharToMultiByte(CP_ACP, 0, 
                        (LPCWSTR) pSrc, cbSrcLength, 0, 0, 0, 0);

                    // Terminate the output buffer.
                    *((LPSTR) pDst + cbDstMaxLength  - 1) = '\0';
                }

                return (DB_S_ERRORSOCCURRED);
            }

            return (S_OK);
        }
        // Handle the *i8 types which are not supported by msdadc.dll
        // right now (OLE DB bug #4449).
        // @todo revisit before ship, see if latest version fixes this.
        else if ((wSrcType == DBTYPE_UI8 || wSrcType == DBTYPE_I8) &&
            (wDstType == DBTYPE_STR || wDstType == DBTYPE_WSTR))
        {
            if (wDstType == DBTYPE_STR)
            {
                *pcbDstLength = _snprintf((char *) pDst, cbDstMaxLength,
                        (wSrcType == DBTYPE_I8) ? "%I64d" : "%I64u",
                        *(unsigned __int64 *) pSrc);
            }
            else
            {
                *pcbDstLength = _snwprintf((wchar_t *) pDst, cbDstMaxLength,
                        (wSrcType == DBTYPE_I8) ? L"%I64d" : L"%I64u",
                        *(unsigned __int64 *) pSrc);
                *pcbDstLength *= sizeof(WCHAR);
            }

            // Check for truncation.
            if (*pcbDstLength >= 0)
                *pdbsStatus = S_OK;
            else
            {
                // Tell caller they didnt have enough room.
                *pdbsStatus = DBSTATUS_S_TRUNCATED;

                // Tell them to allocate a bunch more next time.
                *pcbDstLength = 128;
            }

            return (S_OK);
        }
#ifdef __PDC_Sphinx_Hack__
        // Sphinx cannot handle I8's at all, so truncate to I4's.
        else if ((wSrcType == DBTYPE_UI8 || wSrcType == DBTYPE_I8) && wDstType == DBTYPE_I4)
        {
            *(long *) pDst = *(long *) pSrc;
            *pcbDstLength = sizeof(long);
            *pdbsStatus = S_OK;
            return (S_OK);
        }
#endif
    }

    // If we got there, then it means no inline conversion could be done.
    CComPtr<IDataConvert> pIDataConvert; // Working copy.

    // Load the conversion service if required.
    if (FAILED(hr = ::GetDataConversion(&pIDataConvert)))
    {
        // If you get this assert, it means you are running an OLE DB
        // client that forced a data type conversion.  This is done using
        // the OLE DB conversion library which comes with the OLE DB
        // setup.  This dll must be shipped with any production code
        // that requires the OLE DB layer from this driver.  This dll is
        // not required for the COM 3 only run-time scenario.
        _ASSERTE(!"OLE DB conversion dll not installed, msdadc.dll, please run setup.");
        return (PostError(hr));
    }

    // Now let them do the real conversion for us.
    DBLENGTH dstLength;
    if (FAILED(hr = pIDataConvert->DataConvert(
            wSrcType, wDstType, cbSrcLength, &dstLength,
            pSrc, pDst, cbDstMaxLength,
            dbsSrcStatus, pdbsStatus, bPrecision, bScale, dwFlags)))
        return (hr);
    // WARNING: Possible data loss on IA64
    *pcbDstLength = (ULONG)dstLength;
    return (S_OK);
}


//*****************************************************************************
// This is a wrapper function for the msdadc conversion code.  It will demand
// load the conversion service interface then call the GetConversionSize
// function.
//*****************************************************************************
HRESULT GetConversionSize( 
    DBTYPE      wSrcType,
    DBTYPE      wDstType,
    DBLENGTH    *pcbSrcLength,
    DBLENGTH    *pcbDstLength,
    void        *pSrc)
{
    CComPtr<IDataConvert> pIDataConvert; // Working copy.
    HRESULT     hr;

    // Load the conversion service if required.
    if (FAILED(hr = ::GetDataConversion(&pIDataConvert)))
    {
        _ASSERTE(0);
        return (PostError(hr));
    }

    // Now let them do the real conversion for us.
    return (pIDataConvert->GetConversionSize(wSrcType, wDstType,
                pcbSrcLength, pcbDstLength, pSrc));
}



//*****************************************************************************
// Extracts a property value from a property set.  Handles type mismatch.
//@todo:
// (1) could handle data type conversions.
// (2) fill out remaining data types.
//*****************************************************************************
CORCLBIMPORT HRESULT GetPropValue(      // Return code.
    VARTYPE     vtType,                 // Type of arguement expected.
    HRESULT     *phr,                   // Return warnings here.
    void        *pData,                 // where to copy data to.
    int         cbData,                 // Max size of data.
    int         *pcbData,               // Out, size of actual data.
    DBPROP      &dbProp)                // The property value.
{
    void        *pUserData;
    
    if (dbProp.vValue.vt != vtType && (dbProp.vValue.vt & ~VT_BYREF) != vtType)
    {
        if (phr)
            *phr = DB_S_ERRORSOCCURRED;
        return (PostError(BadError(E_FAIL)));
    }

    // Make sure it is a type we support.
    _ASSERTE((dbProp.vValue.vt & ~VT_BYREF) == VT_I2 || (dbProp.vValue.vt & ~VT_BYREF) == VT_I4 ||
        (dbProp.vValue.vt & ~VT_BYREF) == VT_BOOL || (dbProp.vValue.vt & ~VT_BYREF) == VT_BSTR);

    // Get address of data from union.
    if ((dbProp.vValue.vt & VT_BYREF) == 0)
    {
        if ((dbProp.vValue.vt & ~VT_BYREF) == VT_BSTR)
            pUserData = dbProp.vValue.bstrVal;
        else
            pUserData = &dbProp.vValue.iVal;
    }
    else
    {
        if ((dbProp.vValue.vt & ~VT_BYREF) == VT_BSTR)
            pUserData = *dbProp.vValue.pbstrVal;
        else
            pUserData = dbProp.vValue.piVal;
    }

    // Copy data for caller.
    if (pData && pUserData)
    {
        if ((dbProp.vValue.vt & ~VT_BYREF) == VT_BSTR)
        {
            int     iLen = lstrlenW((LPCWSTR) pUserData) * 2;
            iLen = min(iLen, cbData);
            wcsncpy((LPWSTR) pData, (LPCWSTR) pUserData, iLen / 2);
            *((LPWSTR) ((UINT_PTR) pData + iLen)) = '\0';
        }
        else
            memcpy(pData, pUserData, cbData);
    }
    if (pcbData)
        *pcbData = cbData;
    return (S_OK);
}



//*****************************************************************************
// Helpers for data type compare.
//*****************************************************************************
inline int CmpDBDate(DBDATE *p1, DBDATE *p2)
{
    if (p1->year < p2->year)
        return (-1);
    else if (p1->year > p2->year)
        return (1);

    if (p1->month < p2->month)
        return (-1);
    else if (p1->month > p2->month)
        return (1);

    if (p1->day < p2->day)
        return (-1);
    else if (p1->day > p2->day)
        return (1);
    return (0);
}

inline int CmpDBTime(DBTIME *p1, DBTIME *p2)
{
    if (p1->hour < p2->hour)
        return (-1);
    else if (p1->hour > p2->hour)
        return (1);

    if (p1->minute < p2->minute)
        return (-1);
    else if (p1->minute > p2->minute)
        return (1);

    if (p1->second < p2->second)
        return (-1);
    else if (p1->second > p2->second)
        return (1);
    return (0);
}


//*****************************************************************************
// Compares two pieces of data which are of the same type.  The return value
// is < 0 if p1 < p2, == 0 if the values are the same, or > 0 if p1 > p2.
// This routine, unlike memcmp, will work on integer formats that have 
// been little endian swapped.
//*****************************************************************************
#define CMPFIXEDTYPES(type, buf1, buf2) ( (*(type *) buf1 == *(type *) buf2) ? 0 : (*(type *) buf1 < *(type *) buf2) ? -1 : 1 )
int CmpData(                            // -1, 0, 1, just like memcmp.
    DBTYPE      wType,                  // Type of data we're comparing.
    void        *p1,                    // First piece of data.
    void        *p2,                    // Second piece of data.
    int         iSize1,                 // Size of p1, -1 for fixed.
    int         iSize2)                 // Size of p2, -1 for fixed.
{
    int         iCmp;

    switch (wType)
    {
        // Fixed data is easy, just copy it.
        case DBTYPE_I2:
        return (CMPFIXEDTYPES(short, p1, p2));

        case DBTYPE_I4:
        return (CMPFIXEDTYPES(long, p1, p2));

        case DBTYPE_R4:
        return (CMPFIXEDTYPES(float, p1, p2));

        case DBTYPE_R8:
        return (CMPFIXEDTYPES(double, p1, p2));

        case DBTYPE_DATE:
        return (CMPFIXEDTYPES(DATE, p1, p2));

        case DBTYPE_BOOL:
        return (CMPFIXEDTYPES(VARIANT_BOOL, p1, p2));

        case DBTYPE_UI1:
        return (CMPFIXEDTYPES(unsigned char, p1, p2));

        case DBTYPE_I1:
        return (CMPFIXEDTYPES(char, p1, p2));

        case DBTYPE_UI2:
        return (CMPFIXEDTYPES(unsigned short, p1, p2));

        case DBTYPE_UI4:
        return (CMPFIXEDTYPES(unsigned long, p1, p2));

        case DBTYPE_CY:
        case DBTYPE_I8:
        return (CMPFIXEDTYPES(__int64, p1, p2));

        case DBTYPE_UI8:
        return (CMPFIXEDTYPES(unsigned __int64, p1, p2));

        case DBTYPE_DBDATE:
        return (CmpDBDate((DBDATE *) p1, (DBDATE *) p2));

        case DBTYPE_DBTIME:
        return (CmpDBTime((DBTIME *) p1, (DBTIME *) p2));

        case DBTYPE_DBTIMESTAMP:
        if ((iCmp = CmpDBDate((DBDATE *) p1, (DBDATE *) p2)) != 0)
            return (iCmp);
        if ((iCmp = CmpDBTime((DBTIME *) &((DBTIMESTAMP *) p1)->hour,
                    (DBTIME *) &((DBTIMESTAMP *) p2)->hour)) != 0)
            return (iCmp);
        if (((DBTIMESTAMP *) p1)->fraction < ((DBTIMESTAMP *) p2)->fraction)
            return (-1);
        else if (((DBTIMESTAMP *) p1)->fraction > ((DBTIMESTAMP *) p2)->fraction)
            return (1);
        return (0);

        // Intentional fall through for GUID.
        case DBTYPE_GUID:
        iSize1 = iSize2 = sizeof(GUID);

        // Variable data requires extra handling.
        case DBTYPE_BYTES:
        case DBTYPE_STR:
        case DBTYPE_WSTR:
        if (iSize1 < iSize2)
            return (-1);
        else if (iSize1 > iSize2)
            return (1);
        else
            return (memcmp(p1, p2, iSize1));
        break;
    }

    _ASSERTE(0 && "Unknown data type!");
    return (PostError(BadError(E_FAIL)));
}



//*****************************************************************************
// This template function compares two fixed size values according to the 
// option passed in.  The caller should attempt to promote things to a standard
// set of types instead of instantiating the template too many times.
//*****************************************************************************
template <class T> 
int CompareNumbers(                     // true if match, false if not.
    DBCOMPAREOP fCompare,               // How to compare values.
    T           iVal1,                  // First value.
    T           iVal2)                  // Second value.
{
    switch (fCompare & ~(DBCOMPAREOPS_MODIFIERMASK))
    {
        case DBCOMPAREOPS_LT:
        return (iVal1 < iVal2);

        case DBCOMPAREOPS_LE:
        return (iVal1 <= iVal2);

        case DBCOMPAREOPS_EQ:
        return (iVal1 == iVal2);

        case DBCOMPAREOPS_GE:
        return (iVal1 >= iVal2);

        case DBCOMPAREOPS_GT:
        return (iVal1 > iVal2);

        case DBCOMPAREOPS_NE:
        return (iVal1 != iVal2);

        default:
        _ASSERTE(!"Unknown compare option.");
    }
    return (false);
}


//*****************************************************************************
// Compare two byte strings.
//*****************************************************************************
int CompareBytes(                       // true if match, false else.
    DBCOMPAREOP fCompare,               // What comparison to use.
    BYTE        *pbData1,               // First buffer.
    ULONG       cbLen1,                 // Length of first buffer.
    BYTE        *pbData2,               // Second buffer.
    ULONG       cbLen2)                 // Length of second buffer.
{
    long        iCmp;

    // Give memcmp first crack at the data.
    iCmp = memcmp(pbData1, pbData2, min(cbLen1, cbLen2));

    // If the values are the same, but one is a substring of the other, then
    // need to decide order.
    if (!iCmp && cbLen1 != cbLen2)
        iCmp = (cbLen1 < cbLen2) ? -1 : 1;

    // Now default to the comparison template based on 0 as equality.
    return (CompareNumbers(fCompare, iCmp, (long) 0));
}


//*****************************************************************************
// Compare two ansi strings.  Apply case sensitivity accordingly.  The
// CompareString win32 function is used, meaning that collating sequence is
// decided based on this machine.
//*****************************************************************************
int CompareStr(                         // true if match, false else.
    DBCOMPAREOP fCompare,               // What type of comparison is desired.
    const char *sz1,                    // First string.
    int         cb1,                    // Length of first string, -1 nts.
    const char *sz2,                    // First string.
    int         cb2)                    // Length of first string, -1 nts.
{
    long        iCmp = 0;               // Failure by default

    if (SafeCompareOp(fCompare) == DBCOMPAREOPS_EQ || SafeCompareOp(fCompare) == DBCOMPAREOPS_NE)
    {
        if (fCompare & DBCOMPAREOPS_CASEINSENSITIVE)
		{
#ifdef UNDER_CE
            iCmp = _stricmp(sz1, sz2);
#else
			iCmp = CompareStringA(LOCALE_USER_DEFAULT, NORM_IGNORECASE, 
                sz1, cb1, sz2, cb2) - 2;
#endif
		}
        else // case-sensitive
            iCmp = strcmp(sz1, sz2);
    }
#ifndef UNDER_CE
    else if (SafeCompareOp(fCompare) == DBCOMPAREOPS_BEGINSWITH)
    {
        // Return true if sz1 starts with sz2.

        // Make sure there is a fixed length.
        //@todo: handle dbcs
        if (cb1 == -1)
            cb1 = (int)strlen(sz1);
        if (cb2 == -1)
            cb2 = (int)strlen(sz2);
        
        // Can start with it if it is bigger.
        if (cb2 > cb1)
            return (false);

        iCmp = CompareStringA(LOCALE_USER_DEFAULT, 
                (fCompare & DBCOMPAREOPS_CASEINSENSITIVE) ? NORM_IGNORECASE : 0, 
                sz1, cb2, sz2, cb2) - 2;

        fCompare = DBCOMPAREOPS_EQ;
    }
#endif // UNDER_CE
    else
    {
        _ASSERTE(!"nyi");
		iCmp = 0;
    }

    // The following is common to WinCE and other platforms

    return (CompareNumbers(fCompare, iCmp, (long) 0));
}

int CompareStrW(                        // true if match, false else.
    DBCOMPAREOP fCompare,               // What type of comparison is desired.
    const wchar_t *sz1,                 // First string.
    int         cch1,                    // Length of first string, -1 nts.
    const wchar_t *sz2,                 // First string.
    int         cch2)                    // Length of first string, -1 nts.
{
    long        iCmp = 0;

    if (SafeCompareOp(fCompare) == DBCOMPAREOPS_EQ || SafeCompareOp(fCompare) == DBCOMPAREOPS_NE)
    {
        if (fCompare & DBCOMPAREOPS_CASEINSENSITIVE)
		{
            iCmp = Wszlstrcmpi(sz1, sz2);
		}
        else // case-sensitive
            iCmp = wcscmp(sz1, sz2);
    }
    else if (SafeCompareOp(fCompare) == DBCOMPAREOPS_BEGINSWITH)
    {
        // Return true if sz1 starts with sz2.

        // Make sure there is a fixed length.
        if (cch1 == -1)
            cch1 = (int)wcslen(sz1);
	
        if (cch2 == -1)
            cch2 = (int)wcslen(sz2);
        
        // Can start with it if it is bigger.
        if (cch2 > cch1)
            return (false);

        iCmp = CompareStringW(LOCALE_USER_DEFAULT, 
                (fCompare & DBCOMPAREOPS_CASEINSENSITIVE) ? NORM_IGNORECASE : 0, 
                sz1, cch2, sz2, cch2) - 2;

        fCompare = DBCOMPAREOPS_EQ;
    }
    else
    {
        _ASSERTE(!"nyi");
    }
    return (CompareNumbers(fCompare, iCmp, (long) 0));
}


//*****************************************************************************
// Compare two pieces of data using a particular comparison operator.  The
// data types must be compatible already, no conversion of the data will be
// done for you.  In addition, any null values must be resolved before calling
// this function, it is assumed there is data (it may be zero length data for
// variable type data).
//*****************************************************************************
int CompareData(                        // true if data matches, false if not.
    DBTYPE      iSrcType,               // Type of source data for compare.
    BYTE        *pCellData,             // Source data buffer.
    ULONG       cbLen,                  // Source buffer length.
    DBBINDING   *pBinding,              // User binding descriptor.
    BYTE        *pbData,                // User buffer.
    DBCOMPAREOP fCompare)               // What type of comparison is desired.
{
    ULONG       cbUserLen = -1;        // User data length.
    BYTE        *pbUserData;            // User's data from binding.
    long        iCmp;                   // Value comparisons.

    // Disallow any conflicting comparisons.
#ifdef _DEBUG
    if (fCompare == DBCOMPAREOPS_CONTAINS || fCompare == DBCOMPAREOPS_BEGINSWITH)
        _ASSERTE(iSrcType == DBTYPE_STR || iSrcType == DBTYPE_WSTR || iSrcType == DBTYPE_BYTES);
#endif

    // Get pointer to user data.
    pbUserData = (BYTE *) DataPart(pbData, pBinding);
    if (pBinding->dwPart & DBPART_LENGTH)
        cbUserLen = LengthPart(pbData, pBinding);


    // Figure out what data type we are doing comparisons between.
    //
    // For numeric types, promote values within well known families and then
    // defer to the CompareNumbers template.  The reason for promoting is to
    // avoid the code bloat required for every data type comparison.  
    // The types of comparisons used include: long, ULONG, __int64, unsigned __int64,
    // and double.
    //
    // String data types are compared using the current machines collating
    // sequence.  Binary data is always compared by binary order.
    //
    switch (iSrcType)
    {
        case DBTYPE_I2:
        return (CompareNumbers(fCompare, (long) *(short *) pCellData, 
                (long) *(short *) pbUserData));

        case DBTYPE_I4:
        return (CompareNumbers(fCompare, *(long *) pCellData, 
                *(long *) pbUserData));

        case DBTYPE_R4:
        return (CompareNumbers(fCompare, (double) *(float *) pCellData, 
                (double) *(float *) pbUserData));

        case DBTYPE_R8:
        return (CompareNumbers(fCompare, *(double *) pCellData, 
                *(double *) pbUserData));

        case DBTYPE_CY:
        return (CompareNumbers(fCompare, *(__int64 *) pCellData, 
                *(__int64 *) pbUserData));

        case DBTYPE_DATE:
        return (CompareNumbers(fCompare, (double) *(DATE *) pCellData, 
                (double) *(DATE *) pbUserData));

        case DBTYPE_BOOL:
        return (CompareNumbers(fCompare, (long) *(VARIANT_BOOL *) pCellData, 
                (long) *(VARIANT_BOOL *) pbUserData));

        case DBTYPE_UI1:
        return (CompareNumbers(fCompare, (ULONG) *(unsigned char *) pCellData, 
                (ULONG) *(unsigned char *) pbUserData));

        case DBTYPE_I1:
        return (CompareNumbers(fCompare, (long) *(char *) pCellData, 
                (long) *(char *) pbUserData));

        case DBTYPE_UI2:
        return (CompareNumbers(fCompare, (ULONG) *(unsigned short *) pCellData, 
                (ULONG) *(unsigned short *) pbUserData));

        case DBTYPE_UI4:
        return (CompareNumbers(fCompare, *(unsigned long *) pCellData, 
                *(unsigned long *) pbUserData));

        case DBTYPE_I8:
        return (CompareNumbers(fCompare, *(__int64 *) pCellData, 
                *(__int64 *) pbUserData));

        case DBTYPE_UI8:
        return (CompareNumbers(fCompare, *(unsigned __int64 *) pCellData, 
                *(unsigned __int64 *) pbUserData));

        case DBTYPE_GUID:
        return (CompareBytes(fCompare, (BYTE *) pCellData, sizeof(GUID),
                (BYTE *) pbUserData, sizeof(GUID)));

        case DBTYPE_BYTES:
        _ASSERTE(pBinding->dwPart & DBPART_LENGTH);
        return (CompareBytes(fCompare, (BYTE *) pCellData, cbLen,
                (BYTE *) pbUserData, cbUserLen));

        case DBTYPE_STR:
        _ASSERTE(pBinding->dwPart & DBPART_LENGTH);
        return (CompareStr(fCompare, (const char *) pCellData, 
                (cbLen == 0xffff) ? -1 : cbLen,
                (const char *) pbUserData, 
                (cbUserLen == 0xffffffff) ? -1 : cbUserLen));

        case DBTYPE_WSTR:
        _ASSERTE(pBinding->dwPart & DBPART_LENGTH);
        return (CompareStrW(fCompare, (const wchar_t *) pCellData, 
                (int)((cbLen == 0xffff) ? -1 : cbLen/sizeof(WCHAR)),
                (const wchar_t *) pbUserData, 
                (int)((cbUserLen == 0xffffffff) ? -1 : cbUserLen/sizeof(WCHAR))));

        case DBTYPE_DBDATE:
        iCmp = CmpDBDate((DBDATE *) pCellData, (DBDATE *) pbUserData);
        return (CompareNumbers(fCompare, iCmp, (long) 0));

        case DBTYPE_DBTIME:
        iCmp = CmpDBTime((DBTIME *) pCellData, (DBTIME *) pbUserData);
        return (CompareNumbers(fCompare, iCmp, (long) 0));

        case DBTYPE_DBTIMESTAMP:
        {
            iCmp = CmpDBDate((DBDATE *) pCellData, (DBDATE *) pbUserData);
            if (!CompareNumbers(fCompare, iCmp, (long) 0))
                return (false);

            iCmp = CmpDBTime((DBTIME *) &((DBTIMESTAMP *) pCellData)->hour,
                        (DBTIME *) &((DBTIMESTAMP *) pbUserData)->hour);
            if (!CompareNumbers(fCompare, iCmp, (long) 0))
                return (false);

            return (CompareNumbers(fCompare, ((DBTIMESTAMP *) pCellData)->fraction,
                    ((DBTIMESTAMP *) pbUserData)->fraction));
        }

        default:
        _ASSERTE(!"Unknown data type in comparison");
    }
    return (false); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\openclb.cpp ===
//*****************************************************************************
// OpenCLB.cpp
//
// This implementation of the Create/OpenComponentLibrary[OnMem] functions is
// for internal use only.  These functions will create a very low level interface
// to the database which does very little error checking.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
#include "StgDatabase.h"                // Database interface.
#include "InternalDebug.h"				// Memory dump recording.

extern "C" 
{

//*****************************************************************************
// Create a new component library.  If the path exists, then this call will
// fail.
//*****************************************************************************
HRESULT STDAPICALLTYPE CreateComponentLibraryEx(
    LPCWSTR     szName,
    long        dwMode,
    IComponentRecords **ppIComponentRecords,
    LPSECURITY_ATTRIBUTES pAttributes)  // Security token.
{
	StgDatabase	*pDB;					// Database object.
	HRESULT		hr;

    // Avoid confusion on error.
    *ppIComponentRecords = 0;

	// Always report dumps.
	_DbgRecord();

    // Check for invalid flags.
    if (dwMode & (DBPROP_TMODEF_SMEMCREATE | DBPROP_TMODEF_SMEMOPEN))
        return (E_INVALIDARG);

    // Make sure you have the default required flags.
    dwMode |= DBPROP_TMODEF_READ | DBPROP_TMODEF_WRITE | DBPROP_TMODEF_CREATE;

    // Get a database object we can use.
    if (FAILED(hr = GetStgDatabase(&pDB)))
        return (hr);

    // Init the database for create.
    if (FAILED(hr = pDB->InitDatabase(szName, dwMode, 0, 0, 0, 0, pAttributes)))
    {
        DestroyStgDatabase(pDB);
        return (hr);
    }

    // Save the pointer for the caller.
    *ppIComponentRecords = (IComponentRecords *) pDB;
    return (S_OK);
}


//*****************************************************************************
// Open the given component library.
//*****************************************************************************
HRESULT STDAPICALLTYPE OpenComponentLibraryEx(
    LPCWSTR     szName, 
    long        dwMode,
    IComponentRecords **ppIComponentRecords,
    LPSECURITY_ATTRIBUTES pAttributes)
{
    StgDatabase *pDB;                   // Database object.
    HRESULT     hr;

    // Avoid confusion on error.
    *ppIComponentRecords = 0;

	// Always report dumps.
	_DbgRecord();

    // Check for invalid flags.
    if (dwMode & (DBPROP_TMODEF_CREATE | DBPROP_TMODEF_FAILIFTHERE | 
                DBPROP_TMODEF_SMEMCREATE | DBPROP_TMODEF_SMEMOPEN))
    {
        return (E_INVALIDARG);
    }

    // Get a database object we can use.
    if (FAILED(hr = GetStgDatabase(&pDB)))
        return (hr);

    // Init the database for create.
    if (FAILED(hr = pDB->InitDatabase(szName, dwMode, 0, 0, 0, 0, pAttributes)))
    {
        DestroyStgDatabase(pDB);
        return (hr);
    }

    // Save the pointer for the caller.
    *ppIComponentRecords = (IComponentRecords *) pDB;
    return (S_OK);
}


//*****************************************************************************
// Open the a database as shared memory for read only access.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE OpenComponentLibrarySharedEx( 
    LPCWSTR     szName,                 // Name of file on create, NULL on open.
    LPCWSTR     szSharedMemory,         // Name of shared memory.
    ULONG       cbSize,                 // Size of shared memory, 0 on create.
    LPSECURITY_ATTRIBUTES pAttributes,  // Security token.
    long        fFlags,                 // Open modes, must be read only.
    IComponentRecords **ppIComponentRecords) // Return database on success.
{
    StgDatabase *pDB;                   // Database object.
    HRESULT     hr;

    // Avoid confusion on error.
    *ppIComponentRecords = 0;

	// Always report dumps.
	_DbgRecord();

    // Check for invalid flags.
    if (fFlags & (DBPROP_TMODEF_WRITE | DBPROP_TMODEF_CREATE | DBPROP_TMODEF_FAILIFTHERE))
    {
        return (E_INVALIDARG);
    }

    // Get a database object we can use.
    if (FAILED(hr = GetStgDatabase(&pDB)))
        return (hr);

    // Init the database for create.
    if (FAILED(hr = pDB->InitDatabase(szName, fFlags, 0, cbSize, 0, 
                szSharedMemory, pAttributes)))
    {
        DestroyStgDatabase(pDB);
        return (hr);
    }

    // Save the pointer for the caller.
    *ppIComponentRecords = (IComponentRecords *) pDB;
    return (S_OK);
}


//*****************************************************************************
// Open the given component library.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE OpenComponentLibraryOnStreamEx( 
    IStream *pIStream,
    long dwMode,
    IComponentRecords **ppIComponentRecords)
{
    StgDatabase *pDB;                   // Database object.
    HRESULT     hr;

    // Avoid confusion on error.
    *ppIComponentRecords = 0;

	// Always report dumps.
	_DbgRecord();

    // Check for invalid flags.
    if (dwMode & (DBPROP_TMODEF_CREATE | DBPROP_TMODEF_FAILIFTHERE | 
                DBPROP_TMODEF_SMEMCREATE | DBPROP_TMODEF_SMEMOPEN))
    {
        return (E_INVALIDARG);
    }

    // Have to give us the stream.
    if (!pIStream)
        return (E_INVALIDARG);

    // Get a database object we can use.
    if (FAILED(hr = GetStgDatabase(&pDB)))
        return (hr);

    // Init the database for create.
    if (FAILED(hr = pDB->InitDatabase(0, dwMode, 0, 0, pIStream)))
    {
        DestroyStgDatabase(pDB);
        return (hr);
    }

    // Save the pointer for the caller.
    *ppIComponentRecords = (IComponentRecords *) pDB;
    return (S_OK);
}


//*****************************************************************************
// Open the given component library.
//*****************************************************************************
HRESULT STDAPICALLTYPE OpenComponentLibraryOnMemEx(
    ULONG       cbData, 
    LPCVOID     pbData, 
    IComponentRecords **ppIComponentRecords)
{
    StgDatabase *pDB;                   // Database object.
    HRESULT     hr;

    // Avoid confusion on error.
    *ppIComponentRecords = 0;

	// Always report dumps.
	_DbgRecord();

    // Get a database object we can use.
    if (FAILED(hr = GetStgDatabase(&pDB)))
        return (hr);

    // Init the database for create.
    if (FAILED(hr = pDB->InitDatabase(0, DBPROP_TMODEF_READ, 
            (void *) pbData, cbData)))
    {
        DestroyStgDatabase(pDB);
        return (hr);
    }

    // Save the pointer for the caller.
    *ppIComponentRecords = (IComponentRecords *) pDB;
    return (S_OK);
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stdafx.cpp ===
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\recordheap.cpp ===
//*****************************************************************************
// RecordHeap.cpp
//
// This module contains code to manage a heap of records for use in each table.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"
#include "StgDatabase.h"				// Database definitions.
#include "StgRecordManager.h"			// Record manager code.
#include "RecordHeap.h"



#ifdef _DEBUG
void DumpHeap(RECORDHEAP *pHeap);
#endif


//*****************************************************************************
// Get a pointer to the 0-based record in the heap.  This requires walking
// the list of heaps to find the correct record.
//*****************************************************************************
STGRECORDHDR *RECORDHEAP::GetRecordByIndex(ULONG Index)
{
	RECORDHEAP *pHeap;
	ULONG		Count=0;
	for (pHeap=this;  pHeap;  pHeap=pHeap->pNextHeap)
	{
		if (Index < Count + pHeap->VMArray.Count())
			return ((STGRECORDHDR *) pHeap->VMArray.Get(Index - Count));
		Count += pHeap->VMArray.Count();
	}
	DEBUG_STMT(DumpHeap(this));
	_ASSERTE(!"Index out of range for record heaps");
	return (0);
}

//*****************************************************************************
// Walk the record heaps looking for the given record and return its index.
//*****************************************************************************
ULONG RECORDHEAP::IndexForRecord(const STGRECORDHDR *pRecord)
{
	RECORDHEAP *pHeap;
	ULONG		Count=0;
	for (pHeap=this;  pHeap;  pHeap=pHeap->pNextHeap)
	{
		int Index = pHeap->VMArray.ValidItemIndex((void *) pRecord);
		if (Index >= 0)
			return (Count + Index);
		Count += pHeap->VMArray.Count();
	}
	DEBUG_STMT(DumpHeap(this));
	_ASSERTE(!"Record pointer not in record heap list");
	return (~0);
}


//*****************************************************************************
// This function walks every record heap looking for the one that contains
// the record passed in.
//*****************************************************************************
ULONG RECORDHEAP::GetHeapForRecord(		// 0 based record index on success.
	STGRECORDHDR *psRecord,				// The record to find.
	RECORDHEAP	*&pRecordHeap)			// First heap to search from.
{
	ULONG		Count=0;
	// Loop through each record heap we have to find the record.
	for (;  pRecordHeap;  pRecordHeap = pRecordHeap->pNextHeap)
	{
		int Index = pRecordHeap->VMArray.ValidItemIndex(psRecord);
		if (Index >= 0)
			return (Count + Index);
		Count += pRecordHeap->VMArray.Count();
	}
	DEBUG_STMT(DumpHeap(this));
	_ASSERTE(!"Record not found in any heap.");
	return (~0);
}




#ifdef _DEBUG
void DumpHeap(RECORDHEAP *pHeapDump)
{
	_ASSERTE(pHeapDump);

	DbgWriteEx(L"Dumping heap %p\n", pHeapDump);
	DbgWriteEx(L" Count:  Pointer  Items_in_heap  LastValidPtr\n");

	RECORDHEAP *pHeap;
	ULONG		Count=0;
	for (pHeap=pHeapDump;  pHeap;  pHeap=pHeap->pNextHeap)
	{
		DbgWriteEx(L"  %d:  %p   %d   %p\n", 
				Count, pHeap->VMArray.Ptr(), pHeap->VMArray.Count(),
				(UINT_PTR) pHeap->VMArray.Ptr() + pHeap->VMArray.Count() * pHeap->VMArray.ElemSize());
		Count += pHeap->VMArray.Count();
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stdafx.h ===
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#pragma once

#include <limits.h>						// ULONG_MAX, etc.

#include <CrtWrap.h>
#include <WinWrap.h>

#include <ole2.h>                       // OLE definitions
#include "oledb.h"                      // OLE DB headers.
#include "oledberr.h"                   // OLE DB Error messages.
#include "msdadc.h"                     // Data type conversion service.

#define _COMPLIB_GUIDS_


//#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_

//#include <atlbase.h>                    // ATL template classes.
//#ifdef _IA64_
//#    include <atlcom.h>                 // 64-bit ATL implementation is *all* different
//#endif

//#include "Intrinsic.h"                  // Functions to make intrinsic.
#define __STGDB_CODE__
#include "Exports.h"


// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgconstantdata.h ===
//*****************************************************************************
// StgConstantData.h
//
// Globally defined constants.  Please use the values here rather than putting
// in your own "static const" data around the source code.   This will fold
// all references into the same instances.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __StgConstantData_h__
#define __StgConstantData_h__


#ifdef __cplusplus
extern "C" {
#endif

#ifndef STGEXTERNCONSTANTDATA
#define STGEXTERNCONSTANTDATA extern const
#endif

STGEXTERNCONSTANTDATA DBCOMPAREOP	g_rgCompareEq[];
STGEXTERNCONSTANTDATA DBTYPE		g_rgDBTypeOID[];

STGEXTERNCONSTANTDATA ULONG			g_rgcbSizeByte[];
STGEXTERNCONSTANTDATA ULONG			g_rgcbSizeShort[];
STGEXTERNCONSTANTDATA ULONG			g_rgcbSizeLong[];
STGEXTERNCONSTANTDATA ULONG			g_rgcbSizeLongLong[];



#define g_rgcbSizeI1				g_rgcbSizeByte
#define g_rgcbSizeI2				g_rgcbSizeShort
#define g_rgcbSizeI4				g_rgcbSizeLong
#define g_rgcbSizeI8				g_rgcbSizeLongLong

#define g_rgcbSizeUI1				g_rgcbSizeByte
#define g_rgcbSizeUI2				g_rgcbSizeShort
#define g_rgcbSizeUI4				g_rgcbSizeLong
#define g_rgcbSizeUI8				g_rgcbSizeLongLong

#define g_rgcbSizeOID				g_rgcbSizeLong
#define g_rgcbSizeRID				g_rgcbSizeLong


#ifdef __cplusplus
}	// extern "C"
#endif


#endif // __StgConstantData_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\pagedef.h ===
//*****************************************************************************
// PageDef.h
//
// Descriptions of pages in the stream that hold data.  This data is read and
// written to disk.
//
// The following is the layout of the main header page.
//	+-------------------------------------------+
//	| PAGEHEADER (special case for page 0)		|
//	+-------------------------------------------+
//	| TABLEHEADER								|
//	+-------------------------------------------+
//	| TABLEDEF									|
//	+-------------------------------------------+
//	| COLUMNDEF[]								|
//	+-------------------------------------------+
//	| INDEXDEF[]								|
//	|	Key numbers[]							|
//	+-------------------------------------------+
//	| PAGELINK[]								|
//	|	[0] data								|
//	|	[1] data pages with free space			|
//	|	[2] free page list						|
//	|	[3] index #1							|
//	|	[4] index #2 (as applicable)			|
//	|	[5] index #3...							|
//	+-------------------------------------------+
//
// The following is the layout for a data page.
//	+-------------------------------------------+
//	| PAGEHEADER								|
//	+-------------------------------------------+
//	| RECORDHDR[]								|
//	+-------------------------------------------+
//	| Record offsets [grows backwards]			|
//	+-------------------------------------------+
//
// The following is the layout for a hashed index page.
//	+-------------------------------------------+
//	| PAGEHEADER								|
//	+-------------------------------------------+
//	| INDEXHEADER								|
//	+-------------------------------------------+
//	| HASHRECORD[]								|
//	+-------------------------------------------+
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __PageDef_h__
#define __PageDef_h__

#include "UtilCode.h"					// Hashing definitions.
#include "CompLib.h"					// IDL definitions.


#ifndef __COMPLIB_NAME_LENGTHS__
#define __COMPLIB_NAME_LENGTHS__
const int MAXCOLNAME = 64;
const int MAXSCHEMANAME = 32;
const int MAXINDEXNAME = 32 + MAXSCHEMANAME;
const int MAXTABLENAME = 32 + MAXSCHEMANAME;
const int MAXDESC = 256;
const int MAXTYPENAME = 36;
#endif




//
// Generic defines.
//
const int DEFAULTKEYSIZE = 256;

inline ULONG BstrLen(BSTR bstr)
{
	return (*((ULONG *) bstr - 1));
}



//
// Definitions for page information.
//
typedef USHORT PAGEID;

const PAGE_END_MARKER = 0xffff;			// Null page reference (no page).
const PAGESIZE = 2048;					// Size of a page.
const PAGELINKFIXED = 4;				// How many fixed page links are there.

enum PAGETYPES
{
	PAGE_DATA,							// Page contains data tuples.
	PAGE_DATAFREE,						// Pages with free space in them.
	PAGE_FREE,							// The entire page is free.
	PAGE_FREEFREE,						// Place holder, not actually used.
	PAGE_INDEX,							// Page is used for index data.
	PAGE_INDEXFREE						// Next page with room for index data.
};
typedef USHORT PAGETYPE;


enum PAGEFLAGS
{
	PAGEF_DIRTY		= 0x01,				// Indicates this page is dirty.
	PAGEF_TABLE		= 0x02,				// Table header page, cannot throw out.
	PAGEF_USED		= 0x04,				// Clock page out algorithm.
	PAGEF_FREE		= 0x08				// The page (in cache) is free to use.
};


//*****************************************************************************
// Describes the next and prev pages to link pages together.
//*****************************************************************************
struct PAGELINK
{
	PAGEID		iPageNext;				// Next page to find.
	PAGEID		iPagePrev;				// Previous page.

	inline PAGELINK & operator=(const PAGELINK &TheCopy)
	{
		iPageNext = TheCopy.iPageNext;
		iPagePrev = TheCopy.iPagePrev;
		return (*this);
	};
};

inline bool operator==(const PAGELINK& One, const PAGELINK& Other)
{
	return (One.iPageNext == Other.iPageNext &&
			One.iPagePrev == Other.iPagePrev);
}
inline bool operator!=(const PAGELINK& One, const PAGELINK& Other)
{
	return (!(One == Other));
}



//*****************************************************************************
// This struct is persisted with the page, but is only used at run time by the
// page caching system.
//*****************************************************************************
struct PAGERUNTIME
{
	DWORD		iAge;					// How old is this page.
	USHORT		iRefCnt;				// How many people are using this page.
	BYTE		fFlags;					// Flags for this page.
	BYTE		rcPad;					// Padding for alignemnt.
};


//*****************************************************************************
// Every page on disk starts with this header.  The record data itself can be
// found by looking at an array at the end of the page that grows backwords.
// For example, the offset for record 0 is the last two bytes of the page, the
// offset for record 1 is the two bytes before that, etc...
//*****************************************************************************
struct PAGEHEADER
{
	PAGERUNTIME	sCache;					// Cache specific data.
	PAGEID		PageID;					// Page number, 0 based.
	PAGETYPE	iPageType;				// PAGE_xxx type.
	USHORT		iFreeBytes;				// How many bytes are free in this page.
	USHORT		iRecords;				// How many records on this page.
	PAGELINK	sLink;					// Link to next page of this type.
	PAGELINK	sFreeLink;				// Link to next page with free space.
};


//*****************************************************************************
// The first bytes of every table stream consist of this struct.  Immediately
// following this struct is the table definition data, columns, and indexes.
// After all of that is an array of page offset structs.
//*****************************************************************************
struct TABLEHEADER
{
	USHORT		iHeaderSize;			// Size of the rest of the header.
	USHORT		iPageSize;				// Size of a page in this stream.
	USHORT		iPages;					// How many pages are in this stream.
	USHORT		iVersion;				// Format version number.
};




//
//
// Schema definitions.
//
//

//*****************************************************************************
// Used to describe the different types of indexes this system supports.
//*****************************************************************************
enum INDEXTYPES
{
	INDEX_HASHED,						// Hashed index.
	INDEX_CLUSTERED,					// Clustered index.
};


//*****************************************************************************
// GUID's to uniquely identify a database type.
//*****************************************************************************
#define TYPE_SPEC(g) extern const GUID __declspec(selectany) g

TYPE_SPEC(TYPE_OID) = { 0x623c846, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_I2) = { 0x623c847, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_I4) = { 0x623c848, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_R4) = { 0x623c849, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_R8) = { 0x623c84a, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_CY) = { 0x623c84b, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_DATE) = { 0x623c84c, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_BOOL) = { 0x623c84d, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_VARIANT) = { 0x623c84e, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_UI1) = { 0x623c84f, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_I1) = { 0x623c850, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_UI2) = { 0x623c851, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_UI4) = { 0x623c852, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_I8) = { 0x623c853, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_UI8) = { 0x623c854, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_GUID) = { 0x623c855, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_BYTES) = { 0x623c856, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_STR) = { 0x623c857, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_WSTR) = { 0x623c858, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_DBDATE) = { 0x623c859, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_DBTIME) = { 0x623c85a, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_DBTIMESTAMP) = { 0x623c85b, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_IDISPATCH) = { 0x623c85c, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_IUNKNOWN) = { 0x623c85d, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };
TYPE_SPEC(TYPE_INT) = { 0x623c85e, 0x7891, 0x11d0, { 0xad, 0x16, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0x80 } };






#define VARCOLDEF (DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)
#define FIXEDCOLDEF (DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_ISFIXEDLENGTH | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL)

enum
{
	TYPEF_NUMBER		= 0x01,			// Normal signed number.
	TYPEF_UNSIGNED		= 0x02,			// Data type only allows unsigned.
	TYPEF_AUTOINC		= 0x04,			// Number is auto increment capable.
// Combinations.
	TYPEF_UNUMBER		= 0x01 | 0x02,	// Unsigned number.
};




//*****************************************************************************
// This struct is used to answer questions about data types in this database.
//*****************************************************************************
#define DBTYPEDECL( dbtype,  szName, szCName, fFlags, fFlags2, iSize, iPrecision, pguidType ) dbtype, fFlags,  L#dbtype, szName, szCName, fFlags2, iSize, iPrecision, pguidType
const struct DATATYPEDEF
{
	DBTYPE		iType;					// The numeric type for this datatype.
	DBCOLUMNFLAGS fFlags;				// Description of the data type.
	LPCWSTR		szDBTypeName;			// The name of the type, char string.
	LPCWSTR		szName;					// The name of the data type.
	LPCWSTR		szCName;				// A data type declaration in C for this type.
	ULONG		fFlags2;				// TYPEF_ values.
	USHORT		iSize;					// Default size.
	ULONG		iPrecision;				// Max precision.
	const GUID	*pguidType;				// Unique guid for this data type.
} grDataTypes[] =
{
//	Enumerated type						szName					szCName				fFlags				fFlags2						iSize						iPrecision		pguidType
	DBTYPEDECL( DBTYPE_OID,				L"OID",					L"OID",				FIXEDCOLDEF,		TYPEF_NUMBER|TYPEF_AUTOINC,	sizeof(long),				10,				&TYPE_OID),
	DBTYPEDECL( DBTYPE_I2,				L"short",				L"short",			FIXEDCOLDEF,		TYPEF_NUMBER|TYPEF_AUTOINC,	sizeof(short),				5,				&TYPE_I2),
	DBTYPEDECL( DBTYPE_I4,				L"long",				L"long",			FIXEDCOLDEF,		TYPEF_NUMBER|TYPEF_AUTOINC,	sizeof(long),				10,				&TYPE_I4),
	DBTYPEDECL( DBTYPE_R4,				L"float",				L"float",			FIXEDCOLDEF,		TYPEF_NUMBER,				sizeof(float),				7,				&TYPE_R4),
	DBTYPEDECL( DBTYPE_R8,				L"double",				L"double",			FIXEDCOLDEF,		TYPEF_NUMBER,				sizeof(double),				16,				&TYPE_R8),
	DBTYPEDECL( DBTYPE_CY,				L"currency",			L"CY",				FIXEDCOLDEF,		TYPEF_NUMBER,				sizeof(CY),					19,				&TYPE_CY),
	DBTYPEDECL( DBTYPE_DATE,			L"vbdate",				L"DATE",			FIXEDCOLDEF,		0,							sizeof(DATE),				(ULONG) -1,		&TYPE_DATE),
	DBTYPEDECL( DBTYPE_BOOL,			L"bool",				L"VARIANT_BOOL",	FIXEDCOLDEF,		TYPEF_UNUMBER,				sizeof(VARIANT_BOOL),		1,				&TYPE_BOOL),
	DBTYPEDECL( DBTYPE_VARIANT,			L"variant",				L"VARIANT",			VARCOLDEF,			0,							1024,						1024,			&TYPE_VARIANT),
	DBTYPEDECL( DBTYPE_UI1,				L"unsigned tinyint",	L"unsigned char",	FIXEDCOLDEF,		TYPEF_UNUMBER,				sizeof(unsigned char),		3,				&TYPE_UI1),
	DBTYPEDECL( DBTYPE_I1,				L"tinyint",				L"char",			FIXEDCOLDEF,		TYPEF_NUMBER,				sizeof(char),				3,				&TYPE_I1),
	DBTYPEDECL( DBTYPE_UI2,				L"unsigned short",		L"unsigned short",	FIXEDCOLDEF,		TYPEF_UNUMBER|TYPEF_AUTOINC,sizeof(unsigned short),		5,				&TYPE_UI2),
	DBTYPEDECL( DBTYPE_UI4,				L"unsigned long",		L"unsigned long",	FIXEDCOLDEF,		TYPEF_UNUMBER|TYPEF_AUTOINC,sizeof(unsigned long),		10,				&TYPE_UI4),
	DBTYPEDECL( DBTYPE_I8,				L"bigint",				L"__int64",			FIXEDCOLDEF,		TYPEF_NUMBER,				sizeof(__int64),			20,				&TYPE_I8),
	DBTYPEDECL( DBTYPE_UI8,				L"unsigned bigint",		L"unsigned __int64",FIXEDCOLDEF,		TYPEF_UNUMBER,				sizeof(unsigned __int64),	20,				&TYPE_UI8),
	DBTYPEDECL( DBTYPE_GUID,			L"GUID",				L"GUID",			FIXEDCOLDEF,		0,							sizeof(GUID),				16,				&TYPE_GUID),
	DBTYPEDECL( DBTYPE_BYTES,			L"varbinary",			L"BYTE",			VARCOLDEF,			0,							1024,						0xffff,			&TYPE_BYTES),
	DBTYPEDECL( DBTYPE_STR,				L"varchar",				L"char",			VARCOLDEF,			0,							1024,						0xffff,			&TYPE_STR),
	DBTYPEDECL( DBTYPE_WSTR,			L"wide varchar",		L"wchar_t",			VARCOLDEF,			0,							1024,						0xffff,			&TYPE_WSTR),
	DBTYPEDECL( DBTYPE_DBDATE,			L"date",				L"DBDATE",			FIXEDCOLDEF,		0,							sizeof(DBDATE),				(ULONG) -1,		&TYPE_DBDATE),
	DBTYPEDECL( DBTYPE_DBTIME,			L"time",				L"DBTIME",			FIXEDCOLDEF,		0,							sizeof(DBTIME),				(ULONG) -1,		&TYPE_DBTIME),
	DBTYPEDECL( DBTYPE_DBTIMESTAMP,		L"datetime",			L"DBTIMESTAMP",		FIXEDCOLDEF,		0,							sizeof(DBTIMESTAMP),		(ULONG) -1,		&TYPE_DBTIMESTAMP),
};

// Map a name to a type.
inline const DATATYPEDEF *GetTypeFromName(LPCWSTR szName)
{
	for (int i=0;  i<NumItems(grDataTypes);  i++)
	{
		if (wcscmp(grDataTypes[i].szName, szName) == 0)
			return (&grDataTypes[i]);
	}
	return (0);
}

// Map a type to full data.
inline const DATATYPEDEF *GetTypeFromType(DBTYPE iType)
{
	for (int i=0;  i<NumItems(grDataTypes);  i++)
	{
		if (grDataTypes[i].iType == iType)
			return (&grDataTypes[i]);
	}
	return (0);
}

// Get a size for a type.
inline USHORT GetSizeForType(DBTYPE iType, USHORT iDftSize)
{
	// Lookup data type.
	const DATATYPEDEF *pDataType = GetTypeFromType(iType);
	
	if (pDataType == 0)
	{
		_ASSERTE(0);
		return (iDftSize);
	}

	if (pDataType->fFlags & DBCOLUMNFLAGS_ISFIXEDLENGTH)
		return (pDataType->iSize);
	else
		return (iDftSize);
}


// These are extended types that cannot be persisted as is, but are part
// of the type set.
const DATATYPEDEF grExtDataTypes[] =
{
//	Enumerated type						szName					szCName			fFlags			fFlags2						iSize						iPrecision		pguidType
	DBTYPEDECL( DBTYPE_IDISPATCH,		L"IDispatch",			L"IDispach *",	0,				0,							sizeof(IDispatch *),		(ULONG) -1,		&TYPE_IDISPATCH),
	DBTYPEDECL( DBTYPE_IUNKNOWN,		L"IUnknown",			L"IUnknown *",	0,				0,							sizeof(IUnknown *),			(ULONG) -1,		&TYPE_IUNKNOWN),
	DBTYPEDECL( DBTYPE_INT,				L"int",					L"int",			FIXEDCOLDEF,	TYPEF_NUMBER|TYPEF_AUTOINC,	sizeof(int),				10,				&TYPE_INT),
};
inline const DATATYPEDEF *GetExtendedType(DBTYPE iType)
{
	for (int i=0;  i<NumItems(grExtDataTypes);  i++)
	{
		if (grExtDataTypes[i].iType == iType)
			return (&grExtDataTypes[i]);
	}
	return (0);
};


// The assembly generated 

// Is the data type variable size?  Variable types are DBTYPE_BYTES, DBTYPE_STR,
//  and DBTYPE_WSTR.
FORCEINLINE int IsVarType(DBTYPE eType)
{
	eType &= ~DBTYPE_BYREF;
	return (eType >= DBTYPE_BYTES && eType <= DBTYPE_WSTR);
}

// Is the data type fixed size?
FORCEINLINE int IsFixedType(DBTYPE eType)
{
	eType &= ~DBTYPE_BYREF;
	return (eType < DBTYPE_BYTES || eType > DBTYPE_WSTR);
}

// Is the data stored in a pool, not directly in the row?
FORCEINLINE int IsPooledType(DBTYPE eType)
{
	eType &= ~DBTYPE_BYREF;
	return (eType == DBTYPE_VARIANT ||
			eType == DBTYPE_GUID ||
			IsVarType(eType));
}

// Convenience accessor for non-pooled.
FORCEINLINE int IsNonPooledType(DBTYPE eType)
{
	return (!IsPooledType(eType));
}

// Can the size IN THE ROW be compressed, depending on # of items?
inline int IsCompressableType(DBTYPE eType)
{
	eType &= ~DBTYPE_BYREF;
	return (eType == DBTYPE_OID ||
			eType == DBTYPE_VARIANT ||
			eType == DBTYPE_GUID ||
			IsVarType(eType));
}


//*****************************************************************************
// Each column in a table is described by this struct.  The instance data lives
// at the end of the TABLEDEF struct.
//*****************************************************************************
struct COLUMNDEF
{
	WCHAR		rcName[MAXCOLNAME];		// Column name.
	BYTE		iColumn;				// Column number.
	BYTE		fFlags;					// Our column flags.
	DBTYPE		iType;					// Column type.
	USHORT		iSize;					// Size of the column.
	USHORT		iOffset;				// Offset of a column in a record from
										//  head of record (fixed), offset to
										//	length indicator for variable data.
};

//*****************************************************************************
// An index contains the main information, and is then followed by an array
// of up column numbers up to iKeys.  The sizes and types of those columns
// must be found out by looking at the column descriptors.
//*****************************************************************************
struct INDEXDEF
{
	WCHAR		rcName[MAXINDEXNAME];	// Name of the index.
	GUID		sIndexType;				// Index identifier.
	USHORT		fFlags;					// Flags describing the index.
	USHORT		iBuckets;				// How many buckets to use.
	USHORT		iRowThreshold;			// Don't index if rowcount < this.
	USHORT		iMaxCollisions;			// ~Maximum collisions allowed.

	BYTE		iIndexNum;				// Which index is this.
	BYTE		iKeys;					// How many columns in the key.
	BYTE		rgKeys[2];				// Start of array of key numbers.
};

inline INDEXDEF * NextIndexDef(INDEXDEF *psIndexDef)
{
	psIndexDef = (INDEXDEF *) ((BYTE *) psIndexDef + ALIGN4BYTE(offsetof(INDEXDEF, rgKeys) + psIndexDef->iKeys * sizeof(BYTE)));
	return (psIndexDef);
}



//*****************************************************************************
// Definition of a table that lives in a stream.  &rgColumns[0] is the first
// of an array of up to iColumns column definitions.
//*****************************************************************************
struct TABLEDEF
{
	WCHAR		rcName[MAXTABLENAME];	// Name of this table.
	GUID		sTableID;				// Unique ID of this table in this stream.
	BYTE		iColumns;				// How many columns in the table.
	BYTE		iVarColumns;			// How many variable columns are there.
	BYTE		iIndexes;				// How many indexes.
	BYTE		iBuckets;				// Buckets for hash table.
	USHORT		iRecordSize;			// Size of fixed portion of one record,
										//	includes header and null bitmask size.
	USHORT		fFlags;					// TABLEDEFF_values
	COLUMNDEF	rgColumns[1];			// First column in list of columns.
};

enum
{
	TABLEDEFF_TEMPTABLE		= 0x01,		// Table is temporary only.
	TABLEDEFF_DELETEIFEMPTY	= 0x02,		// Delete table on Save if empty.
	TABLEDEFF_PERFECTCOLS	= 0x04,		// Set if columns hash perfectly.
	TABLEDEFF_HASPKEYCOL	= 0x08,		// Has a primary key column, does
										//	not include pk index.
	TABLEDEFF_HASRIDCOL		= 0x10,		// Has a RID column.
	TABLEDEFF_CORE			= 0x20,		// Part of hard coded schema.
};

enum RECORDSTATE
{
	RECORDSTATE_NORMAL		= 0x00,		// A normal record.
	RECORDSTATE_FREE		= 0x01,		// The record is free to be reclaimed.
	RECORDSTATE_LINKED		= 0x02		// This record is a forward link to the real one.
};

//*****************************************************************************
// A RECORDID is used to uniquely find a record inside of the paging system.
// The PAGEID gives you the page the record lives on, and the iIndex gives
// you the tuple offset indicator on that page.  Dereferencing the offset
// value gives you the exact byte location of the record on the page.
//*****************************************************************************
struct RECORDID_STRUCT
{
	PAGEID		sPageID;				// Page the record lives on.
	USHORT		iIndex;					// Index of the offset locator.
};
typedef ULONG RECORDID;
typedef RECORDID & REFRECORID;
const RECORDID LAST_RECORD = 0xffffffff;

inline PAGEID PageFromRecordID(RECORDID RecordID)
	{ return (*((PAGEID *) &RecordID + 1)); }

inline USHORT IndexFromRecordID(RECORDID RecordID)
	{ return (*((USHORT *) &RecordID)); }

inline RECORDID RecordIDFromPage(PAGEID sPageID, USHORT iIndex)
{ 
	RECORDID	RecordID;
	*(USHORT *) &RecordID = iIndex;
	*((USHORT *) &RecordID + 1) = sPageID;
	return (RecordID);
}

//*****************************************************************************
// Description of an actual record.
//*****************************************************************************
struct RECORDINFO
{
	BYTE		rgNull[4];				// Start of NULL bitmask.
};


//*****************************************************************************
// Every record starts with one of these structs in the persistent store.  If
// the record is a forward link, then use RecordID to find the next link (there
// may be n links before the real record).  If it is a real record, then it
// will have data about the record instance in sRecordInfo.  Fixed record data
// always comes after the header and NULL bitmask.  An offset array of variable
// record data then follows, finally followed by the actual data.
//*****************************************************************************
struct RECORDHDR
{
	RECORDID	RecordID;				// This record's ID.
	USHORT		fFlags;					// Describes state of this record.
	USHORT		iRecordSize;			// How large is the total record.
	union
	{
		RECORDID	RecordID;			// Forward locator for RECORDSTATE_LINKED and _FREE.
		RECORDINFO	sRecordInfo;		// Data for a real record.
	} uRecordData;
};



//*****************************************************************************
// Defines and helpers for hashing indexes.
//*****************************************************************************
typedef RECORDID HASHID;
const HASH_END_MARKER = 0xffffffff;

inline PAGEID PageFromHashID(HASHID HashID)
	{ return (*((PAGEID *) &HashID + 1)); }

inline USHORT IndexFromHashID(HASHID HashID)
	{ return (*((USHORT *) &HashID)); }

inline RECORDID HashIDFromPage(PAGEID sPageID, USHORT iIndex)
{ 
	HASHID	HashID;
	*(USHORT *) &HashID = iIndex;
	*((USHORT *) &HashID + 1) = sPageID;
	return (HashID);
}


//*****************************************************************************
// A hash record is used to track one data record inside of a hash chain.
//*****************************************************************************
struct HASHRECORD
{
	HASHID		HashID;					// Hash ID of this entry.
	ULONG		iHashVal;				// The hash key.
	RECORDID	RecordID;				// The real data record, set to -1 in
										//	special case where bucket is empty.
	HASHID		PrevHashID;				// Previous hash record.
	HASHID		NextHashID;				// Next hash record.
};


//*****************************************************************************
// This struct is at the front of an index page.
//*****************************************************************************
struct INDEXHEADER
{
	HASHID		FreeHashID;				// First free ID on this page.
	USHORT		iFreeEntries;			// How many free entries on this page.
	USHORT		Pad;
};


#endif // __PageDef_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\peparse.c ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#if defined(UNDER_CE)
#include <windows.h>

HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData)
	{ return E_NOTIMPL; }
HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData)
	{ return E_NOTIMPL; }

#else

#pragma warning (disable : 4121) // ntkxapi.h(59) alignment warning
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <CorHdr.h>
#pragma warning (default : 4121)

static const char g_szCORMETA[] = ".cormeta";

// Following structure is copied from cor.h
#define IMAGE_DIRECTORY_ENTRY_COMHEADER 	14

// This header was used for betas but never shipped.
typedef struct _BETA_COR_HEADER
{
	DWORD		Flags;								// Reserved, set to 0.
	DWORD		EntryPointMetaTK;					// Reserved, set to 0.
	USHORT		RuntimeVersion; 					// Set to COR_VERSION.
	USHORT		Directories;						// Count of directories to follow,
													//	 see IMAGE_CEE_NUMBEROF_DIRECTORY_ENTRIES.
	IMAGE_DATA_DIRECTORY	MetaData;				// Location of meta data from IMetaDataRegEmit.
} BETA_COR_HEADER;


// Following two functions lifted from NT sources, imagedir.c
PIMAGE_SECTION_HEADER
Cor_RtlImageRvaToSection(
	IN PIMAGE_NT_HEADERS NtHeaders,
	IN PVOID Base,
	IN ULONG Rva
	)

/*++

Routine Description:

	This function locates an RVA within the image header of a file
	that is mapped as a file and returns a pointer to the section
	table entry for that virtual address

Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Base - Supplies the base of the image or data file.  The image
		was mapped as a data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

	NULL - The RVA was not found within any of the sections of the image.

	NON-NULL - Returns the pointer to the image section that contains
			   the RVA

--*/

{
	ULONG i;
	PIMAGE_SECTION_HEADER NtSection;

	NtSection = IMAGE_FIRST_SECTION( NtHeaders );
	for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
		if (Rva >= NtSection->VirtualAddress &&
			Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
		   ) {
			return NtSection;
			}
		++NtSection;
		}

	return NULL;
}



PVOID
Cor_RtlImageRvaToVa(
	IN PIMAGE_NT_HEADERS NtHeaders,
	IN PVOID Base,
	IN ULONG Rva,
	IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
	)

/*++

Routine Description:

	This function locates an RVA within the image header of a file that
	is mapped as a file and returns the virtual addrees of the
	corresponding byte in the file.


Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Base - Supplies the base of the image or data file.  The image
		was mapped as a data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

	LastRvaSection - Optional parameter that if specified, points
		to a variable that contains the last section value used for
		the specified image to translate and RVA to a VA.

Return Value:

	NULL - The file does not contain the specified RVA

	NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
	PIMAGE_SECTION_HEADER NtSection;

	if (!ARGUMENT_PRESENT( LastRvaSection ) ||
		(NtSection = *LastRvaSection) == NULL ||
		Rva < NtSection->VirtualAddress ||
		Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
	   ) {
		NtSection = Cor_RtlImageRvaToSection( NtHeaders,
										  Base,
										  Rva
										);
		}

	if (NtSection != NULL) {
		if (LastRvaSection != NULL) {
			*LastRvaSection = NtSection;
			}

		return (PVOID)((PCHAR)Base +
					   (Rva - NtSection->VirtualAddress) +
					   NtSection->PointerToRawData
					  );
		}
	else {
		return NULL;
		}
}

HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData)
{
	BETA_COR_HEADER 		*pCorBetaHeader;
	IMAGE_COR_HEADER		*pCorHeader;
	PIMAGE_NT_HEADERS		pImageHeader;
	PIMAGE_SECTION_HEADER	pSectionHeader;

	pImageHeader = RtlpImageNtHeader(pImage);

	pSectionHeader = Cor_RtlImageRvaToVa(pImageHeader, pImage, 
		pImageHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
		NULL);
	if (pSectionHeader)
	{
		// Check for a size which would indicate the retail header.
		DWORD dw = *(DWORD *) pSectionHeader;
		if (dw == sizeof(IMAGE_COR_HEADER) || dw == sizeof(IMAGE_COR20_HEADER))
		{
			pCorHeader = (IMAGE_COR_HEADER *) pSectionHeader;
			*ppMetaData = Cor_RtlImageRvaToVa(pImageHeader, pImage,
					pCorHeader->MetaData.VirtualAddress, NULL);
			*pcbMetaData = pCorHeader->MetaData.Size;
		}
		else
		{
			pCorBetaHeader = (BETA_COR_HEADER *) pSectionHeader;
			*ppMetaData = Cor_RtlImageRvaToVa(pImageHeader, pImage,
					pCorBetaHeader->MetaData.VirtualAddress, NULL);
			*pcbMetaData = pCorBetaHeader->MetaData.Size;
		}
	}
	else
	{
		*ppMetaData = NULL;
		*pcbMetaData = 0;
	}

	if (*ppMetaData == NULL || *pcbMetaData == 0)
		return (E_FAIL);
	return (S_OK);
}


HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData)
{
	IMAGE_FILE_HEADER *pImageHdr;		// Header for the .obj file.
	IMAGE_SECTION_HEADER *pSectionHdr;	// Section header.
	WORD		i;						// Loop control.

	// Get a pointer to the header and the first section.
	pImageHdr = (IMAGE_FILE_HEADER *) pImage;
	pSectionHdr = (IMAGE_SECTION_HEADER *)(pImageHdr + 1);

	// Avoid confusion.
	*ppMetaData = NULL;
	*pcbMetaData = 0;

	// Walk each section looking for .cormeta.
	for (i=0;  i<pImageHdr->NumberOfSections;  i++, pSectionHdr++)
	{
		// Simple comparison to section name.
		if (strcmp((const char *) pSectionHdr->Name, g_szCORMETA) == 0)
		{
			*pcbMetaData = pSectionHdr->SizeOfRawData;
			*ppMetaData = (void *) ((UINT_PTR) pImage + pSectionHdr->PointerToRawData);
			break;
		}
	}

	// Check for errors.
	if (*ppMetaData == NULL || *pcbMetaData == 0)
		return (E_FAIL);
	return (S_OK);
}

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\recordheap.h ===
//*****************************************************************************
// RecordHeap.h
//
// This module contains code to manage a heap of records for use in each table.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#pragma once



//*****************************************************************************
// The set of records in a table are managed using a linked list of heaps of
// records.  Each heap contains the next set of records for the table.  The
// memory for each heap is managed separately, and can come from different
// sources.
//*****************************************************************************
struct RECORDHEAP
{
	VMStructArray VMArray;
	RECORDHEAP	*pNextHeap;				// Pointer to the next heap.

	RECORDHEAP()
	{
		pNextHeap = 0;
	}

	~RECORDHEAP()
	{
		VMArray.Clear();
	}


//*****************************************************************************
// Sum the records in each heap and return that total sum of all records.
//*****************************************************************************
	inline ULONG Count()
	{
		RECORDHEAP *pHeap;
		ULONG		Count=0;
		for (pHeap=this;  pHeap;  pHeap=pHeap->pNextHeap)
			Count += pHeap->VMArray.Count();
		return (Count);
	}


//*****************************************************************************
// Get a pointer to the 0-based record in the heap.  This requires walking
// the list of heaps to find the correct record.
//*****************************************************************************
	STGRECORDHDR *GetRecordByIndex(ULONG Index);

//*****************************************************************************
// Walk the record heaps looking for the given record and return its index.
//*****************************************************************************
	ULONG IndexForRecord(const STGRECORDHDR *pRecord);


//*****************************************************************************
// This function walks every record heap looking for the one that contains
// the record passed in.
//*****************************************************************************
	ULONG GetHeapForRecord(					// 0 based record index on success.
		STGRECORDHDR *psRecord,				// The record to find.
		RECORDHEAP	*&pRecordHeap);			// First heap to search from.


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdatabasei.h ===
//*****************************************************************************
// StgDatabasei.h
//
// This module contains helper code and classes for StgDatabase.  It is in this
// module to reduce clutter in the main interface.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __StgDatabasei_h__
#define __StgDatabasei_h__

#include "Tigger.h"						// Macros for tables.


// Helper class for sorting a list of schema names.
class SortNames : public CQuickSort<LPCWSTR>
{
public:
	SortNames(LPCWSTR rg[], int iCount) :
		CQuickSort<LPCWSTR>(rg, iCount) { }

	int Compare(LPCWSTR *psz1, LPCWSTR *psz2)
	{ return (SchemaNameCmp(*psz1, *psz2)); }
};

#endif // __StgDatabasei_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdatabase.cpp ===
//*****************************************************************************
// StgDatabase.cpp
//
// The database is used for storing relation table information.  The database
// manages one or more open tables, a string pool, and a binary string pool.
// The data itself is in turn managed by a record manager, index manager, and
// all of the I/O is then managed by the page manager.	This module contains
// the top most interface for consumers of a database, including the ability
// to create, delete, and open tables.
//
// Locking is done with a critical section for the entire StgDatabase and all
// contained classes, such as record manager and index manager.  The one
// exception is IComponentRecords which is not locked since the object layer
// is already serializing calls.  The only hole left is a client who calls
// through the object layer and OLE DB at the sime time.  By design.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#pragma warning(disable : 4652)
#include "stdafx.h" 					// Standard includes.
#include "Complib.h"					// Public enums and defines.
#include "Errors.h" 					// Errors.
#include "OleDBUtil.h"					// Helper functions.
#include "StgDatabase.h"				// Database definitions.
#include "StgRecordManager.h"			// Record manager code.
#include "StgIO.h"						// Raw Input/output.
#include "StgTiggerStorage.h"			// Storage based i/o.
#include "StgSchema.h"					// Core schema defs.
#include "DBSchema.h"					// Core table defs.


//@todo: these are here only to get the PDC demo working on Sphinx.
#ifdef __PDC_Sphinx_Hack__
CORCLBIMPORT DBTYPE GetSafeSphinxType(DBTYPE dbType)
{
	// Sphinx currently can not handle unsigned data types.  Need to return 
	// them as signed values to get PDC demo working.
	switch (dbType)
	{
		case DBTYPE_UI2:
		return (DBTYPE_I2);

		case DBTYPE_UI4:
		return (DBTYPE_I4);

		case DBTYPE_I8:
		case DBTYPE_UI8:
		return (DBTYPE_I4);
	}
	return (dbType);
}
#endif


//****** Local prototypes. ****************************************************
HRESULT GetFileTypeForPath(StgIO *pStgIO, FILETYPE *piType);
HRESULT GetFileTypeForPathExt(StgIO *pStgIO, FILETYPE *piType);
int IsNTPEImage(StgIO *pStgIO);




//********** Code. ************************************************************


//*****************************************************************************
// This function will return a StgDatabase instance to an external client which
// must be in the same process.
//*****************************************************************************
CORCLBIMPORT HRESULT GetStgDatabase(StgDatabase **ppDB)
{
	if ((*ppDB = new StgDatabase) == 0)
		return (PostError(OutOfMemory()));
	
	_ASSERTE(SUCCEEDED(_DbgAddDatabase(*ppDB)));
	return (S_OK);
}

CORCLBIMPORT void DestroyStgDatabase(StgDatabase *pDB)
{
	_ASSERTE(SUCCEEDED(_DbgFreeDatabase(pDB)));
	delete pDB;
}


//*****************************************************************************
// This function can be called by the OLE DB layer to free data from the
// correct heap.
//*****************************************************************************
CORCLBIMPORT void ClearList(CStructArray *pList)
{
	_ASSERTE(pList);
	pList->Clear();
}



//*****************************************************************************
// ctor/dtor
//*****************************************************************************

StgDatabase::StgDatabase() :
	m_pStorage(0),
	m_fFlags(0),
	m_bEnforceDeleteOnEmpty(true),
	m_cRef(1),
	m_iNextOid(OID_INTERNAL),
	m_pTableHash(0),
	m_pStreamList(0),
	m_pHandler(0),
	m_pMapper(0)
{ 
	*m_rcDatabase = '\0';
	DEBUG_STMT(m_dbgcbSaveSize = 0xffffffff);
	m_bPoolsOrganized = false;

	m_pfnHash = GetPersistHashMethod(-1);
	m_rgSchemaList = 0;
	m_iSchemas = 0;
}


StgDatabase::~StgDatabase()
{
	Close();
}



//*****************************************************************************
// Indicates if database has changed and is therefore dirty.
//*****************************************************************************
HRESULT StgDatabase::IsDirty()			// true if database is changed.
{
	// Enforce thread safety for database.
	AUTO_CRIT_LOCK(GetLock());

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// If we are not in write mode, it can't possibly be dirty.
	if ((m_fFlags & SD_WRITE) == 0)
		return (S_FALSE);

	// Check the heaps to see if they are dirty.
	SCHEMADEFS *pSchemaDef;
	for (int i=0;  i<m_Schemas.Count();  i++)
	{
		if ((pSchemaDef = m_Schemas.Get(i)) != 0)
			if (pSchemaDef->IsDirty())
				return (S_OK);
	}

	// Ask each table if it is dirty.
	STGOPENTABLE *pOpenTable;
	for (pOpenTable=m_TableHeap.GetHead();	pOpenTable;
				pOpenTable=m_TableHeap.GetNext(pOpenTable))
	{
		if (pOpenTable->RecordMgr.GetTableDef()->IsTempTable() &&
				pOpenTable->RecordMgr.IsDirty())
			return (S_OK);
	}
	return (S_FALSE);
}


//*****************************************************************************
// Turn off dirty flag for this entire database.
//*****************************************************************************
void StgDatabase::SetDirty(
	bool		bDirty) 				// true if dirty, false otherwise.
{
	// Enforce thread safety for database.
	AUTO_CRIT_LOCK(GetLock());

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Clear all schemas dirty state.
	SCHEMADEFS *pSchemaDef;
	for (int i=0;  i<m_Schemas.Count();  i++)
	{
		if ((pSchemaDef = m_Schemas.Get(i)) != 0)
			pSchemaDef->SetDirty(bDirty);
	}

	// Tell each table its dirty state.
	STGOPENTABLE *pOpenTable;
	for (pOpenTable=m_TableHeap.GetHead();	pOpenTable;
			pOpenTable=m_TableHeap.GetNext(pOpenTable))
	{
		if (pOpenTable->RecordMgr.IsOpen())
			pOpenTable->RecordMgr.SetDirty(bDirty);
	}
}




//*****************************************************************************
// Return the shared heap allocator.  A copy is cached in this class to make
// subsequent requests faster.
//*****************************************************************************
HRESULT StgDatabase::GetIMalloc(		// Return code.
	IMalloc 	**ppIMalloc)			// Return pointer on success.
{
#if defined(UNDER_CE)
	// Under CE we don't support OLEDB or IMalloc.
	return (E_NOTIMPL);
#else
	HRESULT 	hr;

	// If we don't have the pointer yet, get one.
	if ((IMalloc *) m_pIMalloc == 0)
	{
		hr = CoGetMalloc(1, &m_pIMalloc);
		if (FAILED(hr))
			return (hr);
	}

	// Give addref'd copy to caller.
	*ppIMalloc = m_pIMalloc;
	(*ppIMalloc)->AddRef();
	return (S_OK);
#endif
}


//*****************************************************************************
// Align all columns in the table for safe in memory access.  This means
// sorting descending by fixed data types, and ascending by variable data
// types, with the small parts of each meeting in the middle.  Then apply 
// proper byte alignment to each column as required.
//*****************************************************************************
HRESULT StgDatabase::AlignTable(		// Return code.
	STGTABLEDEF *pTableDef) 			// The table to align.
{
	ALIGNCOLS	*rgAlignData;			// For alignment of table.
	int 		iCols;					// Columns we store.
	USHORT		iOffset = 0;			// For layout of records.
	USHORT		iSize;					// For alignment.

	// Put all columns into a sort list and then sort them according to alignment rules.
	VERIFY(rgAlignData = (ALIGNCOLS *) _alloca(sizeof(ALIGNCOLS) * pTableDef->iColumns));
	CAlignColumns::AddColumns(rgAlignData, pTableDef, &iCols);
	CAlignColumns sSort(rgAlignData, iCols);
	sSort.Sort();

	// Walk each entry and apply alignment accordingly.
	for (int i=0;  i<iCols;  i++)
	{
		// Get the size of the current item.
		if (IsNonPooledType(rgAlignData[i].uData.pColDef->iType))
			iSize = rgAlignData[i].uData.pColDef->iSize;
		else
			iSize = sizeof(ULONG);

		// Ensure the current offset is naturally aligned for this type.
		if ((iOffset % iSize) != 0)
			iOffset = ALIGN4BYTE(iOffset);

		// The current column gets the current offset.
		rgAlignData[i].uData.pColDef->iOffset = iOffset;

		// Move the offset over this data.
		iOffset += iSize;
	}

	// Save off the size of the record.
	if (pTableDef->iNullBitmaskCols)
	{
		pTableDef->iNullOffset = iOffset;
		iOffset += DWORDSFORBITS(pTableDef->iNullBitmaskCols);
	}
	pTableDef->iRecordSize = iOffset;
	return (S_OK);
}


HRESULT GetFileTypeForPath(StgIO *pStgIO, FILETYPE *piType)
{
	LPCWSTR 	szDatabase = pStgIO->GetFileName();
	ULONG		lSignature;
	HRESULT 	hr;
	
	// Assume native file.
	*piType = FILETYPE_CLB;

	// Need to read signature to see what type it is.
	if (!(pStgIO->GetFlags() & DBPROP_TMODEF_CREATE))
	{
		if (FAILED(hr = pStgIO->Read(&lSignature, sizeof(ULONG), 0)) ||
			FAILED(hr = pStgIO->Seek(0, FILE_BEGIN)))
		{
			return (hr);
		}

		if (lSignature == STORAGE_MAGIC_SIG)
			*piType = FILETYPE_CLB;
		else if ((WORD) lSignature == IMAGE_DOS_SIGNATURE && IsNTPEImage(pStgIO))
			*piType = FILETYPE_NTPE;
		else if (!GetFileTypeForPathExt(pStgIO, piType))
			return (PostError(CLDB_E_FILE_CORRUPT));
	}
	return (S_OK);
}


HRESULT GetFileTypeForPathExt(StgIO *pStgIO, FILETYPE *piType)
{
	LPCWSTR 	szPath;
	
	// Avoid confusion.
	*piType = FILETYPE_UNKNOWN;

	// If there is a path given, we can default to checking type.
	szPath = pStgIO->GetFileName();
	if (szPath && *szPath)
	{
#ifdef UNDER_CE
		WCHAR *rcExt = wcsrchr(szPath,L'.');
		if (rcExt == NULL)
			return FALSE;
#else // UNDER_CE
		WCHAR		rcExt[_MAX_PATH];
		SplitPath(szPath, 0, 0, 0, rcExt);
#endif
		if (_wcsicmp(rcExt, L".obj") == 0)
			*piType = FILETYPE_NTOBJ;

	}

	// All file types except .obj have a signature built in.  You should
	// not get to this code for those file types unless that file is corrupt,
	// or someone has changed a format without updating this code.
	_ASSERTE(*piType == FILETYPE_UNKNOWN || *piType == FILETYPE_NTOBJ || *piType == FILETYPE_TLB);

	// If we found a type, then you're ok.
	return (*piType != FILETYPE_UNKNOWN);
}




//*****************************************************************************
// Checks the given storage object to see if it is an NT PE image.
//*****************************************************************************
int IsNTPEImage(						// true if file is NT PE image.
	StgIO		*pStgIO)				// Storage object.
{
	LONG		lfanew; 				// Offset in DOS header to NT header.
	ULONG		lSignature; 			// For NT header signature.
	HRESULT 	hr;
	
	// Read DOS header to find the NT header offset.
	if (FAILED(hr = pStgIO->Seek(60, FILE_BEGIN)) ||
		FAILED(hr = pStgIO->Read(&lfanew, sizeof(LONG), 0)))
	{
		return (false);
	}

	// Seek to the NT header and read the signature.
	if (FAILED(hr = pStgIO->Seek(lfanew, FILE_BEGIN)) ||
		FAILED(hr = pStgIO->Read(&lSignature, sizeof(ULONG), 0)) ||
		FAILED(hr = pStgIO->Seek(0, FILE_BEGIN)))
	{
		return (false);
	}

	// If the signature is a match, then we have a PE format.
	if (lSignature == IMAGE_NT_SIGNATURE)
		return (true);
	else
		return (false);
}



//*****************************************************************************
// Code to dump the size of various items.
//*****************************************************************************
ULONG StgDatabase::PrintSizeInfo(bool verbose)
{ 
#if defined(_TRACE_SIZE)
	ULONG total; 
	total = m_pStorage->PrintSizeInfo(verbose);
	total += m_UserSchema.StringPool.PrintSizeInfo(verbose);
	total += m_UserSchema.BlobPool.PrintSizeInfo(verbose);
	total += m_UserSchema.VariantPool.PrintSizeInfo(verbose);
	total += m_UserSchema.GuidPool.PrintSizeInfo(verbose);
	printf("schemas: %d\n",m_Schemas.Count());
	return total;
#else
	return 0;
#endif
}



//*****************************************************************************
// Rotate hash method ignores type and rotates in each byte for a hash.
//*****************************************************************************
ULONG RotateHash(ULONG iHash, DBTYPE dbType, const BYTE *pbData, ULONG cbData, BOOL bCaseInsensitive)
{
	ULONG		j;						// Loop control.
	long		iHashVal = (long) iHash;

	// Walk each byte in the key and add it to the hash.
	for (j=0;  j<cbData;  j++, pbData++)
	{
		RotateLong(iHashVal);
		iHashVal += *pbData;
	}
	return (iHashVal);
}


//*****************************************************************************
// This version does some per type hash optmizations, and uses the table driven
// hash code for better distribution.
//*****************************************************************************
ULONG TableHash(ULONG iHash, DBTYPE dbType, const BYTE *pbData, ULONG cbData, BOOL bCaseInsensitive)
{
	// The first 4 bytes of a GUID is the part that changes all the time, so
	// simply use the value.  OID's are always incremental and therefore
	// naturally good for hashing.
	// For unicode string, using the charater based Hash methods implemented in utilcode.h.  
	if ( dbType == DBTYPE_WSTR )
	{
		if ( bCaseInsensitive )
			return (iHash + HashiString( (LPWSTR)pbData ) );
		else
			return (iHash + HashString( (LPWSTR)pbData ) );
	}
	else if (dbType == DBTYPE_GUID)
		return (iHash + (*(ULONG *) pbData));
	else if (dbType == DBTYPE_OID)
	{
		if (cbData == sizeof(USHORT))
			return (iHash + (*(USHORT *) pbData));
		else
			return (iHash + (*(ULONG *) pbData));
	}
	

	// Fall back on  shifting hash.
	ULONG	hash = 5381;

	while (cbData > 0)
	{
		--cbData;
		hash = ((hash << 5) + hash) ^ *pbData;
		++pbData;
	}
	
	return (iHash + hash);
}


//*****************************************************************************
// Return based on a table a hash function.
//*****************************************************************************
static const PFN_HASH_PERSIST g_rgHashPersistFuncs[] =
{
	RotateHash, 
	TableHash
};

PFN_HASH_PERSIST GetPersistHashMethod(int Index)
{
	_ASSERTE(Index == -1 || Index < NumItems(g_rgHashPersistFuncs));
	if (Index == -1)
		Index = NumItems(g_rgHashPersistFuncs) - 1;
	return (g_rgHashPersistFuncs[Index]);
}

int GetPersistHashIndex(PFN_HASH_PERSIST pfn)
{
	for (int i=NumItems(g_rgHashPersistFuncs) - 1;  i>=0;  i--)
		if (g_rgHashPersistFuncs[i] == pfn)
			return (i);
	_ASSERTE(0);
	return (0);
}






//*****************************************************************************
// Storage for global constant values.
//*****************************************************************************
extern "C"
{
static const DBCOMPAREOP		g_rgCompareEq[] 	= { DBCOMPAREOPS_EQ };

static const DBTYPE 			g_rgDBTypeOID[] 	= { DBTYPE_OID };

static const ULONG				g_rgcbSizeByte[]	= { sizeof(BYTE) };
static const ULONG				g_rgcbSizeShort[]	= { sizeof(short) };
static const ULONG				g_rgcbSizeLong[]	= { sizeof(long) };
static const ULONG				g_rgcbSizeLongLong[]= { sizeof(__int64) };

}


//*****************************************************************************
// Debug helper code for tracking leaks, tracing, etc.
//*****************************************************************************
#ifdef _DEBUG

static _DBG_DB_ITEM *g_pHeadDB = 0; 	// First list in debug.
static long 	g_iDbgAlloc = 0;		// Track allocation number.
static long 	g_iDbgBreakAlloc = 0;	// Set this value to force a break.
static RTSemExclusive g_DbgDBLock;		// Lock for leak list.

HRESULT _DbgAddDatabase(StgDatabase *pdb)
{
	CLock sLock(&g_DbgDBLock);
	_DBG_DB_ITEM *pItem;

	// Check if this is the allocation for debugging.  Set g_iDbgBreakAlloc
	// in the debugger to catch memory leaks.
	_ASSERTE(g_iDbgBreakAlloc != g_iDbgAlloc + 1);

	pItem = new _DBG_DB_ITEM;
	if (!pItem)
		return (OutOfMemory());
	pItem->pdb = pdb;
	pItem->iAlloc = ++g_iDbgAlloc;
	pItem->pNext = g_pHeadDB;
	g_pHeadDB = pItem;
	return (S_OK);
}


// Search for the node which owns this pointer and delete it.
HRESULT _DbgFreeDatabase(StgDatabase *pdb)
{
	CLock sLock(&g_DbgDBLock);
	_DBG_DB_ITEM **ppLast, *pItem;

	for (ppLast = &g_pHeadDB, pItem = g_pHeadDB;  pItem;  )
	{
		if (pItem->pdb == pdb)
		{
			*ppLast = pItem->pNext;
			delete pItem;
			return (S_OK);
		}
		else
		{
			ppLast = &(pItem->pNext);
			pItem = *ppLast;
		}
	}
	_ASSERTE(!"Failed to find pointer to delete from list!");
	return (E_FAIL);
}


//@Todo: this is an m3 hack to avoid giving errors for com interop.
extern "C" int		g_bMetaDataLeakDetect = true;
extern int			g_bDumpMemoryLeaks;

int _DbgValidateList()					// true if everything is ok.
{
	CLock sLock(&g_DbgDBLock);

	// If this assert fires, it means that a Meta Data database (a complib or .clb)
	// has been leaked by the program.	These database objects are created through
	// either:
	//	(1) The IMetaData*::OpenScope or ::DefineScope methods used for
	//			symbol table data.
	//	(2) The IInternalMetaData* API's.
	//	(3) Calling one of the Open/CreateComponentLibraryEx functions.
	//	(4) Creating an OLE DB DataSource/Session object which is never freed.
	// Consult your API's documentation for how to fix this leak.  It will almost
	// assuredly be a leaked interface poniter or scope object.
	_ASSERTE(g_bMetaDataLeakDetect == false || g_bDumpMemoryLeaks == false || g_pHeadDB == 0);
	return (g_pHeadDB == 0);
}

long _DbgSetBreakAlloc(long iAlloc)
{
	CLock sLock(&g_DbgDBLock);

	long		iTemp = g_iDbgBreakAlloc;
	g_iDbgBreakAlloc = iAlloc;
	return (iTemp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdbclassfile.h ===
//*****************************************************************************
// StgDBClassFile.h
//
// These are helper functions used by the .class file import and export code.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once


// Forward.
struct Full_Member;


//*****************************************************************************
// Used to cache auto generated name and type values.
//*****************************************************************************
struct NAME_AND_TYPE
{
	OID			name_index;				// ID of name object.
	OID			descriptor_index;		// ID of descriptor object.
};
typedef CDynArray<NAME_AND_TYPE> NAMETYPELIST;



//*****************************************************************************
// This little helper class will keep a list of members sorted by name and signature.
//*****************************************************************************

struct Sort_Member
{
	ULONG		Name;
	ULONG		Signature;
};


class MEMBERLIST : public CDynArray<Sort_Member *>
{
public:
	void Sort();
	Sort_Member *Find(OID Name, OID Signature);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdatabase.h ===
//*****************************************************************************
// StgDatabase.h
//
// The database is used for storing relation table information.  The database
// manages one or more open tables, a string pool, and a binary string pool.
// The data itself is in turn managed by a record manager, index manager, and
// all of the I/O is then managed by the page manager.  This module contains
// the top most interface for consumers of a database, including the ability
// to create, delete, and open tables.
//
// Locking is done with a critical section for the entire StgDatabase and all
// contained classes, such as record manager and index manager.  The one
// exception is IComponentRecords which is not locked since the object layer
// is already serializing calls.  The only hole left is a client who calls
// through the object layer and OLE DB at the sime time.  By design.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __StgDatabase_h__
#define __StgDatabase_h__

// Forwards.
class StgDatabase;
class PageDump;
class CStructDump;
class StgRecordManager;
class StgIndexManager;
class StgIO;
class CSimpleTable;
interface ISimpleTable;
struct CLASS_TABLES;
class CMiniMdCreate;
class TokenMapper;
class CorMetaDataScope;

#include <complib.h>
#include "StgApi.h"                     // Helper defines.
#define __MSCORCLB_CODE__
#include <icmprecs.h>                   // ICR interface.
#include "StgOpenTable.h"               // Open table list structures.

#include "UTSem.h"                      // Lock access.
#include "StgDef.h"                     // Storage struct definitions.
#include "StgPool.h"                    // String and blob pool code.
#include "StgDatabasei.h"               // Internal helpers.
#include "StgDBClassFile.h"             
#include "StgSchema.h"                  // Schema related definitions.
#include "StgUserSection.h"             // User managed sections.
#include "StgConstantData.h"            // Useful constant data values.
#include "StgTiggerStorage.h"           // Tigger storage mechanism

// For some reason this doesn't come in from stdlib
extern "C" _CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);

#if defined(_TRACE_SIZE)
#include "StgTraceSize.h"
#endif


#define SCHEMA_STREAM           L"#Schema"
#define STRING_POOL_STREAM      L"#Strings"
#define BLOB_POOL_STREAM        L"#Blob"
#define VARIANT_POOL_STREAM     L"#Variants"
#define GUID_POOL_STREAM        L"#GUID"
#define COMPRESSED_MODEL_STREAM L"#~"

// This macro figures out the minimum required BYTEs that are required to 
// represent each columns NULL status.
inline int BytesForColumns(int iColumns)
{
    return (int)((iColumns / (sizeof(BYTE) * 8) + 
                 (iColumns % (sizeof(BYTE) * 8) != 0 ? 1 : 0)));
}


// How many DWORDs required to represent iCount bits.
#define DWORDSFORBITS(iBits) (((iBits - 1) & ~(sizeof(DWORD) - 1)) + sizeof(DWORD))


// NT signature values.
#ifndef IMAGE_DOS_SIGNATURE
#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#endif

#ifndef IMAGE_NT_SIGNATURE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00
#endif

#ifndef TYPELIB_SIG
#define TYPELIB_SIG_MSFT                    0x5446534D  // MSFT
#define TYPELIB_SIG_SLTG                    0x47544C53  // SLTG
#endif


// File types for the database.
enum FILETYPE
{
    FILETYPE_UNKNOWN,                   // Unknown or undefined type.
    FILETYPE_CLB,                       // Native .clb file format.
    FILETYPE_CLASS,                     // Class file format.
    FILETYPE_NTPE,                      // Windows PE executable.
    FILETYPE_NTOBJ,                     // .obj file format (with .clb embedded).
    FILETYPE_TLB                        // Typelib format.
};


enum
{
    SD_OPENED               = 0x0001,   // Database is open.
    SD_READ                 = 0x0002,   // Open for read.
    SD_WRITE                = 0x0004,   // Open for write.
    SD_CREATE               = 0x0008,   // Database is brand new.
    SD_SLOWSAVE             = 0x0010,   // Save optimized copy of data.
    SD_EXISTS               = 0x0020,   // File exists on disk.
    SD_INITDONE             = 0x1000,   // Init routine has been run.
    SD_FREESCHEMA           = 0x2000,   // Schema in malloc'd memory.
    SD_TABLEHEAP            = 0x4000    // Table heap has been allocated.
};

// Internal data type to get blob types into variants.
enum VARIANTEXTENDEDDBTYPES
    {   DBTYPE_VARIANT_BLOB = 333
    };


//*****************************************************************************
// Search structure for iterating tables.
//*****************************************************************************
struct SCHEMASRCH
{
    int         iIndex;                 // Table index.
    int         iSchema;                // Which schema so far.
    int         fFlags;                 // Search flags.
    SCHEMADEFS  *pSchemaDef;            // Current schema.

    int GetCurSchemaDex() const
    { return (iSchema - 1); }
};

enum
{
    SCHEMASRCH_NOCORE       = 0x0001,   // Don't walk core tables.
    SCHEMASRCH_NOUSER       = 0x0002,   // Don't walk user tables.
    SCHEMASRCH_NOTEMP       = 0x0004    // Don't walk temporary tables.
};


//*****************************************************************************
// This extra data is stored in the storage header instead of a full blown
// stream which has extra overhead associated with it.  The OID is used to
// implement NewOid.  The value is unique accross the entire database.  The
// schema list is used to track what schemas have been added to this database
// so that if a generic tool opens it, it can find the correct definitions
// using the schema catalog (a set of .clb files with the schema defs inside
// of them).
//*****************************************************************************
#pragma warning(disable : 4200)         // Don't care about 0 sized array.
struct STGEXTRA
{
    ULONG       fFlags;                 // Persistent header flags.
    OID         NextOid;                // Next valid OID for this db.
    BYTE        rgPad[3];               // Unused.
    BYTE        iHashFuncIndex;         // Index to hash index
    ULONG       iSchemas;               // How many are registered.
    COMPLIBSCHEMASTG rgSchemas[0];      // The start of the array.
};
#pragma warning(default : 4200)


//*****************************************************************************
// Core tables are formatted using their schema index and tableid which yields
// a much smaller name in the stream header.  The schema index is relative to
// this database, so any changes in index (say by deleting a schema) would
// require the streams on disk to be renamed accordingly.
//*****************************************************************************
inline void GetCoreTableStreamName(USHORT schemaid, USHORT tableid, LPWSTR szName, int iMax)
{
    _ASSERTE(tableid != 0xffff && szName && iMax >= 4);

    // The following code logically does the same as the swprintf(), without calling swprintf(),
    // which brings in all sorts of CRT crud we don't want
    // swprintf(szName, L"%u_%u", (ULONG) schemaid, (ULONG) tableid);

    char szTempBuf[32];
    char *pSrc;

    _ultoa((ULONG) schemaid, szTempBuf, 10);
    strcat(szTempBuf, "_");
    _ultoa((ULONG) tableid, &szTempBuf[strlen(szTempBuf)], 10);

    pSrc = szTempBuf;

    do
    {
    } while ((*szName++ = *pSrc++) != '\0');
}


//*****************************************************************************
// Support for hashing of persisted data.
//*****************************************************************************
PFN_HASH_PERSIST GetPersistHashMethod(int Index);
int GetPersistHashIndex(PFN_HASH_PERSIST pfn);

ULONG RotateHash(ULONG iHash, DBTYPE dbType, const BYTE *pbData, ULONG cbData);
ULONG TableHash(ULONG iHash, DBTYPE dbType, const BYTE *pbData, ULONG cbData);


//*****************************************************************************
// This function will return a StgDatabase instance to an external client which
// must be in the same process.
//*****************************************************************************
CORCLBIMPORT HRESULT GetStgDatabase(StgDatabase **ppDB);
CORCLBIMPORT void DestroyStgDatabase(StgDatabase *pDB);

//*****************************************************************************
// This class encapsulates the knowledge of what lives inside of a database.
// You can use it to create new tables, drop them, and open them.  This class
// owns the string and binary pools as well as all schema data.
//*****************************************************************************
class StgDatabase : public IComponentRecords, public IComponentRecordsSchema
{
friend CStructDump;
friend PageDump;
friend StgRecordManager;
friend StgIndexManager;
friend CSimpleTable;
friend CMiniMdCreate;


public:
    StgDatabase();
    ~StgDatabase();

//*****************************************************************************
// This function is called with a database to open or create.  The flags
// come in as the DBPROPMODE values which then allow this function to route
// to either Create or Open.
//*****************************************************************************
    virtual HRESULT InitDatabase(           // Return code.
        LPCWSTR     szDatabase,             // Name of database.
        ULONG       fFlags,                 // Flags to use on init.
        void        *pbData=0,              // Data to open on top of, 0 default.
        ULONG       cbData=0,               // How big is the data.
        IStream     *pIStream=0,            // Optional stream to use.
        LPCWSTR     szSharedMem=0,          // Shared memory name for read.
        LPSECURITY_ATTRIBUTES pAttributes=0); // Security token.

//*****************************************************************************
// Close the database and release all memory.
//*****************************************************************************
    virtual void Close();                   // Return code.

//*****************************************************************************
// Indicates if database has changed and is therefore dirty.
//*****************************************************************************
    virtual HRESULT IsDirty();              // S_OK if database is changed.

//*****************************************************************************
// Turn off dirty flag for this entire database.
//*****************************************************************************
    virtual void SetDirty(
        bool        bDirty);                // true if dirty, false otherwise.

//*****************************************************************************
// Allow deferred setting of save path.
//*****************************************************************************
    virtual HRESULT SetSaveFile(                    // Return code.
        LPCWSTR     szDatabase);            // Name of file.

//*****************************************************************************
// Save any changes made to the database.
//*****************************************************************************
    virtual HRESULT Save(                   // Return code.
        IStream     *pIStream=0);           // Optional override for save location.

//*****************************************************************************
// Create a new table in this database.
//*****************************************************************************
    virtual HRESULT CreateTable(            // Return code.
        LPCWSTR     szTableName,            // Name of new table to create.
        int         iColumns,               // Columns to put in table.
        COLUMNDEF   rColumnDefs[],          // Array of column definitions.
        USHORT      usFlags=0,              // Create values for flags.
        USHORT      iRecordStart=0,         // Start point for records.
        STGTABLEDEF **ppTableDef=0,         // Return new table def here.
        TABLEID     tableid=~0);            // Hard coded ID if there is one.

//*****************************************************************************
// Create a new index on the given table.
//*****************************************************************************
    virtual HRESULT CreateIndex(            // Return code.
        LPCWSTR     szTableName,            // Name of table to put index on.
        STGINDEXDEF *pInIndexDef,           // Index description.
        ULONG       iKeys,                  // How many key columns.
        const DBINDEXCOLUMNDESC rgInKeys[], // Which columns make up key.
        SCHEMADEFS  *pSchemaDefs=0,         // The schema that owns pTableDef, 0 allowed.
        STGTABLEDEF *pTableDef=0,           // Table defintion for new item, 0 allowed.
        STGCOLUMNDEF *pColDef=0);           // The column for pk, 0 allowed.

//*****************************************************************************
// Drops the given table from the list.
//*****************************************************************************
    virtual HRESULT DropTable(              // Return code.
        LPCWSTR     szTableName);           // Name of table.

//*****************************************************************************
// Opens the given table and returns a string for it.  The open table struct
// is addref'd for the caller and must be released when you are done with it.
//*****************************************************************************
    virtual HRESULT OpenTable(              // Return code.
        LPCWSTR     szTableName,            // The name of the table.
        STGOPENTABLE *&pOpenTable,          // Return opened table struct here.
        TABLEID     tableid=-1,             // Index for the table if known.
        SCHEMADEFS  *pSchemaDefs=0,         // Schema where table lives.
        int         iSchemaIndex=-1,        // Index of the schemadef if given.
        STGTABLEDEF *pTableDef=0,           // The definition of the table for open.
        ULONG       iTableDef=0,            // Which table definition is it.
        TABLEID     *pNewTableID=0,         // Return if new entry added.
        ULONG       InitialRecords=0);      // How many initial records to preallocate for
                                            //  new open of empty table, hint only.

//*****************************************************************************
// A tableid after open is turned into a pointer to the actual data structure.
// This is a very fast way to handle this 99.9% case, while allowing a call
// to the real function if needed.
//*****************************************************************************
    inline HRESULT QuickOpenTable(          // Return code.
        STGOPENTABLE *&pOpenTable,          // Return opened table struct here.
        TABLEID     tableid)                // Index for the table if known.
    {
        HRESULT     hr = S_OK;
        _ASSERTE(IsValidTableID(tableid));
        if ((UINT_PTR)tableid > 0xffff)
            pOpenTable = (STGOPENTABLE *) tableid;
        else
            hr = OpenTable(0, pOpenTable, tableid);
        return (hr);
    }

//*****************************************************************************
// Close the given table.
//*****************************************************************************
    virtual void CloseTable(
        LPCSTR      szTable);               // Table to close.


//*****************************************************************************
// Use these functions to walk the table list.  Note that you must lock down
// the database for schema changes so the pointers and counts remain valid.
// This code will not do that synchronization for you.
//*****************************************************************************
    virtual STGTABLEDEF *GetFirstTable(
        SCHEMASRCH  &sSrch,                 // Search structure.
        int         fFlags);                // Flags for the search.
    virtual STGTABLEDEF *GetNextTable(
        SCHEMASRCH  &sSrch);                // Search structure.

//*****************************************************************************
// Look for a table definition and the schema it lives in.  This will use
// the current schema list of this database from top to bottom.  Lookups by
// tableid are very fast, so give one if possible.
//
// NOTE: This function does *not* post an error, just returns a failure code.
// This allows the caller to decide if this state is fatal or not without
// faulting in the resource dll.
//*****************************************************************************
    virtual HRESULT GetTableDef(            // S_OK or DB_E_NOTABLE, never posts.
        LPCWSTR      szTable,                // Name of table to find.
        TABLEID     tableid,                // ID of table, -1 if not known.
        SCHEMADEFS  **ppSchema,             // Return owning schema here.
        STGTABLEDEF **ppTableDef,           // Return table def in schema if found.
        ULONG       *piTableDef,            // Logical offset of table def.
        int         *piSchemaDef = 0,       // Index of schema def in list.
        int         bSkipOverrides = true); // true to skip core overrides (default).

//*****************************************************************************
// Return the shared heap allocator.  A copy is cached in this class to make
// subsequent requests faster.
//*****************************************************************************
    HRESULT GetIMalloc(                     // Return code.
        IMalloc     **ppIMalloc);           // Return pointer on success.


// IUnknown:
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp);

    virtual ULONG STDMETHODCALLTYPE AddRef()
    { return (InterlockedIncrement((long *) &m_cRef)); }

    virtual ULONG STDMETHODCALLTYPE Release()
    {
        ULONG   cRef;
        if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
            DestroyStgDatabase(this);
        return (cRef);
    }
    


//
// IComponentRecords
//


//*****************************************************************************
// This version will simply tell the record manager to allocate a new (but empty)
// record and return a pointer to it.  The caller must take extreme care to set
// only fixed size values and go through helpers for everything else.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE NewRecord(// Return code.
        TABLEID     tableid,                // Which table to work with.
        void        **ppData,               // Return new record here.
        OID         _oid,                   // ID of the record.
        ULONG       iOidColumn,             // Ordinal of OID column.
        ULONG       *pRecordID);            // Optionally return the record id.

    virtual HRESULT STDMETHODCALLTYPE NewTempRecord(// Return code.
        TABLEID     tableid,                // Which table to work with.
        void        **ppData,               // Return new record here.
        OID         _oid,                   // ID of the record.
        ULONG       iOidColumn,             // Ordinal of OID column.
        ULONG       *pRecordID);            // Optionally return the record id.


//*****************************************************************************
// This function will insert a new record into the given table and set all of
// the data for the columns.  In cases where a primary key and/or unique indexes
// need to be specified, this is the only function that can be used.
//
// Please see the SetColumns function for a description of the rest of the
// parameters to this function.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE NewRecordAndData( // Return code.
        TABLEID     tableid,                // Which table to work on.
        void        **ppData,               // Return new record here.
        ULONG       *pRecordID,             // Optionally return the record id.
        int         fFlags,                 // ICR_RECORD_xxx value, 0 default.
        int         iCols,                  // number of columns
        const DBTYPE rgiType[],             // data types of the columns.
        const void  *rgpbBuf[],             // pointers to where the data will be stored.
        const ULONG cbBuf[],                // sizes of the data buffers.
        ULONG       pcbBuf[],               // size of data available to be returned.
        HRESULT     rgResult[],             // [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
        const ULONG *rgFieldMask);          // IsOrdinalList(iCols) 
                                            //  ? an array of 1 based ordinals
                                            //  : a bitmask of columns

    virtual HRESULT STDMETHODCALLTYPE GetStruct(    //Return Code
        TABLEID     tableid,                // Which table to work on.
        int         iRows,                  // number of rows for bulk fetch.
        void        *rgpRowPtr[],           // pointer to array of row pointers.
        int         cbRowStruct,            // size of <table name>_RS structure.
        void        *rgpbBuf,               // pointer to the chunk of memory where the
                                            // retrieved data will be placed.
        HRESULT     rgResult[] = NULL,      // array of HRESULT for iRows.
        ULONG       fFieldMask = -1);       // mask to specify a subset of fields.

    virtual HRESULT STDMETHODCALLTYPE SetStruct(    // Return Code
        TABLEID     tableid,                // table to work on.
        int         iRows,                  // number of Rows for bulk set.
        void        *rgpRowPtr[],           // pointer to array of row pointers.
        int         cbRowStruct,            // size of <table name>_RS struct.
        void        *rgpbBuf,               // pointer to chunk of memory to set the data from.
        HRESULT     rgResult[] = NULL,      // array of HRESULT for iRows.
        ULONG       fFieldMask = -1,        // mask to specify a subset of the fields.
        ULONG       fNullFieldMask = 0);    // fields which need to be set to NULL.

    virtual HRESULT STDMETHODCALLTYPE InsertStruct( // Return Code
        TABLEID     tableid,                // table to work on.
        int         iRows,                  // number of Rows for bulk set.
        void        *rgpRowPtr[],           // Return pointer to new values.
        int         cbRowStruct,            // size of <table name>_RS struct.
        void        *rgpbBuf,               // pointer to chunk of memory to set the data from.
        HRESULT     rgResult[] = NULL,      // array of HRESULT for iRows.
        ULONG       fFieldMask = -1,        // mask to specify a subset of the fields.
        ULONG       fNullFieldMask = 0);    // fields which need to be set to null.
    
    virtual HRESULT STDMETHODCALLTYPE GetColumns(   // Return code.
        TABLEID     tableid,                // table to work on.
        const void  *pRowPtr,               // row pointer
        int         iCols,                  // number of columns
        const DBTYPE rgiType[],             // data types of the columns.
        const void  *rgpbBuf[],             // pointers to where the data will be stored.
        ULONG       cbBuf[],                // sizes of the data buffers.
        ULONG       pcbBuf[],               // size of data available to be returned.
        HRESULT     rgResult[] = NULL,      // array of HRESULT for iCols.
        const ULONG *rgFieldMask = NULL);   // IsOrdinalList(iCols) 
                                            //  ? an array of 1 based ordinals
                                            //  : a bitmask of columns

    virtual HRESULT STDMETHODCALLTYPE SetColumns(   // Return code.
        TABLEID     tableid,                // table to work on.
        void        *pRowPtr,               // row pointer
        int         iCols,                  // number of columns
        const DBTYPE rgiType[],             // data types of the columns.
        const void  *rgpbBuf[],             // pointers to where the data will be stored.
        const ULONG cbBuf[],                // sizes of the data buffers.
        ULONG       pcbBuf[],               // size of data available to be returned.
        HRESULT     rgResult[] = NULL,      // array of HRESULT for iCols.
        const ULONG *rgFieldMask = NULL);   // IsOrdinalList(iCols) 
                                            //  ? an array of 1 based ordinals
                                            //  : a bitmask of columns

    virtual HRESULT STDMETHODCALLTYPE GetRecordCount(// Return code.
        TABLEID     tableid,                // Which table to work on.
        ULONG       *piCount);              // Not including deletes.

    virtual HRESULT STDMETHODCALLTYPE GetRowByOid(// Return code.
        TABLEID     tableid,                // Which table to work with.
        OID         _oid,                   // Value for keyed lookup.
        ULONG       iColumn,                // 1 based column number (logical).
        void        **ppStruct);            // Return pointer to record.

    virtual HRESULT STDMETHODCALLTYPE GetRowByRID(// Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       rid,                    // Record id.
        void        **ppStruct);            // Return pointer to record.

    virtual HRESULT STDMETHODCALLTYPE GetRIDForRow(// Return code.
        TABLEID     tableid,                // Which table to work with.
        const void  *pRecord,               // The record we want RID for.
        ULONG       *pirid);                // Return the RID for the given row.

//*****************************************************************************
// This function allows a faster path to find records that going through
// OLE DB.  Rows found can be returned in one of two ways:  (1) if you know
// how many should be returned, you may pass in a pointer to an array of
// record pointers, in which case rgRecords and iMaxRecords must be non 0.
// (2) If the count of records is unknown, then pass in a record list in
// pRecords and all records will be dynamically added to this list.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetRowByColumn( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pData,                 // User data.
        ULONG       cbData,                 // Size of data (blobs)
        DBTYPE      iType,                  // What type of data given.
        void        *rgRecords[],           // Return array of records here.
        int         iMaxRecords,            // Max that will fit in rgRecords.
        RECORDLIST  *pRecords,              // If variable rows desired.
        int         *piFetched);            // How many records were fetched.


//*****************************************************************************
// This query function allows you to do lookups on one or more column at a 
// time.  It does not expose the full OLE DB view-filter mechanism which is
// very flexible, but rather exposes multiple column AND conditions with
// equality.  A record must match all of the criteria to be returned to 
// in the cursor.
//
// User data - For each column, rgiColumn, rgpbData, and rgiType contain the 
//      pointer information to the user data to filter on.
//
// Query hints - Queries will run faster if it is known that some of the 
//      columns are indexed.  While there is code in the engine to scan query
//      lists for target indexes, this internal function bypasses that code in
//      favor of performance.  If you know that a column is a RID or PK, or that
//      there is an index, then these columns need to be the first set passed
//      in.  Fill out a QUERYHINT and pass this value in.  Pass NULL if you
//      know there is no index information, and the table will be scanned.
//
//      Note that you may follow indexes columns with non-indexed columns,
//      in which case all records in the index are found first, and then those
//      are scanned for the rest of the criteria.
//
// Returned cursor - Data may be returned in two mutually exclusive ways:
//      (1) Pass an array of record pointers in rgRecords and set iMaxRecords
//          to the count of this array.  Only that many rows are brought back.
//          This requires to heap allocations and is good for cases where you
//          can predict cardinality up front.
//      (2) Pass the address of a CRCURSOR to get a dynamic list.  Then use
//          the cursor functions on this interface to fetch data and close
//          the cursor.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE QueryByColumns( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
        TABLEID     tableid,                // Which table to work with.
        const QUERYHINT *pQryHint,          // What index to use, NULL valid.
        int         iColumns,               // How many columns to query on.
        const ULONG rgiColumn[],            // 1 based column numbers.
        const DBCOMPAREOP rgfCompare[],     // Comparison operators, NULL means ==.
        const void  *rgpbData[],            // User data.
        const ULONG rgcbData[],             // Size of data (blobs)
        const DBTYPE rgiType[],             // What type of data given.
        void        *rgRecords[],           // Return array of records here.
        int         iMaxRecords,            // Max that will fit in rgRecords.
        CRCURSOR    *psCursor,              // Buffer for the cursor handle.
        int         *piFetched);            // How many records were fetched.

    virtual HRESULT STDMETHODCALLTYPE OpenCursorByColumn(// Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pData,                 // User data.
        ULONG       cbData,                 // Size of data (blobs)
        DBTYPE      iType,                  // What type of data given.
        CRCURSOR    *psCursor);             // Buffer for the cursor handle.

//*****************************************************************************
// Reads the next set of records from the cursor into the given buffer.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE ReadCursor(// Return code.
        CRCURSOR    *psCursor,              // The cursor handle.
        void        *rgRecords[],           // Return array of records here.
        int         *piRecords);            // Max that will fit in rgRecords.

//*****************************************************************************
// Move the cursor location to the index given.  The next ReadCursor will start
// fetching records at that index.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE MoveTo( // Return code.
        CRCURSOR    *psCursor,              // The cursor handle.
        ULONG       iIndex);                // New index.

//*****************************************************************************
// Get the count of items in the cursor.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetCount( // Return code.
        CRCURSOR    *psCursor,              // The cursor handle.
        ULONG       *piCount);              // Return the count.

//*****************************************************************************
// Close the cursor and clean up the resources we've allocated.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE CloseCursor(// Return code.
        CRCURSOR    *psCursor);             // The cursor handle.

//*****************************************************************************
// Get functions.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetStringUtf8( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        LPCSTR      *pszOutBuffer);         // Where to put string pointer.

    virtual HRESULT STDMETHODCALLTYPE GetStringA( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        LPSTR       szOutBuffer,            // Where to write string.
        int         cchOutBuffer,           // Max size, including room for \0.
        int         *pchString);            // Size of string is put here.

    virtual HRESULT STDMETHODCALLTYPE GetStringW( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        LPWSTR      szOutBuffer,            // Where to write string.
        int         cchOutBuffer,           // Max size, including room for \0.
        int         *pchString);            // Size of string is put here.

    virtual HRESULT STDMETHODCALLTYPE GetBstr( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        BSTR        *pBstr);                // Output for bstring on success.

    virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        BYTE        *pOutBuffer,            // Where to write blob.
        ULONG       cbOutBuffer,            // Size of output buffer.
        ULONG       *pcbOutBuffer);         // Return amount of data available.

    virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        const BYTE  **ppBlob,               // Pointer to blob.
        ULONG       *pcbSize);              // Size of blob.

    virtual HRESULT STDMETHODCALLTYPE GetOid( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        OID         *poid);                 // Return id here.

    virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        VARIANT     *pValue);               // Put the variant here.

    virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        const void  **ppBlob,               // Put Pointer to blob here.
        ULONG       *pcbSize);              // Put Size of blob here.

    virtual HRESULT STDMETHODCALLTYPE GetVARIANTType( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        VARTYPE     *pType);                // Put VARTEPE here.

    virtual HRESULT STDMETHODCALLTYPE GetGuid( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        GUID        *pGuid);                // Return guid here.

    virtual HRESULT STDMETHODCALLTYPE IsNull( // S_OK yes, S_FALSE no.
        TABLEID     tableid,                // Which table to work with.
        const void  *pRecord,               // Record with data.
        ULONG       iColumn);               // 1 based column number (logical).

//*****************************************************************************
// Put functions.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE PutStringUtf8( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        LPCSTR      szString,               // String we are writing.
        int         cbBuffer);              // Bytes in string, -1 null terminated.

    virtual HRESULT STDMETHODCALLTYPE PutStringA( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        LPCSTR      szString,               // String we are writing.
        int         cbBuffer);              // Bytes in string, -1 null terminated.

    virtual HRESULT STDMETHODCALLTYPE PutStringW( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        LPCWSTR     szString,               // String we are writing.
        int         cbBuffer);              // Bytes (not characters) in string, -1 null terminated.

    virtual HRESULT STDMETHODCALLTYPE PutBlob( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        const BYTE  *pBuffer,               // User data.
        ULONG       cbBuffer);              // Size of buffer.

    virtual HRESULT STDMETHODCALLTYPE PutOid( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        OID         oid);                   // Return id here.

    virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        const VARIANT *pValue);             // The variant to write.

    virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        const void  *pBuffer,               // User data to write as a variant.
        ULONG       cbBuffer);              // Size of buffer.

    virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        VARTYPE     vt,                     // Type of data.
        const void  *pValue);               // The actual data.

    virtual HRESULT STDMETHODCALLTYPE PutGuid( // Return code.
        TABLEID     tableid,                // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        REFGUID     guid);                  // Guid to put.

    virtual void STDMETHODCALLTYPE SetNull(
        TABLEID     tableid,                // Which table to work with.
        void        *pRecord,               // Record with data.
        ULONG       iColumn);               // 1 based column number (logical).

    virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        VARIANT     *pValue);               // The variant to write.

    virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        const void  **ppBlob,               // Put Pointer to blob here.
        ULONG       *pcbSize);              // Put Size of blob here.

    virtual HRESULT STDMETHODCALLTYPE GetVARIANTType( // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        VARTYPE     *pType);                // Put VARTEPE here.

    virtual HRESULT STDMETHODCALLTYPE DeleteRowByRID(
        TABLEID     tableid,                // Which table to work with.
        ULONG       rid);                   // Record id.

    // These are place holders for the COM+ Runtime source code.
    virtual HRESULT STDMETHODCALLTYPE GetCPVARIANT( // Return code.
        USHORT      ixCP,                   // 1 based Constant Pool index.
        VARIANT     *pValue)                // Put the data here.
        { return (E_NOTIMPL); }

    virtual HRESULT STDMETHODCALLTYPE AddCPVARIANT( // Return code.
        VARIANT     *pValue,                // The variant to write.
        ULONG       *pixCP)                 // Put 1 based Constant Pool index here.
        { return (E_NOTIMPL); }


//*****************************************************************************
//
//********** File and schema functions.
//
//*****************************************************************************


//*****************************************************************************
// Add a refernece to the given schema to the database we have open right now
// You must have the database opened for write for this to work.  If this
// schema extends another schema, then that schema must have been added first
// or an error will occur.  It is not an error to add a schema when it was
// already in the database.
//
// Adding a new version of a schema to the current file is not supported in the
// '98 product.  In the future this ability will be added and will invovle a
// forced migration of the current file into the new format.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE SchemaAdd( // Return code.
        const COMPLIBSCHEMABLOB *pSchema);  // The schema to add.
    
//*****************************************************************************
// Deletes a reference to a schema from the database.  You must have opened the
// database in write mode for this to work.  An error is returned if another
// schema still exists in the file which extends the schema you are trying to
// remove.  To fix this problem remove any schemas which extend you first.
// All of the table data associated with this schema will be purged from the
// database on Save, so use this function very carefully.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE SchemaDelete( // Return code.
        const COMPLIBSCHEMABLOB *pSchema);  // The schema to add.

//*****************************************************************************
// Returns the list of schema references in the current database.  Only
// iMaxSchemas can be returned to the caller.  *piTotal tells how many were
// actually copied.  If all references schemas were returned in the space
// given, then S_OK is returned.  If there were more to return, S_FALSE is
// returned and *piTotal contains the total number of entries the database has.
// The caller may then make the array of that size and call the function again
// to get all of the entries.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE SchemaGetList( // Return code.
        int         iMaxSchemas,            // How many can rgSchema handle.
        int         *piTotal,               // Return how many we found.
        COMPLIBSCHEMADESC rgSchema[]);      // Return list here.

//*****************************************************************************
// Before you can work with a table, you must retrieve its TABLEID.  The
// TABLEID changes for each open of the database.  The ID should be retrieved
// only once per open, there is no check for a double open of a table.
// Doing multiple opens will cause unpredictable results.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE OpenTable( // Return code.
        const COMPLIBSCHEMA *pSchema,       // Schema identifier.
        ULONG       iTableNum,              // Table number to open.
        TABLEID     *pTableID);             // Return ID on successful open.


//*****************************************************************************
// Figures out how big the persisted version of the current scope would be.
// This is used by the linker to save room in the PE file format.  After
// calling this function, you may only call the SaveToStream or Save method.
// Any other function will product unpredictable results.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
        CorSaveSize fSave,                  // cssQuick or cssAccurate.
        DWORD       *pdwSaveSize);          // Return size of saved item.

    virtual HRESULT STDMETHODCALLTYPE SaveToStream(// Return code.
        IStream     *pIStream);             // Where to save the data.

    virtual HRESULT STDMETHODCALLTYPE Save( 
        LPCWSTR szFile);


//*****************************************************************************
// After a successful open, this function will return the size of the in-memory
// database being used.  This is meant to be used by code that has opened a
// shared memory database and needs the exact size to init the system.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetDBSize( // Return code.
        ULONG       *pcbSize);              // Return size on success.

//*****************************************************************************
// Call this method only after calling LightWeightClose.  This method will try
// to reaquire the shared view of a database that was given on the call to
// OpenComponentLibrarySharedEx.  If the data is no longer available, then an
// error will result and no data is valid.  If the memory cannot be loaded into
// exactly the same address range as on the open, CLDB_E_RELOCATED will be
// returned.  In either of these cases, the only valid operation is to free
// this instant of the database and redo the OpenComponentLibrarySharedEx.  There
// is no automatic relocation scheme in the engine.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE LightWeightOpen();

//*****************************************************************************
// This method will close any resources related to the file or shared memory
// which were allocated on the OpenComponentLibrary*Ex call.  No other memory
// or resources are freed.  The intent is solely to free lock handles on the
// disk allowing another process to get in and change the data.  The shared
// view of the file can be reopened by calling LightWeightOpen.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE LightWeightClose();

    
    virtual HRESULT STDMETHODCALLTYPE NewOid( 
        OID *poid);

//*****************************************************************************
// Return the current total number of objects allocated.  This is essentially
// the highest OID value allocated in the system.  It does not look for deleted
// items, so the count is approximate.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetObjectCount( 
        ULONG       *piCount);
    
//*****************************************************************************
// Allow the user to create a stream that is independent of the database.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE OpenSection(
        LPCWSTR     szName,                 // Name of the stream.
        DWORD       dwFlags,                // Open flags.
        REFIID      riid,                   // Interface to the stream.
        IUnknown    **ppUnk);               // Put the interface here.

//*****************************************************************************
// Allow the user to query write state.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE GetOpenFlags(
        DWORD       *pdwFlags);

//*****************************************************************************
// Allow the user to provide a custom handler.  The purpose of the handler
//  may be determined dynamically.  Initially, it will be for save-time 
//  callback notification to the caller.
//*****************************************************************************
    virtual HRESULT STDMETHODCALLTYPE SetHandler(
        IUnknown    *pHandler);             // The handler.

//
// IComponentRecordsSchema
//

    virtual HRESULT GetTableDefinition(     // Return code.
        TABLEID     TableID,                // Return ID on successful open.
        ICRSCHEMA_TABLE *pTableDef);        // Return table definition data.

    virtual HRESULT GetColumnDefinitions(   // Return code.
        ICRCOLUMN_GET GetType,              // How to retrieve the columns.
        TABLEID     TableID,                // Return ID on successful open.
        ICRSCHEMA_COLUMN rgColumns[],       // Return array of columns.
        int         ColCount);              // Size of the rgColumns array, which

    virtual HRESULT GetIndexDefinition(     // Return code.
        TABLEID     TableID,                // Return ID on successful open.
        LPCWSTR     szIndex,                // Name of the index to retrieve.
        ICRSCHEMA_INDEX *pIndex);           // Return index description here.

    virtual HRESULT GetIndexDefinitionByNum( // Return code.
        TABLEID     TableID,                // Return ID on successful open.
        int         IndexNum,               // Index to return.
        ICRSCHEMA_INDEX *pIndex);           // Return index description here.

    virtual HRESULT  CreateTableEx(			// Return code.
		LPCWSTR		szTableName,			// Name of new table to create.
		int			iColumns,				// Columns to put in table.
		ICRSCHEMA_COLUMN	rColumnDefs[],	// Array of column definitions.
		USHORT		usFlags, 				// Create values for flags.
		USHORT		iRecordStart,			// Start point for records.
		TABLEID		tableid,				// Hard coded ID if there is one.
		BOOL		bMultiPK);				// The table has multi-column PK.

	virtual HRESULT CreateIndexEx(			// Return code.
		LPCWSTR		szTableName,			// Name of table to put index on.
		ICRSCHEMA_INDEX	*pInIndexDef,		// Index description.
		const DBINDEXCOLUMNDESC rgInKeys[]);// Which columns make up key.

	virtual HRESULT GetSchemaBlob(			//Return code.
		ULONG* cbSchemaSize,				//schema blob size
		BYTE** pSchema,						//schema blob
		ULONG* cbNameHeap,					//name heap size
		HGLOBAL*  phNameHeap);				//name heap blob




//
// Public helpers.
//


//*****************************************************************************
// Manage ref counts on open tables.
//*****************************************************************************


//*****************************************************************************
// Accessor functions.  None of these do locking.  Lock the database up
// front if you have to.
//*****************************************************************************
    inline LPCWSTR GetName()
    {   
        return (m_rcDatabase); 
    }

    virtual int IsOpen()
    { return ((m_fFlags & SD_OPENED) != 0); }

    virtual int IsReadOnly()
    { return ((m_fFlags & SD_WRITE) == 0); }

    int IsExistingFile()
    { return (m_fFlags & SD_EXISTS); }

    FILETYPE GetFileType()
    { return (m_eFileType); }

    int IsClassFile()
    { return (false); }

    static void GetUniqueTempIndexName(LPSTR szOut, int cbOut, LPCSTR szTable)
    {
        _snprintf(szOut, cbOut, "##%s_Dex", szTable);
    }

    static void GetUniqueTempIndexNameW(LPWSTR szOut, int cbOut, LPCWSTR szTable)
    {
        _snwprintf(szOut, cbOut, L"##%s_Dex", szTable);
    }

    void SetEnforceDeleteOnEmpty(int bEnforce)
    { m_bEnforceDeleteOnEmpty = bEnforce; }

    OID GetNextOidValue()
    { return (m_iNextOid); }

    RTSemExclusive *GetLock()
    { return (&m_Lock); }

    PFN_HASH_PERSIST GetHashFunc()
    { return (m_pfnHash); }

protected:

//*****************************************************************************
// These functions are used to manage the open table heap and hash table.
//*****************************************************************************
    STGOPENTABLE *TableListFind(LPCSTR szTable);

    HRESULT TableListAdd(                   // Return code.
        LPCSTR      szTableName,            // The new table to open.
        STGOPENTABLE *&pTable);             // Return new pointer on success.

    void TableListDel(
        STGOPENTABLE *pOpenTable);          // Table to clean up.


//*****************************************************************************
// Faults in the table list hash table which makes table name lookups much
// faster.  This is not created by default because COM+ uses tableid's instead
// of names.
//*****************************************************************************
    HRESULT TableListHashCreate();

//*****************************************************************************
// Looks for a schema reference in the current database.
//*****************************************************************************
    SCHEMADEFS *_SchemaFind(                // Pointer to item if found.
        const COMPLIBSCHEMA *pSchema,       // Schema identifier.
        int         *piIndex = 0);          // Return index of item if found.

//*****************************************************************************
// Given the header data which contains schema references, add the reference
// to the loaded instance of the database.  There will be no attempt to fix
// up the definition pointer yet.  The caller may provide this value by calling
// SchemaAdd(), or if we need it we can fault it in by looking it up in the
// schema catalog.
//*****************************************************************************
    HRESULT AddSchemasRefsFromFile(         // Return code.
        STGEXTRA    *pExtra);               // Extra header data.


//
// This code is used by the PageDump program which creates the hard coded 
// internal core schema used by COM+.  It needs direct access to some of the
// data structures it will compile into the image.
//
    virtual SCHEMADEFS *GetSchema(SCHEMAS eSchema);

    inline CSchemaList *GetSchemaList()
    { return (&m_Schemas); }

//
// The code in this section is needed by the record manager and index manager
// which need direct access to the underlying schema definition data.  An
// external user should simply use the public interface.
//
protected:

//*****************************************************************************
// Handle open of native format, the .clb file.
//*****************************************************************************
    HRESULT InitClbFile(                    // Return code.
        ULONG       fFlags,                 // Flags for init.
        StgIO       *pStgIO);               // Data for the file.

//*****************************************************************************
// These functions are provided for the IST functions to call.
//*****************************************************************************

    virtual HRESULT PutOid(                 // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        OID         oid);                   // Return id here.

    virtual HRESULT GetOid(                 // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        OID         *poid);                 // Return id here.

    virtual HRESULT GetStringUtf8(          // Return code.
        STGOPENTABLE    *pOpenTable,        // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        LPCSTR      *pszOutBuffer);         // Where to put string pointer.

    virtual HRESULT GetStringA(             // Return code.
        STGOPENTABLE *pOpenTable,           // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        LPSTR       szOutBuffer,            // Where to write string.
        int         cchOutBuffer,           // Max size, including room for \0.
        int         *pchString);            // Size of string is put here.

    virtual HRESULT GetStringW(             // Return code.
        STGOPENTABLE *pOpenTable,           // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        LPWSTR      szOutBuffer,            // Where to write string.
        int         cchOutBuffer,           // Max size, including room for \0.
        int         *pchString);            // Size of string is put here.

    virtual HRESULT STDMETHODCALLTYPE PutStringUtf8( // Return code.
        STGOPENTABLE *pOpenTable,           // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        LPCSTR      szString,               // String we are writing.
        int         cbBuffer);              // Bytes in string, -1 null terminated.

    virtual HRESULT STDMETHODCALLTYPE PutStringA( // Return code.
        STGOPENTABLE *pOpenTable,           // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        LPCSTR      szString,               // String we are writing.
        int         cbBuffer);              // Bytes in string, -1 null terminated.

    virtual HRESULT STDMETHODCALLTYPE PutStringW( // Return code.
        STGOPENTABLE *pOpenTable,           // Which table to work with.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        LPCWSTR     szString,               // String we are writing.
        int         cbBuffer);              // Bytes (not characters) in string, -1 null terminated.

    virtual HRESULT PutVARIANT(             // Return code.
        STGOPENTABLE *pOpenTable,           // The table to work on.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        const VARIANT *pValue);             // The variant to write.

    virtual HRESULT PutVARIANT(             // Return code.
        STGOPENTABLE *pOpenTable,           // The table to work on.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        const void  *pBuffer,               // User data to write as a variant.
        ULONG       cbBuffer);              // Size of buffer.

    virtual HRESULT PutVARIANT(             // Return code.
        STGOPENTABLE *pOpenTable,           // Table to work on.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        VARTYPE     vt,                     // Type of data.
        const void  *pValue);               // The actual data.

    virtual HRESULT PutGuid(                // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        REFGUID     guid);                  // Guid to put.

    virtual HRESULT GetGuid(                // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        GUID        *pguid);                // Return guid here.

    virtual HRESULT PutBlob(                // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        void        *pRecord,               // Record with data.
        const BYTE  *pBuffer,               // User data.
        ULONG       cbBuffer);              // Size of buffer.

    virtual HRESULT GetBlob(                // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       iColumn,                // 1 based column number (logical).
        const void  *pRecord,               // Record with data.
        const BYTE  **ppBlob,		        // Return pointer to data.
        ULONG       *pcbSize);              // How much data in blob.

    virtual HRESULT GetColumnOffset(        // Return code.
        STGOPENTABLE *pOpenTable,           // The table with the column.
        ULONG       iColumn,                // The column with the data.
        const void  *pRecord,               // Record with data.
        DBTYPE      iType,                  // Type the column should be.
        ULONG       *pulOffset);            // Put offset here.


//
// Record heap code.
//

//*****************************************************************************
// Allocates a new record heap for a table.  If the heap allocation request 
// can be satisified using the small table heap, then it will be allocated
// from that heap.  If there isn't enough room, or the size requested is too
// large, then a VMStructArray will be allocated and returned.
//*****************************************************************************
    HRESULT GetRecordHeap(                  // Return code.
        ULONG       Records,                // How many records to allocate room for.
        int         iRecordSize,            // How large is each record.
        ULONG       InitialRecords,         // How many records to automatically reserve.
        int         bAllocateHeap,          // True:  allocate heap and return in *ppHeap
                                            // False: Use heap in *ppHeap, no allocation.
        RECORDHEAP  **ppHeap,               // Return new heap here.
        ULONG       *pRecordTotal = 0);     // Return how many records we allocated space for.

//*****************************************************************************
// Free both the virtual memory and each record heap item starting with the 
// item passed to this function.  pRecordHeap is no longer valid after this
// function is run.
//*****************************************************************************
    void FreeRecordHeap(                    // Return code.
        RECORDHEAP  *pRecordHeap);          // Item to free.

//*****************************************************************************
// Free the record data for a record heap.  This involves clearing any
// suballocated records from the heap, and then checking to see if the
// underlying heap data was part of the small table heap.  If the latter, 
// then free the entry so another table can use it eventually.
//*****************************************************************************
    void FreeHeapData(
        RECORDHEAP  *pRecordHeap);          // The heap to free.


private:
//*****************************************************************************
//  This function retrieves the data from a particular column, given the type etc.
//  
//*****************************************************************************
    HRESULT STDMETHODCALLTYPE GetData(
        STGOPENTABLE    *pOpenTable,        // pointer to the open table.
        STGCOLUMNDEF    *pColDef,           // column def pointer
        ULONG           columnOrdinal,      // column, 1-based,
        const void      *pRowPtr,           // row pointer
        ULONG           dataTypeSize,       // size of data tranafer.
        byte            *destAddr,          // out buffer.
        ULONG           *pcbLength);        // Return length retrieved.

    HRESULT STDMETHODCALLTYPE SetData(
        STGOPENTABLE    *pOpenTable,        // pointer to the open table.
        STGCOLUMNDEF    *pColDef,           // column def pointer
        ULONG           columnOrdinal,      // column, 1-based,
        byte            *srcAddr,           // in buffer.
        ULONG           dataTypeSize,       // size of data tranafer
        DBTYPE          srcType,            // Type of actual data.
        void            *pRowPtr);          // row pointer
        
    USHORT STDMETHODCALLTYPE GetSizeFromDataType(
        STGCOLUMNDEF    *pColDef,           // column
        DBTYPE          iType);             // iType.

//*****************************************************************************
// Create a transient index on a primary key.  This is used in write mode when
// records cannot be sorted by their primary key and must therefore be indexed
// using another method.
//*****************************************************************************
    HRESULT CreateTempPKIndex(              // Return code.
        LPCWSTR     szTableName,            // Name of table.
        SCHEMADEFS  *pSchemaDefs,           // Schema definitions.
        STGTABLEDEF *pTableDef,             // Table definition to create index on.
        STGCOLUMNDEF *pColDef);             // Primary key column.

//*****************************************************************************
// Called for a create table|index where we need to know which schema the object
// is going to be created in.  One can only create a user or temp schema, so
// it has to be one of those.  The temporary schema is not allocated by default,
// so create it if need be.
//*****************************************************************************
    HRESULT ChooseCreateSchema(             // Return code.
        SCHEMADEFS  **ppSchemaDefs,         // Return pointer to schema.
        int         bIsTempTable);          // true for temporary table.

//*****************************************************************************
// Called whenever the schema has changed.  Each record object is notified of
// the change.  For example, if the schema def memory location has changed,
// any cached pointers must be udpated.
//*****************************************************************************
    void NotifySchemaChanged();             // Return code.

//*****************************************************************************
// This function does the real work of saving the data to disk.  It is called
// by Save() so that the exceptions can be caught without the need for stack
// unwinding.
//*****************************************************************************
    HRESULT SaveWork(                       // Return code.
        TiggerStorage *pStorage,            // Where to save a copy of this file.
        ULONG       *pcbSaveSize);          // Optionally return save size of data.

//*****************************************************************************
// Artificially load all tables from disk so we have an in memory
// copy to rewrite from.  The backing storage will be invalid for
// the rest of this operation.
//*****************************************************************************
    HRESULT SavePreLoadTables();            // Return code.

//*****************************************************************************
// Organize the pools, so that the live data is known.  This eliminates 
//  deleted and temporary data from the persistent data.  This step also lets
//  the pools give a correct size for their cookies.
// This must be performed before GetSaveSize() or Save() can complete (it is
//  called by them).  After calling this, no add functions are valid until a
//  call to SaveOrganizePoolsFinished().
//*****************************************************************************
    HRESULT SaveOrganizePools();            // Return code.

//*****************************************************************************
// Lets the pools know that the persist-to-stream reorganization is done, and
//  that they should return to normal operation.
//*****************************************************************************
    HRESULT SaveOrganizePoolsEnd();         // Return code.

//*****************************************************************************
// Save a pool of data out to a stream.
//*****************************************************************************
    HRESULT SavePool(                       // Return code.
        LPCWSTR     szName,                 // Name of stream on disk.
        TiggerStorage *pStorage,            // The storage to put data in.
        StgPool     *pPool);                // The pool to save.

//*****************************************************************************
// Add the size of the pool data and any stream overhead it may occur to the
// value already in *pcbSaveSize.
//*****************************************************************************
    HRESULT GetPoolSaveSize(                // Return code.
        LPCWSTR     szHeap,                 // Name of the heap stream.
        StgPool     *pPool,                 // The pool to save.
        ULONG       *pcbSaveSize);          // Add pool data to this value.

//*****************************************************************************
// Save a User Section to the database.
//*****************************************************************************
    HRESULT SaveUserSection(                // Return code.
        LPCWSTR     szName,                 // Name of the Section.
        TiggerStorage *pStorage,            // Storage to put data in.
        IUserSection *pISection);           // Section to put into it.

//*****************************************************************************
// This function sets the tableid and finds an exisiting open table struct
// if there is one for a core table.  If the table is a core table and it has
// not been opened, then there is nothing to save and true is returned to
// skip the thing.
//*****************************************************************************
    int SkipSaveTable(                      // Return true to skip table def.
        STGTABLEDEF *pTableDef,             // Table to check.
        STGOPENTABLE *&pTablePtr,           // If found, return open table struct.
        TABLEID     *ptableid);             // Return tableid for lookups.

//*****************************************************************************
// Figure out how much room will be used in the header for extra data for the
// current state of the database.
//*****************************************************************************
    ULONG GetExtraDataSaveSize();           // Size of extra data.


//*****************************************************************************
// Align all columns in the table for safe in memory access.  This means
// sorting descending by fixed data types, and ascending by variable data
// types, with the small parts of each meeting in the middle.  Then apply 
// proper byte alignment to each column as required.
//*****************************************************************************
    HRESULT AlignTable(                     // Return code.
        STGTABLEDEF *pTableDef);            // The table to align.

//*****************************************************************************
// This function is called on a new database object that does not know what
// schemas it is to use yet.  There are three calling scenarios:
//
//  Create:  This scenario will optionally pull in the COM+ schema and add
//          the user schema to the list.
//
//  Open r/w:  This scenario will pull in the COM+ schema if need be and apply
//          any overrides that were saved on a previous run.  Next the user
//          schema is added to the list.
//
//  Open r/o:  This scenario will pull in the COM+ schema, apply overrides,
//          and select in the user schema.
//
// After this function succeeds, the database is prepared to handle all
// table related operations.
//*****************************************************************************
    HRESULT InitSchemaLoad(                 // Return code.
        long        fFlags,                 // What mode are we in.
        STGSCHEMA   *pstgSchema,            // Header for schema storage.
        int         bReadOnly,              // true if read only open.
        int         bLoadCoreSchema,        // true if the COM+ schema is loaded.
        int         iSchemas = -1,          // How many schemas there were.
        BYTE        rgSchemaList[] = 0);    // For overrides, corresponding schema dex.

//*****************************************************************************
// It has been determined that there is data that needs to be imported from disk.
// This code will find the schema and table definitions that describe the on
// disk data so it can be imported.  szTable and tableid are mutually exclusive.
//*****************************************************************************
    HRESULT GetOnDiskSchema(                // S_OK, S_FALSE, or error.
        LPCWSTR      szTable,                // Table name if tableid == -1
        TABLEID     tableid,                // Tableid or -1 if name.
        SCHEMADEFS  **ppSchemaDefs,         // Return schema here, 0 not found.
        STGTABLEDEF **ppTableDef);          // Return table def, 0 not found.

//*****************************************************************************
// Given a persisted set of tables from an existing database, recreate the
// original table definitions in memory with fully expanded columns.
//*****************************************************************************
    HRESULT LoadSchemaFromDisk(             // Return code.
        SCHEMADEFS  *pTo,                   // Load the data into here.
        const SCHEMADEFS *pFrom);           // Take data from here.

//*****************************************************************************
// Look for core table overrides (change in column size, indexes stored or not)
// then make the in memory definition match it.
//*****************************************************************************
    void AddCoreOverrides(
        SCHEMADEFS  *pCoreSchema,           // Core schema definitions to overwrite.
        const SCHEMADEFS *pUserSchema,      // Where the overrides live.
        int         iSchemaDex,             // Index of pCoreSchema.
        int         iSchemas,               // How many schemas there were.
        BYTE        rgSchemaList[]);        // The list of schemas for overrides.

//*****************************************************************************
// Find a table def override in the given schema.  Because overrides are not
// indexed by tableid, this does require a scan of each table def.
//*****************************************************************************
    STGTABLEDEF *FindCoreTableOverride(     // Table def override if found.
        SCHEMADEFS  *pUserSchema,           // Schema which might have overrides.
        TABLEID     tableid);               // Which table do you want.

//*****************************************************************************
// Examines the given table definition against the compact r/o version.  If
// there are any overrides that are too big, then return true so that the
// caller knows an override must be stored in the database file.
//*****************************************************************************
    int IsCoreTableOverride(                // true if it is.
        SCHEMADEFS  *pSchemaDef,            // The schema which owns the table.
        STGTABLEDEF *pTableDef);            // The table def to compare.

    HRESULT GetRowByOid(                    // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        OID         _oid,                   // Value for keyed lookup.
        void        **ppStruct);            // Return pointer to record.

    HRESULT GetRowByRID(                    // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        ULONG       rid,                    // Record id.
        void        **ppStruct);            // Return pointer to record.

    HRESULT NewRecord(                      // Return code.
        STGOPENTABLE *pOpenTable,           // For the new table.
        void        **ppData,               // Return new record here.
        OID         _oid,                   // ID of the record.
        ULONG       iOidColumn,             // Ordinal of OID column.
        ULONG       *pRecordID,             // Optionally return the record id.
        BYTE        fFlags = 0);            // optional flag to mark records.

    ULONG PrintSizeInfo(                    // The size.
        bool verbose);                      // Be verbose?

private:
    TiggerStorage *m_pStorage;          // The storage with database in it.
    WCHAR       m_rcDatabase[_MAX_PATH];// Name of this database.
    FILETYPE    m_eFileType;            // What type of file format.
    ULONG       m_fFlags;               // SD_xxx flags for this class.
    ULONG       m_fOpenFlags;           // Open mode flags.

    IUnknown    *m_pHandler;            // Custom handler.
    TokenMapper *m_pMapper;             // Token remapper helper.

    // Schema support.
    CSchemaList m_Schemas;              // List of installed schemas.
    SCHEMADEFSDATA m_UserSchema;        // User defined tables.
    SCHEMADEFS  m_TableDefDisk;         // On disk formats used for import r/w.
    int         m_bEnforceDeleteOnEmpty;// true to enforce delete empty.
    PFN_HASH_PERSIST m_pfnHash;         // Hashing method for this database.

//@todo: these go away when schemas become immutable.
    BYTE        *m_rgSchemaList;        // List of schema overrides.
    int         m_iSchemas;             // How many schema overrides.

    VMStructArray m_SmallTableHeap;     // Heap for small record heaps.

    // For ICR support, internal COR runtime hookup.
    ULONG       m_cRef;                 // Ref counting for ICR.
    OID         m_iNextOid;             // Counter for OID.

    // User Section support.
    TStringMap<IUserSection*>   m_UserSectionMap;

    // System support.
    CComPtr<IMalloc> m_pIMalloc;        // System shared heap.

    // These two go together; if you have a known TABLEID, then simply use
    // m_rgTables.  Use m_TableList to index m_rgTables by name.
    COpenTablePtrHash *m_pTableHash;    // A hash table to find open tables.
    COpenTableHeap m_TableHeap;         // Heap of open table structs.
    RTSemExclusive m_Lock;              // Lock for thread safety.

    // Save support.
    STORAGESTREAMLST *m_pStreamList;    // List of streams for save.

    int         m_bPoolsOrganized;      // True when pools are organized for saving.

    // Debug check support.
#ifdef _DEBUG
    ULONG       m_dbgcbSaveSize;        // Test for GetSaveSize.
#endif
};




//*****************************************************************************
// Debug helper code for tracking leaks, tracing, etc.
//*****************************************************************************
#ifdef _DEBUG

struct _DBG_DB_ITEM
{
    StgDatabase *pdb;                   // Pointer to database object.
    long        iAlloc;                 // What number allocation was it.
    _DBG_DB_ITEM *pNext;                // Next item in the list.
};
HRESULT _DbgAddDatabase(StgDatabase *pdb);
HRESULT _DbgFreeDatabase(StgDatabase *pdb);
int _DbgValidateList();
long _DbgSetBreakAlloc(long iAlloc);

#endif



#endif // __StgDatabase_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdef.h ===
//*****************************************************************************
// StgDef.h
//
// This is the main header for the storage subsystem.  It contains the structs
// and other required stuff for persiting information.
// @todo: review structs and get rid of padding.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgDef_h__
#define __StgDef_h__

#include "PageDef.h"					//@todo: temporary, pagedef.h goes away.
#include "Errors.h"

// Save the current struct alignment value, then set it to 1.  This makes sure
// the compiler doesn't put any extra space into these structs which must have
// the precise size when written and read to disk.  Not packing the structs
// ourselves is a bug.
#pragma pack(push)
#pragma pack(1)



//*****************************************************************************
// Persisted hash method.
//*****************************************************************************
typedef ULONG (*PFN_HASH_PERSIST)(ULONG OldHashValue, DBTYPE dbType, const BYTE *pbData, ULONG cbData, BOOL bCaseInsensitive);


//*****************************************************************************
// This is here to put the decision on case sensitivity in exactly one place.
//*****************************************************************************
inline SchemaNameCmp(LPCWSTR sz1, LPCWSTR sz2)
{
	return (_wcsicmp(sz1, sz2));
};

inline SchemaNameCmp(LPCSTR sz1, LPCSTR sz2)
{
	return (_stricmp(sz1, sz2));
};



//*****************************************************************************
// Every page on disk starts with this header.  The record data itself can be
// found by looking at an array at the end of the page that grows backwords.
// For example, the offset for record 0 is the last two bytes of the page, the
// offset for record 1 is the two bytes before that, etc...
//*****************************************************************************
struct STGPAGEHDR
{
	PAGERUNTIME	sCache;					// Cache specific data.
	PAGEID		PageID;					// Page number, 0 based.
	PAGETYPE	iPageType;				// PAGE_xxx type.
	USHORT		iFreeBytes;				// How many bytes are free in this page.
	USHORT		iRecords;				// How many records on this page.
	PAGELINK	sLink;					// Link to next page of this type.
	PAGELINK	sFreeLink;				// Link to next page with free space.
};




//*****************************************************************************
// Schema information is headed first by an array of offsets to table defs.
// Each table def is followed by its columns, and then by its indexes.  
// Table defs are linked together in a chain.  The stream itself starts out 
// with a header describing what to look for.
//	+-------------------+
//	| STGSCHEMA			|
//	+-------------------+
//	| ULONG[]           |
//	+-------------------+
//	| STGTABLEDEF		|
//	+-------------------+
//	| STGCOLUMNDEF[]	|
//	+-------------------+
//	| STGINDEXDEF[]		|
//	+-------------------+
//	| Next Table[]...	|
//	+-------------------+
//*****************************************************************************

typedef INT_PTR STGRECORDHDR;
// The following definition appears below, outside the #pragma pack
// typedef CDynArray<STGRECORDHDR> STGRECORDLIST;

// These flags describe the status of a record in a table.
enum
{
	RECORDF_USED	=		0x01,		// Record is in use.
	RECORDF_DEAD	=		0x02,		// This record is no longer usable.
	RECORDF_DEL		=		0x04,		// This record has been deleted.
	RECORDF_PENDING =		0x08,		// Pending changes are waiting.
    RECORDF_TEMP    =       0x10,       // temporary records.
};
typedef BYTE STGRECORDFLAGS;

//*****************************************************************************
// These values are used as a sanity check for definition objects.  The magic
// value is placed in a piece of padding in the structure and access to that
// item is then checked to look for corruption in the code.  Debug only,
// of course.
//*****************************************************************************
const BYTE MAGIC_COL		= 'C';		// Column def struct.
const BYTE MAGIC_TABLE		= 'T';		// Table def struct.
const BYTE MAGIC_INDEX		= 'X';		// Index def struct.

#define COL_NO_DATA_LIMIT	((USHORT) ~0)

enum
{
	CTF_NULLABLE			= 0x01,		// Column is nullable.
	CTF_INDEXED				= 0x02,		// Column is in an index.
	CTF_PRIMARYKEY			= 0x04,		// Column is the primary key.
	CTF_RECORDID			= 0x08,		// Column is a logical record id.
	CTF_CASEINSENSITIVE		= 0x10,		// Column is case insensitive
	CTF_MULTIPK				= 0x80		// Column is part of multi-column primary key.
};

struct STGCOLUMNDEF
{
	ULONG		Name;					// Offset for name.
	BYTE		iColumn;				// Column number.
	BYTE		fFlags;					// CTF_xxx values
	DBTYPE		iType;					// Database type.
	USHORT		iOffset;				// Offset of data value in tuple.
	USHORT		iSize;					// Size of the column.
	USHORT		iMaxSize;				// Max size for var length values.
	BYTE		iNullBit;				// Which logical bit is null indicator.
	BYTE		pad[1];

	inline int IsNullable() const
	{ return ((fFlags & CTF_NULLABLE) != 0); }
	
	inline int IsIndexed() const
	{ return ((fFlags & CTF_INDEXED) != 0); }
	
	inline int IsPrimaryKey() const
	{ return ((fFlags & CTF_PRIMARYKEY) != 0); }

	inline int IsRecordID() const
	{ return ((fFlags & CTF_RECORDID) != 0); }

	inline DBTYPE GetSafeType() const
	{
		if (iType == DBTYPE_OID)
		{
			if (iSize == sizeof(short))
				return (DBTYPE_I2);
			else
				return (DBTYPE_I4);
		}
		return (iType);
	}
};


enum
{
//	DEXF_HASHED			= 0x01,			// Hashing index.
	DEXF_UNIQUE			= 0x02,			// True if unique index.
	DEXF_PRIMARYKEY		= 0x04,			// True if primary key (order data by it).
	DEXF_SAVENOTIFY		= 0x08,			// True if the index needs notify on inserts during save.
	DEXF_DEFERCREATE	= 0x10,			// Index should be created during slow save,
										//  and it can't be used if table is dirty.
	DEXF_INCOMPLETE		= 0x20,			// The index is incomplete and cannot be used
										//	until it is rebuilt.
	DEXF_DYNAMIC		= 0x40			// There is no persistent state for this index,
										//	the data is ordered on disk and can be
										//	binary searched.

};

enum
{
	IT_HASHED = 0x01,
	IT_SORTED = 0x02,
	IT_PAGEHASHED = 0x04,
	IT_CLUSTERED = 0x08
};


#define DFTKEYS 3
struct STGINDEXDEF
{
	ULONG		Name;					// Offset for name.
	BYTE		fFlags;					// Flags describing the index.
	BYTE		iRowThreshold;			// Don't index if rowcount < this.
	BYTE		iIndexNum;				// Which index is this.
	BYTE		fIndexType;				// Type of index.
	union
	{
		struct 
		{
			BYTE	iBuckets;
			BYTE	iMaxCollisions;			// ~Maximum collisions allowed.
			USHORT	iNextOffset;			// Offset in record for next indicator.
		} HASHDATA;
		struct 
		{
			BYTE	fOrder;				// the possible values are defined in tigger.h
			BYTE	rcPad[3];
		} SORTDATA;
	};
	BYTE		iKeys;					// How many columns in the key.
	BYTE		rgKeys[DFTKEYS];		// Start of array of key numbers.

	inline STGINDEXDEF * NextIndexDef() const
	{
		STGINDEXDEF *pTmp;
		BYTE iCount = max(DFTKEYS, iKeys);
		pTmp = (STGINDEXDEF *) ((BYTE *) this + ALIGN4BYTE(offsetof(STGINDEXDEF, rgKeys) + iCount * sizeof(BYTE)));
		_ASSERTE(pTmp->iKeys >= DFTKEYS || pTmp->rgKeys[DFTKEYS - 1] == MAGIC_INDEX);
		return (pTmp);
	}

	int IsUnique() const
	{ return (fFlags & DEXF_UNIQUE); }

	int IsSorted() const
	{ return (fIndexType == IT_SORTED); }

	int IsPrimaryKey() const
	{ return (fFlags & DEXF_PRIMARYKEY); }

	int IsIncomplete() const
	{ return (fFlags & DEXF_INCOMPLETE); }

	int IsDynamic() const
	{ return (fFlags & DEXF_DYNAMIC); }

	int NeedsSaveNotify() const
	{ return (fFlags & DEXF_SAVENOTIFY); }

};

struct STGTABLEDEF
{
	ULONG		Name;					// Offset for name.
	USHORT		tableid;				// A unique id for a core table.
	BYTE		iIndexes;				// How many indexes.
	BYTE		fFlags;					// Flags for this table.
	BYTE		iColumns;				// How many columns in the table.
	BYTE		iNullableCols;			// How many columns are nullable.
	BYTE		iNullBitmaskCols;		// How many columns are in null bitmask.
	BYTE		pad[1];					// For alignment and debugging support.
	USHORT		iRecordStart;			// Start for logical record id.
	USHORT		iNullOffset;			// Offset to null bitmask in record.
	USHORT		iRecordSize;			// Size of fixed portion of one record,
										//	includes header and null bitmask size.
	USHORT		iSize;					// Size of all table data (columns + indexes).
	

	inline STGTABLEDEF *NextTable() const
	{
		return ((STGTABLEDEF *) ((UINT_PTR) this + iSize));
	};

	inline STGCOLUMNDEF *GetColDesc(int iColumn) const
	{
		_ASSERTE(iColumn >= 0 && iColumn < iColumns);
		// Columns start after this table definition.
		STGCOLUMNDEF *pCol = ((STGCOLUMNDEF *)(this + 1)) + iColumn;
		_ASSERTE(pCol->pad[0] == MAGIC_COL);
		return (pCol);
	};

	inline STGINDEXDEF *GetIndexDesc(int iIndex) const
	{
		_ASSERTE(iIndex >= 0 && iIndex < iIndexes);
		STGINDEXDEF	*p;

		// First index is after column array.  Let casting find offset.
		p = (STGINDEXDEF *) (((STGCOLUMNDEF *)(this + 1)) + iColumns);
		while (iIndex--)
			p = p->NextIndexDef();
		_ASSERTE(p->iKeys >= DFTKEYS || p->rgKeys[DFTKEYS - 1] == MAGIC_INDEX);
		return (p);
	};

	inline DWORD *NullBitmask(STGRECORDHDR *p) const
	{
		if (iNullOffset == 0xffff)
			return (0);
		return ((DWORD *) ((UINT_PTR) p + iNullOffset));
	}

	int IsTempTable() const
	{ return ((fFlags & TABLEDEFF_TEMPTABLE) != 0); }

	int IsDeleteOnEmpty() const
	{ return ((fFlags & TABLEDEFF_DELETEIFEMPTY) != 0); }

	int HasPrimaryKeyColumn() const
	{ return ((fFlags & TABLEDEFF_HASPKEYCOL) != 0); }

	int HasRIDColumn() const
	{ return ((fFlags & TABLEDEFF_HASRIDCOL) != 0); }

	int IsCoreTable() const
	{ return ((fFlags & TABLEDEFF_CORE) != 0); }
};



enum
{
	STGSCHEMAF_CORETABLE	= 0x0001	// Contains Core tables.
};


//*****************************************************************************
// STGSCHEMA is the start of the schema definition persistent format.  It
// contains an array of iTables offsets to table definitions, and then the
// actual table definition information itself.
//*****************************************************************************
struct STGSCHEMA
{
	USHORT		iTables;				// How many tables do we have.
	USHORT		fFlags;					// Flags about this schema.
	ULONG		cbSchemaSize;			// Size of schema data.
	ULONG		rgTableOffset[1];		// Offset of first table.

	STGTABLEDEF *GetTableDef(int i) const
	{ 
		_ASSERTE(i <= iTables);
		STGTABLEDEF *pTbl = (STGTABLEDEF *)  ((UINT_PTR) this + rgTableOffset[i]);
		_ASSERTE(i == iTables || pTbl->pad[0] == MAGIC_TABLE);
		return (pTbl);
	}

	int HasCoreTables() const
	{ return ((fFlags & STGSCHEMAF_CORETABLE) != 0); }
};




//*****************************************************************************
// The format of a table stream is as follows:
//	+-------------------+
//	| STGTABLEHDR		|
//	+-------------------+
//	| STGDATAITEM[]		|
//	+-------------------+
//	| Record Data[]		|
//	+-------------------+
//	| STGINDEXHDR       |
//	| Index 1 data[]	|
//	+-------------------+
//	| STGINDEXHDR       |
//	| Index n data[]...	|
//	+-------------------+
// The table header indicates how many records are stored.  The record size is
// is also record and must match the table definition.  Finally the count of
// indexes which have persisted data is given.
//
// Each persisted index starts with an STGINDEXHDR which contains override
// information for the index.  The size of this structure depends on the type
// of index and index specific alignment rules.  For example, a hashed index
// contains the bucket size change and is then padded to either 2 or 4 bytes
// based on the size of a RID.
//*****************************************************************************

struct STGTABLEHDR
{
	ULONG		iRecords;				// How many records follow.
	USHORT		cbRecordSize;			// How big is the record.
	BYTE		iIndexes;				// How many persistent indexes.
	BYTE		rcPad[1];
};

struct STGINDEXHDR
{
	BYTE		iBuckets;				// Override for bucket count.
	BYTE		fFlags;					// Flags for this index.
	BYTE		iIndexNum;				// Which index is this.
	BYTE		rcPad[1];
};



//*****************************************************************************
// A hash record is used to track one data record inside of a hash chain.
//*****************************************************************************
struct STGHASHRECORD
{
	RECORDID	RecordID;				// The real data record, set to -1 in
										//	special case where bucket is empty.
	HASHID		NextHashID;				// Next hash record.
};
typedef CDynArray<STGHASHRECORD> STGHASHLIST;



//*****************************************************************************
// Return the size required to store the largest OID based on value of an OID.
// 0 to 0xfffe will fit in 2 bytes.  0xffff means NULL for a 2 byte OID.
// 0xffff to 0xfffffffe fits in 4 bytes.  0xffffffff means NULL in a 4 byte OID.
//*****************************************************************************
inline int GetOidSizeBasedOnValue(OID oid)
{
	if ((ULONG)oid < 0xffff)
		return (sizeof(USHORT));
	else
		return (sizeof(ULONG));
}


//*****************************************************************************
// Return struct padding to what it was at the front of this file.
//*****************************************************************************
#pragma pack(pop)

//*****************************************************************************
// These need to _not_ be inside the #pragma pack(1).
//*****************************************************************************
typedef CDynArray<STGRECORDHDR> STGRECORDLIST;

// @todo: this would be nicer if it was sparse.
class CStgRecordFlags
{
public:
	HRESULT SetFlags(long iIndex, STGRECORDFLAGS fFlags)
	{
		BYTE		*pfFlags = 0;

		// If the array is large enough, then overwrite old.
		if (iIndex < m_rgFlags.Count())
			m_rgFlags[iIndex] |= fFlags;
		// Otherwise make the array big enough for the new status.
		else
		{
			while (iIndex >= m_rgFlags.Count())
			{
				if ((pfFlags = m_rgFlags.Append()) == 0)
					return (PostError(OutOfMemory()));
				*pfFlags = 0;
			}
			*pfFlags = fFlags;
		}
		return (S_OK);
	}

	BYTE GetFlags(long iIndex)
	{
		if (iIndex >= m_rgFlags.Count())
			return (0);
		return (m_rgFlags[iIndex]);
	}

	BOOL HasFlags()
	{ return(m_rgFlags.Count() != 0); }

	int Count()
	{ return (m_rgFlags.Count()); }

private:
	BYTEARRAY	m_rgFlags;				// Data for flags.
};

#endif // __StgDef_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdbdatadef.cpp ===
//*****************************************************************************
// StgDBDataDef.cpp
//
// This module contains the DDL code for this database.  This includes:
//	CreateTable
//	CreateIndex
//	DropTable
//	DropIndex
//	AlterTable
//
// Table definitions are scoped by a schema.  Only the user and temp schemas
// may be modified by this code.  To change the COM+ schema, change the table
// lay outs in dbschema.h and use the pagedump tool.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Precompiled header.
#include "OleDBUtil.h"					// Helpers for OLE DB api.
#include "StgDatabase.h"				// Database definition.


//********** Code. ************************************************************


//*****************************************************************************
// Create a new table in this database.
//*****************************************************************************
HRESULT StgDatabase::CreateTable(		// Return code.
	LPCWSTR		szTableName,			// Name of new table to create.
	int			iColumns,				// Columns to put in table.
	COLUMNDEF	rColumnDefs[],			// Array of column definitions.
	USHORT		usFlags, 				// Create values for flags.
	USHORT		iRecordStart,			// Start point for records.
	STGTABLEDEF **ppTableDef,			// Put new tabledef here.
	TABLEID		tableid)				// Hard coded ID if there is one.
{
	STGTABLEDEF	*pTableDef;				// Table defintion for new item.
	STGCOLUMNDEF *pColDef;				// Working pointer for copying.
	STGCOLUMNDEF sPKColDef;				// The primary key, if found.
	SCHEMADEFS	*pSchemaDefs;			// Where to create table.
	LPCWSTR		*rgszColList;			// List of column names.
	ULONG		*piOffset;				// Offset of new table def.
	long		iNewSize;				// Memory routines.
	BYTE		iNullBit;				// Track null bits on fixed values.
	int			iPrimaryKeys=0;			// Enforce max primary keys.
	int			iRidCols=0;				// Enforce max RID columns.
	BYTE		fFlags; 				// Default values for flags.
	int			i;						// Loop control.
	HRESULT		hr;

	// Enforce thread safety for database.
	AUTO_CRIT_LOCK(GetLock());

	// Get persistent flags.
	fFlags = static_cast<BYTE>(usFlags);

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Assume we never find one.
	sPKColDef.Name = 0;

	// Chose the schema to host the create.
	if (FAILED(hr = ChooseCreateSchema(&pSchemaDefs, fFlags & TABLEDEFF_TEMPTABLE)))
		return (hr);

	// Valdiate the name we're given.
	if (FAILED(hr = CheckName(szTableName, MAXTABLENAME)))
		return (hr);

	// Check for duplicate table.
//@todo: Now that we have schema names, we should check only the schema if
// the table name is qualified.  In addition, we should make a rule that all
// ## table names are unique and skip this check, because user's can't create
// one with that prefix and we should always choose unique names.
	if (SUCCEEDED(hr = GetTableDef(szTableName, -1, 0, 0, 0)))
		return (PostError(DB_E_DUPLICATETABLEID, szTableName));

	// Decide how big the new table and columns are.
	int cbTableData = sizeof(STGTABLEDEF) + (iColumns * sizeof(STGCOLUMNDEF));

	// Allocate room in for the new meta data.
	if (!pSchemaDefs->pSchema)
	{
		// Allocate.
		iNewSize = sizeof(STGSCHEMA) + cbTableData;
		pSchemaDefs->pSchema = (STGSCHEMA *) malloc(iNewSize);
		if (!pSchemaDefs->pSchema)
			return (PostError(OutOfMemory()));

		// Init.
		memset(pSchemaDefs->pSchema, 0, sizeof(STGSCHEMA));
		pSchemaDefs->pSchema->cbSchemaSize = sizeof(STGSCHEMA) - sizeof(ULONG);
		piOffset = &pSchemaDefs->pSchema->rgTableOffset[0];
	}
	// Grow the definition to make room for new table and the offset.
	else
	{
		// Realloc larger.
		iNewSize = pSchemaDefs->pSchema->cbSchemaSize + sizeof(ULONG) + cbTableData;
		STGSCHEMA *pNew = (STGSCHEMA *) realloc(pSchemaDefs->pSchema, iNewSize);
		if (!pNew)
			return (PostError(OutOfMemory()));
		pSchemaDefs->pSchema = pNew;

		// Init on success by moving all table def data down past new index.
		// (memmove ensures overlapped buffers are handled correctly)
		piOffset = (ULONG *) pNew->GetTableDef(0);
		_ASSERTE(((UINT_PTR) piOffset - (UINT_PTR) pNew) < ULONG_MAX);
		memmove(piOffset + 1, piOffset, 
			iNewSize - (ULONG)((UINT_PTR) piOffset - (UINT_PTR) pNew) - sizeof(ULONG));

		// Need to move all previous tables offsets over the new offset value.
		// Note that this technically goes beyond the typedef'd size of [1], but
		// is perfectly legal.
		for (int k=0;  k<pSchemaDefs->pSchema->iTables;  k++)
			pSchemaDefs->pSchema->rgTableOffset[k] += sizeof(ULONG);
	}
	
	// Need to mark the schema to be freed on shut down.
	pSchemaDefs->fFlags |= SCHEMADEFSF_FREEDATA;

	// Set the offset of this new table def.
	*piOffset = pSchemaDefs->pSchema->cbSchemaSize + sizeof(ULONG);
	pTableDef = pSchemaDefs->pSchema->GetTableDef(pSchemaDefs->pSchema->iTables);
	++pSchemaDefs->pSchema->iTables;
	memset(pTableDef, 0, iNewSize - pSchemaDefs->pSchema->cbSchemaSize - sizeof(ULONG));
	pSchemaDefs->pSchema->cbSchemaSize = iNewSize;
	
	// Copy in the table data.
	if (FAILED(hr = pSchemaDefs->pNameHeap->AddStringW(szTableName, &pTableDef->Name)))
		goto ErrExit;
	pTableDef->tableid = (tableid == 0xffffffff) ? 0xffff : (USHORT) tableid;
	pTableDef->iIndexes = 0;
	pTableDef->fFlags = fFlags;
	pTableDef->iColumns = iColumns;
	pTableDef->iNullableCols = 0;
	pTableDef->iNullBitmaskCols = 0;
	pTableDef->iRecordStart = iRecordStart;
	pTableDef->iNullOffset = 0xffff;
	pTableDef->iSize = (USHORT)(sizeof(STGTABLEDEF) + (iColumns * sizeof(STGCOLUMNDEF)));
	pTableDef->pad[0] = MAGIC_TABLE;

	// Record the list of column names to check for dupes afterward.
	VERIFY(rgszColList = (LPCWSTR *) _alloca(sizeof(LPCWSTR) * iColumns));

	// Init each column and save for alignment.
	pColDef = (STGCOLUMNDEF *) (pTableDef + 1);
	iNullBit = 0;
	for (i=0;  i<iColumns;  i++, pColDef++)
	{
		// Get the datatype description to make sure it is valid.
		const DATATYPEDEF *pDataType = GetTypeFromType(rColumnDefs[i].iType);
		if (!pDataType)
		{
			hr = PostError(DB_E_BADTYPE);
			goto ErrExit;
		}

		// Save rest of structure.
		pColDef->iColumn = i + 1;
		pColDef->iType = rColumnDefs[i].iType;
		pColDef->iMaxSize = rColumnDefs[i].iSize;
		pColDef->fFlags = rColumnDefs[i].fFlags;
		pColDef->pad[0] = MAGIC_COL;

		// Count total nullable columns.
		if (pColDef->fFlags & CTF_NULLABLE)
		{
			// A primary key column can't be NULL in this database.
			if (pColDef->fFlags & CTF_PRIMARYKEY)
			{
				hr = PostError(CLDB_E_COLUMN_PKNONULLS, rColumnDefs[i].rcName);
				goto ErrExit;
			}

			++pTableDef->iNullableCols;
		}

		// Check for null attribute, and reset iSize for pooled types
		// since iSize is size in record and iMaxSize is limit on data.
		if (!IsPooledType(pColDef->iType))
		{
			// Set size based on data type description.
			_ASSERTE(pDataType->fFlags & DBCOLUMNFLAGS_ISFIXEDLENGTH);
			pColDef->iSize = pDataType->iSize;

			// Check for null bitmask requirement.
			if (pColDef->fFlags & CTF_NULLABLE)
			{
				++pTableDef->iNullBitmaskCols;
				pColDef->iNullBit = iNullBit++;
			}
			else
				pColDef->iNullBit = 0xff;
		}
		else
		{
			// Set size and null bit defaults for full offsets.
			pColDef->iSize = sizeof(ULONG);
			pColDef->iNullBit = 0xff;
		}

		// Add column name to heap, then in the list of columns.
		if (FAILED(hr = CheckName(rColumnDefs[i].rcName, MAXCOLNAME)) ||
			FAILED(hr = pSchemaDefs->pNameHeap->AddStringW(rColumnDefs[i].rcName, &pColDef->Name)))
		{
			goto ErrExit;
		}
		rgszColList[i] = rColumnDefs[i].rcName;

		// Can only have one column as pk, use index for multi-col.  Session must enforce.
		if (pColDef->IsPrimaryKey())
		{ 
			if (++iPrimaryKeys > 1)
			{
				hr = PostError(CLDB_E_COLUMN_SPECIALCOL);
				goto ErrExit;
			}
			sPKColDef = *pColDef;

			// Record the fact that a primary key exists to make inserts
			// and other operations faster.
			pTableDef->fFlags |= TABLEDEFF_HASPKEYCOL;
		}
		// Record at the table level that we have a RID, which is then used
		// to speed up scans for indexed lookups.
		else if (pColDef->IsRecordID())
		{
			if (++iRidCols > 1)
			{
				hr = PostError(CLDB_E_COLUMN_SPECIALCOL);
				goto ErrExit;
			}
			pTableDef->fFlags |= TABLEDEFF_HASRIDCOL;
		}
	}

	// Check for dupe column names by sorting the list of names and checking
	// for duplicate names adjacent to each other.  This is a bit of overkill but
	// will scale to a large count.
	{
		SortNames sSort(rgszColList, iColumns);
		sSort.Sort();
		for (i=0;  i<iColumns-1;  i++)
			if (SchemaNameCmp(rgszColList[i], rgszColList[i+1]) == 0)
			{
				hr = PostError(DB_E_DUPLICATECOLUMNID, rgszColList, szTableName);
				goto ErrExit;
			}
	}

	// Align all of the columns for easy record access.
	if (FAILED(hr = AlignTable(pTableDef)))
		goto ErrExit;

	// If there is a primary key, we need to auto-create a hashed index on it
	// so we can do keyed lookups.
	if (sPKColDef.Name != 0 &&
		FAILED(hr = CreateTempPKIndex(szTableName, pSchemaDefs, pTableDef, &sPKColDef)))
		goto ErrExit;

	// If caller wants the table def, retrieve it for them.  Must do a dynamic
	// lookup because transient index create might have caused memory to move.
	if (ppTableDef)
		*ppTableDef = pSchemaDefs->pSchema->GetTableDef(pSchemaDefs->pSchema->iTables - 1);

ErrExit:
	if (FAILED(hr))
	{
		//@todo: kill off the new table, return memory to before state.
	}
	
	// Notify records that things have changed.
	NotifySchemaChanged();
	return (hr);
}


//*****************************************************************************
// Create a new index on the given table.
//@todo: clean up errors.
//*****************************************************************************
HRESULT StgDatabase::CreateIndex(		// Return code.
	LPCWSTR		szTableName,			// Name of table to put index on.
	STGINDEXDEF	*pInIndexDef,			// Index description.
	ULONG		iKeys,					// How many key columns.
	const DBINDEXCOLUMNDESC rgInKeys[], // Which columns make up key.
	SCHEMADEFS	*pSchemaDefs,			// The schema that owns pTableDef, 0 allowed.
	STGTABLEDEF *pTableDef,				// Table defintion for new item, 0 allowed.
	STGCOLUMNDEF *pColDef)				// The column for pk, 0 allowed.
{
	STGINDEXDEF	*pIndexDef;				// New index definition.
	BYTE		*rgKeys;				// Array of keys.
	long		iNewSize;				// Memory routines.
	long		iIndexDefSize;			// Size of new index.
	USHORT		iOffset = 0;			// For layout of records.
	HRESULT		hr;

	// These three go together, cannot mix and match.
	_ASSERTE((pSchemaDefs && pTableDef && pColDef) || (!pSchemaDefs && !pTableDef && !pColDef));

	// Enforce thread safety for database.
	AUTO_CRIT_LOCK(GetLock());

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Get the table layout and owning schema.
	if (!pSchemaDefs)
	{
		if (FAILED(hr = GetTableDef(szTableName, -1, &pSchemaDefs, &pTableDef, 0, 0, false)))
			return (PostError(DB_E_NOTABLE, szTableName));
	}

	// Chose the schema to host the create.
	if (FAILED(hr = ChooseCreateSchema(&pSchemaDefs, pTableDef->IsTempTable())))
		return (hr);

	// Figure out how much data is required.
	_ASSERTE(pSchemaDefs->pSchema && (pSchemaDefs->fFlags & SCHEMADEFSF_FREEDATA));
	iIndexDefSize =  sizeof(STGINDEXDEF);
	if (iKeys > DFTKEYS)
		iIndexDefSize = iIndexDefSize + iKeys - DFTKEYS;
	iIndexDefSize = ALIGN4BYTE(iIndexDefSize);
	iNewSize = pSchemaDefs->pSchema->cbSchemaSize + iIndexDefSize;

	// Grow the schema data large enough to handle the new index.
	void *pbNew = realloc(pSchemaDefs->pSchema, iNewSize);
	if (!pbNew)
		return (PostError(OutOfMemory()));
	pSchemaDefs->pSchema = (STGSCHEMA *) pbNew;

	// Find where our definition starts, we have to re-do this after the realloc.
	VERIFY((hr = GetTableDef(szTableName, -1, &pSchemaDefs, &pTableDef, 0, 0, false)) == S_OK);

	// If there is a table definition behind us, we need it to move down.
//@todo:
//	if ((ULONG) pTableDef + pTableDef->iSize - (ULONG) pSchema->pTables != pSchema->iSchemaSize)
//	{
//		_ASSERTE(0);
//	}
	
	// Get the address for the index.
	pIndexDef = (STGINDEXDEF *) ((UINT_PTR) pTableDef + pTableDef->iSize);
	
	// Save the new size.
	memset(pIndexDef, 0, iNewSize - pSchemaDefs->pSchema->cbSchemaSize);
	pSchemaDefs->pSchema->cbSchemaSize = iNewSize;

	// Fill out the index definition.
	*pIndexDef = *pInIndexDef;

  	// Breaks on 64 bit
	_ASSERTE (sizeof (ULONG) == sizeof (LPCWSTR));

	if (FAILED(hr = CheckName((LPCWSTR) (ULONG_PTR) pInIndexDef->Name, MAXINDEXNAME)) ||
		FAILED(hr = pSchemaDefs->pNameHeap->AddStringW((LPCWSTR) (ULONG_PTR) pInIndexDef->Name, &pIndexDef->Name)))
		return (hr);
	
	// Use the last key number for magic, let code overwrite it if you have
	// too many keys.
	pIndexDef->rgKeys[DFTKEYS - 1] = MAGIC_INDEX;

	// If the index is built on one column (primary key support), then
	// no need to scan just fill it out.
	if (pColDef)
	{
		pIndexDef->iKeys = 1;
		pIndexDef->rgKeys[0] = pColDef->iColumn;

		if (pColDef->IsNullable() && 
				((pInIndexDef->fFlags & DEXF_PRIMARYKEY) ||
				 (pInIndexDef->fFlags & DEXF_UNIQUE)))
		{
			LPCWSTR		szCol;
			char		rcColumn[MAXCOLNAME];

			// Get the name in ANSI which is how we store them.
			VERIFY((hr = GetNameFromDBID(rgInKeys[pIndexDef->iKeys].pColumnID, szCol)) == S_OK);

			if (FAILED(hr = CheckName(szCol, MAXCOLNAME)))
				return (hr);

			VERIFY(Wsz_wcstombs(rcColumn, szCol, sizeof(rcColumn)));
			return (PostError(CLDB_E_COLUMN_PKNONULLS, rcColumn));
		}
	}
	// It is a full blown index, so we need to go through all validation.
	else
	{
		// Convert each column name into an ordinal we can use.  This ordinal
		// is stored 1 based.  We do a scan for names (slow) because the table
		// cannot be loaded while we do this change.
		rgKeys = &pIndexDef->rgKeys[0];
		for (pIndexDef->iKeys=0;  pIndexDef->iKeys<iKeys;  pIndexDef->iKeys++)
		{
			LPCWSTR		szCol;
			char		rcColumn[MAXCOLNAME];

			// Get the name in ANSI which is how we store them.
			VERIFY((hr = GetNameFromDBID(rgInKeys[pIndexDef->iKeys].pColumnID, szCol)) == S_OK);

			if (FAILED(hr = CheckName(szCol, MAXCOLNAME)))
				return (hr);

			VERIFY(Wsz_wcstombs(rcColumn, szCol, sizeof(rcColumn)));

			// Assume error.
			hr = DB_E_BADCOLUMNID;

			// Look for the name.  @future: Note that we could speed this scan up by
			// sorting the column names in another array, and possibly sorting
			// use columns as well.  However create index speed is not a crucial
			// benchmark.
			for (int i=0;  i<pTableDef->iColumns;  i++)
			{
				VERIFY(pColDef = pTableDef->GetColDesc(i));

				if (SchemaNameCmp(pSchemaDefs->pNameHeap->GetString(pColDef->Name), szCol) == 0)
				{
					// Cannot index a record id column.
					if (pColDef->IsRecordID())
						return (PostError(DB_E_BADPROPERTYVALUE, rcColumn));

					// This database doesn't allow the NULL value in a unique index.
					if (pColDef->IsNullable() && 
							((pInIndexDef->fFlags & DEXF_PRIMARYKEY) ||
							 (pInIndexDef->fFlags & DEXF_UNIQUE)))
						return (PostError(CLDB_E_COLUMN_PKNONULLS, rcColumn));

					rgKeys[pIndexDef->iKeys] = pColDef->iColumn;

					// Disallow certain data types in an index.
					if (pColDef->iType == DBTYPE_VARIANT)
						return (PostError(CLDB_E_INDEX_BADTYPE));

					// Modify the column so it knows it is in an index.
					pColDef->fFlags |= CTF_INDEXED;

					// Add primary key bit for multi-column index.
					if (pInIndexDef->fFlags & DEXF_PRIMARYKEY)
						pColDef->fFlags |= CTF_MULTIPK;

					hr = S_OK;
					break;
				}
			}

			// Didn't find the name, which is an error.
			if (FAILED(hr))
			{
				//@todo: handle failure by removing the index def.
				if (hr == DB_E_BADCOLUMNID)
					return (PostError(DB_E_BADCOLUMNID, szCol));
				return (hr);
			}
		}
	}

	// If index is to be created, then find room for it in the record format.
	if ((pIndexDef->fFlags & DEXF_DEFERCREATE) == 0)
	{
		// Sorted Index needs no space in the record format.
		if (pIndexDef->fIndexType != IT_SORTED)
		{
			pIndexDef->HASHDATA.iNextOffset = pTableDef->iRecordSize;
			pTableDef->iRecordSize += sizeof(ULONG);
		}
	}

	// Figure out if the index requires save notification.
	if (pIndexDef->fIndexType != IT_SORTED)
		pIndexDef->fFlags |= DEXF_SAVENOTIFY;

	// Set rest of data.
	pIndexDef->iIndexNum = ++pTableDef->iIndexes;
	pTableDef->iSize += (USHORT) iIndexDefSize;

	// Notify record managers that things have changed.
	NotifySchemaChanged();
	return (S_OK);
}


//*****************************************************************************
// Create a transient index on a primary key.  This is used in write mode when
// records cannot be sorted by their primary key and must therefore be indexed
// using another method.
//*****************************************************************************
HRESULT StgDatabase::CreateTempPKIndex( // Return code.
	LPCWSTR		szTableName,			// Name of table.
	SCHEMADEFS	*pSchemaDefs,			// Schema definitions.
	STGTABLEDEF	*pTableDef,				// Table definition to create index on.
	STGCOLUMNDEF *pColDef)				// Primary key column.
{
	STGINDEXDEF sIndexDef;
	WCHAR		rcDex[64];
	HRESULT		hr;

	_ASSERTE(pColDef->IsPrimaryKey());

	// Generate a unique temp name for the index.
	GetUniqueTempIndexNameW(rcDex, sizeof(rcDex), szTableName);

   	// Breaks on 64 bit
	_ASSERTE (sizeof (LPVOID) == sizeof (ULONG));

	// Create a automatic index that won't persist.
	sIndexDef.Name = PtrToUlong(rcDex);
	sIndexDef.fFlags = DEXF_UNIQUE | DEXF_PRIMARYKEY | DEXF_DYNAMIC;
	sIndexDef.fIndexType = IT_HASHED;
	sIndexDef.iRowThreshold = 8;
#if 1  
	// @todo: PRIMARYKEY_SORTEDINDEX
	sIndexDef.HASHDATA.iBuckets = 17;  //@todo: heuristic
	sIndexDef.HASHDATA.iMaxCollisions = 11;
	sIndexDef.HASHDATA.iNextOffset = 0xffff;
#else 
	sIndexDef.SORTDATA.fOrder = DBINDEX_COL_ORDER_DESC;
#endif
	sIndexDef.iIndexNum = 0xff;
	sIndexDef.iKeys = 1;
	sIndexDef.rgKeys[0] = pColDef->iColumn;

	// Create the index on the table.
	hr = CreateIndex(szTableName, &sIndexDef, 1, 0, 
				pSchemaDefs, pTableDef, pColDef);
	return (hr);
}


//*****************************************************************************
// Drops the given table from the list.
//*****************************************************************************
HRESULT StgDatabase::DropTable(			// Return code.
	LPCWSTR		szTableName) 			// Name of table.
{

	// Enforce thread safety for database.
	AUTO_CRIT_LOCK(GetLock());

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Notify record managers that things have changed.
	NotifySchemaChanged();

	return (BadError(E_NOTIMPL));
}


//*****************************************************************************
// Called for a create table|index where we need to know which schema the object
// is going to be created in.  One can only create a user or temp schema, so
// it has to be one of those.  The temporary schema is not allocated by default,
// so create it if need be.
//*****************************************************************************
HRESULT StgDatabase::ChooseCreateSchema(// Return code.
	SCHEMADEFS	**ppSchemaDefs,			// Return pointer to schema.
	int			bIsTempTable)			// true for temporary table.
{
	HRESULT		hr;

	// Avoid confusion.
	*ppSchemaDefs = 0;

	// Determine where to write the new table.
	if (!bIsTempTable)
	{
		// Must be in write mode to add a table.
		if ((m_fFlags & SD_WRITE) == 0)
			return (PostError(CLDB_E_FILE_READONLY));
		
		// Get the schema to be changed.
		VERIFY(*ppSchemaDefs = m_Schemas.Get(SCHEMA_USER));
	}
	// It is a temp table.
	else
	{
		// Retrieve the temorary schema.  Create it if it doesn't exist.
		if ((*ppSchemaDefs = m_Schemas.Get(SCHEMA_TEMP)) == 0)
		{
			SCHEMADEFSDATA * pNew = new SCHEMADEFSDATA;
			if (!pNew)
				return (PostError(OutOfMemory()));
			*ppSchemaDefs = pNew;
			pNew->sid = SCHEMA_Temp;
			pNew->Version = 0;
			if (FAILED(hr = pNew->StringPool.InitNew()) ||
					FAILED(hr = pNew->BlobPool.InitNew())	||
					FAILED(hr = pNew->VariantPool.InitNew(&pNew->BlobPool, &pNew->StringPool))	||
					FAILED(hr = pNew->GuidPool.InitNew()))
				return (hr);
			m_Schemas.AddSchema(*ppSchemaDefs, SCHEMA_TEMP);
		}
	}
	return (S_OK);
}


//*****************************************************************************
// Called whenever the schema has changed.  Each record object is notified of
// the change.  For example, if the schema def memory location has changed,
// any cached pointers must be udpated.
//*****************************************************************************
void StgDatabase::NotifySchemaChanged()	// Return code.
{
	STGOPENTABLE *pOpenTable;			// Working pointer for tables.

	// Walk the list of open tables and notify each one.
	for (pOpenTable=m_TableHeap.GetHead();  pOpenTable;
				pOpenTable=m_TableHeap.GetNext(pOpenTable))
	{
		if (pOpenTable->RecordMgr.IsOpen())
			pOpenTable->RecordMgr.OnSchemaChange();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdbinit.cpp ===
//*****************************************************************************
// StgDBInit.cpp
//
// This module contains the init code for loading a database.  This includes
// the code to detect file formats, dispatch to the correct import/load code,
// and anything else required to bootstrap the schema into place.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Precompiled header.
#include "StgDatabase.h"                // Database definitions.
#include "StgIO.h"                      // Generic i/o class.
#include "StgTiggerStorage.h"           // Storage implementation.
//#include "ImpTlb.h"                     // Type lib importer.




//****** Local prototypes. ****************************************************
HRESULT GetFileTypeForPath(StgIO *pStgIO, FILETYPE *piType);

extern "C" 
{
HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData);
HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData);
}



//********** Code. ************************************************************


//*****************************************************************************
// This function is called with a database to open or create.  The flags
// come in as the DBPROPMODE values which then allow this function to route
// to either Create or Open.
//*****************************************************************************
HRESULT StgDatabase::InitDatabase(      // Return code.
    LPCWSTR     szDatabase,             // Name of database.
    ULONG       fFlags,                 // Flags to use on init.
    void        *pbData,                // Data to open on top of, 0 default.
    ULONG       cbData,                 // How big is the data.
    IStream     *pIStream,              // Optional stream to use.
    LPCWSTR     szSharedMem,            // Shared memory name for read.
    LPSECURITY_ATTRIBUTES pAttributes)  // Security token.
{
    LPCWSTR     pNoFile=L"";            // Constant for empty file name.
    StgIO       *pStgIO = 0;            // For file i/o.
    HRESULT     hr = S_OK;

    // szDatabase, pbData, and pIStream are mutually exclusive.  Only one may be
    // non-NULL.  Having all 3 NULL means empty stream creation.
    _ASSERTE(!(szDatabase && (pbData || pIStream)));
    _ASSERTE(!(pbData && (szDatabase || pIStream)));
    _ASSERTE(!(pIStream && (szDatabase || pbData)));

    // Enforce thread safety for database.
    AUTO_CRIT_LOCK(GetLock());

    //@todo: need to check for bogus parameters here and return errors.

    // Verify state transition.
    if (m_fFlags & SD_OPENED)
        return (PostError(BadError(E_UNEXPECTED)));

    // Make sure we have a path to work with.
    if (!szDatabase)
        szDatabase = pNoFile;

    // Sanity check the name.
    if (lstrlenW(szDatabase) >= _MAX_PATH)
        return (PostError(E_INVALIDARG));

    // Save off the open flags.
    m_fOpenFlags = fFlags;

	if (FAILED(hr = m_UserSectionMap.NewInit()))
    {
        return hr;
    }

    // If we have storage to work with, init it and get type.
    if (*szDatabase || pbData || pIStream || szSharedMem)
    {
        // Allocate a storage instance to use for i/o.
        if ((pStgIO = new StgIO) == 0)
            return (PostError(OutOfMemory()));

        // Open the storage so we can read the signature if there is already data.
        if (FAILED(hr = pStgIO->Open(szDatabase, fFlags, pbData, cbData, 
                        pIStream, szSharedMem, pAttributes)))
            goto ErrExit;

        // Determine the type of file we are working with.
        if (FAILED(hr = GetFileTypeForPath(pStgIO, &m_eFileType)))
            goto ErrExit;
    }
    // Everthing will get created in memory.
    else
    {
        //@todo: this is the case where caller must tell us what kind of
        // thing we are creating.
        m_eFileType = FILETYPE_CLB;
    }

    // Check for default type.
    if (m_eFileType == FILETYPE_CLB)
    {
        // Try the native .clb file.
        if (FAILED(hr = InitClbFile(fFlags, pStgIO)))
            goto ErrExit;
    }
    // PE/COFF executable/object format.  This requires us to find the .clb 
    // inside the binary before doing the Init.
    else if (m_eFileType == FILETYPE_NTPE || m_eFileType == FILETYPE_NTOBJ)
    {
        //@todo: this is temporary.  Ideally the FindImageMetaData function
        // would take the pStgIO and map only the part of the file where
        // our data lives, leaving the rest alone.  This would be smaller
        // working set for us.
        void        *ptr;
        ULONG       cbSize;

        // Map the entire binary for the FindImageMetaData function.
        if (FAILED(hr = pStgIO->MapFileToMem(ptr, &cbSize)))
            goto ErrExit;

        // Find the .clb inside of the content.
        if (m_eFileType == FILETYPE_NTPE)
            hr = FindImageMetaData(ptr, &ptr, (long *) &cbSize);
        else
            hr = FindObjMetaData(ptr, &ptr, (long *) &cbSize);

        // Was the metadata found inside the PE file?
        if (FAILED(hr))
        {	
			// The PE or OBJ doesn't contain metadata, and doesn't have a name.  There
			//  is no .CLB data to be found.
            if (FAILED(hr))
            {
                hr = PostError(CLDB_E_NO_DATA);
                goto ErrExit;
            }
        }
        else
        {	// Metadata was found inside the file.
            // Now reset the base of the stg object so that all memory accesses
            // are relative to the .clb content.
            if (FAILED(hr = pStgIO->SetBaseRange(ptr, cbSize)))
                goto ErrExit;
            
            // Defer to the normal lookup.
            if (FAILED(hr = InitClbFile(fFlags, pStgIO)))
                goto ErrExit;
        }
    }
    // This spells trouble, we need to handle all types we might find.
    else
    {
        _ASSERTE(!"Unknown file type.");
    }

    // Free up this stacks reference on the I/O object.
    if (pStgIO)
        pStgIO->Release();

    // Check for an error condition from any code path.
    if (FAILED(hr))
        return (hr);

    // Save off everything.
    wcscpy(m_rcDatabase, szDatabase);
    return (S_OK);

ErrExit:
    // Free up this stacks reference on the I/O object.
    if (pStgIO)
        pStgIO->Release();

    // Clean up anything we've done so far.
    Close();
    return (hr);
}


//*****************************************************************************
// Close the database and release all memory.
//*****************************************************************************
void StgDatabase::Close()           // Return code.
{
    SCHEMADEFS *pSchemaDefs;        // Working pointer.

    // Avoid double close, one from user and another from dtor.
    if (m_fFlags == 0)
        return;

    // Enforce thread safety for database.
    AUTO_CRIT_LOCK(GetLock());

    // Sanity check.
    if ((m_fFlags & SD_OPENED) == 0)
        return;

    // Release any table specific data.
    STGOPENTABLE *pOpenTable;
    for (pOpenTable=m_TableHeap.GetHead();  pOpenTable;
            pOpenTable=m_TableHeap.GetNext(pOpenTable))
    {
        if (pOpenTable->RecordMgr.IsOpen())
            pOpenTable->RecordMgr.CloseTable();
    }

    // Free any allocated schema data.
    for (int i=0;  i<m_Schemas.Count();  i++)
    {
        pSchemaDefs = m_Schemas.Get(i);
        if (!pSchemaDefs)
            continue;

		// Sanity check this pointer to catch stress failure.
		if (SCHEMADEFS::IsValidPtr(pSchemaDefs) != true)
			continue;

        if ((pSchemaDefs->fFlags & SCHEMADEFSF_FREEDATA) && pSchemaDefs->pSchema)
        {
            free(pSchemaDefs->pSchema);
            pSchemaDefs->pSchema = 0;
        }

        // Clean up the heaps.
        if (pSchemaDefs->pNameHeap && pSchemaDefs->pNameHeap != pSchemaDefs->pStringPool)
            pSchemaDefs->pNameHeap->Uninit();
        if (pSchemaDefs->pStringPool)
            pSchemaDefs->pStringPool->Uninit();
        if (pSchemaDefs->pBlobPool)
            pSchemaDefs->pBlobPool->Uninit();
        if (pSchemaDefs->pVariantPool)
            pSchemaDefs->pVariantPool->Uninit();

        // Delete the temporary schema object if allocated.
        if (i == SCHEMA_TEMP)
        {
            SCHEMADEFSDATA *p = (SCHEMADEFSDATA *) pSchemaDefs;
            delete p;
        }
        // Delete any allocated memory for external schemas.
        else if (i >= SCHEMA_EXTERNALSTART)
        {
            if (pSchemaDefs->pNameHeap)
                delete pSchemaDefs->pNameHeap;
            SCHEMADEFS::SafeFreeSchema(pSchemaDefs);
        }
    }

    // Clear the list.
    m_Schemas.Clear();

    // Free memory allocated for small table heap.
    if (m_fFlags & SD_TABLEHEAP)
        m_SmallTableHeap.Clear();

    // Reset flag values.
    *m_rcDatabase = '\0';
    m_fFlags = 0;

    // Delete the table hash if it was created.
    if (m_pTableHash)
        delete m_pTableHash;

    // Clear out the table description information.
    m_TableHeap.Clear();

    // Release any user sections.
    TStringMap<IUserSection*>::TItemType *pIT; // Pointer to a UserSection map item.
    HASHFIND    sMapSrch;               // For iterating over UserSection map.
    pIT = m_UserSectionMap.FindFirstEntry(&sMapSrch);
    while (pIT)
    {
        pIT->m_value->Release();
        pIT = m_UserSectionMap.FindNextEntry(&sMapSrch);
    }
    m_UserSectionMap.Clear();

	// finally, clear the backing storage.  This has to be done last because many
	// other objects (record heaps, data heaps, etc.) will cache pointers to
	// this memory which will become invalid later on.
    if (m_pStorage)
    {
        delete m_pStorage;
        m_pStorage = 0;
    }

	// Free stream list if used on a save.
	if (m_pStreamList)
	{
		delete m_pStreamList;
		m_pStreamList = 0;
	}

	// Free any handler that's been set.
	if (m_pHandler)
	{
		m_pHandler->Release();
		m_pHandler = 0;
	}
}   



//*****************************************************************************
// Handle open of native format, the .clb file.
//*****************************************************************************
HRESULT StgDatabase::InitClbFile(       // Return code.
    ULONG       fFlags,                 // Flags for init.
    StgIO       *pStgIO)                // Data for the file.
{
    TiggerStorage *pStorage = 0;        // Storage object.
    STGEXTRA    *pExtra;                // Extra data pointer.
    ULONG       cbExtra;                // Size of extra data.
    void        *pbData;                // Pointer for loaded streams.
    ULONG       cbData;                 // Size of streams.
    int         bCoreSchema;            // true to load core schema.
    HRESULT     hr = S_OK;

    // Determine if this open requires the core schema.
    bCoreSchema = (fFlags & DBPROP_TMODEF_COMPLUS) != 0;

    // Allow for case where user wants to do everything in memory and
    // optionally save to stream or disk at the end.
    if (pStgIO)
    {
        // Allocate a new storage object which has IStorage on it.
        if ((pStorage = new TiggerStorage) == 0)
            return (PostError(OutOfMemory()));

        // Init the storage object on the backing storage.
        if (FAILED(hr = pStorage->Init(pStgIO)))
            goto ErrExit;
    }

    // Do an open of the database.
    if (pStgIO && (fFlags & DBPROP_TMODEF_CREATE) == 0)
    {
        STGSCHEMA   *pstgSchema=0;      // Header for schema data.
        int         bReadOnly;          // true for read only mode.

        // Record mode for open.
        bReadOnly = pStgIO->IsReadOnly();

        // Load the string pool.
        if (SUCCEEDED(hr = pStorage->OpenStream(STRING_POOL_STREAM, &cbData, &pbData)))
        {
            if (FAILED(hr = m_UserSchema.pStringPool->InitOnMem(pbData, cbData, bReadOnly)))
                goto ErrExit;
        }
        else if (hr != STG_E_FILENOTFOUND || FAILED(hr = m_UserSchema.pStringPool->InitNew()))
            goto ErrExit;

        // Load the blob pool.
        if (SUCCEEDED(hr = pStorage->OpenStream(BLOB_POOL_STREAM, &cbData, &pbData)))
        {
            if (FAILED(hr = m_UserSchema.pBlobPool->InitOnMem(pbData, cbData, bReadOnly)))
                goto ErrExit;
        }
        else if (hr != STG_E_FILENOTFOUND || FAILED(hr = m_UserSchema.pBlobPool->InitNew()))
            goto ErrExit;

        // Load the variant pool.
        if (SUCCEEDED(hr = pStorage->OpenStream(VARIANT_POOL_STREAM,  &cbData, &pbData)))
        {
            if (FAILED(hr = m_UserSchema.pVariantPool->InitOnMem(m_UserSchema.pBlobPool, 
                    m_UserSchema.pStringPool, pbData, cbData, bReadOnly)))
                goto ErrExit;
        }
        // Still need to init the pool.
        else if (hr != STG_E_FILENOTFOUND || 
            FAILED(hr = m_UserSchema.pVariantPool->InitNew(m_UserSchema.pBlobPool, m_UserSchema.pStringPool)))
            goto ErrExit;

        // Load the guid pool.
        if (SUCCEEDED(hr = pStorage->OpenStream(GUID_POOL_STREAM,  &cbData, &pbData)))
        {
            if (FAILED(hr = m_UserSchema.pGuidPool->InitOnMem(pbData, cbData, bReadOnly)))
                goto ErrExit;
        }
        // Still need to init the pool.
        else if (hr != STG_E_FILENOTFOUND || 
            FAILED(hr = m_UserSchema.pGuidPool->InitNew()))
            goto ErrExit;

        // Load the schema definitions from the schema stream.
        if (FAILED(hr = pStorage->OpenStream(SCHEMA_STREAM, &cbData, &pbData)) &&
            hr != STG_E_FILENOTFOUND)
        {
            goto ErrExit;
        }
        // Get a pointer to the on disk schema data.
        else if (SUCCEEDED(hr))
        {
            // Count is first long, followed by one byte for every schema
            // index override, then the real schema data.
            m_iSchemas = (int) *(ULONG *) pbData;
            if (m_iSchemas)
            {
                m_rgSchemaList = (BYTE *) pbData + sizeof(ULONG);
                pstgSchema = (STGSCHEMA *) ((BYTE *) pbData + ALIGN4BYTE(sizeof(ULONG) + m_iSchemas));
            }
            // If there are no schema overrides, then just pointer.
            else
            {
                m_rgSchemaList = 0;
                pstgSchema = (STGSCHEMA *) ((BYTE *) pbData + sizeof(ULONG));
            }
        }

        // Read the extra data from the file if it is there.
        if (SUCCEEDED(hr = pStorage->GetExtraData(&cbExtra, (BYTE *&) pExtra)))
        {
            // Extra data will always include flags and next oid.
            if (cbExtra >= sizeof(ULONG) + sizeof(OID) + sizeof(ULONG))
            {
				if (pExtra->fFlags & DBPROP_TMODEF_ALIGNBLOBS)
				{
					m_UserSchema.pBlobPool->SetAligned(true);
				}

                // Make sure if the file wants complus schema, that it is added,
                // even if the caller didn't specify it.
                if (pExtra->fFlags & DBPROP_TMODEF_COMPLUS)
                {
                    pStgIO->SetFlags(pStgIO->GetFlags() | DBPROP_TMODEF_COMPLUS);
                    bCoreSchema = true;
                }

				// Save off the hash function that should be used.  Do not 
				// silently upgrade the format, because the file may get distributed
				// to an old machine where the new format is not supported.
				m_pfnHash = GetPersistHashMethod(pExtra->iHashFuncIndex);
				if (!m_pfnHash)
				{
					hr = PostError(CLDB_E_SCHEMA_VERNOTFOUND, pExtra->iHashFuncIndex, L"hash index");
					goto ErrExit;
				}

                // Save off the next OID value to avoid duplicates.
                m_iNextOid = pExtra->NextOid;

                // If there is schema data, then we need to add them at this time.
                if (cbExtra > sizeof(ULONG) + sizeof(OID) + sizeof(ULONG) &&
                    FAILED(hr = AddSchemasRefsFromFile(pExtra)))
                {
                    goto ErrExit;
                }
            }
            // If there was no data, the file is corrupt.
            else
            {
                hr = PostError(CLDB_E_FILE_CORRUPT);
                goto ErrExit;
            }
        }
        else
            goto ErrExit;

        // Init the schemas to match the data from disk.        
        if (FAILED(hr = InitSchemaLoad(pStgIO->GetFlags(), pstgSchema, 
                        bReadOnly, bCoreSchema, m_iSchemas, m_rgSchemaList)))
            goto ErrExit;

        // Record the open mode of the file.
        m_fFlags = SD_READ | SD_OPENED | SD_EXISTS;
        if (!bReadOnly)
            m_fFlags |= SD_WRITE;
    }
    // Check for create of a new file.
    else
    {
        // Can't do a create without asking for write mode.
        if (pStgIO && pStgIO->IsReadOnly())
        {
            hr = PostError(STG_E_INVALIDFLAG);
            goto ErrExit;
        }

        // Init the schemas to the default list.
        if (FAILED(hr = InitSchemaLoad(fFlags, 0, false, bCoreSchema)))
            goto ErrExit;

        // Just save the thing off,
        m_fFlags = SD_WRITE | SD_READ | SD_OPENED | SD_CREATE;

        // Create a comp library record if need be.
        if (bCoreSchema)
        {
            OID         oid;
            hr = NewOid(&oid);
        }

		if (fFlags & DBPROP_TMODEF_ALIGNBLOBS)
		{
			m_UserSchema.pBlobPool->SetAligned(true);
		}
    }

ErrExit:
    // On failure, free the storage object.
    if (FAILED(hr))
        delete pStorage;
    // Save the storage pointer.
    else if (pStorage)
        m_pStorage = pStorage;
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgdbrecords.cpp ===
//*****************************************************************************
// StgDBRecords.cpp
//
// This module contains the init code for loading a database.  This includes
// the code to detect file formats, dispatch to the correct import/load code,
// and anything else required to bootstrap the schema into place.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Precompiled header.
#include "StgDatabase.h"				// Database definitions.
#include "StgIO.h"						// Generic i/o class.
#include "StgTiggerStorage.h"			// Storage implementation.
//#include "ImpTlb.h"						// Type lib importer.



//****** Types. ***************************************************************
#define SMALL_TABLE_HEAP			1024
#define SMALL_TABLE_HEAP_TOTAL		65536
#define MIN_VIRTM_SIZE				65536



//****** Code. ****************************************************************

//*****************************************************************************
// Allocates a new record heap for a table.  If the heap allocation request 
// can be satisified using the small table heap, then it will be allocated
// from that heap.  If there isn't enough room, or the size requested is too
// large, then a VMStructArray will be allocated and returned.
//*****************************************************************************
HRESULT StgDatabase::GetRecordHeap(		// Return code.
	ULONG		Records,				// How many records to allocate room for.
	int			iRecordSize,			// How large is each record.
	ULONG		InitialRecords,			// How many records to automatically reserve.
	int			bAllocateHeap,			// True:  allocate heap and return in *ppHeap
										// False: Use heap in *ppHeap, no allocation.
	RECORDHEAP	**ppHeap,				// Return new heap here.
	ULONG		*pRecordTotal)			// Return how many records we allocated space for.
{
	unsigned __int64 cbTotalSize;		// Maximum size required.
	void		*pbData = 0;			// New allocated data.
	HRESULT		hr = S_OK;

	// Avoid any confusion.
	_ASSERTE(ppHeap);
	_ASSERTE(bAllocateHeap || *ppHeap);

	// Allocate a heap right up front if need be.
	if (bAllocateHeap)
	{
		*ppHeap = new RECORDHEAP;
		if (!*ppHeap)
		{
			hr = PostError(OutOfMemory());
			goto ErrExit;
		}
	}
	(*ppHeap)->pNextHeap = 0;

	// Figure out the total size required for all the records.
	cbTotalSize = Records * iRecordSize;

	// First try the small table heap.
	if (cbTotalSize < SMALL_TABLE_HEAP)
	{
		// Allocate the small table heap if it has not already been allocated.
		if ((m_fFlags & SD_TABLEHEAP) == 0)
		{
			// Initialize the heap with virtual memory to suballocate.
			hr = m_SmallTableHeap.InitNew(
					SMALL_TABLE_HEAP_TOTAL / SMALL_TABLE_HEAP,
					SMALL_TABLE_HEAP, 0, 0);

			if (SUCCEEDED(hr))
				m_fFlags |= SD_TABLEHEAP;
			else
				goto ErrExit;
		}
		
		// Allocate room from this heap.
		pbData = m_SmallTableHeap.Append();

		// If there was room in the small heap, then initialize a new heap on it.
		if (pbData)
		{
			// Init the record heap on top of the record heap.
			hr = (*ppHeap)->VMArray.InitOnMem(pbData, SMALL_TABLE_HEAP, 
					InitialRecords, iRecordSize, false);
			
			// If there was a failure, delete the allocated space.
			if (FAILED(hr))
				m_SmallTableHeap.Delete(m_SmallTableHeap.ItemIndex(pbData));
			goto ErrExit;
		}
	}

	// There wasn't enough room on the small table heap, so allocate a stand
	// alone Virtual Memory array.
	
	// Virtual memory always allocates a 64kb chunk, even if you ask for
	// less.  So allocate at least 64kb for use in this stand alone heap.
	if (cbTotalSize < MIN_VIRTM_SIZE)
		Records = MIN_VIRTM_SIZE / iRecordSize;
	
	// Allocate a new Virtual Memory heap for memory.  Force a full heap to return an
	// error (the VMSA_NOMEMMOVE flag), so that records don't move and we
	// have the chance to chain a new heap in.
	hr = (*ppHeap)->VMArray.InitNew(Records, iRecordSize, InitialRecords, VMStructArray::VMSA_NOMEMMOVE);
	if (FAILED(hr))
		goto ErrExit;

ErrExit:
	// Record successful status.
	if (SUCCEEDED(hr))
	{
		// If caller wants count of records, then return it for them.
		if (pRecordTotal)
			*pRecordTotal = (*ppHeap)->VMArray.GetCapacity();
	}
	// On error, clean up anything allocated we won't use.
	else
	{
		if (*ppHeap)
		{
			(*ppHeap)->VMArray.Clear();
			if (bAllocateHeap)
				delete *ppHeap;
		}
	}
	return (hr);
}


//*****************************************************************************
// Free both the virtual memory and each record heap item starting with the 
// item passed to this function.  pRecordHeap is no longer valid after this
// function is run.
//*****************************************************************************
void StgDatabase::FreeRecordHeap(		// Return code.
	RECORDHEAP	*pRecordHeap)			// Item to free.
{
	// Recursive escape hatch.
	if (!pRecordHeap)
		return;

	// Recurse to the next heap.
	FreeRecordHeap(pRecordHeap->pNextHeap);

	// Free the virtual memory allocated for this heap.
	FreeHeapData(pRecordHeap);
	delete pRecordHeap;
}


//*****************************************************************************
// Free the record data for a record heap.  This involves clearing any
// suballocated records from the heap, and then checking to see if the
// underlying heap data was part of the small table heap.  If the latter, 
// then free the entry so another table can use it eventually.
//*****************************************************************************
void StgDatabase::FreeHeapData(
	RECORDHEAP	*pRecordHeap)			// The heap to free.
{
	int			Index;					// Index on small heap.

	// If the small table heap was never allocated, cannot free from it.
	if ((m_fFlags & SD_TABLEHEAP) == 0)
		Index = -1;
	// Determine if heap is in the small table heap.
	else
		Index = m_SmallTableHeap.ValidItemIndex(pRecordHeap->VMArray.Ptr());

	// Free up the entries we've suballocated.
	pRecordHeap->VMArray.Clear();

	// If this heap was in the small table heap, then free its memory so
	// that another heap can use it.
	if (Index >= 0)
		m_SmallTableHeap.Delete(Index);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgicr.cpp ===
//*****************************************************************************
// StgICR.cpp
//
// This is stripped down code which implements IComponentRecords and
// ICompRecordsLibrary required internally by the COR runtime.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h" 					// Standard header.
#include "StgSchema.h"					// Core schema defs.
#include "StgDatabase.h"				// Database definitions.
#include "StgRecordManager.h"			// Record api.
#include "StgIO.h"						// Storage api.
#include "StgTiggerStorage.h"			// Storage subsystem.
#include "OleDBUtil.h"					// Binding helpers.
#include "DBSchema.h"					// Default schema and bindings.



//********** Macros. **********************************************************

// If this is turned on, then you will get tracing messages for the struct funcs.
//#define _STRUCT_DEBUG
#if defined( _STRUCT_DEBUG ) && defined( _DEBUG )
#define STRUCT_TRACE(func) (func)
#else
#define STRUCT_TRACE(func)
#endif

// Tracing code for leaked cursors.
#ifdef _DEBUG
struct DBG_CURSOR
{
	CRCURSOR	*pCursor;
	ULONG		cRecords;
	char		rcFile[_MAX_PATH];
	int			line;
	DBG_CURSOR	*pNext;
};
DBG_CURSOR *g_pDbgCursorList = 0;
static void AddCursorToList(CRCURSOR *pCursor, const char *szFile, int line);
static void DelCursorFromList(CRCURSOR *pCursor);
extern "C" BOOL CheckCursorList();
#endif



//********** Locals. **********************************************************

HRESULT GetThreadSafeICR(int bReadOnly, IComponentRecords *pICR, REFIID riid, PVOID *ppIface);


//*****************************************************************************
// Check to see it the newDataSize can be accomodated while maintaining the
// required byteAlignment.
//*****************************************************************************
inline int NeedsAlignment(
	ULONG		byteAlignment,			// chosen byte alignment (typically 4 or 8)
	ULONG		cbOffset,				// current offset into the structure.
	ULONG		newDataSize)			// next field size.
{
	_ASSERTE(byteAlignment > 0);
	
	if (((cbOffset % byteAlignment) != 0) && 
		(newDataSize > (byteAlignment - (cbOffset % byteAlignment))))
	{
		return (TRUE);
	}
	return (FALSE);
}

//*****************************************************************************
// Account the required padding to ensure the required byteAlignment.
//*****************************************************************************
inline void DoAlignment(
	ULONG		byteAlignment,			// chosen byte alignment.
	ULONG		*cbOffset)				// current offset into the structure.
{
	_ASSERTE(byteAlignment > 0);
	_ASSERTE(cbOffset != NULL);

	*cbOffset += byteAlignment - (*cbOffset % byteAlignment);
}




//********** Code. ************************************************************

//
// IUnknown
//

//*****************************************************************************
// This is an internal version which therefore does very little error checking.
// You may only call it with the list of interfaces given, and only the first
// 4 bytes will be checked to speed up the navigation.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::QueryInterface(REFIID riid, PVOID *pp)
{
	HRESULT 	hr = S_OK;

	if (riid == IID_IUnknown)
	{
		*pp = (PVOID) (IUnknown *) (IComponentRecords *) this;
		AddRef();
	}
	else if (riid == IID_IComponentRecords)
	{
		*pp = (PVOID) (IComponentRecords *) this;
		AddRef();
	}
	else if (riid == IID_IComponentRecordsSchema)
	{
		*pp = (PVOID) (IComponentRecordsSchema *) this;
		AddRef();
	}
	else if (riid == IID_ITSComponentRecords)
	{
		hr = GetThreadSafeICR(IsReadOnly(), (IComponentRecords *) this, riid, pp);
	}
	else if (riid == IID_ITSComponentRecordsSchema)
	{
		hr = GetThreadSafeICR(IsReadOnly(), (IComponentRecords *) this, riid, pp);
	}
	else
	{
		_ASSERTE(!"QueryInterface on non-implemented interface");
		hr = E_NOINTERFACE;
	}
	return (hr);
}





//
//
// IComponentRecords
//	Note on locking:  This interface does not lock because anyone coming through
//	ICR should be serialized at the object level. The only hole left is a client
//	calling through the object layer and OLE DB simultaneously.  This is 
//	a restriction.
//
//


//*****************************************************************************
// Allow the user to query open/create flags.
//*****************************************************************************
HRESULT StgDatabase::GetOpenFlags(
	DWORD		*pdwFlags)
{
	*pdwFlags = m_fOpenFlags;
	return (S_OK);
}

//*****************************************************************************
// Allow the user to provide a custom handler.  The purpose of the handler
//  may be determined dynamically.  Initially, it will be for save-time 
//  callback notification to the caller.
//*****************************************************************************
HRESULT StgDatabase::SetHandler(
	IUnknown	*pHandler)				// The handler.
{
	// Currently there is only one handler, so just store it and its flags.
	//  A future implementation might need to QI for supported interfaces
	//  and take appropriate action.

	// If there is an existing handler, release it.
	if (m_pHandler)
		m_pHandler->Release();

	// Update our pointer.  If there is a new handler, addref it.
	m_pHandler = pHandler;
	if (m_pHandler)
		m_pHandler->AddRef();

	return S_OK;
}

//*****************************************************************************
// This version will simply tell the record manager to allocate a new (but empty)
// record and return a pointer to it.  The caller must take extreme care to set
// only fixed size values and go through helpers for everything else.
//*****************************************************************************
HRESULT StgDatabase::NewRecord( 		// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	void		**ppData,				// Return new record here.
	OID 		_oid,					// ID of the record.
	ULONG		iOidColumn, 			// Ordinal of OID column.
	ULONG		*pRecordID, 			// Optionally return the record id.
	BYTE		fFlags) 				// optional flag to mark records.
{
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// If an OID was given, then do the insert.
	if (iOidColumn != 0)
	{
		const void	*rgOid[] = { &_oid };

		hr = pOpenTable->RecordMgr.InsertRowWithData(fFlags, pRecordID,
					(STGRECORDHDR **) ppData, 
					COLUMN_ORDINAL_LIST(1), g_rgDBTypeOID, 
					rgOid, g_rgcbSizeOID, 0, 
					0, &iOidColumn);
	}
	// Insert an empty record.  If you get back out a primary key error,
	// it means the primary key data has to be supplied with the set.
	else
	{
		hr = pOpenTable->RecordMgr.InsertRowWithData(fFlags, pRecordID,
					(STGRECORDHDR **) ppData, 0, 0, 0, 0, 0, 0, 0);
	}
	return (hr);
}


HRESULT StgDatabase::NewRecord( 		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	void		**ppData,				// Return new record here.
	OID 		_oid,					// ID of the record.
	ULONG		iOidColumn, 			// Ordinal of OID column.
	ULONG		*pRecordID) 			// Optionally return the record id.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Pull back the correct definitions.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = NewRecord(pOpenTable, ppData, _oid, iOidColumn, pRecordID);
	return (hr);
}


HRESULT StgDatabase::NewTempRecord( 		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	void		**ppData,				// Return new record here.
	OID 		_oid,					// ID of the record.
	ULONG		iOidColumn, 			// Ordinal of OID column.
	ULONG		*pRecordID) 			// Optionally return the record id.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Pull back the correct definitions.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = NewRecord(pOpenTable, ppData, _oid, iOidColumn, pRecordID, RECORDF_TEMP);
	return (hr);
}


//*****************************************************************************
// This function will insert a new record into the given table and set all of
// the data for the columns.  In cases where a primary key and/or unique indexes
// need to be specified, this is the only function that can be used.
//*****************************************************************************
HRESULT StgDatabase::NewRecordAndData(	// Return code.
	TABLEID 	tableid,				// Which table to work on.
	void		**ppData,				// Return new record here.
	ULONG		*pRecordID, 			// Optionally return the record id.
	int			fFlags,					// ICR_RECORD_xxx value, 0 default.
	int 		iCols,					// number of columns
	const DBTYPE rgiType[], 			// data types of the columns.
	const void	*rgpbBuf[], 			// pointers to where the data will be stored.
	const ULONG cbBuf[],				// sizes of the data buffers.
	ULONG		pcbBuf[],				// size of data available to be returned.
	HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
	const ULONG *rgFieldMask)			// IsOrdinalList(iCols) 
										//	? an array of 1 based ordinals
										//	: a bitmask of columns
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	STGRECORDFLAGS fRecordFlags = 0;	// Flags for new record.
	STGRECORDHDR *pNewRecord = 0;		// The new created record.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Pull back the correct definitions.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Update flags if needed.
	if (fFlags & ICR_RECORD_TEMP)
		fRecordFlags = RECORDF_TEMP;

	// Insert a new, empty record into the table.  Do not index it.
	hr = pOpenTable->RecordMgr.InsertRowWithData(fRecordFlags, pRecordID,
				&pNewRecord, iCols, rgiType, rgpbBuf, cbBuf, pcbBuf, 
				rgResult, rgFieldMask);

	// Return a pointer to the new record, which might be null on error.
	*ppData = pNewRecord;
	return (hr);
}


//*****************************************************************************
// Generic function to retrieve data in the provided buffer.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::GetData(
	STGOPENTABLE	*pOpenTable,		// pointer to the open table.
	STGCOLUMNDEF	*pColDef,			// column def pointer
	ULONG			columnOrdinal,		// column, 1-based,
	const void		*pRowPtr,			// row pointer
	ULONG			dataTypeSize,		// size of data tranafer.
	byte			*destAddr,			// out buffer.
	ULONG			*pcbLength) 		// Return length retrieved.
{
	const BYTE	*pbBlob;			// For blob retreival.
	ULONG			cbBlob; 			// Size of blob.
	HRESULT 		hr = S_OK;

	_ASSERTE(pOpenTable && pColDef && pRowPtr && destAddr);
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRowPtr));

	switch(pColDef->iType)
	{
	case DBTYPE_VARIANT:
		hr = GetVARIANT(pOpenTable, columnOrdinal, pRowPtr, (VARIANT *) destAddr);
		break;
		
	case DBTYPE_BYTES:
		hr = GetBlob(pOpenTable, columnOrdinal, pRowPtr, &pbBlob, &cbBlob);
		if (SUCCEEDED(hr))
		{
			_ASSERTE(pcbLength);
			*pcbLength = cbBlob;
			memcpy(destAddr, pbBlob, cbBlob);
		}
		break;
		
	case DBTYPE_STR:
	case DBTYPE_WSTR:
		hr = GetStringW(pOpenTable, columnOrdinal, pRowPtr, (LPWSTR) destAddr, 
			static_cast<int>(dataTypeSize), reinterpret_cast<int*>(pcbLength));
		break;			
		
	case DBTYPE_OID:
		hr = GetOid(pOpenTable, columnOrdinal, pRowPtr, (OID *) destAddr);
		if (pcbLength)
			*pcbLength = sizeof(OID);
		break;

	case DBTYPE_GUID:
		hr = GetGuid(pOpenTable, columnOrdinal, pRowPtr, reinterpret_cast<GUID*>(destAddr));
		if (SUCCEEDED(hr) && pcbLength)
		{
			*pcbLength = sizeof(GUID);
		}
		break;

	default:
		_ASSERTE(dataTypeSize == pColDef->iSize);
		if (!pColDef->IsRecordID())
		{
			memcpy((void*)destAddr, (void *)((BYTE *) pRowPtr + pColDef->iOffset), dataTypeSize);
			if (pcbLength)
				*pcbLength = dataTypeSize;
		}
		else
		{
			*(ULONG *) destAddr = pOpenTable->RecordMgr.GetRecordID((STGRECORDHDR *) pRowPtr);
		}
		break;
	}

	return (hr);
}


//*****************************************************************************
// Generic function to set the data from the provided buffer.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::SetData(
	STGOPENTABLE	*pOpenTable,		// pointer to the open table.
	STGCOLUMNDEF	*pColDef,			// column def pointer
	ULONG			columnOrdinal,		// column, 1-based,
	byte			*srcAddr,			// source data pointer
	ULONG			dataTypeSize,		// size of data tranafer.
	DBTYPE			srcType,			// Type of actual data.
	void			*pRowPtr)			// row pointer
{
	HRESULT 		hr = S_OK;

	// Good database row?
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRowPtr));

	// Can't set a RID column since it doesn't really exist.
	_ASSERTE(pColDef->IsRecordID() == false);
	if (pColDef->IsRecordID())
		return (E_INVALIDARG);

	// Now test for type to set.
	switch (pColDef->iType)
	{
	case DBTYPE_VARIANT:
		_ASSERTE(srcType == DBTYPE_VARIANT);
		hr = PutVARIANT(pOpenTable, columnOrdinal, pRowPtr, (VARIANT *) srcAddr);
		break;
					
	case DBTYPE_BYTES:
		_ASSERTE(srcType == DBTYPE_BYTES);
		if (dataTypeSize > pColDef->iMaxSize && pColDef->iMaxSize != USHRT_MAX)
			return (CLDB_S_TRUNCATION);
		hr = PutBlob(pOpenTable, columnOrdinal, pRowPtr, srcAddr, dataTypeSize);
		break;
	
	// All strings in the database are stored in the heap, in the same format (UTF8).
	case DBTYPE_STR:
	case DBTYPE_WSTR:
		// Call appropriate PutString* based on the source data type.
		//@todo: put truncation check code back in post m3
		switch (srcType)
		{
		case DBTYPE_STR:
			hr = PutStringA(pOpenTable, columnOrdinal, pRowPtr, (LPCSTR) srcAddr, (int) dataTypeSize);
			break;
		case DBTYPE_WSTR:
			hr = PutStringW(pOpenTable, columnOrdinal, pRowPtr, (LPCWSTR) srcAddr, (int) dataTypeSize);
			break;
		case DBTYPE_UTF8:
			hr = PutStringUtf8(pOpenTable, columnOrdinal, pRowPtr, (LPCSTR) srcAddr, (int) dataTypeSize);
			break;
		default:
			hr = PostError(BadError(E_INVALIDARG));
			break;
		}
		break;
					
	case DBTYPE_OID:
		_ASSERTE(srcType == DBTYPE_OID);
		hr = PutOid(pOpenTable, columnOrdinal, pRowPtr,*((OID *)srcAddr));
		break;
					
	case DBTYPE_GUID:
		_ASSERTE(srcType == DBTYPE_GUID);
		hr = PutGuid(pOpenTable, columnOrdinal, pRowPtr, *((GUID*)srcAddr));
		break;

	default:
		_ASSERTE(dataTypeSize == pColDef->iMaxSize);
		if (pColDef->IsNullable())
			pOpenTable->RecordMgr.SetCellNull((STGRECORDHDR *)pRowPtr, columnOrdinal - 1, FALSE);
		memcpy((void *)((BYTE *)pRowPtr + pColDef->iOffset), (void*)srcAddr, dataTypeSize);
	}

	return (hr);
}


//*****************************************************************************
// Map a data type to it size. This function is provided here since the array lookup in 
// grDataTypes is very expensive.
//*****************************************************************************
inline USHORT StgDatabase::GetSizeFromDataType( 
	STGCOLUMNDEF *pColDef,
	DBTYPE		iType)
{
	USHORT retSize;

	if (DBTYPE_VARIANT == iType)
	{
		retSize = sizeof(VARIANT);
	}
	else if (IsPooledType(iType))
	{
		// @:todo -- WSTR, STR, BSTR need to handled differently after we figure out how to 
		// handle heaped data types.
		retSize = 4;
	}
	else
	{
		retSize = pColDef->iSize;
	}

	return (retSize);
}

//*****************************************************************************
// GetStruct 
//		Retrieve the fields specified by fFieldMask, for the array of iRows row pointers
//		of size cbRowStruct and place it into the memory chunk pointed to by rgpbBuf.
//		rgResult[] is any array of the HRESULTs for each row if the user is interested in 
//		knowing. 
//		The function will bail bail out on the first error. In this case it is the 
//		responsibility of the user to walk through the rgResults[] array to figure out
//		when the error happened. Warnings generated by the lower level functions are placed
//		rgResults[] array, but the function continues with the next row.
//
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::GetStruct(	//Return Code
	TABLEID 	tableid,				// Which table to work on.
	int 		iRows,					// number of rows for bulk fetch.
	void		*rgpRowPtr[],			// pointer to array of row pointers.
	int 		cbRowStruct,			// size of <table name>_RS structure.
	void		*rgpbBuf,				// pointer to the chunk of memory where the
										// retrieved data will be placed.
	HRESULT 	rgResult[], 			// array of HRESULT for iRows.
	ULONG		fFieldMask) 			// mask to specify a subset of fields, -1 for all.
{
	return E_NOTIMPL;	
}


//*****************************************************************************
// SetStruct:
//		given an array of iRows row pointers, set the data the user provided in the
//		specified fields of the row. cbRowStruct has been provided
//		to be able to embed the RowStruct (as defined by pagedump) in a user defined structure.
//		fNullFieldMask specifies fields that the user wants to set to NULL.
//		The user provides rgResult[] array if interested in the outcome of each row.
//
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::SetStruct(	// Return Code
	TABLEID 	tableid,				// table to work on.
	int 		iRows,					// number of Rows for bulk set.
	void		*rgpRowPtr[],			// pointer to array of row pointers.
	int 		cbRowStruct,			// size of <table name>_RS struct.
	void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
	HRESULT 	rgResult[], 			// array of HRESULT for iRows.
	ULONG		fFieldMask, 			// mask to specify a subset of the fields, -1 for all.
	ULONG		fNullFieldMask) 		// fields that need to be set to null.
{
	return E_NOTIMPL;
}


//*****************************************************************************
// InsertStruct:
//		Creates new records first and then calls SetStruct.
//		See SetStruct() for details on the parameters.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::InsertStruct(	// Return Code
	TABLEID 	tableid,				// table to work on.
	int 		iRows,					// number of Rows for bulk set.
	void		*rgpRowPtr[],			// Return pointer to new values.
	int 		cbRowStruct,			// size of <table name>_RS struct.
	void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
	HRESULT 	rgResult[], 			// array of HRESULT for iRows.
	ULONG		fFieldMask, 			// mask to specify a subset of the fields.
	ULONG		fNullFieldMask) 		// fields which need to be set to null, -1 for all
{
	return E_NOTIMPL;	
}



//*****************************************************************************
// Similar to GetStruct(), this function retrieves the specified columns 
// of 1 record pointer. The major difference between GetColumns() and 
// GetStruct() is that GetColumns() let's the caller specify a individual 
// buffer for each field. Hence, the caller does not have to allocate the row 
// structure like you would with GetStruct(). Refer to the GetStruct() header 
// for details on the parameters.
//
// fFieldMask can be one of two types.	If you apply the COLUMN_ORDINAL_LIST
// macro to the iCols parameter, then fFieldMask points to an array of 
// ULONG column ordinals.  This consumes more room, but allows column ordinals
// greater than 32.  If the macro is not applied to the count, then fFieldMask
// is a pointer to a bitmaks of columns which are to be touched.  Use the
// SetColumnBit macro to set the correct bits.
//
// DBTYPE_BYREF may be given for the data type on the get.	In this case, 
// rgpbBuf will the address of an array of void * pointers that will be filled
// out with pointers to the actual data for the column.  These pointers point
// to the internal data structures of the engine and must never be written to.
// If the column was null, then the pointer value will be set to NULL.	Finally,
// the pcbBuf entry for the column contains the length of the data pointed to
// by rgpbBuf.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::GetColumns(	// Return code.
	TABLEID 	tableid,				// table to work on.
	const void	*pRowPtr,				// row pointer
	int 		iCols,					// number of columns.
	const DBTYPE rgiType[], 			// data types of the columns.
	const void	*rgpbBuf[], 			// pointers to where the data will be stored.
	ULONG		cbBuf[],				// sizes of the data buffers.
	ULONG		pcbBuf[],				// size of data available to be returned.
	HRESULT 	rgResult[], 			// array of HRESULT for iCols.
	const ULONG *rgFieldMask)			// An array of 0 based ordinals
										
{
	STGOPENTABLE *pOpenTable;			// Open table instance.
	STGTABLEDEF *pTableDef; 			// Table definition.
	STGCOLUMNDEF *pColDef;				// Per column definition.
	int 		bColumnList;			// true if a column list is given.
	ULONG		dataTypeSize;			// Size of the data type for a column.
	ULONG		cbData; 				// Length of data on get.
	int 		colCounter; 			// Escape hatch for total columns in table.
	int 		columnOrdinal;			// 0 based column ordinal.
	HRESULT 	hr = S_OK;
	int			iTarget;				// Where in rgpbBuf and pcbBuf to put the data
										// I'm using the same semantics as IST.

	// Validate state.
	_ASSERTE(pRowPtr != NULL);
	_ASSERTE(rgpbBuf != NULL);

	iCols = iCols & ~COLUMN_ORDINAL_MASK;
	
	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		goto ErrExit;

	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRowPtr));

	// Get column description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());

	_ASSERTE(iCols > 0 && iCols <= pTableDef->iColumns);

	for (colCounter=0; colCounter < iCols; colCounter++)
	{
		// For a field mask, get the next valid value and check if it is set.
		
		if (rgFieldMask)
			columnOrdinal = rgFieldMask[colCounter];
		else
			columnOrdinal = colCounter;

		if ( iCols > 1 )
			iTarget = columnOrdinal;
		else
			iTarget = 0;


		// Get the column description and the size of the data type for the column. 	
		VERIFY(pColDef = pTableDef->GetColDesc(columnOrdinal));
		dataTypeSize = GetSizeFromDataType(pColDef, pColDef->iType);

	
		if ( IsNonPooledType(pColDef->iType) )
		{
			//Get non-pooled type column
			if ( pColDef->IsNullable() && GetBit((BYTE *) pTableDef->NullBitmask((STGRECORDHDR *)pRowPtr),
				 pColDef->iNullBit) != 0 )
			{	// If the column can have nulls and is null, record that fact.
				rgpbBuf[iTarget] = NULL;

				hr = DBSTATUS_S_ISNULL;
				cbData = 0;
			}
			else
			{
				rgpbBuf[iTarget] = pOpenTable->RecordMgr.FindColCellOffset(pColDef, (STGRECORDHDR *)pRowPtr);
				cbData = pColDef->iSize;

				hr = S_OK;
			}
		}
		else	//Get pooled type column
		{
			rgpbBuf[iTarget] = pOpenTable->RecordMgr.GetColCellData(
					pColDef, (STGRECORDHDR *) pRowPtr, &cbData);

			if ( !rgpbBuf[iTarget] )
			{
				_ASSERTE( pColDef->IsNullable() );
			
				hr = DBSTATUS_S_ISNULL;
				cbData = 0;
			}
			else
			{
				//Adjust the size to include NULL terminator.
				if ( pColDef->iType == DBTYPE_WSTR )
					cbData += sizeof(WCHAR);
				hr = S_OK;
			}
		}
		

		if (rgResult)
			rgResult[colCounter] = hr;

		if (pcbBuf)
			pcbBuf[iTarget] = cbData;

		if (FAILED(hr))
			break;
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Similar to SetStruct(), this function puts the specified columns of 1 record
// pointer. The major difference between SetColumns() and SetStruct() is that 
// SetColumns() let's the caller specify a individual buffer for each field. 
// Hence, the caller does not have to allocate the row structure like you would 
// with SetStruct(). Refer to the SetStruct() hearder for details on the 
// parameters.
//
// fFieldMask can be one of two types.	If you apply the COLUMN_ORDINAL_LIST
// macro to the iCols parameter, then fFieldMask points to an array of 
// ULONG column ordinals.  This consumes more room, but allows column ordinals
// greater than 32.  If the macro is not applied to the count, then fFieldMask
// is a pointer to a bitmaks of columns which are to be touched.  Use the
// SetColumnBit macro to set the correct bits.
//
// DBTYPE_BYREF is not allowed by this function since this function must 
// always make a copy of the data for it to be saved to disk with the database.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::SetColumns(	// Return code.
	TABLEID 	tableid,				// table to work on.
	void		*pRowPtr,				// row pointer
	int 		iCols,					// number of columns
	const DBTYPE rgiType[], 			// data types of the columns.
	const void	*rgpbBuf[], 			// pointers to where the data will be stored.
	const ULONG cbBuf[],				// sizes of the data buffers.
	ULONG		pcbBuf[],				// size of data available to be returned.
	HRESULT 	rgResult[], 			// array of HRESULT for iCols.
	const ULONG *rgFieldMask)			// IsOrdinalList(iCols) 
										//	? an array of 1 based ordinals
										//	: a bitmask of columns
{
	STGOPENTABLE *pOpenTable;			// Open table instance.
	HRESULT		hr;

	// Validate state.
	_ASSERTE((iCols & ~COLUMN_ORDINAL_MASK) > 0);
	_ASSERTE(pRowPtr != NULL);
	_ASSERTE(rgpbBuf != NULL);
	_ASSERTE(cbBuf != NULL);
	_ASSERTE(pcbBuf != NULL);
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		goto ErrExit;

	// Let the record manager update the data.
	hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRowPtr, 
					iCols, rgiType, rgpbBuf, cbBuf, pcbBuf, 
					rgResult, rgFieldMask);

ErrExit:
	return (hr);
}


HRESULT StgDatabase::GetRecordCount(	
	TABLEID 	tableid,				// Which table to work on.
	ULONG		*piCount)				// Not including deletes.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Pull back the correct definitions.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	*piCount = pOpenTable->RecordMgr.Records();
	return (hr);
}



HRESULT StgDatabase::GetRowByOid(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	OID 		_oid,					// Value for keyed lookup.
	ULONG		iColumn,				// 1 based column number (logical).
	void		**ppStruct) 			// Return pointer to record.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	QUERYINDEX	rgIndex[1]; 			// Hint to lookup by OID column.
	QUERYINDEX	*prgIndex = rgIndex;	// Pointer to the hint.
	DBCOMPAREOP fCompare = DBCOMPAREOPS_EQ; // Operator for equality.
	HRESULT 	hr;

	CFetchRecords sFetch((STGRECORDHDR **) ppStruct, 1);

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Avoid confusion.
	*ppStruct = 0;

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Create a binding for the user data.
	::BindCol(&rgBinding[0], iColumn, 0, sizeof(OID), DBTYPE_OID);

	// Fill out the hint for the OID column.
	rgIndex[0].iType = QI_PK;
	rgIndex[0].pIIndex = 0;

	// Let query code run the rest, the column is in the binding.
	hr = pOpenTable->RecordMgr.QueryRowsExecute(&sFetch, 1, rgBinding,
			1, &fCompare, &_oid, sizeof(OID), &prgIndex);

	// Map record not found.
	if (sFetch.Count() == 0)
		return (CLDB_E_RECORD_NOTFOUND);
	return (hr);
}


HRESULT StgDatabase::GetRowByRID(		// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		rid,					// Record id.
	void		**ppStruct) 			// Return pointer to record.
{
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Should not be asking for record entries by RID unless you have a
	// RID column in the schema.
	_ASSERTE(pOpenTable->RecordMgr.GetTableDef()->HasRIDColumn());

	//@todo: range check RID in question.  GetRecord only does assert
	// and should continue to do so for speed reasons.

	// Ask for the record.	Caller makes sure it is valid.
	rid = pOpenTable->RecordMgr.IndexForRecordID(rid);
	
	// Check for a deleted record.
	if (pOpenTable->RecordMgr.GetRecordFlags(rid) & RECORDF_DEL)
		return (PostError(CLDB_E_RECORD_DELETED));

	// Retrieve the record.
	*ppStruct = (void *) pOpenTable->RecordMgr.GetRecord(&rid);
	if (*ppStruct)
		hr = S_OK;
	else
		hr = CLDB_E_RECORD_NOTFOUND;
	return (hr);
}


HRESULT StgDatabase::GetRowByRID(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		rid,					// Record id.
	void		**ppStruct) 			// Return pointer to record.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Ask for the record.	Caller makes sure it is valid.
	rid = pOpenTable->RecordMgr.IndexForRecordID(rid);
	
	// Check for a deleted record.
	if (pOpenTable->RecordMgr.GetRecordFlags(rid) & RECORDF_DEL)
		return (CLDB_E_RECORD_DELETED);

	// Retrieve the record.
	*ppStruct = (void *) pOpenTable->RecordMgr.GetRecord(&rid);
	if (*ppStruct)
		hr = S_OK;
	else
		hr = CLDB_E_RECORD_NOTFOUND;
	return (hr);
}


HRESULT StgDatabase::GetRIDForRow(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	const void	*pRecord,				// The record we want RID for.
	ULONG		*pirid) 				// Return the RID for the given row.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Ask for the record.	Caller makes sure it is valid.
	*pirid = pOpenTable->RecordMgr.GetRecordID((STGRECORDHDR *) pRecord);
	return (S_OK);
}


//*****************************************************************************
// This function allows a faster path to find records that going through
// OLE DB.	Rows found can be returned in one of two ways:	(1) if you know
// how many should be returned, you may pass in a pointer to an array of
// record pointers, in which case rgRecords and iMaxRecords must be non 0.
// (2) If the count of records is unknown, then pass in a record list in
// pRecords and all records will be dynamically added to this list.
//*****************************************************************************
HRESULT _GetRowByColumn(				// S_OK, CLDB_E_RECORD_NOTFOUND, error.
	STGOPENTABLE *pOpenTable,			// new table.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pData, 				// User data.
	ULONG		cbData, 				// Size of data (blobs)
	DBTYPE		iType,					// What type of data given.
	void		*rgRecords[],			// Return array of records here.
	int 		iMaxRecords,			// Max that will fit in rgRecords.
	RECORDLIST	*pRecords,				// If variable rows desired.
	int 		*piFetched) 			// How many records were fetched.
{
	CRecordList sRecords;				// For record mapping.
	CRecordList *pRecordList;			// For record fetch.
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	int 		i=0;					// Loop control.
	HRESULT 	hr;

	// Figure out how we will fetch records.
	if (rgRecords)
		pRecordList = 0;
	else
		pRecordList = &sRecords;
	CFetchRecords sFetch(pRecordList, (STGRECORDHDR **) rgRecords, iMaxRecords);

	// Put user data in a contiguous layout (that works on all platforms).
	struct USERDATA
	{
		const void	*pData;
		ULONG		cbData;
	} sData;
	sData.pData = pData;
	sData.cbData = cbData;

	// Either you get the static array back, or you get a dynamic list.
	// You cannot ask for both.
	_ASSERTE((rgRecords != 0 && iMaxRecords > 0) || (pRecords != 0));
	_ASSERTE(!(rgRecords != 0 && pRecords != 0));

	// If a filter column is given, then bind and get rows.
	if (iColumn != 0xffffffff)
	{
		// Create a binding for the user data.
		if (SUCCEEDED(hr = ::BindCol(&rgBinding[0], iColumn, offsetof(USERDATA, pData),
					offsetof(USERDATA, cbData), sizeof(void *), iType | DBTYPE_BYREF)))
		{
			// Retrieve the record(s).
			hr = pOpenTable->RecordMgr.GetRow(&sFetch, rgBinding,
					1, &sData, 0, 0, DBRANGE_MATCH);
		}
	}
	// Else user wants to do their own scan, so get all records.
	else
	{
		hr = pOpenTable->RecordMgr.GetRow(&sFetch, 0,
				0, 0, 0, 0, DBRANGE_MATCH);
	}

	// Check for failure, cleanup, and go home.
	if (FAILED(hr))
		return (hr);

	// Add each record to the dynamic array.
	if (pRecordList)
	{
		void	**ppRecord;
		for (i=0;  i<sRecords.Count();	i++)
		{
			if ((ppRecord = pRecords->Append()) == 0)
			{
				hr = PostError(OutOfMemory());
				break;
			}
			*ppRecord = (void *) pOpenTable->RecordMgr.GetRecord(&sRecords[i].RecordID);
		}
	}
	else
		i = sFetch.Count();

	// Return fetch count if asked for.
	if (piFetched)
		*piFetched = i;

	// Look for any errors.
	if (FAILED(hr))
		return (hr);
	else if (i == 0)
		return (CLDB_E_RECORD_NOTFOUND);
	return (S_OK);
}

	
//*****************************************************************************
// This function allows a faster path to find records that going through
// OLE DB.	Rows found can be returned in one of two ways:	(1) if you know
// how many should be returned, you may pass in a pointer to an array of
// record pointers, in which case rgRecords and iMaxRecords must be non 0.
// (2) If the count of records is unknown, then pass in a record list in
// pRecords and all records will be dynamically added to this list.
//*****************************************************************************
HRESULT StgDatabase::GetRowByColumn(	// S_OK, CLDB_E_RECORD_NOTFOUND, error.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pData, 				// User data.
	ULONG		cbData, 				// Size of data (blobs)
	DBTYPE		iType,					// What type of data given.
	void		*rgRecords[],			// Return array of records here.
	int 		iMaxRecords,			// Max that will fit in rgRecords.
	RECORDLIST	*pRecords,				// If variable rows desired.
	int 		*piFetched) 			// How many records were fetched.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	int 		i=0;					// Loop control.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	return _GetRowByColumn(pOpenTable, iColumn, pData, cbData, iType, rgRecords,
				iMaxRecords, pRecords, piFetched);
}




//*****************************************************************************
// This query function allows you to do lookups on one or more column at a 
// time.  It does not expose the full OLE DB view-filter mechanism which is
// very flexible, but rather exposes multiple column AND conditions with
// equality.  A record must match all of the criteria to be returned to 
// in the cursor.
//
// User data - For each column, rgiColumn, rgpbData, and rgiType contain the 
//		pointer information to the user data to filter on.
//
// Query hints - Queries will run faster if it is known that some of the 
//		columns are indexed.  While there is code in the engine to scan query
//		lists for target indexes, this internal function bypasses that code in
//		favor of performance.  If you know that a column is a RID or PK, or that
//		there is an index, then these columns need to be the first set passed
//		in.  Fill out a QUERYHINT and pass this value in.  Pass NULL if you
//		know there is no index information, and the table will be scanned.
//
//		Note that you may follow indexes columns with non-indexed columns,
//		in which case all records in the index are found first, and then those
//		are scanned for the rest of the criteria.
//
// Returned cursor - Data may be returned in two mutually exclusive ways:
//		(1) Pass an array of record pointers in rgRecords and set iMaxRecords
//			to the count of this array.  Only that many rows are brought back.
//			This requires to heap allocations and is good for cases where you
//			can predict cardinality up front.
//		(2) Pass the address of a CRCURSOR to get a dynamic list.  Then use
//			the cursor functions on this interface to fetch data and close
//			the cursor.
//*****************************************************************************
HRESULT StgDatabase::QueryByColumns(	// S_OK, CLDB_E_RECORD_NOTFOUND, error.
	TABLEID 	tableid,				// Which table to work with.
	const QUERYHINT *pQryHint,			// What index to use, NULL valid.
	int 		iColumns,				// How many columns to query on.
	const ULONG rgiColumn[],			// 1 based column numbers.
	const DBCOMPAREOP rgfCompare[], 	// Comparison operators, NULL means ==.
	const void	*rgpbData[],			// User data.
	const ULONG rgcbData[], 			// Size of data (blobs)
	const DBTYPE rgiType[], 			// What type of data given.
	void		*rgRecords[],			// Return array of records here.
	int 		iMaxRecords,			// Max that will fit in rgRecords.
	CRCURSOR	*psCursor,				// Buffer for the cursor handle.
	int 		*piFetched) 			// How many records were fetched.
{
	CRecordList *pRecordList;			// For record fetch.
	CRecordList sRecords;				//
	STGOPENTABLE *pOpenTable;			// For the new table.
	STGTABLEDEF *pTableDef; 			// Definition for table.
	STGINDEXDEF *pIndexDef=0;			// Index definition object.
	STGCOLUMNDEF *pColDef;				// Column definition.
	DBBINDING	*rgBinding; 			// To get pointer to the string.
	PROVIDERDATA *rgData;				// Contiguous data layouts.
	DBCOMPAREOP *rgfTempComp;			// Temporary comparison structs.
	DBTYPE		iBindType;				// Data type for binding.
	QUERYINDEX	sIndex; 				// Index hint if known.
	QUERYINDEX	*pQryIndex = &sIndex;	// If there is a hint.
	void		**rgConvert=0;			// Conversion data buffer, if allocated.
	ULONG		iOffset;				// For binding setups.
	int 		i=0;					// Loop control.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Special case no filter data.  Caller just wants a cursor with all data.
	if (iColumns == 0)
	{
		// It is possible to pass in rgRecords for a full scan, but this is
		// dangerous and I don't know why we'd do it.
		_ASSERTE(psCursor);

		// Force ctor to init cursor.
		new (&psCursor->sRecords) RECORDLIST;
		psCursor->iIndex = 0;

		// Get all records then clean up and quit.
		hr = pOpenTable->RecordMgr.QueryAllRecords(psCursor->sRecords);

		// Return count if need be.
		if (piFetched)
			*piFetched = psCursor->sRecords.Count();

		DEBUG_STMT(AddCursorToList(psCursor, __FILE__, __LINE__));
		return (hr);
	}

	// Figure out how we will fetch records.	
	if (rgRecords)
		pRecordList = 0;
	else
		pRecordList = &sRecords;
	CFetchRecords sFetch(pRecordList, (STGRECORDHDR **) rgRecords, iMaxRecords);

	// If there are going to be huge queries sent through ICR, then
	// we need to rethink allocating control structures on the stack.
	_ASSERTE(iColumns < 5);

	// Allocate room for control structures, don't use heap.
	rgData = (PROVIDERDATA *) _alloca(sizeof(PROVIDERDATA) * iColumns);
	rgBinding = (DBBINDING *) _alloca(sizeof(DBBINDING) * iColumns);
	if (!rgfCompare)
	{
		rgfTempComp = (DBCOMPAREOP *) _alloca(sizeof(DBCOMPAREOP) * iColumns);
		rgfCompare = rgfTempComp;

		// All comparisons are done via equality in this case.
		for (i=0;  i<iColumns;	i++)
			rgfTempComp[i] = DBCOMPAREOPS_EQ;
	}

	// For each column, create a contiguous binding array for data.
	for (i=0, iOffset=0;  i<iColumns;  i++, iOffset += sizeof(PROVIDERDATA))
	{
		// Fill out the provider data to match.  iStatus is being overloaded
		// to track conversion allocated memory.
		rgData[i].iStatus = S_OK;

		// Check for query of the NULL value.
		if (SafeDBType(rgiType[i]) == DBTYPE_NULL)
		{
			// Verify the column allows nulls.	If it doesn't, then you can't query
			// for them.  The only fuzzy area here is col != NULL, which technically 
			// if it isn't NULL is all of the records.	We're disallowing that case.
			_ASSERTE(pOpenTable->RecordMgr.GetTableDef()->GetColDesc(rgiColumn[i] - 1)->IsNullable());

			// No data to work with, set status only.
			iBindType = DBTYPE_NULL;
			rgData[i].pData = 0;
			rgData[i].iLength = 0;
			rgData[i].iStatus = DBSTATUS_S_ISNULL;
		}
		// Handle OID column specially because of its variable sized nature.
		// Convert it in place to a ULONG.
		else if (SafeDBType(rgiType[i]) == DBTYPE_OID)
		{
			*(ULONG *) &rgData[i].pData = *(ULONG *) rgpbData[i];
			iBindType = DBTYPE_UI4;
			rgData[i].iLength = rgcbData[i];
		}
		// For all other types, just copy the pointer.
		else
		{
			rgData[i].pData = (void *) rgpbData[i];
			iBindType = rgiType[i] | DBTYPE_BYREF;

			if ((SafeDBType(iBindType) == DBTYPE_STR || SafeDBType(iBindType) == DBTYPE_UTF8) && 
					rgcbData[i] == 0xffffffff)
				rgData[i].iLength = (ULONG) strlen((const char *) rgpbData[i]);
			else if ( SafeDBType(iBindType) == DBTYPE_WSTR )
				rgData[i].iLength = (ULONG) wcslen((LPWSTR)rgpbData[i])*sizeof(WCHAR); 
			else
				rgData[i].iLength = rgcbData[i];
		}

		// Bind the column accesor.
		::BindCol(&rgBinding[i], rgiColumn[i], 
					iOffset + offsetof(PROVIDERDATA, pData),
					iOffset + offsetof(PROVIDERDATA, iLength), 
					iOffset + offsetof(PROVIDERDATA, iStatus),
					sizeof(void *), iBindType);
	}

	// If an index hint was given, then fill it out.
	if (pQryHint)
	{
		_ASSERTE(pQryHint->iType == QH_COLUMN || pQryHint->iType == QH_INDEX);

		// Need the table definition to find other data.
		VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());

		// If it is a column, then fill out our index definition.
		if (pQryHint->iType == QH_COLUMN)
		{
			// If this is a multi-column primary key, then it is implemented as
			// a unique hashed index under the covers.	Need to create a QUERYINDEX
			// for the real index itself.
			if (pQryHint->columnid == QUERYHINT_PK_MULTICOLUMN)
			{
				// Walk each index definition looking for the multi-pk index.
				pIndexDef = pTableDef->GetIndexDesc(0);
				for (i=pTableDef->iIndexes;  i;  )
				{
					// If primary key is set, then use this one.
					if (pIndexDef->fFlags & DEXF_PRIMARYKEY)
						break;

					// Get next index in the list.
					if (--i)
						pIndexDef = pIndexDef->NextIndexDef();
				}

				// Check for the pk not being found with is a programming error
				// when using the ICR interface.  This will work as a table scan,
				// but will yield very bad performance.
				if (i <= 0)
				{
					_ASSERTE(0 && "Hinted mulit-column PK index not found");
					pIndexDef = 0;
				}
			}
			// It is a single column primary key.  Need to lookup the column with
			// the index and setup up the query index for the record manager.
			else
			{
				// Only RID's and primary keys can be given as hints.
				VERIFY(pColDef = pTableDef->GetColDesc(pQryHint->columnid - 1));
				if (pColDef->IsRecordID())
				{
					sIndex.iType = QI_RID;
				}
				else
				{
					_ASSERTE(pColDef->IsPrimaryKey());
					sIndex.iType = QI_PK;
				}

				// There will always be one binding and no indexes in this case.
				sIndex.pIIndex = 0;
			}
		}
		// Has to be an index.
		else
		{
			_ASSERTE(pQryHint->iType == QH_INDEX);

			// Load the index definition.
			VERIFY(pIndexDef = pOpenTable->RecordMgr.GetIndexDefByName(pQryHint->szIndex));
		}

		// If there is an index definition at this point, then we will be using it
		// for the query.  This will be either (a) when a multiple column pk was
		// given and converted to the index, or (b) when the user simply gave us the
		// index name to begin with.
		if (pIndexDef)
		{
			// See if it is actually loaded, it might not be.
			sIndex.pIIndex = pOpenTable->RecordMgr.GetLoadedIndex(pIndexDef);
			if (sIndex.pIIndex)
			{
				if (pIndexDef->fIndexType == IT_HASHED)
					sIndex.iType = QI_HASH;
				else
					sIndex.iType = QI_SORTED;

				// For debug, verify that the index keys match the values passed
				// in, in order, and the types have to be the same.
				#ifdef _DEBUG
				{
					for (int idex=0;  idex<pIndexDef->iKeys;  idex++)
					{
						// The first set of columns passed in must match index.
						_ASSERTE(pIndexDef->rgKeys[idex] == rgiColumn[idex]);

						DBTYPE iColType = pTableDef->GetColDesc(rgiColumn[idex] - 1)->iType;
						if (iColType == DBTYPE_OID)
							iColType = DBTYPE_UI4;

						// The data must not require conversion.
						if (iColType != SafeDBType(rgBinding[idex].wType) &&
							iColType != DBTYPE_WSTR)
						{
							_ASSERTE(!"Data type mismatch for index lookup.");
						}
					}
				}
				#endif
			}
			// If not loaded, then there is no hint to pass.
			else
				pQryHint = 0;
		}
	}

	// Either you get the static array back, or you get a dynamic list.
	// You cannot ask for both.
	_ASSERTE((rgRecords != 0 && iMaxRecords > 0) || (psCursor != 0));
	_ASSERTE(!(rgRecords == 0 && psCursor == 0));

	// Query for the records.
	hr = pOpenTable->RecordMgr.QueryRowsExecute(&sFetch, iColumns,
			rgBinding, 1, (DBCOMPAREOP *) rgfCompare, rgData, 
			sizeof(PROVIDERDATA) * iColumns, pQryHint ? &pQryIndex : 0);
	
	if (pRecordList)
	{
		void	**ppRecord;

		new (&psCursor->sRecords) RECORDLIST;

		psCursor->iIndex = 0;

		for (i=0;  i<sRecords.Count();	i++)
		{
			if ((ppRecord = psCursor->sRecords.Append()) == 0)
			{
				hr = PostError(OutOfMemory());
				break;
			}
			if (ppRecord)
				*ppRecord = (void *) pOpenTable->RecordMgr.GetRecord(&sRecords[i].RecordID);
		}

		DEBUG_STMT(AddCursorToList(psCursor, __FILE__, __LINE__));
	}

ErrExit:
	// Return count if need be.
	if (piFetched)
		*piFetched = sFetch.Count();

	// Free any allocated memory used for conversion.
	if (rgConvert)
	{
		for (i=0;  i<iColumns;	i++)
		{
			if (rgConvert[i])
				free(rgConvert[i]);
		}
	}

	// Map no records into a return code.
	if (SUCCEEDED(hr) && sFetch.Count() == 0)
		return (CLDB_E_RECORD_NOTFOUND);
	return (hr);
}


HRESULT StgDatabase::OpenCursorByColumn(// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pData, 				// User data.
	ULONG		cbData, 				// Size of data (blobs)
	DBTYPE		iType,					// What type of data given.
	CRCURSOR	*psCursor)				// Buffer for the cursor handle.
{
	int 		iFetched;
	HRESULT 	hr;

	new (&psCursor->sRecords) RECORDLIST;

	if (FAILED(hr = GetRowByColumn(tableid, iColumn, pData, cbData, iType, NULL, 0x7fffffff,
					&psCursor->sRecords, &iFetched)))
		return (hr);

	psCursor->iIndex = 0;
	DEBUG_STMT(AddCursorToList(psCursor, __FILE__, __LINE__));
	return (S_OK);
}


//*****************************************************************************
// Reads the next set of records from the cursor into the given buffer.
//*****************************************************************************
HRESULT StgDatabase::ReadCursor(		// Return code.
	CRCURSOR	*psCursor,				// The cursor handle.
	void		*rgRecords[],			// Return array of records here.
	int 		*piRecords) 			// Max that will fit in rgRecords.
{
	_ASSERTE(psCursor && rgRecords && piRecords);
	*piRecords = min(*piRecords, psCursor->sRecords.Count() - psCursor->iIndex);
	memcpy(rgRecords, psCursor->sRecords.Ptr() + psCursor->iIndex, *piRecords * sizeof(void *));
	psCursor->iIndex += *piRecords;
	if (!*piRecords)
		return (CLDB_E_RECORD_NOTFOUND);
	return (S_OK);
}

//*****************************************************************************
// Move the cursor location to the index given.  The next ReadCursor will start
// fetching records at that index.
//*****************************************************************************
HRESULT StgDatabase::MoveTo(			// Return code.
	CRCURSOR	*psCursor,				// The cursor handle.
	ULONG		iIndex) 				// New index.
{
	_ASSERTE(psCursor);
	_ASSERTE(iIndex < (ULONG) psCursor->sRecords.Count());
	psCursor->iIndex = iIndex;
	return (S_OK);
}


//*****************************************************************************
// Get the count of items in the cursor.
//*****************************************************************************
HRESULT StgDatabase::GetCount(			// Return code.
	CRCURSOR	*psCursor,				// The cursor handle.
	ULONG		*piCount)				// Return the count.
{
	_ASSERTE(psCursor && piCount);
	*piCount = psCursor->sRecords.Count();
	return (S_OK);
}

//*****************************************************************************
// Close the cursor and clean up the resources we've allocated.
//*****************************************************************************
HRESULT StgDatabase::CloseCursor(		// Return code.
	CRCURSOR	*psCursor)				// The cursor handle.
{
	_ASSERTE(psCursor);
	psCursor->sRecords.Clear();
	DEBUG_STMT(DelCursorFromList(psCursor));
	return (S_OK);
}


//*****************************************************************************
// Get a pointer to string data.  The pointer will be to the raw UTF8 string.
//
// This is the fundamental string access function upon which the others are
//	built.
//*****************************************************************************
HRESULT StgDatabase::GetStringUtf8( 	// Return code.
	STGOPENTABLE	*pOpenTable,		// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	LPCSTR		*pszOutBuffer)			// Where to write string.
{
	return E_NOTIMPL;
}


//*****************************************************************************
// Get a string in ANSI, into the caller's buffer.	May require an expensive 
//	conversion from UTF8 encoded characters.
//*****************************************************************************
HRESULT StgDatabase::GetStringA(		// Return code.
	STGOPENTABLE	*pOpenTable,		// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	LPSTR		szOutBuffer,			// Where to write string.
	int 		cchOutBuffer,			// Max size, including room for \0.
	int 		*pchString) 			// Size of string is put here.
{
	LPCSTR		szString;				// UTF8 version.
	LPCSTR		szFrom; 				// Update pointer for copy.
	LPSTR		szTo;					// Update pointer for copy.
	int 		cbTo;					// Update counter for copy.
	int 		iSize;					// Size of resulting string, in bytes.
	HRESULT 	hr;

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Get a pointer to the string.
	if (FAILED(hr = GetStringUtf8(pOpenTable, iColumn, pRecord, &szString)) ||
		hr == DBSTATUS_S_ISNULL)
	{
		return (hr);
	}

	// Copy to output buffer.  If high-bit characters are found, call system 
	//	conversion functions.
	szFrom = szString;
	szTo = szOutBuffer;
	cbTo = cchOutBuffer;
	while (*szFrom && cbTo)
	{
		// If high-bit character, convert.	If out of space, convert, since there
		//	may yet be high-bit characters.
		if ((*szTo++ = *szFrom++) & 0x80 || --cbTo == 0)
		{
			// Local buffer for conversion.
			CQuickBytes rBuf;

			// Allocate an intermediate buffer.  Max size is one W char per input char.
			LPWSTR szW = reinterpret_cast<LPWSTR>(rBuf.Alloc(iSize = (int) ((strlen(szString)+1) * sizeof(WCHAR))));
			if (szW == 0)
				return (PostError(OutOfMemory()));

			// UTF8 -> Unicode.
			iSize=::W95MultiByteToWideChar(CP_UTF8, 0, szString, -1, szW, iSize);
			if (iSize == 0)
				return (BadError(HRESULT_FROM_NT(GetLastError())));

			// Unicode->Ansi
			if (!(iSize=::W95WideCharToMultiByte(CP_ACP, 0, szW, -1, szOutBuffer, cchOutBuffer, 0, 0)))
			{
				// What was the problem?
				DWORD dwNT = GetLastError();
				// Not truncation?
				if (dwNT != ERROR_INSUFFICIENT_BUFFER)
					return (BadError(PostError(HRESULT_FROM_NT(dwNT))));

				// Truncation error; get the size required.
				if (pchString)
					*pchString = ::W95WideCharToMultiByte(CP_ACP, 0, szW, -1, 0, 0, 0, 0);

				return (CLDB_S_TRUNCATION);
			}
			// Give size of string back to caller.
			if (pchString)
				*pchString = iSize;

			return (S_OK);
		}
	}

	*szTo = '\0';

	// How big was the string?
	if (pchString)
		*pchString = cchOutBuffer - cbTo;

	return (S_OK);
}


//*****************************************************************************
// Get a string in Unicode, into the caller's buffer.  Required translation
//	from UTF8.
//*****************************************************************************
HRESULT StgDatabase::GetStringW(		// Return code.
	STGOPENTABLE	*pOpenTable,		// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	LPWSTR		szOutBuffer,			// Where to write string.
	int 		cchOutBuffer,			// Max size, including room for \0.
	int 		*pchString) 			// Size of string is put here.
{
	LPCSTR		szString;				// Single byte version.
	int 		iSize;					// Size of resulting string, in wide chars.
	HRESULT 	hr;

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	if (FAILED(hr = GetStringUtf8(pOpenTable, iColumn, pRecord, &szString)) ||
		hr == DBSTATUS_S_ISNULL)
	{
		return (hr);
	}
	if (!(iSize=::W95MultiByteToWideChar(CP_UTF8, 0, szString, -1, szOutBuffer, cchOutBuffer)))
	{
		// What was the problem?
		DWORD dwNT = GetLastError();
		// Not truncation?
		if (dwNT != ERROR_INSUFFICIENT_BUFFER)
			return (BadError(PostError(HRESULT_FROM_NT(dwNT))));

		// Truncation error; get the size required.
		if (pchString)
			*pchString = ::W95MultiByteToWideChar(CP_UTF8, 0, szString, -1, szOutBuffer, 0);

		return (CLDB_S_TRUNCATION);
	}
	if (pchString)
		*pchString = iSize;
	return (S_OK);
}


//*****************************************************************************
// Get a pointer to string data.  The pointer will be to the raw UTF8 string.
//*****************************************************************************
HRESULT StgDatabase::GetStringUtf8( 	// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	LPCSTR		*pszOutBuffer)			// Where to write string.

{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = GetStringUtf8(pOpenTable, iColumn, pRecord, pszOutBuffer);
	return (hr);
}


//*****************************************************************************
// Get a string in Ansi, into the caller's buffer.
//*****************************************************************************
HRESULT StgDatabase::GetStringA(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	LPSTR		szOutBuffer,			// Where to write string.
	int 		cchOutBuffer,			// Max size, including room for \0.
	int 		*pchString) 			// Size of string is put here.
{
	STGOPENTABLE *pOpenTable;			// Open Table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = GetStringA(pOpenTable, iColumn, pRecord, szOutBuffer, cchOutBuffer, pchString);
	return (hr);
}


//*****************************************************************************
// Get a string in Unicode, into the caller's buffer.
//*****************************************************************************
HRESULT StgDatabase::GetStringW(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	LPWSTR		szOutBuffer,			// Where to write string.
	int 		cchOutBuffer,			// Max size, including room for \0.
	int 		*pchString) 			// Size of string is put here.
{
	STGOPENTABLE *pOpenTable;			// Open Table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = GetStringW(pOpenTable, iColumn, pRecord, szOutBuffer, cchOutBuffer, pchString);
	return (hr);
}


//*****************************************************************************
// Get a string as a BSTR.
//*****************************************************************************
HRESULT StgDatabase::GetBstr(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	BSTR		*pBstr) 				// Output for bstring on success.
{
	LPCSTR		szString;				// Single byte version.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Get UTF8 string pointer.
	if (FAILED(hr = GetStringUtf8(tableid, iColumn, pRecord, &szString)))
		return (hr);
	
	// Make into a BSTR.
	if (hr != DBSTATUS_S_ISNULL)
	{
		if ((*pBstr = ::Utf8StringToBstr(szString)) == 0)
			return (PostError(OutOfMemory()));
	}
	else
	{
		*pBstr = 0;
	}
	return (S_OK);
}


//*****************************************************************************
// Get a blob into the caller's buffer.
//*****************************************************************************
HRESULT StgDatabase::GetBlob(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	BYTE		*pOutBuffer,			// Where to write blob.
	ULONG		cbOutBuffer,			// Size of output buffer.
	ULONG		*pcbOutBuffer)			// Return amount of data available.
{
	HRESULT 	hr; 					// A result.
	const BYTE *pData; 				// Pointer to data retrieved here.
	ULONG		cbData; 				// Size of the data retrieved here.

	// Get the blob.
	if (FAILED(hr = GetBlob(tableid, iColumn, pRecord, &pData, &cbData)))
		return (hr);

	// Copy as much as there is or will fit.
	if (pData)
		memcpy(pOutBuffer, pData, min(cbData, cbOutBuffer));

	// Tell user how much there is.
	*pcbOutBuffer = cbData;

	// If caller didn't give enough space for the whole buffer, set appropriate return code.
	if (cbData > cbOutBuffer)
		return (CLDB_S_TRUNCATION);

	return (S_OK);
}


//*****************************************************************************
// Get a pointer and size for a blob.
//*****************************************************************************
HRESULT StgDatabase::GetBlob(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	const BYTE	**ppBlob,				// Pointer to blob.
	ULONG		*pcbSize)				// Size of blob.
{
	HRESULT 	hr;
	STGOPENTABLE *pOpenTable=0; 		// For the new table.
	BYTE		*pColData;				// Pointer to pool offset in record.
	int 		bNull;					// true for null column.
	ULONG		iOffset;				// Offset in heap.
	STGTABLEDEF *pTableDef; 			// Describes a table.
	STGCOLUMNDEF *pColDef;				// Describes a column.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Get column description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));

	// Make sure column is correct type.
	_ASSERTE(pColDef->iType == DBTYPE_BYTES);

	// Get a pointer to where this offset lives.
	pColData = (BYTE *) pRecord + pColDef->iOffset;
	_ASSERTE(pColData);

	// Get the heap offset from the record, and check for null value.
	if (pColDef->iSize == sizeof(short))
	{
		bNull = (*(USHORT *) pColData == 0xffff);
		iOffset = *(USHORT *) pColData;
	}
	else
	{
		bNull = (*(ULONG *) pColData == 0xffffffff);
		iOffset = *(ULONG *) pColData;
	}

	// If a null column, set out params to 0.
	if (bNull)
	{
		*ppBlob = 0;
		*pcbSize = 0;
		return (S_OK);
	}	 

	// This will get the blob.
	SCHEMADEFS *pSchemaDefs = pOpenTable->RecordMgr.GetSchema();
	*ppBlob = reinterpret_cast<BYTE*>(pSchemaDefs->GetBlobPool()->GetBlob(iOffset, pcbSize));

	return ( S_OK );
}


HRESULT StgDatabase::GetOid(			// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	OID 		*poid)					// Return id here.
{
	STGTABLEDEF *pTableDef; 			// Table definition.
	STGCOLUMNDEF *pColDef;				// Column definition.
	BYTE		*pColData;				// Column data based on defintion.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Get column description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));

	// Make some assumptions to speed things up.
	_ASSERTE(pColDef->iType == DBTYPE_OID);

	// If column allows nulls, then check for null value.
	if (pColDef->IsNullable())
	{
		if (pOpenTable->RecordMgr.GetCellNull((STGRECORDHDR *) pRecord, iColumn - 1))
		{
			*poid = ~0;
			return (CLDB_S_NULL);
		}
	}

	// Get a pointer to where this data lives.
	pColData = (BYTE *) pRecord + pColDef->iOffset;
	_ASSERTE(pColData);

	// Copy the correct number of bytes based on format, 0 extend if need be.
	if (!pColDef->IsRecordID())
	{
		if (pColDef->iSize == sizeof(short))
			*poid = (OID) (*(USHORT *) pColData);
		else
			*poid = *(OID *) pColData;
	}
	// The RID is the OID in this case.
	else
	{
		*poid = pOpenTable->RecordMgr.GetRecordID((STGRECORDHDR *) pRecord);
	}

	// These mean that you got a null oid and this funtion wasn't written
	// to like those.
	_ASSERTE(*poid != 0xffffffff);
	_ASSERTE(!(*poid == 0x0000ffff && pColDef->iSize == sizeof(short)));
	return (S_OK);
}


HRESULT StgDatabase::GetOid(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	OID 		*poid)					// Return id here.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = GetOid(pOpenTable, iColumn, pRecord, poid);
	return (hr);
}


HRESULT StgDatabase::GetVARIANT(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	VARIANT 	*pValue)				// The variant to write.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	hr = GetVARIANT(pOpenTable, iColumn, pRecord, pValue);

	return (hr);
}

HRESULT StgDatabase::GetVARIANT(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	const void	**ppBlob,				// Pointer to blob.
	ULONG		*pcbSize)				// Size of blob.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	hr = GetVARIANT(pOpenTable, iColumn, pRecord, ppBlob, pcbSize);

	return (hr);
}

HRESULT StgDatabase::GetVARIANTType(	// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	VARTYPE 	*pType) 				// The VARTYPE of the variant.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	hr = GetVARIANTType(pOpenTable, iColumn, pRecord, pType);

	return (hr);
}

HRESULT StgDatabase::GetGuid(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	GUID		*pguid) 				// Put Guid here.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = GetGuid(pOpenTable, iColumn, pRecord, pguid);

	return (hr);
}

HRESULT StgDatabase::GetGuid(			// Return code.
	STGOPENTABLE *pOpenTable,			// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	GUID		*pguid) 				// Put Guid here.
{
	BYTE		*pColData;
	int 		bNull;					// true for null column.
	ULONG		iIndex; 				// Offset in heap.
	STGTABLEDEF *pTableDef;
	STGCOLUMNDEF	*pColDef;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Get column description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));

	// Get a pointer to where this data lives.
	pColData = (BYTE *) pRecord + pColDef->iOffset;
	_ASSERTE(pColData);

	// Get the heap offset from the record, and check for null value.
	if (pColDef->iSize == sizeof(short))
	{
		bNull = (*(USHORT *) pColData == 0xffff);
		iIndex = (ULONG) *(USHORT *) pColData;
	}
	else
	{
		bNull = (*(ULONG *) pColData == 0xffffffff);
		iIndex = *(ULONG *) pColData;
	}

	if (bNull)
		*pguid = GUID_NULL;
	else
	{
		SCHEMADEFS *pSchemaDefs = pOpenTable->RecordMgr.GetSchema();
		*pguid = *pSchemaDefs->GetGuidPool()->GetGuid(iIndex);
	}
	return (S_OK);
}



HRESULT StgDatabase::IsNull(			// S_OK yes, S_FALSE no.
	TABLEID 	tableid,				// Which table to work with.
	const void	*pRecord,				// Record with data.
	ULONG		iColumn)				// 1 based column number (logical).
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Do a get data only on status.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	
	// Let record manager read null status.
	if (pOpenTable->RecordMgr.GetCellNull((STGRECORDHDR *) pRecord, iColumn - 1))
		hr = S_OK;
	else
		hr = S_FALSE;
	return (hr);
}



//*****************************************************************************
// Put a UTF8 string into a column.
//*****************************************************************************
HRESULT StgDatabase::PutStringUtf8( 	// Return code.
	STGOPENTABLE *pOpenTable,			// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	LPCSTR		szString,				// String we are writing.
	int 		cbBuffer)				// Bytes in string, -1 null terminated.
{
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	STGTABLEDEF *pTableDef;
	STGCOLUMNDEF *pColDef;
	BYTE		rgBuf[4];
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Setup a struct we can using for bindings, with contiguous memory.
	struct STRINGDATA
	{
		LPCSTR	szString;
		ULONG	cbString;
		ULONG	iStatus;
	} rgData[1];
	rgData[0].iStatus = S_OK;
	rgData[0].szString = szString;
	if (cbBuffer != -1)
		rgData[0].cbString = cbBuffer;
	else
		rgData[0].cbString = (ULONG) strlen(szString);

	// Set the value for this column to the new string.
	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, offsetof(STRINGDATA, szString),
				offsetof(STRINGDATA, cbString), offsetof(STRINGDATA, iStatus), 
				sizeof(LPCSTR), DBTYPE_UTF8 | DBTYPE_BYREF)))
	{
		goto ErrExit;
	}

	// back up the data first.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));
	memcpy(rgBuf, (BYTE *) pRecord + pColDef->iOffset, pColDef->iSize);

	if (FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) &rgData[0], 1, rgBinding, 0, true)))
	{
		// recover the data in this case.
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalBeforeUpdate(
				pTableDef, 1, &pRecord, 1, rgBinding));

		memcpy((BYTE*)pRecord+pColDef->iOffset, rgBuf, pColDef->iSize);
		
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalAfterUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));

		// Status mapping for overflow.
		if (rgData[0].iStatus == DBSTATUS_E_DATAOVERFLOW)
			hr = CLDB_E_TRUNCATION;

		goto ErrExit;
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Put an Ansi string into a column.
//*****************************************************************************
HRESULT StgDatabase::PutStringA(		// Return code.
	STGOPENTABLE *pOpenTable,			// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	LPCSTR		szString,				// String we are writing.
	int 		cbBuffer)				// Bytes in string, -1 null terminated.
{
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	STGTABLEDEF *pTableDef;
	STGCOLUMNDEF *pColDef;
	BYTE		rgBuf[4];
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Setup a struct we can using for bindings, with contiguous memory.
	struct STRINGDATA
	{
		LPCSTR	szString;
		ULONG	cbString;
		ULONG	iStatus;
	} rgData[1];
	rgData[0].iStatus = S_OK;
	rgData[0].szString = szString;
	if (cbBuffer != -1)
		rgData[0].cbString = cbBuffer;
	else
		rgData[0].cbString = (ULONG) strlen(szString);

	// Set the value for this column to the new string.
	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, offsetof(STRINGDATA, szString),
				offsetof(STRINGDATA, cbString), offsetof(STRINGDATA, iStatus), 
				sizeof(LPCSTR), DBTYPE_STR | DBTYPE_BYREF)))
	{
		goto ErrExit;
	}

	// back up the data first.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));
	memcpy(rgBuf, (BYTE *) pRecord + pColDef->iOffset, pColDef->iSize);

	if (FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) &rgData[0], 1, rgBinding, 0, true)))
	{
		// recover the data in this case.
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalBeforeUpdate(
				pTableDef, 1, &pRecord, 1, rgBinding));

		memcpy((BYTE*)pRecord+pColDef->iOffset, rgBuf, pColDef->iSize);
		
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalAfterUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));
				 
		// Status mapping for overflow.
		if (rgData[0].iStatus == DBSTATUS_E_DATAOVERFLOW)
			hr = CLDB_E_TRUNCATION;

		goto ErrExit;
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Put a Unicode string into a column.
//*****************************************************************************
HRESULT StgDatabase::PutStringW(		// Return code.
	STGOPENTABLE *pOpenTable,			// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	LPCWSTR 	szString,				// String we are writing.
	int 		cbBuffer)				// Bytes (not characters) in string, -1 null terminated.
{
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	STGTABLEDEF *pTableDef;
	STGCOLUMNDEF *pColDef;
	BYTE		rgBuf[4];
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Setup a struct we can using for bindings, with contiguous memory.
	struct STRINGDATA
	{
		LPCWSTR 	szString;
		ULONG		cbString;
		ULONG		iStatus;
	} rgData[1];
	rgData[0].iStatus = S_OK;
	rgData[0].szString = szString;
	if (cbBuffer != -1)
		rgData[0].cbString = cbBuffer;
	else
		rgData[0].cbString = (ULONG) (wcslen(szString) * sizeof(WCHAR));

	// Set the value for this column to the new string.
	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, offsetof(STRINGDATA, szString),
				offsetof(STRINGDATA, cbString), offsetof(STRINGDATA, iStatus), 
				sizeof(LPCWSTR), DBTYPE_WSTR | DBTYPE_BYREF)))
	{
		goto ErrExit;		
	}	

	// back up the data first.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));
	memcpy(rgBuf, (BYTE *) pRecord + pColDef->iOffset, pColDef->iSize);

	if (FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) &rgData[0], 1, rgBinding, 0, true)))
	{
		// recover the data in this case.
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalBeforeUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));				

		memcpy((BYTE*)pRecord+pColDef->iOffset, rgBuf, pColDef->iSize);
	
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalAfterUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));

		// Status mapping for overflow.
		if (rgData[0].iStatus == DBSTATUS_E_DATAOVERFLOW)
			hr = CLDB_E_TRUNCATION;

		goto ErrExit;
	}	

ErrExit:
	return (hr);
}


//*****************************************************************************
// Open a table and put a UTF8 string into a column.
//*****************************************************************************
HRESULT StgDatabase::PutStringUtf8( 	// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	LPCSTR		szString,				// String we are writing.
	int 		cbBuffer)				// Bytes in string, -1 null terminated.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	hr = QuickOpenTable(pOpenTable, tableid);
	if(FAILED(hr))
		goto ErrExit;
	
	hr = PutStringUtf8(pOpenTable, iColumn, pRecord, szString, cbBuffer);
	if(FAILED(hr))
		goto ErrExit;

ErrExit:
	return (hr);
}	

//*****************************************************************************
// Open a table and put an Ansi string into a column.
//*****************************************************************************
HRESULT StgDatabase::PutStringA(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	LPCSTR		szString,				// String we are writing.
	int 		cbBuffer)				// Bytes in string, -1 null terminated.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	hr = QuickOpenTable(pOpenTable, tableid);
	if(FAILED(hr))
		goto ErrExit;
	
	hr = PutStringA(pOpenTable, iColumn, pRecord, szString, cbBuffer);
	if(FAILED(hr))
		goto ErrExit;

ErrExit:
	return (hr);
}	

//*****************************************************************************
// Open a table and put a Unicode string into a column.
//*****************************************************************************
HRESULT StgDatabase::PutStringW(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	LPCWSTR 	szString,				// String we are writing.
	int 		cbBuffer)				// Bytes (not characters) in string, -1 null terminated.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	hr = QuickOpenTable(pOpenTable, tableid);
	if(FAILED(hr))
		goto ErrExit;

	hr = PutStringW(pOpenTable, iColumn, pRecord, szString, cbBuffer);
	if(FAILED(hr))
		goto ErrExit;

ErrExit:
	return (hr);
}
	

HRESULT StgDatabase::PutBlob(			// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	const BYTE *pBuffer,				// User data.
	ULONG		cbBuffer)				// Size of buffer.
{
	PROVIDERDATA sData; 				// For contiguous bindings.
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	STGTABLEDEF *pTableDef;
	STGCOLUMNDEF *pColDef;
	BYTE		rgBuf[4];
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Set up a binding structure for the blob and length.
	sData.pData = (void *) pBuffer;
	sData.iLength = cbBuffer;
	sData.iStatus = S_OK;

	// first back up the old offset.
	pTableDef = pOpenTable->RecordMgr.GetTableDef();
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));
	memcpy(rgBuf, (BYTE *) pRecord + pColDef->iOffset, pColDef->iSize);
	
	// Insert the new value.
	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, 0, offsetof(PROVIDERDATA, iLength), 
				offsetof(PROVIDERDATA, iStatus), sizeof(BYTE *), DBTYPE_BYTES | DBTYPE_BYREF)) ||
		FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) &sData, 1, rgBinding, 0, true)))
	{

				// recover the data in this case.
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalBeforeUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));				

		memcpy((BYTE*)pRecord+pColDef->iOffset, rgBuf, pColDef->iSize);
	
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalAfterUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));

		// Status mapping for overflow.
		if (sData.iStatus == DBSTATUS_E_DATAOVERFLOW)
			hr = CLDB_E_TRUNCATION;

		goto ErrExit;
	}

ErrExit:	
	return (hr);
}


HRESULT StgDatabase::PutBlob(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	const BYTE *pBuffer,				// User data.
	ULONG		cbBuffer)				// Size of buffer.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = PutBlob(pOpenTable, iColumn, pRecord, pBuffer, cbBuffer);
	return (hr);
}

HRESULT StgDatabase::PutOid(			// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	OID 		oid)					// Return id here.
{
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	BYTE		rgBuf[4];
	STGTABLEDEF *pTableDef;
	STGCOLUMNDEF	*pColDef;
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// back up the data first.
	pTableDef = pOpenTable->RecordMgr.GetTableDef();
	VERIFY(pColDef = pOpenTable->RecordMgr.GetTableDef()->GetColDesc(iColumn - 1));
	memcpy(rgBuf, (BYTE *) pRecord + pColDef->iOffset, pColDef->iSize);
	
	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, 0, sizeof(OID), DBTYPE_OID)) ||
		FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
					(BYTE *) &oid, 1, rgBinding, 0, true)))
	{
		// recover the data in this case.
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalBeforeUpdate(
				pTableDef, 1, &pRecord, 1, rgBinding));

		memcpy((BYTE*)pRecord+pColDef->iOffset, rgBuf, pColDef->iSize);
		
		VERIFY(S_OK == pOpenTable->RecordMgr.SignalAfterUpdate
				(pTableDef, 1, &pRecord, 1, rgBinding));
				 
		goto ErrExit;
	}

ErrExit:
	return (hr);
}


HRESULT StgDatabase::PutOid(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	OID 					oid)		// Return id here.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = PutOid(pOpenTable, iColumn, pRecord, oid);
	return (hr);
}

HRESULT StgDatabase::PutVARIANT(		// Return code.
	STGOPENTABLE *pOpenTable,			// The table to work on.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	const VARIANT *pValue)				// The variant to write.
{
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, 0, sizeof(VARIANT), DBTYPE_VARIANT)) ||
		FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) pValue, 1, rgBinding, 0, true)))
	{
		return (hr);
	}
	return (S_OK);
}


HRESULT StgDatabase::PutVARIANT(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	const VARIANT *pValue)				// The variant to write.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = PutVARIANT(pOpenTable, iColumn, pRecord, pValue);
	return (hr);
}


HRESULT StgDatabase::PutVARIANT(		// Return code.
	STGOPENTABLE *pOpenTable,			// The table to work on.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	const void	*pBuffer,				// User data.
	ULONG		cbBuffer)				// Size of buffer.
{
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	if (FAILED(hr = ::BindCol(&rgBinding[0], iColumn, 0, cbBuffer, DBTYPE_VARIANT_BLOB)) ||
		FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) pBuffer, 1, rgBinding, 0, true)))
	{
		return (hr);
	}
	return (S_OK);
}

HRESULT StgDatabase::PutVARIANT(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	const void	*pBuffer,				// User data.
	ULONG		cbBuffer)				// Size of buffer.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = PutVARIANT(pOpenTable, iColumn, pRecord, pBuffer, cbBuffer);
	return (hr);
}


//*****************************************************************************
// VT_BYREF, VT_ARRAY, etc... are not supported.  SAFEARRAY's of any type are
// not supported.  All other data values must be a pointer to the actual 
// memory, UNICODE string or Utf8 string.
//*****************************************************************************
HRESULT StgDatabase::PutVARIANT(		// Return code.
	STGOPENTABLE *pOpenTable,			// Table to work on.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	VARTYPE 	vt, 					// Type of data.
	const void	*pValue)				// The actual data.
{
	//@todo: this version will construct a VARIANT around the passed in
	// data.  This is temporary because the OLE DB api's don't allow you to
	// pass the data separately.  May need to add a new way to break this down.
	WCHAR		*wszValue = 0;
	VARIANT 	sValue;
	HRESULT 	hr;

	::VariantInit(&sValue);

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	_ASSERTE((vt & VT_BYREF) == 0);

	// Copy fixed sized data by size.  All others are special.
	switch (vt)
	{
		case VT_I1:
		case VT_UI1:
		sValue.bVal = *(BYTE *) pValue;
		break;

		case VT_I2:
		case VT_UI2:
		case VT_BOOL:
		sValue.iVal = *(USHORT *) pValue;
		break;

		case VT_I4:
		case VT_UI4:
		case VT_R4:
		case VT_INT:
		case VT_UINT:
		case VT_ERROR:
		case VT_UNKNOWN:
		case VT_DISPATCH:
		sValue.lVal = *(ULONG *) pValue;
		break;

		case VT_I8:
		case VT_UI8:
		*(unsigned __int64 *) &sValue.bVal = *(unsigned __int64 *) pValue;
		break;

		case VT_R8:
		case VT_CY:
		case VT_DATE:
		sValue.cyVal = *(CY *) pValue;
		break;

		// Assume pointer to UNICODE string.
		case VT_BSTR:
		case VT_LPWSTR:
		if (pValue)
		{
			if ((sValue.bstrVal = ::SysAllocString((LPCWSTR) pValue)) == 0)
				return (PostError(OutOfMemory()));
		}
		else
			sValue.bstrVal = 0;
		break;

		default:
		_ASSERTE(!"Unknown VT type in PutVARIANT");
		sValue.lVal = *(long *) pValue;
	}

	// Set type and call other function.
	if (vt == VT_LPWSTR)
		sValue.vt = VT_BSTR;
	else
		sValue.vt = vt;
	hr = PutVARIANT(pOpenTable, iColumn, pRecord, &sValue);

	// Free the one thing we would have deep allocated.
	if (vt == VT_BSTR && sValue.bstrVal)
		::SysFreeString(sValue.bstrVal);
	return (hr);
}


HRESULT StgDatabase::PutVARIANT(		// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	VARTYPE 	vt, 					// Type of data.
	const void	*pValue)				// The actual data.
{
	STGOPENTABLE *pOpenTable;			// The table to update.
	HRESULT 	hr;

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = PutVARIANT(pOpenTable, iColumn, pRecord, vt, pValue);
	return (hr);
}

HRESULT StgDatabase::PutGuid(			// Return code.
	TABLEID 	tableid,				// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	REFGUID 	guid)					// Guid to put.
{
	STGOPENTABLE *pOpenTable;			// The table to update.
	HRESULT 	hr;

	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);
	hr = PutGuid(pOpenTable, iColumn, pRecord, guid);
	return (hr);
}

HRESULT StgDatabase::PutGuid(			// Return code.
	STGOPENTABLE *pOpenTable,			// Which table to work with.
	ULONG		iColumn,				// 1 based column number (logical).
	void		*pRecord,				// Record with data.
	REFGUID 	guid)					// Guid to put.
{
	DBBINDING	rgBinding[1];			// To get pointer to the guid.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	::BindCol(&rgBinding[0], iColumn, 0, sizeof(GUID), DBTYPE_GUID);
	hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
			reinterpret_cast<BYTE*>(const_cast<GUID*>(&guid)), 1, rgBinding, 0, true);

	return (hr);
}


void StgDatabase::SetNull(
	TABLEID 	tableid,				// Which table to work with.
	void		*pRecord,				// Record with data.
	ULONG		iColumn)				// 1 based column number (logical).
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	DBBINDING	rgBinding[1];			// To get pointer to the string.
	DBSTATUS	dbStatus;				// Null indicator.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE((m_fFlags & (SD_OPENED | SD_WRITE)) == (SD_OPENED | SD_WRITE));

	// Create a binding that refers only to the status.
	::BindCol(&rgBinding[0], iColumn, 0, 0, 0, sizeof(dbStatus), 0);
	rgBinding[0].dwPart = DBPART_STATUS;
	dbStatus = DBSTATUS_S_ISNULL;

	// Do a get data only on status.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)) ||
		FAILED(hr = pOpenTable->RecordMgr.SetData((STGRECORDHDR *) pRecord, 
				(BYTE *) &dbStatus, 1, rgBinding, 0, true)))
	{
		_ASSERTE(hr == S_OK);
	}
}


//
// Internal helpers.  These assume you have an open table pointer already.
HRESULT StgDatabase::GetRowByOid(		// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	OID 		_oid,					// Value for keyed lookup.
	void		**ppStruct) 			// Return pointer to record.
{
	HRESULT 	hr;

	// Binding is always to the first column with no length or status, so
	// make it hard coded data.
	static const DBBINDING rgOidBinding[] =
	{
		BINDING(1, 0, 0, 0, DBPART_VALUE, sizeof(OID), DBTYPE_OID )
	};

	// Allow only one record on return, OID's are unique as primary key.
	CFetchRecords sFetch((STGRECORDHDR **) ppStruct, 1);
	*ppStruct = 0;

	// Retrieve the record(s).
	if (FAILED(hr = pOpenTable->RecordMgr.GetRow(&sFetch, (DBBINDING *) rgOidBinding,
				1, &_oid, 0, 0, DBRANGE_MATCH)))
		return (hr);
	
	// Map record not found.
	if (sFetch.Count() == 0)
		return (CLDB_E_RECORD_NOTFOUND);
	return (hr);
}


HRESULT StgDatabase::GetVARIANT(		// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	VARIANT 	*pValue)				// The variant to write.
{
	HRESULT 	hr;
	ULONG		iOffset;				// Offset in heap.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Get the heap's offset.
	if (FAILED(hr = GetColumnOffset(pOpenTable, iColumn, pRecord, DBTYPE_VARIANT, &iOffset)))
		return (hr);

	// If a null column, set out params to 0.
	if (iOffset == 0xffffffff)
	{
		pValue->vt = VT_EMPTY; //@todo: VT_NULL??
		return (S_OK);
	}	 

	// This will get the blob.
	SCHEMADEFS *pSchemaDefs = pOpenTable->RecordMgr.GetSchema();
	hr = pSchemaDefs->GetVariantPool()->GetVariant(iOffset, pValue);

	return (hr);
}

// Retrieve a VARIANT column when the data is in a blob.
HRESULT StgDatabase::GetVARIANT(		// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	const void	**ppBlob,				// Pointer to blob.
	ULONG		*pcbSize)				// Size of blob.
{
	HRESULT 	hr;
	ULONG		iOffset;				// Offset in heap.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Get the heap's offset.
	if (FAILED(hr = GetColumnOffset(pOpenTable, iColumn, pRecord, DBTYPE_VARIANT, &iOffset)))
		return (hr);

	// If a null column, set out params to 0.
	if (iOffset == 0xffffffff)
	{
		*ppBlob = 0;
		*pcbSize = 0;
		return (S_OK);
	}	 

	// This will get the blob.
	SCHEMADEFS *pSchemaDefs = pOpenTable->RecordMgr.GetSchema();
	hr = pSchemaDefs->GetVariantPool()->GetVariant(iOffset, pcbSize, ppBlob);

	return (hr);
}


// Retrieve the VARTYPE of a variant column.
HRESULT StgDatabase::GetVARIANTType(	// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	VARTYPE 	*pType) 				// Type of the variant.
{
	HRESULT 	hr;
	ULONG		iOffset;				// Offset in heap.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Get the heap's offset.
	if (FAILED(hr = GetColumnOffset(pOpenTable, iColumn, pRecord, DBTYPE_VARIANT, &iOffset)))
		return (hr);

	// If a null column, set out params to 0.
	if (iOffset == 0xffffffff)
	{
		*pType = VT_EMPTY; //@todo: VT_NULL??
		return (S_OK);
	}	 

	// This will get the blob.
	SCHEMADEFS *pSchemaDefs = pOpenTable->RecordMgr.GetSchema();
	hr = pSchemaDefs->GetVariantPool()->GetVariantType(iOffset, pType);

	return (hr);
}


HRESULT StgDatabase::GetBlob(			// Return code.
	STGOPENTABLE *pOpenTable,			// For the new table.
	ULONG		iColumn,				// 1 based column number (logical).
	const void	*pRecord,				// Record with data.
	const BYTE	**ppBlob,				// Return pointer to data.
	ULONG		*pcbSize)				// How much data in blob.
{
	HRESULT 	hr;
	BYTE		*pColData;				// Pointer to pool offset in record.
	int 		bNull;					// true for null column.
	ULONG		iOffset;				// Offset in heap.
	STGTABLEDEF *pTableDef; 			// Describes a table.
	STGCOLUMNDEF *pColDef;				// Describes a column.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Get column description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));

	// Make sure column is correct type.
	_ASSERTE(pColDef->iType == DBTYPE_BYTES);

	// Get a pointer to where this offset lives.
	pColData = (BYTE *) pRecord + pColDef->iOffset;
	_ASSERTE(pColData);

	// Get the heap offset from the record, and check for null value.
	if (pColDef->iSize == sizeof(short))
	{
		bNull = (*(USHORT *) pColData == 0xffff);
		iOffset = *(USHORT *) pColData;
	}
	else
	{
		bNull = (*(ULONG *) pColData == 0xffffffff);
		iOffset = *(ULONG *) pColData;
	}

	// If a null column, set out params to 0.
	if (bNull)
	{
		*ppBlob = 0;
		*pcbSize = 0;
		return (S_OK);
	}	 

	// This will get the blob.
	SCHEMADEFS *pSchemaDefs = pOpenTable->RecordMgr.GetSchema();
	*ppBlob = reinterpret_cast<BYTE*>(pSchemaDefs->GetBlobPool()->GetBlob(iOffset, pcbSize));

	return ( S_OK );
}


//*****************************************************************************
// Mark the record with the given rid as deleted.  This will not actually
// remove the record from the heap, but rather turn on a flag that the save
// routines will use to determine it is no longer a visible record.  It is then
// purged on save.	All query/lookup code must also obey this flag, so if you
// delete a record, it will never return in a query.  Finally this function
// will cause the indexes to be updated so that the record is no longer in
// any index.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::DeleteRowByRID(
	TABLEID 	tableid,				// Which table to work with.
	ULONG		rid)					// Record id.
{
	STGOPENTABLE *pOpenTable;			// For the new table.
	void		*pStruct;				// Pointer to record.
	HRESULT 	hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Open the table for query.
	if (FAILED(hr = QuickOpenTable(pOpenTable, tableid)))
		return (hr);

	// Ask for the record.	Caller makes sure it is valid.
	rid = pOpenTable->RecordMgr.IndexForRecordID(rid);
	pStruct = (void *) pOpenTable->RecordMgr.GetRecord(&rid);
	if (pStruct)
	{
		pOpenTable->RecordMgr.DeleteRow((STGRECORDHDR *) pStruct, NULL);
		hr = S_OK;
	}
	else
		hr = PostError(CLDB_E_RECORD_NOTFOUND);
	return (hr);
}


HRESULT STDMETHODCALLTYPE StgDatabase::SaveToStream(// Return code.
	IStream 	*pIStream)				// Where to save the data.
{
	return (Save(pIStream));
}


HRESULT STDMETHODCALLTYPE StgDatabase::Save( 
	LPCWSTR 	szFile)
{
	HRESULT 	hr;

	// Ask database to init backing store.
	if (szFile && *szFile && FAILED(hr = SetSaveFile(szFile)))
		return (hr);

	// Now do the save.
	return (Save());
}


//*****************************************************************************
// After a successful open, this function will return the size of the in-memory
// database being used.  This is meant to be used by code that has opened a
// shared memory database and needs the exact size to init the system.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::GetDBSize( // Return code.
	ULONG		*pcbSize)				// Return size on success.
{
	*pcbSize = m_pStorage->GetStgIO()->GetDataSize();
	return (S_OK);
}


//*****************************************************************************
// Call this method only after calling LightWeightClose.  This method will try
// to reaquire the shared view of a database that was given on the call to
// OpenComponentLibrarySharedEx.  If the data is no longer available, then an
// error will result and no data is valid.	If the memory cannot be loaded into
// exactly the same address range as on the open, CLDB_E_RELOCATED will be
// returned.  In either of these cases, the only valid operation is to free
// this instant of the database and redo the OpenComponentLibrarySharedEx.	There
// is no automatic relocation scheme in the engine.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::LightWeightOpen()
{
	return E_NOTIMPL;
}


//*****************************************************************************
// This method will close any resources related to the file or shared memory
// which were allocated on the OpenComponentLibrary*Ex call.  No other memory
// or resources are freed.	The intent is solely to free lock handles on the
// disk allowing another process to get in and change the data.  The shared
// view of the file can be reopened by calling LightWeightOpen.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::LightWeightClose()
{
	return E_NOTIMPL;
}



HRESULT STDMETHODCALLTYPE StgDatabase::NewOid( 
	OID *poid)
{
	*poid = ++m_iNextOid;
	return (S_OK);
}


//*****************************************************************************
// Return the current total number of objects allocated.  This is essentially
// the highest OID value allocated in the system.  It does not look for deleted
// items, so the count is approximate.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE StgDatabase::GetObjectCount( 
	ULONG		*piCount)
{
	_ASSERTE(piCount);
	*piCount = m_iNextOid;
	return (S_OK);
}

//*****************************************************************************
// Get the offset of a heaped column.
//*****************************************************************************
HRESULT StgDatabase::GetColumnOffset(		// Return code.
	STGOPENTABLE *pOpenTable,			// The table with the column.
	ULONG		iColumn,				// The column with the data.
	const void	*pRecord,				// Record with data.
	DBTYPE		iType,					// Type the column should be.
	ULONG		*pulOffset) 			// Put offset here.
{
	BYTE		*pColData;				// Pointer to pool offset in record.
	ULONG		iOffset;				// Offset in heap.
	STGTABLEDEF *pTableDef; 			// Describes a table.
	STGCOLUMNDEF *pColDef;				// Describes a column.

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);

	// Validate the record pointer is in range.
	_ASSERTE(pOpenTable->RecordMgr.IsValidRecordPtr((const STGRECORDHDR *) pRecord));

	// Get column description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());
	VERIFY(pColDef = pTableDef->GetColDesc(iColumn - 1));

	// Make sure column is correct type.
	_ASSERTE(pColDef->iType == iType);

	// Get a pointer to where this offset lives.
	pColData = (BYTE *) pRecord + pColDef->iOffset;
	_ASSERTE(pColData);

	// Get the heap offset from the record, and check for null value.
	if (pColDef->iSize == sizeof(short))
	{
		if ((*(USHORT *) pColData == 0xffff))
			iOffset = 0xffffffff;
		else
			iOffset = *(USHORT *) pColData;
	}
	else
	{
		iOffset = *(ULONG *) pColData;
	}

	*pulOffset = iOffset;

	return ( S_OK );
}


#ifdef _DEBUG

static RTSemExclusive g_DbgCursorLock;		// Lock for leak list.

static void AddCursorToList(CRCURSOR *pCursor, const char *szFile, int line)
{
	DBG_CURSOR *pdbg = new DBG_CURSOR;
	if (!pdbg)
		return;
	pdbg->pCursor = pCursor;
	pdbg->cRecords = pCursor->sRecords.Count();
	strcpy(pdbg->rcFile, szFile);
	pdbg->line = line;

	CLock sLock(&g_DbgCursorLock);
	pdbg->pNext = g_pDbgCursorList;
	g_pDbgCursorList = pdbg;
}

static void DelCursorFromList(CRCURSOR *pCursor)
{
	DBG_CURSOR **pp;

	CLock sLock(&g_DbgCursorLock);

	// Grep linked list for item.  Delete it if found.
	for (pp=&g_pDbgCursorList;  *pp;  )
	{
		if ((*pp)->pCursor == pCursor)
		{
			DBG_CURSOR *pDel = *pp;
			*pp = (*pp)->pNext;
			delete pDel;
			return;
		}
		else
			pp = &((*pp)->pNext);
	}
	_ASSERTE(0 && "failed to find pCursor value, are you freeing an invalid pointer?");
}

BOOL CheckCursorList()
{
	CLock sLock(&g_DbgCursorLock);

	_ASSERTE(g_pDbgCursorList == 0 && "Cursor list is not empty, you failed to free a cursor which will leak memory");
	BOOL bRtn = true;
	DBG_CURSOR *p;
	for (p=g_pDbgCursorList;  p; )
	{
		printf("ERROR: Leaked cursor %p with %d records, allocated in file %s at line %d\n",
					p->pCursor, p->cRecords, p->rcFile, p->line);
		p = p->pNext;
		bRtn = false;
	}
	return (bRtn);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgicrschema.cpp ===
//*****************************************************************************
// StgICRSchema.cpp
//
// This is the code for IComponentRecordsSchema as defined in icmprecs.h.
// The code allows a client to get access to the meta data for a schema.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard header.
#include "StgSchema.h"					// Core schema defs.
#include "StgDatabase.h"				// Database definitions.
#include "StgRecordManager.h"			// Record api.
#include "StgIO.h"						// Storage api.
#include "StgTiggerStorage.h"			// Storage subsystem.
#include "OleDBUtil.h"					// Binding helpers.
#include "DBSchema.h"					// Default schema and bindings.

#define Success(func) VERIFY((func) == S_OK)


//********** Locals. **********************************************************
void _CopyColumnData(ICRSCHEMA_COLUMN *pOut, STGCOLUMNDEF *pIn, StgStringPool *pStrings);
void _CopyIndex(ICRSCHEMA_INDEX *pIndex, STGINDEXDEF *pIndexDef, StgStringPool *pStrings);


//********** Code. ************************************************************


//
// IComponentRecordsSchema
//

//*****************************************************************************
// Lookup the given table and return its table definition information in
// the given struct.
//*****************************************************************************
HRESULT StgDatabase::GetTableDefinition( // Return code.
	TABLEID		TableID,				// Return ID on successful open.
	ICRSCHEMA_TABLE *pTableDef)			// Return table definition data.
{
	STGOPENTABLE *pOpenTable;			// To open the table.
	STGTABLEDEF	*pTableDef2;			// Table definition.
	STGINDEXDEF	*pIndexDef;				// Loop control for primary key index.
	int			iIndex;					// Loop control.
	HRESULT		hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);
	
	// Open the table to get the table definition.
	if (FAILED(hr = OpenTable(0, pOpenTable, TableID)))
		return (hr);

	// Get table description.
	VERIFY(pTableDef2 = pOpenTable->RecordMgr.GetTableDef());

	// Copy the data to the public structure from the private one.
	hr = pOpenTable->RecordMgr.GetSchema()->pNameHeap->GetStringW(pTableDef2->Name, pTableDef->rcTable, MAXTABLENAME);
	pTableDef->fFlags = (ULONG) (pTableDef2->fFlags & ICRSCHEMA_TBL_MASK);
	pTableDef->Columns = pTableDef2->iColumns;
	pTableDef->Indexes = pTableDef2->iIndexes;
	pTableDef->RecordStart = pTableDef2->iRecordStart;

	// Check for a primary key index (multi-columns) and record that fact.
	if (!pTableDef2->HasPrimaryKeyColumn() && pTableDef2->iIndexes)	
	{
		for (iIndex=0, pIndexDef=pTableDef2->GetIndexDesc(0);  
				iIndex<pTableDef2->iIndexes;  iIndex++)
		{
			if (pIndexDef->IsPrimaryKey())
			{
				pTableDef->fFlags |= ICRSCHEMA_TBL_HASPKEYCOL;
				break;
			}
			if (iIndex + 1 < pTableDef2->iIndexes)
				pIndexDef = pIndexDef->NextIndexDef();
		}
	}
	return (hr);
}


//*****************************************************************************
// Lookup the list of columns for the given table and return description of
// each of them.  If GetType is ICRCOLUMN_GET_ALL, then this function will 
// return the data for each column in ascending order for the table in the
// corresponding rgColumns element.  If it is ICRCOLUMN_GET_BYORDINAL, then
// the caller has initialized the Ordianl field of the column structure to
// indicate which columns data is to be retrieved.  The latter allows for ad-hoc
// retrieval of column definitions.
//*****************************************************************************
HRESULT StgDatabase::GetColumnDefinitions( // Return code.
	ICRCOLUMN_GET GetType,				// How to retrieve the columns.
	TABLEID		TableID,				// Return ID on successful open.
	ICRSCHEMA_COLUMN rgColumns[],		// Return array of columns.
	int			ColCount)				// Size of the rgColumns array, which
{
	STGOPENTABLE *pOpenTable;			// To open the table.
	STGTABLEDEF	*pTableDef;				// Table definition.
	STGCOLUMNDEF *pColDef;				// Column definition.
	int			i;						// Loop control.
	HRESULT		hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);
	_ASSERTE(rgColumns && ColCount > 0);
	
	// Open the table to get the table definition.
	if (FAILED(hr = OpenTable(0, pOpenTable, TableID)))
		return (hr);

	// Get table description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());

	// For retrieval of all columns, simply walk the list from front to back.	
	if (GetType == ICRCOLUMN_GET_ALL)
	{
		// Sanity check what they gave us.  If this fires, you need to ask for
		// the same number of columns that are in the table.
		if (ColCount > pTableDef->iColumns)
		{
			_ASSERTE(0 && "GetColumnDefinitions asked for incorrect column count");
			ColCount = pTableDef->iColumns;
		}
		
		// Fill out each column description.
		for (i=0;  i<ColCount;  i++)
		{
			// Retreive the column definition.
			VERIFY(pColDef = pTableDef->GetColDesc(i));
			
			// Copy the data from the column.
			_CopyColumnData(&rgColumns[i], pColDef, pOpenTable->RecordMgr.GetSchema()->pNameHeap);
		}
	}
	// User wants control over which columns are returned.
	else
	{
		_ASSERTE(GetType == ICRCOLUMN_GET_BYORDINAL);

		// Retrieve the columns indentified by the user.
		for (i=0;  i<ColCount;  i++)
		{
			// Retreive the column definition.
			_ASSERTE(rgColumns[i].Ordinal > 0 && rgColumns[i].Ordinal <= pTableDef->iColumns);
			VERIFY(pColDef = pTableDef->GetColDesc(rgColumns[i].Ordinal - 1));
			
			// Copy the data from the column.
			_CopyColumnData(&rgColumns[i], pColDef, pOpenTable->RecordMgr.GetSchema()->pNameHeap);
		}
	}
	return (S_OK);
}


//*****************************************************************************
// Return the description of the given index into the structure.  See the
// ICRSCHEMA_INDEX structure definition for more information.
//*****************************************************************************
HRESULT StgDatabase::GetIndexDefinition( // Return code.
	TABLEID		TableID,				// Return ID on successful open.
	LPCWSTR		szIndex,				// Name of the index to retrieve.
	ICRSCHEMA_INDEX *pIndex)			// Return index description here.
{
	STGOPENTABLE *pOpenTable;			// To open the table.
	STGTABLEDEF	*pTableDef;				// Table definition.
	STGINDEXDEF	*pIndexDef;				// Internal definition.
	HRESULT		hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);
	
	// Open the table to get the table definition.
	if (FAILED(hr = OpenTable(0, pOpenTable, TableID)))
		return (hr);

	// Get table description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());

	// Lookup the index definition.
	pIndexDef = pOpenTable->RecordMgr.GetIndexDefByName(szIndex);
	if (!pIndexDef)
		return (PostError(CLDB_E_INDEX_NOTFOUND, szIndex));

	// Copy index definition.
	_CopyIndex(pIndex, pIndexDef, pOpenTable->RecordMgr.GetSchema()->pNameHeap);
	return (S_OK);
}


//*****************************************************************************
// Return the description of the given index into the structure.  See the
// ICRSCHEMA_INDEX structure definition for more information.
//*****************************************************************************
HRESULT StgDatabase::GetIndexDefinitionByNum( // Return code.
	TABLEID		TableID,				// Return ID on successful open.
	int			IndexNum,				// 0 based index to return.
	ICRSCHEMA_INDEX *pIndex)			// Return index description here.
{
	STGOPENTABLE *pOpenTable;			// To open the table.
	STGTABLEDEF	*pTableDef;				// Table definition.
	STGINDEXDEF	*pIndexDef;				// Internal definition.
	HRESULT		hr;

	// Sanity check.
	_ASSERTE(m_fFlags & SD_OPENED);
	
	// Open the table to get the table definition.
	if (FAILED(hr = OpenTable(0, pOpenTable, TableID)))
		return (hr);

	// Get table description.
	VERIFY(pTableDef = pOpenTable->RecordMgr.GetTableDef());

	// Lookup the index definition.
	if (IndexNum >= pTableDef->iIndexes)
	{
		WCHAR rcIndex[32];
		swprintf(rcIndex, L"%d", IndexNum);
		return (PostError(CLDB_E_INDEX_NOTFOUND, rcIndex));
	}
	VERIFY(pIndexDef = pTableDef->GetIndexDesc(IndexNum));

	// Copy index definition.
	_CopyIndex(pIndex, pIndexDef, pOpenTable->RecordMgr.GetSchema()->pNameHeap);
	return (S_OK);
}




//
// Helpers.
//

void _CopyColumnData(ICRSCHEMA_COLUMN *pOut, STGCOLUMNDEF *pIn, StgStringPool *pStrings)
{
	_ASSERTE(pOut && pIn);

	VERIFY(pStrings->GetStringW(pIn->Name, pOut->rcColumn, MAXCOLNAME) == S_OK);
	pOut->wType = pIn->iType;
	pOut->Ordinal = pIn->iColumn;

	const DATATYPEDEF *pDataType = GetTypeFromType(pOut->wType);
	_ASSERTE(pDataType && "Can't have a column with an invalid type");

	pOut->fFlags = pIn->fFlags & ICRSCHEMA_COL_MASK;
	if (pIn->fFlags & CTF_MULTIPK)
		pOut->fFlags |= ICRSCHEMA_COL_PK;

	if (pDataType->fFlags & DBCOLUMNFLAGS_ISFIXEDLENGTH)
	{
		pOut->cbSize = pDataType->iSize;
		pOut->fFlags |= ICRSCHEMA_COL_FIXEDLEN;
	}
	else if (pIn->iMaxSize == COL_NO_DATA_LIMIT)
		pOut->cbSize = ~0;
	else
		pOut->cbSize = pIn->iMaxSize;
}


void _CopyIndex(ICRSCHEMA_INDEX *pIndex, STGINDEXDEF *pIndexDef, StgStringPool *pStrings)
{
	int			i, iMax;				// Loop control.

	// Copy the internal state into the return structure.
	VERIFY(pStrings->GetStringW(pIndexDef->Name, pIndex->rcIndex, MAXINDEXNAME) == S_OK);
	pIndex->fFlags = pIndexDef->fFlags & ICRSCHEMA_DEX_MASK;
	pIndex->RowThreshold = pIndexDef->iRowThreshold;
	pIndex->IndexOrdinal = pIndexDef->iIndexNum;
	pIndex->Type = pIndexDef->fIndexType;
	
	// Copy the key list for the caller up to the maximum.  Return in Keys
	// the total number of keys.
	iMax = min(pIndex->Keys, pIndexDef->iKeys);
	for (i=0;  i<iMax;  i++)
		pIndex->rgKeys[i] = pIndexDef->rgKeys[i];
	pIndex->Keys = pIndexDef->iKeys;
}

//*****************************************************************************
// Wrapper for StgDatabase::CreateTable.
//*****************************************************************************
HRESULT StgDatabase::CreateTableEx(		// Return code.
	LPCWSTR		szTableName,			// Name of new table to create.
	int			iColumns,				// Columns to put in table.
	ICRSCHEMA_COLUMN	rColumnDefs[],	// Array of column definitions.
	USHORT		usFlags, 				// Create values for flags.
	USHORT		iRecordStart,			// Start point for records.
	TABLEID		tableid,				// Hard coded ID if there is one.
	BOOL		bMultiPK)				// The table has multi-column PK.
{
	CDynArray<COLUMNDEF> rgColDefs;		// Array of column defs.
	COLUMNDEF   *pColDef;               // Column definition.

	for ( int i = 0; i < iColumns; i ++ )
	{
		
		if ((pColDef = rgColDefs.Append()) == 0)
        {
            return OutOfMemory();
        }
		memset(pColDef, 0, sizeof(COLUMNDEF));

		wcscpy(pColDef->rcName, rColumnDefs[i].rcColumn);
		pColDef->iType = rColumnDefs[i].wType;
        pColDef->iColumn = (UCHAR)rColumnDefs[i].Ordinal;

		if ( rColumnDefs[i].fFlags & ICRSCHEMA_COL_NULLABLE )
			pColDef->fFlags |= CTF_NULLABLE;

		if (rColumnDefs[i].fFlags & ICRSCHEMA_COL_PK && !bMultiPK ) 
		{
			pColDef->fFlags |= CTF_PRIMARYKEY;
		}

		if ( rColumnDefs[i].fFlags & ICRSCHEMA_COL_CASEINSEN )
			pColDef->fFlags |= CTF_CASEINSENSITIVE;

		if ( pColDef->iSize != ~0 )
			pColDef->iSize = (USHORT)rColumnDefs[i].cbSize;
		else
			pColDef->iSize = COL_NO_DATA_LIMIT;
		
	}

	usFlags |= TABLEDEFF_CORE;

	return CreateTable(szTableName, rgColDefs.Count(), rgColDefs.Ptr(), 
					   usFlags, iRecordStart, 0, tableid );


}

//*****************************************************************************
// Wrapper for StgDatabase::CreateIndex
//*****************************************************************************
HRESULT StgDatabase::CreateIndexEx(		// Return code.
	LPCWSTR		szTableName,			// Name of table to put index on.
	ICRSCHEMA_INDEX	*pInIndexDef,		// Index description.
	const DBINDEXCOLUMNDESC rgInKeys[] )// Which columns make up key.

{
	STGINDEXDEF sIndexDef;				//internal index definition

	memset(&sIndexDef, 0, sizeof(STGINDEXDEF));

    //this breaks on 64 bits
    _ASSERTE( sizeof(ULONG) == sizeof(LPVOID));

	sIndexDef.Name = (ULONG)(ULONG_PTR)pInIndexDef->rcIndex;
	sIndexDef.fFlags = (UCHAR)pInIndexDef->fFlags;
	sIndexDef.iRowThreshold = (UCHAR)pInIndexDef->RowThreshold;
	sIndexDef.fIndexType = (UCHAR)pInIndexDef->Type;

	 // Hash index.
    if (sIndexDef.fIndexType == IT_HASHED)
    {
        sIndexDef.HASHDATA.iBuckets = 17;
        sIndexDef.HASHDATA.iMaxCollisions = 5;
        sIndexDef.HASHDATA.iNextOffset = 0xffff;
    }

	sIndexDef.iKeys = (UCHAR)pInIndexDef->Keys;

	return CreateIndex(szTableName, &sIndexDef, 
                       pInIndexDef->Keys, rgInKeys);

}

//*****************************************************************************
// return user schema blob and nameheap
//*****************************************************************************
HRESULT StgDatabase::GetSchemaBlob(		//Return code.
		ULONG* pcbSchemaSize,			//schema blob size
		BYTE** ppSchema,				//schema blob
		ULONG* pcbNameHeap,				//name heap size
		HGLOBAL*  phNameHeap)				//name heap blob
{
	// Open the user schema which contains the table definitions.
	SCHEMADEFS	*pSchemaDefs;			// The schema definition
	HRESULT hr;

	VERIFY(pSchemaDefs = GetSchema(SCHEMA_USER));

	*pcbSchemaSize = pSchemaDefs->pSchema->cbSchemaSize;
	*ppSchema = (BYTE*)pSchemaDefs->pSchema;

	// Dump the string heap that was used to save the names.  Save the string
	// data to an in memory stream, then dump it as a big byte array.  This allows
	// the load code to init it from the same format used for normal persistence.
	//
	CComPtr<IStream> pIStream;
	LARGE_INTEGER	iMove = { 0, 0 };
	ULARGE_INTEGER	iSize;

	VERIFY(*phNameHeap = GlobalAlloc(GHND, 4096));
	if ( NULL == *phNameHeap )
		return E_OUTOFMEMORY;
	Success(hr = CreateStreamOnHGlobal(*phNameHeap, FALSE, &pIStream));
	if ( FAILED(hr) ) return hr;
	Success(hr = pSchemaDefs->pNameHeap->PersistToStream(pIStream));
	if ( FAILED(hr) ) return hr;
	Success(hr = pIStream->Seek(iMove, STREAM_SEEK_CUR, &iSize));
	if ( FAILED(hr) ) return hr;
	*pcbNameHeap	= iSize.LowPart;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgindexmanagerbase.h ===
//*****************************************************************************
// StgIndexManagerBase.h
//
// The index manager is in charge of indexing data in a table.  The main index
// type supported in this system in a persistent hashed index.  Support for
// unique indexes is offered, as well as heuristics for stripping indexes for
// small data, and configing bucket size dynamically based on load.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgIndexManagerBase_h__
#define __StgIndexManagerBase_h__

#include "RecordHeap.h"


// Forwards.
class StgRecordManager;



//*****************************************************************************
// Abstract base class definition for an index.  Indexes are called by the
// record manager in response to events that may affect them.
//*****************************************************************************
class IStgIndex
{
public:
	virtual ULONG STDMETHODCALLTYPE AddRef() = 0;

	virtual ULONG STDMETHODCALLTYPE Release() = 0;

	virtual ~IStgIndex() {};

//*****************************************************************************
// Opens the index on top of the given table.
//*****************************************************************************
	virtual HRESULT Open(					// Return status.
		UINT_PTR	iIndexDef,				// Offset of index def.
		StgRecordManager *pRecordMgr,		// The record manager that owns us.
		RECORDHEAP	*pRecordHeap,			// The first heap for this table.
		ULONG		iRecords,				// If -1, unknown.
		STGINDEXHDR	*pIndexHdr,				// The persisted header data.
		ULONG		*pcbSize) = 0;			// Return size of index data.

//*****************************************************************************
// Close the index and free any run-time state.
//*****************************************************************************
	virtual void Close() = 0;

//*****************************************************************************
// Returns the save size of this index object based on current data.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return.
		ULONG		iIndexSize,				// Size of an index offset.
		ULONG		*pcbSave,				// Return save size here.
		ULONG		RecordCount) = 0;		// Total records to save, excluding deleted.

//*****************************************************************************
// Persist the index data into the stream.
//*****************************************************************************
	virtual HRESULT SaveToStream(			// Return status.
		IStream		*pIStream,				// Stream to save to.
		long		*pMappingTable,			// mapping table. (Optional)
		ULONG		RecordCount) = 0;		// Total records to save, excluding deleted.

//*****************************************************************************
// Called by the record manager's Save() method before it tells the page
// manager to flush all changed pages to disk.  The index should perform any
// changes it needs before this event.
//*****************************************************************************
	virtual HRESULT BeforeSave() = 0;

//*****************************************************************************
// Called after a new row has been inserted into the table.  The index should
// update itself to reflect the new row.
//*****************************************************************************
	virtual HRESULT AfterInsert(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record after insert.
		int			bCheckDupes) = 0;		// true to enforce duplicates.

//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
	virtual HRESULT AfterDelete(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord) = 0;		// The record to delete.

//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
	virtual HRESULT BeforeUpdate(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]) = 0;		// Column accessors.

//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
	virtual HRESULT AfterUpdate(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]) = 0;		// Column accessors.

//*****************************************************************************
// Looks up the given record given the column information.  The user data must
// match the data types of the indexed data exactly, no conversions are done.
// The order of the user columns must match the index definition exactly, no
// attempt to sort the columns is made.
//*****************************************************************************
	virtual HRESULT FindRecord(				// Return code.
		BYTE		*pData,					// User data.
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns
		CFetchRecords *pFetchRecords,		// Return list of records here.
		BYTE		*pbFilterData,			// Filter data.
		ULONG		iFilterColumns,			// How many additional filter columns.
		DBBINDING	rgFilterBindings[],		// Bindings for filter data.
		DBCOMPAREOP	rgfCompare[]) = 0;		// Filter comparison operators.

	virtual HRESULT FindRecord(				// Return code.
		BYTE		*pData,					// User data.
		ULONG		iKeyColumns,			// key columns 
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns
		CDynBitVector *pBits,			// record index in the array for the given data.
		int			iLevel) = 0;			// current column of the query.

//*****************************************************************************
// Returns the indentifier for this index type.
//*****************************************************************************
	virtual BYTE GetIndexType() = 0;

//*****************************************************************************
// Return the index definition for this item.
//*****************************************************************************
	virtual STGINDEXDEF *GetIndexDef() = 0;	// The definition of the index.
};


// Track an array of indexes.
typedef CDynArray<IStgIndex *> STGINDEXLIST;


#endif // __StgIndexManagerBase_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgindexmanager.cpp ===
//*****************************************************************************
// StgIndexManager.cpp
//
// The index manager is in charge of indexing data in a table.  The main index
// type supported in this system in a persistent hashed index.  Support for
// unique indexes is offered, as well as heuristics for stripping indexes for
// small data, and configing bucket size dynamically based on load.
//
// The format of a hashed index stream is as follows:
//	+-----------------------------------------------+
//	| STGINDEXHDR									|
//	| 2 or 4 byte bucket RID array					|
//	+-----------------------------------------------+
// The count of buckets can be found in the STGINDEXHDR.HASHDATA and can be
// multiplied by 2 or 4 bytes based on the largest RID for this table.  The
// stream is 4 byte aligned at the end.

// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard includes.
#include "OleDBUtil.h"					// Helpers for bindings.
#include "Errors.h"						// Error handling.
#include "StgDatabase.h"				// Database class.
#include "StgIndexManager.h"			// Our definitions.
#include "StgRecordManager.h"			// The record manager interface.
#include "StgSchema.h"					// Access to schema data.
#include "StgConstantData.h"			// Well known constant values.


//********** Locals. **********************************************************
int _BindingsContainNullValue(ULONG iColumns, DBBINDING rgBinding[], const BYTE *pData);
int _UpdatesRelevent(STGINDEXDEF *pIndexDef, USHORT iColumns, DBBINDING rgBindings[]);

#ifdef _DEBUG
HRESULT _DbgCheckIndexForNulls(STGTABLEDEF *pTableDef, USHORT iColumns,
			DBBINDING rgBinding[]);
#endif


//********** Code. ************************************************************

//*****************************************************************************
// Init the index.
//*****************************************************************************
StgHashedIndex::StgHashedIndex(
	bool		bUnique) :
	m_pRecordMgr(0),
	m_cbIndexDef(0),
	m_bUnique(bUnique),
	m_cRef(0),
	m_pfnHash(0)
{ 
	DEBUG_STMT(m_cbDebugSaveSize = 0);
}


//*****************************************************************************
// Clean up the index.
//*****************************************************************************
StgHashedIndex::~StgHashedIndex()
{
}


//*****************************************************************************
// Opens the index on top of the given table.
//*****************************************************************************
HRESULT StgHashedIndex::Open(			// Return status.
	UINT_PTR	iIndexDef,				// Offset of index def.
	StgRecordManager *pRecordMgr,		// The record manager that owns us.
	RECORDHEAP	*pRecordHeap,			// The first heap for this table.
	ULONG		iRecords,				// If -1, unknown.
	STGINDEXHDR	*pIndexHdr,				// The persisted header data.
	ULONG		*pcbSize)				// Return size of index data.
{
	HRESULT		hr=S_OK;

	// Save off the parent data.
	_ASSERTE(iIndexDef > sizeof(STGTABLEDEF));
	m_cbIndexDef = iIndexDef;
	m_pRecordMgr = pRecordMgr;

	// Get the hash method used for this format.
	VERIFY(m_pfnHash = m_pRecordMgr->GetDB()->GetHashFunc());

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	if (pcbSize)
		*pcbSize = sizeof(STGINDEXHDR);

	// If buckets were passed in, then we'll just use those.
	if (pIndexHdr)
	{
		if (RIDSizeFromRecords(iRecords) == sizeof(USHORT))
		{
			m_iIndexSize = sizeof(USHORT);
			m_Bucket2.SetRecordMgr(pRecordHeap);
			m_Bucket2.InitOnMem((USHORT *) (pIndexHdr + 1), pThisIndexDef->HASHDATA.iBuckets);
		}
		else
		{
			m_iIndexSize = sizeof(ULONG);
			m_Bucket4.SetRecordMgr(pRecordHeap);
			m_Bucket4.InitOnMem((ULONG *) (pIndexHdr + 1), pThisIndexDef->HASHDATA.iBuckets);
		}

		// The size of our index data is the size of the header, plus the size of
		// the bucket entries.  Align for good measure.
		if (pcbSize)
		{
			*pcbSize += m_iIndexSize * pThisIndexDef->HASHDATA.iBuckets;
			*pcbSize = ALIGN4BYTE(*pcbSize);
		}
	}
	// If this is a new index, then we need a bucket array.
	else 
	{
		if (iRecords == 0xffffffff || iRecords > 0xffff)
		{
			m_iIndexSize = sizeof(ULONG);
			m_Bucket4.SetRecordMgr(pRecordHeap);
			hr = m_Bucket4.InitNew(pThisIndexDef);
		}
		else
		{
			m_iIndexSize = sizeof(USHORT);
			m_Bucket2.SetRecordMgr(pRecordHeap);
			hr = m_Bucket2.InitNew(pThisIndexDef);
		}
	}

	return (hr);
}


//*****************************************************************************
// Close the index and free any run-time state.
//*****************************************************************************
void StgHashedIndex::Close()
{
}


//*****************************************************************************
// Returns the save size of this index object based on current data.
//*****************************************************************************
HRESULT StgHashedIndex::GetSaveSize(	// Return status.
	ULONG		iIndexSize,				// Size of an index offset.
	ULONG		*pcbSave,				// Return save size here.
	ULONG		RecordCount)			// Total records to save, excluding deleted.
{
	ULONG		cbSave;
	cbSave = GetIndexDef()->HASHDATA.iBuckets * iIndexSize;
	cbSave = ALIGN4BYTE(cbSave);
	cbSave += sizeof(STGINDEXHDR);
	*pcbSave = cbSave;
	DEBUG_STMT(m_cbDebugSaveSize = cbSave);
	return (S_OK);
}


//*****************************************************************************
// Persist the index data into the stream.
//*****************************************************************************
HRESULT StgHashedIndex::SaveToStream(	// Return status.
	IStream		*pIStream,				// Stream to save to.
	long		*pMappingTable,			// table for mapping old rids to new rids (due to
										// discarding deleted and transient records.
	ULONG		RecordCount)			// Total records to save, excluding deleted.
{
	STGINDEXHDR	sHeader;
	HRESULT		hr;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// Init the header with the bucket count for this definition.
	memset(&sHeader, 0, sizeof(STGINDEXHDR));
	sHeader.iBuckets = pThisIndexDef->HASHDATA.iBuckets;
	sHeader.fFlags = pThisIndexDef->fFlags;
	sHeader.iIndexNum = pThisIndexDef->iIndexNum;
	sHeader.rcPad[0] = MAGIC_INDEX;

	// Write the header.
	if (FAILED(hr = pIStream->Write(&sHeader, sizeof(STGINDEXHDR), 0)))
		return (hr);

	// Now save the bucket data.
	if (m_iIndexSize == sizeof(USHORT))
		return (m_Bucket2.SaveToStream(pIStream));
	else
		return (m_Bucket4.SaveToStream(pIStream));
}


//*****************************************************************************
// Called by the record manager's Save() method before it tells the page
// manager to flush all changed pages to disk.  The index should perform any
// changes it needs before this event.
//*****************************************************************************
HRESULT StgHashedIndex::BeforeSave()
{
	return (BadError(E_NOTIMPL));
}


//*****************************************************************************
// Called after a new row has been inserted into the table.  The index should
// update itself to reflect the new row.
//*****************************************************************************
HRESULT StgHashedIndex::AfterInsert(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record after insert.
	int			bCheckDupes)			// true to enforce duplicates.
{
	DBBINDING	*rgBindings;			// Array of bindings;
	PROVIDERDATA *rgData;				// Pointers to data.
	int			bNulls;					// true if null data present.
	HRESULT		hr=S_OK;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// If we are deferring create of the index, then return right now.
	if (pThisIndexDef->fFlags & DEXF_DEFERCREATE)
		goto ErrExit;

	// Set up binding descriptions for this record type.	
	VERIFY(rgBindings = (DBBINDING *) _alloca(pThisIndexDef->iKeys * sizeof(DBBINDING)));
	VERIFY(rgData = (PROVIDERDATA *) _alloca(pThisIndexDef->iKeys * sizeof(PROVIDERDATA)));

	// Get binding values for this record for the hash code to use.
	if (FAILED(hr = m_pRecordMgr->GetBindingsForColumns(pTableDef, psRecord,
			pThisIndexDef->iKeys, &pThisIndexDef->rgKeys[0], rgBindings, rgData)))
		goto ErrExit;

	// Scan for null values in the user data.
	bNulls = _BindingsContainNullValue(pThisIndexDef->iKeys, rgBindings, 
					(const BYTE *) &rgData[0]);

	// Disallow any null values in primary key, unique indexes.
	if (bNulls)
	{
		if (pThisIndexDef->IsUnique() || pThisIndexDef->IsPrimaryKey())
		{
			hr = PostError(CLDB_E_INDEX_NONULLKEYS);
			goto ErrExit;
		}
	}
	else
	{
		// Let the hash code add the new index entry.
		hr = HashAdd(pTableDef, RecordID, (BYTE *) &rgData[0], 
					pThisIndexDef->iKeys, rgBindings, bCheckDupes);
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
HRESULT StgHashedIndex::AfterDelete(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord)				// The record to delete.
{
	DBBINDING	*rgColBindings;			// Our internal bindings.
	PROVIDERDATA *rgData;				// Pointers to data.
	HRESULT		hr;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// If we are deferring create of the index, then return right now.
	if (pThisIndexDef->fFlags & DEXF_DEFERCREATE)
		return (S_OK);

	// Set up binding descriptions for this record type.	
	VERIFY(rgColBindings = (DBBINDING *) _alloca(pThisIndexDef->iKeys * sizeof(DBBINDING)));
	VERIFY(rgData = (PROVIDERDATA *) _alloca(pThisIndexDef->iKeys * sizeof(PROVIDERDATA)));

	// Get binding values for this record for the hash code to use.
	if (FAILED(hr = m_pRecordMgr->GetBindingsForColumns(pTableDef, psRecord,
			pThisIndexDef->iKeys, &pThisIndexDef->rgKeys[0], rgColBindings, rgData)))
		return (hr);

	// Let the hash code add the new index entry.
	hr = HashDel(pTableDef, RecordID, (BYTE *) &rgData[0], pThisIndexDef->iKeys, rgColBindings);
	
	// It is possible the record was not in our index because the data values
	// were null. In this case, eat the error, because we hide this behavior
	// from the user and the end intent is made: the record is not in the
	// index after this function is called.
	if (hr == CLDB_E_INDEX_NONULLKEYS)
		return (S_OK);
	return (hr);
}


//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
HRESULT StgHashedIndex::BeforeUpdate(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record to be changed.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	DBBINDING	*rgColBindings;			// Our internal bindings.
	PROVIDERDATA *rgData;				// Pointers to data.
	HRESULT		hr;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// If we are deferring create of the index, then return right now.
	if (pThisIndexDef->fFlags & DEXF_DEFERCREATE)
		return (S_OK);

	// Ignore this index if it doesn't afect us.
	if (_UpdatesRelevent(pThisIndexDef, iColumns, rgBindings) == false)
		return (S_OK);

	// Set up binding descriptions for this record type.	
	VERIFY(rgColBindings = (DBBINDING *) _alloca(pThisIndexDef->iKeys * sizeof(DBBINDING)));
	VERIFY(rgData = (PROVIDERDATA *) _alloca(pThisIndexDef->iKeys * sizeof(PROVIDERDATA)));

	// Get binding values for this record for the hash code to use.
	if (FAILED(hr = m_pRecordMgr->GetBindingsForColumns(pTableDef, psRecord,
			pThisIndexDef->iKeys, &pThisIndexDef->rgKeys[0], rgColBindings, rgData)))
		return (hr);

	// Let the hash code add the new index entry.
	hr = HashDel(pTableDef, RecordID, (BYTE *) &rgData[0], pThisIndexDef->iKeys, rgColBindings);
	
	// It is possible the record was not in our index because the data values
	// were null. In this case, eat the error, because we hide this behavior
	// from the user and the end intent is made: the record is not in the
	// index after this function is called.
	if (hr == CLDB_E_INDEX_NONULLKEYS)
		return (S_OK);
	return (hr);
}


//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
HRESULT StgHashedIndex::AfterUpdate(	// Return status.
	STGTABLEDEF *pTableDef,				// Table definition to use.
	RECORDID	&RecordID,				// The record we inserted.
	STGRECORDHDR *psRecord,				// Record to be changed.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	DBBINDING	*rgColBindings;			// Our internal bindings.
	PROVIDERDATA *rgData;				// Pointers to data.
	int			bNulls;					// true if null value present.
	HRESULT		hr=S_OK;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// If we are deferring create of the index, then return right now.
	if (pThisIndexDef->fFlags & DEXF_DEFERCREATE)
		goto ErrExit;

	// Ignore this index if it doesn't afect us.
	if (_UpdatesRelevent(pThisIndexDef, iColumns, rgBindings) == false)
		goto ErrExit;

	// Set up binding descriptions for this record type.	
	VERIFY(rgColBindings = (DBBINDING *) _alloca(pThisIndexDef->iKeys * sizeof(DBBINDING)));
	VERIFY(rgData = (PROVIDERDATA *) _alloca(pThisIndexDef->iKeys * sizeof(PROVIDERDATA)));

	// Get binding values for this record for the hash code to use.
	if (FAILED(hr = m_pRecordMgr->GetBindingsForColumns(pTableDef, psRecord,
			pThisIndexDef->iKeys, &pThisIndexDef->rgKeys[0], rgColBindings, rgData)))
		goto ErrExit;

	// Scan for null values in the record after the update.
	bNulls = _BindingsContainNullValue(pThisIndexDef->iKeys, rgColBindings, 
				(const BYTE *) &rgData[0]);

	// Disallow any null values in primary key, unique indexes.
	if (bNulls)
	{
		if (pThisIndexDef->IsUnique() || pThisIndexDef->IsPrimaryKey())
		{
			hr = PostError(CLDB_E_INDEX_NONULLKEYS);
			goto ErrExit;
		}
	}
	else
	{
		// Let the hash code add the new index entry.
		hr = HashAdd(pTableDef, RecordID, (BYTE *) &rgData[0], pThisIndexDef->iKeys, rgColBindings);
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Looks up the given record given the column information.
//*****************************************************************************
HRESULT StgHashedIndex::FindRecord(		// Return code.
	BYTE		*pData,					// User data.
	ULONG		iColumns,				// How many columns.
	DBBINDING	rgBindings[],			// Column accessors.
	DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the bindings. 
	CFetchRecords *pFetchRecords,		// Return list of records here.
	BYTE		*pbFilterData,			// Filter data.
	ULONG		iFilterColumns,			// How many additional filter columns.
	DBBINDING	rgFilterBindings[],		// Bindings for filter data.
	DBCOMPAREOP	rgfCompare[])			// Filter comparison operators.
{
	STGRECORDHDR *psRecord;				// For walking records.
	RECORD		*pRecord;				// For adding new records.
	ULONG		iHashVal;				// The hashed value of keys.
	ULONG		iFetched = 0;			// Track how many we add.
	HRESULT		hr = NOERROR;

//@todo: is this safe in the case where we do a full save and have two active
// table defs going at the same time.
STGTABLEDEF *pTableDef;
VERIFY(pTableDef = m_pRecordMgr->GetTableDef());

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// Hash the user data.
	hr = HashKeys(pTableDef, pData, iColumns, rgBindings, &iHashVal);

	// If null values were found in the user's data, then this code path cannot
	// proceede.  Tell caller to back off to a table scan.
	if (hr == CLDB_E_INDEX_NONULLKEYS)
		return (CLDB_S_INDEX_TABLESCANREQUIRED);

	// Get the index of the first item.
	if (m_iIndexSize == sizeof(USHORT))
	{
		USHORT		iIndex;
		RECORDID	RecordID;

		// Get the index for this item.
		iIndex = m_Bucket2[iHashVal % pThisIndexDef->HASHDATA.iBuckets];

		if (iIndex != m_Bucket2.GetEndMarker())
		{
			// Loop through each record in the list looking for matches.
			for (RecordID = iIndex, psRecord=m_Bucket2.GetRecord(RecordID);
					psRecord != 0;  
					psRecord=m_Bucket2.GetNextIndexRecord(psRecord, RecordID, pThisIndexDef))
			{
				// See if this one matches the index data.
				if (m_pRecordMgr->CompareKeys(pThisIndexDef, psRecord, 
							pData, iColumns, rgBindings) != 0)
				{
					continue;
				}

				// If there is a filter, then check that also.
				if (iFilterColumns && 
					m_pRecordMgr->QueryFilter(psRecord, iFilterColumns,
							rgFilterBindings, pbFilterData, rgfCompare) != 0)
				{
					continue;
				}

				// This one matched, so add it to the user's array.
				if (FAILED(hr = pFetchRecords->AddRecordToRowset(psRecord,
						&RecordID, pRecord)))
					break;
				++iFetched;

				// If index is unique, why bother looking for more data.
				if (pThisIndexDef->fFlags & DEXF_UNIQUE)
					break;
			}
		}
	}
	else
	{
		RECORDID	RecordID;

		// Get the index for this item.
		RecordID = m_Bucket4[iHashVal % pThisIndexDef->HASHDATA.iBuckets];

		if (RecordID != m_Bucket4.GetEndMarker())
		{
			// Loop through each record in the list looking for matches.
			for (psRecord=m_Bucket4.GetRecord(RecordID);
					psRecord != 0;  
					psRecord=m_Bucket4.GetNextIndexRecord(psRecord, RecordID, pThisIndexDef))
			{
				// See if this one matches the index data.
				if (m_pRecordMgr->CompareKeys(pThisIndexDef, psRecord, 
							pData, iColumns, rgBindings) != 0)
				{
					continue;
				}

				// If there is a filter, then check that also.
				if (iFilterColumns && 
					m_pRecordMgr->QueryFilter(psRecord, iFilterColumns,
							rgFilterBindings, pbFilterData, rgfCompare) != 0)
				{
					continue;
				}

				// This one matched, so add it to the user's array.
				if (FAILED(hr = pFetchRecords->AddRecordToRowset(psRecord,
						&RecordID, pRecord)))
					break;
				++iFetched;

				// If index is unique, why bother looking for more data.
				if (pThisIndexDef->fFlags & DEXF_UNIQUE)
					break;
			}
		}
	}
	
	// Map no rows into an hr.
	if (SUCCEEDED(hr) && iFetched == 0)
		return (CLDB_E_RECORD_NOTFOUND);
	return hr;
}


//*****************************************************************************
// Returns the indentifier for this index type.
//*****************************************************************************
BYTE StgHashedIndex::GetIndexType()
{
	return (0);
}


//*****************************************************************************
// Return the index definition for this item.
//*****************************************************************************
STGINDEXDEF *StgHashedIndex::GetIndexDef()
{
	// Verify we have the right data to get this value.
	_ASSERTE(m_pRecordMgr && m_cbIndexDef > sizeof(STGTABLEDEF));
	
	// Find the index in the table definition.
	STGTABLEDEF *pTbl = m_pRecordMgr->GetTableDef();
	STGINDEXDEF *pDex = (STGINDEXDEF *) ((UINT_PTR) pTbl + m_cbIndexDef);

	// In debug, validate that either we have too many keys to have the magic
	// byte, or that it is there.
	_ASSERTE(pDex->iKeys >= DFTKEYS || pDex->rgKeys[DFTKEYS - 1] == MAGIC_INDEX);
	return (pDex);
}



//
//
// Private methods.
//
//



//*****************************************************************************
// Do a hashed lookup using the index for the given record.  All of the key
// values must be supplied in the bindings.
//*****************************************************************************
HASHRECORD StgHashedIndex::HashFind(	// Record information.
	BYTE		*pData,					// User data.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[],			// Column accessors.
	RECORDID	*pRecordID)				// Record if found.
{
	HASHRECORD s;
	memset(&s, 0, sizeof(s));
	return (s);
}


//*****************************************************************************
// Add the given record to the index by hashing the key values and finding
// a location for insert.  If duplicates are enforced, then this function
// will catch an error.
//*****************************************************************************
HRESULT StgHashedIndex::HashAdd(		// Return code.
	STGTABLEDEF	*pTableDef,				// The table to work on.
	RECORDID	RecordID,				// The record to add to index.
	BYTE		*pData,					// User data.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[],			// Column accessors.
	int			bCheckDupes)			// true to enforce duplicates.
{
	ULONG		iHash;					// Hash value.
	USHORT		iBucket;				// The bucket to put item in.
	HRESULT		hr=S_OK;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());


	//
	// Step 1:  Check for duplicate key violation.
	//

	// Check this update to see if it is a duplicate value.
	if (bCheckDupes && 
		FAILED(hr = IsDuplicateRecord(pThisIndexDef, pData, iColumns, rgBindings)))
	{
		return (hr);
	}


	//
	// Step 2:  Must update the index.
	//

	// Compute the hash value and bucket for the entry
	VERIFY(HashKeys(pTableDef, pData, iColumns, rgBindings, &iHash) == S_OK);
	iBucket = (USHORT) (iHash % pThisIndexDef->HASHDATA.iBuckets);

//@todo: Why would you allow changes to a 2 byte bucket value?  This seems
// unecessary
	if (m_iIndexSize == sizeof(USHORT))
		m_Bucket2.HashAdd(iBucket, RecordID, pThisIndexDef);
	else
		m_Bucket4.HashAdd(iBucket, RecordID, pThisIndexDef);

	return (hr);
}


//*****************************************************************************
// Delete a hashed entry from the index.  You must have looked it up in the
// first place to delete it.
//*****************************************************************************
HRESULT StgHashedIndex::HashDel(		// Return code.
	STGTABLEDEF	*pTableDef,				// The table to work on.
	RECORDID	RecordID,				// The record to add to index.
	BYTE		*pData,					// User data.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	STGRECORDHDR *psRecord;				// For scanning.
	ULONG		iHash;					// Hash value.
	USHORT		iBucket;				// The bucket to put item in.
	HRESULT		hr;

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// Compute the hash value and bucket for the entry
	hr = HashKeys(pTableDef, pData, iColumns, rgBindings, &iHash);
	if (FAILED(hr))
		return (hr);

	iBucket = (USHORT) (iHash % pThisIndexDef->HASHDATA.iBuckets);

	// Can't update indexes in 2 byte bucket mode.
	_ASSERTE(m_iIndexSize == sizeof(ULONG));

	// If no data was ever set, it is not indexed so you won't find it.
	if (m_Bucket4[iBucket] == m_Bucket4.GetEndMarker())
		return (S_FALSE);

	// If the item is the first in the list, then change the bucket.
	if (m_Bucket4[iBucket] == RecordID)
		m_Bucket4[iBucket] = m_Bucket4.GetIndexValue(RecordID, pThisIndexDef);
	// Scan the list for the item in the collision chain and take it out.
	else
	{
		VERIFY(psRecord = m_Bucket4.GetRecord(m_Bucket4[iBucket]));

		while (psRecord && m_Bucket4.GetIndexValuePtr(psRecord, pThisIndexDef) != RecordID)
			psRecord = m_Bucket4.GetNextIndexRecord(psRecord, pThisIndexDef);

		// This probably means data was never indexed.  This means someone is
		// using the direct record support without actually updating indexes.
		// Not typical database behavior, but acceptable for this code base.
		if (psRecord == 0)
			return (S_FALSE);

		m_Bucket4.SetIndexValuePtr(psRecord, m_Bucket4.GetIndexValuePtr(m_Bucket4.GetRecord(RecordID), pThisIndexDef), pThisIndexDef);
	}
	return (S_OK);
}


//*****************************************************************************
// Generate a hashed value for the key information given.
//*****************************************************************************
HRESULT StgHashedIndex::HashKeys(		// Return code.
	STGTABLEDEF	*pTableDef,				// The table to work on.
	BYTE		*pData,					// User data.
	ULONG		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[],			// Column accessors.
	ULONG		*piHash)				// Return hash value here.
{
	STGCOLUMNDEF *pColDef;				// Column definition.
	BYTE		*pbHash;				// Working pointer.
	USHORT		iSize;					// Working loop control.
	BYTE		*piKey;					// List of keys.
	long		iHash = 0;				// Store hash value as built.
	int			i;						// Loop control.

	_ASSERTE(piHash);

	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	// Sanity check key info given.  Must match.
	_ASSERTE(iColumns == pThisIndexDef->iKeys);
	if (iColumns != pThisIndexDef->iKeys)
		return (0);

	// Walk the list of keys and hash each of the key values given.
	piKey = &pThisIndexDef->rgKeys[0];
	for (i=0;  i<pThisIndexDef->iKeys;  i++, piKey++)
	{
		// Key order must match bindings given.
		_ASSERTE(*piKey == rgBindings[i].iOrdinal);

		// Get a pointer to the data part.
		pbHash = DataPart(pData, &rgBindings[i]);

		// Cannot pass a NULL value for a keyed lookup, and you have
		// to give me a value to hash.
		if (((rgBindings[i].dwPart & DBPART_STATUS) != 0 && 
			StatusPart(pData, &rgBindings[i]) == DBSTATUS_S_ISNULL) ||
			(rgBindings[i].dwPart & DBPART_VALUE) == 0)
		{
			return (CLDB_E_INDEX_NONULLKEYS);
		}

		// Load the column definition.
		VERIFY(pColDef = pTableDef->GetColDesc((int)(rgBindings[i].iOrdinal - 1)));

		// Finally hash the data.
		if (IsNonPooledType(rgBindings[i].wType))
			iSize = pColDef->iSize;
		// Variable data requires checking user binding.
		else
		{
			iSize = (USHORT) LengthPart(pData, &rgBindings[i]);
			
			// GUID and VARIANT's are two special pooled types which have
			// fixed size.  Allow a caller (IST) to pass zero and still
			// get this size set, which is the case for all other fixed
			// size data types.
			if (!iSize)
			{
				if (pColDef->iType == DBTYPE_GUID)
					iSize = sizeof(GUID);
				else if (pColDef->iType == DBTYPE_VARIANT)
					iSize = sizeof(VARIANT);
			}
		}

		// Hash this value into the current hash.
		iHash = (*m_pfnHash)(iHash, pColDef->iType, pbHash, iSize, pColDef->fFlags & CTF_CASEINSENSITIVE );
	}
	
	// Save return value.
	*piHash = iHash;
	return (S_OK);
}


//*****************************************************************************
// Load the first entry in the given bucket.  The entry is addref'd to begin
// with and must be freed.
//*****************************************************************************
HRESULT StgHashedIndex::GetBucketHead(	// Return code.
	USHORT		iBucket,				// The bucket to load.
	STGHASHRECORD *&psHash)				// Pointer if successful.
{
	return (BadError(E_NOTIMPL));
}


//*****************************************************************************
// Create a new hash entry and return it to the caller.  The new entry has
// it's ID stamped.  The page it lives on is automatically dirtied for you,
// and the entry is add ref'd already.
//*****************************************************************************
HRESULT StgHashedIndex::GetNewHashEntry(// Return code.
	STGHASHRECORD *&psHash)			// Pointer if successful.
{
	return (BadError(E_NOTIMPL));
}


//*****************************************************************************
// Take a new entry which has the correct RecordID and hash value set, and
// insert it into the given bucket at a decent location.  The nodes in the hash
// chain are ordered by hash value.  This allows for faster lookups on collision.
//*****************************************************************************
HRESULT StgHashedIndex::InsertNewHashEntry(	// Return code.
	STGHASHRECORD *psBucket,			// Head node in bucket.
	STGHASHRECORD *psNewEntry)			// New entry to add.
{
	return (BadError(E_NOTIMPL));
}


//*****************************************************************************
// Called when the a node was taken from the free list but for some reason
// couldn't be placed into the bucket.
//*****************************************************************************
void StgHashedIndex::AbortNewHashEntry(	// Return code.
	STGHASHRECORD *psHash)				// Record to abort.
{
	
}




//*****************************************************************************
// Get the name of this index into a buffer suitable for things like errors.
//*****************************************************************************
HRESULT StgHashedIndex::GetIndexName(	// Return code.
	LPWSTR		szName,					// Name buffer.
	int			cchName)				// Max name.
{
	// Get the index definition for this object.
	STGINDEXDEF *pThisIndexDef;
	VERIFY(pThisIndexDef = GetIndexDef());

	return (m_pRecordMgr->GetSchema()->pNameHeap->GetStringW(
			pThisIndexDef->Name, szName, cchName));	
}


//*****************************************************************************
// If the index is unique or a primary key, then guarantee that this update
// does not cause a duplicate record.  Return an error if it does.
//*****************************************************************************
HRESULT StgHashedIndex::IsDuplicateRecord( // Return code.
	STGINDEXDEF *pIndexDef,				// Index definition.
	BYTE		*pData,					// User data.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	HRESULT		hr = S_OK;

	// If this is a unique index, look for duplicates first.
	if (pIndexDef->IsUnique() || pIndexDef->IsPrimaryKey()) 
	{
		STGRECORDHDR *rgRecord[1];
		CFetchRecords Records(rgRecord, 1);

		// Don't allow null value in unique/pk indexes.
		_ASSERTE(_DbgCheckIndexForNulls(m_pRecordMgr->GetTableDef(), iColumns, rgBindings) == S_OK);

		// Lookup the record in the hash table.  If not found, that is good.
		hr = FindRecord(pData, iColumns, rgBindings, 
						(DBCOMPAREOP *) g_rgCompareEq, &Records, 0, 0, 0, 0);
		if (hr == CLDB_E_RECORD_NOTFOUND)
			hr = S_OK;
		// Else the user attempted to insert a duplicate record which cannot
		// be allowed.  Give back an error in this case.
		else
		{
			WCHAR	rcwName[MAXINDEXNAME];
			GetIndexName(rcwName, MAXINDEXNAME);
			hr = PostError(CLDB_E_INDEX_DUPLICATE, rcwName);
		}
	}
	return (hr);
}



//
//
// Helper code.
//
//


//*****************************************************************************
// Return true if there are any null values present in the user's binding data.
//*****************************************************************************
int _BindingsContainNullValue(			// true if nulls present, false otherwise.
	ULONG		iColumns,				// User columns being bound.
	DBBINDING	rgBinding[],			// User bindings for data insert.
	const BYTE	*pData)					// User data to check.
{
	USHORT		i;						// Loop control.
	
	// Check the user's data.  The null value is not allowed for unique/pk.
	for (i=0;  i<iColumns;  i++)
	{
		if ((rgBinding[i].dwPart & DBPART_STATUS) &&
			(StatusPart(pData, &rgBinding[i]) & DBSTATUS_S_ISNULL))
		{
			return (true);
		}
	}
	return (false);
}


//*****************************************************************************
// Give a set of user bindings that reflect an update, decide if those updates
// are relevent to this index.
//*****************************************************************************
int _UpdatesRelevent(					// true if relevent to this index.
	STGINDEXDEF	*pIndexDef,				// The index being checked.
	USHORT		iColumns,				// How many columns to update.
	DBBINDING	rgBindings[])			// Column accessors.
{
	USHORT		iIndexCol, iBinding;	// Loop control.

	// Special case check, have to be touching columns to care.
	if (!iColumns)
		return (false);

	// Look for an intersection between the columns being upated and the
	// columns in the index.  If there is any intersection there, then this update
	// is relative to this index.  Note that this looping behavior is worst
	// case but the safest.  Any sort of sorting or other optimizations would
	// outway this technique given the small set of data being compared (typically
	// under only 1 or 2 indexed columns).
	for (iIndexCol=0;  iIndexCol<pIndexDef->iKeys;  iIndexCol++)
		for (iBinding=0;  iBinding<iColumns;  iBinding++)
		{
			if (pIndexDef->rgKeys[iIndexCol] == rgBindings[iBinding].iOrdinal)
				return (true);
		} 

	// At this point there was no intersection and therefore this index will
	// not be affected by this update.
	return (false);
}


//*****************************************************************************
// Round the see value up to the next valid prime number.  This is useful for
// hashing indexes because most hash functions hash better to a prime number.
// Since prime numbers are compute intensive to check, a table is kept up
// front.  Any value greater than that stored in the table is just accepted.
//*****************************************************************************
const USHORT griPrimeNumbers[] = { 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };
USHORT GetPrimeNumber(					// A prime number.
	USHORT		iSeed)					// Seed value.
{
	// Search the array up front to see if it is a match.
	CBinarySearch<USHORT> sSearch(griPrimeNumbers, NumItems(griPrimeNumbers));
	if (sSearch.Find(&iSeed) != 0)
		return (iSeed);

	// At this point scan for the first value greater than the seed.
	for (int i=0;  i<NumItems(griPrimeNumbers);  i++)
		if (iSeed < griPrimeNumbers[i])
			return (griPrimeNumbers[i]);
	return (iSeed);
}




#ifdef _DEBUG

//*****************************************************************************
// Helper function which should be called when a unique index or primary key
// is being modified.  This will verify that the columns disallow null (a
// schemagen/create table bug if this fails), and that the user didn't pass
// in a null value for data (user error).
//*****************************************************************************
HRESULT _DbgCheckIndexForNulls(			// S_OK if data ok, S_FALSE if null found.
	STGTABLEDEF	*pTableDef,				// Definition of the table in question.
	USHORT		iColumns,				// User columns being bound.
	DBBINDING	rgBinding[])			// User bindings for data insert.
{
	USHORT		i;						// Loop control.

	// Sanity check that all columns in this index are non-nullable.
	for (i=0;  i<iColumns;  i++)
	{
		STGCOLUMNDEF *pColDef;
		pColDef = pTableDef->GetColDesc((int)(rgBinding[i].iOrdinal - 1));
		_ASSERTE(pColDef->IsNullable() == false);
	}

	return (S_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgindexmanager.h ===
//*****************************************************************************
// StgIndexManager.h
//
// The index manager is in charge of indexing data in a table.  The main index
// type supported in this system in a persistent hashed index.  Support for
// unique indexes is offered, as well as heuristics for stripping indexes for
// small data, and configing bucket size dynamically based on load.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgIndexManager_h__
#define __StgIndexManager_h__

#include "StgDef.h"							// Standard storage struct defines.
#include "StgIndexManageri.h"				// Helper values.


const ULONG HASH_INDEX_THRESHOLD = 0xffff;



//*****************************************************************************
// This index hashes the key value into a set number of buckets and performs
// lookups based on the hashed values.
//*****************************************************************************
class StgHashedIndex : public IStgIndex
{
public:
//*****************************************************************************
// Init the index.
//*****************************************************************************
	StgHashedIndex(
		bool		bUnique=false);

//*****************************************************************************
// Clean up the index.
//*****************************************************************************
	virtual ~StgHashedIndex();

//*****************************************************************************
// Opens the index on top of the given table.
//*****************************************************************************
	virtual HRESULT Open(					// Return status.
		UINT_PTR	iIndexDef,				// Offset of index def.
		StgRecordManager *pRecordMgr,		// The record manager that owns us.
		RECORDHEAP	*pRecordHeap,			// The first heap for this table.
		ULONG		iRecords,				// If -1, unknown.
		STGINDEXHDR	*pIndexHdr,				// The persisted header data.
		ULONG		*pcbSize);				// Return size of index data.

//*****************************************************************************
// Close the index and free any run-time state.
//*****************************************************************************
	virtual void Close();

//*****************************************************************************
// Returns the save size of this index object based on current data.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return status.
		ULONG		iIndexSize,				// Size of an index offset.
		ULONG		*pcbSave,				// Return save size here.
		ULONG		RecordCount);			// Total records to save, excluding deleted.

//*****************************************************************************
// Persist the index data into the stream.
//*****************************************************************************
	virtual HRESULT SaveToStream(			// Return status.
		IStream		*pIStream,				// Stream to save to.
		long		*pMappingTable=NULL,	// optional rid mapping table.
		ULONG		RecordCount=0);			// Total records to save, excluding deleted.

//*****************************************************************************
// Called by the record manager's Save() method before it tells the page
// manager to flush all changed pages to disk.  The index should perform any
// changes it needs before this event.
//*****************************************************************************
	virtual HRESULT BeforeSave();

//*****************************************************************************
// Called after a new row has been inserted into the table.  The index should
// update itself to reflect the new row.
//*****************************************************************************
	virtual HRESULT AfterInsert(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record after insert.
		int			bCheckDupes);			// true to enforce duplicates.

//*****************************************************************************
// Called after a row is deleted from a table.  The index must update itself
// to reflect the fact that the row is gone.
//*****************************************************************************
	virtual HRESULT AfterDelete(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord);			// The record to delete.

//*****************************************************************************
// Called before an update is applied to a row.  The data for the change is
// included.  The index must update itself if and only if the change in data
// affects the order of the index.
//*****************************************************************************
	virtual HRESULT BeforeUpdate(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

//*****************************************************************************
// Called after a row has been updated.  This is our chance to update the
// index with the new column data.
//*****************************************************************************
	virtual HRESULT AfterUpdate(			// Return status.
		STGTABLEDEF *pTableDef,				// Table definition to use.
		RECORDID	&RecordID,				// The record we inserted.
		STGRECORDHDR *psRecord,				// Record to be changed.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

//*****************************************************************************
// Looks up the given record given the column information.  The user data must
// match the data types of the indexed data exactly, no conversions are done.
// The order of the user columns must match the index definition exactly, no
// attempt to sort the columns is made.
//*****************************************************************************
	virtual HRESULT FindRecord(				// Return code.
		BYTE		*pData,					// User data.
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP rgfBindingCompare[],	// compare operators for the bindings.
		CFetchRecords *pFetchRecords,		// Return list of records here.
		BYTE		*pbFilterData=0,		// Filter data.
		ULONG		iFilterColumns=0,		// How many additional filter columns.
		DBBINDING	rgFilterBindings[]=0,	// Bindings for filter data.
		DBCOMPAREOP	rgfCompare[]=0);		// Filter comparison operators.

	virtual HRESULT FindRecord(				// Return code.
		BYTE		*pData,					// User data.
		ULONG		iKeyColumns,			// key columns
		ULONG		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		DBCOMPAREOP	rgfBindingCompare[],	// compare operators for the key columns
		CDynBitVector *pBits,			// record index in the array for the given data.
		int			iLevel)					// which column of the query are we at.
	{ 
		_ASSERTE(0);
		return (E_NOTIMPL); 
	}

//*****************************************************************************
// Returns the indentifier for this index type.
//*****************************************************************************
	virtual BYTE GetIndexType();

//*****************************************************************************
// Return the index definition for this item.
//*****************************************************************************
	virtual STGINDEXDEF *GetIndexDef();		// The definition of the index.

//*****************************************************************************
// Return the size of a RID required based on the count of records being stored.
//*****************************************************************************
	static int RIDSizeFromRecords(ULONG iRecords)
	{
		return (int)(iRecords < HASH_INDEX_THRESHOLD ? sizeof(USHORT) : sizeof(ULONG));
	}

private:
//*****************************************************************************
// Binary search a page in the case where the data is stored in order by 
// this index definition, but no persistent index data was kept in order to
// conserve space.
//*****************************************************************************
	HRESULT FindRecordDynamic(				// Return code.
		BYTE		*pData,					// User data.
		USHORT		iColumns,				// How many columns.
		DBBINDING	rgBindings[],			// Column accessors.
		CFetchRecords *pFetchRecords);		// Return list of records here.

//*****************************************************************************
// Do a hashed lookup using the index for the given record.  All of the key
// values must be supplied in the bindings.
//*****************************************************************************
	HASHRECORD HashFind(					// Record information.
		BYTE		*pData,					// User data.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[],			// Column accessors.
		RECORDID	*pRecordID);			// Record if found.

//*****************************************************************************
// Add the given record to the index by hashing the key values and finding
// a location for insert.  If duplicates are enforced, then this function
// will catch an error.
//*****************************************************************************
	HRESULT HashAdd(						// Return code.
		STGTABLEDEF	*pTableDef,				// The table to work on.
		RECORDID	RecordID,				// The record to add to index.
		BYTE		*pData,					// User data.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[],			// Column accessors.
		int			bCheckDupes=true);		// true to enforce duplicates.

//*****************************************************************************
// Delete a hashed entry from the index.  You must have looked it up in the
// first place to delete it.
//*****************************************************************************
	HRESULT HashDel(						// Return code.
		STGTABLEDEF	*pTableDef,				// The table to work on.
		RECORDID	RecordID,				// The record to add to index.
		BYTE		*pData,					// User data.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

//*****************************************************************************
// Generate a hashed value for the key information given.
//*****************************************************************************
	HRESULT HashKeys(						// Return code.
		STGTABLEDEF	*pTableDef,				// The table to work on.
		BYTE		*pData,					// User data.
		ULONG		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[],			// Column accessors.
		ULONG		*piHash);				// Return hash value here.

//*****************************************************************************
// Load the first entry in the given bucket.  The entry is addref'd to begin
// with and must be freed.
//*****************************************************************************
	HRESULT GetBucketHead(					// Return code.
		USHORT		iBucket,				// The bucket to load.
		STGHASHRECORD *&psHash);			// Pointer if successful.

//*****************************************************************************
// Create a new hash entry and return it to the caller.  The new entry has
// it's ID stamped.  The page it lives on is automatically dirtied for you,
// and the entry is add ref'd already.
//*****************************************************************************
	HRESULT GetNewHashEntry(				// Return code.
		STGHASHRECORD *&psHash);			// Pointer if successful.

//*****************************************************************************
// Take a new entry which has the correct RecordID and hash value set, and
// insert it into the given bucket at a decent location.  The nodes in the hash
// chain are ordered by hash value.  This allows for faster lookups on collision.
//*****************************************************************************
	HRESULT InsertNewHashEntry(				// Return code.
		STGHASHRECORD *psBucket,			// Head node in bucket.
		STGHASHRECORD *psNewEntry);			// New entry to add.

//*****************************************************************************
// Called when the a node was taken from the free list but for some reason
// couldn't be placed into the bucket.
//*****************************************************************************
	void AbortNewHashEntry(					// Return code.
		STGHASHRECORD *psHash);				// Record to abort.

//*****************************************************************************
// Get the name of this index into a buffer suitable for things like errors.
//*****************************************************************************
	HRESULT GetIndexName(					// Return code.
		LPWSTR		szName,					// Name buffer.
		int			cchName);				// Max name.

//*****************************************************************************
// If the index is unique or a primary key, then guarantee that this update
// does not cause a duplicate record.  Return an error if it does.
//*****************************************************************************
	HRESULT IsDuplicateRecord(				// Return code.
		STGINDEXDEF *pIndexDef,				// Index definition.
		BYTE		*pData,					// User data.
		USHORT		iColumns,				// How many columns to update.
		DBBINDING	rgBindings[]);			// Column accessors.

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }

	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}

private:
	StgRecordManager *m_pRecordMgr;			// Record manager for the table.
	UINT_PTR	m_cbIndexDef;				// Offset of the index def.
	CHashHelper2 m_Bucket2;					// Short bucket array.
	CHashHelper4 m_Bucket4;					// Long bucket array.
	int			m_iIndexSize;				// Which array are we using.
	bool		m_bUnique;					// true if unique enforced.
	ULONG		m_cRef;
	PFN_HASH_PERSIST m_pfnHash;
#ifdef _DEBUG
	ULONG		m_cbDebugSaveSize;			// GetSaveSize debugging.
#endif
};




//*****************************************************************************
// Round the see value up to the next valid prime number.  This is useful for
// hashing indexes because most hash functions hash better to a prime number.
// Since prime numbers are compute intensive to check, a table is kept up
// front.  Any value greater than that stored in the table is just accepted.
//*****************************************************************************
USHORT GetPrimeNumber(					// A prime number.
	USHORT		iSeed);					// Seed value.




#endif // __StgIndexManager_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgio.h ===
//*****************************************************************************
// StgIO.h
//
// This module handles disk/memory i/o for a generic set of storage solutions,
// including:
//	* File system handle (HFILE)
//	* IStream
//	* User supplied memory buffer (non-movable)
//
// The Read, Write, Seek, ... functions are all directed to the corresponding
// method for each type of file, allowing the consumer to use one set of api's.
//
// File system data can be paged fully into memory in two scenarios:
//	read:	Normal Win32 memory mapped file is created to manage paging.
//	write:	A custom paging system provides storage for pages as required.  This
//				data is invalidated when you call Rewrite on the file.
//
// Transactions and backups are handled in the existing file case only.  The
// Rewrite function can make a backup of the current contents, and the Restore
// function can be used to recover the data into the current scope.  The backup
// file is flushed to disk (which is slower but safer) after the copy.  The
// Restore also flushed the recovered changes to disk.  Worst case scenario you
// get a crash after calling Rewrite but before Restore, in which case you will
// have a foo.clb.txn file in the same directory as the source file, foo.clb in
// this example.
//
// @todo: issues,
//	1.  For reading a .clb in an image, it would be great to memory map
//		only the portion of the file with the .clb in it.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#include "icmprecs.h"


// Types of IO we can handle.
enum STGIOTYPE
{
	STGIO_NODATA,							// Currently not open.
	STGIO_HFILE,							// File handle contains data.
	STGIO_STREAM,							// Stream pointer has data.
	STGIO_MEM,								// In memory pointer has data.
	STGIO_SHAREDMEM,						// Shared memory handle.
	STGIO_HFILEMEM							// Handle open, but memory allocated.
};


class StgIO
{
public:
	StgIO(
		bool		bAutoMap=true);			// Memory map for read on open?

	~StgIO();

//*****************************************************************************
// Open the base file on top of: (a) file, (b) memory buffer, or (c) stream.
// If create flag is specified, then this will create a new file with the
// name supplied.  No data is read from an opened file.  You must call
// MapFileToMem before doing direct pointer access to the contents.
//*****************************************************************************
	HRESULT Open(							// Return code.
		LPCWSTR		szName,					// Name of the storage.
		long		fFlags,					// How to open the file.
		const void	*pbBuff=0,				// Optional buffer for memory.
		ULONG		cbBuff=0,				// Size of buffer.
		IStream		*pIStream=0,			// Stream for input.
		LPCWSTR		szSharedMem=0,			// Shared memory name.
		LPSECURITY_ATTRIBUTES pAttributes=0); // Security token.

//*****************************************************************************
// Shut down the file handles and allocated objects.
//*****************************************************************************
	void Close();

//*****************************************************************************
// Read data from the storage source.  This will handle all types of backing
// storage from mmf, streams, and file handles.  No read ahead or MRU
// caching is done.
//*****************************************************************************
	HRESULT Read(							// Return code.
		void		*pbBuff,				// Write buffer here.
		ULONG		cbBuff,					// How much to read.
		ULONG		*pcbRead);				// How much read.

//*****************************************************************************
// Write to disk.  This function will cache up to a page of data in a buffer
// and peridocially flush it on overflow and explicit request.  This makes it
// safe to do lots of small writes without too much performance overhead.
//*****************************************************************************
	HRESULT Write(							// Return code.
		const void	*pbBuff,				// Buffer to write.
		ULONG		cbWrite,				// How much.
		ULONG		*pcbWritten);			// Return how much written.

//*****************************************************************************
// Moves the file pointer to the new location.  This handles the different
// types of storage systems.
//*****************************************************************************
	ULONG Seek(								// New offset.
		long		lVal,					// How much to move.
		ULONG		fMoveType);				// Direction, use Win32 FILE_xxxx.

//*****************************************************************************
// Retrieves the current offset for the storage being used.  This value is
// tracked based on Read, Write, and Seek operations.
//*****************************************************************************
	ULONG GetCurrentOffset();				// Current offset.

//*****************************************************************************
// Map the file contents to a memory mapped file and return a pointer to the 
// data.  For read/write with a backing store, map the file using an internal
// paging system.
//*****************************************************************************
	HRESULT MapFileToMem(					// Return code.
		void		*&ptr,					// Return pointer to file data.
		ULONG		*pcbSize,				// Return size of data.
		LPSECURITY_ATTRIBUTES pAttributes=0); // Security token.

//*****************************************************************************
// Free the mapping object for shared memory but keep the rest of the internal
// state intact.
//*****************************************************************************
	HRESULT ReleaseMappingObject();			// Return code.

//*****************************************************************************
// Resets the logical base address and size to the value given.  This is for
// cases like finding a section embedded in another format, like the .clb inside
// of an image.  GetPtrForMem, Read, and Seek will then behave as though only
// data from pbStart to cbSize is valid.
//*****************************************************************************
	HRESULT SetBaseRange(					// Return code.
		void		*pbStart,				// Start of file data.
		ULONG		cbSize);				// How big is the range.

//*****************************************************************************
// For read/write case, get a pointer to a chunk of the file at cbStart for
// size cbSize.  Return the pointer.  This will page in parts of the file from
// disk if not already loaded.
//*****************************************************************************
	HRESULT GetPtrForMem(					// Return code.
		ULONG		cbStart,				// Offset from beginning to load.
		ULONG		cbSize,					// How much, rounded to page.
		void		*&ptr);					// Return pointer on success.

//*****************************************************************************
// For cached writes, flush the cache to the data store.
//*****************************************************************************
	HRESULT FlushCache();

//*****************************************************************************
// Tells the Win32 file system to flush any cached data it may have.  This is
// expensive, but if successful guarantees you won't loose writes short of
// a disk failure.
//*****************************************************************************
	HRESULT FlushFileBuffers();

//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
	HRESULT Rewrite(						// Return code.
		LPWSTR		szBackup);				// If non-0, backup the file.

//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
	HRESULT ResetBackingStore();			// Return code.

//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
	HRESULT Restore(						// Return code.
		LPWSTR		szBackup,				// If non-0, backup the file.
		int			bDeleteOnSuccess);		// Delete backup file if successful.

	LPCWSTR GetFileName()
	{ return (m_rcFile); }

	int IsReadOnly()
	{ return ((m_fFlags & DBPROP_TMODEF_WRITE) == 0); }

	ULONG GetFlags()
	{ return (m_fFlags); }

	ULONG SetFlags(ULONG fFlags)
	{ m_fFlags = fFlags;
		return (m_fFlags); }

	ULONG GetDataSize()
	{ return (m_cbData); }

	long AddRef()
	{
		return (++m_cRef);
	}

	long Release()
	{
		long cRef = --m_cRef;
		if (cRef == 0)
			delete this;
		return (cRef);
	}

#ifdef _DEBUG
	int IsAlignedPtr(UINT_PTR Value, int iAlignment);
#endif

private:
	int IsBackingStore()
	{ return (m_rgPageMap != 0); }
	int IsMemoryMapped()
	{ return (m_hMapping != 0); }

	void CtorInit();
	HRESULT WriteToDisk(const void *pbBuff, ULONG cbWrite, ULONG *pcbWritten);
	HRESULT ReadFromDisk(void *pbBuff, ULONG cbBuff, ULONG *pcbRead);
	HRESULT CopyFileInternal(LPCWSTR szTo, int bFailIfThere, int bWriteThrough);
	void FreePageMap();

private:
	// Flags and state data.
	WCHAR		m_rcFile[_MAX_PATH];	// Path of the file we manage.
	WCHAR		m_rcShared[MAXSHMEM];	// Name of shared memory segment.
	long		m_cRef;					// Ref count on this object.
	bool		m_bWriteThrough : 1;	// true for write through mode.
	bool		m_bRewrite : 1;			// State check for rewrite mode.
	bool		m_bAutoMap : 1;			// true to automatically memory map file.
	bool		m_bFreeMem : 1;			// true to free allocated memory.

	// Handles.
	CComPtr<IStream> m_pIStream;		// For save to stream instead of file.
	HANDLE		m_hFile;				// The actual file with contents.
	HANDLE		m_hMapping;				// Mapping handle.
	void		*m_pBaseData;			// Base address for memory mapped file.
	void		*m_pData;				// For memory mapped file read.
	ULONG		m_cbData;				// Size of in memory data.
	long		m_fFlags;				// Flags for open/create mode.
	STGIOTYPE	m_iType;				// Where is the data.

	// File cache information.
	BYTE		*m_rgBuff;				// Cache buffer for writing.
	ULONG		m_cbBuff;				// Current cache size.
	ULONG		m_cbOffset;				// Current offset in file.

	// Buffer read management.
	static int	m_iPageSize;			// Size of an OS page.
	static int	m_iCacheSize;			// How big a write back cache to use.
	BYTE		*m_rgPageMap;			// Track loaded pages on read/write.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgio.cpp ===
//*****************************************************************************
// StgIO.h
//
// This module handles disk/memory i/o for a generic set of storage solutions,
// including:
//	* File system handle (HFILE)
//	* IStream
//	* User supplied memory buffer (non-movable)
//
// The Read, Write, Seek, ... functions are all directed to the corresponding
// method for each type of file, allowing the consumer to use one set of api's.
//
// File system data can be paged fully into memory in two scenarios:
//	read:	Normal Win32 memory mapped file is created to manage paging.
//	write:	A custom paging system provides storage for pages as required.  This
//				data is invalidated when you call Rewrite on the file.
//
// Transactions and backups are handled in the existing file case only.  The
// Rewrite function can make a backup of the current contents, and the Restore
// function can be used to recover the data into the current scope.  The backup
// file is flushed to disk (which is slower but safer) after the copy.  The
// Restore also flushed the recovered changes to disk.  Worst case scenario you
// get a crash after calling Rewrite but before Restore, in which case you will
// have a foo.clb.txn file in the same directory as the source file, foo.clb in
// this example.
//
// @todo: issues,
//	1.  For reading a .clb in an image, it would be great to memory map
//		only the portion of the file with the .clb in it.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard headers.
#include "Errors.h"						// Posting exceptions.
#include "complib.h"					// Open mode flags.
#include "StgIO.h"						// Our definitions.


//********** Types. ***********************************************************
#define SMALL_ALLOC_MAP_SIZE (64 * 1024) // 64 kb is the minimum size of virtual
										// memory you can allocate, so anything
										// less is a waste of Virtuam Memory resources.
#define MIN_WRITE_CACHE_BYTES (16 * 1024) // 16 kb for a write back cache



//********** Locals. **********************************************************
HRESULT MapFileError(DWORD error);
static void *AllocateMemory(int iSize);
static void FreeMemory(void *pbData);
inline HRESULT MapFileError(DWORD error)
{
	return (PostError(HRESULT_FROM_WIN32(error)));
}

// Static to class.
int	StgIO::m_iPageSize=0;				// Size of an OS page.
int	StgIO::m_iCacheSize=0;				// Size for the write cache.



//********** Code. ************************************************************
StgIO::StgIO(
	bool		bAutoMap) :				// Memory map for read on open?
	m_bAutoMap(bAutoMap)
{
	CtorInit();

	// If the system page size has not been queried, do so now.
	if (m_iPageSize == 0)
	{
		SYSTEM_INFO	sInfo;				// Some O/S information.

		// Query the system page size.
		GetSystemInfo(&sInfo);
		m_iPageSize = sInfo.dwPageSize;
		m_iCacheSize = ((MIN_WRITE_CACHE_BYTES - 1) & ~(m_iPageSize - 1)) + m_iPageSize;
	}
}


void StgIO::CtorInit()
{
	m_bWriteThrough = false;
	m_bRewrite = false;
	m_bFreeMem = false;
	m_hFile = INVALID_HANDLE_VALUE;
	m_hMapping = 0;
	m_pBaseData = 0;
	m_pData = 0;
	m_cbData = 0;
	m_fFlags = 0;
	m_iType = STGIO_NODATA;
	m_cbOffset = 0;
	m_rgBuff = 0;
	m_cbBuff = 0;
	m_rgPageMap = 0;
	*m_rcFile = '\0';
	*m_rcShared = '\0';
	m_cRef = 1;
}



StgIO::~StgIO()
{
	if (m_rgBuff)
	{
		FreeMemory(m_rgBuff);
		m_rgBuff = 0;
	}

	Close();
}


//*****************************************************************************
// Open the base file on top of: (a) file, (b) memory buffer, or (c) stream.
// If create flag is specified, then this will create a new file with the
// name supplied.  No data is read from an opened file.  You must call
// MapFileToMem before doing direct pointer access to the contents.
//*****************************************************************************
HRESULT StgIO::Open(					// Return code.
	LPCWSTR		szName,					// Name of the storage.
	long		fFlags,					// How to open the file.
	const void	*pbBuff,				// Optional buffer for memory.
	ULONG		cbBuff,					// Size of buffer.
	IStream		*pIStream,				// Stream for input.
	LPCWSTR		szSharedMem,			// Shared memory name.
	LPSECURITY_ATTRIBUTES pAttributes)	// Security token.
{
	DWORD		dwFlagsAndAttributes = 0; // Attribute flags for backup.
	DWORD		dwReadWrite = 0;		// Access mode.
	HRESULT		hr;

	// Check for shared mode open.
	if (szSharedMem)
	{
		// Must give a name if you use this option.
		_ASSERTE(szSharedMem);
		_ASSERTE(fFlags & (DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE));

		// Cannot allow write mode access to mapped view of file.
		_ASSERTE((fFlags & DBPROP_TMODEF_WRITE) == 0);

		// Save the name.
		_ASSERTE(_tcslen(szSharedMem) < MAXSHMEM);
		_tcsncpy(m_rcShared, szSharedMem, MAXSHMEM);
		m_rcShared[MAXSHMEM - 1] = 0;
	}

	// If we were given the storage memory to begin with, then use it.
	if (pbBuff && cbBuff)
	{
		_ASSERTE((fFlags & DBPROP_TMODEF_WRITE) == 0);

		// Save the memory address and size only.  No handles.
		m_pData = (void *) pbBuff;
		m_cbData = cbBuff;

		// All access to data will be by memory provided.
		m_iType = STGIO_MEM;
		goto ErrExit;
	}
	// Check for data backed by a stream pointer.
	else if (pIStream)
	{
		// If this is for the non-create case, get the size of existing data.
		if ((fFlags & DBPROP_TMODEF_CREATE) == 0)
		{
			LARGE_INTEGER	iMove = { 0, 0 };
			ULARGE_INTEGER	iSize;

			// Need the size of the data so we can map it into memory.
			if (FAILED(hr = pIStream->Seek(iMove, STREAM_SEEK_END, &iSize)))
				return (hr);
			m_cbData = iSize.LowPart;
		}
		// Else there is nothing.
		else
			m_cbData = 0;

		// Save an addref'd copy of the stream.
		m_pIStream = pIStream;

		// All access to data will be by memory provided.
		m_iType = STGIO_STREAM;
		goto ErrExit;
	}
	// Check for the open of a shared memory segment.
	else if (fFlags & DBPROP_TMODEF_SMEMOPEN)
	{
		// Save the size parameter given if open.
		if (!pbBuff && cbBuff && !m_cbData)
			m_cbData = cbBuff;

		// Treat this as a memory driven type.
		m_iType = STGIO_SHAREDMEM;
		m_fFlags = fFlags;

		// Try to do the map immediately.
		void		*ptr;
		ULONG		cb;
		
		if (FAILED(hr = MapFileToMem(ptr, &cb, pAttributes)))
		{
			// If we failed to open shared memory, and we're allowed to
			// create it, then proceed.
			if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
				(fFlags & DBPROP_TMODEF_SMEMCREATE))
			{
				hr = S_OK;
				
				// Don't try any opens at this point.
				fFlags &= ~DBPROP_TMODEF_SMEMOPEN;
			}
			else
			{
				Close();
				return (hr);
			}
		}
		else
			goto ErrExit;
	}

	// Check for backup semantics.
	if (fFlags & DBPROP_TMODEF_BACKUP_SEMANTICS)
		dwFlagsAndAttributes = FILE_FLAG_BACKUP_SEMANTICS;

	// If not on memory, we need a file to do a create/open.
	if (!szName || !*szName)
	{
		return (PostError(E_INVALIDARG));
	}
	// Check for create of a new file.
	else if (fFlags & DBPROP_TMODEF_CREATE)
	{
		// @future: This could chose to open the file in write through
		// mode, which would provide better Duribility (from ACID props),
		// but would be much slower.

		// Create the new file, overwriting only if caller allows it.
		if ((m_hFile = W95CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, pAttributes, 
				(fFlags & DBPROP_TMODEF_FAILIFTHERE) ? CREATE_NEW : CREATE_ALWAYS, 
				dwFlagsAndAttributes, 0)) == INVALID_HANDLE_VALUE)
		{
			return (MapFileError(GetLastError()));
		}

		// Data will come from the file.
		m_iType = STGIO_HFILE;
	}
	// For open in read mode, need to open the file on disk.  If opening a shared
	// memory view, it has to be opened already, so no file open.
	else if ((fFlags & DBPROP_TMODEF_WRITE) == 0)
	{
		// Open the file for read.  Sharing is determined by caller, it can
		// allow other readers or be exclusive.
		if ((m_hFile = W95CreateFile(szName, GENERIC_READ, 
					(fFlags & DBPROP_TMODEF_EXCLUSIVE) ? 0 : FILE_SHARE_READ,
					pAttributes, OPEN_EXISTING, dwFlagsAndAttributes, 0)) == INVALID_HANDLE_VALUE)
			return (MapFileError(GetLastError()));

		// Get size of file.
		m_cbData = ::SetFilePointer(m_hFile, 0, 0, FILE_END);

		// Data will come from the file.
		m_iType = STGIO_HFILE;
	}
	// For write mode, we're going to read everything into memory and
	// eventually rewrite it, so open for both in exclusive share mode.
	else if ((fFlags & (DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE)) == 0)
	{
		if ((m_hFile = W95CreateFile(szName, GENERIC_WRITE | GENERIC_READ, 
					0, pAttributes, OPEN_EXISTING, dwFlagsAndAttributes, 0)) == INVALID_HANDLE_VALUE)
			return (MapFileError(GetLastError()));

		// Get size of file.
		m_cbData = ::SetFilePointer(m_hFile, 0, 0, FILE_END);

		// Data will come from the file.
		m_iType = STGIO_HFILE;
	}

ErrExit:

	// If we will ever write, then we need the buffer cache.
	if (fFlags & DBPROP_TMODEF_WRITE)
	{
		// Allocate a cache buffer for writing.
		if ((m_rgBuff = (BYTE *) AllocateMemory(m_iCacheSize)) == 0)
		{
			Close();
			return (PostError(OutOfMemory()));
		}
		m_cbBuff = 0;
	}


	// Save flags for later.
	m_fFlags = fFlags;
	if (szName && *szName)
		wcscpy(m_rcFile, szName);

	// For auto map case, map the view of the file as part of open.
	if (m_bAutoMap && 
		(m_iType == STGIO_HFILE || m_iType == STGIO_STREAM || 
			(fFlags & (DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE))) &&
		!(fFlags & DBPROP_TMODEF_CREATE))
	{
		void		*ptr;
		ULONG		cb;
		
		if (FAILED(hr = MapFileToMem(ptr, &cb, pAttributes)))
		{
			Close();
			return (hr);
		}
	}
	return (S_OK);	
}


//*****************************************************************************
// Shut down the file handles and allocated objects.
//*****************************************************************************
void StgIO::Close()
{
	switch (m_iType)
	{
		// Free any allocated memory.
		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		case STGIO_HFILEMEM:
		if (m_bFreeMem && m_pBaseData)
		{
			FreeMemory(m_pBaseData);
			m_pBaseData = m_pData = 0;
		}
		// Intentional fall through to file case, if we kept handle open.

		case STGIO_HFILE:
		{
			// Free the file handle.
			if (m_hFile != INVALID_HANDLE_VALUE)
				CloseHandle(m_hFile);

			// If we allocated space for in memory paging, then free it.
		}
		break;

		// Free the stream pointer.
		case STGIO_STREAM:
		m_pIStream = 0;
		break;

		// Weird to shut down what you didn't open, isn't it?  Allow for
		// error case where dtor shuts down as after thought.
		case STGIO_NODATA:
		default:
		return;
	}

	// Free any page map and base data.
	FreePageMap();

	// Reset state values so we don't get confused.
	CtorInit();
}


//*****************************************************************************
// Read data from the storage source.  This will handle all types of backing
// storage from mmf, streams, and file handles.  No read ahead or MRU
// caching is done.
//*****************************************************************************
HRESULT StgIO::Read(					// Return code.
	void		*pbBuff,				// Write buffer here.
	ULONG		cbBuff,					// How much to read.
	ULONG		*pcbRead)				// How much read.
{
	ULONG		cbCopy;					// For boundary checks.
	void		*pbData;				// Data buffer for mem read.
	HRESULT		hr = S_OK;

	// Validate arguments, don't call if you don't need to.
	_ASSERTE(pbBuff != 0);
	_ASSERTE(cbBuff > 0);

	// Get the data based on type.
	switch (m_iType)
	{
		// For data on file, there are two possiblities:
		// (1) We have an in memory backing store we should use, or
		// (2) We just need to read from the file.
		case STGIO_HFILE:
		{
			_ASSERTE(m_hFile != INVALID_HANDLE_VALUE);

			// Backing store does its own paging.
			if (IsBackingStore() || IsMemoryMapped())
			{
				// Force the data into memory.
				if (FAILED(hr = GetPtrForMem(GetCurrentOffset(), cbBuff, pbData)))
					goto ErrExit;

				// Copy it back for the user and save the size.
				memcpy(pbBuff, pbData, cbBuff);
				if (pcbRead)
					*pcbRead = cbBuff;				
			}
			// If there is no backing store, this is just a read operation.
			else
			{
				ULONG	cbTemp = 0;
				if (!pcbRead)
					pcbRead = &cbTemp;
				hr = ReadFromDisk(pbBuff, cbBuff, pcbRead);
				m_cbOffset += *pcbRead;
			}
		}
		break;

		// Data in a stream is always just read.
		case STGIO_STREAM:
		{
			_ASSERTE((IStream *) m_pIStream);
			if (!pcbRead)
				pcbRead = &cbCopy;
			hr = m_pIStream->Read(pbBuff, cbBuff, pcbRead);
			if (SUCCEEDED(hr))
				m_cbOffset += *pcbRead;
		}
		break;

		// Simply copy the data from our data.
		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		case STGIO_HFILEMEM:
		{
			_ASSERTE(m_pData && m_cbData);

			// Check for read past end of buffer and adjust.
			if (GetCurrentOffset() + cbBuff > m_cbData)
				cbCopy = m_cbData - GetCurrentOffset();
			else
				cbCopy = cbBuff;
							
			// Copy the data into the callers buffer.
			memcpy(pbBuff, (void *) ((UINT_PTR) m_pData + GetCurrentOffset()), cbCopy);
			if (pcbRead)
				*pcbRead = cbCopy;
			
			// Save a logical offset.
			m_cbOffset += cbCopy;
		}
		break;
		 
		case STGIO_NODATA:
		default:
		_ASSERTE(0);
		break;
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Write to disk.  This function will cache up to a page of data in a buffer
// and peridocially flush it on overflow and explicit request.  This makes it
// safe to do lots of small writes without too much performance overhead.
//*****************************************************************************
HRESULT StgIO::Write(					// true/false.
	const void	*pbBuff,				// Data to write.
	ULONG		cbWrite,				// How much data to write.
	ULONG		*pcbWritten)			// How much did get written.
{
	ULONG		cbWriteIn=cbWrite;		// Track amount written.
	ULONG		cbCopy;
	HRESULT		hr = S_OK;

	_ASSERTE(m_rgBuff != 0);
	_ASSERTE(cbWrite);

	while (cbWrite)
	{
		// In the case where the buffer is already huge, write the whole thing
		// and avoid the cache.
		if (m_cbBuff == 0 && cbWrite >= (ULONG) m_iPageSize)
		{
			if (SUCCEEDED(hr = WriteToDisk(pbBuff, cbWrite, pcbWritten)))
				m_cbOffset += cbWrite;
			break;
		}
		// Otherwise cache as much as we can and flush.
		else
		{
			// Determine how much data goes into the cache buffer.
			cbCopy = m_iPageSize - m_cbBuff;
			cbCopy = min(cbCopy, cbWrite);
			
			// Copy the data into the cache and adjust counts.
			memcpy(&m_rgBuff[m_cbBuff], pbBuff, cbCopy);
			pbBuff = (void *) ((UINT_PTR) pbBuff + cbCopy);
			m_cbBuff += cbCopy;
			m_cbOffset += cbCopy;
			cbWrite -= cbCopy;

			// If there is enough data, then flush it to disk and reset count.
			if (m_cbBuff >= (ULONG) m_iPageSize)
			{
				if (FAILED(hr = FlushCache()))
					break;
			}
		}
	}

	// Return value for caller.
	if (SUCCEEDED(hr) && pcbWritten)
		*pcbWritten = cbWriteIn;
	return (hr);
}


//*****************************************************************************
// Moves the file pointer to the new location.  This handles the different
// types of storage systems.
//*****************************************************************************
ULONG StgIO::Seek(						// New offset.
	long		lVal,					// How much to move.
	ULONG		fMoveType)				// Direction, use Win32 FILE_xxxx.
{
	ULONG		cbRtn = 0;
	HRESULT		hr;

	_ASSERTE(fMoveType >= FILE_BEGIN && fMoveType <= FILE_END);

	// Action taken depends on type of storage.
	switch (m_iType)
	{
		case STGIO_HFILE:
		{
			// Use the file system's move.
			_ASSERTE(m_hFile != INVALID_HANDLE_VALUE);
			cbRtn = ::SetFilePointer(m_hFile, lVal, 0, fMoveType);
			
			// Save the location redundently.
			if (cbRtn != 0xffffffff)
				m_cbOffset = cbRtn;
		}
		break;

		case STGIO_STREAM:
		{
			LARGE_INTEGER	iMove;
			ULARGE_INTEGER	iNewLoc;

			// Need a 64-bit int.
			iMove.QuadPart = lVal;

			// The move types are named differently, but have same value.
			if (FAILED(hr = m_pIStream->Seek(iMove, fMoveType, &iNewLoc)))
				return (hr);

			// Save off only out location.
			m_cbOffset = iNewLoc.LowPart;
		}
		break;

		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		case STGIO_HFILEMEM:
		{
			// We own the offset, so change our value.
			switch (fMoveType)
			{
				case FILE_BEGIN:
				_ASSERTE(lVal >= 0);
				m_cbOffset = lVal;
				break;

				case FILE_CURRENT:
				m_cbOffset = m_cbOffset + lVal;
				_ASSERTE(m_cbOffset < m_cbData);
				break;

				case FILE_END:
				_ASSERTE(lVal < (LONG) m_cbData);
				m_cbOffset = m_cbData + lVal;
				_ASSERTE(m_cbOffset < m_cbData);
				break;
			}

			cbRtn = m_cbOffset;
		}
		break;

		// Weird to seek with no data.
		case STGIO_NODATA:
		default:
		_ASSERTE(0);
		break;
	}
	return (cbRtn);
}


//*****************************************************************************
// Retrieves the current offset for the storage being used.  This value is
// tracked based on Read, Write, and Seek operations.
//*****************************************************************************
ULONG StgIO::GetCurrentOffset()			// Current offset.
{
	return (m_cbOffset);
}


//*****************************************************************************
// Map the file contents to a memory mapped file and return a pointer to the 
// data.  For read/write with a backing store, map the file using an internal
// paging system.
//*****************************************************************************
HRESULT StgIO::MapFileToMem(			// Return code.
	void		*&ptr,					// Return pointer to file data.
	ULONG		*pcbSize,				// Return size of data.
	LPSECURITY_ATTRIBUTES pAttributes)	// Security token.
{
    char		rcShared[MAXSHMEM];		// ANSI version of shared name.
	HRESULT		hr = S_OK;

	// Don't penalize for multiple calls.  Also, allow calls for mem type so
	// callers don't need to do so much checking.
	if (IsBackingStore() || IsMemoryMapped() || 
			m_iType == STGIO_MEM || m_iType == STGIO_HFILEMEM)
	{
		ptr = m_pData;
		if (pcbSize)
			*pcbSize = m_cbData;
		return (S_OK);
	}

#if defined(UNDER_CE) // CE doesn't have MapViewOfFileEx

	return (E_NOTIMPL);

#else // UNDER_CE

	// Check for a shared chunk of memory to create/open.
	if (m_fFlags & DBPROP_TMODEF_SMEMOPEN)
	{
		// Determine if there is a name for the shared memory to create/open.
		_ASSERTE(*m_rcShared);

		// Convert the name to ansi.
		Wsz_wcstombs(rcShared, m_rcShared, sizeof(rcShared));

		// First open the shared memory handle into this process.
		_ASSERTE(m_hMapping == 0);
		m_hMapping = OpenFileMappingA(FILE_MAP_READ, FALSE, rcShared);
		if (!m_hMapping)
		{
			hr = MapFileError(GetLastError());
			goto ErrExit;
		}

		// Now map the file into memory so we can read from pointer access.
		// Note: Added a check for IsBadReadPtr per the Services team which
		// indicates that under some conditions this API can give you back
		// a totally bogus pointer.
		void *pbData;
		pbData = MapViewOfFileEx(m_hMapping, FILE_MAP_READ, 0, 0, 0, m_pData);
		if (!pbData || IsBadReadPtr(pbData, m_iPageSize))
		{
			hr = MapFileError(GetLastError());
			if (!FAILED(hr))
				hr = PostError(CLDB_E_FILE_CORRUPT);
			goto ErrExit;
		}

		// Check for relocation.  This is the case where the caller has done
		// a light close of a memory mapped object but kept its pointer state.
		// They are now doing a light weight open but the memory could not
		// be mapped to the same location in the address state.  Their in-memory
		// state is now bogus and they need to know that.
		if (m_pData != 0 && pbData != m_pData)
		{
			VERIFY(UnmapViewOfFile(pbData));
			hr = CLDB_E_RELOCATED;
			goto ErrExit;
		}

		// Assume a file with unknown size is simply the rest of the process space.
		// This makes it easier on the caller who doesn't have to know the size
		// up front.
#if defined(_WIN64)
		if (m_cbData == 0)
			m_cbData = ULONG_MAX - 1;
#else
		if (m_cbData == 0)
			m_cbData = ((ULONG) -1) - (ULONG) pbData - 4096;
#endif // _WIN64

		// Everything is ok for us to use.
		m_pBaseData = m_pData = pbData;
	}
	// Check the size of the data we want to map.  If it is small enough, then
	// simply allocate a chunk of memory from a finer grained heap.  This saves
	// virtual memory space, page table entries, and should reduce overall working set.
	// Note that any shared memory objects will require the handles to be in place
	// and are not elligible.  Also, open for read/write needs a full backing
	// store.
	else 

#endif // UNDER_CE
	
	if (!*m_rcShared && m_cbData <= SMALL_ALLOC_MAP_SIZE)
	{
		DWORD cbRead = m_cbData;
		_ASSERTE(m_pData == 0);

		// Just malloc a chunk of data to use.
		m_pBaseData = m_pData = AllocateMemory(m_cbData);
		if (!m_pData)
		{
			hr = OutOfMemory();
			goto ErrExit;
		}

		// Read all of the file contents into this piece of memory.
		Seek(0, FILE_BEGIN);
		if (FAILED(hr = Read(m_pData, cbRead, &cbRead)))
		{
			FreeMemory(m_pData);
			m_pData = 0;
			goto ErrExit;
		}
		_ASSERTE(cbRead == m_cbData);

		// If the file isn't being opened for exclusive mode, then free it.
		// If it is for exclusive, then we need to keep the handle open so the
		// file is locked, preventing other readers.  Also leave it open if
		// in read/write mode so we can truncate and rewrite.
		if (m_hFile == INVALID_HANDLE_VALUE ||
			((m_fFlags & DBPROP_TMODEF_EXCLUSIVE) == 0 && (m_fFlags & DBPROP_TMODEF_WRITE) == 0))
		{
			// If there was a handle open, then free it.
			if (m_hFile != INVALID_HANDLE_VALUE)
			{
				VERIFY(CloseHandle(m_hFile));
				m_hFile = INVALID_HANDLE_VALUE;
			}
			// Free the stream pointer.
			else
				m_pIStream = 0;

			// Switch the type to memory only access.
			m_iType = STGIO_MEM;
		}
		else
			m_iType = STGIO_HFILEMEM;

		// Free the memory when we shut down.
		m_bFreeMem = true;
	}
	// Finally, a real mapping file must be created.
	else
	{
		// Now we will map, so better have it right.
		_ASSERTE(m_hFile != INVALID_HANDLE_VALUE || m_iType == STGIO_STREAM);
		_ASSERTE(m_rgPageMap == 0);

		// For read mode, use Windows memory mapped file since the size will never
		// change for the life of the handle.
		if ((m_fFlags & DBPROP_TMODEF_WRITE) == 0 && m_iType != STGIO_STREAM)
		{
			_ASSERTE(!*m_rcShared || (m_fFlags & (DBPROP_TMODEF_SMEMCREATE | DBPROP_TMODEF_SMEMOPEN)));

			// Create a mapping object for the file.
			_ASSERTE(m_hMapping == 0);
			if ((m_hMapping = WszCreateFileMapping(m_hFile, pAttributes, PAGE_READONLY,
					0, 0, *m_rcShared ? m_rcShared : 0)) == 0)
			{
				return (MapFileError(GetLastError()));
			}

			// Check to see if the memory already exists, in which case we have
			// no guarantees it is the right piece of data.
			if (GetLastError() == ERROR_ALREADY_EXISTS)
			{
				hr = PostError(CLDB_E_SMDUPLICATE, rcShared);
				goto ErrExit;
			}

			// Now map the file into memory so we can read from pointer access.
			// Note: Added a check for IsBadReadPtr per the Services team which
			// indicates that under some conditions this API can give you back
			// a totally bogus pointer.
			if ((m_pBaseData = m_pData = MapViewOfFile(m_hMapping, FILE_MAP_READ,
						0, 0, 0)) == 0 ||
				IsBadReadPtr(m_pData, m_iPageSize))
			{
				hr = MapFileError(GetLastError());
				if (!FAILED(hr))
					hr = PostError(CLDB_E_FILE_CORRUPT);
				
				// In case we got back a bogus pointer.
				m_pBaseData = m_pData = 0;
				goto ErrExit;
			}
		}
		// In write mode, we need the hybrid combination of being able to back up
		// the data in memory via cache, but then later rewrite the contents and
		// throw away our cached copy.  Memory mapped files are not good for this
		// case due to poor write characteristics.
		else
		{
			ULONG		iMaxSize;			// How much memory required for file.

			// Figure out how many pages we'll require, round up actual data
			// size to page size.
			iMaxSize = (((m_cbData - 1) & ~(m_iPageSize - 1)) + m_iPageSize);

			// Allocate a bit vector to track loaded pages.
			if ((m_rgPageMap = new BYTE[iMaxSize / m_iPageSize]) == 0)
				return (PostError(OutOfMemory()));
			memset(m_rgPageMap, 0, sizeof(BYTE) * (iMaxSize / m_iPageSize));

			// Allocate space for the file contents.
			if ((m_pBaseData = m_pData = ::VirtualAlloc(0, iMaxSize, MEM_RESERVE, PAGE_NOACCESS)) == 0)
			{
				hr = PostError(OutOfMemory());
				goto ErrExit;
			}
		}
	}

	// Reset any changes made by mapping.
	Seek(0, FILE_BEGIN);
	if (pcbSize)
		*pcbSize = m_cbData;

ErrExit:

	// Check for errors and clean up.
	if (FAILED(hr))
	{
		if (m_hMapping)
			CloseHandle(m_hMapping);
		m_hMapping = 0;
		m_pBaseData = m_pData = 0;
	}
	return (hr);
}


//*****************************************************************************
// Free the mapping object for shared memory but keep the rest of the internal
// state intact.
//*****************************************************************************
HRESULT StgIO::ReleaseMappingObject()	// Return code.
{
	// Check type first.
	if (m_iType != STGIO_SHAREDMEM)
	{
		_ASSERTE(0);
		return (S_OK);
	}

	// Must have an allocated handle.
	_ASSERTE(m_hMapping != 0);

	// Freeing the mapping object doesn't do any good if you still have the file.
	_ASSERTE(m_hFile == INVALID_HANDLE_VALUE);

	// Unmap the memory we allocated before freeing the handle.  But keep the
	// memory address in tact.
	if (m_pData)
		VERIFY(UnmapViewOfFile(m_pData));

	// Free the handle.
	if (m_hMapping != 0)
	{
		VERIFY(CloseHandle(m_hMapping));
		m_hMapping = 0;
	}
	return (S_OK);
}



//*****************************************************************************
// Resets the logical base address and size to the value given.  This is for
// cases like finding a section embedded in another format, like the .clb inside
// of an image.  GetPtrForMem, Read, and Seek will then behave as though only
// data from pbStart to cbSize is valid.
//*****************************************************************************
HRESULT StgIO::SetBaseRange(			// Return code.
	void		*pbStart,				// Start of file data.
	ULONG		cbSize)					// How big is the range.
{
	// The base range must be inside of the current range.
	_ASSERTE(m_pBaseData && m_cbData);
	_ASSERTE((UINT_PTR) pbStart >= (UINT_PTR) m_pBaseData);
	_ASSERTE((UINT_PTR) pbStart + cbSize < (UINT_PTR) m_pBaseData + m_cbData);

	// Save the base range per user request.
	m_pData = pbStart;
	m_cbData = cbSize;
	return (S_OK);
}


//*****************************************************************************
// Caller wants a pointer to a chunk of the file.  This function will make sure
// that the memory for that chunk has been committed and will load from the
// file if required.  This algorithm attempts to load no more data from disk
// than is necessary.  It walks the required pages from lowest to highest,
// and for each block of unloaded pages, the memory is committed and the data
// is read from disk.  If all pages are unloaded, all of them are loaded at
// once to speed throughput from disk.
//*****************************************************************************
HRESULT StgIO::GetPtrForMem(			// Return code.
	ULONG		cbStart,				// Where to start getting memory.
	ULONG		cbSize,					// How much data.
	void		*&ptr)					// Return pointer to memory here.
{
	int			iFirst, iLast;			// First and last page required.
	ULONG		iOffset, iSize;			// For committing ranges of memory.
	int			i, j;					// Loop control.
	HRESULT		hr;

	// We need either memory (mmf or user supplied) or a backing store to
	// return a pointer.  Call Read if you don't have these.
	if (!IsBackingStore() && m_pData == 0)
		return (PostError(BadError(E_UNEXPECTED)));

	// Validate the caller isn't asking for a data value out of range.
	_ASSERTE(cbStart + cbSize <= m_cbData);

	// This code will check for pages that need to be paged from disk in
	// order for us to return a pointer to that memory.
	if (IsBackingStore())
	{
		// Backing store is bogus when in rewrite mode.
		if (m_bRewrite)
			return (PostError(BadError(E_UNEXPECTED)));

		// Must have the page map to continue.
		_ASSERTE(m_rgPageMap && m_iPageSize && m_pData);

		// Figure out the first and last page that are required for commit.
		iFirst = cbStart / m_iPageSize;
		iLast = (cbStart + cbSize - 1) / m_iPageSize;

		// Avoid confusion.
		ptr = 0;

		// Do a smart load of every page required.  Do not reload pages that have
		// already been brought in from disk.
		//@todo: add an optimization so that when all pages have been faulted, we no
		// longer to a page by page search.
		for (i=iFirst;  i<=iLast;  )
		{
			// Find the first page that hasn't already been loaded.
			while (GetBit(m_rgPageMap, i) && i<=iLast)
				++i;
			if (i > iLast)
				break;

			// Offset for first thing to load.
			iOffset = i * m_iPageSize;
			iSize = 0;

			// See how many in a row have not been loaded.
			for (j=i;  i<=iLast && !GetBit(m_rgPageMap, i);  i++)
				iSize += m_iPageSize;

			// First commit the memory for this part of the file.
			if (::VirtualAlloc((void *) ((UINT_PTR) m_pData + iOffset), 
					iSize, MEM_COMMIT, PAGE_READWRITE) == 0)
				return (PostError(OutOfMemory()));

			// Now load that portion of the file from disk.
			if (FAILED(hr = Seek(iOffset, FILE_BEGIN)) ||
				FAILED(hr = ReadFromDisk((void *) ((UINT_PTR) m_pData + iOffset), iSize, 0)))
			{
				return (hr);
			}

			// Change the memory to read only to avoid any modifications.  Any faults
			// that occur indicate a bug whereby the engine is trying to write to
			// protected memory.
			_ASSERTE(::VirtualAlloc((void *) ((UINT_PTR) m_pData + iOffset), 
					iSize, MEM_COMMIT, PAGE_READONLY) != 0);
		
			// Record each new loaded page.
			for (;  j<i;  j++)
				SetBit(m_rgPageMap, j, true);
		}

		// Everything was brought into memory, so now return pointer to caller.
		ptr = (void *) ((UINT_PTR) m_pData + cbStart);
	}
	// Memory version or memory mapped file work the same way.
	else if (IsMemoryMapped() || m_iType == STGIO_MEM || 
			m_iType == STGIO_SHAREDMEM || m_iType == STGIO_HFILEMEM)
	{	
		_ASSERTE(cbStart < m_cbData);
		ptr = (void *) ((UINT_PTR) m_pData + cbStart);
	}
	// What's left?!  Add some defense.
	else
	{
		_ASSERTE(0);
		ptr = 0;
	}
	return (S_OK);
}


//*****************************************************************************
// For cached writes, flush the cache to the data store.
//*****************************************************************************
HRESULT StgIO::FlushCache()
{
	ULONG		cbWritten;
	HRESULT		hr;

	if (m_cbBuff)
	{
		if (FAILED(hr = WriteToDisk(m_rgBuff, m_cbBuff, &cbWritten)))
			return (hr);
		m_cbBuff = 0;
	}
	return (S_OK);
}

//*****************************************************************************
// Tells the Win32 file system to flush any cached data it may have.  This is
// expensive, but if successful guarantees you won't loose writes short of
// a disk failure.
//*****************************************************************************
HRESULT StgIO::FlushFileBuffers()
{
	_ASSERTE(!IsReadOnly());

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		if (::FlushFileBuffers(m_hFile))
			return (S_OK);
		else
			return (MapFileError(GetLastError()));
	}
	return (S_OK);
}


//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
HRESULT StgIO::Rewrite(					// Return code.
	LPWSTR		szBackup)				// If non-0, backup the file.
{
#ifdef UNDER_CE

    return (E_NOTIMPL);

#else // UNDER_CE

    void		*ptr;					// Working pointer.
	HRESULT		hr;

	// @todo: handle this case for stream.
	_ASSERTE(m_iType == STGIO_HFILE || m_hFile != INVALID_HANDLE_VALUE);
	if (m_hFile == INVALID_HANDLE_VALUE)
		return (BadError(E_UNEXPECTED));

	// Don't be calling this function for read only data.
	_ASSERTE(!IsReadOnly());

	// If there is still memory on disk, then it needs to be brought in because
	// we are about to truncate the file contents.  This state occurs when
	// data is partially faulted in, for example if there are 5 tables on disk
	// and you only opened 1 of them.  Also need to check for case where a save
	// was already done in this session.  In that case, there is no data on disk
	// that we care about and therefore we can't call GetPtrForMem.
	if (IsBackingStore())
	{
		if (FAILED(hr = GetPtrForMem(0, m_cbData, ptr)))
			return (hr);
	}

	// Caller wants a backup.  Create a temporary file copy of the user data,
	// and return the path to the caller.
	if (szBackup)
	{
		WCHAR		rcDir[_MAX_PATH];

		_ASSERTE(*m_rcFile);
		
		// Attempt to put the backup file in the user's directory so it is
		// easy for them to find on severe error.
		if (WszGetCurrentDirectory(_MAX_PATH, rcDir) &&
			(WszGetFileAttributes(rcDir) & FILE_ATTRIBUTE_READONLY) == 0)
		{
			WCHAR		rcDrive[_MAX_DRIVE];	// Volume name.
			WCHAR		rcDir2[_MAX_PATH];		// Directory.
			WCHAR		rcFile[_MAX_PATH];		// Name of file.

			SplitPath(m_rcFile, rcDrive, rcDir2, rcFile, 0);
			MakePath(szBackup, rcDrive, rcDir2, rcFile, L".clb.txn");
		}
		// Otherwise put the file in the temp directory.
		else
		{
			// Create a temporary path for backup.
			WszGetTempPath(sizeof(rcDir), rcDir);
			VERIFY(WszGetTempFileName(rcDir, L"clb", 0, szBackup));
		}

		// Copy the file to the temporary path.
		if (FAILED(hr = CopyFileInternal(szBackup, false, m_bWriteThrough)))
			return (hr);
	}

	// Set mode to rewrite.  The backing store is rendered invalid at this point,
	// unless Restore is called.  If the rewrite is successful, this state will
	// stay in affect until shutdown.
	m_bRewrite = true;

	// Verify that we don't have any hanging data from previous work.
	_ASSERTE(m_cbBuff == 0);
	m_cbBuff = 0;
	m_cbOffset = 0;

	// Truncate the file.
	_ASSERTE(!IsReadOnly() && m_hFile != INVALID_HANDLE_VALUE);
	::SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);
	VERIFY(::SetEndOfFile(m_hFile));
	return (S_OK);

#endif // UNDER_CE
}


//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
HRESULT StgIO::ResetBackingStore()		// Return code.
{
	// Don't be calling this function for read only data.
	_ASSERTE(!IsReadOnly());

	// Free up any backing store data we no longer need now that everything
	// is in memory.
	FreePageMap();
	return (S_OK);
}


//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
HRESULT StgIO::Restore(					// Return code.
	LPWSTR		szBackup,				// If non-0, backup the file.
	int			bDeleteOnSuccess)		// Delete backup file if successful.
{
	BYTE		rcBuffer[4096];			// Buffer for copy.
	ULONG		cbBuff;					// Bytes read/write.
	ULONG		cbWrite;				// Check write byte count.
	HANDLE		hCopy;					// Handle for backup file.

	// Don't be calling this function for read only data.
	_ASSERTE(!IsReadOnly());

	// Open the backup file.
	if ((hCopy = ::W95CreateFile(szBackup, GENERIC_READ, 0,
				0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
		return (MapFileError(GetLastError()));

	// Move to front of old file.
	VERIFY(::SetFilePointer(m_hFile, 0, 0, FILE_BEGIN) == 0);
	VERIFY(::SetEndOfFile(m_hFile));

	// Copy all data from the backup into our file.
	while (::ReadFile(hCopy, rcBuffer, sizeof(rcBuffer), &cbBuff, 0) && cbBuff)
		if (!::WriteFile(m_hFile, rcBuffer, cbBuff, &cbWrite, 0) || cbWrite != cbBuff)
		{
			::CloseHandle(hCopy);
			return (MapFileError(GetLastError()));
		}

	::CloseHandle(hCopy);

	// We were successful, so if caller desires, delete the backup file.
	if (::FlushFileBuffers(m_hFile) && 
			bDeleteOnSuccess
#if !defined(UNDER_CE) // On CE, always delete the file.  On other platforms, ask.
				&& REGUTIL::GetLong(L"AllowDeleteOnRevert", true)
#endif
			)
		VERIFY(::W95DeleteFile(szBackup));

	// Change mode back, after restore everything is back to open mode.
	m_bRewrite = false;
	return (S_OK);
}


//
// Private.
//



//*****************************************************************************
// This version will force the data in cache out to disk for real.  The code
// can handle the different types of storage we might be sitting on based on
// the open type.
//*****************************************************************************
HRESULT StgIO::WriteToDisk(				// Return code.
	const void	*pbBuff,				// Buffer to write.
	ULONG		cbWrite,				// How much.
	ULONG		*pcbWritten)			// Return how much written.
{
	ULONG		cbWritten;				// Buffer for write funcs.
	HRESULT		hr = S_OK;

	// Pretty obvious.
	_ASSERTE(!IsReadOnly());

	// Always need a buffer to write this data to.
	if (!pcbWritten)
		pcbWritten = &cbWritten;

	// Action taken depends on type of storage.
	switch (m_iType)
	{
		case STGIO_HFILE:
		case STGIO_HFILEMEM:
		{
			// Use the file system's move.
			_ASSERTE(m_hFile != INVALID_HANDLE_VALUE);

			// Do the write to disk.
			if (!::WriteFile(m_hFile, pbBuff, cbWrite, pcbWritten, 0))
				hr = MapFileError(GetLastError());
		}
		break;

		// Free the stream pointer.
		case STGIO_STREAM:
		{
			// Delegate write to stream code.
			hr = m_pIStream->Write(pbBuff, cbWrite, pcbWritten);
		}
		break;

		// We cannot write to fixed read/only memory.
		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		_ASSERTE(0);
		hr = BadError(E_UNEXPECTED);
		break;

		// Weird to seek with no data.
		case STGIO_NODATA:
		default:
		_ASSERTE(0);
		break;
	}
	return (hr);
}


//*****************************************************************************
// This version only reads from disk.
//*****************************************************************************
HRESULT StgIO::ReadFromDisk(			// Return code.
	void		*pbBuff,				// Write buffer here.
	ULONG		cbBuff,					// How much to read.
	ULONG		*pcbRead)				// How much read.
{
	ULONG		cbRead;

	_ASSERTE(m_iType == STGIO_HFILE || m_iType == STGIO_STREAM);

	// Need to have a buffer.
	if (!pcbRead)
		pcbRead = &cbRead;

	// Read only from file to avoid recursive logic.
	if (m_iType == STGIO_HFILE || m_iType == STGIO_HFILEMEM)
	{
		if (::ReadFile(m_hFile, pbBuff, cbBuff, pcbRead, 0))
			return (S_OK);
		return (MapFileError(GetLastError()));
	}
	// Read directly from stream.
	else
	{
		return (m_pIStream->Read(pbBuff, cbBuff, pcbRead));
	}
}


//*****************************************************************************
// Copy the contents of the file for this storage to the target path.
//*****************************************************************************
HRESULT StgIO::CopyFileInternal(		// Return code.
	LPCWSTR		szTo,					// Target save path for file.
	int			bFailIfThere,			// true to fail if target exists.
	int			bWriteThrough)			// Should copy be written through OS cache.
{
	DWORD		iCurrent;				// Save original location.
	DWORD		cbRead;					// Byte count for buffer.
	DWORD		cbWrite;				// Check write of bytes.
	BYTE		rgBuff[4096];			// Buffer for copy.
	HANDLE		hFile;					// Target file.
	HRESULT		hr = S_OK;

	// Create target file.
	if ((hFile = ::W95CreateFile(szTo, GENERIC_WRITE, 0, 0, 
			(bFailIfThere) ? CREATE_NEW : CREATE_ALWAYS, 
			(bWriteThrough) ? FILE_FLAG_WRITE_THROUGH : 0, 
			0)) == INVALID_HANDLE_VALUE)
	{
		return (MapFileError(GetLastError()));
	}

	// Save current location and reset it later.
	iCurrent = ::SetFilePointer(m_hFile, 0, 0, FILE_CURRENT);
	::SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);

	// Copy while there are bytes.
	while (::ReadFile(m_hFile, rgBuff, sizeof(rgBuff), &cbRead, 0) && cbRead)
	{
		if (!::WriteFile(hFile, rgBuff, cbRead, &cbWrite, 0) || cbWrite != cbRead)
		{
			hr = STG_E_WRITEFAULT;
			break;
		}
	}

	// Reset file offset.
	::SetFilePointer(m_hFile, iCurrent, 0, FILE_BEGIN);

	// Close target.
	if (!bWriteThrough)
		VERIFY(::FlushFileBuffers(hFile));
	::CloseHandle(hFile);
	return (hr);
}


//*****************************************************************************
// Free the data used for backing store from disk in read/write scenario.
//*****************************************************************************
void StgIO::FreePageMap()
{
	// If a small file was allocated, then free that memory.
	if (m_bFreeMem && m_pBaseData)
		FreeMemory(m_pBaseData);
	// For win32 mmf, close handles and free resources.
	else if (m_hMapping && m_pBaseData)
	{
		VERIFY(UnmapViewOfFile(m_pBaseData));
		VERIFY(CloseHandle(m_hMapping));
	}
	// For our own system, free memory.
	else if (m_rgPageMap && m_pBaseData)
	{
		delete [] m_rgPageMap;
		m_rgPageMap = 0;
		VERIFY(::VirtualFree(m_pBaseData, (((m_cbData - 1) & ~(m_iPageSize - 1)) + m_iPageSize), MEM_DECOMMIT));
		VERIFY(::VirtualFree(m_pBaseData, 0, MEM_RELEASE));
		m_pBaseData = 0;
		m_cbData = 0;	
	}

	m_pBaseData = 0;
	m_hMapping = 0;
	m_cbData = 0;
}


//*****************************************************************************
// Check the given pointer and ensure it is aligned correct.  Return true
// if it is aligned, false if it is not.
//*****************************************************************************
#ifdef _DEBUG
int StgIO::IsAlignedPtr(UINT_PTR Value, int iAlignment)
{
	void		*ptrStart;

	if (m_iType == STGIO_STREAM || m_iType == STGIO_MEM || 
				m_iType == STGIO_SHAREDMEM)
	{
		return ((Value - (UINT_PTR) m_pData) % iAlignment == 0);
	}
	else
	{
		_ASSERTE(GetPtrForMem(0, 1, ptrStart) == S_OK);
		_ASSERTE(Value > (UINT_PTR) ptrStart);
		return (((Value - (UINT_PTR) ptrStart) % iAlignment) == 0);	
	}
}
#endif





//*****************************************************************************
// These helper functions are used to allocate fairly large pieces of memory,
// more than should be taken from the runtime heap, but less that would require
// virtual memory overhead.
//*****************************************************************************
// #define _TRACE_MEM_ 1

void *AllocateMemory(int iSize)
{
	void * ptr;
	ptr = HeapAlloc(GetProcessHeap(), 0, iSize);

#if defined(_DEBUG) && defined(_TRACE_MEM_)
	static int i=0;
	DbgWriteEx(L"AllocateMemory: (%d) 0x%08x, size %d\n", ++i, ptr, iSize);
#endif
	return (ptr);
}


void FreeMemory(void *pbData)
{
#if defined(_DEBUG) && defined(_TRACE_MEM_)
	static int i=0;
	DbgWriteEx(L"FreeMemory: (%d) 0x%08x\n", ++i, pbData);
#endif

	_ASSERTE(pbData);
	VERIFY(HeapFree(GetProcessHeap(), 0, pbData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgindexmanageri.h ===
//*****************************************************************************
// StgIndexManageri.h
//
// This module contains helper code for the index manager.  This code is
// secondary to the primary interface and therefore here to reduce clutter.
// Most of this code deals with the fact that we need to handle both 2 and 4
// byte index values based dynamically on record size.  Rather than repeat the
// code that is sensitive to size everywhere, this part is templatized.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgIndexManageri_h__
#define __StgIndexManageri_h__


#include "StgRecordManager.h"			// Need to get records in template.


const USHORT HASH_END_MARKER2 = 0xffff;
const ULONG HASH_END_MARKER4 = 0xffffffff;


template <class T, T HASH_END_MARKER> class CHashHelper
{
public:
	CHashHelper(RECORDHEAP *pRecordHeap=0, STGINDEXDEF *pIndexDef=0) :
		m_pRecords(pRecordHeap),
		m_rgBuckets(0),
		m_iBuckets(0),
		m_bFree(false)
	{ }

	~CHashHelper()
	{
		if (m_bFree)
		{
			delete [] m_rgBuckets;
			m_rgBuckets = 0;
		}
	}

	void SetRecordMgr(RECORDHEAP *pRecordHeap)
	{ 
		m_pRecords = pRecordHeap; 
	}

//*****************************************************************************
// Call to init brand new array.
//*****************************************************************************
	HRESULT InitNew(						// Return code.
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		m_iBuckets = pIndexDef->HASHDATA.iBuckets;
		if ((m_rgBuckets = new T[m_iBuckets]) == 0)
			return (PostError(OutOfMemory()));
		for (int i=0;  i<m_iBuckets;  i++)
			m_rgBuckets[i] = HASH_END_MARKER;
		m_bFree = true;
		return (S_OK);
	}

//*****************************************************************************
// Init this class on top of the allocated memory, which we won't free.
//*****************************************************************************
	void InitOnMem(T rgBuckets[], int iBuckets)
	{
		_ASSERTE(m_rgBuckets == 0 && m_iBuckets == 0);
		m_rgBuckets = rgBuckets;
		m_iBuckets = iBuckets;
	}

//*****************************************************************************
// Save the buckets to the stream.
//*****************************************************************************
	HRESULT SaveToStream(					// Return code.
		IStream		*pIStream)				// The stream to save to.
	{
		ULONG		cbWrite;
		HRESULT		hr;

		// Write out the buckets.  Pad to 4 byte alignment if need be.
		cbWrite = sizeof(T) * m_iBuckets;
		hr = pIStream->Write(m_rgBuckets, cbWrite, 0);
		if (SUCCEEDED(hr) && ALIGN4BYTE(cbWrite) != cbWrite)
			hr = pIStream->Write(&hr, ALIGN4BYTE(cbWrite) - cbWrite, 0);
		return (hr);
	}

//*****************************************************************************
// Set the index value in the record to the value given.
//*****************************************************************************
	void SetIndexValue(
		RECORDID	RecordID,				// The record to set.
		T			iValue,					// The new value.
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		STGRECORDHDR *psRecord;				// The record to update.
		VERIFY(psRecord = GetRecord(RecordID));
		*(T *) ((UINT_PTR) psRecord + pIndexDef->HASHDATA.iNextOffset) = iValue;
	}
	void SetIndexValuePtr(
		STGRECORDHDR *psRecord,				// Record to modify.
		T			iValue,					// The new value.
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		*(T *) ((UINT_PTR) psRecord + pIndexDef->HASHDATA.iNextOffset) = iValue;
	}

//*****************************************************************************
// Get the index value for the given record.
//*****************************************************************************
	T GetIndexValue(						// The value for the record.
		RECORDID	RecordID,				// Which record.
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		STGRECORDHDR *psRecord;				// The record to update.
		VERIFY(psRecord = GetRecord(RecordID));
		return (*(T *) ((UINT_PTR) psRecord + pIndexDef->HASHDATA.iNextOffset));
	}
	T GetIndexValuePtr(						// The value for the record.
		STGRECORDHDR *psRecord,				// Read the index value for record.
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		return (*(T *) ((UINT_PTR) psRecord + pIndexDef->HASHDATA.iNextOffset));
	}

	STGRECORDHDR *GetNextIndexRecord(
		STGRECORDHDR *psRecord,
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		RECORDID	RecordID;
		if ((RecordID = GetIndexValuePtr(psRecord, pIndexDef)) != GetEndMarker())
			return (GetRecord(RecordID));
		return (0);
	}

	STGRECORDHDR *GetNextIndexRecord(
		STGRECORDHDR *psRecord, 
		RECORDID &RecordID,
		STGINDEXDEF	*pIndexDef)				// Index def.
	{
		if ((RecordID = GetIndexValuePtr(psRecord, pIndexDef)) != GetEndMarker())
			return (GetRecord(RecordID));
		return (0);
	}

//*****************************************************************************
// Insert the given record into the hash chain.
//*****************************************************************************
	void HashAdd(							// Return code.
		USHORT		iBucket,				// Which bucket entry to use.
		RECORDID	&RecordID,				// Which record are we changing.
		STGINDEXDEF *pIndexDef)				// Index definition.
	{
		// If there is no entry at this bucket location, use it.
		if (m_rgBuckets[iBucket] == HASH_END_MARKER)
		{
			m_rgBuckets[iBucket] = (T) RecordID;
			SetIndexValue(RecordID, HASH_END_MARKER, pIndexDef);
		}
		// Else put record in collision chain.
		else
		{
			SetIndexValue(RecordID, m_rgBuckets[iBucket], pIndexDef);
			m_rgBuckets[iBucket] = (T) RecordID;
		}
	}

	T &operator[](ULONG iIndex)
	{ return (m_rgBuckets[iIndex]); }

	T GetEndMarker()
	{ return (HASH_END_MARKER); }

	STGRECORDHDR *GetRecord(RECORDID RecordID)
	{ return ((STGRECORDHDR *) m_pRecords->GetRecordByIndex(RecordID)); }

private:
	RECORDHEAP	*m_pRecords;			// The list of records for the table.
	T			*m_rgBuckets;			// The fixed buckets we manage.
	int			m_iBuckets;				// How many are there.
	bool		m_bFree;				// true if we own memory.
};


typedef CHashHelper<USHORT, HASH_END_MARKER2> CHashHelper2;
typedef CHashHelper<ULONG, HASH_END_MARKER4> CHashHelper4;

#endif  // __StgIndexManageri_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgopentable.cpp ===
//*****************************************************************************
// StgOpenTable.cpp
//
// This module contains the code which manages the open table list for the
// database.  This code is build around an item heap and contains the ability
// to search allocated entries.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"						// Standard includes.
#include "StgOpenTable.h"				// Open table tracking structs.
#include "CoreSchemaExtern.h"			// Extern defines for core schema.




//*****************************************************************************
// Allocate a new open table struct and link it into the allocated list.
//*****************************************************************************
STGOPENTABLE *COpenTableHeap::AddOpenTable()
{
	STGOPENTABLE *p;					// New item.

	// Allocate an item from the heap.
	p = m_Heap.AddEntry();
	if (!p)
		return (0);

	// If successful, add to allocated list, ordering is unimportant.
	if (m_pHead)
		p->pNext = m_pHead;
	else
		p->pNext = 0;
	m_pHead = p;
	return (p);
}


//*****************************************************************************
// Free a heap item and take it out of the allocated list.
//*****************************************************************************
void COpenTableHeap::DelOpenTable(STGOPENTABLE *p)
{
	STGOPENTABLE *pTemp, *pLast;			// Working pointer.
	
	// Search the list for the item and take it out of the list.  Then free
	// it for real from the heap.
	for (pLast=pTemp=GetHead();  pTemp;  pLast=pTemp, pTemp=GetNext(pTemp))
	{
		if (pTemp == p)
		{
			// Check for head node.
			if (p == m_pHead)
				m_pHead = p->pNext;
			// Else need to take item out of list.
			else
				pLast->pNext = pTemp->pNext;

			// Delete from the heap.
			m_Heap.DelEntry(p);
			return;
		}
	}
}

/* Remove it since it's not used and g_rgszCoreTables[i] is meta data specific
HRESULT COpenTableHeap::ReserveRange(StgDatabase *pDB, int iCount)
{
	// Init the range in the heap to begin with.
	if (!m_Heap.ReserveRange(iCount))
		return (PostError(OutOfMemory()));

	// Init the block of reserved table items.
	STGOPENTABLE *p = m_pHead = m_Heap.GetAt(0);
	for (int i=0;  i<iCount;  i++)
	{
		p->szTableName = (LPSTR) g_rgszCoreTables[i];
		p->RecordMgr.SetDB(pDB);
		p->pNext = m_Heap.GetAt(i + 1);
		p = p->pNext;
	}
	m_Heap.GetAt(iCount - 1)->pNext = 0;
	return (S_OK);
}
*/

void COpenTableHeap::Clear()
{
	STGOPENTABLE *pOpenTable;
	LPCSTR		szStart=0;
	LPCSTR		szEnd=0;

	// Get name heap range if allocated.
	if (m_rgNames.Size())
	{
		szStart = (LPCSTR) m_rgNames.Ptr();
		szEnd = (LPCSTR) (szStart + m_rgNames.Offset());
	}

	// Retrieve everything from the head of the list which is faster.
	while ((pOpenTable = GetHead()) != 0)
	{
		// Delete any string which was allocated for user tables.
		if (pOpenTable->szTableName < szStart && pOpenTable->szTableName > szEnd)
			delete [] pOpenTable->szTableName;

		// Now delete the heap entry.
		DelOpenTable(pOpenTable);
	}

	// Clear out the heap settings.
	m_Heap.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgpool.cpp ===
//*****************************************************************************
// StgPool.cpp
//
// Pools are used to reduce the amount of data actually required in the database.
// This allows for duplicate string and binary values to be folded into one
// copy shared by the rest of the database.  Strings are tracked in a hash
// table when insert/changing data to find duplicates quickly.  The strings
// are then persisted consecutively in a stream in the database format.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#include "stdafx.h"                     // Standard include.
#include "StgPool.h"                    // Our interface definitions.
#include "CompLib.h"                    // Extended VT types.
#include "Errors.h"                     // Error handling.
#include "basetsd.h"					// For UINT_PTR typedef


//********** Internal helpers. ************************************************
HRESULT CreateStreamOnMemory(void *pMem, ULONG cbSize, IStream **ppIStream);
HRESULT VariantWriteToStream(VARIANT *pVal, IStream* pStream);
HRESULT VariantReadFromStream(VARIANT *pVal, IStream* pStream);


//
//
// StgPool
//
//


//*****************************************************************************
// Free any memory we allocated.
//*****************************************************************************
StgPool::~StgPool()
{
    Uninit();
}


//*****************************************************************************
// Init the pool for use.  This is called for both the create empty case.
//*****************************************************************************
HRESULT StgPool::InitNew()              // Return code.
{
    // Make sure we aren't stomping anything and are properly initialized.
    _ASSERTE(m_pSegData == 0);
    _ASSERTE(m_pNextSeg == 0);
    _ASSERTE(m_pCurSeg == this);
    _ASSERTE(m_cbCurSegOffset == 0);
    _ASSERTE(m_cbSegSize == 0);
    _ASSERTE(m_cbSegNext == 0);

    m_bDirty = false;
    m_bReadOnly = false;
    m_bFree = false;

    return (S_OK);
}

//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
HRESULT StgPool::InitOnMem(             // Return code.
        void        *pData,             // Predefined data.
        ULONG       iSize,              // Size of data.
        int         bReadOnly)          // true if append is forbidden.
{
    // Make sure we aren't stomping anything and are properly initialized.
    _ASSERTE(m_pSegData == 0);
    _ASSERTE(m_pNextSeg == 0);
    _ASSERTE(m_pCurSeg == this);
    _ASSERTE(m_cbCurSegOffset == 0);

    // Create case requires no further action.
    if (!pData)
        return (E_INVALIDARG);

    // Might we be extending this heap?
    m_bReadOnly = bReadOnly;

	InitOnMemReadOnly(pData, iSize);
    m_bFree = false;
    m_bDirty = false;

    return (S_OK);
}


//*****************************************************************************
// Called when the pool must stop accessing memory passed to InitOnMem().
//*****************************************************************************
HRESULT StgPool::TakeOwnershipOfInitMem()
{
    // If the pool doesn't have a pointer to non-owned memory, done.
    if (m_bFree)
        return (S_OK);

    // If the pool doesn't have a pointer to memory at all, done.
    if (m_pSegData == 0)
    {
        _ASSERTE(m_cbSegSize == 0);
        return (S_OK);
    }

    // Get some memory to keep.
    BYTE *pData = reinterpret_cast<BYTE*>(malloc(m_cbSegSize));
    if (pData == 0)
        return (PostError(OutOfMemory()));

    // Copy the old data to the new memory.
    memcpy(pData, m_pSegData, m_cbSegSize);
    m_pSegData = pData;
    m_bFree = true;

    return (S_OK);
}


//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
void StgPool::Uninit()
{
    // Free base segment, if appropriate.
    if (m_bFree && m_pSegData)
        free(m_pSegData);

    // Free chain, if any.
    StgPoolSeg  *pSeg = m_pNextSeg;
    while (pSeg)
    {
        StgPoolSeg *pNext = pSeg->m_pNextSeg;
        free(pSeg);
        pSeg = pNext;
    }

    // Clear vars.
    m_pSegData = 0;
    m_cbSegSize = m_cbSegNext = 0;
    m_pNextSeg = 0;
    m_pCurSeg = this;
    m_cbCurSegOffset = 0;
    m_State = eNormal;
}


//*****************************************************************************
// Allocate memory if we don't have any, or grow what we have.  If successful,
// then at least iRequired bytes will be allocated.
//*****************************************************************************
bool StgPool::Grow(                     // true if successful.
    ULONG       iRequired)              // Min required bytes to allocate.
{
    ULONG       iNewSize;               // New size we want.
    StgPoolSeg  *pNew;                  // Temp pointer for malloc.

    // Would this put the pool over 2GB?
    if ((m_cbCurSegOffset + iRequired) > INT_MAX)
        return (false);

    // Adjust grow size as a ratio to avoid too many reallocs.
    if ((m_pCurSeg->m_cbSegNext + m_cbCurSegOffset) / m_ulGrowInc >= 3)
        m_ulGrowInc *= 2;

    // If first time, handle specially.
    if (m_pSegData == 0)
    {
        // Allocate the buffer.
        iNewSize = max(m_ulGrowInc, iRequired);
        m_pSegData = reinterpret_cast<BYTE*>(malloc(iNewSize));
        if (m_pSegData == 0)
            return (false);

        // Will need to delete it.
        m_bFree = true;

        // How big is this initial segment?
        m_cbSegSize = iNewSize;

        // Do some validation of var fields.
        _ASSERTE(m_cbSegNext == 0);
        _ASSERTE(m_pCurSeg == this);
        _ASSERTE(m_pNextSeg == 0);

        return (true);
    }

    // Allocate the new space enough for header + data.
    iNewSize = max(m_ulGrowInc, iRequired) + (ULONG)sizeof(StgPoolSeg);
    pNew = reinterpret_cast<StgPoolSeg*>(malloc(iNewSize));
    if (pNew == 0)
        return (false);

    // Set the fields in the new segment.
    pNew->m_pSegData = reinterpret_cast<BYTE*>(pNew) + sizeof(StgPoolSeg);
    _ASSERTE(ALIGN4BYTE(reinterpret_cast<ULONG_PTR>(pNew->m_pSegData)) == reinterpret_cast<ULONG_PTR>(pNew->m_pSegData));
    pNew->m_pNextSeg = 0;
    pNew->m_cbSegSize = iNewSize - sizeof(StgPoolSeg);
    pNew->m_cbSegNext = 0;

    // Calculate the base offset of the new segment.
    m_cbCurSegOffset = m_cbCurSegOffset + m_pCurSeg->m_cbSegNext;

    // Handle special case for a segment that was completely unused.
    if (m_pCurSeg->m_cbSegNext == 0)
    {
        // Find the segment which points to the empty segment.
        for (StgPoolSeg *pPrev = this; pPrev && pPrev->m_pNextSeg != m_pCurSeg; pPrev = pPrev->m_pNextSeg);
        _ASSERTE(pPrev && pPrev->m_pNextSeg == m_pCurSeg);

        // Free the empty segment.
        free(m_pCurSeg);
        
        // Link in the new segment.
        pPrev->m_pNextSeg = pNew;
        m_pCurSeg = pNew;

        return (true);
    }

#ifndef UNDER_CE
#ifndef NO_CRT
    // Give back any memory that we won't use.
    if (m_pNextSeg == 0)
    {   // First segment allocated as [header]->[data].
        // Be sure that we are contracting the allocation.
        if (m_pCurSeg->m_cbSegNext < _msize(m_pCurSeg->m_pSegData))
        {
            // Contract the allocation.
            void *pRealloc = _expand(m_pCurSeg->m_pSegData, m_pCurSeg->m_cbSegNext);
            // Shouldn't have moved.
            _ASSERTE(pRealloc == m_pCurSeg->m_pSegData);
        }
    }
    else
    {   // Chained segments are allocated together, [header][data].
        // Be sure that we are contracting the allocation.
        if (m_pCurSeg->m_cbSegNext+sizeof(StgPoolSeg) < _msize(m_pCurSeg))
        {
            // Contract the allocation.
            void *pRealloc = _expand(m_pCurSeg, m_pCurSeg->m_cbSegNext+sizeof(StgPoolSeg));
            // Shouldn't have moved.
            _ASSERTE(pRealloc == m_pCurSeg);
        }
    }
#endif
#endif // UNDER_CE

    // Fix the size of the old segment.
    m_pCurSeg->m_cbSegSize = m_pCurSeg->m_cbSegNext;

    // Link the new segment into the chain.
    m_pCurSeg->m_pNextSeg = pNew;
    m_pCurSeg = pNew;

    return (true);
}


//*****************************************************************************
// Prepare for pool reorganization.
//*****************************************************************************
HRESULT StgPool::OrganizeBegin()
{
    // Validate transition.
    _ASSERTE(m_State == eNormal);

    m_State = eMarking;
    return (S_OK);
}       

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgPool::OrganizeMark(
    ULONG       ulOffset)
{
    // Validate state.
    _ASSERTE(m_State == eMarking);

    return (S_OK);
}       

//*****************************************************************************
// This reorganizes the string pool for minimum size.  This is done by sorting
//  the strings, eliminating any duplicates, and performing tail-merging on
//  any that are left (that is, if "IFoo" is at offset 2, "Foo" will be
//  at offset 3, since "Foo" is a substring of "IFoo").
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgPool::OrganizePool()
{
    // Validate transition.
    _ASSERTE(m_State == eMarking);

    m_State = eOrganized;
    return (S_OK);
}

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgPool::OrganizeRemap(
    ULONG       ulOld,                  // Old offset.
    ULONG       *pulNew)                // Put new offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    *pulNew = ulOld;
    return (S_OK);
}

//*****************************************************************************
// Called to leave the organizing state.  Strings may be added again.
//*****************************************************************************
HRESULT StgPool::OrganizeEnd()
{ 
    m_State = eNormal;
    return (S_OK); 
}


//*****************************************************************************
// Copy from the organized pool into a chunk of memory.  Then init pTo to be
// on top of that version of the data.  The pTo heap will treat this copy of
// the data as read only, even though we allocated it.
//*****************************************************************************
HRESULT StgPool::SaveCopy(              // Return code.
    StgPool     *pTo,                   // Copy to this heap.
    StgPool     *pFrom,                 // From this heap.
    StgBlobPool *pBlobPool,             // Pool to keep blobs in.
    StgStringPool *pStringPool)         // String pool for variant heap.
{
    IStream     *pIStream = 0;          // Stream for save.
    void        *pbData= 0;             // Pointer to allocated data.
    ULONG       cbSaveSize;             // Save size for the heap after organization.
    HRESULT     hr;

    // Get the save size so we can grow our own segment to the correct size.
    if (FAILED(hr = pFrom->GetSaveSize(&cbSaveSize)))
        goto ErrExit;

	// Make sure that we're going to malloc more than zero bytes before
	// allocating and manipulating memory
	if (cbSaveSize > 0)
	{
		// Allocate a piece of memory big enough for this heap.
		if ((pbData = malloc(cbSaveSize)) == 0)
		{
			hr = OutOfMemory();
			goto ErrExit;
		}

		// Create a stream on top of our internal memory for the persist function.
		{
			if (SUCCEEDED(hr = CreateStreamOnMemory(pbData, cbSaveSize, &pIStream)))
			{
				// Save the stream we are copying to our own memory, thus giving us
				// a copy of the persisted data in the new format.
				hr = pFrom->PersistToStream(pIStream);
        
				pIStream->Release();
			}
		}
		if (FAILED(hr)) 
			goto ErrExit;

		// Now finally init the to heap with this data.
		if (!pStringPool)
		{
			hr = pTo->InitOnMem(pbData, cbSaveSize, true);
		}
		else
		{
			hr = ((StgVariantPool *) pTo)->InitOnMem(pBlobPool, pStringPool, 
					pbData, cbSaveSize, true);
		}
        // The pool owns the memory. In case of failure it will clean the pbData.
        pbData = 0;
	} 
	else // instead of malloc'ing 0 bytes, just init pointer to 0
		pbData = 0;

ErrExit:
    if (FAILED(hr))
    {
        if (pbData)
            free(pbData);
    }
    return (hr);
}


//*****************************************************************************
// Free the data that was allocated for this heap.  The SaveCopy method
// allocates the data from the mem heap and then gives it to this heap to
// use as read only memory.  We'll ask the heap for that pointer and free it.
//*****************************************************************************
void StgPool::FreeCopy(
    StgPool     *pCopy)                 // Heap with copy data.
{
    void        *pbData;                // Pointer to data to free.

    // Retrieve and free the data.
    pbData = pCopy->GetData(0);
    if (pbData)
		free(pbData);
}


//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgPool::PersistToStream(       // Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr = S_OK;
    ULONG       cbTotal;                // Total bytes written.
    StgPoolSeg  *pSeg;                  // A segment being written.

    _ASSERTE(m_pSegData);

    // Start with the base segment.
    pSeg = this;
    cbTotal = 0;

    // As long as there is data, write it.
    while (pSeg)
    {   
        // If there is data in the segment . . .
        if (pSeg->m_cbSegNext)
		{	// . . . write and count the data.
			if (FAILED(hr = pIStream->Write(pSeg->m_pSegData, pSeg->m_cbSegNext, 0)))
				return (hr);
			cbTotal += pSeg->m_cbSegNext;
		}

        // Get the next segment.
        pSeg = pSeg->m_pNextSeg;
    }

    // Align to 4 byte boundary.
    if (ALIGN4BYTE(cbTotal) != cbTotal)
    {
        _ASSERTE(sizeof(hr) >= 3);
        hr = 0;
        hr = pIStream->Write(&hr, ALIGN4BYTE(cbTotal)-cbTotal, 0);
    }

    return (hr);
}

//*****************************************************************************
// Get a pointer to the data at some offset.  May require traversing the
//  chain of extensions.  It is the caller's responsibility not to attempt
//  to access data beyond the end of a segment.
// This is an internal accessor, and should only be called when the data
//  is not in the base segment.
//*****************************************************************************
BYTE *StgPool::GetData_i(               // pointer to data or NULL.
    ULONG       ulOffset)               // Offset of data within pool.
{
    // Shouldn't be called on base segment.
    _ASSERTE(ulOffset >= m_cbSegNext);
    StgPoolSeg  *pSeg = this;

    while (ulOffset && ulOffset >= pSeg->m_cbSegNext)
    {
        // If we are chaining through this segment, it should be fixed (size == next).
        _ASSERTE(pSeg->m_cbSegNext == pSeg->m_cbSegSize);

        // On to next segment.
        ulOffset -= pSeg->m_cbSegNext;
        pSeg = pSeg->m_pNextSeg;

        // Is there a next?
        if (pSeg == 0)
        {
            _ASSERTE(!"Offset past end-of-chain passed to GetData_i()");
            return (0);
        }
    }

    return (pSeg->m_pSegData + ulOffset);
}


//
//
// StgStringPool
//
//


//*****************************************************************************
// Create a new, empty string pool.
//*****************************************************************************
HRESULT StgStringPool::InitNew()        // Return code.
{
    HRESULT     hr;                     // A result.
    ULONG       i;                      // Offset of empty string.

    // Let base class intialize.
    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    _ASSERTE(m_Remap.Count() == 0);
    _ASSERTE(m_RemapIndex.Count() == 0);

    // Init with empty string.
    hr = AddStringW(L"", &i, 0,true);
    // Empty string had better be at offset 0.
    _ASSERTE(i == 0);
    SetDirty(false);
    return (hr);
}


//*****************************************************************************
// Load a string heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new strings.
//*****************************************************************************
HRESULT StgStringPool::InitOnMem(       // Return code.
    void        *pData,                 // Predefined data.
    ULONG       iSize,                  // Size of data.
    int         bReadOnly)              // true if append is forbidden.
{
    HRESULT     hr;
	ULONG chSize = iSize/sizeof(WCHAR);

    // There may be up to three extra '\0' characters appended for padding.  Trim them.
    LPWSTR pchData = reinterpret_cast<LPWSTR>(pData);
    while (chSize > 1 && pchData[chSize-1] == 0 && pchData[chSize-2] == 0)
        --chSize;

	iSize = chSize*sizeof(WCHAR);

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    //@todo: defer this until we hand out a pointer.
    if (!bReadOnly)
        TakeOwnershipOfInitMem();

    _ASSERTE(m_Remap.Count() == 0);
    _ASSERTE(m_RemapIndex.Count() == 0);

    // If might be updated, build the hash table.
    if (!bReadOnly)
        hr = RehashStrings();

    return (hr);
}


//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
void StgStringPool::Uninit()
{
    // Clear the hash table.
    m_Hash.Clear();

    // Let base class clean up.
    StgPool::Uninit();

    // Clean up any remapping state.
    m_State = eNormal;
    m_Remap.Clear();
    m_RemapIndex.Clear();
}


//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
HRESULT StgStringPool::SetHash(int bHash)
{
    HRESULT     hr = S_OK;

    _ASSERTE(m_State == eNormal);

    // If turning on hash again, need to rehash all strings.
    if (bHash)
        hr = RehashStrings();

    m_bHash = bHash;
    return (hr);
}

//*****************************************************************************
// The string will be added to the pool.  The offset of the string in the pool
// is returned in *piOffset.  If the string is already in the pool, then the
// offset will be to the existing copy of the string.
//*****************************************************************************
HRESULT StgStringPool::AddStringW(       // Return code.
    LPCWSTR      szString,               // The string to add to pool.
    ULONG       *piOffset,              // Return offset of string here.
    int         iLength,                // -1 null terminated.
	bool		bInitEmtpy)
{
	STRINGHASH	*pHash;					// Hash item for add.
	ULONG		iLen;					// To handle non-null strings.
    LPWSTR       pData;					// Pointer to location for new string.

    _ASSERTE(!m_bReadOnly);

    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Null pointer is an error.
    if (szString == 0)
        return (PostError(E_INVALIDARG));

    // Find the real length we need in buffer.
    if (iLength == -1)
        iLen = (int) (( wcslen(szString) + 1 ) * sizeof(WCHAR));
    else
        iLen = ( iLength + 1 ) * sizeof(WCHAR);

	// Special case empty string.
	if ( *szString == '\0' && !bInitEmtpy )
	{
        *piOffset = 0;
        return (S_OK);
    }
		

    // Where to put the new string?
    if (iLen > GetCbSegAvailable())
    {
        if (!Grow(iLen))
            return (PostError(OutOfMemory()));
    }
    pData = reinterpret_cast<LPWSTR>(GetNextLocation());

    // Copy the data into the buffer.
    if (iLength == -1)
        wcscpy(pData, szString);
    else
    {
        wcsncpy(pData, szString, iLength);
        pData[iLength] = '\0';
    }

    // If the hash table is to be kept built (default).
    if (m_bHash)
    {
        // Find or add the entry.
        pHash = m_Hash.Find(pData, true);
        if (!pHash)
            return (PostError(OutOfMemory()));

        // If the entry was new, keep the new string.
        if (pHash->iOffset == 0xffffffff)
        {
            *piOffset = pHash->iOffset = GetNextOffset();
            SegAllocate(iLen);
            SetDirty();
        }
        // Else use the old one.
        else
            *piOffset = pHash->iOffset;
    }
    // Probably an import which defers the hash table for speed.
    else
    {
        *piOffset = GetNextOffset();
        SegAllocate(iLen);
        SetDirty();
    }
    return (S_OK);
}

//*****************************************************************************
// Add a string to the pool with ANSI to Unicode conversion.
//*****************************************************************************
HRESULT StgStringPool::AddStringA(      // Return code.
    LPCSTR      szString,               // The string to add to pool.
    ULONG       *piOffset,              // Return offset of string here.
    int         iLength)                // -1 null terminated.
{
	STRINGHASH	*pHash;					// Hash item for add.
	ULONG		iLen;					// To handle non-null strings.
    LPWSTR       pData;					// Pointer to location for new string.

    _ASSERTE(!m_bReadOnly);
    
    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Null pointer is an error.
    if (szString == 0)
        return (PostError(E_INVALIDARG));

	// Special case empty string.
    if (iLength == 0 || (iLength == -1 && *szString == '\0'))
    {
        *piOffset = 0;
        return (S_OK);
    }

	// How many bytes will be required in the heap?
    iLen = ::W95MultiByteToWideChar(CP_ACP, 0, szString, iLength, 0, 0 );
    // WCTMB includes trailing 0 if iLength==-1, doesn't otherwise.
    if (iLength >= 0)
        ++iLen;

    // Check for room.
    if (iLen > GetCbSegAvailable())
    {
        if (!Grow(iLen))
            return (PostError(OutOfMemory()));
    }
    pData = reinterpret_cast<LPWSTR>(GetNextLocation());

    // Convert the data in place to the correct location.
    iLen = ::W95MultiByteToWideChar(CP_ACP, 0, szString, iLength,
			pData, GetCbSegAvailable());
    if (iLen == 0)
        return (BadError(HRESULT_FROM_NT(GetLastError())));
    // If the conversion didn't, null terminate; count the null.
    if (iLength >= 0)
        pData[iLen++] = '\0';

    // If the hash table is to be kept built (default).
    if (m_bHash)
    {
        // Find or add the entry.
        pHash = m_Hash.Find(pData, true);
        if (!pHash)
            return (PostError(OutOfMemory()));

        // If the entry was new, keep the new string.
        if (pHash->iOffset == 0xffffffff)
        {
            *piOffset = pHash->iOffset = GetNextOffset();
            SegAllocate(iLen);
            SetDirty();
        }
        // Else use the old one.
        else
            *piOffset = pHash->iOffset;
    }
    // Probably an import which defers the hash table for speed.
    else
    {
        *piOffset = GetNextOffset();
        SegAllocate(iLen);
        SetDirty();
    }
    return (S_OK);
	
}


//*****************************************************************************
// Clears out the existing hash table used to eliminate duplicates.  Then
// rebuilds the hash table from scratch based on the current data.
//*****************************************************************************
HRESULT StgStringPool::RehashStrings()
{
    ULONG       iOffset;                // Loop control.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.
    STRINGHASH  *pHash;                 // Hash item for add.
    LPCWSTR      pString;                // A string;
    ULONG       iLen;                   // The string's length.

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=sizeof(WCHAR);  iOffset < iMax;  )
    {
        // Get the string from the pool.
        pString = reinterpret_cast<LPCWSTR>(pSeg->m_pSegData + iSeg);
        // Add the string to the hash table.
        if ((pHash = m_Hash.Add(pString)) == 0)
            return (PostError(OutOfMemory()));
        pHash->iOffset = iOffset;

        // Move to next string.
        iLen = (ULONG) ((wcslen(pString) + 1)*sizeof(WCHAR));
        iOffset += iLen;
        iSeg += iLen;
        if (iSeg > pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
}


//*****************************************************************************
// Prepare for string reorganization.
//*****************************************************************************
HRESULT StgStringPool::OrganizeBegin()
{
	ULONG		iOffset;				// Loop control.
	ULONG		iMax;					// End of loop.
	ULONG		iSeg;					// Location within segment.
	StgPoolSeg	*pSeg = this;			// To loop over segments.
	LPCWSTR		pString;				// A string;
	ULONG		iLen;					// The string's length.
	StgStringRemap *pRemap;				// A new remap element.

    _ASSERTE(m_State == eNormal);
    _ASSERTE(m_Remap.Count() == 0);

    //@todo: should this code iterate over the pool, counting the strings
    //  and then allocate a buffer big enough?

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=sizeof(WCHAR);  iOffset < iMax;  )
    {
        // Get the string from the pool.
        pString = reinterpret_cast<LPCWSTR>(pSeg->m_pSegData + iSeg);
        iLen = (ULONG) (wcslen(pString)*sizeof(WCHAR));

        // Add the string to the remap list.
        pRemap = m_Remap.Append();
        if (pRemap == 0)
        {
            m_Remap.Clear();
            return (PostError(OutOfMemory()));
        }
        pRemap->ulOldOffset = iOffset;
        pRemap->cbString = iLen;
        pRemap->ulNewOffset = ULONG_MAX;

        // Move to next string.
        iOffset += iLen + sizeof(WCHAR);
        iSeg += iLen + sizeof(WCHAR);
        if (iSeg >= pSeg->m_cbSegNext)
        {
            _ASSERTE(iSeg == pSeg->m_cbSegNext);
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }

    m_State = eMarking;
    return (S_OK);
}       

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgStringPool::OrganizeMark(
    ULONG       ulOffset)
{
    int         iContainer;             // Index for insert, if not already in list.
    StgStringRemap  *pRemap;            // Found entry.

    // Validate state.
    _ASSERTE(m_State == eMarking);

    // Treat (very common) null string specially.
    // Some columns use 0xffffffff as a null flag.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);
    
    StgStringRemap  sTarget = {ulOffset};// For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search.  If exact match, set the ulNewOffset to 0;
    if (pRemap = const_cast<StgStringRemap*>(Searcher.Find(&sTarget, &iContainer)))
    {
        pRemap->ulNewOffset = 0;
        return (S_OK);
    }

    // Found a tail string.  Get the remap record for the containing string.
    _ASSERTE(iContainer > 0);
    pRemap = m_Remap.Get(iContainer-1);

    // If this is the longest tail so far, set ulNewOffset to the delta from the 
    //  heap's string.
    _ASSERTE(ulOffset > pRemap->ulOldOffset);
    ULONG cbDelta = ulOffset - pRemap->ulOldOffset;
    if (cbDelta < pRemap->ulNewOffset)
        pRemap->ulNewOffset = cbDelta;

    return (S_OK);
}       

//*****************************************************************************
// This reorganizes the string pool for minimum size.  This is done by sorting
//  the strings, eliminating any duplicates, and performing tail-merging on
//  any that are left (that is, if "IFoo" is at offset 2, "Foo" will be
//  at offset 3, since "Foo" is a substring of "IFoo").
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgStringPool::OrganizePool()
{
    StgStringRemap  *pRemap;            // An entry in the Remap array.
    LPCWSTR      pszSaved;               // Pointer to most recently saved string.
    LPCWSTR      pszNext;                // Pointer to string under consideration.
    ULONG       cbSaved;                // Size of most recently saved string.
    ULONG       cbDelta;                // Delta in sizes between saved and current strings.
    ULONG       ulOffset;               // Current offset as we loop through the strings.
    int         i;                      // Loop control.
    int         iCount;                 // Count of live strings.


    // Validate state.
    _ASSERTE(m_State == eMarking);
    m_State = eOrganized;

    // Allocate enough indices for the entire remap array.
    if (!m_RemapIndex.AllocateBlock(m_Remap.Count()))
        return (PostError(OutOfMemory()));
    iCount = 0;

    // Add the live strings to the index map.  Discard any unused heads
    //  at this time.
    for (i=0; i<m_Remap.Count(); ++i)
    {
        pRemap = m_Remap.Get(i);
        if (pRemap->ulNewOffset != ULONG_MAX)
        {
            _ASSERTE(pRemap->ulNewOffset < pRemap->cbString);
            m_RemapIndex[iCount++] = i;
            // Discard head of the string?
            if (pRemap->ulNewOffset)
            {
                pRemap->ulOldOffset += pRemap->ulNewOffset;
                pRemap->cbString -= pRemap->ulNewOffset;
                pRemap->ulNewOffset = 0;
            }
        }
    }
    // Clear unused entries from the index map. 
    // Note: AllocateBlock a negative number.
    m_RemapIndex.AllocateBlock(iCount - m_RemapIndex.Count());

    // If no strings marked, nothing to save.
    if (iCount == 0)
    {
        m_cbOrganizedSize = 0;
        m_cbOrganizedOffset = 0;
        return (S_OK);
    }


    //*****************************************************************
    // Phase 1: Sort decending by reversed string value.
    SortReversedName NameSorter(m_RemapIndex.Ptr(), m_RemapIndex.Count(), *this);
    NameSorter.Sort();

#if defined(_DEBUG)
    {
        LPCWSTR  pString;
        ULONG   ulOld;
        int     ix;
        for (ix=0; ix<iCount; ++ix)
        {
            ulOld = m_Remap[m_RemapIndex[ix]].ulOldOffset;
            pString = GetString(ulOld);
        }
    }
#endif
    //*****************************************************************
    // Search for duplicates and potential tail-merges.

    // Build the pool from highest to lowest offset.  Since we don't 
    //  know yet how big the pool will be, start with the end at 
    //  ULONG_MAX; then shift the whole set down to start at 1 (right
    //  after the empty string).

    // Map the highest entry first string.  Save length and pointer.
    int ix = iCount - 1;
    pRemap = m_Remap.Get(m_RemapIndex[ix]);
    pszSaved = GetString(pRemap->ulOldOffset);
    cbSaved = pRemap->cbString;
    ulOffset = ULONG_MAX - (cbSaved + sizeof(WCHAR));
    pRemap->ulNewOffset = ulOffset;

    // For each item in array (other than the highest entry)...
    for (--ix; ix>=0; --ix)
    {
        // Get the remap entry.
        pRemap = m_Remap.Get(m_RemapIndex[ix]);
        pszNext = GetString(pRemap->ulOldOffset);
        _ASSERTE(wcslen(pszNext)*sizeof(WCHAR) == pRemap->cbString);
        // If the length is less than or equal to saved length, it might be a substring.
        if (pRemap->cbString <= cbSaved)
        {
             // delta = len(saved) - len(next) [saved is not shorter].  Compare (szOld+delta, szNext)
            cbDelta = cbSaved - pRemap->cbString;
            if (wcscmp(pszNext, pszSaved + cbDelta/sizeof(WCHAR)) == 0)
            {   // Substring: save just the offset
                pRemap->ulNewOffset = ulOffset + cbDelta;
                continue;
            }
        }
        // Unique string.  Map string.  Save length and pointer.
        cbSaved = pRemap->cbString;
        ulOffset -= cbSaved + sizeof(WCHAR);
        pRemap->ulNewOffset = ulOffset;
        pszSaved = pszNext;
    }

    // How big is the optimized pool?
    m_cbOrganizedSize = ULONG_MAX - ulOffset + sizeof(WCHAR);

    // Shift each entry so that the lowest one starts at 1.
    for (ix=0; ix<iCount; ++ix)
        m_Remap[m_RemapIndex[ix]].ulNewOffset -= ulOffset - sizeof(WCHAR);
    // Find the highest offset in the pool.
    m_cbOrganizedOffset = m_Remap[m_RemapIndex[--ix]].ulNewOffset;
    for (--ix; ix >= 0 && m_Remap[m_RemapIndex[ix]].ulNewOffset >= m_cbOrganizedOffset ; --ix)
        m_cbOrganizedOffset = m_Remap[m_RemapIndex[ix]].ulNewOffset;
    m_cbOrganizedSize = ALIGN4BYTE(m_cbOrganizedSize);

    return (S_OK);
}

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgStringPool::OrganizeRemap(
    ULONG       ulOld,                  // Old offset.
    ULONG       *pulNew)                // Put new offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    // If not reorganized, new == old.
    // Treat (very common) null string specially.
    // Some columns use 0xffffffff as a null flag.
    if (m_State == eNormal || ulOld == 0 || ulOld == 0xffffffff)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Search for old index.  May not be in the map, since the pool may have
    //  been optimized previously.  In that case, find the string that this 
    //  one was the tail of, get the new location of that string, and adjust
    //  by the length deltas.
    int         iContainer;                 // Index of containing string, if not in map.
    StgStringRemap const *pRemap;               // Found entry.
    StgStringRemap  sTarget = {ulOld};          // For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search.
    pRemap = Searcher.Find(&sTarget, &iContainer);
    // Found?
    if (pRemap)
    {   // Yes.
        _ASSERTE(pRemap->ulNewOffset > 0);
        *pulNew = static_cast<ULONG>(pRemap->ulNewOffset);
        return (S_OK);
    }

    // Not Found; this is a persisted tail-string.  New offset is to containing
    //  string's new offset as old offset is to containing string's old offset.
    // This string wasn't found; it is a tail of the previous entry.
    _ASSERTE(iContainer > 0);
    pRemap = m_Remap.Get(iContainer-1);
    // Make sure that the offset really is contained within the previous entry.
    _ASSERTE(ulOld >= pRemap->ulOldOffset && ulOld < pRemap->ulOldOffset + pRemap->cbString);
    *pulNew = pRemap->ulNewOffset + ulOld-pRemap->ulOldOffset;

    return (S_OK);
}

//*****************************************************************************
// Called to leave the organizing state.  Strings may be added again.
//*****************************************************************************
HRESULT StgStringPool::OrganizeEnd()
{ 
    m_Remap.Clear(); 
    m_RemapIndex.Clear();
    m_State = eNormal;
    m_cbOrganizedSize = 0;

    return (S_OK); 
}

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgStringPool::PersistToStream( // Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr;                     // A result.
    StgStringRemap  *pRemap;            // A remap entry.
    ULONG       ulOffset;               // Offset within the pool.
#ifdef _DEBUG
    ULONG       ulOffsetDbg;            // For debugging offsets.
#endif
    int         i;                      // Loop control.
    LPCWSTR      pszString;              // Pointer to a string.

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

    // Validate state.
    _ASSERTE(m_State == eOrganized);

    // If there is any string data at all, then start pool with empty string.
    if (m_RemapIndex.Count())
    {
        hr = 0; // cheeze -- use hr as a buffer for 0
        if (FAILED(hr = pIStream->Write(&hr, sizeof(WCHAR), 0)))
            return (hr);
        ulOffset = sizeof(WCHAR);
    }
    else
        ulOffset = 0;

    // Iterate over the map writing unique strings.  We will detect a unique string
    //  because it will start just past the end of the previous string; ie the next
    //  offset.
    DEBUG_STMT(ulOffsetDbg = 0);
    for (i=0; i<m_RemapIndex.Count(); ++i)
    {
        // Get the remap entry.
        pRemap = m_Remap.Get(m_RemapIndex[i]);

        // The remap array is sorted by strings.  A given entry may be a tail-string of a higer
        //  indexed string.  Thus, each new unique string will start at ulOffset, just past the
        //  previous unique string.  Tail matched strings will be destined for an offset higher
        //  than ulOffset, and should be skipped.  Finally, in the case of duplicate copies of 
        //  otherwise unique strings, the first copy will appear to be the unique string; the 
        //  offset will be advanced, and subsequent strings will start before ulOffset.
        //  or equal to what we've already written.
        _ASSERTE(pRemap->ulNewOffset >= ulOffset || pRemap->ulNewOffset == ulOffsetDbg);

        // If this string starts past ulOffset, it must be a tail string, and needn't be
        //  written.
        if (static_cast<ULONG>(pRemap->ulNewOffset) > ulOffset)
        {
            // Better be at least one more string, for this one to be the tail of.
            _ASSERTE(i < (m_RemapIndex.Count() - 1));

            // Better end at same point as next string, which this one is a tail of.
            DEBUG_STMT(StgStringRemap *pRemapDbg = m_Remap.Get(m_RemapIndex[i+1]);)
            _ASSERTE(pRemap->ulNewOffset + pRemap->cbString == pRemapDbg->ulNewOffset + pRemapDbg->cbString);

            // This string better really be a tail of the next one.
            DEBUG_STMT(int delta = pRemapDbg->cbString - pRemap->cbString;)
            DEBUG_STMT(const WCHAR *p1 = GetString(pRemap->ulOldOffset);)
            DEBUG_STMT(const WCHAR *p2 = GetString(pRemapDbg->ulOldOffset) + delta/sizeof(WCHAR);)
            _ASSERTE(wcscmp(p1, p2) == 0);
            continue;
        }

		// If this string starts before ulOffset, it is a duplicate of a previous string.
        if (static_cast<ULONG>(pRemap->ulNewOffset) < ulOffset)
		{
            // There had better be some string before this one.
            _ASSERTE(i > 0);

            // Better end just before where the next string is supposed to start.
			_ASSERTE(pRemap->ulNewOffset + pRemap->cbString + sizeof(WCHAR) == ulOffset);

            // This string better really match up with the one it is supposed to be a duplicate of.
            DEBUG_STMT(StgStringRemap *pRemapDbg = m_Remap.Get(m_RemapIndex[i-1]);)
            DEBUG_STMT(int delta = pRemapDbg->cbString - pRemap->cbString;)
            DEBUG_STMT(const WCHAR *p1 = GetString(pRemap->ulOldOffset);)
            DEBUG_STMT(const WCHAR *p2 = GetString(pRemapDbg->ulOldOffset) + delta/sizeof(WCHAR);)
            _ASSERTE(wcscmp(p1, p2) == 0);
			continue;
		}

        // New unique string.  (It starts exactly where we expect it to.)

        // Get the string data, and write it.
        pszString = GetString(pRemap->ulOldOffset);
        _ASSERTE(pRemap->cbString == wcslen(pszString)*sizeof(WCHAR));
        if (FAILED(hr=pIStream->Write(pszString, pRemap->cbString+sizeof(WCHAR), 0)))
            return (hr);

        // Save this offset for debugging duplicate strings.
        DEBUG_STMT(ulOffsetDbg = ulOffset);

        // Shift up for the next one.
        ulOffset += pRemap->cbString + sizeof(WCHAR);
        _ASSERTE(ulOffset <= m_cbOrganizedSize);
        _ASSERTE(ulOffset > 0);
    }

    // Align.
    if (ulOffset != ALIGN4BYTE(ulOffset))
    {
        hr = 0;
        if (FAILED(hr = pIStream->Write(&hr, ALIGN4BYTE(ulOffset)-ulOffset, 0)))
            return (hr);
        ulOffset += ALIGN4BYTE(ulOffset)-ulOffset;
    }

    // Should have written exactly what we expected.
    _ASSERTE(ulOffset == m_cbOrganizedSize);

    return (S_OK);
}


//
//
// StgGuidPool
//
//

HRESULT StgGuidPool::InitNew()          // Return code.
{
    HRESULT     hr;                     // A result.

    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    return (S_OK);
}

//*****************************************************************************
// Load a Guid heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new Guids.
//*****************************************************************************
HRESULT StgGuidPool::InitOnMem(         // Return code.
    void        *pData,                 // Predefined data.
    ULONG       iSize,                  // Size of data.
    int         bReadOnly)              // true if append is forbidden.
{
    HRESULT     hr;

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    // For init on existing mem case.
    if (pData && iSize)
    {
        // If we cannot update, then we don't need a hash table.
        if (bReadOnly)
            return (S_OK);

        //@todo: defer this until we hand out a pointer.
        TakeOwnershipOfInitMem();

        // Build the hash table on the data.
        if (FAILED(hr = RehashGuids()))
        {
            Uninit();
            return (hr);
        }
    }

    return (S_OK);
}

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
void StgGuidPool::Uninit()
{
    // Clear the hash table.
    m_Hash.Clear();

    // Let base class clean up.
    StgPool::Uninit();
}

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
HRESULT StgGuidPool::SetHash(int bHash)
{
    HRESULT     hr = S_OK;

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

    // If turning on hash again, need to rehash all guids.
    if (bHash)
        hr = RehashGuids();

    m_bHash = bHash;
    return (hr);
}

//*****************************************************************************
// The Guid will be added to the pool.  The index of the Guid in the pool
// is returned in *piIndex.  If the Guid is already in the pool, then the
// index will be to the existing copy of the Guid.
//*****************************************************************************
HRESULT StgGuidPool::AddGuid(			// Return code.
	REFGUID		guid,					// The Guid to add to pool.
	ULONG		*piIndex)				// Return 1-based index of Guid here.
{
	GUIDHASH	*pHash = 0;					// Hash item for add.

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

	// Special case for GUID_NULL
	if (guid == GUID_NULL)
	{
		*piIndex = 0;
		return (S_OK);
	}

	// If the hash table is to be kept built (default).
	if (m_bHash)
	{
		// Find or add the entry.
		pHash = m_Hash.Find(&guid, true);
		if (!pHash)
			return (PostError(OutOfMemory()));

		// If the guid was found, just use it.
		if (pHash->iIndex != 0xffffffff)
		{	// Return 1-based index.
			*piIndex = pHash->iIndex;
			return (S_OK);
		}
	}

    // Space on heap for new guid?
    if (sizeof(GUID) > GetCbSegAvailable())
    {
        if (!Grow(sizeof(GUID)))
            return (PostError(OutOfMemory()));
    }

    // Copy the guid to the heap.
    *reinterpret_cast<GUID*>(GetNextLocation()) = guid;
    SetDirty();

	// Give the 1-based index back to caller.
    *piIndex = (GetNextOffset() / sizeof(GUID)) + 1;

	// If hashing, save the 1-based index in the hash.
	if (m_bHash)
		pHash->iIndex = *piIndex;

    // Update heap counters.
    SegAllocate(sizeof(GUID));

    return (S_OK);
}

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
GUID *StgGuidPool::GetGuid(				// Pointer to guid in pool.
	ULONG		iIndex)					// 1-based index of Guid in pool.
{
    if (iIndex == 0)
        return (reinterpret_cast<GUID*>(const_cast<BYTE*>(m_zeros)));

	// Convert to 0-based internal form, defer to implementation.
	return (GetGuidi(iIndex-1));
}



//*****************************************************************************
// Recompute the hashes for the pool.
//*****************************************************************************
HRESULT StgGuidPool::RehashGuids()
{
    ULONG       iOffset;                // Loop control.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.
    GUIDHASH    *pHash;                 // Hash item for add.
    GUID        *pGuid;                 // A guid;

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each guid.
    for (iSeg=iOffset=0;  iOffset < iMax;  )
    {
        // Get a pointer to the guid.
        pGuid = reinterpret_cast<GUID*>(pSeg->m_pSegData + iSeg);
        // Add the guid to the hash table.
        if ((pHash = m_Hash.Add(pGuid)) == 0)
            return (PostError(OutOfMemory()));
        pHash->iIndex = iOffset / sizeof(GUID);

        // Move to next Guid.
        iOffset += sizeof(GUID);
        iSeg += sizeof(GUID);
        if (iSeg > pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
}

//*****************************************************************************
// Prepare for pool reorganization.
//*****************************************************************************
HRESULT StgGuidPool::OrganizeBegin()
{
    int         cRemap;

    // Validate transition.
    _ASSERTE(m_State == eNormal);

	_ASSERTE(m_Remap.Count() == 0);
	cRemap = GetNextIndex();
	if (cRemap == 0)
	{
		m_State = eMarking;
		m_cbOrganizedSize = 0;
		return (S_OK);
	}

	if (!m_Remap.AllocateBlock(cRemap))
		return (PostError(OutOfMemory()));

    memset(m_Remap.Ptr(), 0xff, cRemap * sizeof(m_Remap.Ptr()[0]));
    // Be sure we recognize the "not mapped" value.
    _ASSERTE(m_Remap[0] == ULONG_MAX);

    m_State = eMarking;
    return (S_OK);
}       

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgGuidPool::OrganizeMark(
	ULONG		ulOffset)				// 1-based index of guid.
{
    // Validate state.
    _ASSERTE(m_State == eMarking);

    // Don't mark special NULL-GUID. Some columns use 0xffffffff as NULL.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);

	// Convert to 0-based internal format.
	--ulOffset;

	_ASSERTE(ulOffset < static_cast<ULONG>(m_Remap.Count()));
	m_Remap[ulOffset] = 1;

    return (S_OK);
}       

//*****************************************************************************
// This reorganizes the string pool for minimum size.  This is done by sorting
//  the strings, eliminating any duplicates, and performing tail-merging on
//  any that are left (that is, if "IFoo" is at offset 2, "Foo" will be
//  at offset 3, since "Foo" is a substring of "IFoo").
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgGuidPool::OrganizePool()
{
    int         i;                      // Loop control.
    int         iIndex;                 // New index.

    // Validate transition.
    _ASSERTE(m_State == eMarking);
    m_State = eOrganized;

	iIndex = 0;
	for (i=0; i<m_Remap.Count(); ++i)
	{
		if (m_Remap[i] != ULONG_MAX)
			m_Remap[i] = iIndex++;
	}

	// Remember how big the pool will be.
	m_cbOrganizedSize = iIndex * sizeof(GUID);

    return (S_OK);
}

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgGuidPool::OrganizeRemap(
	ULONG		ulOld,					// Old 1-based offset.
	ULONG		*pulNew)				// Put new 1-based offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    if (ulOld == 0 || ulOld == 0xffffffff || m_State == eNormal)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

	// Convert to 0-based internal form.
	--ulOld;

	// Valid index?
	_ASSERTE(ulOld < static_cast<ULONG>(m_Remap.Count()));
	// Did they map this one?
	_ASSERTE(m_Remap[ulOld] != ULONG_MAX);

	// Give back 1-based external form.
	*pulNew = m_Remap[ulOld] + 1;

    return (S_OK);
}

//*****************************************************************************
// Called to leave the organizing state.  Strings may be added again.
//*****************************************************************************
HRESULT StgGuidPool::OrganizeEnd()
{ 
    m_Remap.Clear();
    m_cbOrganizedSize = 0;

    m_State = eNormal;
    return (S_OK); 
}

//*****************************************************************************
// Save the pool data into the given stream.
//*****************************************************************************
HRESULT StgGuidPool::PersistToStream(// Return code.
    IStream     *pIStream)              // The stream to write to.
{
	int			i;						// Loop control.
	GUID		*pGuid;					// data to write.
	ULONG		cbTotal;				// Size written.
	HRESULT		hr = S_OK;

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

	// Verify state.
	_ASSERTE(m_State == eOrganized);

	cbTotal = 0;
	for (i=0; i<m_Remap.Count(); ++i)
	{
		if (m_Remap[i] != ULONG_MAX)
		{	// Use internal form, GetGuidi, to get 0-based index.
			pGuid = GetGuidi(i);
			if (FAILED(hr = pIStream->Write(pGuid, sizeof(GUID), 0)))
				return (hr);
			cbTotal += sizeof(GUID);
		}
	}
	_ASSERTE(cbTotal == m_cbOrganizedSize);

    return (S_OK);
}
//
//
// StgBlobPool
//
//



//*****************************************************************************
// Create a new, empty blob pool.
//*****************************************************************************
HRESULT StgBlobPool::InitNew()          // Return code.
{
    HRESULT     hr;                     // A result.
    ULONG       i;                      // Offset of empty blob.

    // Let base class intialize.
    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    _ASSERTE(m_Remap.Count() == 0);

    // Init with empty blob.
    hr = AddBlob(0, NULL, &i);
    // Empty blob better be at offset 0.
    _ASSERTE(i == 0);
    SetDirty(false);
    return (hr);
}


//*****************************************************************************
// Init the blob pool for use.  This is called for both create and read case.
// If there is existing data and bCopyData is true, then the data is rehashed
// to eliminate dupes in future adds.
//*****************************************************************************
HRESULT StgBlobPool::InitOnMem(         // Return code.
    void        *pBuf,                  // Predefined data.
    ULONG       iBufSize,               // Size of data.
    int         bReadOnly)              // true if append is forbidden.
{
    BLOBHASH    *pHash;                 // Hash item for add.
    ULONG       iOffset;                // Loop control.
    void const  *pBlob;                 // Pointer to a given blob.
    ULONG       cbBlob;                 // Length of a blob.
    int         iSizeLen;               // Size of an encoded length.
    HRESULT     hr;

    // Let base class init our memory structure.
    if (FAILED(hr = StgPool::InitOnMem(pBuf, iBufSize, bReadOnly)))
        return (hr);

    // Init hash table from existing data.
    // If we cannot update, we don't need a hash table.
    if (bReadOnly)
        return (S_OK);

    //@todo: defer this until we hand out a pointer.
    TakeOwnershipOfInitMem();

    // Go through each blob.
    ULONG       iMax;                   // End of loop.
    ULONG       iSeg;                   // Location within segment.
    StgPoolSeg  *pSeg = this;           // To loop over segments.

    // How far should the loop go.
    iMax = GetNextOffset();

    // Go through each string, skipping initial empty string.
    for (iSeg=iOffset=0; iOffset < iMax; )
    {
        // Get the string from the pool.
        pBlob = pSeg->m_pSegData + iSeg;

        // Add the blob to the hash table.
        if ((pHash = m_Hash.Add(pBlob)) == 0)
        {
            Uninit();
            return (hr);
        }
        pHash->iOffset = iOffset;

        // Move to next blob.
        cbBlob = CPackedLen::GetLength(pBlob, &iSizeLen);
        iOffset += cbBlob + iSizeLen;
        iSeg += cbBlob + iSizeLen;
        if (iSeg > pSeg->m_cbSegNext)
        {
            pSeg = pSeg->m_pNextSeg;
            iSeg = 0;
        }
    }
    return (S_OK);
}


//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
void StgBlobPool::Uninit()
{
    // Clear the hash table.
    m_Hash.Clear();

    // Let base class clean up.
    StgPool::Uninit();
}


//*****************************************************************************
// The blob will be added to the pool.  The offset of the blob in the pool
// is returned in *piOffset.  If the blob is already in the pool, then the
// offset will be to the existing copy of the blob.
//*****************************************************************************
HRESULT StgBlobPool::AddBlob(           // Return code.
    ULONG       iSize,                  // Size of data item.
    const void  *pData,                 // The data.
    ULONG       *piOffset)              // Return offset of blob here.
{
    BLOBHASH    *pHash;                 // Hash item for add.
    void        *pBytes;                // Working pointer.
	BYTE		*pStartLoc;				// Location to write real blob
    ULONG       iRequired;              // How much buffer for this blob?
	ULONG		iFillerLen;				// space to fill to make byte-aligned

    // Can't do any updates during a reorganization.
    _ASSERTE(m_State == eNormal);

    // Can we handle this blob?
    if (iSize > CPackedLen::MAX_LEN)
        return (PostError(CLDB_E_TOO_BIG));

	// worst case is we need three more bytes to ensure byte-aligned, hence the 3
	iRequired = iSize + CPackedLen::Size(iSize) + 3;
    if (iRequired > GetCbSegAvailable())
    {
        if (!Grow(iRequired))
            return (PostError(OutOfMemory()));
    }

	
	// unless changed due to alignment, the location of the blob is just
	// the value returned by GetNextLocation(), which is also a iFillerLen of
	// 0

	pStartLoc = (BYTE *) GetNextLocation();
	iFillerLen = 0;

	// technically, only the data portion must be DWORD-aligned.  So, if the
	// data length is zero, we don't need to worry about alignment.

	if (m_bAlign && iSize > 0)
	{
		// figure out how many bytes are between the current location and
		// the position to write the size of the real blob.
		size_t iStart = (ULONG)((UINT_PTR)GetNextLocation());
		ULONG iLenSize  = CPackedLen::Size(iSize);
		ULONG iSum = (ULONG) ((iStart % sizeof(DWORD)) + iLenSize);
		iFillerLen = (sizeof(DWORD)-((iSum)%sizeof(DWORD)))%sizeof(DWORD);

		// if there is a difference between where we are now and we want to
		// start, put in a filler blob.
		if (iFillerLen > 0)
		{
			// Pack in "filler blob" length.
			pStartLoc = (BYTE *) CPackedLen::PutLength(GetNextLocation(), iFillerLen - 1);

			// Write iFillerLen - 1 bytes of zeros after the length indicator.
			for (ULONG i = 0; i < iFillerLen - 1; i++)
			{
				*pStartLoc++ = 0;
			}
		}		
	} 
	
    // Pack in the length at pStartLoc (the start location)
    pBytes = CPackedLen::PutLength(pStartLoc, iSize);

#if defined(_DEBUG)
	if (m_bAlign && iSize > 0)
		// check to make sure blob write will be DWORD-aligned
		_ASSERTE( ( ( (ULONG_PTR) pBytes ) % sizeof(DWORD) ) == 0);
#endif

    // Put the bytes themselves.
    memcpy(pBytes, pData, iSize);

    // Find or add the entry.
    if ((pHash = m_Hash.Find(GetNextLocation() + iFillerLen, true)) == 0)
        return (PostError(OutOfMemory()));

    // If the entry was new, keep the new blob.
    if (pHash->iOffset == 0xffffffff)
    {
		// this blob's offset is increased by iFillerLen bytes
        pHash->iOffset = *piOffset = GetNextOffset() + iFillerLen;
		// only SegAllocate what we actually used, rather than what we requested
        SegAllocate(iSize + CPackedLen::Size(iSize) + iFillerLen);
        SetDirty();
    }
    // Else use the old one.
    else
        *piOffset = pHash->iOffset;
    return (S_OK);
}

//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
void *StgBlobPool::GetBlob(             // Pointer to blob's bytes.
    ULONG       iOffset,                // Offset of blob in pool.
    ULONG       *piSize)                // Return size of blob.
{
    void const  *pData;                 // Pointer to blob's bytes.

    if (iOffset == 0)
    {
        *piSize = 0;
        return (const_cast<BYTE*>(m_zeros));
    }

    // Is the offset within this heap?
    _ASSERTE(IsValidOffset(iOffset));

    // Get size of the blob (and pointer to data).
    *piSize = CPackedLen::GetLength(GetData(iOffset), &pData);

	// Sanity check the return alignment.
	_ASSERTE(!IsAligned() || (((UINT_PTR)(pData) % sizeof(DWORD)) == 0));

    // Return pointer to data.
    return (const_cast<void*>(pData));
}

//*****************************************************************************
// Prepare for pool reorganization.
//*****************************************************************************
HRESULT StgBlobPool::OrganizeBegin()
{
	m_cbOrganizedOffset = 0;
    return (StgPool::OrganizeBegin());
}

//*****************************************************************************
// Mark an object as being live in the organized pool.
//*****************************************************************************
HRESULT StgBlobPool::OrganizeMark(
    ULONG       ulOffset)
{
    int         iContainer;             // Index for insert, if not already in list.
    StgBlobRemap  *psRemap;             // Found entry.

    // Validate state.
    _ASSERTE(m_State == eMarking);

    // Don't mark 0 (empty) entry.  Some columns use 0xffffffff as a null flag.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);
    
    // Is the offset within this heap?
    _ASSERTE(IsValidOffset(ulOffset));

    StgBlobRemap    sTarget = {ulOffset};// For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search, done if found.
    if (psRemap = const_cast<StgBlobRemap*>(Searcher.Find(&sTarget, &iContainer)))
        return (S_OK);

    // Add the entry to the remap array.
    if ((psRemap = m_Remap.Insert(iContainer)) == 0)
        return (PostError(OutOfMemory()));

    psRemap->ulOldOffset = ulOffset;
    psRemap->iNewOffset = -1;
    return (S_OK);
}       

//*****************************************************************************
// This reorganizes the blob pool for minimum size. 
//
// After this function is called, the only valid operations are RemapOffset and
//  PersistToStream.
//*****************************************************************************
HRESULT StgBlobPool::OrganizePool()
{
    ULONG       ulOffset;               // New offset of a blob.
    int         i;                      // Loop control.
	ULONG		iFillerLen;				// Size of pre-blob filler to maintain alignment
    ULONG       cbBlob;                 // Size of a blob.
    int         cbLen;                  // Size of a length.
    // Validate transition.
    _ASSERTE(m_State == eMarking);

    m_State = eOrganized;

    // If nothing to save, we're done.
    if (m_Remap.Count() == 0)
    {
        m_cbOrganizedSize = 0;
        return (S_OK);
    }

    // Start past the empty blob.
    ulOffset = 1;

    // Go through the remap array, and assign each item it's new offset.
    for (i=0; i<m_Remap.Count(); ++i)
    {
        // Still at a valid offset within this heap?
        _ASSERTE(IsValidOffset(ulOffset));

        // Get size of the blob and of length.
        cbBlob = CPackedLen::GetLength(GetData(m_Remap[i].ulOldOffset), &cbLen);

		// For alignment case, need to add in expected padding.
		if (m_bAlign)
		{
			ULONG iSum = (ulOffset % sizeof(DWORD)) + cbLen;
			iFillerLen = (sizeof(DWORD)-((iSum)%sizeof(DWORD)))%sizeof(DWORD);
		}
		else
			iFillerLen = 0;

		// Set the mapping values.
        m_Remap[i].iNewOffset = ulOffset + iFillerLen;
        m_cbOrganizedOffset = m_Remap[i].iNewOffset;

        // Adjust offset to next blob.
        ulOffset += cbBlob + cbLen + iFillerLen;
    }

    // How big is the whole thing?
    m_cbOrganizedSize = ALIGN4BYTE(ulOffset);

    return (S_OK);
}

//*****************************************************************************
// Given an offset from before the remap, what is the offset after the remap?
//*****************************************************************************
HRESULT StgBlobPool::OrganizeRemap(
    ULONG       ulOld,                  // Old offset.
    ULONG       *pulNew)                // Put new offset here.
{
    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    // If not reorganized, new == old.
    if (m_State == eNormal)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Empty blob translates to self.  Some columns use 0xffffffff as a null flag.
    if (ulOld == 0 || ulOld == 0xffffffff)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Search for old index.  
    int         iContainer;                 // Index of containing Blob, if not in map.
    StgBlobRemap const *psRemap;                // Found entry.
    StgBlobRemap    sTarget = {ulOld};          // For the search, only contains ulOldOffset.
    BinarySearch Searcher(m_Remap.Ptr(), m_Remap.Count()); // Searcher object

    // Do the search.
    psRemap = Searcher.Find(&sTarget, &iContainer);
    // Found?
    if (psRemap)
    {   // Yes.
        _ASSERTE(psRemap->iNewOffset >= 0);
        *pulNew = static_cast<ULONG>(psRemap->iNewOffset);
        return (S_OK);
    }

    // Not Found, translate to SQL-style NULL.
    _ASSERTE(!"Remap a non-marked blob.");
    *pulNew = 0xffffffff;

    return (S_OK);
}

//*****************************************************************************
// Called to leave the organizing state.  Blobs may be added again.
//*****************************************************************************
HRESULT StgBlobPool::OrganizeEnd()
{ 
    m_Remap.Clear(); 
    m_State = eNormal;
    m_cbOrganizedSize = 0;

    return (S_OK); 
}

//*****************************************************************************
// The entire Blob pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
HRESULT StgBlobPool::PersistToStream(   // Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr;                     // A result.
    StgBlobRemap *psRemap;              // A remap entry.
    ULONG       ulTotal;                // Bytes written so far.
    int         i;                      // Loop control.
    ULONG       cbBlob;                 // Size of a blob.
    int         cbLen;                  // Size of a length.
    BYTE        *pBlob;                 // Pointer to a blob.
	ULONG		iFillerLen;				// Size of pre-blob filler to maintain alignment

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

    // Validate state.
    _ASSERTE(m_State == eOrganized);

    // If there is any blob data at all, then start pool with empty blob.
    if (m_Remap.Count())
    {
        hr = 0; // cheeze -- use hr as a buffer for 0
        if (FAILED(hr = pIStream->Write(&hr, 1, 0)))
            return (hr);
        ulTotal = 1;
    }
    else
        ulTotal = 0;

    // Iterate over the map writing Blobs.  
    for (i=0; i<m_Remap.Count(); ++i)
    {
        // Get the remap entry.
        psRemap = m_Remap.Get(i);

        // Get size of the blob and of length.
        pBlob = GetData(psRemap->ulOldOffset);
        cbBlob = CPackedLen::GetLength(pBlob, &cbLen);

		if (m_bAlign)
		{
			ULONG iSum = (ulTotal % sizeof(DWORD)) + cbLen;
			iFillerLen = (sizeof(DWORD)-((iSum)%sizeof(DWORD)))%sizeof(DWORD);

			// if there is a difference between where we are now and we want to
			// start, put in a filler blob.
			if (iFillerLen > 0)
			{
				BYTE	rgFillBlob[sizeof(DWORD)];

				// Zero out buffer.				
				*(DWORD *) rgFillBlob = 0;

				// Pack in "filler blob" length, we know it will only be 1 byte
				CPackedLen::PutLength(&rgFillBlob[0], iFillerLen - 1);
				if (FAILED(hr = pIStream->Write(&rgFillBlob, iFillerLen, 0)))
					return (hr);

				ulTotal += iFillerLen;
			}
		}
		else
			iFillerLen = 0;

        // Is this what we expected?
        _ASSERTE(ulTotal == static_cast<ULONG>(psRemap->iNewOffset));

#if defined (_DEBUG)
	// check to make sure that we are writing aligned if desired
	if (m_bAlign)
		_ASSERTE( (ulTotal + cbLen) % sizeof(DWORD) == 0 );
#endif

        // Write the data.
        if (FAILED(hr = pIStream->Write(pBlob, cbBlob+cbLen, 0)))
            return (hr);

        // Accumulate the bytes.
        ulTotal += cbBlob + cbLen;
    }

    // Align.
    if (ulTotal != ALIGN4BYTE(ulTotal))
    {
        hr = 0;
        if (FAILED(hr = pIStream->Write(&hr, ALIGN4BYTE(ulTotal)-ulTotal, 0)))
            return (hr);
        ulTotal += ALIGN4BYTE(ulTotal)-ulTotal;
    }

    // Should have written exactly what we expected.
    _ASSERTE(ulTotal == m_cbOrganizedSize);

    return (S_OK);
}



//
//
// StgVariantPool
//
//



//*****************************************************************************
// Init the variant pool for usage.  This is called for the create case.
//*****************************************************************************
HRESULT StgVariantPool::InitNew(        // Return code.
    StgBlobPool *pBlobPool,             // Pool to keep blobs in.
    StgStringPool *pStringPool)         // Pool to keep strings in.
{
    HRESULT     hr;

    if (FAILED(hr = StgPool::InitNew()))
        return (hr);

    // Save off the pools we know about.
    m_pBlobPool = pBlobPool;
    m_pStringPool = pStringPool;

    return (S_OK);
}

//*****************************************************************************
// Init the variant pool for usage.  This is called for the open existing case.
//*****************************************************************************
HRESULT StgVariantPool::InitOnMem(      // Return code.
    StgBlobPool *pBlobPool,             // Pool to keep blobs in.
    StgStringPool *pStringPool,         // Pool to keep strings in.
    void        *pData,                 // Predefined data, may be null.
    ULONG       iSize,                  // Size of data.
    int         bReadOnly)              // true if update is forbidden.
{
	HRESULT		hr;
	ULONG		cVariants;				// Count of persisted variants.
	ULONG		ulPoolData;				// Offset of start of some pool data.

    if (FAILED(hr = StgPool::InitOnMem(pData, iSize, bReadOnly)))
        return (hr);

    // Copy the data, so we can update it.
    if (!bReadOnly)
        TakeOwnershipOfInitMem();

    // Save off the pools we know about.
    m_pBlobPool = pBlobPool;
    m_pStringPool = pStringPool;

    // Get the count of variants.
    cVariants = *reinterpret_cast<ULONG*>(m_pSegData);
    ulPoolData = sizeof(ULONG);

    // Get the array of variants.
    m_rVariants.InitOnMem(sizeof(StgVariant), m_pSegData + ulPoolData, cVariants, cVariants);
    ulPoolData += cVariants * sizeof(StgVariant);

    // Other data goes on top of stream.
    if (FAILED(hr = CreateStreamOnMemory(m_pSegData + ulPoolData,
                iSize - ulPoolData, &m_pIStream)))
        return (hr);

    // If not readonly, copy the other stream to an updateable one.
    if (!bReadOnly)
    {
#if defined(UNDER_CE)
		//@todo: we could check the stream size, and only fail if non-zero.
		m_pIStream = 0;
		return (E_INVALIDARG);
#else
        IStream *pTmp=0;
        if (FAILED(hr = CreateStreamOnHGlobal(0, true, &pTmp)))
            return (hr);
        ULARGE_INTEGER iBigSize;
        iBigSize.QuadPart = iSize - ulPoolData;
        if (FAILED(hr = m_pIStream->CopyTo(pTmp, iBigSize, 0, 0)))
            return (hr);
        m_pIStream = pTmp;
#endif
    }

    return (S_OK);
}


//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
void StgVariantPool::Uninit()
{
    // Clear out dynamic arrays.
    ClearVars();

    // Clean up any remapping state.
    m_State = eNormal;

    // Let base class free any memory it owns.
    StgPool::Uninit();
}


//*****************************************************************************
// Add the given variant to the pool.  The index returned is good only for
// the duration of the load.  It must be converted into a final index when you
// persist the information to disk.
//*****************************************************************************
HRESULT StgVariantPool::AddVariant(     // Return code.
    VARIANT     *pVal,                  // The value to store.
    ULONG       *piIndex)               // The 1-based index of the new item.
{
    _ASSERTE(pVal->vt != VT_BLOB);
    return AddVarianti(pVal, 0, 0, piIndex);
}

HRESULT StgVariantPool::AddVariant(     // Return code.
    ULONG       iSize,                  // Size of data item.
    const void  *pData,                 // The data.
    ULONG       *piIndex)               // The 1-based index of the new item.
{
    VARIANT vt;
    vt.vt = VT_BLOB;
    return AddVarianti(&vt, iSize, pData, piIndex);
}


HRESULT StgVariantPool::AddVarianti(    // Return code.
    VARIANT     *pVal,                  // The value to store, if variant.
    ULONG       cbBlob,                 // The size to store, if blob.
    const void  *pBlob,                 // Pointer to data, if blob.
    ULONG       *piIndex)               // The 1-based index of the new item.
{
    HRESULT     hr = S_OK;              // A result.
    StgVariant  *pStgVariant;           // New pool entry.
    ULONG       iIndex;                 // Index of new item.
    ULONG       ulOffset;               // Offset into pool's stream.
    ULONG       ulOther;                // Offset into another pool.
    void        *pWrite = 0;            // For writing directly to the stream.
    ULONG       cbWrite = 0;            // Bytes to write directly to stream.
    
    // Can't add during a reorganization.
    _ASSERTE(m_State == eNormal);

    _ASSERTE(!m_bReadOnly);

    // Find new index.
    iIndex = m_rVariants.Count();

    // Add the item to the current list of values.
    if ((pStgVariant = m_rVariants.Append()) == 0)
        return (PostError(OutOfMemory()));

    // Type of variant.
    pStgVariant->m_vt = pVal->vt;

    // Be optimistic about storing the value directly.
    pStgVariant->m_bDirect = true;

    // See if the value can be stored directly.
    switch (pVal->vt)
    {
    // one and two byte values are easy.
    case VT_UI1:
    case VT_I1:
        pStgVariant->Set(pVal->cVal);
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        pStgVariant->Set(pVal->iVal);
        break;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        pStgVariant->Set(pVal->lVal);
        // If it is possible to store all the bits directly, done.
        if (pStgVariant->Get() == pVal->lVal)
            break;
        // Won't fit; write to the stream
        pWrite = &pVal->lVal;
        cbWrite = 4;
        goto WriteToStream;

    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_I8:
    case VT_UI8:
        pWrite = &pVal->dblVal;
        cbWrite = sizeof(double);
        goto WriteToStream;

    case VT_BSTR:
        // Special case for NULL bstrVal.
        if (pVal->bstrVal == 0)
        {
            ulOther = -1;
        }
        else
        {
            hr = m_pStringPool->AddStringW(pVal->bstrVal, &ulOther);
            if (FAILED(hr)) goto ErrExit;
        }
        pWrite = &ulOther;
        cbWrite = sizeof(ulOther);
        goto WriteToStream;

    case VT_BLOB:
        hr = m_pBlobPool->AddBlob(cbBlob, pBlob, &ulOther);
        if (FAILED(hr)) goto ErrExit;
        pWrite = &ulOther;
        cbWrite = sizeof(ulOther);
        goto WriteToStream;

    default:
        // Write to other pool.
        // Get the current offset for the data, then write this value to the stream.
        if (FAILED(hr = GetOtherSize(&ulOffset)))
            goto ErrExit;
        if (ulOffset > StgVariant::VALUE_MASK)
        {
            hr = PostError(DISP_E_OVERFLOW);
            goto ErrExit;
        }

WriteToStream:
        // Create a temporary stream if need be.
        if (m_pIStream == 0 &&
#if defined(UNDER_CE)
            FAILED(hr = E_INVALIDARG))
#else
            FAILED(hr = CreateStreamOnHGlobal(0, true, &m_pIStream)))
#endif
            return (hr);

        // Data will go at the end of the stream.
        LARGE_INTEGER iSeek;
        ULARGE_INTEGER ulPos;
        iSeek.QuadPart = 0;
        if (FAILED(hr = m_pIStream->Seek(iSeek, STREAM_SEEK_END, &ulPos)))
            goto ErrExit;;
        // Never allow the size to get bigger than 4 bytes.
        if (ulPos.QuadPart >= StgVariant::VALUE_MASK)
            return (PostError(DISP_E_OVERFLOW));
        // Size is where new data will be written.
        ulOffset = static_cast<ULONG>(ulPos.QuadPart);
        // Write direct or through variant helper?
        if (cbWrite)
            hr = m_pIStream->Write(pWrite, cbWrite, 0);
        else
            hr = VariantWriteToStream(pVal, m_pIStream);
        if (FAILED(hr)) goto ErrExit;
        pStgVariant->Set(ulOffset);
        pStgVariant->m_bDirect = 0;

        break;
    }

ErrExit:
    if (SUCCEEDED(hr))
    {
        // Convert from internal 0-based to external 1-based index.
        *piIndex = iIndex + 1;
        SetDirty();
    }
    else
        m_rVariants.Delete(iIndex);
    return (hr);
}

	
//*****************************************************************************
// Lookup the logical variant and return a copy to the caller.
//*****************************************************************************
HRESULT StgVariantPool::GetVariant(     // Return code.
    ULONG       iIndex,                 // 1-based index of the item to get.
    VARIANT     *pVal)                  // Put variant here.
{
    HRESULT     hr = S_OK;              // A result.
    StgVariant  *pStgVariant;           // The pool entry.
    ULONG       ulOffset;               // Offset into pool's stream.
    ULONG       ulOther = -1;           // Offset into another pool
    void        *pRead;                 // For writing directly to the stream.
    ULONG       cbRead = 0;             // Bytes to write directly to stream.
    LPCWSTR      pString;                // The string, if a BSTR.
    LARGE_INTEGER liOffset;             // For stream seek.
    VARTYPE     vt;                     // Resulting type.

    _ASSERTE(pVal->vt == VT_EMPTY);

    // If the index is 0, then nothing was ever assigned.  Leave the value of VT_EMPTY.
    if (iIndex == 0)
        return (S_OK);

    // Convert to 0-based internal format.
    --iIndex;
    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

    pStgVariant = m_rVariants.Get(iIndex);
    vt = pStgVariant->m_vt;

    // Pull the value out of the array and/or stream.
    switch (vt)
    {
    // one and two byte values are easy.
    case VT_UI1:
    case VT_I1:
        pVal->cVal = static_cast<CHAR>(pStgVariant->Get());
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        pVal->iVal = static_cast<SHORT>(pStgVariant->Get());
        break;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        pRead = &pVal->lVal;
        cbRead = 4;
        goto ReadFromStream;

    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_I8:
    case VT_UI8:
        pRead = &pVal->dblVal;
        cbRead = sizeof(double);
        goto ReadFromStream;

    case VT_BLOB:
    case VT_BSTR:
        pRead = &ulOther;
        cbRead = sizeof(ulOther);
        
ReadFromStream:
        // Get the value; perhaps indirectly.
        if (FAILED(hr = GetValue(pStgVariant, pRead, cbRead)))
            goto ErrExit;
        // If the variant is a BSTR, create one.
        if (pStgVariant->m_vt == VT_BSTR)
        {
            if (ulOther == -1)
                pVal->bstrVal = 0;
            else
            {
                pString = m_pStringPool->GetString(ulOther);
                if (pString == 0)
                    pVal->bstrVal = 0;
                else
                {
                    if ((pVal->bstrVal = ::SysAllocString(pString)) == 0)
                        return (PostError(OutOfMemory()));
                }
            }
        }
        else
        if (pStgVariant->m_vt == VT_BLOB)
        {   // It is a blob.  Retrieve it.
            if (ulOther == -1)
                vt = VT_EMPTY;
            else
            {
                const void *pBlob;
                ULONG cbBlob;
                pBlob = m_pBlobPool->GetBlob(ulOther, &cbBlob);
				//@todo: if we can find a supported way to keep OLEAUT32 from freeing safearray memory
				// we should let the safearray point to our data.  Until then, we have to copy.
#if !defined(VARIANT_BLOB_NOALLOC)
				pVal->parray = SafeArrayCreateVector(VT_UI1, 0, cbBlob);
				if (pVal->parray == 0)
					return (E_OUTOFMEMORY);
				memcpy(pVal->parray->pvData, pBlob, cbBlob);
#else
                if (FAILED(hr = SafeArrayAllocDescriptor(1, &pVal->parray)))
                    return (hr);
                pVal->parray->cbElements = 1;
                pVal->parray->rgsabound[0].cElements = cbBlob;
                pVal->parray->rgsabound[0].lLbound = 0;
                pVal->parray->fFeatures = FADF_STATIC | FADF_FIXEDSIZE;
                pVal->parray->pvData = const_cast<void*>(pBlob);
#endif
                vt = VT_UI1 | VT_ARRAY;
            }
        }
        break;

    default:
        // Retrieve the offset into the variant stream.
        ulOffset = pStgVariant->Get();
        liOffset.QuadPart = ulOffset;

        // Read the value from the stream.
        if (FAILED(hr = m_pIStream->Seek(liOffset, STREAM_SEEK_SET, 0)) ||
            FAILED(hr = VariantReadFromStream(pVal, m_pIStream)))
            goto ErrExit;
        break;
    }

ErrExit:
    if (SUCCEEDED(hr))
        pVal->vt = vt;
    return (hr);
}

//*****************************************************************************
// Get the BLOB stored as a variant.
//*****************************************************************************
HRESULT StgVariantPool::GetVariant(     // Return code.
    ULONG       iIndex,                 // 1-based index of the item to get.
    ULONG       *pcbBlob,               // Return size of blob.
    const void  **ppBlob)               // Put blob pointer here.
{
    HRESULT     hr;                     // A result.
    StgVariant  *pStgVariant;           // A pool entry.
    ULONG       ulOther;                // Offset into another pool

    // If the index is 0, then nothing was ever assigned.  Leave the value of VT_EMPTY.
    if (iIndex == 0)
        return (S_OK);

    // Convert to 0-based internal format.
    --iIndex;
    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

    pStgVariant = m_rVariants.Get(iIndex);

    if (pStgVariant->m_vt != VT_BLOB)
        return (E_INVALIDARG);

    // Get the blob's offset.
    if (FAILED(hr = GetValue(pStgVariant, &ulOther, 4)))
        return (hr);

    // Get the blob.
    *ppBlob = m_pBlobPool->GetBlob(ulOther, pcbBlob);

    return (S_OK);
}

//*****************************************************************************
// Get the type of the variant.
//*****************************************************************************
HRESULT StgVariantPool::GetVariantType( // Return code.
    ULONG       iIndex,                 // 1-based index of the item to get.
    VARTYPE     *pVt)                   // Put variant type here.
{
    StgVariant  *pStgVariant;           // A pool entry.

    // If the index is 0, then nothing was ever assigned.  The type is VT_EMPTY.
    if (iIndex == 0)
    {
        *pVt = VT_EMPTY;
        return (S_OK);
    }

    // Convert to 0-based internal format.
    --iIndex;

    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

    pStgVariant = m_rVariants.Get(iIndex);

    *pVt = pStgVariant->m_vt;
    
    return (S_OK);
}

//*****************************************************************************
// Get the blob pool index of a blob variant.
//*****************************************************************************
ULONG StgVariantPool::GetBlobIndex(		// Return blob pool index.
	ULONG		iIndex)					// 1-based Variant index.
{
    HRESULT     hr;                     // A result.
    StgVariant  *pStgVariant;           // A pool entry.
    ULONG       ulOther;                // Offset into another pool

    // If the index is 0, then nothing was ever assigned.  Return 0, null blob.
    if (iIndex == 0)
        return 0;

    // Convert to 0-based internal format.
    --iIndex;
    _ASSERTE(iIndex < static_cast<ULONG>(m_rVariants.Count()));

	// Get the small form of the variant.
    pStgVariant = m_rVariants.Get(iIndex);

	// If not a blob, there is no blob index.  Return 0.
    if (pStgVariant->m_vt != VT_BLOB)
        return 0;

    // Get the blob's offset.
    if (FAILED(hr = GetValue(pStgVariant, &ulOther, 4)))
        return (hr);

    // Return the offset.
    return ulOther;
}


HRESULT StgVariantPool::GetValue(       // Get the value directly or from the stream.
    StgVariant  *pStgVariant,           // The internal form of variant.
    void        *pRead,                 // Where to put the value.
    ULONG       cbRead)                 // Bytes to read for value.
{
    HRESULT     hr;                     // A result.

    if (pStgVariant->m_bDirect)
    {
        _ASSERTE(cbRead == 4);
        *reinterpret_cast<long*>(pRead) = pStgVariant->Get();
        return (S_OK);
    }

    // Seek to this variant in the pool's stream.
    LARGE_INTEGER iSeek;
    iSeek.QuadPart = pStgVariant->Get();
    if (FAILED(hr = m_pIStream->Seek(iSeek, STREAM_SEEK_SET, 0)))
        return (hr);

    // Read the bits from the pool's stream.
    hr = m_pIStream->Read(pRead, cbRead, 0);

    return (hr);
}
        
HRESULT StgVariantPool::GetEntrysStreamSize(// Get the size for the streamed part of this item.
    StgVariant  *pStgVariant,           // The internal form of variant.
    ULONG       *pSize)                 // Put size here..
{
	HRESULT		hr = S_OK;				// A result.
	ULONG		cbOthers;				// Total size of others pool.
	int			i;						// Loop control.

    if (pStgVariant->m_bDirect)
    {
        *pSize = 0;
        return (S_OK);
    }

    switch (pStgVariant->m_vt)
    {
    // one and two byte values are easy.
    case VT_UI1:
    case VT_I1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        _ASSERTE(!"Non-directly stored 1 or 2 byte variant");
        *pSize = 0;
        break;

    // If these are in stream, they are 4 bytes.
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:

    case VT_BSTR:
    case VT_BLOB:
        *pSize = sizeof(LONG);
        break;

    // If these are in stream, they are 8 bytes.
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_I8:
    case VT_UI8:
        *pSize = sizeof(DOUBLE);
        break;

    default:
        // Search for next non-direct entry.  Stream size will be offsets delta.
        i = m_rVariants.ItemIndex(pStgVariant);
        for (++i; i<m_rVariants.Count(); ++i)
        {
            if (!m_rVariants[i].m_bDirect)
                break;
        }
        // Found one, or ran out of entries?
        if (i == m_rVariants.Count())
        {   // Ran out of entries
            if (FAILED(hr = GetOtherSize(&cbOthers)))
                break;
            *pSize = cbOthers - pStgVariant->m_iVal;
        }
        else
        {   // Found one.
            *pSize = m_rVariants[i].m_iVal - pStgVariant->m_iVal;
        }
        break;
    }
    return (hr);
}
        

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
// Prepare for pool re-organization.
HRESULT StgVariantPool::OrganizeBegin()
{
    int         cRemap;                 // Number of entries in remap array.
    int         i;                      // Loop control.

    // Validate transition.
    _ASSERTE(m_State == eNormal);

    _ASSERTE(m_Remap.Count() == 0);

    // Allocate an array with an entry for every current variant.
    cRemap = m_rVariants.Count();
    if (!m_Remap.AllocateBlock(cRemap))
        return (PostError(OutOfMemory()));

    // Set everything as "not marked".
    for (i=0; i<cRemap; ++i)
        m_Remap[i] = -1;

    m_State = eMarking;
    return (S_OK);
}

// Mark an object as being live in the organized pool.
HRESULT StgVariantPool::OrganizeMark(
    ULONG       ulOffset)               // 1-based index of the item.
{
    HRESULT     hr=S_OK;                // A result.
    StgVariant  *pStgVariant;           // The entry being marked.
    ULONG       ulOther;                // Offset into another pool.

    // Validate state.
    _ASSERTE(m_State == eMarking);

    // If index 0, is for a VT_EMPTY, which is not in the pool.
    // Some columns use 0xffffffff as a null flag.
    if (ulOffset == 0 || ulOffset == 0xffffffff)
        return (S_OK);

    // Convert to 0-based internal format.
    --ulOffset;

    // Mark the entry as in use.
    _ASSERTE(ulOffset < static_cast<ULONG>(m_Remap.Count()));
    m_Remap[ulOffset] = 0;

    // If it is a string or blob, mark the appropriate pool entry.
    pStgVariant = m_rVariants.Get(ulOffset);

    if (pStgVariant->m_vt == VT_BSTR || pStgVariant->m_vt == VT_BLOB)
    {
        if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
            return (hr);
        if (pStgVariant->m_vt == VT_BSTR)
            hr = m_pStringPool->OrganizeMark(ulOther);
        else
            hr = m_pBlobPool->OrganizeMark(ulOther);
    }

    return (hr);
}

// Organize, based on marked items.
HRESULT StgVariantPool::OrganizePool()
{
    HRESULT     hr;                     // A result.
    int         i, j;                   // Loop control.
    int         iNew=0;                 // For assigning the new index.
    ULONG       ulOffset;               // An offset into something.
    ULONG       cbStreamExtra;          // Extra size in the Stream.
    ULONG       cbBlobExtra;            // sizeof(ULONG) if Blobs not stored directly.
    ULONG       cbStringExtra;          // sizeof(ULONG) if strings not stored directly.
    StgVariant  *pStgVariant;           // An entry in the pool.
    StgVariant  *pStgVariant2;          // A prior entry, for finding duplicates.
    ULONG       ulOffset2;              // A prior entry's offset; for finding duplicates.
    int         bFoundDup;              // Was a duplicate prior entry found?
#ifdef _DEBUG
    int         cDups;                  // Count of duplicates.
#endif

    // Validate state.
    _ASSERTE(m_State == eMarking);
    m_State = eOrganized;

    // Record size of header.
    m_cbOrganizedSize = sizeof(ULONG);
    DEBUG_STMT(cDups = 0);

    // How big are string and blob pool offsets?
    if (FAILED(hr = m_pBlobPool->GetSaveSize(&ulOffset)))
        return (hr);
    cbBlobExtra = (ULONG)((ulOffset <= StgVariant::VALUE_MASK) ? 0 : sizeof(ULONG));

    if (FAILED(hr = m_pStringPool->GetSaveSize(&ulOffset)))
        return (hr);
    cbStringExtra = (ULONG)((ulOffset <= StgVariant::VALUE_MASK) ? 0 : sizeof(ULONG));

    //@todo: use a hashed lookup instead of an O(n) lookup.  (which makes loop O(n**2) )

    // Assign new indices for marked entries.
    for (i=0; i<m_Remap.Count(); ++i)
    {   // Is entry marked as in-use?
        if (m_Remap[i] != -1)
        {   // Examine the entry, and look for a prior duplicate to use instead.
            bFoundDup = false;
            pStgVariant = m_rVariants.Get(i);
            // Look for Blobs and Strings by their pool offset.
            if (pStgVariant->m_vt == VT_BLOB || pStgVariant->m_vt == VT_BSTR)
            {
                if (FAILED(hr = GetValue(pStgVariant, &ulOffset, sizeof(ulOffset))))
                    return (hr);
                for (j = i-1; j>=0 ; --j)
                {   // If prior item is getting deleted, skip it.
                    if (m_Remap[j] == -1)
                        continue;
                    pStgVariant2 = m_rVariants.Get(j);
                    if (pStgVariant2->m_vt == pStgVariant->m_vt)
                    {
                        if (FAILED(hr = GetValue(pStgVariant2, &ulOffset2, sizeof(ulOffset2))))
                            return (hr);
                        if (ulOffset2 == ulOffset)
                        {
                            m_Remap[i] = m_Remap[j];
                            bFoundDup = true;
                            break;
                        }
                    }
                }
            }
            else
            if (pStgVariant->m_bDirect)
            {   // Look for a prior duplicate of the direct value.
                for (j = i-1; j>=0 ; --j)
                {   // If prior item is getting deleted, skip it.
                    if (m_Remap[j] == -1)
                        continue;
                    if (*pStgVariant == m_rVariants[j])
                    {
                        m_Remap[i] = m_Remap[j];
                        bFoundDup = true;
                        break;
                    }
                }
            }

            // If entry is a dup, size is already counted, so on to the next entry.
            if (bFoundDup)
            {
                DEBUG_STMT(++cDups;)
                continue;
            }

            // Record this kept entry.
            m_Remap[i] = iNew++;

            // Record the size. Every item has a StgVariant.
            m_cbOrganizedSize += sizeof(StgVariant);

            // If a blob or string, size will depend on that other pool.
            if (pStgVariant->m_vt == VT_BSTR)
                m_cbOrganizedSize += cbStringExtra;
            else 
            if (pStgVariant->m_vt == VT_BLOB)
                m_cbOrganizedSize += cbBlobExtra;
            else
            {
                if (FAILED(hr = GetEntrysStreamSize(pStgVariant, &cbStreamExtra)))
                    return (hr);
                m_cbOrganizedSize += cbStreamExtra;
            }

        }
    }

    // Align; compute size needed for cookie.
    m_cOrganizedVariants = iNew;
    m_cbOrganizedSize = ALIGN4BYTE(m_cbOrganizedSize);
    m_cbOrganizedCookieSize = (int)(iNew > USHRT_MAX ? sizeof(long) : sizeof(short));

#if defined(_DEBUG)
    WCHAR buf[30];
    wsprintfW(buf, L"%d duplicates merged\n", cDups);
    WszOutputDebugString(buf);
#endif
    return (S_OK);
}

// Remap a cookie from the in-memory state to the persisted state.
HRESULT StgVariantPool::OrganizeRemap(
    ULONG       ulOld,                  // 1-based old index.
    ULONG       *pulNew)                // 1-based new index.
{
    ULONG       ulNew;

    // Validate state.
    _ASSERTE(m_State == eOrganized || m_State == eNormal);

    // If for VT_EMPTY, no translation.  If not reorganized, new == old.
    // If index 0, is for a VT_EMPTY, which is not in the pool.
    // Some columns use 0xffffffff as a null flag.
    if (ulOld == 0 || ulOld == 0xffffffff || m_State == eNormal)
    {
        *pulNew = ulOld;
        return (S_OK);
    }

    // Convert to 0-based internal format.
    --ulOld;

    // Look up in the remap array.
    _ASSERTE(ulOld < static_cast<ULONG>(m_Remap.Count()));
    _ASSERTE(m_Remap[ulOld] != -1);
    ulNew = m_Remap[ulOld];

    // Give back the new index in 1-based external format.
    *pulNew = ulNew + 1;

    return (S_OK);
}

// Done with regoranization.  Release any state.
HRESULT StgVariantPool::OrganizeEnd()
{
    m_Remap.Clear();
    m_cbOrganizedSize = 0;

    m_State = eNormal;
    return (S_OK);
}


//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
HRESULT StgVariantPool::GetSaveSize(    // Return code.
    ULONG       *pcbSaveSize)           // Return save size of this pool.
{
	// Only an organized pool can be saved to stream.
	_ASSERTE(m_State == eOrganized);

    *pcbSaveSize = m_cbOrganizedSize;
    
    return (S_OK);
}


//*****************************************************************************
// Save the pool data into the given stream.
//*****************************************************************************
HRESULT StgVariantPool::PersistToStream(// Return code.
    IStream     *pIStream)              // The stream to write to.
{
    HRESULT     hr = S_OK;              // A result.
    int         i;                      // Loop control.
    int         iPrev;                  // Most recently persisted item.
    ULONG       ulOffset;               // Cumulative offset in stream.
    ULONG       ulOther;                // Offset into another pool.
    int         bDirect;                // Is a given entry direct?
    StgVariant  *pStgVariant;           // An entry to be written.
    StgVariant  sStgVariant;            // A working variant.
    ULONG       cbWritten;              // For tracking the size.
    ULONG       cbStream;               // Size of an entry's stream part.
    int         bBlobDirect;            // Blobs offset stored direct?
    int         bStringDirect;          // Strings offset stored direct?

    // If not reorganized, just let the base class write the data.
    if (m_State == eNormal)
    {
        return StgPool::PersistToStream(pIStream);
    }

    // Write the size.
    if (FAILED(hr = pIStream->Write(&m_cOrganizedVariants, sizeof(ULONG), 0)))
        return (hr);
    cbWritten = sizeof(ULONG);

    // How big are string and blob pool offsets?
    if (FAILED(hr = m_pBlobPool->GetSaveSize(&ulOffset)))
        return (hr);
    bBlobDirect = (ulOffset <= StgVariant::VALUE_MASK) ? true : false;

    if (FAILED(hr = m_pStringPool->GetSaveSize(&ulOffset)))
        return (hr);
    bStringDirect = (ulOffset <= StgVariant::VALUE_MASK) ? true : false;

    // Write the variants to be kept.
    ulOffset = 0;
    iPrev = -1;
    for (i=0; i<m_rVariants.Count(); ++i)
    {   // Is this entry to be kept?  
        if (m_Remap[i] != -1)
        {   // If a duplicate of an already persisted entry, skip.
            if (static_cast<int>(m_Remap[i]) <= iPrev)
            {
#if defined(_DEBUG)
                // Search back until we find another entry that mapped to the same place.
                for (int j=i-1; j>=0; --j)
                {
                    if (m_Remap[j] == m_Remap[i])
                    {
                        _ASSERTE(m_rVariants[j].m_vt == m_rVariants[i].m_vt);
                        break;
                    }
                }
#endif
                continue;
            }
            // Get the entry.
            pStgVariant = m_rVariants.Get(i);
            bDirect = pStgVariant->m_bDirect;

            // If a string, direct is computed at save time (now).
            if (pStgVariant->m_vt == VT_BSTR)
            {   // If string offsets are stored directly, create the correct StgVariant.
                if (bStringDirect)
                {
                    if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                        return (hr);
                    if (FAILED(hr = m_pStringPool->OrganizeRemap(ulOther, &ulOther)))
                        return (hr);
                    sStgVariant.m_vt = VT_BSTR;
                    sStgVariant.m_bDirect = 1;
                    sStgVariant.m_iSign = 0;
                    sStgVariant.m_iVal = ulOther;
                    pStgVariant = &sStgVariant;
                    bDirect = true;
                }
                else

                    bDirect = false;
            }
            else
            if (pStgVariant->m_vt == VT_BLOB)
            {   // If Blob offsets are stored directly, create the correct StgVariant.
                if (bBlobDirect)
                {
                    if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                        return (hr);
                    if (FAILED(hr = m_pBlobPool->OrganizeRemap(ulOther, &ulOther)))
                        return (hr);
                    sStgVariant.m_vt = VT_BLOB;
                    sStgVariant.m_bDirect = 1;
                    sStgVariant.m_iSign = 0;
                    sStgVariant.m_iVal = ulOther;
                    pStgVariant = &sStgVariant;
                    bDirect = true;
                }
                else

                    bDirect = false;
            }

            // If not direct, create a new variant with the correct (future) offset.
            if (!bDirect)
            {   // Create a StgVariant with the stream offset that will exist in the persisted state.
                sStgVariant = *pStgVariant;
                sStgVariant.m_iVal = ulOffset;
                sStgVariant.m_bDirect = 0;
                // Account for the size of the stream part.
                if (FAILED(hr = GetEntrysStreamSize(pStgVariant, &cbStream)))
                    return (hr);
                ulOffset += cbStream;
                // Point to new variant, for the write.
                pStgVariant = &sStgVariant;
            }

            // Write out the variant.
            if (FAILED(hr = pIStream->Write(pStgVariant, sizeof(StgVariant), 0)))
                return (hr);
            cbWritten += sizeof(StgVariant);
            // Record that we've written it.
            iPrev = m_Remap[i];
        }
    }

    // Write any stream parts for the variants.
    iPrev = -1;
    for (i=0; i<m_rVariants.Count(); ++i)
    {   // Is this entry to be kept?  
        if (m_Remap[i] != -1)
        {   // If a duplicate of an already persisted entry, skip.
            if (static_cast<int>(m_Remap[i]) <= iPrev)
                continue;
            // Get the entry.
            pStgVariant = m_rVariants.Get(i);

            // If direct, there is no stream part.
            if (pStgVariant->m_vt == VT_BSTR)
            {
                if (bStringDirect)
                    continue;
                if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                    return (hr);
                if (FAILED(hr = m_pStringPool->OrganizeRemap(ulOther, &ulOther)))
                    return (hr);
WriteOtherOffset:
                if (FAILED(hr = m_pIStream->Write(&ulOther, sizeof(ulOther), 0)))
                    return (hr);
                // Record that it was written.
                cbWritten += sizeof(ulOther);

                iPrev = m_Remap[i];
                continue;
            }
            else 
            if (pStgVariant->m_vt == VT_BLOB)
            {
                if (bBlobDirect)
                    continue;
                if (FAILED(hr = GetValue(pStgVariant, &ulOther, sizeof(ulOther))))
                    return (hr);
                if (FAILED(hr = m_pBlobPool->OrganizeRemap(ulOther, &ulOther)))
                    return (hr);
                goto WriteOtherOffset;
            }
            else
            if (pStgVariant->m_bDirect)
                continue;

            // Get the size of the stream part.
            if (FAILED(hr = GetEntrysStreamSize(pStgVariant, &cbStream)))
                return (hr);
            // Copy the stream bytes to the output stream.

            // Seek to this variant in the storage stream.
            LARGE_INTEGER iSeek;
            iSeek.QuadPart = pStgVariant->m_iVal;
            if (FAILED(hr = m_pIStream->Seek(iSeek, STREAM_SEEK_SET, 0)))
                return (hr);

            // Copy the bits to the output stream.
            ULARGE_INTEGER iBigSize;
            iBigSize.QuadPart = cbStream;
            hr = m_pIStream->CopyTo(pIStream, iBigSize, 0, 0);
            cbWritten += cbStream;

            iPrev = m_Remap[i];
        }
    }

    // Align.
    if ((cbStream = ALIGN4BYTE(cbWritten) - cbWritten) != 0)
    {
        hr = 0;
        _ASSERTE(sizeof(hr) >= cbStream);
        hr = m_pIStream->Write(&hr, cbStream, 0);
        cbWritten += cbStream;
    }

    _ASSERTE(cbWritten == m_cbOrganizedSize);

    return (hr);
}


//*****************************************************************************
// Return the size of the current variable sized data.
//*****************************************************************************
HRESULT StgVariantPool::GetOtherSize(   // Return code.
    ULONG       *pulSize)               // Put size of the stream here.
{
    STATSTG     statstg;                // Information about stream.
    HRESULT     hr;

    // Allow case where there is no data.
    if (m_pIStream == 0)
    {
        *pulSize = 0;
        return (S_OK);
    }

    // Ask the stream for how big it is.
    if (FAILED(hr = m_pIStream->Stat(&statstg, 0)))
        return (hr);

    // Never allow the size to get bigger than 4 bytes.
    if (statstg.cbSize.QuadPart > ULONG_MAX)
        return (PostError(DISP_E_OVERFLOW));

    // Return the new offset to caller.
    *pulSize = static_cast<ULONG>(statstg.cbSize.QuadPart);
    return (S_OK);
}



//
//
// Helper code.
//
//


//*****************************************************************************
// Unfortunately the CreateStreamOnHGlobal is a little too smart in that
// it gets its size from GlobalSize.  This means that even if you give it the
// memory for the stream, it has to be globally allocated.  We don't want this
// because we have the stream read only in the middle of a memory mapped file.
// CreateStreamOnMemory and the corresponding, internal only stream object solves
// that problem.
//*****************************************************************************

class CInMemoryStream : public IStream
{
public:
    CInMemoryStream() :
        m_pMem(0),
        m_cbSize(0),
        m_cbCurrent(0),
        m_cRef(1)
    { }

    void InitNew(
        void        *pMem,
        ULONG       cbSize)
    {
        m_pMem = pMem;
        m_cbSize = cbSize;
        m_cbCurrent = 0;
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (InterlockedIncrement((long *) &m_cRef));
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        ULONG       cRef = InterlockedDecrement((long *) &m_cRef);
        if (cRef == 0)
            delete this;
        return (cRef);
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppOut)
    {
        *ppOut = this;
        AddRef();
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Read(
        void        *pv,
        ULONG       cb,
        ULONG       *pcbRead)
    {
        ULONG       cbRead = min(cb, m_cbSize - m_cbCurrent);

        if (cbRead == 0)
            return (PostError(STG_E_READFAULT));
        memcpy(pv, (void *) ((UINT_PTR) m_pMem + m_cbCurrent), cbRead);
        if (pcbRead)
            *pcbRead = cbRead;
        m_cbCurrent += cbRead;
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Write(
        const void  *pv,
        ULONG       cb,
        ULONG       *pcbWritten)
    {
        if (m_cbCurrent + cb > m_cbSize)
            return (OutOfMemory());
        memcpy((BYTE *) m_pMem + m_cbCurrent, pv, cb);
        m_cbCurrent += cb;
        if (pcbWritten) *pcbWritten = cb;
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Seek(
        LARGE_INTEGER dlibMove,
        DWORD       dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
    {
        _ASSERTE(dwOrigin == STREAM_SEEK_SET);
        _ASSERTE(dlibMove.QuadPart <= ULONG_MAX);
        m_cbCurrent = (ULONG) dlibMove.QuadPart;
        _ASSERTE(m_cbCurrent < m_cbSize);
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE SetSize(
        ULARGE_INTEGER libNewSize)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream     *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
    {
        HRESULT     hr;
        // We don't handle pcbRead or pcbWritten.
        _ASSERTE(pcbRead == 0);
        _ASSERTE(pcbWritten == 0);

        _ASSERTE(cb.QuadPart <= ULONG_MAX);
        ULONG       cbTotal = min(static_cast<ULONG>(cb.QuadPart), m_cbSize - m_cbCurrent);
        ULONG       cbRead=min(1024, cbTotal);
        CQuickBytes rBuf;
        void        *pBuf = rBuf.Alloc(cbRead);
        if (pBuf == 0)
            return (PostError(OutOfMemory()));

        while (cbTotal)
        {
            if (cbRead > cbTotal)
                cbRead = cbTotal;
            if (FAILED(hr=Read(pBuf, cbRead, 0)))
                return (hr);
            if (FAILED(hr=pstm->Write(pBuf, cbRead, 0)))
                return (hr);
            cbTotal -= cbRead;
        }

        // Adjust seek pointer to the end.
        m_cbCurrent = m_cbSize;

        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD       grfCommitFlags)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE Revert()
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD       dwLockType)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD       dwLockType)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG     *pstatstg,
        DWORD       grfStatFlag)
    {
        pstatstg->cbSize.QuadPart = m_cbCurrent;
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream     **ppstm)
    {
        return (BadError(E_NOTIMPL));
    }

private:
    void        *m_pMem;                // Memory for the read.
    ULONG       m_cbSize;               // Size of the memory.
    ULONG       m_cbCurrent;            // Current offset.
    ULONG       m_cRef;                 // Ref count.
};

HRESULT CreateStreamOnMemory(           // Return code.
    void        *pMem,                  // Memory to create stream on.
    ULONG       cbSize,                 // Size of data.
    IStream     **ppIStream)            // Return stream object here.
{
    CInMemoryStream *pIStream;          // New stream object.
    if ((pIStream = new CInMemoryStream) == 0)
        return (PostError(OutOfMemory()));
    pIStream->InitNew(pMem, cbSize);
    *ppIStream = pIStream;
    return (S_OK);
}

//********************************************************************************
// The following functions make up for lacks in the 64-bit SDK ATL implementation
// as of 15 May 1998. [[brianbec]]
//********************************************************************************
#ifdef _IA64_

    HRESULT BstrWriteToStream (const CComBSTR & bStr,  IStream * pStream)
    {
        _ASSERTE(pStream != NULL);
        
        ULONG cb;
        ULONG cbStrLen = bStr.m_str ? SysStringByteLen(bStr.m_str)+sizeof(OLECHAR) : 0;
        
        HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
        
        if (FAILED(hr))
            return hr;
        return cbStrLen ? pStream->Write((void*) bStr.m_str, cbStrLen, &cb) : S_OK;
            return S_OK ;
    }


    HRESULT BstrReadFromStream (CComBSTR & bStr ,  IStream * pStream)
    {
        _ASSERTE(pStream != NULL);
        _ASSERTE(bStr.m_str == NULL); // should be empty
        ULONG cb = 0;
        ULONG cbStrLen;
        HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &cb);
        if (hr != S_OK)
            return hr;
            
        // FIX:
        if (cb != sizeof(cbStrLen))
            return E_FAIL;
    
        if (cbStrLen != 0)
        {
            //subtract size for terminating NULL which we wrote out
            //since SysAllocStringByteLen overallocates for the NULL
            bStr.m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
            if (bStr.m_str == NULL)
                hr = E_OUTOFMEMORY;
            else
                hr = pStream->Read((void*) bStr.m_str, cbStrLen, &cb);
        }
        return hr;
    }

#endif



//*****************************************************************************
// This helper functions is stolen from CComVariant in the ATL code.  this
// version fixes a couple of problems with ATL's code:  (1) it handles VT_BYREF
// data, and (2) it will back out the 2 byte VARTYPE if the first Write fails.
// Finally, this version doesn't require a complete copy of the variant to work.
//*****************************************************************************
HRESULT VariantWriteToStream(VARIANT *pVal, IStream* pStream)
{
    CComVariant sConvert;
    HRESULT     hr;

    // Convert byref values into the value they point to.
    if (pVal->vt & VT_BYREF)
    {
        if (FAILED(hr = ::VariantChangeType(&sConvert, pVal, 0, pVal->vt & ~VT_BYREF)))
            return (hr);
        pVal = &sConvert;
    }

    if (FAILED(hr = pStream->Write(&pVal->vt, sizeof(VARTYPE), 0)))
        return (hr);

    int cbWrite = 0;
    switch (pVal->vt)
    {
    case VT_UNKNOWN:
    case VT_DISPATCH:
        {
#if defined(UNDER_CE)
			return E_INVALIDARG;
#else
            CComPtr<IPersistStream> spStream;
            if (pVal->punkVal != NULL)
                hr = pVal->punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
            if (SUCCEEDED(hr))
            {
                if (spStream != NULL)
                    hr = OleSaveToStream(spStream, pStream);
                else
                    hr = WriteClassStm(pStream, CLSID_NULL);
            }
#endif
        }
    case VT_UI1:
    case VT_I1:
        cbWrite = sizeof(BYTE);
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        cbWrite = sizeof(short);
        break;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        cbWrite = sizeof(long);
        break;
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        cbWrite = sizeof(double);
        break;
    case VT_I8:
    case VT_UI8:
        cbWrite = sizeof(__int64);
        break;
    default:
        break;
    }

    // If intrinsic type, write it out.
    if (SUCCEEDED(hr) && cbWrite != 0)
        hr = pStream->Write((void*) &pVal->bVal, cbWrite, NULL);

    // If errors occured on conversion, then take off the VARTTYPE.
    if (FAILED(hr))
    {
        STATSTG     statstg;                // Information about stream.
        if (SUCCEEDED(pStream->Stat(&statstg, 0)))
            VERIFY(pStream->SetSize(statstg.cbSize) == S_OK);
        return (hr);
    }

    if (cbWrite != 0)
        return (S_OK);

    // Try conversion to BSTR.
    CComBSTR bstrWrite;
    CComVariant varBSTR;
    if (pVal->vt != VT_BSTR)
    {
        if (SUCCEEDED(hr = ::VariantChangeType(&varBSTR, pVal, VARIANT_NOVALUEPROP, VT_BSTR)))
            bstrWrite = varBSTR.bstrVal;
    }
    else
        bstrWrite = pVal->bstrVal;

	if (SUCCEEDED(hr))
    {
    	_ASSERTE(pStream != NULL);
    	ULONG cb;
    	ULONG cbStrLen = (ULONG)(bstrWrite ? SysStringByteLen(bstrWrite)+sizeof(OLECHAR) : 0);
    	HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
    	if (FAILED(hr))
    		return hr;
    	hr = cbStrLen ? pStream->Write((void*) bstrWrite, cbStrLen, &cb) : S_OK;
    }

    // Cleanup conversion errors in the stream.
    if (FAILED(hr))
    {
        STATSTG     statstg;                // Information about stream.
        if (SUCCEEDED(pStream->Stat(&statstg, 0)))
            VERIFY(pStream->SetSize(statstg.cbSize) == S_OK);
        return (hr);
    }
    return (hr);
}


//*****************************************************************************
// Modified version of ATL's read code.
//*****************************************************************************
HRESULT VariantReadFromStream(VARIANT *pVal, IStream* pStream)
{
    _ASSERTE(pStream != NULL);
    HRESULT hr;
    hr = VariantClear(pVal);
    if (FAILED(hr))
        return hr;
    VARTYPE vtRead;
    hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
    if (FAILED(hr))
        return hr;

	pVal->vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
#if defined(UNDER_CE)
			return E_INVALIDARG;
#else
			pVal->punkVal = NULL;
			hr = OleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
				(void**)&pVal->punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
#endif
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	case VT_I8:
	case VT_UI8:
		cbRead = sizeof(__int64);
		break;
	default:
		break;
	}
	if (cbRead != 0)
		return pStream->Read((void*) &pVal->bVal, cbRead, NULL);

    // Try to read as BSTR.
    BSTR bstrRead=0;
    ULONG cb;
    ULONG cbStrLen;
    hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &cb);
    if (FAILED(hr))
        return hr;
    if (cbStrLen != 0)
    {
        //subtract size for terminating NULL which we wrote out
        //since SysAllocStringByteLen overallocates for the NULL
        bstrRead = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
        if (bstrRead == NULL)
            hr = E_OUTOFMEMORY;
        else
            hr = pStream->Read((void*) bstrRead, cbStrLen, &cb);
    }

	if (FAILED(hr))
		return hr;
	pVal->vt = VT_BSTR;
	pVal->bstrVal = bstrRead;
	if (vtRead != VT_BSTR)
		hr = VariantChangeType(pVal, pVal, 0, vtRead);
	return hr;
}


#if 0 && defined(_DEBUG)
//*****************************************************************************
// Checks all structures for validity.
//*****************************************************************************
void StgCodePool::AssertValid() const
{
    CCodeChunk  *pChunk;                // To follow chain.
    ULONG       iOffset;                // Offset within a chunk.
    ULONG       iTotal;                 // Total offset so far.
    ULONG       iLen;                   // Length of one element.


    if (m_pChain)
    {
        // If we have a chain, we'd better plan on freeing it.
        _ASSERTE(m_bFree);

        iTotal = 0;
        pChunk = m_pChain;
        // Iterate over chunks.
        do {
            iOffset = 0;

            // Is this chunk the last one in the chain?
            if (pChunk->m_pNext == 0)
            {
                _ASSERTE(m_pCurrent == pChunk);
                _ASSERTE(m_iOffsetCurChunk == iTotal);
            }

            // Iterate over elements in the chunk.
            iLen = 0;
            while (iOffset < pChunk->m_iSize && iLen >= 0)
            {
                // Length of an element.
                iLen = CPackedLen::GetLength(pChunk->m_data+iOffset);
                // Validate length.
                _ASSERTE(iLen != -1);
                if (iLen == -1) break;
                // On to next element (or end).
                iOffset += iLen + CPackedLen::Size(iLen);
            };

            // If not out due to bad length, check that exactly consumed chunk.
            if (iLen >= 0)
                _ASSERTE(iOffset == pChunk->m_iSize);

            iTotal += iOffset;

            // On to next chunk;
            pChunk = pChunk->m_pNext;
        } while (pChunk);
    }
    else
    if (m_pData)
    {
        _ASSERTE(m_iSize > 0);
        iOffset = 0;

        // Iterate over elements in the file data.
        do {
            // Length of an element.
            iLen = CPackedLen::GetLength(m_pData+iOffset);
            // Validate length.
            _ASSERTE(iLen >= 0);
            if (iLen < 0) break;
            // On to next element (or end).
            iOffset += iLen + CPackedLen::Size(iLen);
        } while (iOffset < m_iSize && iLen >= 0);

        // If not out due to bad length, check that exactly consumed chunk.
        if (iLen >= 0)
            _ASSERTE(iOffset == m_iSize);
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\complib\stgdb\stgpool.h ===
//*****************************************************************************
// StgPool.h
//
// Pools are used to reduce the amount of data actually required in the database.
// This allows for duplicate string and binary values to be folded into one
// copy shared by the rest of the database.  Strings are tracked in a hash
// table when insert/changing data to find duplicates quickly.  The strings
// are then persisted consecutively in a stream in the database format.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __StgPool_h__
#define __StgPool_h__

#pragma warning (disable : 4355)		// warning C4355: 'this' : used in base member initializer list

#include <limits.h>
#include "StgPooli.h"					// Internal helpers.

#if defined(_TRACE_SIZE)
#include "StgTraceSize.h"
#endif

// @todo: One problem with the pools, we have no way to removing strings from
// the pool.  To remove, you need to know the ref count on the string, and
// need the ability to compact the pool and reset all references (ouch!).


//********** Constants ********************************************************
const int DFT_STRING_HEAP_SIZE = 2048;
const int DFT_GUID_HEAP_SIZE = 2048;
const int DFT_BLOB_HEAP_SIZE = 1024;
const int DFT_VARIANT_HEAP_SIZE = 512;
const int DFT_CODE_HEAP_SIZE = 8192;



// Forwards.
class StgStringPool;
class StgBlobPool;
class StgCodePool;


//*****************************************************************************
// This class provides common definitions for heap segments.  It is both the
//  base class for the heap, and the class for heap extensions (additional
//  memory that must be allocated to grow the heap).
//*****************************************************************************
class StgPoolSeg
{
public:
	StgPoolSeg() : 
		m_pSegData(0), 
		m_pNextSeg(0), 
		m_cbSegSize(0), 
		m_cbSegNext(0) 
	{ }
	~StgPoolSeg() 
	{ _ASSERTE(m_pSegData == 0);_ASSERTE(m_pNextSeg == 0); }
protected:
	BYTE		*m_pSegData;			// Pointer to the data.
	StgPoolSeg	*m_pNextSeg;			// Pointer to next segment, or 0.
	ULONG		m_cbSegSize;			// Size of the buffer.  Note that this may
										//  be less than the allocated size of the
										//  buffer, if the segment has been filled
										//  and a "next" allocated.
	ULONG		m_cbSegNext;			// Offset of next available byte in segment.
										//  Segment relative.

	friend class StgPool;
    friend class StgStringPool;
	friend class StgGuidPool;
	friend class StgBlobPool;
};

//
//
// StgPoolReadOnly
//
// 
//*****************************************************************************
// This is the read only StgPool class
//*****************************************************************************
class StgPoolReadOnly : public StgPoolSeg
{
friend CBlobPoolHash;

public:
	StgPoolReadOnly() { };

	~StgPoolReadOnly();

	
//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
	HRESULT InitOnMemReadOnly(				// Return code.
		void		*pData,					// Predefined data.
		ULONG		iSize);					// Size of data.

//*****************************************************************************
// Prepare to shut down or reinitialize.
//*****************************************************************************
	virtual	void UnInit();

//*****************************************************************************
// Indicate if heap is empty.
//*****************************************************************************
	virtual int IsEmpty()					// true if empty.
	{ return (m_pSegData == 0); }

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
	virtual int OffsetSize()
	{
        if (m_cbSegSize < USHRT_MAX)
			return (sizeof(USHORT));
		else
			return (sizeof(ULONG));
	}

//*****************************************************************************
// true if the heap is read only.
//*****************************************************************************
	virtual int IsReadOnly() { return true ;};

//*****************************************************************************
// Is the given cookie a valid offset, index, etc?
//*****************************************************************************
	virtual int IsValidCookie(ULONG ulCookie)
	{ return (IsValidOffset(ulCookie)); }


//*****************************************************************************
// Return a pointer to a null terminated string given an offset previously
// handed out by AddString or FindString.
//*****************************************************************************
	FORCEINLINE LPCWSTR GetStringReadOnly(	// Pointer to string.
		ULONG		iOffset)				// Offset of string in pool.
	{     return (reinterpret_cast<LPCWSTR>(GetDataReadOnly(iOffset))); }

//*****************************************************************************
// Return a pointer to a null terminated string given an offset previously
// handed out by AddString or FindString.
//*****************************************************************************
	FORCEINLINE LPCWSTR GetString(			// Pointer to string.
		ULONG		iOffset)				// Offset of string in pool.
	{     return (reinterpret_cast<LPCWSTR>(GetData(iOffset))); }

//*****************************************************************************
// Convert a string to UNICODE into the caller's buffer.
//*****************************************************************************
	virtual HRESULT GetStringW(						// Return code.
		ULONG		iOffset,				// Offset of string in pool.
        LPWSTR      szOut,                  // Output buffer for string.
		int			cchBuffer);				// Size of output buffer.

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
	virtual GUID *GetGuid(					// Pointer to guid in pool.
		ULONG		iIndex);				// 1-based index of Guid in pool.



//*****************************************************************************
// Copy a GUID into the caller's buffer.
//*****************************************************************************
	virtual HRESULT GetGuid(				// Return code.
		ULONG		iIndex,					// 1-based index of Guid in pool.
		GUID		*pGuid)					// Output buffer for Guid.
	{
		*pGuid = *GetGuid(iIndex);
		return (S_OK);
	}


//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
	virtual void *GetBlob(					// Pointer to blob's bytes.
		ULONG		iOffset,				// Offset of blob in pool.
		ULONG		*piSize);				// Return size of blob.


protected:

//*****************************************************************************
// Check whether a given offset is valid in the pool.
//*****************************************************************************
    virtual int IsValidOffset(ULONG ulOffset)
    { return ulOffset == 0 || (m_pSegData && ulOffset < m_cbSegSize); }

//*****************************************************************************
// Get a pointer to an offset within the heap.  Inline for base segment,
//  helper for extension segments.
//*****************************************************************************
	FORCEINLINE BYTE *GetDataReadOnly(ULONG ulOffset)
	{
		_ASSERTE(IsReadOnly());
		_ASSERTE(ulOffset < m_cbSegSize);
		return (m_pSegData+ulOffset); 
	}

//*****************************************************************************
// Get a pointer to an offset within the heap.  Inline for base segment,
//  helper for extension segments.
//*****************************************************************************
	virtual BYTE *GetData(ULONG ulOffset)
	{
		return (GetDataReadOnly(ulOffset));
	}

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
	GUID *GetGuidi(							// Pointer to guid in pool.
		ULONG		iIndex);				// 0-based index of Guid in pool.

	static const BYTE m_zeros[16];			// array of zeros for "0" indices.
};



//
//
// StgPool
//
//

//*****************************************************************************
// This base class provides common pool management code, such as allocation
// of dynamic memory.
//*****************************************************************************
class StgPool : public StgPoolReadOnly
{
friend StgStringPool;
friend StgBlobPool;
friend CBlobPoolHash;

public:
	StgPool(ULONG ulGrowInc=512) :
		m_ulGrowInc(ulGrowInc),
		m_pCurSeg(this),
        m_cbCurSegOffset(0),
		m_bFree(true),
		m_bDirty(false),
		m_bReadOnly(false),
		m_State(eNormal)
	{ }

	virtual ~StgPool();

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
	virtual HRESULT InitNew();				// Return code.

//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
	virtual HRESULT InitOnMem(				// Return code.
		void		*pData,					// Predefined data.
		ULONG		iSize,					// Size of data.
		int			bReadOnly);				// true if append is forbidden.

//*****************************************************************************
// Called when the pool must stop accessing memory passed to InitOnMem().
//*****************************************************************************
	virtual HRESULT TakeOwnershipOfInitMem();

//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
	virtual void Uninit();

//*****************************************************************************
// Allocate memory if we don't have any, or grow what we have.  If successful,
// then at least iRequired bytes will be allocated.
//*****************************************************************************
	bool Grow(								// true if successful.
		ULONG		iRequired);				// Min required bytes to allocate.

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return code.
		ULONG		*pcbSaveSize)			// Return save size of this pool.
	{
		_ASSERTE(pcbSaveSize);
		// Size is offset of last seg + size of last seg.
        ULONG ulSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
		// Align.
		ulSize = ALIGN4BYTE(ulSize);

		*pcbSaveSize = ulSize;
		return (S_OK);
	}

//*****************************************************************************
// Copy the given pool into this pool in the organized format.
//*****************************************************************************
	static HRESULT SaveCopy(				// Return code.
		StgPool		*pTo,					// Copy to this heap.
		StgPool		*pFrom,					// From this heap.
		StgBlobPool	*pBlobPool=0,			// Pool to keep blobs in.
		StgStringPool *pStringPool=0);		// String pool for variant heap.

//*****************************************************************************
// Free the data that was allocated for this heap.  The SaveCopy method
// allocates the data from the mem heap and then gives it to this heap to
// use as read only memory.  We'll ask the heap for that pointer and free it.
//*****************************************************************************
	static void FreeCopy(
		StgPool		*pCopy);				// Heap with copy data.

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
	virtual HRESULT PersistToStream(		// Return code.
		IStream		*pIStream);				// The stream to write to.

//*****************************************************************************
// Return true if this pool is dirty.
//*****************************************************************************
	virtual int IsDirty()					// true if dirty.
	{ return (m_bDirty); }
	void SetDirty(int bDirty=true)
	{ m_bDirty = bDirty; }

//*****************************************************************************
// Indicate if heap is empty.
//*****************************************************************************
	virtual int IsEmpty()					// true if empty.
	{ return (m_pSegData == 0); }

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
	virtual int OffsetSize()
	{
        if (m_pCurSeg->m_cbSegNext + m_cbCurSegOffset < USHRT_MAX)
			return (sizeof(USHORT));
		else
			return (sizeof(ULONG));
	}

//*****************************************************************************
// true if the heap is read only.
//*****************************************************************************
	int IsReadOnly()
	{ return (m_bReadOnly == false); }

//*****************************************************************************
// Is the given cookie a valid offset, index, etc?
//*****************************************************************************
	virtual int IsValidCookie(ULONG ulCookie)
	{ return (IsValidOffset(ulCookie)); }

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
	// Prepare for pool re-organization.
	virtual HRESULT OrganizeBegin();
	// Mark an object as being live in the organized pool.
	virtual HRESULT OrganizeMark(ULONG ulOffset);
	// Organize, based on marked items.
	virtual HRESULT OrganizePool();
	// Remap a cookie from the in-memory state to the persisted state.
	virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
	// Done with regoranization.  Release any state.
	virtual HRESULT OrganizeEnd();

	enum {eNormal, eMarking, eOrganized} m_State;

#if defined(_TRACE_SIZE)
	virtual ULONG PrintSizeInfo(bool verbose) PURE;
#endif


protected:

//*****************************************************************************
// Check whether a given offset is valid in the pool.
//*****************************************************************************
    virtual int IsValidOffset(ULONG ulOffset)
    { return ulOffset == 0 || (m_pSegData && ulOffset < GetNextOffset()); }

//*****************************************************************************
// Get a pointer to an offset within the heap.  Inline for base segment,
//  helper for extension segments.
//*****************************************************************************
	BYTE *GetData(ULONG ulOffset)
	{ return ((ulOffset < m_cbSegNext) ? (m_pSegData+ulOffset) : GetData_i(ulOffset)); }

	// Following virtual because a) this header included outside the project, and
	//  non-virtual function call (in non-expanded inline function!!) generates
	//  an external def, which causes linkage errors.
	virtual BYTE *GetData_i(ULONG ulOffset);

	// Get pointer to next location to which to write.
	BYTE *GetNextLocation()
	{ return (m_pCurSeg->m_pSegData + m_pCurSeg->m_cbSegNext); }

	// Get pool-relative offset of next location to which to write.
	ULONG GetNextOffset()
	{ return (m_cbCurSegOffset + m_pCurSeg->m_cbSegNext); }

	// Get count of bytes available in tail segment of pool.
	ULONG GetCbSegAvailable()
	{ return (m_pCurSeg->m_cbSegSize - m_pCurSeg->m_cbSegNext); }

    // Allocate space from the segment.
	void SegAllocate(ULONG cb)
	{
		_ASSERTE(cb <= GetCbSegAvailable());
		m_pCurSeg->m_cbSegNext += cb;
	}

	ULONG		m_ulGrowInc;				// How many bytes at a time.
	StgPoolSeg	*m_pCurSeg;					// Current seg for append -- end of chain.
    ULONG       m_cbCurSegOffset;           // Base offset of current seg.

	unsigned	m_bFree		: 1;			// True if we should free base data.
											//  Extension data is always freed.
	unsigned	m_bDirty	: 1;			// Dirty bit.
	unsigned	m_bReadOnly	: 1;			// True if we shouldn't append.

};


//
//
// StgStringPool
//
//



//*****************************************************************************
// This string pool class collects user strings into a big consecutive heap.
// Internally it manages this data in a hash table at run time to help throw
// out duplicates.  The list of strings is kept in memory while adding, and
// finally flushed to a stream at the caller's request.
//*****************************************************************************
class StgStringPool : public StgPool
{
public:
	StgStringPool() :
		StgPool(DFT_STRING_HEAP_SIZE),
		m_Hash(this),
		m_bHash(true)
	{	// force some code in debug.
		_ASSERTE(m_bHash);
	}

//*****************************************************************************
// Create a new, empty string pool.
//*****************************************************************************
	HRESULT InitNew();						// Return code.

//*****************************************************************************
// Load a string heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new strings.
//*****************************************************************************
	HRESULT InitOnMem(						// Return code.
		void		*pData,					// Predefined data.
		ULONG		iSize,					// Size of data.
		int			bReadOnly);				// true if append is forbidden.

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
	void Uninit();

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
	HRESULT SetHash(int bHash);

//*****************************************************************************
// The string will be added to the pool.  The offset of the string in the pool
// is returned in *piOffset.  If the string is already in the pool, then the
// offset will be to the existing copy of the string.
// 
// The first version essentially adds a zero-terminated sequence of bytes
//  to the pool.  MBCS pairs will not be converted to the appropriate UTF8
//  sequence.  The second version does perform necessary conversions.
//  The third version converts from Unicode.
//*****************************************************************************

	HRESULT AddStringA(						// Return code.
		LPCSTR		szString,				// The string to add to pool.
		ULONG		*piOffset,				// Return offset of string here.
		int			iLength=-1);			// chars in string; -1 null terminated.

	HRESULT AddStringW(						// Return code.
		LPCWSTR		szString,				// The string to add to pool.
		ULONG		*piOffset,				// Return offset of string here.
		int			iLength=-1,				// chars in string; -1 null terminated.
		bool		bInitEmtpy=false);		// true only if called from InitNew
//*****************************************************************************
// Look for the string and return its offset if found.
//*****************************************************************************
	HRESULT FindString(						// S_OK, S_FALSE.
		LPCSTR		szString,				// The string to find in pool.
		ULONG		*piOffset)				// Return offset of string here.
	{
		STRINGHASH	*pHash;					// Hash item for lookup.
        if ((pHash = m_Hash.Find(szString)) == 0)
			return (S_FALSE);
		*piOffset = pHash->iOffset;
		return (S_OK);
	}


//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
	int Count()
	{ _ASSERTE(m_bHash);
		return (m_Hash.Count()); }

//*****************************************************************************
// String heap is considered empty if the only thing it has is the initial
// empty string, or if after organization, there are no strings.
//*****************************************************************************
	int IsEmpty()						// true if empty.
    { 
		if (m_State == eNormal)
			return (GetNextOffset() <= 1); 
		else
			return (m_cbOrganizedSize == 0);
	}

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
	// Prepare for pool re-organization.
	virtual HRESULT OrganizeBegin();
	// Mark an object as being live in the organized pool.
	virtual HRESULT OrganizeMark(ULONG ulOffset);
	// Organize, based on marked items.
	virtual HRESULT OrganizePool();
	// Remap a cookie from the in-memory state to the persisted state.
	virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
	// Done with regoranization.  Release any state.
	virtual HRESULT OrganizeEnd();

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
	int OffsetSize()
	{
		ULONG		ulOffset;

		// Pick an offset based on whether we've been organized.
		if (m_State == eOrganized)
			ulOffset = m_cbOrganizedOffset;
		else
			ulOffset = GetNextOffset();

        if (ulOffset< USHRT_MAX)
			return (sizeof(USHORT));
		else
			return (sizeof(ULONG));
	}

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return code.
		ULONG		*pcbSaveSize)			// Return save size of this pool.
	{
		ULONG		ulSize;					// The size.
		_ASSERTE(pcbSaveSize);

		if (m_State == eOrganized)
			ulSize = m_cbOrganizedSize;
		else
		{	// Size is offset of last seg + size of last seg.
			ulSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
		}
		// Align.
		ulSize = ALIGN4BYTE(ulSize);

		*pcbSaveSize = ulSize;
		return (S_OK);
	}

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
	virtual HRESULT PersistToStream(		// Return code.
		IStream		*pIStream);				// The stream to write to.

#if defined(_TRACE_SIZE)
	// Prints out information (either verbosely or not, depending on argument) about
	// the contents of this pool.  Returns the total size of this pool.
	virtual ULONG PrintSizeInfo(bool verbose)
	{
		// for the moment, just return size of pool.  In the future, show us the 
		// sizes of indiviudual items in this pool.
		ULONG size;
		StgPool::GetSaveSize(&size);
		PrintSize("String Pool",size);
		return size; 
	}
#endif

private:
	HRESULT RehashStrings();

private:
	CStringPoolHash m_Hash;					// Hash table for lookups.
	int			m_bHash;					// true to keep hash table.
	ULONG		m_cbOrganizedSize;			// Size of the optimized pool.
	ULONG		m_cbOrganizedOffset;		// Highest offset.

    //*************************************************************************
	// Private classes used in optimization.
    //*************************************************************************
	struct StgStringRemap
	{
		ULONG	ulOldOffset;
		ULONG	ulNewOffset;
		ULONG	cbString;
	};

	CDynArray<StgStringRemap> m_Remap;		// For use in reorganization.
	ULONGARRAY	m_RemapIndex;				// For use in reorganization.

	// Sort by reversed strings.
	friend class SortReversedName;
	class BinarySearch : public CBinarySearch<StgStringRemap>
	{
	public:
		BinarySearch(StgStringRemap *pBase, int iCount) : CBinarySearch<StgStringRemap>(pBase, iCount) {}

		int Compare(StgStringRemap const *pFirst, StgStringRemap const *pSecond)
		{
			if (pFirst->ulOldOffset < pSecond->ulOldOffset)
				return -1;
			if (pFirst->ulOldOffset > pSecond->ulOldOffset)
				return 1;
			return 0;
		}
	};
};

class SortReversedName : public CQuickSort<ULONG>
{
public:
	SortReversedName(ULONG *pBase, int iCount, StgStringPool &Pool) 
		:  CQuickSort<ULONG>(pBase, iCount),
		m_Pool(Pool)
	{}
	
	int Compare(ULONG *pUL1, ULONG *pUL2)
	{
		StgStringPool::StgStringRemap *pRM1 = m_Pool.m_Remap.Get(*pUL1);
		StgStringPool::StgStringRemap *pRM2 = m_Pool.m_Remap.Get(*pUL2);
		LPCWSTR p1 = m_Pool.GetString(pRM1->ulOldOffset) + pRM1->cbString/sizeof(WCHAR) - 1;
		LPCWSTR p2 = m_Pool.GetString(pRM2->ulOldOffset) + pRM2->cbString/sizeof(WCHAR) - 1;
		while (*p1 == *p2 && *p1)
			--p1, --p2;
		if (*p1 < *p2)
			return -1;
		if (*p1 > *p2)
			return 1;
		return 0;
	}
	
	StgStringPool	&m_Pool;
};


//
//
// StgGuidPool
//
//



//*****************************************************************************
// This Guid pool class collects user Guids into a big consecutive heap.
// Internally it manages this data in a hash table at run time to help throw
// out duplicates.  The list of Guids is kept in memory while adding, and
// finally flushed to a stream at the caller's request.
//*****************************************************************************
class StgGuidPool : public StgPool
{
public:
	StgGuidPool() :
		StgPool(DFT_GUID_HEAP_SIZE),
		m_Hash(this),
		m_bHash(true)
	{ }

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
    HRESULT InitNew();

//*****************************************************************************
// Load a Guid heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new Guids.
//*****************************************************************************
    HRESULT InitOnMem(                      // Return code.
		void		*pData,					// Predefined data.
		ULONG		iSize,					// Size of data.
        int         bReadOnly);             // true if append is forbidden.

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
	void Uninit();

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
	HRESULT SetHash(int bHash);

//*****************************************************************************
// The Guid will be added to the pool.  The index of the Guid in the pool
// is returned in *piIndex.  If the Guid is already in the pool, then the
// index will be to the existing copy of the Guid.
//*****************************************************************************
	HRESULT AddGuid(						// Return code.
		REFGUID		guid,					// The Guid to add to pool.
		ULONG		*piIndex);				// Return index of Guid here.

#if 0
//*****************************************************************************
// Look for the Guid and return its index if found.
//*****************************************************************************
	HRESULT FindGuid(						// S_OK, S_FALSE.
		REFGUID		guid,					// The Guid to find in pool.
		ULONG		*piIndex)				// Return index of Guid here.
	{
		GUIDHASH	*pHash;					// Hash item for lookup.
		if ((pHash = m_Hash.Find((void *) &guid)) == 0)
			return (S_FALSE);
		*piIndex = pHash->iIndex;
		return (S_OK);
	}
#endif

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
	virtual GUID *GetGuid(					// Pointer to guid in pool.
		ULONG		iIndex);				// 1-based index of Guid in pool.

//*****************************************************************************
// Copy a GUID into the caller's buffer.
//*****************************************************************************
	HRESULT GetGuid(						// Return code.
		ULONG		iIndex,					// 1-based index of Guid in pool.
		GUID		*pGuid)					// Output buffer for Guid.
	{
		*pGuid = *GetGuid(iIndex);
		return (S_OK);
	}

//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
	int Count()
	{ _ASSERTE(m_bHash);
		return (m_Hash.Count()); }

//*****************************************************************************
// Indicate if heap is empty.  This has to be based on the size of the data
// we are keeping.  If you open in r/o mode on memory, there is no hash
// table.  
//*****************************************************************************
	virtual int IsEmpty()					// true if empty.
	{ 
		if (m_State == eNormal)
			return (GetNextOffset() == 0);
		else
			return (m_cbOrganizedSize == 0);
	}

//*****************************************************************************
// Is the index valid for the GUID?
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
	{ return (ulCookie == 0 || IsValidOffset((ulCookie-1) * sizeof(GUID))); }

//*****************************************************************************
// Return the size of the heap.
//*****************************************************************************
    ULONG GetNextIndex()
    { return (GetNextOffset() / sizeof(GUID)); }

//*****************************************************************************
// How big is an offset in this heap.
//*****************************************************************************
	int OffsetSize()
	{
		ULONG cbSaveSize;
		GetSaveSize(&cbSaveSize);
        ULONG iIndex = cbSaveSize / sizeof(GUID);
		if (iIndex < 0xffff)
			return (sizeof(short));
		else
			return (sizeof(long));
	}

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
	// Prepare for pool re-organization.
	virtual HRESULT OrganizeBegin();
	// Mark an object as being live in the organized pool.
	virtual HRESULT OrganizeMark(ULONG ulOffset);
	// Organize, based on marked items.
	virtual HRESULT OrganizePool();
	// Remap a cookie from the in-memory state to the persisted state.
	virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
	// Done with regoranization.  Release any state.
	virtual HRESULT OrganizeEnd();

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return code.
		ULONG		*pcbSaveSize)			// Return save size of this pool.
	{
		ULONG		ulSize;					// The size.

		_ASSERTE(pcbSaveSize);

		if (m_State == eNormal)
			// Size is offset of last seg + size of last seg.
		    ulSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
		else
			ulSize = m_cbOrganizedSize;

		// Should be aligned.
		_ASSERTE(ulSize == ALIGN4BYTE(ulSize));

		*pcbSaveSize = ulSize;
		return (S_OK);
	}

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
	virtual HRESULT PersistToStream(		// Return code.
		IStream		*pIStream);				// The stream to write to.

#if defined(_TRACE_SIZE)
	// Prints out information (either verbosely or not, depending on argument) about
	// the contents of this pool.  Returns the total size of this pool.
	virtual ULONG PrintSizeInfo(bool verbose) 
	{ 
		// for the moment, just return size of pool.  In the future, show us the 
		// sizes of indiviudual items in this pool.
		ULONG size;
		StgPool::GetSaveSize(&size);
		PrintSize("Guid Pool",size);
		return size; 
	}
#endif


private:

	HRESULT RehashGuids();


private:
	ULONGARRAY	m_Remap;					// For remaps.
	ULONG		m_cbOrganizedSize;			// Size after organization.
	CGuidPoolHash m_Hash;					// Hash table for lookups.
	int			m_bHash;					// true to keep hash table.
};



//
//
// StgBlobPool
//
//


//*****************************************************************************
// Just like the string pool, this pool manages a list of items, throws out
// duplicates using a hash table, and can be persisted to a stream.  The only
// difference is that instead of saving null terminated strings, this code
// manages binary values of up to 64K in size.  Any data you have larger than
// this should be stored someplace else with a pointer in the record to the
// external source.
//*****************************************************************************
class StgBlobPool : public StgPool
{
public:
	StgBlobPool(ULONG ulGrowInc=DFT_BLOB_HEAP_SIZE) :
        StgPool(ulGrowInc),
        m_Hash(this),
		m_bAlign(false)
	{ }

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
	HRESULT InitNew();						// Return code.

//*****************************************************************************
// Init the blob pool for use.  This is called for both create and read case.
// If there is existing data and bCopyData is true, then the data is rehashed
// to eliminate dupes in future adds.
//*****************************************************************************
    HRESULT InitOnMem(                      // Return code.
		void		*pData,					// Predefined data.
		ULONG		iSize,					// Size of data.
        int         bReadOnly);             // true if append is forbidden.

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
	void Uninit();

//*****************************************************************************
// The blob will be added to the pool.  The offset of the blob in the pool
// is returned in *piOffset.  If the blob is already in the pool, then the
// offset will be to the existing copy of the blob.
//*****************************************************************************
	HRESULT AddBlob(						// Return code.
		ULONG		iSize,					// Size of data item.
		const void	*pData,					// The data.
		ULONG		*piOffset);				// Return offset of blob here.

//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
	virtual void *GetBlob(					// Pointer to blob's bytes.
		ULONG		iOffset,				// Offset of blob in pool.
		ULONG		*piSize);				// Return size of blob.

//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
	int Count()
	{ return (m_Hash.Count()); }

//*****************************************************************************
// String heap is considered empty if the only thing it has is the initial
// empty string, or if after organization, there are no strings.
//*****************************************************************************
	virtual int IsEmpty()					// true if empty.
    { 
		if (m_State == eNormal)
			return (GetNextOffset() <= 1); 
		else
			return (m_Remap.Count() == 0);
	}

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
	// Prepare for pool re-organization.
	virtual HRESULT OrganizeBegin();
	// Mark an object as being live in the organized pool.
	virtual HRESULT OrganizeMark(ULONG ulOffset);
	// Organize, based on marked items.
	virtual HRESULT OrganizePool();
	// Remap a cookie from the in-memory state to the persisted state.
	virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
	// Done with regoranization.  Release any state.
	virtual HRESULT OrganizeEnd();

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
	int OffsetSize()
	{
		ULONG		ulOffset;

		// Pick an offset based on whether we've been organized.
		if (m_State == eOrganized)
			ulOffset = m_cbOrganizedOffset;
		else
			ulOffset = GetNextOffset();

        if (ulOffset< USHRT_MAX)
			return (sizeof(USHORT));
		else
			return (sizeof(ULONG));
	}

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
	virtual HRESULT GetSaveSize(			// Return code.
		ULONG		*pcbSaveSize)			// Return save size of this pool.
	{
		_ASSERTE(pcbSaveSize);

		if (m_State == eOrganized)
		{
			*pcbSaveSize = m_cbOrganizedSize;
			return (S_OK);
		}

		return (StgPool::GetSaveSize(pcbSaveSize));
	}

//*****************************************************************************
// The entire blob pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
	virtual HRESULT PersistToStream(		// Return code.
		IStream		*pIStream);				// The stream to write to.

    //*************************************************************************
	// Private classes used in optimization.
    //*************************************************************************
	struct StgBlobRemap
	{
		ULONG	ulOldOffset;
		int		iNewOffset;
	};
	class BinarySearch : public CBinarySearch<StgBlobRemap>
	{
	public:
		BinarySearch(StgBlobRemap *pBase, int iCount) : CBinarySearch<StgBlobRemap>(pBase, iCount) {}

		int Compare(StgBlobRemap const *pFirst, StgBlobRemap const *pSecond)
		{
			if (pFirst->ulOldOffset < pSecond->ulOldOffset)
				return -1;
			if (pFirst->ulOldOffset > pSecond->ulOldOffset)
				return 1;
			return 0;
		}
	};

	const void *GetBuffer() {return (m_pSegData);}

	int IsAligned() { return (m_bAlign); };
	void SetAligned(int bAlign) { m_bAlign = bAlign; };

#if defined(_TRACE_SIZE)
	// Prints out information (either verbosely or not, depending on argument) about
	// the contents of this pool.  Returns the total size of this pool.
	virtual ULONG PrintSizeInfo(bool verbose)
	{ 
		// for the moment, just return size of pool.  In the future, show us the 
		// sizes of indiviudual items in this pool.
		ULONG size;
		StgPool::GetSaveSize(&size);
		PrintSize("Blob Pool",size);
		return size; 
	}
#endif


private:
	CBlobPoolHash m_Hash;					// Hash table for lookups.
	CDynArray<StgBlobRemap> m_Remap;		// For use in reorganization.
	ULONG		m_cbOrganizedSize;			// Size of the optimized pool.
	ULONG		m_cbOrganizedOffset;		// Highest offset.
	unsigned	m_bAlign : 1;				// if blob data should be aligned on DWORDs
};



//
//
// StgVariantPool
//
//

//*****************************************************************************
// This pool is for storing variants.  The storage is optimized to store
// short, long, and string data types.  Other types may be persisted but
// require more overhead.  The pool must have a pointer to a string and blob
// pool which it uses to store the actual string data and the binary data for
// types which aren't specialized.  A detailed desription of this subsystem
// can be found in EngineNotes.doc.
//*****************************************************************************
class StgVariantPool : public StgPool
{
public:
	StgVariantPool() :
		StgPool(DFT_VARIANT_HEAP_SIZE)
	{
		ClearVars();
	}

	void ClearVars()
	{
		m_rVariants.Clear();
		m_Remap.Clear();
		m_pIStream = 0;
		m_cOrganizedVariants = 0;
		m_cbOrganizedSize = 0;
	}


//*****************************************************************************
// Init the variant pool for usage.  This is called for both the create and
// open existing case.
//*****************************************************************************
	HRESULT InitNew(						// Return code.
		StgBlobPool	*pBlobPool,				// Pool to keep blobs in.
		StgStringPool *pStringPool);		// Pool to keep strings in.

//*****************************************************************************
// Init the variant pool for usage.  This is called for both the create and
// open existing case.
//*****************************************************************************
	HRESULT InitOnMem(						// Return code.
		StgBlobPool	*pBlobPool,				// Pool to keep blobs in.
		StgStringPool *pStringPool,			// Pool to keep strings in.
		void		*pData,					// Predefined data.
		ULONG		iSize,					// Size of data.
		int			bReadOnly);				// true if update is forbidden.

//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
	void Uninit();

//*****************************************************************************
// Indicate if heap is empty.
//*****************************************************************************
	virtual int IsEmpty()					// true if empty.
	{ 	
		if (m_State == eOrganized)
			return (m_cOrganizedVariants == 0); 
		else
			return (m_rVariants.Count() == 0);
	}

//*****************************************************************************
// Check whether a given index is valid in the pool.
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
    { return (ulCookie <= static_cast<ULONG>(m_rVariants.Count())) ;}

//*****************************************************************************
// Add the given variant to the pool.  The index returned is good only for
// the duration of the load.  It must be converted into a final index when you
// persist the information to disk.
//*****************************************************************************
	HRESULT AddVariant(						// Return code.
		VARIANT		*pVal,					// The value to store.
		ULONG		*piIndex);				// The index of the new item.
	HRESULT AddVariant(						// Return code.
		ULONG		iSize,					// Size of data item.
		const void	*pData,					// The data.
		ULONG		*piIndex);				// The index of the new item.

//*****************************************************************************
// Lookup the logical variant and return a copy to the caller.
//*****************************************************************************
	HRESULT GetVariant(						// Return code.
		ULONG		iIndex,					// Index of the item to get.
		VARIANT		*pVal);					// Put variant here.
	HRESULT GetVariant(						// Return code.
		ULONG		iIndex,					// Index of the item to get.
		ULONG		*pcbBlob,				// Return size of blob.
		const void	**ppBlob);				// Put blob pointer here.
	HRESULT GetVariantType(					// Return code.
		ULONG		iIndex,					// Index of the item to get.
		VARTYPE		*pVt);					// Put variant type here.

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
	// Prepare for pool re-organization.
	virtual HRESULT OrganizeBegin();
	// Mark an object as being live in the organized pool.
	virtual HRESULT OrganizeMark(ULONG ulOffset);
	// Organize, based on marked items.
	virtual HRESULT OrganizePool();
	// Remap a cookie from the in-memory state to the persisted state.
	virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
	// Done with regoranization.  Release any state.
	virtual HRESULT OrganizeEnd();

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
	HRESULT GetSaveSize(					// Return code.
		ULONG		*pcbSaveSize);			// Return save size of this pool.

//*****************************************************************************
// Save the pool data into the given stream.
//*****************************************************************************
	HRESULT PersistToStream(				// Return code.
		IStream		*pIStream);				// The stream to write to.

//*****************************************************************************
// Return the size of the current variable sized data.
//*****************************************************************************
	HRESULT GetOtherSize(					// Return code.
		ULONG		*pulSize);				// Put size of the stream here.

//*****************************************************************************
// Return the maximum offset for next item.  To be used to determine offset
// sizes for heap.
//*****************************************************************************
	int OffsetSize()
	{
		_ASSERTE(m_State == eOrganized);
		if (m_cOrganizedVariants < USHRT_MAX)
			return (sizeof(short));
		else
			return (sizeof(long));
	}

#if defined(_TRACE_SIZE)
	// Prints out information (either verbosely or not, depending on argument) about
	// the contents of this pool.  Returns the total size of this pool.
	virtual ULONG PrintSizeInfo(bool verbose) 
	{ 
		// for the moment, just return size of pool.  In the future, show us the 
		// sizes of indiviudual items in this pool.
		ULONG size;
		StgPool::GetSaveSize(&size);
		PrintSize("Variant Pool",size);
		return size; 
	}
#endif

	ULONG GetBlobIndex(						// Return blob pool index.
		ULONG		ix);					// 1-based Variant index.

private:
	HRESULT AddVarianti(					// Return code.
		VARIANT		*pVal,					// The value to store, if variant.
		ULONG		cbBlob,				    // The size to store, if blob.
		const void	*pBlob,					// Pointer to data, if blob.
		ULONG		*piIndex);				// The index of the new item.

	struct StgVariant;
	HRESULT GetValue(						// Get the value directly or from the stream.
		StgVariant	*pStgVariant,			// The internal form of variant.
		void		*pRead,					// Where to put the value.
		ULONG		cbRead);				// Bytes to read for value.
		
	HRESULT GetEntrysStreamSize(			// Get the size for the streamed part of this item.
		StgVariant	*pStgVariant,			// The internal form of variant.
		ULONG		*pSize);				// Put size here.
		

	// Internal clases.
	struct StgVariant
	{
		unsigned	m_vt : 7;				// The var type.
		unsigned	m_bDirect : 1;			// Is value stored directly?
		unsigned	m_iSign : 1;			// S