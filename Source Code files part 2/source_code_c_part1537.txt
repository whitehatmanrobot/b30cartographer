 != lRead)
        return -1;

    return lRead;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#define INDEX_WRITE_SIZE    32l*1024
#define INDEX_READ_SIZE     32l*1024

static BOOL WriteOutIndex(CAVIFile FAR *pfile, DWORD dwOffsetMovie)
{
    MMCKINFO ck;
    PAVIINDEXENTRY pIndex;
    LONG cnt = INDEX_WRITE_SIZE / sizeof(*pIndex);
    LONG l;
    BOOL f=FALSE;
#ifdef DEBUG
    DWORD time;
#endif

    /*
    ** Now write index out!
    */
    ck.ckid = ckidAVINEWINDEX;
    ck.cksize = sizeof(AVIINDEXENTRY) * pfile->px->nIndex;
    
    if (shfileCreateChunk(pfile->hshfile, &ck, 0))
        goto exit;

    DPF("Writing Index", time=timeGetTime());

    pIndex = (PAVIINDEXENTRY)GlobalAllocPtr(GHND,INDEX_WRITE_SIZE);

    if (pIndex == NULL)
        goto exit;

    for (l=0; l < pfile->px->nIndex; ) {

        cnt = IndexGetFileIndex(pfile->px, l, cnt, pIndex, -(LONG)dwOffsetMovie);

        if (cnt == 0)
            break;

        if (shfileWrite(pfile->hshfile, (HPSTR)pIndex,
             cnt * sizeof(AVIINDEXENTRY)) != cnt * sizeof(AVIINDEXENTRY))
             goto exit;

        l += cnt;

        DPF("!.");
    }

    DPF("!Done (%ldms)\n", timeGetTime()-time);

    if (shfileAscend(pfile->hshfile, &ck, 0))
        goto exit;

    f = TRUE;

exit:
    if (pIndex)
        GlobalFreePtr(pIndex);
    
    return f;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static BOOL ReadInIndex(CAVIFile FAR *pfile, DWORD size, DWORD dwOffsetMovie, BOOL fRle)
{
    PAVIINDEXENTRY pIndex;
    LONG cnt;
    LONG lIndexAdjust;
    BOOL f = FALSE;
#ifdef DEBUG
    DWORD time;
#endif

    pIndex = (PAVIINDEXENTRY)GlobalAllocPtr(GHND,INDEX_READ_SIZE);

    if (pIndex == NULL)
        goto exit;

    pfile->px = IndexCreate();

    if (pfile->px == 0)
        goto exit;

    DPF("Reading index.", time = timeGetTime());

    if (pfile->avihdr.dwFlags & AVIF_MUSTUSEINDEX)
        lIndexAdjust = dwOffsetMovie;
    else
        lIndexAdjust = -1;      // set when we read first index entry.

    while (size > 0) {

        cnt = min(INDEX_READ_SIZE, size);

        if (shfileRead(pfile->hshfile,(HPSTR)pIndex,cnt) != cnt)
            goto exit;

        size -= cnt;
        cnt /= sizeof(AVIINDEXENTRY);

        //
        // fix up the index
        //
        if (lIndexAdjust == -1) {
            lIndexAdjust = (LONG)(dwOffsetMovie + sizeof(DWORD)) -
                (LONG)pIndex->dwChunkOffset;
        }

        pfile->px = IndexAddFileIndex(pfile->px, pIndex, cnt, lIndexAdjust, fRle);

        if (pfile->px == NULL)
            goto exit;

        DPF("!.");
    }

    DPF("!Done (%ldms)\n", timeGetTime() - time);

    f = TRUE;

exit:
    if (pIndex)
        GlobalFreePtr(pIndex);

    return f;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT SaveChanges(CAVIFile FAR * pfile, BOOL fRelease)
{
    CAVIStream FAR *            pavi;
    int                         stream;
    MMCKINFO                    ck;
    MMCKINFO                    ckRIFF;
    MMCKINFO                    ckLIST;
    MMCKINFO                    ckStream;
    LONG                        lCur;
    HRESULT                     hr = AVIERR_OK;
    AVIStreamHeader             strhdr;

    // Clean up interleaving
    if (pfile->fInRecord) {
        if (pfile->px->nIndex > pfile->lRecordIndex + 1) {
	    AVIFileEndRecord((PAVIFILE) pfile);
	}

	// back out of last record....
        --pfile->px->nIndex;
	pfile->lWriteLoc -= 3 * sizeof(DWORD);
	shfileSeek(pfile->hshfile, pfile->lWriteLoc, SEEK_SET);
	pfile->fInRecord = FALSE;
    }
    
    // Go back and write out the header

    lCur = shfileSeek(pfile->hshfile, 0, SEEK_CUR);
    shfileSeek(pfile->hshfile, 0, SEEK_SET);

    /* Create RIFF chunk */
    ckRIFF.cksize = 0;
    ckRIFF.fccType = formtypeAVI;
    if (shfileCreateChunk(pfile->hshfile, &ckRIFF, MMIO_CREATERIFF)) {
	goto FileError;
    }

    /* Create header list */
    ckLIST.cksize = 0;
    ckLIST.fccType = listtypeAVIHEADER;
    if (shfileCreateChunk(pfile->hshfile, &ckLIST, MMIO_CREATELIST)) {
	goto FileError;
    }

    /* Create AVI header chunk */
    ck.cksize = sizeof(pfile->avihdr);
    ck.ckid = ckidAVIMAINHDR;
    if (shfileCreateChunk(pfile->hshfile, &ck, 0)) {
	goto FileError;
    }

    CalculateFileDataRate(&pfile->m_AVIFile, (LONG FAR *) &pfile->avihdr.dwMaxBytesPerSec);
    
    /* Write AVI header info */
    if (shfileWrite(pfile->hshfile,
		  (LPSTR)&pfile->avihdr,
		  sizeof(pfile->avihdr)) != sizeof(pfile->avihdr)) {
	goto FileError;
    }

    if (shfileAscend(pfile->hshfile, &ck, 0)) {
	goto FileError;
    }


#if 0
    for (l = 0;
	 l < muldiv32(pfile->avihdr.dwTotalFrames,
			     pfile->avihdr.dwMicroSecPerFrame,
			     1000000L);
         l++) {

	     for (stream = 0; stream < (int) pfile->avihdr.dwStreams; stream++) {
             }
    }
#endif
    
    for (stream = 0; stream < (int) pfile->avihdr.dwStreams; stream++) {
	pavi = pfile->ps[stream];
	
	/* Create stream header list */
	ckStream.cksize = 0;
	ckStream.fccType = listtypeSTREAMHEADER;
	if (shfileCreateChunk(pfile->hshfile,&ckStream,MMIO_CREATELIST)) {
	    goto FileError;
	}

	ck.ckid = ckidSTREAMHEADER;
	if (shfileCreateChunk(pfile->hshfile, &ck, 0)) {
	    goto FileError;
	}


	// !!! Make an AVIStreamHeader from the AVISTREAMINFO
	strhdr.fccType =                pavi->avistream.fccType;
	strhdr.fccHandler =             pavi->avistream.fccHandler;
	strhdr.dwFlags =                pavi->avistream.dwFlags;
	strhdr.wPriority =              pavi->avistream.wPriority;
	strhdr.wLanguage =              pavi->avistream.wLanguage;
	strhdr.dwRate =                 pavi->avistream.dwRate;
	strhdr.dwScale =                pavi->avistream.dwScale;
	strhdr.dwStart =                pavi->avistream.dwStart;
	strhdr.dwLength =               pavi->avistream.dwLength;
	strhdr.dwSuggestedBufferSize =  pavi->avistream.dwSuggestedBufferSize;
	strhdr.dwQuality =              pavi->avistream.dwQuality;
	strhdr.dwSampleSize =           pavi->avistream.dwSampleSize;
	strhdr.rcFrame =                pavi->avistream.rcFrame;
	strhdr.dwInitialFrames =        pavi->avistream.dwInitialFrames;
	
	if (shfileWrite(pfile->hshfile, (HPSTR) &strhdr, sizeof(strhdr)) !=
							    sizeof(strhdr)) {
	    goto FileError;
	}

	if (shfileAscend(pfile->hshfile, &ck, 0)) {
	    goto FileError;
	}


	ck.cksize = pavi->cbFormat;
	ck.ckid = ckidSTREAMFORMAT;
	
	if (shfileCreateChunk(pfile->hshfile, &ck, 0))
	    goto FileError;

	if (shfileWrite(pfile->hshfile, (HPSTR) pavi->lpFormat, ck.cksize) !=
			(LONG) ck.cksize)
	    goto FileError;

	if (shfileAscend(pfile->hshfile, &ck, 0))
	    goto FileError;

	if (pavi->avistream.szName[0]) {
	    ck.cksize = lstrlen(pavi->avistream.szName) + 1;
	    ck.ckid = ckidSTREAMNAME;

	    if (shfileCreateChunk(pfile->hshfile, &ck, 0))
		goto FileError;

	    if (shfileWrite(pfile->hshfile, (HPSTR) pavi->avistream.szName, ck.cksize) !=
			    (LONG) ck.cksize)
		goto FileError;

	    if (shfileAscend(pfile->hshfile, &ck, 0))
		goto FileError;
	}
	
	if (pavi->extra.cb) {
	    DPF2("Writing %ld bytes of extra stream data.\n", pavi->extra.cb);
	    if (shfileWrite(pfile->hshfile, (HPSTR) pavi->extra.lp, pavi->extra.cb) !=
			(LONG) pavi->extra.cb)
		goto FileError;
	}

	/* Ascend out of stream's header */
	if (shfileAscend(pfile->hshfile, &ckStream, 0)) {
	    goto FileError;
	}
    }

    /* ascend from the Header list */
    if (shfileAscend(pfile->hshfile, &ckLIST, 0)) {
	goto FileError;
    }

    /* Pad this header out so that the real data will start on a 2K 
    ** boundary by writing a JUNK chunk.
    */
    ck.ckid = ckidAVIPADDING;
    if (shfileCreateChunk(pfile->hshfile,&ck,0)) {
	goto FileError;
    }

    DPF("Data list start = %ld, current pos = %ld\n", pfile->lDataListStart, shfileSeek(pfile->hshfile, 0, SEEK_CUR));
      
    if (shfileSeek(pfile->hshfile, 0, SEEK_CUR) > pfile->lDataListStart) {
	// !!! Ack: we didn't leave enough space for the header.
	// !!! How can we avoid this?
	goto FileError;
    }
    
    shfileSeek(pfile->hshfile, pfile->lDataListStart, SEEK_SET);

    if (shfileAscend(pfile->hshfile, &ck, 0)) {
	goto FileError;
    }

    /* Start the 'movi' list, where all of the actual data will be. */
    ckLIST.cksize = 0;
    ckLIST.fccType = listtypeAVIMOVIE;
    if (shfileCreateChunk(pfile->hshfile, &ckLIST, MMIO_CREATELIST)) {
	goto FileError;
    }

    shfileSeek(pfile->hshfile, pfile->lWriteLoc, SEEK_SET);

    if (shfileAscend(pfile->hshfile, &ckLIST, 0))
        goto FileError;

    if (!WriteOutIndex(pfile, ckLIST.dwDataOffset))
        goto FileError;

    //
    // Write out any extra data around
    //
    if (pfile->extra.cb) {
	DPF2("Writing %ld bytes of extra file data.\n", pfile->extra.cb);
	
	if (shfileWrite(pfile->hshfile,
		      (HPSTR) pfile->extra.lp,
		      pfile->extra.cb) !=
		 (LONG) pfile->extra.cb)
	    goto FileError;
    }

FinishUp:
    if (shfileAscend(pfile->hshfile, &ckRIFF, 0))
	goto FileError;

    //
    // Always flush to be sure that the data really made it to the disk....
    //
    if (shfileFlush(pfile->hshfile, 0))
	goto FileError;
    
    return ResultFromScode(AVIERR_OK);

FileError:
    hr = ResultFromScode(AVIERR_FILEWRITE);
    goto FinishUp;
}    

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CAVIFile::CUnknownImpl::Release()
{
    CAVIFile FAR * pfile = m_pAVIFile;
    CAVIStream FAR * pavi;
    int iStream;

    DPF2("File   %lx: Usage--=%lx\n", (DWORD) (LPVOID) this, m_refs - 1);
    
    uUseCount--;
    if (!--m_refs) {
	if (pfile->fDirty) {
	    ++m_refs;
            SaveChanges(pfile, TRUE);
	    --m_refs;

	    // Unfortunately, it's too late to tell about any errors....
	}

	for (iStream = 0; iStream < (int)pfile->avihdr.dwStreams; iStream++) {
	    pavi = pfile->ps[iStream];

	    if (!pavi)
		continue;
	    
	    if (pavi->lpFormat)
		GlobalFreePtr(pavi->lpFormat);

	    if (pavi->lpData)
		GlobalFreePtr(pavi->lpData);

	    if (pavi->extra.lp) {
		DPF2("Freeing %ld bytes of extra stream data.\n", pavi->extra.cb);
		GlobalFreePtr(pavi->extra.lp);
	    }

	    if (pavi->paviBase)
		AVIStreamClose(pavi->paviBase);

	    delete pavi;
	}

	if (pfile->hshfile) {
	    shfileRelease(pfile->hshfile);
	    shfileClose(pfile->hshfile, 0);
	}

        if (pfile->px)
            FreeIndex(pfile->px);

	if (pfile->extra.lp) {
	    DPF2("Freeing %ld bytes of extra file data.\n", pfile->extra.cb);
	    GlobalFreePtr(pfile->extra.lp);
	}

	if (pfile->pb)
	    EndBuffered(pfile->pb);

	pfile->hshfile = NULL;

        pfile->px = NULL;
	delete pfile;
	return 0;
    } else {
	if (pfile->hshfile)
	    shfileRelease(pfile->hshfile);
    }
    
    return m_refs;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Save(
				   LPCSTR szFile,
				   AVICOMPRESSOPTIONS FAR *lpOptions,
				   AVISAVECALLBACK lpfnCallback)
{
    CAVIFile FAR * pfile = m_pAVIFile;
    HRESULT hr = ResultFromScode(AVIERR_OK);

    if (pfile->fDirty) {
        hr = SaveChanges(pfile, FALSE);
    }
    
    return hr;
}

#define SLASH(c)     ((c) == '/' || (c) == '\\')

/*--------------------------------------------------------------+
| FileName  - return a pointer to the filename part of szPath   |
|             with no preceding path.                           |
+--------------------------------------------------------------*/
LPSTR FAR FileName(LPCSTR lszPath)
{
    LPCSTR   lszCur;

    for (lszCur = lszPath + lstrlen(lszPath); lszCur > lszPath && !SLASH(*lszCur) && *lszCur != ':';)
	lszCur = AnsiPrev(lszPath, lszCur);
    if (lszCur == lszPath)
	return (LPSTR)lszCur;
    else
	return (LPSTR)(lszCur + 1);
}

BOOL IsRectBogus(LPRECT lprc, DWORD dwFrameWidth, DWORD dwFrameHeight,
		 LPBITMAPINFOHEADER lpbi)
{
    if (IsRectEmpty(lprc))
	return TRUE;

    if (lprc->right - lprc->left > (int) dwFrameWidth)
	return TRUE;

    if (lprc->bottom - lprc->top > (int) dwFrameHeight)
	return TRUE;

    // !!!! Check that rectangle matches lpbi?

    // We've run out of things to check, so it's OK....
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Open(LPCSTR szFile, UINT mode)
{
    CAVIFile FAR * pfile = m_pAVIFile;
    CAVIStream FAR *        pavi;
    MMCKINFO        ck;
    MMCKINFO        ckRIFF;
    MMCKINFO        ckLIST;
    MMCKINFO        ckStream;
    DWORD           dwSize;
    BOOL            fRle=FALSE;
    LONG            l;
    int             iStream;
    int             i;
    HRESULT         hr = ResultFromScode(AVIERR_OK);
    IUnknown FAR *  pUnk;
    UINT            ui;
    AVIStreamHeader strhdr;
    char            ach[20];
    char            ach2[20];
    int             iStreamNumber;
#ifdef DEBUG
    DWORD time;
#endif

    if (pfile->achFile[0])
	return ResultFromScode(-1);

    pfile->mode = mode;
    _fstrcpy(pfile->achFile, szFile);

    // Assumptions about avilib.cpp:
    // We're assuming that if CREATE is set, WRITE is set too.
    // We're assuming that we'll always see READWRITE instead of just WRITE.

    // force the share flags to the 'correct' values
    if (mode & OF_READWRITE) {
	pfile->mode = (mode & ~(MMIO_SHAREMODE)) | OF_SHARE_EXCLUSIVE;
    } else {
	pfile->mode = (mode & ~(MMIO_SHAREMODE)) | OF_SHARE_DENY_WRITE;
    }

    // try to open the actual file
    // If the first attempt fails, no system error box, please.
    ui = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    
    pfile->hshfile = shfileOpen(pfile->achFile, NULL, pfile->mode);

    if (!pfile->hshfile && ((mode & MMIO_RWMODE) == OF_READ)) {
	// if the open fails, try again without the share flags.
	pfile->mode &= ~(MMIO_SHAREMODE);
	
	pfile->hshfile = shfileOpen(pfile->achFile, NULL, pfile->mode);
    }
    SetErrorMode(ui);
    
    if (!pfile->hshfile) {
	hr = ResultFromScode(AVIERR_FILEOPEN);
	goto error;
    }

    if (mode & OF_CREATE) {
        // make a empty index.
        pfile->px = IndexCreate();

	if (pfile->px == 0)
	    goto memerror;
	    
	pfile->lWriteLoc = 0;
	pfile->lHeaderSize = sizeof(MainAVIHeader) + 11 * sizeof(DWORD); 
	pfile->avihdr.dwFlags = AVIF_HASINDEX;
    } else {

	/* Read RIFF chunk */
	if (shfileDescend(pfile->hshfile, &ckRIFF, NULL, 0) != 0)
	    goto readerror;

	/*
	 * check for a 'QuickTime AVI' file, a QuickTime AVI file is a
	 * QuickTime public movie with a AVI file in the 'mdat' atom.
	 */
	if (ckRIFF.cksize == mmioFOURCC('m','d','a','t'))
	{
	    /*
	     * now the 'mdat' atom better be a RIFF/AVI or we cant handle it.
	     */
	    if (shfileDescend(pfile->hshfile, &ckRIFF, NULL, 0) != 0)
		goto formaterror;
	}

	if (ckRIFF.ckid != FOURCC_RIFF)
	    goto formaterror;

	if (ckRIFF.fccType != formtypeAVI)
	    goto formaterror;

	/* Read header list */
	ckLIST.fccType = listtypeAVIHEADER;
	if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ckLIST, &ckRIFF, MMIO_FINDLIST))
	    goto error;

	pfile->lHeaderSize = ckLIST.cksize + 8 * sizeof(DWORD);

	/* Read AVI header chunk */
	ck.ckid = ckidAVIMAINHDR;
	if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckLIST, MMIO_FINDCHUNK))
	    goto error;

	dwSize = min(ck.cksize, sizeof(MainAVIHeader));

	/* Read AVI header info */
	if (shfileRead(pfile->hshfile, (HPSTR)&pfile->avihdr, dwSize) != (LONG)dwSize)
	    goto readerror;

	if (shfileAscend(pfile->hshfile, &ck, 0))
	    goto readerror;

	for (iStream = 0; iStream < (int)pfile->avihdr.dwStreams; iStream++) {
	    pfile->ps[iStream] = NULL;
	}
	
	/* Allocate stream data stuff, read streams */
	for (iStream = 0; iStream < (int)pfile->avihdr.dwStreams; ) {

	    if (shfileDescend(pfile->hshfile, &ckStream, &ckLIST, 0) != 0)
		goto readerror;

	    //
	    //  found a non-stream header skip
	    //
	    if (ckStream.fccType != listtypeSTREAMHEADER ||
		    ckStream.ckid != FOURCC_LIST) {
		if ((hr = ReadIntoExtra(&pfile->extra,
				  pfile->hshfile,
				  &ckStream)) != ResultFromScode(AVIERR_OK))
		    goto error;
		
		if (shfileAscend(pfile->hshfile, &ckStream, 0) != 0)
		    goto readerror;

		continue;
	    }

	    pfile->ps[iStream] = new FAR CAVIStream(NULL, &pUnk);
	    if (!pfile->ps[iStream])
		goto memerror;

	    pavi = pfile->ps[iStream];
	    pavi->pfile = pfile;
	    pavi->iStream = iStream;

	    //
	    //  walk every chunk in this stream header, until we are done.
	    //
	    while (shfileDescend(pfile->hshfile, &ck, &ckStream, 0) == 0) {
		switch (ck.ckid) {
                    case ckidSTREAMHEADER:
                        //
                        // set these to sane default's incase the file
                        // header is not big enough
                        //
                        // NOTE the stream rectangle is set to NULL, if
                        // this is a video stream it will be corrected
                        // when we proccess the format.
                        //
                        strhdr.dwQuality = (DWORD) ICQUALITY_DEFAULT;
                        SetRectEmpty(&strhdr.rcFrame);

			l = min(ck.cksize, sizeof(AVIStreamHeader));

			if (shfileRead(pfile->hshfile, (HPSTR)&strhdr, l) != l)
			    goto readerror;

			// !!! Copy fields from strhdr into
			pavi->avistream.fccType =       strhdr.fccType;
			pavi->avistream.fccHandler =    strhdr.fccHandler;
			pavi->avistream.dwFlags =       strhdr.dwFlags; //!!!
			pavi->avistream.dwCaps =        0; // !!!
			pavi->avistream.wPriority =	strhdr.wPriority;
			pavi->avistream.wLanguage =	strhdr.wLanguage;
			pavi->avistream.dwRate =        strhdr.dwRate;
			pavi->avistream.dwScale =       strhdr.dwScale;
			pavi->avistream.dwStart =       strhdr.dwStart;
			pavi->avistream.dwLength =      strhdr.dwLength;
			pavi->avistream.dwSuggestedBufferSize = strhdr.dwSuggestedBufferSize;
			pavi->avistream.dwInitialFrames = strhdr.dwInitialFrames;
			pavi->avistream.dwQuality =     strhdr.dwQuality;
			pavi->avistream.dwSampleSize =  strhdr.dwSampleSize;
			pavi->avistream.rcFrame =       strhdr.rcFrame;
			pavi->avistream.dwEditCount =   0;
			pavi->avistream.dwFormatChangeCount =   0;

			// Make up a stream name out of the filename, stream
			// type, and stream number.
			if (pavi->avistream.fccType == streamtypeVIDEO)
			    LoadString(ghMod, IDS_VIDEO, ach, sizeof(ach));
			else if (pavi->avistream.fccType == streamtypeAUDIO)
			    LoadString(ghMod, IDS_AUDIO, ach, sizeof(ach));
			else
			    wsprintf(ach, "'%4.4s'",
				(LPSTR)&(pavi->avistream.fccType));

			// figure out what # stream of this type this is....
			iStreamNumber = 1;
			for (i = 0; i < iStream; i++) {
			    if (pfile->ps[i]->avistream.fccType ==
					pavi->avistream.fccType)
				++iStreamNumber;
			}
			LoadString(ghMod, IDS_SSSTREAMD, ach2, sizeof(ach2));
			wsprintf(pavi->avistream.szName,
			    (LPSTR)ach2,
                            (LPSTR)FileName(pfile->achFile),
                            (LPSTR)ach,
			    iStreamNumber);
			
			break;

		    case ckidSTREAMFORMAT:

			if (pavi->lpFormat == NULL) {
			    pavi->cbFormat = ck.cksize;
			    pavi->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
							    ck.cksize);

			    if (pavi->lpFormat == NULL)
				goto memerror;

			    if (shfileRead(pfile->hshfile, (HPSTR) pavi->lpFormat, (LONG)ck.cksize) != (LONG)ck.cksize)
				goto readerror;

			    #define lpbi ((LPBITMAPINFOHEADER)pavi->lpFormat)

			    if (pavi->avistream.fccType != streamtypeVIDEO)
				break;

			    //
			    // make sure this is set
			    //
			    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
				lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

			    //
			    // fix up bogus stream rectangles.
			    //
			    if (IsRectBogus(&pavi->avistream.rcFrame,
					    pfile->avihdr.dwWidth,
					    pfile->avihdr.dwHeight,
					    lpbi)) {
				SetRect(&pavi->avistream.rcFrame, 0, 0,
				    (int)lpbi->biWidth, (int)lpbi->biHeight);
			    }

			    //
			    // make sure the biCompression is right for
			    // RLE files.
			    //
			    if (lpbi->biCompression == 0 && lpbi->biBitCount == 8) {
				if (pavi->avistream.fccHandler == comptypeRLE0 ||
				    pavi->avistream.fccHandler == comptypeRLE)
				    lpbi->biCompression = BI_RLE8;
			    }

			    if (pavi->avistream.fccHandler == comptypeNONE &&
				lpbi->biCompression == 0)
				pavi->avistream.fccHandler = comptypeDIB;

			    if (pavi->avistream.fccHandler == 0 &&
				lpbi->biCompression == 0)
				pavi->avistream.fccHandler = comptypeDIB;

			    // Assuming a DIB handler has RGB data will blow up
			    // if it has RLE data, and VidEdit et. al write out
			    // confusing files like this.
			    //if (pavi->avistream.fccHandler == comptypeDIB)
                            //    lpbi->biCompression = BI_RGB;

                            if (lpbi->biCompression <= BI_RLE8)
                                fRle = TRUE;

			    #undef lpbi
			}
			break;

		    case ckidSTREAMHANDLERDATA:

			if (pavi->lpData == NULL) {
			    pavi->cbData = ck.cksize;
			    pavi->lpData = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
							  ck.cksize);

			    if (pavi->lpData == NULL)
				goto memerror;

			    if (shfileRead(pfile->hshfile, (HPSTR)pavi->lpData,
					 (LONG)ck.cksize) != (LONG)ck.cksize)
				goto readerror;
			}
			break;

		    case ckidSTREAMNAME:
			l = min((LONG) ck.cksize, sizeof(pavi->avistream.szName));
			
			if (shfileRead(pfile->hshfile,
				       (HPSTR)pavi->avistream.szName, l) != l)
			    goto readerror;
			break;
			

		    case ckidAVIPADDING:
		    case mmioFOURCC('p','a','d','d'):
			break;

		    default:
			if ((hr = ReadIntoExtra(&pavi->extra,
					  pfile->hshfile,
					  &ck)) != ResultFromScode(AVIERR_OK))
			    goto error;

			break;
		}

		if (shfileAscend(pfile->hshfile, &ck, 0) != 0)
		    goto readerror;
	    }

	    /* Ascend out of stream header */
	    if (shfileAscend(pfile->hshfile, &ckStream, 0) != 0)
		goto readerror;

	    if (pavi->avistream.fccType == 0)
		goto formaterror;

	    if (pavi->lpFormat == NULL)
		goto formaterror;

	    //
	    // make sure the sample size is set right
	    //
	    switch(pavi->avistream.fccType) {
		case streamtypeAUDIO:
		    /* Hack for backward compatibility with audio */
		    pavi->avistream.dwSampleSize =
			((LPWAVEFORMAT)pavi->lpFormat)->nBlockAlign;

		    // For audio, this number isn't useful when reading.
		    pavi->avistream.dwInitialFrames = 0;
		    // !!! We should let people read what the header says....
		    break;

		case streamtypeVIDEO:
		    // !!! But what if the samples are all the right size?
		    pavi->avistream.dwSampleSize = 0;
		    break;

		default:
		    // !!! ??? pavi->avistream.dwInitialFrames = 0;
		    // !!! ??? pavi->avistream.dwSampleSize = 0;
		    break;
	    }


	    l = sizeof(pavi->avistream.szName) - 1;
	    pavi->avistream.szName[l] = '\0';

	    // next stream
	    iStream++;
	}

	// Read extra data at end of header list....
	FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckLIST, 0);
		
	if (shfileAscend(pfile->hshfile, &ckLIST, 0))
	    goto readerror;

	/* Find big data chunk */
	ckLIST.fccType = listtypeAVIMOVIE;
	if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ckLIST, &ckRIFF, MMIO_FINDLIST))
	    goto error;

	pfile->lDataListStart = ckLIST.dwDataOffset - 2 * sizeof(DWORD);

	if (shfileAscend(pfile->hshfile, &ckLIST, 0))
	    goto readerror;

	// Keep track of where data can be written
	pfile->lWriteLoc = ckLIST.dwDataOffset + ckLIST.cksize;

	//
	// read in or create a index, we only want the index entries for the
	// stream we are interested in!
        //
        ck.ckid = ckidAVINEWINDEX;
        if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckRIFF, MMIO_FINDCHUNK) == 0 && ck.cksize != 0) {

            if (!ReadInIndex(pfile, ck.cksize, ckLIST.dwDataOffset, fRle))
                goto formaterror;

        } else {
	    /* Seek back to beginning of list, so we can scan */
            shfileSeek(pfile->hshfile, ckLIST.dwDataOffset + sizeof(DWORD), SEEK_SET);

            //!!! should we realy scan big files?
            //!!! or give a error

            pfile->px = IndexCreate();

            if (pfile->px == 0)
                goto formaterror;

            DPF("Scanning index", time = timeGetTime());

	    /* Scan through chunks... */
	    while (shfileDescend(pfile->hshfile, &ck, &ckLIST, 0) == 0) {

                AddToIndex(pfile,ck.ckid,ck.cksize,ck.dwDataOffset-8,0);

		/* Hack: don't ascend from LISTs */
		if (ck.ckid != FOURCC_LIST) {
		    if (shfileAscend(pfile->hshfile, &ck, 0) != 0)
			goto readerror;
                }

                if (pfile->px->nIndex % 512 == 0)
                    DPF("!.");
            }

            DPF("!Done (%ldms)\n", timeGetTime() - time);
        }

        if (pfile->px->nIndex == 0)
	    goto formaterror;

	// Read extra data at end of file....
	FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckRIFF, 0);
	
        // shfileSetBuffer(pfile->hshfile, NULL, 0L, 0);

        //
        //  compute dwSuggestedBufferSize
        //
        if (pfile->avihdr.dwFlags & AVIF_ISINTERLEAVED) {

            LONG l;
            LONG lLen;

            pfile->avihdr.dwSuggestedBufferSize = 0;

            for (l=IndexFirst(pfile->px, STREAM_REC);
                 l != -1;
                 l = IndexNext(pfile->px, l, 0)) {

                lLen = IndexLength(pfile->px, l);

                if (pfile->avihdr.dwSuggestedBufferSize < (DWORD)lLen)
                    pfile->avihdr.dwSuggestedBufferSize = (DWORD)lLen;
            }
        }

	if ((pfile->avihdr.dwFlags & AVIF_ISINTERLEAVED) &&
                pfile->avihdr.dwInitialFrames) {

	    pfile->pb = InitBuffered((int) pfile->avihdr.dwInitialFrames * 2,
                                     pfile->avihdr.dwSuggestedBufferSize,
				     pfile->hshfile,
                                     pfile->px);
        }
        else /* if (pfile->avihdr.dwSuggestedBufferSize > 0 &&
                 pfile->avihdr.dwSuggestedBufferSize < 32l*1024) */ {

            int  nBuffers = GetProfileInt("avifile", "buffers", 5);

            pfile->pb = InitBuffered(nBuffers,
                                     min(pfile->avihdr.dwSuggestedBufferSize * 2, 32768L),
				     pfile->hshfile,
                                     pfile->px);
        }
    }

    return ResultFromScode(AVIERR_OK);

readerror:
    hr = ResultFromScode(AVIERR_FILEREAD);
    goto error;

memerror:
    hr = ResultFromScode(AVIERR_MEMORY);
    goto error;

formaterror:
    hr = ResultFromScode(AVIERR_BADFORMAT);
    
error:
    if (hr == ResultFromScode(AVIERR_OK))
	hr = ResultFromScode(AVIERR_ERROR);

    return hr;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::GetStream(PAVISTREAM FAR *ppavi, DWORD fccType, LONG lParam)
{
    CAVIFile FAR * pfile = m_pAVIFile;
    
    CAVIStream FAR *pavi;
    int             iStreamCur;
    int             iStreamWant;
    int             iStream;
    LONG            lLength;

    *ppavi = NULL;
    
    iStreamWant = (int)lParam;

    if (iStreamWant < 0 || iStreamWant >= (int)pfile->avihdr.dwStreams)
	return ResultFromScode(AVIERR_NODATA);

    /* Allocate stream data stuff, read streams */
    for (iStreamCur = -1, iStream = 0;
	    iStream < (int)pfile->avihdr.dwStreams;
	    iStream++) {
	if (fccType == 0 || pfile->ps[iStream]->avistream.fccType == fccType)
	    iStreamCur++;

	if (iStreamCur == iStreamWant)
	    break;
    }

    if (iStreamCur != iStreamWant)
	return ResultFromScode(AVIERR_NODATA);

    pavi = pfile->ps[iStream];

    if (pavi->fInit)
	goto returnnow;

    pavi->fInit = TRUE;
    
#if 0
    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0) {
	pavi->hshfile = shfileOpen(pfile->achFile, NULL, MMIO_ALLOCBUF | pfile->mode);

	if (!pavi->hshfile)
	    goto error;
    } else
#endif
    pavi->hshfile = pfile->hshfile;

    AddRef();

    pavi->lPal = -4242;

    pavi->psx = MakeStreamIndex(pfile->px, iStream,
        (LONG)pavi->avistream.dwStart - pavi->avistream.dwInitialFrames,
        (LONG)pavi->avistream.dwSampleSize,
        pfile->hshfile, shfileReadProc, NULL);

    if (pavi->psx == NULL)
        return ResultFromScode(AVIERR_MEMORY);

    pavi->avistream.dwSuggestedBufferSize = pavi->psx->lMaxSampleSize;

    if (pavi->psx->lPalFrames == 0)
        pavi->avistream.dwFlags &= ~AVISF_VIDEO_PALCHANGES;
    else
        pavi->avistream.dwFlags |= AVISF_VIDEO_PALCHANGES;

    pavi->pb = pavi->pfile->pb;

    if (!pavi->pb) {

	lBufferSize = GetProfileInt("avifile", "buffersize", 0) * 1024L;
	nBuffers = GetProfileInt("avifile", "buffers", 0);
    
	if (lBufferSize && nBuffers && !(pavi->pfile->mode & OF_CREATE)) {
	    pavi->pb = InitBuffered(nBuffers, lBufferSize,
                                pavi->hshfile, NULL);
	}
    }

    //
    //  use ReadBuffered() to read data!
    //
    if (pavi->pb) {
        pavi->psx->hFile = (HANDLE)pavi->pb;
        pavi->psx->Read  = (STREAMIOPROC)BufferedRead;
    }

    lLength = pavi->psx->lEnd - pavi->psx->lStart;

    if (lLength != (LONG)pavi->avistream.dwLength +
                            (LONG)pavi->avistream.dwInitialFrames) {
#ifdef DEBUG
	DPF("Stream %d: Length is %ld, header says %ld.\n",
	    iStream, lLength,
	    pavi->avistream.dwLength + pavi->avistream.dwInitialFrames);
#endif
        //!!! should we correct the header!!!
    }

returnnow:
    pavi->m_AVIStream.QueryInterface(IID_IAVIStream, (LPVOID FAR *) ppavi);
    
    //
    // all done return success.
    //
    return ResultFromScode(AVIERR_OK); // success
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::CreateStream(
				   PAVISTREAM FAR *ppavi,
				   AVISTREAMINFO FAR *psi)
{
    CAVIFile FAR * pf = m_pAVIFile;
    CAVIStream FAR * pavi;
    int         iStream = (int) pf->avihdr.dwStreams;
    IUnknown FAR *  pUnk;

    // Check to see if the header will take up too much room!
    if (pf->lWriteLoc > 0) {
	if ((sizeof(AVIStreamHeader) + pf->lHeaderSize +
	     lstrlen(psi->szName) + 8 * sizeof(DWORD)) >
		    pf->lWriteLoc) {
	    DPF("Header will be too big with this new stream!\n");
	    return ResultFromScode(AVIERR_UNSUPPORTED);
	}
    }
    pf->lHeaderSize += sizeof(AVIStreamHeader) + 8 * sizeof(DWORD) +
		       lstrlen(psi->szName);

    if (iStream >= MAXSTREAMS) {
	DPF("Ack: Too many streams: we only support %ld.\n", (LONG) MAXSTREAMS);

	return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    pf->ps[iStream] = new FAR CAVIStream(NULL, &pUnk);

    if (!pf->ps[iStream])
	return ResultFromScode(AVIERR_MEMORY);
    
    pavi = pf->ps[iStream];
    pavi->iStream = iStream;
    pavi->pfile = pf;
    pavi->avistream = *psi;
    pavi->avistream.dwLength = 0;       // no data initially
    pavi->avistream.dwSuggestedBufferSize = 0;
    pavi->hshfile = pf->hshfile;
    pavi->m_AVIStream.AddRef();
    AddRef();

    pavi->lpFormat = NULL;      // This will be set leater with a SetFormat
    pavi->cbFormat = 0;

    if (pavi->avistream.fccType == streamtypeAUDIO) {
	SetRectEmpty(&pavi->avistream.rcFrame);
    }

    pf->avihdr.dwStreams++;
    
    if (pavi->iStream == 0) {
	pavi->pfile->avihdr.dwMicroSecPerFrame =
		max(1000L, muldiv32(1000000L,
				     pavi->avistream.dwScale,
				     pavi->avistream.dwRate));
    }

    /* Make sure the width and height of the created file are right.... */
    pf->avihdr.dwWidth = max(pf->avihdr.dwWidth,
			     (DWORD) pavi->avistream.rcFrame.right);
    pf->avihdr.dwHeight = max(pf->avihdr.dwHeight,
			     (DWORD) pavi->avistream.rcFrame.bottom);

    // Only if interleaved?
    pf->avihdr.dwInitialFrames = max(pf->avihdr.dwInitialFrames,
                                     pavi->avistream.dwInitialFrames);

    *ppavi = &pavi->m_AVIStream;

    return ResultFromScode(AVIERR_OK);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#if 0
STDMETHODIMP CAVIFile::CAVIFileImpl::AddStream(
				PAVISTREAM pavi,
				PAVISTREAM FAR *ppaviNew)
{
    CAVIFile FAR * pf = m_pAVIFile;
    CAVIStream FAR * paviNew;
    int         iStream = (int) pf->avihdr.dwStreams;
    HRESULT     hr;
    IUnknown FAR *  pUnk;

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    pfile->ps[iStream] = new FAR CAVIStream(NULL, &pUnk);

    // !!! error check?
    
    paviNew = pf->ps[iStream];
    paviNew->iStream = iStream;
    paviNew->pfile = pf;
    AVIStreamInfo(pavi, &paviNew->avistream, sizeof(paviNew->avistream));
    paviNew->hshfile = pf->hshfile;
    paviNew->m_AVIStream.AddRef();
    paviNew->paviBase = pavi;
    AVIStreamAddRef(pavi);

    paviNew->cbFormat = AVIStreamFormatSize(pavi, 0);
    paviNew->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, paviNew->cbFormat); 
    if (!paviNew->lpFormat) {
	AVIStreamClose((PAVISTREAM) pf->ps[iStream]);
	return ResultFromScode(AVIERR_MEMORY);
    }

    AVIStreamReadFormat(pavi, 0, paviNew->lpFormat, &paviNew->cbFormat);

    pf->avihdr.dwStreams++;
    
    AddRef();

    if (paviNew->iStream == 0) {
	pf->avihdr.dwMicroSecPerFrame =
		muldiv32(1000000L,
			 paviNew->avistream.dwScale,
			 paviNew->avistream.dwRate);
    }
    
    *ppaviNew = (PAVISTREAM) paviNew;
    
    return ResultFromScode(AVIERR_OK);
}
#endif

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::WriteData(
		       DWORD ckid,
		       LPVOID lpData,
		       LONG cbData)
{
    CAVIFile FAR *      pf = m_pAVIFile;

    // !!! Anything else we can check?
    if (lpData == NULL || cbData == 0)
	return ResultFromScode(AVIERR_BADPARAM);

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    pf->fDirty = TRUE;

    return WriteExtra(&pf->extra, ckid, lpData, cbData);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::ReadData(
		      DWORD ckid,
		      LPVOID lpData,
		      LONG FAR *lpcbData)
{
    CAVIFile FAR * pf = m_pAVIFile;

    return ReadExtra(&pf->extra, ckid, lpData, lpcbData);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::EndRecord()
{
    CAVIFile FAR * pf = m_pAVIFile;

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    pf->fDirty = TRUE;
    pf->avihdr.dwFlags |= AVIF_ISINTERLEAVED;

    if (pf->lWriteLoc == 0) {
	pf->lWriteLoc = (pf->lHeaderSize + 1024 + 2047) & ~(2047);
	pf->lDataListStart = pf->lWriteLoc - 3 * sizeof(DWORD);
	DPF("Writing first chunk at position %lu\n", pf->lWriteLoc);
    }

    shfileSeek(pf->hshfile, pf->lWriteLoc, SEEK_SET);
    
    if (pf->fInRecord) {
	// !!! Support padding here?
	
	if (shfileAscend(pf->hshfile, (MMCKINFO FAR *) &pf->ckRecord, 0))
	    return ResultFromScode(AVIERR_FILEWRITE);

        IndexSetLength(pf->px, pf->lRecordIndex, pf->ckRecord.cksize);

	//
	// Keep the main suggested buffer size as big as the biggest
	// record....
	//
	if (pf->ckRecord.cksize + 3 * sizeof(DWORD) >
					    pf->avihdr.dwSuggestedBufferSize)
	    pf->avihdr.dwSuggestedBufferSize = pf->ckRecord.cksize +
							   3 * sizeof(DWORD);
    }

    /* Start the next 'rec' list */
    pf->ckRecord.cksize = 0;
    pf->ckRecord.fccType = listtypeAVIRECORD;
    pf->fInRecord = TRUE;
    if (shfileCreateChunk(pf->hshfile, (MMCKINFO FAR *) &pf->ckRecord, MMIO_CREATELIST)) {
	return ResultFromScode(AVIERR_FILEWRITE);
    }

    pf->lWriteLoc = shfileSeek(pf->hshfile, 0, SEEK_CUR);
    
    pf->lRecordIndex = pf->px->nIndex;

    if (!AddToIndex(pf, pf->ckRecord.fccType, 0,
        pf->ckRecord.dwDataOffset - 2 * sizeof(DWORD), AVIIF_LIST)) {
        return ResultFromScode(AVIERR_MEMORY);
    }

    return ResultFromScode(AVIERR_OK);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Info(
		  AVIFILEINFO FAR * pfi,
		  LONG lSize)
{
    CAVIFile FAR * pf = m_pAVIFile;
    AVIFILEINFO     fi;
    char	ach[30];

    if (pfi == NULL)
	return ResultFromScode(AVIERR_BADPARAM);
	
    if (lSize < sizeof(fi))
	return ResultFromScode(AVIERR_BUFFERTOOSMALL);

    fi.dwMaxBytesPerSec =       pf->avihdr.dwMaxBytesPerSec;
    fi.dwFlags =                0;
    fi.dwStreams =              pf->avihdr.dwStreams;
    fi.dwSuggestedBufferSize =  pf->avihdr.dwSuggestedBufferSize;
    fi.dwWidth =                pf->avihdr.dwWidth;
    fi.dwHeight =               pf->avihdr.dwHeight;
    fi.dwScale =                pf->avihdr.dwMicroSecPerFrame;
    fi.dwRate =                 1000000L;
    fi.dwLength =               pf->avihdr.dwTotalFrames;
    fi.dwEditCount =            0;

    LoadString(ghMod, IDS_AVIFILE, ach, sizeof(ach));
    wsprintf(fi.szFileType, (LPSTR)ach);
    
    hmemcpy(pfi, &fi, sizeof(fi));

    return AVIERR_OK;
}


///////////////////////////////////////////////////////////////////////////
//
//  AVIFileClose()
//
//      close a AVIFile stream
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CAVIStream::CUnknownImpl::Release()
{
    CAVIStream FAR * pavi = m_pAVIStream;
	
    uUseCount--;

    if (m_refs < 20) {
	DPF2("Stream %lx: Usage--=%lx\n", (DWORD) (LPVOID) this, m_refs - 1);
    }

    shfileRelease(pavi->hshfile);
    
    if (!--m_refs) {
	if (pavi->hshfile != pavi->pfile->hshfile) {
	    shfileClose(pavi->hshfile, 0);
	    pavi->hshfile = 0;
	}

	if (pavi->pb && pavi->pb != pavi->pfile->pb) {
	    EndBuffered(pavi->pb);
	    pavi->pb = 0;
        }

        if (pavi->psx) {
            FreeStreamIndex(pavi->psx);
            pavi->psx = NULL;
        }

        pavi->fInit = FALSE;

	pavi->pfile->m_AVIFile.Release();
	return 0;
    }
    return m_refs;
}

/*      -       -       -       -       -       -       -       -       */

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

void CAVIStream::CAVIStreamImpl::ReadPalette(LONG lPos, LONG lPal, LPRGBQUAD prgb)
{
    CAVIStream FAR * pavi = m_pAVIStream;

    LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;
    LONG l;
    int i,n;

    static struct {
	BYTE                bFirstEntry;    /* first entry to change */
	BYTE                bNumEntries;    /* # entries to change (0 if 256) */
	WORD                wFlags;         /* Mostly to preserve alignment... */
	PALETTEENTRY        peNew[256];     /* New color specifications */
    } pc;

    DPF("Reading palette: lPos = %ld, lPal = %ld\n", lPos, lPal);

    if (lPal > lPos)
	lPal = 0;

    //
    //  get the palette colors in the initial format header
    //
    if (lPal <= 0) {
	hmemcpy(prgb,(LPBYTE)lpbi+(int)lpbi->biSize, lpbi->biClrUsed * sizeof(RGBQUAD));
	lPal = -1;
    }

    for (;;) {
	//
	//  search index forward for next palette change
	//
        l = StreamFindSample(pavi->psx, lPal+1, FIND_FORMAT|FIND_NEXT);

        if (l < 0 || l > lPos || l == lPal)
	    break;

	lPal = l;

	if (l <= (LONG) pavi->avistream.dwStart)
            continue;

        LONG off = StreamFindSample(pavi->psx, lPal, FIND_FORMAT|FIND_OFFSET);
        LONG len = StreamFindSample(pavi->psx, lPal, FIND_FORMAT|FIND_LENGTH);

#ifdef DEBUG
        DWORD adw[2];
        shfileSeek(pavi->hshfile, off-8, SEEK_SET);
        shfileRead(pavi->hshfile, (HPSTR)adw, sizeof(adw));
        Assert(TWOCCFromFOURCC(adw[0]) == cktypePALchange);
        Assert(adw[1] == (DWORD) len);
#endif

        if (len > (LONG)sizeof(AVIPALCHANGE) + (LONG)lpbi->biClrUsed * sizeof(PALETTEENTRY) * 2) {
	    DPF("Palette chunk obviously too large!\n");
	    break;
	}

	//
	//  read palchange from file and apply it
	//
        shfileSeek(pavi->hshfile, off, SEEK_SET);

        while (len >= sizeof(AVIPALCHANGE)) {

	    if (shfileRead(pavi->hshfile, (HPSTR)&pc, sizeof(AVIPALCHANGE)) !=
			sizeof(AVIPALCHANGE)) {
		DPF("Error reading palette change\n");
		break;
	    }

	    n = pc.bNumEntries == 0 ? 256 : (int)pc.bNumEntries;

	    if ((DWORD) n > lpbi->biClrUsed) {
		DPF("%d colors in palette change, only %lu in movie!\n", n, lpbi->biClrUsed);
		break;
            }

            if (pc.bFirstEntry + n > (int)lpbi->biClrUsed) {
		DPF("%d colors in palette change, only %lu in movie!\n", n, lpbi->biClrUsed);
		break;
	    }

	    if (shfileRead(pavi->hshfile,
			   (HPSTR)&pc.peNew,
			   n * sizeof(PALETTEENTRY)) !=
		    (LONG) n * sizeof(PALETTEENTRY)) {
		DPF("Error reading palette change entries\n");
		break;
	    }

	    for (i=0; i<n; i++) {
		pavi->argbq[pc.bFirstEntry+i].rgbRed       = pc.peNew[i].peRed;
		pavi->argbq[pc.bFirstEntry+i].rgbGreen     = pc.peNew[i].peGreen;
		pavi->argbq[pc.bFirstEntry+i].rgbBlue      = pc.peNew[i].peBlue;
		pavi->argbq[pc.bFirstEntry+i].rgbReserved  = 0;
	    }

            len -= n * sizeof(PALETTEENTRY) + sizeof(AVIPALCHANGE);
	}
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    CAVIStream FAR * pavi = m_pAVIStream;
    
    LONG lPal;
    LPBITMAPINFOHEADER lpbi;

    if (lpcbFormat == NULL)
	return ResultFromScode(AVIERR_BADPARAM);

    if (lpFormat == NULL || *lpcbFormat == 0) {
	*lpcbFormat = pavi->cbFormat;
	return AVIERR_OK;
    }

    if (pavi->avistream.dwFlags & AVISF_VIDEO_PALCHANGES) {

        Assert(pavi->psx);

	//
	//  now go find the nearest palette change
	//
        lPal = StreamFindSample(pavi->psx, lPos, FIND_FORMAT|FIND_PREV);

        if (lPal < 0)
	    lPal = 0;

	if (lPal != pavi->lPal) {
	    ReadPalette(lPal, pavi->lPal, pavi->argbq);
	    pavi->lPal = lPal;
	}

	lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;

	hmemcpy(lpFormat, lpbi, min((LONG) lpbi->biSize, *lpcbFormat));

	if (*lpcbFormat > (LONG) lpbi->biSize) {
	    hmemcpy((LPBYTE)lpFormat + (int)lpbi->biSize, pavi->argbq,
		    min(lpbi->biClrUsed * sizeof(RGBQUAD),
			*lpcbFormat - lpbi->biSize));
	}
    }
    else {
	hmemcpy(lpFormat, pavi->lpFormat, min(*lpcbFormat, pavi->cbFormat));
    }

    if (*lpcbFormat < pavi->cbFormat) {
	*lpcbFormat = pavi->cbFormat;
	return ResultFromScode(AVIERR_BUFFERTOOSMALL);
    }

    *lpcbFormat = pavi->cbFormat;

    return AVIERR_OK;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Create(LONG lParam1, LONG lParam2)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Info(AVISTREAMINFO FAR * psi, LONG lSize)
{
    CAVIStream FAR * pavi = m_pAVIStream;
    
    if (psi == NULL)
	return ResultFromScode(AVIERR_BADPARAM);

    if (lSize < sizeof(pavi->avistream))
	return ResultFromScode(AVIERR_BUFFERTOOSMALL);

    hmemcpy(psi, &pavi->avistream, sizeof(pavi->avistream));

    return AVIERR_OK;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(LONG) CAVIStream::CAVIStreamImpl::FindSample(LONG lPos, LONG lFlags)
{
    CAVIStream FAR * pavi = m_pAVIStream;
    
    if (pavi->paviBase) {
	// If we haven't copied over the data yet, delegate.
        return AVIStreamFindSample(pavi->paviBase, lPos, lFlags);
    }

    if (lPos < (LONG)pavi->avistream.dwStart)
	return -1;

    if (lPos >= (LONG)(pavi->avistream.dwStart + pavi->avistream.dwLength))
        return -1;

    lPos = StreamFindSample(pavi->psx, lPos, (UINT)lFlags);

    return lPos < 0 ? -1 : lPos;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Read(
		 LONG       lStart,
		 LONG       lSamples,
		 LPVOID     lpBuffer,
		 LONG       cbBuffer,
		 LONG FAR * plBytes,
		 LONG FAR * plSamples)
{
    CAVIStream FAR *    pavi = m_pAVIStream;
    LONG                lBytes;

    if (pavi->paviBase) {
	// If we haven't copied over the data yet, delegate.
	return AVIStreamRead(pavi->paviBase, lStart, lSamples,
			     lpBuffer, cbBuffer, plBytes, plSamples);
    }

    Assert(pavi->psx);

    // !!! What if start too big? Length too long?

    if (lStart < (LONG) pavi->avistream.dwStart) {
	DPF("Read before start!\n");
	return ResultFromScode(AVIERR_BADPARAM);
    }

    // Handle one of the sillier aspects of AVI files:
    // Certain RLE-encoded files have their first frames split
    // up into lots of small pieces.  This code puts all of those
    // pieces back together again if necessary.

    if ((lStart == (LONG) pavi->avistream.dwStart) &&
		    (pavi->avistream.fccType == streamtypeVIDEO) &&
		    (pavi->avistream.dwInitialFrames > 0)) {

	LPBITMAPINFOHEADER  lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;
	LPVOID              lp;

	lStart -= (LONG) pavi->avistream.dwInitialFrames;
	lBytes = (DWORD)(WORD)DIBWIDTHBYTES(lpbi) * (DWORD)(WORD)lpbi->biHeight;

	//
	// a NULL buffer means return the size buffer needed to read
	// the given sample.
	//
        if (lpBuffer == NULL || cbBuffer == 0) {

	    if (plBytes)
                *plBytes = lBytes;

	    return AVIERR_OK;
	}

	if (cbBuffer < lBytes) {
	    if (plBytes)
		*plBytes = lBytes;
	    DPF("ReadFirst: Buffer is %ld bytes, needed %ld\n", cbBuffer, lBytes);
	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}

	lp = GlobalAllocPtr(GMEM_MOVEABLE, lBytes);

	if (!lp)
	    return ResultFromScode(AVIERR_MEMORY);

        while (lStart <= (LONG)pavi->avistream.dwStart) {

            if (StreamRead(pavi->psx, lStart, 1, lp, lBytes) < 0) {
		GlobalFreePtr(lp);
                return ResultFromScode(AVIERR_FILEREAD);
	    }

	    // We probably shouldn't assume RLE here....
	    DecodeRle(lpbi, (BYTE _huge *) lpBuffer, (BYTE _huge *) lp);
	    lStart++;
	}

	GlobalFreePtr(lp);
        goto done;
    }

    //
    // do the read
    //
    lBytes = StreamRead(pavi->psx,lStart,lSamples,lpBuffer,cbBuffer);

    //
    // check for error
    //
    if (lBytes < 0) {

        if (plBytes)
            *plBytes = 0;

        if (plSamples)
            *plSamples = 0;

        if (cbBuffer == 0)
            return ResultFromScode(AVIERR_ERROR);

        //
        // the error may have been buffer too small, check this.
        //
        if (cbBuffer < pavi->psx->lSampleSize)
            return ResultFromScode(AVIERR_BUFFERTOOSMALL);

        lBytes = StreamFindSample(pavi->psx,lStart,FIND_PREV|FIND_LENGTH);

        if (cbBuffer < lBytes) {

            if (plBytes)
                *plBytes = lBytes;

            return ResultFromScode(AVIERR_BUFFERTOOSMALL);
        }
        else
            return ResultFromScode(AVIERR_FILEREAD);
    }

done:
    if (plBytes)
        *plBytes = lBytes;

    if (plSamples) {
        LONG lSampleSize = pavi->psx->lSampleSize;

        if (lSampleSize)
            *plSamples = lBytes / lSampleSize;
        else 
            *plSamples = 1;
    }

    return AVIERR_OK;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
inline BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
        lpbi1->biCompression == lpbi2->biCompression   &&
        lpbi1->biSize        == lpbi2->biSize          &&
        lpbi1->biWidth       == lpbi2->biWidth         &&
        lpbi1->biHeight      == lpbi2->biHeight        &&
        lpbi1->biBitCount    == lpbi2->biBitCount;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    CAVIStream FAR *    pavi = m_pAVIStream;
    LPBITMAPINFOHEADER  lpbi = (LPBITMAPINFOHEADER) lpFormat;
    int                 i;
    RGBQUAD FAR *       lprgb;
    struct {
	BYTE            bFirstEntry;    /* first entry to change */
	BYTE            bNumEntries;    /* # entries to change (0 if 256) */
	WORD            wFlags;         /* Mostly to preserve alignment... */
	PALETTEENTRY    pe[256];
    } s;


    //
    // Make sure the stream isn't read-only
    //
    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    if (pavi->lpFormat == NULL) {
	// Check to see if the header will take up too much room!
	if (pavi->pfile->lWriteLoc > 0) {
	    if ((pavi->cbFormat + pavi->pfile->lHeaderSize + 2 * sizeof(DWORD)) >
			pavi->pfile->lWriteLoc) {
		DPF("Header will be too big with this format!\n");
		return ResultFromScode(AVIERR_UNSUPPORTED);
	    }
	}
	pavi->pfile->lHeaderSize += cbFormat + 2 * sizeof(DWORD);

	// This is a new stream, whose format hasn't been set.
	pavi->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbFormat);
	if (!pavi->lpFormat) {
	    return ResultFromScode(AVIERR_MEMORY);
	}

	hmemcpy(pavi->lpFormat, lpFormat, cbFormat);
	pavi->cbFormat = cbFormat;

	if (pavi->avistream.fccType == streamtypeVIDEO) {

	    if (IsRectBogus(&pavi->avistream.rcFrame,
			    pavi->pfile->avihdr.dwWidth,
			    pavi->pfile->avihdr.dwHeight,
			    lpbi)) {
		DPF("Resetting stream rectangle....\n");
		SetRect(&pavi->avistream.rcFrame, 0, 0,
		    (int)lpbi->biWidth, (int)lpbi->biHeight);
	    }

	    if (lpbi->biClrUsed > 0) {
		// Get the right colors, so that we can detect palette changes
		hmemcpy(pavi->argbq,
			(LPBYTE) lpbi + lpbi->biSize,
			lpbi->biClrUsed * sizeof(RGBQUAD));
	    }

	    /* Make sure the width and height of the created file are right.... */
	    pavi->pfile->avihdr.dwWidth = max(pavi->pfile->avihdr.dwWidth,
				 (DWORD) pavi->avistream.rcFrame.right);
	    pavi->pfile->avihdr.dwHeight = max(pavi->pfile->avihdr.dwHeight,
				 (DWORD) pavi->avistream.rcFrame.bottom);
	} 

	return 0;
    }

    //
    // First, check if the format is actually different....
    //
    if (cbFormat == pavi->cbFormat &&
		(_fmemcmp(pavi->lpFormat, lpFormat, (int) cbFormat) == 0))
	return AVIERR_OK;

    //
    // We really only support format changes if they're palette changes...
    //
    if (pavi->avistream.fccType != streamtypeVIDEO) {	
	return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    //
    // Can only currently set the palette at the end of the file
    //
    if (lPos < (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength))
	return ResultFromScode(AVIERR_UNSUPPORTED);

    //
    // We can only change the palette for things with palettes....
    //
    if (lpbi->biBitCount > 8 || lpbi->biClrUsed == 0)
	return ResultFromScode(AVIERR_UNSUPPORTED);

    //
    // Be sure only the palette is changing, nothing else....
    //
    if (cbFormat != pavi->cbFormat)
	return ResultFromScode(AVIERR_UNSUPPORTED);

    if (!DibEq((LPBITMAPINFOHEADER) lpFormat,
	       (LPBITMAPINFOHEADER) pavi->lpFormat))
	return ResultFromScode(AVIERR_UNSUPPORTED);

    // !!! Need to do here:
    // Get the correct palette for this point in the file, and check
    // that the new palette is in fact different.
    lprgb = (RGBQUAD FAR *) ((LPBYTE) lpbi + lpbi->biSize);

    if (_fmemcmp(pavi->argbq, lprgb, (UINT) lpbi->biClrUsed * sizeof(RGBQUAD)) == 0)
	return AVIERR_OK;

    //
    // Make the new format the current one....
    //
    hmemcpy(pavi->argbq, lprgb, lpbi->biClrUsed * sizeof(RGBQUAD));
    pavi->lPal = lPos;
    
    //
    // And be sure the stream is marked as having changes...
    //
    pavi->avistream.dwFlags |= AVISF_VIDEO_PALCHANGES;
    
    s.bFirstEntry = 0;
    s.bNumEntries = (BYTE) lpbi->biClrUsed;
    s.wFlags = 0;
    for (i = 0; i < (int) lpbi->biClrUsed; i++, lprgb++) {
	s.pe[i].peRed = lprgb->rgbRed;
	s.pe[i].peGreen = lprgb->rgbGreen;
	s.pe[i].peBlue = lprgb->rgbBlue;
    }
    
    // !!! Hack: use Write to write the palette change....

    return Write(lPos,
		 0,
		 &s,
		 sizeof(AVIPALCHANGE) + lpbi->biClrUsed * sizeof(PALETTEENTRY), 
		 AVIIF_NOTIME, NULL, NULL);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Write(LONG lStart,
					       LONG lSamples,
					       LPVOID lpData,
					       LONG cbData,
					       DWORD dwFlags,
					       LONG FAR *plSampWritten,
					       LONG FAR *plBytesWritten)
{
    CAVIStream FAR *        pavi = m_pAVIStream;
    MMCKINFO        ck;
    WORD            cktype;
    HRESULT	    hr;
    DWORD	    dwmsec;

    // !!! Idea: if it's audio-like data, and everything else matches the
    // last chunk written out, then merge the new data in with the old
    // data, rather than making a new chunk....
    
    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    if (pavi->avistream.fccType == streamtypeAUDIO)
	cktype = aviTWOCC('w', 'b');
    else if (pavi->avistream.fccType == streamtypeVIDEO) {
	if (dwFlags & AVIIF_NOTIME)         
	    cktype = aviTWOCC('p', 'c');
	else {
	    LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;

	    if ((dwFlags & AVIIF_KEYFRAME) ||
		(lpbi->biCompression <= BI_RLE8 && cbData == (LONG) lpbi->biSizeImage))
		cktype = aviTWOCC('d', 'b');
	    else
		cktype = aviTWOCC('d', 'c');
	    // !!! 00dx ack!
	}
    } else {
        cktype = aviTWOCC('d', 'c');
    }
    
    ck.ckid = MAKEAVICKID(cktype, pavi->iStream);
    ck.cksize = cbData;

    if (lStart < 0)
	lStart = pavi->avistream.dwStart + pavi->avistream.dwLength;
    
    if (lStart > (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength)) {
	if (pavi->avistream.dwSampleSize == 0) {
	    // !!! bad hack--insert lots of blank index entries....

	    while (lStart > (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength)) {
#if 1
		hr = Write(pavi->avistream.dwStart + pavi->avistream.dwLength,
			    1,
			    NULL,
			    0,
			    0,
			    NULL,
			    NULL);

		if (FAILED(hr))
		    return hr;
#else
		if (!AddToIndex(pavi->pfile, ck.ckid, 0, 0, 0))
		    return ResultFromScode(AVIERR_MEMORY);

		++pavi->avistream.dwLength;
		pavi->pfile->avihdr.dwFlags |= AVIF_MUSTUSEINDEX;
#endif
	    }
	} else 
	    return ResultFromScode(AVIERR_BADPARAM);
    }
    
    if (lStart < (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength))
	return ResultFromScode(AVIERR_UNSUPPORTED);
    
    pavi->pfile->fDirty = TRUE;

    if (pavi->pfile->lWriteLoc == 0) {
	pavi->pfile->lWriteLoc = (pavi->pfile->lHeaderSize + 1024 + 2047) & ~(2047);
	pavi->pfile->lDataListStart = pavi->pfile->lWriteLoc - 3 * sizeof(DWORD);
	DPF("Writing first chunk at position %lu\n", pavi->pfile->lWriteLoc);
    }

#if 0
    if ((lStart == (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength)) &&
	(pavi->avistream.fccType == streamtypeAUDIO) &&
	(pavi->pfile->lIndex > 0)) {
	    AVIINDEXENTRY   idx = pavi->pfile->pIndex[pavi->pfile->lIndex - 1];

	    if ((idx.ckid == ckid) &&
		(idx.dwChunkOffset +
		 2 * sizeof(DWORD) +
		 idx.dwChunkLength == lWriteLoc)) {

		// We could append to the previous chunk here....

	    }
    }
		
#endif
    
#ifdef DONTWRITEZEROLENGTH
    if (cbData == 0) {
	ck.dwDataOffset = 0;
	pavi->pfile->avihdr.dwFlags |= AVIF_MUSTUSEINDEX;
    } else
#endif
    {
	shfileSeek(pavi->hshfile, pavi->pfile->lWriteLoc, SEEK_SET);
	shfileCreateChunk(pavi->hshfile, &ck, 0);

	if (cbData) {
	    if (shfileWrite(pavi->hshfile, (HPSTR) lpData, cbData) != cbData)
		return ResultFromScode(AVIERR_FILEWRITE);
	}

	if (shfileAscend(pavi->hshfile, &ck, 0) != 0)
	    return ResultFromScode(AVIERR_FILEWRITE);
	
	pavi->pfile->lWriteLoc = shfileSeek(pavi->hshfile, 0, SEEK_CUR);
    }
    
    if (!AddToIndex(pavi->pfile, ck.ckid, cbData,
		    ck.dwDataOffset - 2 * sizeof(DWORD), dwFlags))
        return ResultFromScode(AVIERR_MEMORY);

    //
    // if we dont have a stream index now is a good time to make one.
    //
    if (pavi->psx == NULL) {

        pavi->psx = MakeStreamIndex(pavi->pfile->px, pavi->iStream,
            (LONG)pavi->avistream.dwStart - pavi->avistream.dwInitialFrames,
            (LONG)pavi->avistream.dwSampleSize,
            pavi->pfile->hshfile, shfileReadProc, NULL);

        //!!! what about pavi->pb

        if (!(dwFlags & AVIIF_NOTIME))
            pavi->psx->lEnd -= lSamples;    // correct for the decrement below
    }

    if (pavi->psx == NULL) {
        DPF("CAVIStream::Write no stream index!\n");
        return ResultFromScode(AVIERR_MEMORY);
    }

    if (!(dwFlags & AVIIF_NOTIME)) {
        pavi->avistream.dwLength += lSamples;

        if (pavi->psx)
            pavi->psx->lEnd += lSamples;
    }
    
    if (cbData > (LONG) pavi->avistream.dwSuggestedBufferSize)
	pavi->avistream.dwSuggestedBufferSize = cbData;

    if (cbData > (LONG) pavi->pfile->avihdr.dwSuggestedBufferSize)
	pavi->pfile->avihdr.dwSuggestedBufferSize = cbData;

    // Recalculate the overall file length....
    dwmsec = muldiv32(pavi->avistream.dwLength,
			     pavi->avistream.dwScale * 1000L,
			     pavi->avistream.dwRate);
    pavi->pfile->avihdr.dwTotalFrames =
	max(pavi->pfile->avihdr.dwTotalFrames,
	    (DWORD) muldiv32(dwmsec, 1000L,
			     pavi->pfile->avihdr.dwMicroSecPerFrame));
    // !!! The above calculation could easily overflow.
    // !!! NEEDS TO BE REORGANIZED!

    if (plBytesWritten)
	*plBytesWritten = cbData;
    
    if (plSampWritten)
	*plSampWritten = lSamples;
    
    return ResultFromScode(AVIERR_OK);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Delete(LONG lStart,LONG lSamples)
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    // go through and kill things from the index?
    
    // !!! what about keyframe boundaries?
	
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::ReadData(DWORD ckid, LPVOID lp, LONG FAR *lpcb)
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    return ReadExtra(&pavi->extra, ckid, lp, lpcb);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::WriteData(DWORD ckid, LPVOID lp, LONG cb)
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    // Check to see if the header will take up too much room!
    if (pavi->pfile->lWriteLoc > 0) {
	if ((cb + pavi->pfile->lHeaderSize + 2 * sizeof(DWORD)) >
		    pavi->pfile->lWriteLoc) {
	    DPF("Header will be too big with this extra data!\n");
	    return ResultFromScode(AVIERR_UNSUPPORTED);
	}
    }
    
    pavi->pfile->lHeaderSize += cb + 3 * sizeof(DWORD);

    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
	return ResultFromScode(AVIERR_READONLY);

    pavi->pfile->fDirty = TRUE;

    return WriteExtra(&pavi->extra, ckid, lp, cb);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#if 0
STDMETHODIMP CAVIStream::CAVIStreamImpl::Clone(PAVISTREAM FAR * ppaviNew)
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif


STDMETHODIMP CAVIStream::CStreamingImpl::Begin(LONG  lStart,	
					       LONG  lEnd,	
					       LONG  lRate)
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    if (pavi->pb)
	BeginBufferedStreaming(pavi->pb, lRate > 0);
    
    return ResultFromScode(AVIERR_OK);
}


STDMETHODIMP CAVIStream::CStreamingImpl::End()
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    if (pavi->pb)
	EndBufferedStreaming(pavi->pb);
    
    return ResultFromScode(AVIERR_OK);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static
BOOL AddToIndex(CAVIFile FAR * pfile, DWORD ckid, DWORD cksize, LONG off, DWORD dwFlags)
{
    PAVIINDEX px;
    AVIINDEXENTRY idx;

    idx.ckid          = ckid;
    idx.dwChunkOffset = off;
    idx.dwChunkLength = cksize;
    idx.dwFlags       = dwFlags;

    px = IndexAddFileIndex(pfile->px, &idx, 1, 0, FALSE);

    if (px == NULL)
        return FALSE;

    //
    // GlobalReAlloc may have moved our pointer, we need to patch all
    // places we use it!
    //
    if (px != pfile->px) {

        DPF("Index pointer has changed!\n");

        pfile->px = px;

        for (int i=0; i<(int)pfile->avihdr.dwStreams; i++) {

            CAVIStream FAR *ps = pfile->ps[i];

            if (ps->psx)
                ps->psx->px = px;
        }

        if (pfile->pb)
            pfile->pb->px = px;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}



CAVIFile::CMarshalImpl::CMarshalImpl(
	CAVIFile FAR*   pAVIFile)
{
	m_pAVIFile = pAVIFile;
}


STDMETHODIMP CAVIFile::CMarshalImpl::QueryInterface(
	const IID FAR&  iid,
	void FAR* FAR*  ppv)
{
	return m_pAVIFile->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CMarshalImpl::AddRef()
{
	return m_pAVIFile->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CMarshalImpl::Release()
{
	return m_pAVIFile->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */



// *** IMarshal methods ***
STDMETHODIMP CAVIFile::CMarshalImpl::GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPCLSID pCid)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIFile->m_Unknown;

    DPF("(F) UnMarshalClass called (context = %lx)\n", dwDestContext);
    
    if (dwDestContext != MSHCTX_LOCAL) {
	LPMARSHAL    pMarshal;
	
	DPF("Marshal context is %lu: delegating...\n", dwDestContext);

	hr = CoGetStandardMarshal(riid, NULL,
				  dwDestContext, pvDestContext,
				  mshlflags, &pMarshal);

	if (hr != NOERROR)
	    return hr;

	hr = pMarshal->GetUnmarshalClass(riid, pv,
					 dwDestContext, pvDestContext,
					 mshlflags, pCid);

	pMarshal->Release();

	return hr;
    }
    *pCid = CLSID_AVISimpleUnMarshal;
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPDWORD pSize)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIFile->m_Unknown;

    if (dwDestContext != MSHCTX_LOCAL) {
	LPMARSHAL    pMarshal;
	
	hr = CoGetStandardMarshal(riid, NULL, dwDestContext, pvDestContext,
				  mshlflags, &pMarshal);

	if (hr != NOERROR)
	    return hr;

	hr = pMarshal->GetMarshalSizeMax(riid, pv,
					 dwDestContext, pvDestContext,
					 mshlflags, pSize);

	pMarshal->Release();

	return hr;
    }
    *pSize = sizeof(pUnk);
    
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
		    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIFile->m_Unknown;

    DPF("MarshalInterface (F) called\n");
    
    if (dwDestContext != MSHCTX_LOCAL) {
	LPMARSHAL    pMarshal;
	
	DPF("Marshal context is %lu: delegating...\n", dwDestContext);

	hr = CoGetStandardMarshal(riid, NULL,
				  dwDestContext, pvDestContext,
				  mshlflags, &pMarshal);

	if (hr != NOERROR)
	    return hr;

	hr = pMarshal->MarshalInterface(pStm, riid, pv,
					dwDestContext, pvDestContext,
					mshlflags);

	pMarshal->Release();

	return hr;
    }
    
    if ((riid != IID_IAVIStream && riid != IID_IAVIFile && riid != IID_IUnknown))
        return ResultFromScode(E_INVALIDARG);

    if ((hr = pStm->Write(&pUnk, sizeof(pUnk), NULL)) == NOERROR)
	AddRef();

    DPF("Returns %lx\n", (DWORD) (LPVOID) hr);
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
		    LPVOID FAR* ppv)
{
    HRESULT hr = ResultFromScode(E_FAIL);

    DPF("(F) UnMarshalInterface called!!!\n");
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::ReleaseMarshalData (THIS_ LPSTREAM pStm)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk;
    
    hr = pStm->Read(&pUnk,sizeof(pUnk),NULL);
    DPF("(F) ReleaseMarshalData\n");
    if (hr == NOERROR)
	pUnk->Release();

    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::DisconnectObject (THIS_ DWORD dwReserved)
{
    HRESULT hr = NOERROR;

    return hr;
}


CAVIStream::CMarshalImpl::CMarshalImpl(
	CAVIStream FAR* pAVIStream)
{
	m_pAVIStream = pAVIStream;
}


STDMETHODIMP CAVIStream::CMarshalImpl::QueryInterface(
	const IID FAR&  iid,
	void FAR* FAR*  ppv)
{
	return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIStream::CMarshalImpl::AddRef()
{
	return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIStream::CMarshalImpl::Release()
{
	return m_pAVIStream->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */



// *** IMarshal methods ***
STDMETHODIMP CAVIStream::CMarshalImpl::GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPCLSID pCid)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIStream->m_Unknown;

    DPF("(S) UnMarshalClass called (context = %lx)\n", dwDestContext);
    *pCid = CLSID_AVISimpleUnMarshal;
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPDWORD pSize)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIStream->m_Unknown;

    *pSize = sizeof(pUnk);
    
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
		    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIStream->m_Unknown;

    DPF("MarshalInterface (S) called\n");
    if ((riid != IID_IAVIStream && riid != IID_IAVIStream && riid != IID_IUnknown))
        return ResultFromScode(E_INVALIDARG);

    if ((hr = pStm->Write(&pUnk, sizeof(pUnk), NULL)) == NOERROR)
	AddRef();

    DPF("Returns %lx\n", (DWORD) (LPVOID) hr);
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
		    LPVOID FAR* ppv)
{
    HRESULT hr = ResultFromScode(E_FAIL);

    DPF("(S) UnMarshalInterface called!!!\n");
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::ReleaseMarshalData (THIS_ LPSTREAM pStm)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk;
    
    hr = pStm->Read(&pUnk,sizeof(pUnk),NULL);
    DPF("(S) ReleaseMarshalData\n");
    if (hr == NOERROR)
	pUnk->Release();

    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::DisconnectObject (THIS_ DWORD dwReserved)
{
    HRESULT hr = NOERROR;

    return hr;
}



/***************************************************************************

  DecodeRle   - 'C' version

  Play back a RLE buffer into a DIB buffer

  returns
      none

 ***************************************************************************/

void DecodeRle(LPBITMAPINFOHEADER lpbi, BYTE _huge *pb, BYTE _huge *prle)
{
    BYTE    cnt;
    BYTE    b;
    WORD    x;
    WORD    dx,dy;
    WORD    wWidthBytes;

    #define RLE_ESCAPE  0
    #define RLE_EOL     0
    #define RLE_EOF     1
    #define RLE_JMP     2
    #define RLE_RUN     3

#if 0
#ifndef WIN32
    //
    // this uses ASM code found in RLEA.ASM
    //
    if (!(WinFlags & WF_CPU286))
        DecodeRle386(lpbi, pb, prle);
    else if (lpbi->biSizeImage < 65536l)
	DecodeRle286(lpbi, pb, prle);
    else
#endif
#endif
    {
	wWidthBytes = (WORD)lpbi->biWidth+3 & ~3;

	x = 0;

	for(;;)
	{
	    cnt = *prle++;
	    b   = *prle++;

	    if (cnt == RLE_ESCAPE)
	    {
		switch (b)
		{
		    case RLE_EOF:
			return;

		    case RLE_EOL:
			pb += wWidthBytes - x;
			x = 0;
			break;

		    case RLE_JMP:
			dx = (WORD)*prle++;
			dy = (WORD)*prle++;

			pb += (DWORD)wWidthBytes * dy + dx;
			x  += dx;

			break;

		    default:
			cnt = b;
			x  += cnt;
			while (cnt-- > 0)
			    *pb++ = *prle++;

			if (b & 1)
			    prle++;

			break;
		}
	    }
	    else
	    {
		x += cnt;

		while (cnt-- > 0)
		    *pb++ = b;
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avifilei.h ===
#include "extra.h"
#include "fileshar.h"
#include "aviidx.h"
#include "buffer.h"
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#define	CFactoryImpl	CI	// Can't handle long exported names
#define	CAVIFileImpl	CF	// Can't handle long exported names
#define	CAVIStreamImpl	CS	// Can't handle long exported names

/* Remove warning of using object during initialization. */
#pragma warning(disable:4355)

/*	-	-	-	-	-	-	-	-	*/

#define	implement	struct
#define	implementations	private

/*
** _StdClassImplementations
** Defines the standard implementations for a class object.
*/

#define	_StdClassImplementations(Impl)	\
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);	\
	STDMETHODIMP_(ULONG) AddRef();	\
	STDMETHODIMP_(ULONG) Release()


/*	-	-	-	-	-	-	-	-	*/

class FAR CAVIFileCF {
public:
    static HRESULT Create(const CLSID FAR& rclsid, REFIID riid, LPVOID FAR* ppv);
private:
    CAVIFileCF(const CLSID FAR& rclsid, IUnknown FAR* FAR* ppUnknown);
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVIFileCF FAR* pAVIFileCF);
    private:
	CAVIFileCF FAR*	m_pAVIFileCF;
	ULONG	m_refs;
    };
    implement CFactoryImpl : IClassFactory {
    public:
	_StdClassImplementations(CFactoryImpl);
	CFactoryImpl(CAVIFileCF FAR* pAVIFileCF);
	STDMETHODIMP CreateInstance(IUnknown FAR* pUnknownOuter, REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP LockServer(BOOL fLock);
    private:
	CAVIFileCF FAR*	m_pAVIFileCF;
    };
public:
    CUnknownImpl	m_Unknown;
    CFactoryImpl	m_Factory;
public:
    CLSID	m_clsid;
};

/*	-	-	-	-	-	-	-	-	*/

class FAR CAVIFile;

class FAR CAVIStream {
public:
    CAVIStream(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
private:
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVIStream FAR* pAVIStream);
    private:
	CAVIStream FAR*	m_pAVIStream;
	ULONG	m_refs;
    };
    implement CAVIStreamImpl : IAVIStream {
    public:
	_StdClassImplementations(CAVIStreamImpl);
	CAVIStreamImpl(CAVIStream FAR* pAVIStream);
	~CAVIStreamImpl();
	STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
	STDMETHODIMP Info        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize);
        STDMETHODIMP_(LONG) FindSample(THIS_ LONG lPos, LONG lFlags);
	STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
				LPVOID lpFormat, LONG FAR *cbFormat);
	STDMETHODIMP SetFormat   (THIS_ LONG lPos,
				LPVOID lpFormat, LONG cbFormat);
	STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
				LPVOID lpBuffer, LONG cbBuffer,
				LONG FAR * plBytes, LONG FAR * plSamples);
	STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
				  LPVOID lpBuffer, LONG cbBuffer,
				  DWORD dwFlags,
				  LONG FAR *plSampWritten,
				  LONG FAR *plBytesWritten);
	STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
	STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
	STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
	STDMETHODIMP Reserved1            (THIS);
	STDMETHODIMP Reserved2            (THIS);
	STDMETHODIMP Reserved3            (THIS);
	STDMETHODIMP Reserved4            (THIS);
	STDMETHODIMP Reserved5            (THIS);
    private:
	void ReadPalette(LONG lPos, LONG lPal, LPRGBQUAD prgb);
	// private functions here?
	CAVIStream FAR*	m_pAVIStream;
    };
    implement CStreamingImpl : IAVIStreaming {
    public:
	_StdClassImplementations(CStreamingImpl);
	CStreamingImpl(CAVIStream FAR* pAVIStream);
	~CStreamingImpl();
	STDMETHODIMP Begin (THIS_
			  LONG  lStart,	
			  LONG  lEnd,	
			  LONG  lRate);
	STDMETHODIMP End   (THIS);
    private:
	// private functions here?
	CAVIStream FAR*	m_pAVIStream;
    };
    struct CMarshalImpl : IMarshal {
    public:
	CMarshalImpl(CAVIStream FAR* pAVIStream);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IMarshal methods ***
	STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPCLSID pCid);
	STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPDWORD pSize);
	STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags);
	STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID FAR* ppv);
	STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
	STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);
	CAVIStream FAR*	m_pAVIStream;
    };
public:
    CUnknownImpl	m_Unknown;
    CAVIStreamImpl	m_AVIStream;
    CMarshalImpl	m_Marshal;
    CStreamingImpl	m_Streaming;
    
public:
    IUnknown FAR*	m_pUnknownOuter;

    // AVIStream Instance data
    AVISTREAMINFO             avistream;      // stream info
    CAVIFile FAR *		pfile;
    int				iStream;

    PAVISTREAM                  paviBase;

    //
    //  stream instance data
    //
    HSHFILE                     hshfile;        // file I/O

    LONG                        lPal;           // last palette change
    RGBQUAD                     argbq[256];     // current palette

    LPVOID                      lpFormat;       // stream format
    LONG                        cbFormat;

    LPVOID                      lpData;         // stream handler data
    LONG                        cbData;

    EXTRA			extra;
    
    PBUFSYSTEM                  pb;

    BOOL                        fInit;

    PSTREAMINDEX                psx;
};

/*	-	-	-	-	-	-	-	-	*/
#define MAXSTREAMS		64


class FAR CAVIFile {
public:
    static HRESULT Create(IUnknown FAR* pUnknownOuter, REFIID riid, LPVOID FAR* ppv);
private:
    CAVIFile(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVIFile FAR* pAVIFile);
    private:
	CAVIFile FAR*	m_pAVIFile;
	ULONG	m_refs;
    };
    implement CAVIFileImpl : IAVIFile {
    public:
	_StdClassImplementations(CAVIFileImpl);
	CAVIFileImpl(CAVIFile FAR* pAVIFile);
	~CAVIFileImpl();
	STDMETHODIMP Open		    (THIS_
					 LPCSTR szFile,
					 UINT mode);
	STDMETHODIMP Info                 (THIS_
					 AVIFILEINFO FAR * pfi,
					 LONG lSize);
	STDMETHODIMP GetStream            (THIS_
					 PAVISTREAM FAR * ppStream,
					 DWORD fccType,
					 LONG lParam);
	STDMETHODIMP CreateStream         (THIS_
					 PAVISTREAM FAR * ppStream,
					 AVISTREAMINFO FAR * psi);
	STDMETHODIMP Save                 (THIS_
					 LPCSTR szFile,
					 AVICOMPRESSOPTIONS FAR *lpOptions,
					 AVISAVECALLBACK lpfnCallback);
	STDMETHODIMP WriteData            (THIS_
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData);
	STDMETHODIMP ReadData             (THIS_
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR *lpcbData);
	STDMETHODIMP EndRecord            (THIS);
	STDMETHODIMP Reserved1            (THIS);
	STDMETHODIMP Reserved2            (THIS);
	STDMETHODIMP Reserved3            (THIS);
	STDMETHODIMP Reserved4            (THIS);
	STDMETHODIMP Reserved5            (THIS);
    private:
	// private functions here?
	CAVIFile FAR*	m_pAVIFile;
    };
    struct CMarshalImpl : IMarshal {
    public:
	CMarshalImpl(CAVIFile FAR* pAVIFile);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IMarshal methods ***
	STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPCLSID pCid);
	STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPDWORD pSize);
	STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags);
	STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID FAR* ppv);
	STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
	STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);
	CAVIFile FAR*	m_pAVIFile;
    };
public:
    CUnknownImpl	m_Unknown;
    CAVIFileImpl	m_AVIFile;
    CMarshalImpl	m_Marshal;
public:
    IUnknown FAR*	m_pUnknownOuter;
    
    //
    //  AVIFile instance data
    //
    MainAVIHeader FARSTRUCT     avihdr;         // file info
    LONG			lHeaderSize;
    char			achFile[260];
    UINT			mode;
    HSHFILE                     hshfile;          // file I/O
    LONG			lDataListStart;
    BOOL			fInRecord;
    LONG			lRecordIndex;
    MMCKINFO			ckRecord;
    LONG			lWriteLoc;
    EXTRA			extra;
    BOOL			fDirty;
    CAVIStream FAR *            ps[MAXSTREAMS];

    PAVIINDEX                   px;         // the index
    PBUFSYSTEM                  pb;
};


/*
** The usage counter keeps track of the overall usage of objects based on
** implementations provided by the component. This allows one to determine
** when the implementation is no longer in use.
*/

extern UINT	uUseCount;
extern BOOL	fLocked;

/*	-	-	-	-	-	-	-	-	*/


DEFINE_AVIGUID(CLSID_AVIFile,           0x00020000, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avigraph.c ===
#include <win32.h>
#include "avifile.h"
#include "debug.h"

// !!! Note: doesn't take AVI File overhead into account
// !!! Doesn't take padding into account!


// AVIDataSize:
// Calculates the amount of data in the given PAVISTREAM
// from time msStart to msStart + ms
LONG AVIDataSize(PAVISTREAM ps, LONG msStart, LONG ms) 
{
    LONG    lBytes;
    LONG    l;

    LONG    sampStart;
    LONG    sampEnd;
    LONG    samp;

    AVISTREAMINFO sinfo;
    HRESULT hr;
    
    sampStart = AVIStreamTimeToSample(ps, msStart);
    sampEnd = AVIStreamTimeToSample(ps, msStart + ms);

    AVIStreamInfo(ps, &sinfo, sizeof(sinfo));
    
    if (sinfo.dwSampleSize > 0) {
	hr = AVIStreamRead(ps,
			   sampStart,
			   sampEnd - sampStart,
			   NULL, 0,
			   &lBytes, &l);

	if (hr != NOERROR)
	    return 0;
	    
	if (l != sampEnd - sampStart) {
            DPF("Ack: wrong number of samples!\n");
	}
    } else {
	lBytes = 0;

	for (samp = sampStart; samp < sampEnd; samp++) {
	    hr = AVIStreamSampleSize(ps, samp, &l);

	    if (hr != NOERROR)
		return 0;
	    
	    lBytes += l;
	}
    }
    
    return lBytes;
}

#define MAXSTREAMS  64

#define TIMEINT	    250
#define TIMELEN	    1000

STDAPI CalculateFileDataRate(PAVIFILE pf, LONG FAR *plMaxBytesPerSec)
{
    PAVISTREAM	aps[MAXSTREAMS];
    LONG	alMaxData[MAXSTREAMS];
    AVIFILEINFO	finfo;
    int		stream;
    HRESULT	hr;
    LONG	msecLength = 0;
    LONG	l;
    LONG	lStart;
    LONG	lDataSize;
    LONG	lMaxDataSize = 0;

    AVIFileInfo(pf, &finfo, sizeof(finfo));

    for (stream = 0; stream < (int) finfo.dwStreams; stream++) {
	hr = AVIFileGetStream(pf, &aps[stream], 0, stream);

	if (hr != NOERROR) {
	    while (--stream >= 0)
		AVIStreamRelease(aps[stream]);

	    return hr;
	}
	
	l = AVIStreamEndTime(aps[stream]);
	msecLength = max(l, msecLength);
	alMaxData[stream] = 0;
    }

    lStart = 0;

    DPF("Time\t\t\tData Rate\n");
    do {
	lStart += TIMEINT;
	
	lDataSize = 0;
	
	
	for (stream = 0; stream < (int) finfo.dwStreams; stream++) {
	    l = AVIDataSize(aps[stream], lStart, TIMELEN);

	    lDataSize += l;
	    
	    alMaxData[stream] = max(alMaxData[stream], l);
	}

	lMaxDataSize = max(lDataSize, lMaxDataSize);

#ifdef DEBUG
	if (lStart < 50 * TIMEINT) {  // print at most 50 debug lines....
	    DPF("%lu\t\t\t%lu\n", lStart, muldiv32(lDataSize, 1000, TIMELEN));
	}
#endif
    } while (lStart < msecLength);

    *plMaxBytesPerSec = muldiv32(lMaxDataSize, 1000, TIMELEN);

    DPF("Max data rate for file: %ld\n", muldiv32(lMaxDataSize, 1000, TIMELEN));
    for (stream = 0; stream < (int) finfo.dwStreams; stream++) {
	DPF("Max data rate for stream %u: %ld\n", stream, muldiv32(alMaxData[stream], 1000, TIMELEN));
	AVIStreamRelease(aps[stream]);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avifps.cpp ===
// avifps.cpp - proxy and stub code for IAVIFile & IAVIStream
//
//
//  Copyright (c) 1993 Microsoft Corporation.  All Rights Reserved.
//
// History:
//  Created by DavidMay		6/19/93
//
//
// What's in this file:
//
//  Code to enable "standard marshalling" of the IAVIFile and IAVIStream
//  interfaces, consisting of the following classes:
//
//  CPSFactory, derived from IPSFactory:
//	Proxy/stub factory, called from DllGetClassObject to create
//	the other classes.
//
//  CPrxAVIStream, derived from IAVIStream:
//	This class serves as a stand-in for the interface in the app that's
//	calling it.  Uses RPC to communicate with....
//
//  CStubAVIStream, derived from IRpcStubBuffer:
//	This class in the called app receives requests from the proxy
//	and forwards them to the actual implementation of the IAVIStream.
//
//  CPrxAVIFile & CStubAVIFile, just like the stream versions.
//
//
//  Also included:
//  The function TaskHasExistingProxies can be used by an application
//  before exiting to check whether any of its objects are being used
//  by other applications.  This is done by keeping track of what active
//  stubs exist within a given task context.
//

#include <win32.h>
#pragma warning(disable:4355)
#include "avifile.h"
#include "avifps.h"
#include "debug.h"

#ifndef WIN32
typedef POINT POINTS;
#endif

// when thunking between 16-bit ansi and 32-bit unicode apps, the
// AVISTREAMINFO and AVIFILEINFO structures are different. What is transmitted
// is a common format that includes space for both unicode and ansi strings.
// ansi apps will not send or use the unicode strings. unicode apps will send
// both.
typedef struct _PS_STREAMINFO {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    POINTS		ptFrameTopLeft;
    POINTS		ptFrameBottomRight;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
    DWORD		bHasUnicode;
    WCHAR		szUnicodeName[64];
} PS_STREAMINFO, FAR * LPPS_STREAMINFO;

typedef struct _PS_FILEINFO {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
    DWORD		bHasUnicode;
    WCHAR		szUnicodeType[64];	
} PS_FILEINFO, FAR * LPPS_FILEINFO;



#ifndef WIN32
//
// These constants are defined in the 32-bit UUID.LIB, but not
// in any 16-bit LIB.  They are stolen here from the .IDL files
// in the TYPES project.
//
extern "C" {
const IID IID_IRpcStubBuffer = {0xD5F56AFC,0x593b,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
const IID IID_IRpcProxyBuffer = {0xD5F56A34,0x593b,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
const IID IID_IPSFactoryBuffer = {0xD5F569D0,0x593b,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
}
#endif

// functions for proxy/stub usage tracking; see end of this file.
void UnregisterStubUsage(void);
void RegisterStubUsage(void);
extern "C" BOOL FAR TaskHasExistingProxies(void);



#if 0	// this function is actually in classobj.cpp,
// but if this were a separate proxy/stub DLL, it would look like this.
STDAPI DllGetClassObject(const CLSID FAR&	rclsid,
			 const IID FAR&	riid,
			 void FAR* FAR*	ppv)
{
    HRESULT	hresult;

    DPF("DllGetClassObject\n");

    if (rclsid == CLSID_AVIStreamPS) {
	return (*ppv = (LPVOID)new CPSFactory()) != NULL
		? NOERROR : ResultFromScode(E_OUTOFMEMORY);
    } else {
	return ResultFromScode(E_UNEXPECTED);
    }
}
#endif

/*
 *	IMPLEMENTATION of CPSFactory
 *
 *
 *  Note: This Factory supports proxies and stubs for two separate
 *  interfaces, IID_IAVIFile and IID_IAVIStream.
 */

CPSFactory::CPSFactory(void)
{
    m_refs = 1;
}



// controlling unknown for PSFactory
STDMETHODIMP CPSFactory::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPSFactoryBuffer)
    {
	*ppv = this;
	++m_refs;
	return NOERROR;
    }
    else
    {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CPSFactory::AddRef(void)
{
    return ++m_refs;
}

STDMETHODIMP_(ULONG) CPSFactory::Release(void)
{
    if (--m_refs == 0)
    {
	delete this;
	return 0;
    }

    return m_refs;
}


// create proxy for given interface
STDMETHODIMP CPSFactory::CreateProxy(IUnknown FAR* pUnkOuter, REFIID iid,
	IRpcProxyBuffer FAR* FAR* ppProxy, void FAR* FAR* ppv)
{
    IRpcProxyBuffer FAR* pProxy;
    HRESULT     hresult;

    *ppProxy = NULL;
    *ppv = NULL;

    if (pUnkOuter == NULL)
	return ResultFromScode(E_INVALIDARG);

    if (iid == IID_IAVIStream) {
	if ((pProxy = CPrxAVIStream::Create(pUnkOuter)) == NULL)
	    return ResultFromScode(E_OUTOFMEMORY);
    } else if (iid == IID_IAVIFile) {
	if ((pProxy = CPrxAVIFile::Create(pUnkOuter)) == NULL)
	    return ResultFromScode(E_OUTOFMEMORY);
    } else
	return ResultFromScode(E_NOINTERFACE);

    hresult = pProxy->QueryInterface(iid, ppv);

    if (hresult == NOERROR)
	*ppProxy = pProxy;			// transfer ref to caller
    else
	pProxy->Release();			// free proxy just created

    return hresult;
}



// create stub for given interface
STDMETHODIMP CPSFactory::CreateStub(REFIID iid, IUnknown FAR* pUnkServer, IRpcStubBuffer FAR* FAR* ppStub)
{
    if (iid == IID_IAVIStream) {
	return CStubAVIStream::Create(pUnkServer, ppStub);
    } else if (iid == IID_IAVIFile) {
	return CStubAVIFile::Create(pUnkServer, ppStub);
    } else
	return ResultFromScode(E_NOINTERFACE);
}





/*
 *  IMPLEMENTATION of CPrxAVIStream
 *
 */


// create unconnected CPrxAVIStream; return controlling IProxy/IUnknokwn FAR*
IRpcProxyBuffer FAR* CPrxAVIStream::Create(IUnknown FAR* pUnkOuter)
{
    CPrxAVIStream FAR* pPrxAVIStream;

    if ((pPrxAVIStream = new CPrxAVIStream(pUnkOuter)) == NULL)
	return NULL;

    return &pPrxAVIStream->m_Proxy;
}


CPrxAVIStream::CPrxAVIStream(IUnknown FAR* pUnkOuter) : m_Proxy(this)
{
    // NOTE: could assert here since we should always be aggregated
    if (pUnkOuter == NULL)
	pUnkOuter = &m_Proxy;

    m_refs = 1;
    m_pUnkOuter = pUnkOuter;
    m_pRpcChannelBuffer = NULL;
    m_sh.fccType = 0;

    DPF("PrxStream %lx: Usage++=%lx\n", (DWORD) (LPVOID) this, 1L);
}


CPrxAVIStream::~CPrxAVIStream(void)
{
    m_Proxy.Disconnect();
}
		

// Methods for controlling unknown
STDMETHODIMP CPrxAVIStream::CProxyImpl::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IRpcProxyBuffer)
        *ppv = (void FAR *)this;
    else if (iid ==  IID_IAVIStream)
        *ppv = (void FAR *)m_pPrxAVIStream;
    else {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }

    // simplest way to be correct: always addref the pointer we will return;
    // easy since all interfaces here are derived from IUnknown.
    ((IUnknown FAR*) *ppv)->AddRef();

    return NOERROR;
}

STDMETHODIMP_(ULONG) CPrxAVIStream::CProxyImpl::AddRef(void)
{
    return ++m_pPrxAVIStream->m_refs;
}

STDMETHODIMP_(ULONG) CPrxAVIStream::CProxyImpl::Release(void)
{
    if (--m_pPrxAVIStream->m_refs == 0)
    {
	delete m_pPrxAVIStream;
	return 0;
    }
    return m_pPrxAVIStream->m_refs;
}


// connect proxy to channel given
STDMETHODIMP CPrxAVIStream::CProxyImpl::Connect(IRpcChannelBuffer FAR* pRpcChannelBuffer)
{
    if (m_pPrxAVIStream->m_pRpcChannelBuffer != NULL)
	return ResultFromScode(E_UNEXPECTED);

    if (pRpcChannelBuffer == NULL)
	return ResultFromScode(E_INVALIDARG);

    (m_pPrxAVIStream->m_pRpcChannelBuffer = pRpcChannelBuffer)->AddRef();
    return NOERROR;
}


// disconnect proxy from any current channel
STDMETHODIMP_(void) CPrxAVIStream::CProxyImpl::Disconnect(void)
{
    if (m_pPrxAVIStream->m_pRpcChannelBuffer)
    {
	m_pPrxAVIStream->m_pRpcChannelBuffer->Release();
	m_pPrxAVIStream->m_pRpcChannelBuffer = NULL;
    }
}



// IUnknown methods for external interface(s); always delegate
STDMETHODIMP CPrxAVIStream::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    return m_pUnkOuter->QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CPrxAVIStream::AddRef(void)
{
    DPF("PrxStream %lx: Usage++=%lx\n", (DWORD) (LPVOID) this, m_refs + 1);
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CPrxAVIStream::Release(void)
{
    DPF("PrxStream %lx: Usage--=%lx\n", (DWORD) (LPVOID) this, m_refs - 1);
    return m_pUnkOuter->Release();
}



// IAVIStream interface methods

STDMETHODIMP CPrxAVIStream::Create(LONG lParam1, LONG lParam2)
{
    return ResultFromScode(E_NOTIMPL);
}

#ifdef WIN32
STDMETHODIMP CPrxAVIStream::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
#else
STDMETHODIMP CPrxAVIStream::Info(AVISTREAMINFO FAR * psi, LONG lSize)
#endif
{
    HRESULT hrMarshal;
    HRESULT hrMethod = NOERROR;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;
    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    if (pChannel == NULL)
	return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    //
    // NOTE: We take advantage here of the fact that we assume the
    // stream is read-only and not being changed on the other end!
    //
    // To avoid some intertask calls, we assume that the result
    // of the Info() method will not change.
    //
    if (m_sh.fccType == 0) {

	// we might be talking to 16 or 32-bit stub, so we need to
	// exchange a common (superset) format and pick out the bits we need.

	// format in: lSize
	// format out: PS_STREAMINFO, hrMethod
	Message.cbBuffer = sizeof(lSize);
	Message.iMethod = IAVISTREAM_Info;
	
	if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
	    goto ErrExit;

	((DWORD FAR *)Message.Buffer)[0] = sizeof(PS_STREAMINFO);
	
	if ((hrMarshal = pChannel->SendReceive(&Message,(ULONG*) &hrMethod)) != NOERROR) {
	    ;
ErrExit:
	    return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
	}

	hrMethod = ((HRESULT FAR *)Message.Buffer)[0];
	PS_STREAMINFO FAR * psinfo = (PS_STREAMINFO FAR *)
			((LPBYTE)Message.Buffer + sizeof(HRESULT));

	// get the bits we want
	m_sh.fccType 	= psinfo->fccType;
	m_sh.fccHandler = psinfo->fccHandler;
	m_sh.dwFlags 	= psinfo->dwFlags;        /* Contains AVITF_* flags */
	m_sh.dwCaps 	= psinfo->dwCaps;
	m_sh.wPriority 	= psinfo->wPriority;
	m_sh.wLanguage 	= psinfo->wLanguage;
	m_sh.dwScale 	= psinfo->dwScale;
	m_sh.dwRate 	= psinfo->dwRate; /* dwRate / dwScale == samples/second */
	m_sh.dwStart 	= psinfo->dwStart;
	m_sh.dwLength 	= psinfo->dwLength; /* In units above... */
	m_sh.dwInitialFrames = psinfo->dwInitialFrames;
	m_sh.dwSuggestedBufferSize = psinfo->dwSuggestedBufferSize;
	m_sh.dwQuality 	= psinfo->dwQuality;
	m_sh.dwSampleSize = psinfo->dwSampleSize;

	// RECTs are different sizes, so use POINTS (WORD point)
	m_sh.rcFrame.top = psinfo->ptFrameTopLeft.y;	
	m_sh.rcFrame.left = psinfo->ptFrameTopLeft.x;
	m_sh.rcFrame.bottom = psinfo->ptFrameBottomRight.y;	
	m_sh.rcFrame.right = psinfo->ptFrameBottomRight.x;

    	m_sh.dwEditCount = psinfo->dwEditCount;
    	m_sh.dwFormatChangeCount = psinfo->dwFormatChangeCount;

#ifdef WIN32	
	// use unicode if we've been sent it
	if (psinfo->bHasUnicode) {
	    _fmemcpy(m_sh.szName, psinfo->szUnicodeName, sizeof(m_sh.szName));
	} else {
	    // need ansi->unicode thunk
	    MultiByteToWideChar(
	    	CP_ACP, 0,
		psinfo->szName,
	     	-1,
		m_sh.szName,
		NUMELMS(m_sh.szName));
	}
#else
    	// we only use the ansi which is always sent
	_fmemcpy(m_sh.szName, psinfo->szName, sizeof(m_sh.szName));
#endif

	pChannel->FreeBuffer(&Message);
    }

    _fmemcpy(psi, &m_sh, min((int) lSize, sizeof(m_sh)));

    return hrMethod;
}


STDMETHODIMP_(LONG) CPrxAVIStream::FindSample(LONG lPos, LONG lFlags)
{
    HRESULT hrMarshal;
    HRESULT hrMethod;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;
    LONG    lResult;

    if (pChannel == NULL)
	return -1; // !!! ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    // format in: lPos, lFlags
    // format out: hrMethod, lResult
    Message.cbBuffer = sizeof(lPos) + sizeof(lFlags);
    Message.iMethod = IAVISTREAM_FindSample;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
	goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = lPos;
    ((DWORD FAR *)Message.Buffer)[1] = lFlags;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
	goto ErrExit;
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];
    lResult = ((LONG FAR *)Message.Buffer)[1];

    pChannel->FreeBuffer(&Message);

    DPF("Proxy: FindSample (%ld) returns (%ld)\n", lPos, lResult);
    return lResult; // !!! hrMethod;

ErrExit:
    DPF("Proxy: FindSample returning error...\n");
    return -1; // !!! PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
}


STDMETHODIMP CPrxAVIStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    HRESULT hrMarshal;
    HRESULT hrMethod;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;

    if (pChannel == NULL)
	return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    // check that size is 0 if pointer is null
    if (lpFormat == NULL) {
	*lpcbFormat = 0;
    }

    // format in: dw, *lpcbFormat
    // format out: hrMethod, *lpcbFormat, format data

    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    Message.cbBuffer = sizeof(lPos) + sizeof(*lpcbFormat);
    Message.iMethod = IAVISTREAM_ReadFormat;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
	goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = lPos;
    ((DWORD FAR *)Message.Buffer)[1] = lpFormat ? *lpcbFormat : 0;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
	goto ErrExit;
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

    if (lpFormat && *lpcbFormat)
	hmemcpy(lpFormat, (LPBYTE) Message.Buffer + 2*sizeof(DWORD),
		min(*lpcbFormat, (long) ((DWORD FAR *) Message.Buffer)[1]));

    // write the size last, so we don't copy more than user's buffer
    *lpcbFormat = ((DWORD FAR *)Message.Buffer)[1];

    pChannel->FreeBuffer(&Message);

    return hrMethod;

ErrExit:
    return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
}


STDMETHODIMP CPrxAVIStream::Read(
                 LONG       lStart,
                 LONG       lSamples,
                 LPVOID     lpBuffer,
                 LONG       cbBuffer,
                 LONG FAR * plBytes,
                 LONG FAR * plSamples)
{
    HRESULT hrMarshal;
    HRESULT hrMethod;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;
    LONG    lTemp;

    if (pChannel == NULL)
	return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    if (lpBuffer == NULL)
	cbBuffer = 0;

    // format on input: lPos, lLength, cb
    // format on output: hresult, samples, cb, frame
    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    Message.cbBuffer = sizeof(lStart) + sizeof(lSamples) + sizeof(cbBuffer);
    Message.iMethod = IAVISTREAM_Read;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
	goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = lStart;
    ((DWORD FAR *)Message.Buffer)[1] = lSamples;
    ((DWORD FAR *)Message.Buffer)[2] = lpBuffer ? cbBuffer : 0;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
	goto ErrExit;
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

    lTemp = ((DWORD FAR *)Message.Buffer)[1];
    if (plBytes)
	*plBytes = lTemp;

    if (plSamples)
	*plSamples = ((DWORD FAR *)Message.Buffer)[2];

    if (lpBuffer && lTemp)
	hmemcpy(lpBuffer, (LPBYTE) Message.Buffer + 3*sizeof(DWORD), lTemp);

    pChannel->FreeBuffer(&Message);

    return hrMethod;

ErrExit:
    return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
}

//
// All of the writing-related messages are not remoted....
//
STDMETHODIMP CPrxAVIStream::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Write(LONG lStart,
				  LONG lSamples,
				  LPVOID lpData,
				  LONG cbData,
				  DWORD dwFlags,
				  LONG FAR *plSampWritten,
				  LONG FAR *plBytesWritten)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Delete(LONG lStart,LONG lSamples)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::ReadData(DWORD ckid, LPVOID lp, LONG FAR *lpcb)
{
    // !!! This should really be remoted!
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::WriteData(DWORD ckid, LPVOID lp, LONG cb)
{
    return ResultFromScode(E_NOTIMPL);
}


#ifdef WIN32
STDMETHODIMP CPrxAVIStream::SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    return ResultFromScode(E_NOTIMPL);
}

#else
STDMETHODIMP CPrxAVIStream::Reserved1(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved2(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved3(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved4(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved5(void)
{
    return ResultFromScode(E_NOTIMPL);
}

#endif


/*
 *  IMPLEMENTATION of CStubAVIStream
 *	
 */

// create connected interface stub
HRESULT CStubAVIStream::Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub)
{
    CStubAVIStream FAR* pStubAVIStream;

    *ppStub = NULL;

    if ((pStubAVIStream = new CStubAVIStream()) == NULL)
	return ResultFromScode(E_OUTOFMEMORY);

    HRESULT hresult;
    if ((hresult = pStubAVIStream->Connect(pUnkObject)) != NOERROR)
    {
	pStubAVIStream->Release();
	return hresult;
    }

    *ppStub = pStubAVIStream;
    return NOERROR;
}


CStubAVIStream::CStubAVIStream(void)
{
    m_refs	 = 1; /// !!! ??? 0
    DPF("StubStream %lx: Usage++=%lx  (C)\n", (DWORD) (LPVOID) this, 1L);
    m_pAVIStream = NULL;
    RegisterStubUsage();
}


CStubAVIStream::~CStubAVIStream(void)
{
    UnregisterStubUsage();
    Disconnect();
}


// controling unknown methods for interface stub
STDMETHODIMP CStubAVIStream::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (iid == IID_IUnknown || iid == IID_IRpcStubBuffer)
    {
	*ppv = this;
	DPF("StubStream %lx: Usage++=%lx  (QI)\n", (DWORD) (LPVOID) this, m_refs + 1);
	++m_refs;
	return NOERROR;
    }
    else
    {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CStubAVIStream::AddRef(void)
{
    DPF("StubStream %lx: Usage++=%lx\n", (DWORD) (LPVOID) this, m_refs + 1);
    return ++m_refs;
}

STDMETHODIMP_(ULONG) CStubAVIStream::Release(void)
{
    DPF("StubStream %lx: Usage--=%lx\n", (DWORD) (LPVOID) this, m_refs - 1);
    if (--m_refs == 0)
    {
	if (m_pAVIStream) {
	    DPF("Releasing stream in funny place!\n");
	    m_pAVIStream->Release();
	    m_pAVIStream = NULL;
	}
	delete this;
	return 0;
    }

    return m_refs;
}


// connect interface stub to server object
STDMETHODIMP CStubAVIStream::Connect(IUnknown FAR* pUnkObj)
{
    HRESULT	hr;

    if (m_pAVIStream)
	// call Disconnect first
	return ResultFromScode(E_UNEXPECTED);

    if (pUnkObj == NULL)
	return ResultFromScode(E_INVALIDARG);
		
    // NOTE: QI ensures out param is zero if error
    hr = pUnkObj->QueryInterface(IID_IAVIStream, (LPVOID FAR*)&m_pAVIStream);

    DPF("CStubAVIStream::Connect: Result = %lx, stream = %lx\n", (DWORD) (LPVOID) hr, (DWORD) m_pAVIStream);
    return hr;
}


// disconnect interface stub from server objec
STDMETHODIMP_(void) CStubAVIStream::Disconnect(void)
{
    DPF("CStubAVIStream::Disconnect\n");
    if (m_pAVIStream) {
	DPF("Disconnect: Releasing stream\n");
	m_pAVIStream->Release();
	m_pAVIStream = NULL;
    }
}


// remove method call
STDMETHODIMP CStubAVIStream::Invoke
	(RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel)
{
    HRESULT     hresult;
    HRESULT	hrMethod;

    DPF("!AVISTREAM: Invoke: ");

    if (!m_pAVIStream) {
	DPF("!No stream!\n");
	return ResultFromScode(RPC_E_UNEXPECTED);
    }

#if 0
    if (iid != IID_IAVIStream) {
	DPF("!Wrong interface\n");

	return ResultFromScode(RPC_E_UNEXPECTED);
    }
#endif

    switch (pMessage->iMethod)
    {
	case IAVISTREAM_Info:
	    // format on input: lSize
	    // format on output: hresult, PS_STREAMINFO
	{
	    DWORD lSize;
#ifdef WIN32
	    AVISTREAMINFOW si;
#else
	    AVISTREAMINFO si;
#endif

	    DPF("!Info\n");

	    // need to send a common ansi/unicode version with both strings
	    PS_STREAMINFO psinfo;
	    hrMethod = m_pAVIStream->Info(&si, sizeof(si));

	    // copy all members
	    psinfo.fccType	= si.fccType;
	    psinfo.fccHandler	= si.fccHandler;
	    psinfo.dwFlags	= si.dwFlags;        /* Contains AVITF_* flags */
	    psinfo.dwCaps	= si.dwCaps;
	    psinfo.wPriority	= si.wPriority;
	    psinfo.wLanguage	= si.wLanguage;
	    psinfo.dwScale	= si.dwScale;
	    psinfo.dwRate	= si.dwRate; /* dwRate / dwScale == samples/second */
	    psinfo.dwStart	= si.dwStart;
	    psinfo.dwLength	= si.dwLength; /* In units above... */
	    psinfo.dwInitialFrames	= si.dwInitialFrames;
	    psinfo.dwSuggestedBufferSize	= si.dwSuggestedBufferSize;
	    psinfo.dwQuality	= si.dwQuality;
	    psinfo.dwSampleSize	= si.dwSampleSize;
	    psinfo.dwEditCount	= si.dwEditCount;
	    psinfo.dwFormatChangeCount	= si.dwFormatChangeCount;

	    // RECT is different size, so use POINTS
	    psinfo.ptFrameTopLeft.x = (short) si.rcFrame.left;
	    psinfo.ptFrameTopLeft.y = (short) si.rcFrame.top;
	    psinfo.ptFrameBottomRight.x = (short) si.rcFrame.right;
	    psinfo.ptFrameBottomRight.y = (short) si.rcFrame.bottom;

#ifdef WIN32	
	    // send both UNICODE and ansi
	    hmemcpy(psinfo.szUnicodeName, si.szName, sizeof(psinfo.szUnicodeName));
	    psinfo.bHasUnicode = TRUE;
	    WideCharToMultiByte(CP_ACP, 0,
	    	si.szName,
		-1,
		psinfo.szName,
		NUMELMS(psinfo.szName),
		NULL, NULL);
#else
    	    // just send ansi version for 16-bit stub
	    psinfo.bHasUnicode = FALSE;
	    hmemcpy(psinfo.szName, si.szName, sizeof(si.szName));
#endif

	    lSize = ((DWORD FAR *)pMessage->Buffer)[0];


	    pMessage->cbBuffer = lSize + sizeof(hrMethod);
	
	    if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
		return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

	    ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;

	    hmemcpy((LPBYTE) pMessage->Buffer + sizeof(hrMethod),
		    &psinfo,
		    lSize);
		
	    return NOERROR;
	}

	case IAVISTREAM_FindSample:
	    // format on input: lPos, lFlags
	    // format on output: hResult, lResult
	{
	    LONG lPos, lFlags, lResult;

	    lPos = ((DWORD FAR *)pMessage->Buffer)[0];
	    lFlags = ((DWORD FAR *)pMessage->Buffer)[1];

	    DPF("!FindSample (%ld)\n", lPos);
	
	    lResult = m_pAVIStream->FindSample(lPos, lFlags);

	    hrMethod = 0; // !!!

	    pMessage->cbBuffer = sizeof(lResult) + sizeof(hrMethod);
	
	    if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
		return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

	    ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;
	    ((DWORD FAR *)pMessage->Buffer)[1] = lResult;

	    return NOERROR;
	}

	case IAVISTREAM_ReadFormat:
	    // format on input: lPos, cbFormat
	    // format on output: hresult, cbFormat, format
	{

	    LONG cbIn;
	    LONG cb;
	    DWORD lPos;
	    LPVOID lp;

	    lPos = ((DWORD FAR *)pMessage->Buffer)[0];
	    cb = cbIn = ((DWORD FAR *)pMessage->Buffer)[1];
	
	    DPF("!ReadFormat (%ld)\n", lPos);
	
	    pMessage->cbBuffer = sizeof(cbIn) + cbIn + sizeof(hrMethod);
	
	    if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
		return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

	    lp = cbIn ? (LPBYTE) pMessage->Buffer + 2 * sizeof(DWORD) : NULL;
	
	    hrMethod = m_pAVIStream->ReadFormat(lPos, lp, &cb);

	    ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;
	    ((DWORD FAR *)pMessage->Buffer)[1] = cb;
	    pMessage->cbBuffer = sizeof(cbIn) + sizeof(hrMethod) +
				 ((cb && cbIn) ? cb : 0);

	    return NOERROR;
	}

	case IAVISTREAM_Read:
	    // format on input: lPos, lSamples, cb
	    // format on output: hresult, samples, cb, frame
	{

	    LONG cb;
	    LONG lPos, lSamples;
	    LPVOID lp;


	    lPos = ((DWORD FAR *)pMessage->Buffer)[0];
	    lSamples = ((DWORD FAR *)pMessage->Buffer)[1];
	    cb = ((DWORD FAR *)pMessage->Buffer)[2];
	
	    DPF("!Read (%ld, %ld) ", lPos, lSamples);

	    pMessage->cbBuffer = 3 * sizeof(DWORD) + cb;
	
	    if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
		return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

	    lp = cb ? (LPBYTE) pMessage->Buffer + 3 * sizeof(DWORD) : NULL;

            DPF("! %ld bytes ");

	    hrMethod = m_pAVIStream->Read(lPos, lSamples, lp, cb, &cb, &lSamples);

            DPF("! -> %ld bytes\n");

	    ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;
	    ((DWORD FAR *)pMessage->Buffer)[1] = cb;
	    ((DWORD FAR *)pMessage->Buffer)[2] = lSamples;

	    return NOERROR;
	}

	default:
	    // unknown method
	
	    DPF("!Unknown method (%d)\n", pMessage->iMethod);

	    return ResultFromScode(RPC_E_UNEXPECTED);
    }
}


// return TRUE if we support given interface
STDMETHODIMP_(IRpcStubBuffer FAR *) CStubAVIStream::IsIIDSupported(REFIID iid)
{
    // if we are connected, we have already checked for this interface;
    // if we are not connected, it doesn't matter.
    return iid == IID_IAVIStream ? (IRpcStubBuffer *) this : 0;
}


// returns number of refs we have to object
STDMETHODIMP_(ULONG) CStubAVIStream::CountRefs(void)
{
    // return 1 if connected; 0 if not.
    return m_pAVIStream != NULL;
}

STDMETHODIMP CStubAVIStream::DebugServerQueryInterface(LPVOID FAR *ppv)
{
    *ppv = m_pAVIStream;

    if (!m_pAVIStream) {
	DPF("!No stream!\n");
	return ResultFromScode(E_UNEXPECTED);
    }

    return NOERROR;
}

STDMETHODIMP_(void) CStubAVIStream::DebugServerRelease(LPVOID pv)
{


}




/*
 *  IMPLEMENTATION of CPrxAVIFile
 *
 */


// create unconnected CPrxAVIFile; return controlling IProxy/IUnknokwn FAR*
IRpcProxyBuffer FAR* CPrxAVIFile::Create(IUnknown FAR* pUnkOuter)
{
    CPrxAVIFile FAR* pPrxAVIFile;

    if ((pPrxAVIFile = new CPrxAVIFile(pUnkOuter)) == NULL)
		return NULL;

    return &pPrxAVIFile->m_Proxy;
}


CPrxAVIFile::CPrxAVIFile(IUnknown FAR* pUnkOuter) : m_Proxy(this)
{
    // NOTE: could assert here since we should always be aggregated
    if (pUnkOuter == NULL)
	pUnkOuter = &m_Proxy;

    m_refs = 1;
    m_pUnkOuter = pUnkOuter;
    m_pRpcChannelBuffer = NULL;
    m_fi.dwStreams = 0;
}


CPrxAVIFile::~CPrxAVIFile(void)
{
    m_Proxy.Disconnect();
}


// Methods for controlling unknown
STDMETHODIMP CPrxAVIFile::CProxyImpl::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IRpcProxyBuffer)
	*ppv = (void FAR *)this;
    else if (iid ==  IID_IAVIFile)
	*ppv = (void FAR *)m_pPrxAVIFile;
    else
    {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }

    // simplest way to be correct: always addref the pointer we will return;
    // easy since all interfaces here are derived from IUnknown.
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CPrxAVIFile::CProxyImpl::AddRef(void)
{
    return ++m_pPrxAVIFile->m_refs;
}

STDMETHODIMP_(ULONG) CPrxAVIFile::CProxyImpl::Release(void)
{
    if (--m_pPrxAVIFile->m_refs == 0)
    {
	delete m_pPrxAVIFile;
	return 0;
    }
    return m_pPrxAVIFile->m_refs;
}


// connect proxy to channel given
STDMETHODIMP CPrxAVIFile::CProxyImpl::Connect(IRpcChannelBuffer FAR* pChannelChannelBuffer)
{
    if (m_pPrxAVIFile->m_pRpcChannelBuffer != NULL)
	return ResultFromScode(E_UNEXPECTED);

    if (pChannelChannelBuffer == NULL)
	return ResultFromScode(E_INVALIDARG);

    (m_pPrxAVIFile->m_pRpcChannelBuffer = pChannelChannelBuffer)->AddRef();
    return NOERROR;
}


// disconnect proxy from any current channel
STDMETHODIMP_(void) CPrxAVIFile::CProxyImpl::Disconnect(void)
{
    if (m_pPrxAVIFile->m_pRpcChannelBuffer)
    {
	m_pPrxAVIFile->m_pRpcChannelBuffer->Release();
	m_pPrxAVIFile->m_pRpcChannelBuffer = NULL;
    }
}



// IUnknown methods for external interface(s); always delegate
STDMETHODIMP CPrxAVIFile::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    return m_pUnkOuter->QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CPrxAVIFile::AddRef(void)
{
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CPrxAVIFile::Release(void)
{
    return m_pUnkOuter->Release();
}



// IAVIFile interface methods

#ifdef WIN32
STDMETHODIMP CPrxAVIFile::Info(AVIFILEINFOW FAR * psi, LONG lSize)
#else
STDMETHODIMP CPrxAVIFile::Info(AVIFILEINFO FAR * psi, LONG lSize)
#endif
{
    HRESULT hrMarshal;
    HRESULT hrMethod = NOERROR;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;

    if (pChannel == NULL)
	return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    if (m_fi.dwStreams == 0) {
	RPCOLEMESSAGE Message;

	_fmemset(&Message, 0, sizeof(Message));

	// format in: lSize
	// format out: hrMethod, PS_FILEINFO
	Message.cbBuffer = sizeof(lSize);
	Message.iMethod = IAVIFILE_Info;
	
	if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIFile)) != NOERROR)
	    goto ErrExit;

	((DWORD FAR *)Message.Buffer)[0] = sizeof(PS_FILEINFO);
	
	if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
	    ;
ErrExit:
	    return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
	}

	hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

	PS_FILEINFO FAR * psinfo = (PS_FILEINFO FAR *)
			((LPBYTE)Message.Buffer + sizeof(HRESULT));

	// get the bits we want
	m_fi.dwMaxBytesPerSec	= psinfo->dwMaxBytesPerSec;	// max. transfer rate
	m_fi.dwFlags	= psinfo->dwFlags;		// the ever-present flags
	m_fi.dwCaps	= psinfo->dwCaps;
	m_fi.dwStreams	= psinfo->dwStreams;
	m_fi.dwSuggestedBufferSize = psinfo->dwSuggestedBufferSize;
	m_fi.dwWidth	= psinfo->dwWidth;
	m_fi.dwHeight	= psinfo->dwHeight;
	m_fi.dwScale	= psinfo->dwScale;	
	m_fi.dwRate	= psinfo->dwRate;	/* dwRate / dwScale == samples/second */
	m_fi.dwLength	= psinfo->dwLength;
	m_fi.dwEditCount = psinfo->dwEditCount;


#ifdef WIN32	
	// use unicode if we've been sent it
	if (psinfo->bHasUnicode) {
	    _fmemcpy(m_fi.szFileType,
	    	psinfo->szUnicodeType, sizeof(m_fi.szFileType));
	} else {
	    // need ansi->unicode thunk
	    MultiByteToWideChar(
	    	CP_ACP, 0,
		psinfo->szFileType,
	     	-1,
		m_fi.szFileType,
		NUMELMS(m_fi.szFileType));
	}
#else
    	// we only use the ansi which is always sent
	_fmemcpy(m_fi.szFileType, psinfo->szFileType, sizeof(m_fi.szFileType));
#endif

	pChannel->FreeBuffer(&Message);
    }

    _fmemcpy(psi, &m_fi, min((int) lSize, sizeof(m_fi)));

    return hrMethod;

}

#ifndef WIN32
STDMETHODIMP CPrxAVIFile::Open(LPCTSTR szFile, UINT mode)
{
    return ResultFromScode(E_NOTIMPL);
}
#endif

STDMETHODIMP CPrxAVIFile::GetStream(PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam)
{
    HRESULT hrMarshal;
    HRESULT hrMethod = NOERROR;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;

    if (pChannel == NULL)
	return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    // format in: fccType lParam
    // format out: returned interface (marshalled)
    Message.cbBuffer = sizeof(fccType) + sizeof(lParam);
    Message.iMethod = IAVIFILE_GetStream;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIFile)) != NOERROR)
	goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = fccType;
    ((DWORD FAR *)Message.Buffer)[1] = lParam;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
	;
ErrExit:
	return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

    if (hrMethod == NOERROR) {
	HGLOBAL	    h;
	LPSTREAM    pstm;

	h = GlobalAlloc(GHND, Message.cbBuffer - sizeof(hrMethod));

	hmemcpy(GlobalLock(h),
		(LPBYTE) Message.Buffer + sizeof(hrMethod),
		Message.cbBuffer - sizeof(hrMethod));

	CreateStreamOnHGlobal(h, FALSE, &pstm);
	
	CoUnmarshalInterface(pstm, IID_IAVIStream, (LPVOID FAR *) ppStream);

	pstm->Release();

	pChannel->FreeBuffer(&Message);
    }

    return hrMethod;
}

STDMETHODIMP CPrxAVIFile::CreateStream(
                                     PAVISTREAM FAR * ppStream,
#ifdef WIN32
                                     AVISTREAMINFOW FAR * psi)
#else
                                     AVISTREAMINFO FAR * psi)
#endif
{
    return ResultFromScode(E_NOTIMPL);
}

#ifndef WIN32
STDMETHODIMP CPrxAVIFile::Save(
                                     LPCTSTR szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback)
{

    return ResultFromScode(E_NOTIMPL);
}
#endif


STDMETHODIMP CPrxAVIFile::ReadData(DWORD ckid, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::WriteData(DWORD ckid, LPVOID lp, LONG cb)
{
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CPrxAVIFile::EndRecord()
{
    return ResultFromScode(E_NOTIMPL);
}

#ifdef WIN32
STDMETHODIMP CPrxAVIFile::DeleteStream(DWORD fccType, LONG lParam)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#else
STDMETHODIMP CPrxAVIFile::Reserved1(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved2(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved3(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved4(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved5(void)
{
    return ResultFromScode(E_NOTIMPL);
}

#endif


/*
 *  IMPLEMENTATION of CStubAVIFile
 *	
 */

// create connected interface stub
HRESULT CStubAVIFile::Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub)
{
	CStubAVIFile FAR* pStubAVIFile;

	*ppStub = NULL;

    if ((pStubAVIFile = new CStubAVIFile()) == NULL)
		return ResultFromScode(E_OUTOFMEMORY);

	HRESULT hresult;
	if ((hresult = pStubAVIFile->Connect(pUnkObject)) != NOERROR)
	{
		pStubAVIFile->Release();
		return hresult;
	}

	*ppStub = pStubAVIFile;
	return NOERROR;
}


CStubAVIFile::CStubAVIFile(void)
{
    m_refs = 1;
    m_pAVIFile = NULL;
    RegisterStubUsage();
}


CStubAVIFile::~CStubAVIFile(void)
{
    UnregisterStubUsage();
    Disconnect();
}


// controling unknown methods for interface stub
STDMETHODIMP CStubAVIFile::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (iid == IID_IUnknown || iid == IID_IRpcStubBuffer)
    {
	*ppv = this;
	++m_refs;
	return NOERROR;
    }
    else
    {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CStubAVIFile::AddRef(void)
{
	return ++m_refs;
}

STDMETHODIMP_(ULONG) CStubAVIFile::Release(void)
{
	if (--m_refs == 0)
	{
		delete this;
		return 0;
	}

	return m_refs;
}


// connect interface stub to server object
STDMETHODIMP CStubAVIFile::Connect(IUnknown FAR* pUnkObj)
{
	if (m_pAVIFile)
		// call Disconnect first
		return ResultFromScode(E_UNEXPECTED);

	if (pUnkObj == NULL)
		return ResultFromScode(E_INVALIDARG);
		
	// NOTE: QI ensures out param is zero if error
	return pUnkObj->QueryInterface(IID_IAVIFile, (LPVOID FAR*)&m_pAVIFile);
}


// disconnect interface stub from server objec
STDMETHODIMP_(void) CStubAVIFile::Disconnect(void)
{
	if (m_pAVIFile) {
		m_pAVIFile->Release();
		m_pAVIFile = NULL;
	}
}


// remove method call
STDMETHODIMP CStubAVIFile::Invoke
	(RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel)
{
    HRESULT     hresult;
    HRESULT		hrMethod;
	
    if (!m_pAVIFile)
	return ResultFromScode(RPC_E_UNEXPECTED);

#if 0
    if (iid != IID_IAVIFile)
	return ResultFromScode(RPC_E_UNEXPECTED);
#endif

    switch (pMessage->iMethod)
    {
	case IAVIFILE_Info:
	    // format on input: lSize
	    // format on output: hresult, AVIFILEINFO
	{
	    DWORD lSize;
#ifdef WIN32
	    AVIFILEINFOW si;
#else
	    AVIFILEINFO si;
#endif
	    PS_FILEINFO psinfo;
	    hrMethod = m_pAVIFile->Info(&si, sizeof(si));

	    // copy all members
	    psinfo.dwMaxBytesPerSec	= si.dwMaxBytesPerSec;
	    psinfo.dwFlags	= si.dwFlags;
	    psinfo.dwCaps	= si.dwCaps;
	    psinfo.dwStreams	= si.dwStreams;
	    psinfo.dwSuggestedBufferSize	= si.dwSuggestedBufferSize;
	    psinfo.dwWidth	= si.dwWidth;
	    psinfo.dwHeight	= si.dwHeight;
	    psinfo.dwScale	= si.dwScale;	
	    psinfo.dwRate	= si.dwRate;
	    psinfo.dwLength	= si.dwLength;
	    psinfo.dwEditCount	= si.dwEditCount;

#ifdef WIN32	
	    // send both UNICODE and ansi
	    hmemcpy(psinfo.szUnicodeType, si.szFileType, NUMELMS(psinfo.szFileType));
	    psinfo.bHasUnicode = TRUE;
	    WideCharToMultiByte(CP_ACP, 0,
	    	si.szFileType,
		-1,
		psinfo.szFileType,
		NUMELMS(psinfo.szFileType),
		NULL, NULL);
#else
    	    // just send ansi version for 16-bit stub
	    psinfo.bHasUnicode = FALSE;
	    hmemcpy(psinfo.szFileType, si.szFileType, sizeof(si.szFileType));
#endif

	    lSize = ((DWORD FAR *)pMessage->Buffer)[0];

	    pMessage->cbBuffer = lSize + sizeof(hrMethod);
	
	    if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
		return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

	    ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;

	    hmemcpy((LPBYTE) pMessage->Buffer + sizeof(hrMethod),
		    &psinfo,
		    lSize);


	    return NOERROR;
	}

	case IAVIFILE_GetStream:
	    // format on input: fccType, lParam
	    // format on output: marshalled IAVIStream pointer
	{
	    DWORD	    lParam, fccType;
	    PAVISTREAM	    ps;
	    HGLOBAL	    h;
	    DWORD	    dwDestCtx = 0;
	    LPVOID	    pvDestCtx = NULL;
	    DWORD	    cb;
	    LPSTREAM	    pstm;
	
	    fccType = ((DWORD FAR *)pMessage->Buffer)[0];
	    lParam = ((DWORD FAR *)pMessage->Buffer)[1];
	
	    hrMethod = m_pAVIFile->GetStream(&ps, fccType, lParam);

	    if (hrMethod == NOERROR) {

		pChannel->GetDestCtx(&dwDestCtx, &pvDestCtx);

#ifdef WIN32
		cb = 0;
		CoGetMarshalSizeMax(&cb, IID_IAVIStream, ps,
				    dwDestCtx, pvDestCtx, MSHLFLAGS_NORMAL);
#else
		cb = 800; // !!!!!!!
#endif

		h = GlobalAlloc(GHND, cb);

		CreateStreamOnHGlobal(h, FALSE, &pstm);

		CoMarshalInterface(pstm, IID_IAVIStream, ps,
				   dwDestCtx, pvDestCtx, MSHLFLAGS_NORMAL);

		pstm->Release();
	    } else
		cb = 0;

	    pMessage->cbBuffer = cb + sizeof(hrMethod);
	
	    if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
		return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

	    ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;

	    if (cb) {
		hmemcpy((LPBYTE) pMessage->Buffer + sizeof(hrMethod),
			GlobalLock(h), cb);

		GlobalFree(h);
	    }

	    return NOERROR;

	}


	default:
		// unknown method
		return ResultFromScode(RPC_E_UNEXPECTED);
	}
}


// return TRUE if we support given interface
STDMETHODIMP_(IRpcStubBuffer FAR *) CStubAVIFile::IsIIDSupported(REFIID iid)
{
	// if we are connected, we have already checked for this interface;
	// if we are not connected, it doesn't matter.
	return iid == IID_IAVIFile ? (IRpcStubBuffer *) this : 0;
}


// returns number of refs we have to object
STDMETHODIMP_(ULONG) CStubAVIFile::CountRefs(void)
{
	// return 1 if connected; 0 if not.
	return m_pAVIFile != NULL;
}



STDMETHODIMP CStubAVIFile::DebugServerQueryInterface(LPVOID FAR *ppv)
{
    *ppv = m_pAVIFile;

    if (!m_pAVIFile) {
	DPF("!No File!\n");
	return ResultFromScode(E_UNEXPECTED);
    }

    return NOERROR;
}

STDMETHODIMP_(void) CStubAVIFile::DebugServerRelease(LPVOID pv)
{


}



//
// The following functions exist to allow an application to determine
// if another application is using any of its objects.
//
// !!!!!!   I don't know if this really works.
//

#define MAXTASKCACHE	64
HTASK	ahtaskUsed[MAXTASKCACHE];
int	aiRefCount[MAXTASKCACHE];

void RegisterStubUsage(void)
{
    HTASK htask = GetCurrentTask();
    int i;

    for (i = 0; i < MAXTASKCACHE; i++) {
	if (ahtaskUsed[i] == htask) {
	    ++aiRefCount[i];
	    return;
	}
    }

    for (i = 0; i < MAXTASKCACHE; i++) {
	if (ahtaskUsed[i] == NULL) {
	    ahtaskUsed[i] = htask;
	    aiRefCount[i] = 1;
	    return;
	}
    }

    DPF("Ack: Proxy cache full!\n");
}

void UnregisterStubUsage(void)
{
    HTASK htask = GetCurrentTask();
    int i;

    for (i = 0; i < MAXTASKCACHE; i++) {
	if (ahtaskUsed[i] == htask) {
	    if (--aiRefCount[i] <= 0) {
		ahtaskUsed[i] = NULL;
		aiRefCount[i] = 0;
	    }
	    return;
	}
    }

    DPF("Ack: Proxy not in cache!\n");
}

BOOL FAR TaskHasExistingProxies(void)
{
    HTASK htask = GetCurrentTask();
    int i;

    for (i = 0; i < MAXTASKCACHE; i++) {
	if (ahtaskUsed[i] == htask) {
	    return TRUE;
	}
    }

    return FALSE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\aviidx.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   AVIIDX.H - AVI Index stuff

*****************************************************************************/

#ifndef _INC_AVIFMT
#include <avifmt.h>
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
	#define EXTERN_C extern "C"
#else
	#define EXTERN_C extern
#endif
#endif

#define ERR_POS     (-100)      // bad position
#define ERR_IDX     (-1)        // bad index

typedef AVIINDEXENTRY _huge *PAVIINDEXENTRY;

//
//  this is the in memory form of a AVI INDEX, we want this to be 8 bytes
//  to save memory.
//
//  the bit fields may not be portable, so a new structure will be needed.
//
//  we always access via macros, so changing the structure should be posible
//
//  this stucture sotres the following:
//
//      offset  0-1GB   (30 bits)   we assume even number so only need 29bits
//      flags           (4 bits)
//      stream  0-127   (7 bits)
//      length  0-4MB   (24 bits)
//
#pragma pack(1)
typedef union {
    struct {
        DWORD   offset;     // 0-1GB
        DWORD   length;     // 0-4MB
    };
    struct {
        BYTE    ack[3];     // 24 bits of the offset
        WORD    flags;      // access to all flags
        BYTE    smag[3];    // length (24 bits)
    };
#if 0   // I hate bit-fields
    struct {
        DWORD   offset:29;  // 0-1GB
        DWORD   key:1;
        DWORD   nonkey:1;
        DWORD   pal:1;
        DWORD   stream:7;   // 0-127
        DWORD   half:1;
        DWORD   length:24;  // 0-4MB
    };
#endif
}   AVIIDX;
#pragma pack()

//
// limits
//
#define MAX_OFFSET  (1l<<30)
#define MAX_LENGTH  (1l<<24)
#define MAX_STREAM  (1l<<7)

//
//  index flags
//
#define IDX_OFFHI   0x001F      // hi part of offset.
#define IDX_KEY     0x0020      // key frame
#define IDX_NONKEY  0x0040      // not a key frame (but not blank either)
#define IDX_PAL     0x0080      // palette change
#define IDX_STREAM  0x7F00      // stream number
#define IDX_HALF    0x8000      // RLE half frame.
#define IDX_NOTIME  IDX_PAL

//
// macros to acces index to help porting
//
#define Index(px, lx)               ((AVIIDX _huge *)px)[lx+1]
#define IndexOffset(px, lx)         (LONG)((Index(px,lx).offset & 0x1FFFFFFF) * 2)
#define IndexLength(px, lx)         (LONG)((Index(px,lx).length) >> 8)
#define IndexStream(px, lx)         (BYTE)((Index(px,lx).flags & IDX_STREAM) >> 8)
#define IndexFlags(px, lx)          (UINT)(Index(px,lx).flags)

#define IndexSetOffset(px, lx, x)   { Index(px,lx).offset &= ~0x1FFFFFFF; Index(px,lx).offset |= (DWORD)(x)>>1; }
#define IndexSetLength(px, lx, x)   { Index(px,lx).length &= ~0xFFFFFF00; Index(px,lx).length |= (DWORD)(x)<<8; }
#define IndexSetStream(px, lx, x)   { Index(px,lx).flags  &= ~IDX_STREAM; Index(px,lx).flags  |= (DWORD)(x)<<8; }
#define IndexSetFlags(px, lx, x)    { Index(px,lx).flags  &= IDX_STREAM|IDX_OFFHI; Index(px,lx).flags |= (UINT)(x); }
#define IndexSetKey(px, lx)         { Index(px,lx).flags  |= IDX_KEY; Index(px,lx).flags &= ~(IDX_NONKEY); }

//
// special streams
//
#define STREAM_REC      0x7F        // interleave records.

//
// this is the header we put on a list of AVIIDX entries.
//
typedef struct
{
    LONG            nIndex;         // number of entries in index
    LONG            nIndexSize;     // alocated size
    AVIIDX          idx[];          // the entries.
}   AVIINDEX, _huge *PAVIINDEX;

//
// AVI Stream Index
//
typedef LONG (FAR PASCAL *STREAMIOPROC)(HANDLE hFile, LONG off, LONG cb, LPVOID p);

typedef struct
{
    UINT            stream;         // stream number
    UINT            flags;          // combination of all flags in index.

    PAVIINDEX       px;             // main index

    LONG            lx;             // Index index
    LONG            lPos;           // index position

    LONG            lxStart;        // Index start

    LONG            lStart;         // start of stream
    LONG            lEnd;           // end of stream

    LONG            lMaxSampleSize; // largest sample
    LONG            lSampleSize;    // sample size for stream

    LONG            lFrames;        // total "frames"
    LONG            lKeyFrames;     // total key "frames"
    LONG            lPalFrames;     // total pal "frames"
    LONG            lNulFrames;     // total nul "frames"

    HANDLE          hFile;
    STREAMIOPROC    Read;
    STREAMIOPROC    Write;

}   STREAMINDEX, *PSTREAMINDEX;

//
// create and free a index.
//
EXTERN_C PAVIINDEX IndexCreate(void);
#define   FreeIndex(px)  GlobalFreePtr(px)

//
//  convert to and from a file index
//
EXTERN_C PAVIINDEX IndexAddFileIndex(PAVIINDEX px, AVIINDEXENTRY _huge *pidx, LONG cnt, LONG lAdjust, BOOL fRle);
EXTERN_C LONG      IndexGetFileIndex(PAVIINDEX px, LONG l, LONG cnt, PAVIINDEXENTRY pidx, LONG lAdjust);

EXTERN_C PSTREAMINDEX MakeStreamIndex(PAVIINDEX px, UINT stream, LONG lStart, LONG lSampleSize, HANDLE hFile, STREAMIOPROC ReadProc, STREAMIOPROC WriteProc);
#define FreeStreamIndex(psx)    LocalFree((HLOCAL)psx)

//
// index access functions
//
EXTERN_C LONG IndexFirst(PAVIINDEX px, UINT stream);
EXTERN_C LONG IndexNext (PAVIINDEX px, LONG lx, UINT f);
EXTERN_C LONG IndexPrev (PAVIINDEX px, LONG lx, UINT f);

//
//  search index for data
//
#ifndef FIND_DIR
#define FIND_DIR        0x0000000FL     // direction
#define FIND_NEXT       0x00000001L     // go forward
#define FIND_PREV       0x00000004L     // go backward

#define FIND_TYPE       0x000000F0L     // type mask
#define FIND_KEY        0x00000010L     // find key frame.
#define FIND_ANY        0x00000020L     // find any (non-empty) sample
#define FIND_FORMAT     0x00000040L     // find format change
#endif

#ifndef FIND_RET
#define FIND_RET        0x0000F000L     // return mask
#define FIND_POS        0x00000000L     // return logical position
#define FIND_LENGTH     0x00001000L     // return logical size
#define FIND_OFFSET     0x00002000L     // return physical position
#define FIND_SIZE       0x00003000L     // return physical size
#define FIND_INDEX      0x00004000L     // return index position
#endif

EXTERN_C LONG StreamFindSample(PSTREAMINDEX psx, LONG lPos, UINT f);
EXTERN_C LONG StreamRead(PSTREAMINDEX psx, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer);
EXTERN_C LONG StreamWrite(PSTREAMINDEX psx, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avifps.h ===
// avifps.h - AVIStream proxy / stub header

#include <ole2.h>
#ifdef CHICAGO
#include "coguid.h"
#endif
#include <cobjps.h>

#ifndef WIN32
#include "olepriv.h"
#endif

enum {
    IAVISTREAM_Create = 0,
    IAVISTREAM_Info,
    IAVISTREAM_FindSample,
    IAVISTREAM_ReadFormat,
    IAVISTREAM_SetFormat,
    IAVISTREAM_Read,
    IAVISTREAM_Write,
    IAVISTREAM_Delete,
    IAVISTREAM_ReadData,
    IAVISTREAM_WriteData,
    IAVISTREAM_Reserved1,
    IAVISTREAM_Reserved2,
    IAVISTREAM_Reserved3,
    IAVISTREAM_Reserved4,
    IAVISTREAM_Reserved5,
    IAVISTREAM_SetInfo
};

// interface proxy for IAVIStream; always aggregated
class FAR CPrxAVIStream : public IAVIStream
{
public:
    static IRpcProxyBuffer FAR* Create(IUnknown FAR* pUnkOuter);

    // IUnknown methods (for external interface(s))
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IAVIStream methods
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHOD(Info)        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize);
    STDMETHOD_(LONG, FindSample)(THIS_ LONG lPos, LONG lFlags);
    STDMETHOD(ReadFormat)  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *lpcbFormat);
    STDMETHOD(SetFormat)   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHOD(Read)        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHOD(Write)       (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    DWORD dwFlags,
			    LONG FAR *plSampWritten,
			    LONG FAR *plBytesWritten);
    STDMETHOD(Delete)      (THIS_ LONG lStart, LONG lSamples);
    STDMETHOD(ReadData)    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHOD(WriteData)   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
#ifdef WIN32
    STDMETHODIMP SetInfo(AVISTREAMINFO FAR *lpInfo, LONG cbInfo);
#else
    STDMETHOD(Reserved1)   (THIS);
    STDMETHOD(Reserved2)   (THIS);
    STDMETHOD(Reserved3)   (THIS);
    STDMETHOD(Reserved4)   (THIS);
    STDMETHOD(Reserved5)   (THIS);
#endif

private:
    CPrxAVIStream(IUnknown FAR* pUnkOuter);
    ~CPrxAVIStream();


    // IRpcProxyBuffer which is also the controlling unknown
    struct CProxyImpl : IRpcProxyBuffer
	    {
public:
    CProxyImpl(CPrxAVIStream FAR* pPrxAVIStream)
	    { m_pPrxAVIStream = pPrxAVIStream; }

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Connect)(IRpcChannelBuffer FAR* pRpcChannelBuffer);
    STDMETHOD_(void, Disconnect)(void);

	    private:
		CPrxAVIStream FAR* m_pPrxAVIStream;
	    };
    friend CProxyImpl;

    CProxyImpl m_Proxy;


    // private state:
    ULONG		m_refs;
    IUnknown FAR*	m_pUnkOuter;
    IRpcChannelBuffer FAR*	m_pRpcChannelBuffer;
    AVISTREAMINFO	m_sh;
};




// interface stub for IAVIStream
class FAR CStubAVIStream : public IRpcStubBuffer
{
public:
    static HRESULT Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub);

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    STDMETHOD(Connect)(IUnknown FAR* pUnkObject);
    STDMETHOD_(void, Disconnect)(void);
    STDMETHOD(Invoke)(RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel);
    STDMETHOD_(IRpcStubBuffer FAR *, IsIIDSupported)(REFIID iid);
    STDMETHOD_(ULONG, CountRefs)(void);
    STDMETHOD(DebugServerQueryInterface)(LPVOID FAR *ppv);
    STDMETHOD_(void, DebugServerRelease)(LPVOID pv);

private:	
    CStubAVIStream(void);
    ~CStubAVIStream(void);

    ULONG	    m_refs;

    IAVIStream FAR* m_pAVIStream;
};



// Proxy/Stub Factory for pssamp.dll: supports IPSFactory only.
class FAR CPSFactory : public IPSFactoryBuffer
{
public:
    CPSFactory();

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID iid,
			   IRpcProxyBuffer FAR* FAR* ppProxy, LPVOID FAR* ppv);
    STDMETHOD(CreateStub)(REFIID iid, IUnknown FAR* pUnkServer,
			  IRpcStubBuffer FAR* FAR* ppStub);

private:
    ULONG	m_refs;
};

DEFINE_AVIGUID(CLSID_AVIStreamPS,           0x0002000D, 0, 0);



enum {
    IAVIFILE_Open = 0,
    IAVIFILE_Info,
    IAVIFILE_GetStream,
    IAVIFILE_CreateStream,
    IAVIFILE_Save,
    IAVIFILE_ReadData,
    IAVIFILE_WriteData,
    IAVIFILE_EndRecord,
    IAVIFILE_Reserved1,
    IAVIFILE_Reserved2,
    IAVIFILE_Reserved3,
    IAVIFILE_Reserved4,
    IAVIFILE_Reserved5
};

// interface proxy for IAVIFile; always aggregated
class FAR CPrxAVIFile : public IAVIFile
{
public:
    static IRpcProxyBuffer FAR* Create(IUnknown FAR* pUnkOuter);

    // IUnknown methods (for external interface(s))
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IAVIFile methods
#ifndef WIN32
    STDMETHOD(Open)		    (THIS_
                                     LPCTSTR szFile,
                                     UINT mode);
#endif
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFO FAR * pfi,
                                     LONG lSize);
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam);
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFO FAR * psi);
#ifndef WIN32
    STDMETHOD(Save)                 (THIS_
                                     LPCTSTR szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback);
#endif
    STDMETHOD(WriteData)            (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG cbData);
    STDMETHOD(ReadData)             (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG FAR *lpcbData);
    STDMETHOD(EndRecord)            (THIS);
#ifdef WIN32
    STDMETHODIMP DeleteStream            (THIS_
				     DWORD fccType,
				     LONG lParam);

#else
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);
#endif


private:
    CPrxAVIFile(IUnknown FAR* pUnkOuter);
    ~CPrxAVIFile();


    // IRpcProxyBuffer which is also the controlling unknown
    struct CProxyImpl : IRpcProxyBuffer
	    {
public:
    CProxyImpl(CPrxAVIFile FAR* pPrxAVIFile)
	    { m_pPrxAVIFile = pPrxAVIFile; }

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Connect)(IRpcChannelBuffer FAR* pRpcChannelBuffer);
    STDMETHOD_(void, Disconnect)(void);

	    private:
		CPrxAVIFile FAR* m_pPrxAVIFile;
	    };
    friend CProxyImpl;

    CProxyImpl m_Proxy;


    // private state:
    ULONG		m_refs;
    IUnknown FAR*	m_pUnkOuter;
    IRpcChannelBuffer FAR*	m_pRpcChannelBuffer;
    AVIFILEINFO	m_fi;
};




// interface stub for IAVIFile
class FAR CStubAVIFile : public IRpcStubBuffer
{
public:
    static HRESULT Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub);

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    STDMETHOD(Connect)(IUnknown FAR* pUnkObject);
    STDMETHOD_(void, Disconnect)(void);
    STDMETHOD(Invoke)(RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel);
    STDMETHOD_(IRpcStubBuffer FAR *, IsIIDSupported)(REFIID iid);
    STDMETHOD_(ULONG, CountRefs)(void);
    STDMETHOD(DebugServerQueryInterface)(LPVOID FAR *ppv);
    STDMETHOD_(void, DebugServerRelease)(LPVOID pv);

private:	
    CStubAVIFile(void);
    ~CStubAVIFile(void);

    ULONG	    m_refs;

    IAVIFile FAR* m_pAVIFile;
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\aviiface.h ===
/****************************************************************************
 *
 *  AVIIFACE.H
 *
 *  Interface definitions for AVIFile
 *
 *  Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <compobj.h>


#ifndef RIID
#if defined(__cplusplus)
#define	RIID	IID FAR&
#define	RCLSID	CLSID FAR&
#else
#define	RIID	IID FAR*
#define	RCLSID	CLSID FAR*
#endif
#endif


/*	-	-	-	-	-	-	-	-	*/


/****** AVI Stream Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IAVIStream

DECLARE_INTERFACE_(IAVIStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStream methods ***
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2) PURE ;
    STDMETHOD(Info)        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize) PURE ;
    STDMETHOD_(LONG, FindSample)(THIS_ LONG lPos, LONG lFlags) PURE ;
    STDMETHOD(ReadFormat)  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *lpcbFormat) PURE ;
    STDMETHOD(SetFormat)   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat) PURE ;
    STDMETHOD(Read)        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples) PURE ;
    STDMETHOD(Write)       (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    DWORD dwFlags,
			    LONG FAR *plSampWritten,
			    LONG FAR *plBytesWritten) PURE ;
    STDMETHOD(Delete)      (THIS_ LONG lStart, LONG lSamples) PURE;
    STDMETHOD(ReadData)    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb) PURE ;
    STDMETHOD(WriteData)   (THIS_ DWORD fcc, LPVOID lp, LONG cb) PURE ;
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
};

typedef       IAVIStream FAR* PAVISTREAM;


#undef  INTERFACE
#define INTERFACE   IAVIStreaming

DECLARE_INTERFACE_(IAVIStreaming, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStreaming methods ***
    STDMETHOD(Begin) (THIS_
		      LONG  lStart,		    // start of what we expect
						    // to play
		      LONG  lEnd,		    // expected end, or -1
		      LONG  lRate) PURE;	    // Should this be a float?
    STDMETHOD(End)   (THIS) PURE;
};

typedef       IAVIStreaming FAR* PAVISTREAMING;


#undef  INTERFACE
#define INTERFACE   IAVIEditStream

DECLARE_INTERFACE_(IAVIEditStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIEditStream methods ***
    STDMETHOD(Cut) (THIS_ LONG FAR *plStart,
			  LONG FAR *plLength,
			  PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Copy) (THIS_ LONG FAR *plStart,
			   LONG FAR *plLength,
			   PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Paste) (THIS_ LONG FAR *plPos,
			    LONG FAR *plLength,
			    PAVISTREAM pstream,
			    LONG lStart,
			    LONG lEnd) PURE;
    STDMETHOD(Clone) (THIS_ PAVISTREAM FAR *ppResult) PURE;
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFO FAR * lpInfo,
			    LONG cbInfo) PURE;
};

typedef       IAVIEditStream FAR* PAVIEDITSTREAM;


/****** AVI File Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IAVIFile
#define PAVIFILE IAVIFile FAR*

DECLARE_INTERFACE_(IAVIFile, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIFile methods ***
    STDMETHOD(Open)		    (THIS_
                                     LPCTSTR szFile,
                                     UINT mode) PURE;
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFO FAR * pfi,
                                     LONG lSize) PURE;
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam) PURE;
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFO FAR * psi) PURE;
    STDMETHOD(Save)                 (THIS_
                                     LPCTSTR szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback) PURE;
    STDMETHOD(WriteData)            (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG cbData) PURE;
    STDMETHOD(ReadData)             (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG FAR *lpcbData) PURE;
    STDMETHOD(EndRecord)            (THIS) PURE;
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
};

#undef PAVIFILE
typedef       IAVIFile FAR* PAVIFILE;

/****** GetFrame Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IGetFrame
#define PGETFRAME   IGetFrame FAR*

DECLARE_INTERFACE_(IGetFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGetFrame methods ***

    STDMETHOD_(LPVOID,GetFrame) (THIS_ LONG lPos) PURE;
//  STDMETHOD_(LPVOID,GetFrameData) (THIS_ LONG lPos) PURE;

    STDMETHOD(Begin) (THIS_ LONG lStart, LONG lEnd, LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;

    STDMETHOD(SetFormat) (THIS_ LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy) PURE;

//  STDMETHOD(DrawFrameStart) (THIS) PURE;
//  STDMETHOD(DrawFrame) (THIS_ LONG lPos, HDC hdc, int x, int y, int dx, int dy) PURE;
//  STDMETHOD(DrawFrameEnd) (THIS) PURE;
};

#undef PGETFRAME
typedef IGetFrame FAR* PGETFRAME;

/****** GUIDs *******************************************/

#define DEFINE_AVIGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
DEFINE_AVIGUID(IID_IAVIStreaming,       0x00020022, 0, 0);
DEFINE_AVIGUID(IID_IGetFrame,           0x00020023, 0, 0);
DEFINE_AVIGUID(IID_IAVIEditStream,      0x00020024, 0, 0);
DEFINE_AVIGUID(CLSID_AVISimpleUnMarshal,        0x00020009, 0, 0);

#define	AVIFILEHANDLER_CANREAD		0x0001
#define	AVIFILEHANDLER_CANWRITE		0x0002
#define	AVIFILEHANDLER_CANACCEPTNONRGB	0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avilib.cpp ===
/****************************************************************************
 *
 *  AVILIB.CPP
 *
 *  routines for reading a AVIStream
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <compobj.h>
#include <compman.h>
#include <shellapi.h>
#include <memory.h>     // for _fmemset

#include "avifile.h"
#include "aviopts.h"	// string resources
#include "avireg.h"
#include "debug.h"

#ifndef WIN32
#undef HKEY_CLASSES_ROOT
#define HKEY_CLASSES_ROOT       0x00000001
#endif

#define ValidPAVI(pavi)  (pavi != NULL)

#define V_PAVI(pavi, err)   \
    if (!ValidPAVI(pavi))   \
        return err;

/****************************************************************************

    strings

****************************************************************************/

#define SZCODE char _based(_segname("_CODE"))

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

EXTERN_C HINSTANCE ghMod;

static int iInit = 0;

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/**************************************************************************
* @doc INTERNAL InitRegistry()
*
* @api void | write all the default AVIFile/AVIStream handlers to the
*             registry.
*
* @comm This function should be enhanced so that some of the key values
*	can be loaded from resources, instead of a static string table....
*
* @xref AVIStreamInit
*
*************************************************************************/

static void InitRegistry()
{
    char **ppch = aszReg;
    char ach[80];

#ifndef DEBUG
    LONG cb;

    // !!! This should have a version number or something in it....
    if (RegQueryValue(HKEY_CLASSES_ROOT, ppch[0], ach, (cb = sizeof(ach),&cb)) == ERROR_SUCCESS &&
        lstrcmpi(ach, ppch[1]) == 0)

        return;
#endif

    while (ppch[0])
    {
	if (((UINT) ppch[1]) < MAX_RC_CONSTANT) {
	    LoadString(ghMod, (UINT) ppch[1], ach, sizeof(ach));
	    RegSetValue(HKEY_CLASSES_ROOT, ppch[0], REG_SZ, ach, 0L);
	} else
	    RegSetValue(HKEY_CLASSES_ROOT, ppch[0], REG_SZ, ppch[1], 0L);
        ppch += 2;
    }
}

/**************************************************************************
* @doc EXTERNAL AVIFileInit
*
* @api void | AVIFileInit | This function initalizes the AVIFILE library.
*
* @comm Call this function before using any other AVIFILE functions.
*
* @xref <f AVIFileExit>
*
*************************************************************************/
STDAPI_(void) AVIFileInit()
{
    iInit++;

    CoInitialize(NULL);

    if (iInit == 1) {
        InitRegistry();
    }
}

/**************************************************************************
* @doc EXTERNAL AVIFileExit
*
* @api void | AVIFileExit | This function exits the AVIFILE library.
*
* @comm Call this function after using any other AVIFILE functions.
*
* @xref <f AVIFileInit>
*
*************************************************************************/
STDAPI_(void) AVIFileExit()
{
    extern HINSTANCE ghOLE2;

    iInit--;

    CoFreeUnusedLibraries();
    CoUninitialize();

    if (iInit == 0){
	if (ghOLE2) {
	    DPF("Freeing OLE2.DLL\n");
	    FreeLibrary(ghOLE2);
	    ghOLE2 = NULL;
	}
    }
}


/**************************************************************************
* @doc INTERNAL AVIFileCreate
*
* @api LONG | AVIFileCreate | Initializes an empty AVI File interface
*	pointer.
*
* @parm PAVIFILE FAR * | ppfile | Pointer to where the new <t PAVIFILE>
*	should be returned.
*
* @parm LONG | lParam | Specifies a parameter passed to the handler.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a
*       class ID used to create the file.
*
* @devnote Nobody should have to call this function, because AVIFileOpen
*   does it.  In fact, why do we even have this?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref AVIFileOpen
*
*************************************************************************/
STDAPI AVIFileCreate (PAVIFILE FAR *ppfile, LONG lParam,
		      CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    HRESULT hr;

    if (!iInit) {
	return ResultFromScode(CO_E_NOTINITIALIZED);
    }

//    AVIStreamInit();

    if (pclsidHandler)
	clsid = *pclsidHandler;
    else {
//    if (pfh == NULL)
//	pfh = &AVIFFileHandler;
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIFile,
					 (void FAR* FAR*)ppfile))))
	return hr;  // !!! PropagateHResult?

    return AVIERR_OK;
}

// Remove trailing spaces after a file...
void FixFourCC(LPSTR lp)
{
    int i;

    for (i = 3; i >= 0; i--) {
	if (lp[i] == ' ')
	    lp[i] = '\0';
	else
	    break;
    }
}

// Returns a pointer to the extension of a filename....
LPCSTR FindExtension(LPCSTR lp)
{
    LPCSTR lpExt = lp;
    int i;

// Goto end of string
    while (*lpExt != '\0')
    {
        ++lpExt;
    }

// Must be at least 2 characters in string
    if (lpExt - lp < 2)
        return NULL;

    lpExt -= 1;

// Does not count if last character is '.'
    if (*lpExt == '.')
        return NULL;

    lpExt -= 1;
// Now looking at second to the last character.  Check this and the two
// previous characters for a '.'

    for (i=1; i<=3; ++i)
    {
// Cannot have path separator here
        if (*lpExt == '/' || *lpExt == '\\')
            return NULL;

        if (*lpExt == '.')
        {
            ++lpExt;
	    return lpExt;
        }
        if (lpExt == lp)
            return NULL;
        --lpExt;
    }
    return NULL;
}

/**************************************************************************
* @doc INTERNAL GetHandlerFromFile
*
* @api PAVIFILEHANDLER | GetHandlerFromFile | Figure out what handler
*	to use for a file by looking at its extension, its RIFF type,
*	and possibly other things.
*
* @parm LPCSTR | szFile | The file to look at.
*
* @parm CLSID FAR * | pclsidHandler | Pointer to a classID.
*
* @comm We don't look at the extensions yet.  We need a better way to
*	add handlers.
*
* @rdesc Returns the <PAVIFILEHANDLER> to use, or NULL if it can't find
*	one.
*
* @xref AVIFileOpen AVIRegisterLoader
*
*************************************************************************/
#define	HKEY_AVIFILE_ROOT	HKEY_CLASSES_ROOT
static SZCODE aszRegRIFF[] = "AVIFile\\RIFFHandlers\\%.4s";
static SZCODE aszRegExt[] = "AVIFile\\Extensions";
static SZCODE aszRegClsid[] = "Clsid";
static SZCODE aszRegExtTmpl[] = "%s\\%.3s";

BOOL GetHandlerFromFile(LPCSTR szFile, CLSID FAR *pclsid)
{
    DWORD   dw[3];
    HMMIO   hmmio;
    LPCSTR   lpExt;
    char    achKey[100];
    char    achClass[100];
    LONG    lcbClass;

    // I hate share
    hmmio = mmioOpen((LPSTR) szFile, NULL, MMIO_READ | MMIO_DENYWRITE);

    if (hmmio == NULL)
        hmmio = mmioOpen((LPSTR) szFile, NULL, MMIO_READ | MMIO_DENYNONE);

    if (hmmio == NULL)
        hmmio = mmioOpen((LPSTR) szFile, NULL, MMIO_READ);

    if (hmmio == NULL)
        goto UseExtension;

    if (mmioRead(hmmio, (HPSTR) dw, sizeof(dw)) != sizeof(dw)) {
	mmioClose(hmmio, 0);
	goto UseExtension;
    }

    mmioClose(hmmio, 0);

    if (dw[0] != FOURCC_RIFF)
        goto UseExtension;

    FixFourCC((LPSTR) &dw[2]);

    // Look up the RIFF type in the registration database....
    wsprintf(achKey, aszRegRIFF, (LPSTR) &dw[2]);

    lcbClass = sizeof(achClass);
    RegQueryValue(HKEY_CLASSES_ROOT, achKey, achClass, &lcbClass);

    if (!FAILED(GetScode(CLSIDFromString(achClass, pclsid))))
	return TRUE;

UseExtension:
    lpExt = FindExtension(szFile);
    if (lpExt) {
	// Look up the extension in the registration database....
	wsprintf(achKey, aszRegExtTmpl, (LPSTR) aszRegExt, lpExt);
	
	lcbClass = sizeof(achClass);
	RegQueryValue(HKEY_CLASSES_ROOT, achKey, achClass, &lcbClass);

	if (!FAILED(GetScode(CLSIDFromString(achClass, pclsid))))
	    return TRUE;
    }

    // !!! Use IStorage?

    return FALSE;
}

/**************************************************************************
* @doc EXTERNAL AVIFileOpen
*
* @api LONG | AVIFileOpen | Opens an AVI file and returns a file interface
*	pointer used to access it.
*
* @parm PAVIFILE FAR * | ppfile | Pointer to the location used to return
*       the new <t PAVIFILE> file pointer.
*
* @parm LPCSTR | szFile | Specifies a zero-terminated string
*       containing the name of the file to open.
*
* @parm UINT | mode | Specifies the mode to use when opening the file.
*
*
*       @flag	OF_READ | Opens the file for reading only. This is the
*       	default, if OF_WRITE and OF_READWRITE are not specified.
*
*       @flag	OF_WRITE | Opens the file for writing. You should not
*       	read from a file opened in this mode.
*
*       @flag	OF_READWRITE | Opens the file for both reading and writing.
*
*       @flag	OF_CREATE | Creates a new file.
*       	If the file already exists, it is truncated to zero length.
*
*       @flag	OF_DENYWRITE | Opens the file and denies other
*       	processes write access to the file. <f AVIFileOpen> fails
*       	if the file has been opened in compatibility or for write
*       	access by any other process.
*
*       @flag	OF_DENYREAD | Opens the file and denies other
*       	processes read access to the file. <f AVIFileOpen> fails if the
*       	file has been opened in compatibility mode or for read access
*       	by any other process.
*
*       @flag	OF_DENYNONE | Opens the file without denying other
*       	processes read or write access to the file. <f AVIFileOpen>
*       	fails if the file has been opened in compatibility mode
*       	by any other process.
*
*	@flag	OF_EXCLUSIVE | Opens the file and denies other processes
*		any access to the file.  <f AVIFileOpen> will fail if any
*		other process has opened the file.
*
*       See <f OpenFile> for more information about these flags.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a class ID
*       identifying the handler you want to use. If NULL, the system
*       chooses one from the registration database based on the file
*       extension or the file's RIFF type.
*
* @comm In general, the mode specified is used to open
*	     the file.
*
*	Be sure to call <f AVIFileInit> at least once in your
*	application before calling this function, and to balance each
*	call to <f AVIFileInit> with a call to <f AVIFileExit>.
*
* @rdesc Returns zero if successful; otherwise returns an error code.
*	Possible error returns include:
*
*	@flag AVIERR_BADFORMAT | The file was corrupted or not in the
*	    proper format, and could not be read.
*
*	@flag AVIERR_MEMORY | The file could not be opened because
*	    there was not enough memory.
*
*	@flag AVIERR_FILEREAD | A disk error occurred while reading the
*	    file.
*
*	@flag AVIERR_FILEOPEN | A disk error occurred while opening the
*	    file.
*
*	@flag REGDB_E_CLASSNOTREG | No handler could be found to open
*	    this type of file.
*
* @xref <f AVIFileRelease> <f AVIFileInit>
*
*************************************************************************/
STDAPI AVIFileOpen (PAVIFILE FAR *ppfile,
			 LPCSTR szFile,
			 UINT mode,
			 CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    HRESULT hr;

// We used to just fail if AVIFileInit wasn't called
#if 0
    if (!iInit) {
	return ResultFromScode(E_UNEXPECTED);
    }
#endif

    // Now we do it for them
    hr = CoInitialize(NULL);

    // Let them know what they did wrong
    if (GetScode(hr) == NOERROR) {
#ifdef DEBUG
	MessageBox(NULL, "You didn't call AVIFileInit!", "Bad dog!",
		MB_OK | MB_ICONHAND);
#endif
    } else
	CoUninitialize();

    *ppfile = 0;

    if (pclsidHandler)
	clsid = *pclsidHandler;
    else {
	if (!GetHandlerFromFile(szFile, &clsid)) {
	    DPF("Couldn't find handler for %s\n", (LPSTR) szFile);
	    return ResultFromScode(REGDB_E_CLASSNOTREG);
	}
    }

    if (FAILED(GetScode(hr = CoCreateInstance((RCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIFile,
					 (void FAR* FAR*)ppfile)))) {
	DPF("CoCreateInstance returns %08lx\n", (DWORD) hr);
	return hr;
    }

    //
    // Let's simplify things for the handlers.  They will only see...
    //		OF_CREATE | OF_READWRITE	or...
    //		OF_READWRITE			or...
    //		OF_READ
    //

    if (mode & OF_READWRITE)
	mode &= ~(OF_WRITE | OF_READ);

    if (mode & OF_CREATE) {
	mode &= ~(OF_WRITE | OF_READ);
	mode |= OF_READWRITE;
    }

    if (mode & OF_WRITE) {
	mode &= ~(OF_WRITE | OF_READ);
	mode |= OF_READWRITE;
    }

    if (FAILED(GetScode(hr = (*ppfile)->Open(szFile, mode)))) {
	DPF("Open method returns %08lx\n", (DWORD) hr);
	(*ppfile)->Release();
	*ppfile = NULL;
    }

    return hr;
}

/**************************************************************************
* @doc EXTERNAL AVIFileAddRef
*
* @api LONG | AVIFileAddRef | Increases the reference count of an AVI file.
*
* @parm PAVIFILE | pfile | Specifies the handle for an open AVI file.
*
* @rdesc Returns zero on success; otherwise returns an error code.
*
* @comm Balance each call to <f AVIFileAddRef> with a call to
*       <f AVIFileRelease>.
*
* @xref <f AVIFileRelease>
*
*************************************************************************/
STDAPI_(ULONG) AVIFileAddRef(PAVIFILE pfile)
{
    return pfile->AddRef();
}

/**************************************************************************
* @doc EXTERNAL AVIFileRelease
*
* @api LONG | AVIFileRelease | Reduces the reference count of an AVI file
*	interface handle by one, and closes the file if the count reaches
*	zero.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @comm Balance each call to <f AVIFileAddRef> or <f AVIFileOpen>
*       a call to <f AVIFileRelease>.
*
* @devnote Currently, this saves all changes to the file.  Should a separate
*	Save command be needed to do this?
*
* @rdesc Returns the reference count of the file.  This return value
*	should be used only for debugging purposes.
*
* @xref AVIFileOpen AVIFileAddRef
*
*************************************************************************/
STDAPI_(ULONG) AVIFileRelease(PAVIFILE pfile)
{
    return pfile->Release();
}

/**************************************************************************
* @doc EXTERNAL AVIFileInfo
*
* @api LONG | AVIFileInfo | Obtains information about an AVI file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm AVIFILEINFO FAR * | pfi | Pointer to the structure used to
*       return file information.
*
* @parm LONG | lSize | Specifies the size of the structure.  This value
*	should be at least sizeof(AVIFILEINFO), obviously.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
*************************************************************************/
STDAPI AVIFileInfo	         (PAVIFILE pfile, AVIFILEINFO FAR * pfi,
				  LONG lSize)
{
    _fmemset(pfi, 0, (int)lSize);
    return pfile->Info(pfi, lSize);
}

/**************************************************************************
* @doc EXTERNAL AVIFileGetStream
*
* @api LONG | AVIFileGetStream | Returns a pointer to a stream interface
*      that is a component of a file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm PAVISTREAM FAR * | ppavi | Pointer to the return location
*       for the new stream interface pointer.
*
* @parm DWORD | fccType | Specifies a four-character code
*       indicating the type of stream to be opened.
*       Zero indicates that any stream can be opened. The following
*       definitions apply to the data commonly
*       found in AVI streams:
*
* @flag streamtypeAUDIO | Indicates an audio stream.
* @flag streamtypeMIDI | Indicates a MIDI stream.
* @flag streamtypeTEXT | Indicates a text stream.
* @flag streamtypeVIDEO | Indicates a video stream.
*
* @parm LONG | lParam | Specifies an integer indicating which stream
*       of the type defined by <p fccType> should actually be accessed.
*
* @comm Balance each call to <f AVIFileGetStream> with a call to
*       <f AVIStreamRelease> using the stream handle returned.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*	Possible error codes include:
*
*	@flag AVIERR_NODATA | There is no stream in the file corresponding
*	    to the values passed in for <p fccType> and <p lParam>.
*	@flag AVIERR_MEMORY | Not enough memory.
*
* @xref <f AVIStreamRelease>
*
*************************************************************************/
STDAPI AVIFileGetStream     (PAVIFILE pfile, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam)
{
    return pfile->GetStream(ppavi, fccType, lParam);
}

#if 0
// !!! This would be used to save changes, if AVIFileRelease didn't do that.
STDAPI AVIFileSave		 (PAVIFILE pfile,
					  LPCSTR szFile,
					  AVISAVEOPTIONS FAR *lpOptions,
					  AVISAVECALLBACK lpfnCallback,
					  PAVIFILEHANDLER pfh)
{
    if (pfile->FileSave == NULL)
	return -1;

    return pfile->FileSave(pfile, szFile, lpOptions, lpfnCallback);
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIFileCreateStream
*
* @api LONG | AVIFileCreateStream | Creates a new stream in an existing file,
*      and returns a stream interface pointer for it.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer used to return the new
*       stream interface pointer.
*
* @parm AVISTREAMINFO FAR * | psi | Specifies a pointer to a structure
*       containing information about the new stream. This structure
*       contains the type of the new stream and its sample rate.
*
* @comm Balance each call to <f AVIFileCreateStream> with a call to
*       <f AVIStreamRelease> using the returned stream handle.
*
*       This function fails with a return value of AVIERR_READONLY unless
*       the file was opened with write permission.
*
*       After creating the stream, call <f AVIStreamSetFormat>
*       before using <f AVIStreamWrite> to write to the stream.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIStreamRelease> <f AVIFileGetStream> <f AVIStreamSetFormat>
*
*************************************************************************/
STDAPI AVIFileCreateStream  (PAVIFILE pfile,
					 PAVISTREAM FAR *ppavi,
					 AVISTREAMINFO FAR *psi)
{
    *ppavi = NULL;
    return pfile->CreateStream(ppavi, psi);
}

/**************************************************************************
* @doc INTERNAL AVIFileAddStream
*
* @api LONG | AVIFileAddStream | Adds an existing stream into
*	an existing file, and returns a stream interface pointer for it.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm PAVISTREAM | pavi | Specifies a stream interface pointer
*       for the stream being added.
*
* @parm PAVISTREAM FAR * | ppaviNew | Pointer to a buffer used
*       to return the new stream interface pointer.
*
* @comm Balance each call to <f AVIFileAddStream> with a call to
*       <f AVIStreamRelease> using the returned stream handle.
*
*	This call fails with a return value of AVIERR_READONLY unless
*	the file was opened with write permission.
*
* @devnote This function still doesn't really work.  Perhaps it should just
*	be a helper function that gets data from the stream and calls
*	AVIFileCreateStream, then copies the data from one stream to another.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref AVIStreamRelease AVIFileGetStream AVIFileCreateStream
*
*************************************************************************/
#if 0
STDAPI AVIFileAddStream	(PAVIFILE pfile,
					 PAVISTREAM pavi,
					 PAVISTREAM FAR * ppaviNew)
{
//    if (pfile->FileAddStream == NULL)
//	return -1;

    return pfile->AddStream(pavi, ppaviNew);
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIFileWriteData
*
* @api LONG | AVIFileWriteData | Writes some additional data to the file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to the data to write.
*
* @parm LONG | cbData | Specifies the size of the memory block
*       referenced by <p lpData>.
*
* @comm This function fails with a return value of AVIERR_READONLY unless
*       the file was opened with write permission.
*
*       Use <f AVIStreamWriteData> instead of this function to write
*       data that applies to an individual stream.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIStreamWriteData> <f AVIFileReadData>
*
*************************************************************************/
STDAPI AVIFileWriteData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData)
{
//    if (pfile->FileWriteData == NULL)
//	return -1;

    return pfile->WriteData(ckid, lpData, cbData);
}

/**************************************************************************
* @doc EXTERNAL AVIFileReadData
*
* @api LONG | AVIFileReadData | Reads optional header data from the file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to a buffer used to return
*       the data read.
*
* @parm LONG FAR * | lpcbData | Specifies a pointer to a location indicating
*	the size of the memory block referred to by <p lpData>. If
*	the read is successful, the value is changed to indicate the
*	amount of data read.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
*	@comm Do not use this function to read video and audio data. Use it
*  only to read additional information such as author
*	information or copyright information that applies to the file
*	as a whole. Information that applies to a single stream should
*	be read using <f AVIStreamReadData>.
*	
* @rdesc Returns zero if successful; otherwise it returns an error code.
*       The return value AVIERR_NODATA indicates that data with the
*       requested chunk ID does not exist.
*
* @xref <f AVIStreamReadData> <f AVIFileWriteData>
*
*************************************************************************/
STDAPI AVIFileReadData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR * lpcbData)
{
    return pfile->ReadData(ckid, lpData, lpcbData);
}

/**************************************************************************
* @doc EXTERNAL AVIFileEndRecord
*
* @api LONG | AVIFileEndRecord | Marks the end of a record, if writing out
*	a strictly interleaved file.
*
* @parm PAVIFILE | pfile | Specifies a handle to a currently open AVI file.
*
* @comm <f AVIFileSave> uses this function when writing files that are
*	have audio interleaved every frame.  In general, applications
*	should not need to use this function.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileSave> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIFileEndRecord	(PAVIFILE pfile)
{
//    if (pfile->FileEndRecord == NULL)
//	return -1;

    return pfile->EndRecord();
}



/**************************************************************************
* @doc EXTERNAL AVIStreamAddRef
*
* @api LONG | AVIStreamAddRef | Increases the reference count of an AVI stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open AVI stream.
*
* @comm Balance each call to <f AVIStreamAddRef> with a call to
*       <f AVIStreamRelease>.
*
* @rdesc Returns the current reference count of the stream.  This value
*	should only be used for debugging purposes.
*
* @xref <f AVIStreamRelease>
*
*************************************************************************/
STDAPI_(ULONG) AVIStreamAddRef       (PAVISTREAM pavi)
{
    return pavi->AddRef();
}

/**************************************************************************
* @doc EXTERNAL AVIStreamRelease
*
* @api LONG | AVIStreamRelease | Reduces the reference count of an AVI stream
*	interface handle by one, and closes the stream if the count reaches
*	zero.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @comm Balance each call to <f AVIStreamAddRef> or <f AVIFileGetStream>
*       with a call to <f AVIStreamRelease>.
*
* @rdesc Returns the current reference count of the stream.  This value
*	should only be used for debugging purposes.
*
* @xref <f AVIFileGetStream> <f AVIStreamAddRef>
*
*************************************************************************/
STDAPI_(ULONG) AVIStreamRelease        (PAVISTREAM pavi)
{
    return pavi->Release();
}

/**************************************************************************
* @doc EXTERNAL AVIStreamInfo
*
* @api LONG | AVIStreamInfo | Obtains stream header information.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm AVISTREAMINFO FAR * | psi | Specifies a pointer to a structure
*       used to return stream information.
*
* @parm LONG | lSize | Specifies the size of the structure used for
*       <p psi>.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
*************************************************************************/
STDAPI AVIStreamInfo         (PAVISTREAM pavi, AVISTREAMINFO FAR * psi, LONG lSize)
{
    _fmemset(psi, 0, (int)lSize);

    return pavi->Info(psi, lSize);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamFindSample
*
* @api LONG | AVIStreamFindSample | Returns the position of
*      a key frames or non-empty frame relative to the specified position.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lPos | Specifies the starting position
*       for the search.
*
* @parm LONG | lFlags | The following flags are defined:
*
* @flag FIND_KEY     | Finds a key frame.
* @flag FIND_ANY     | Finds a non-empty sample.
* @flag FIND_FORMAT  | Finds a format change.
*
* @flag FIND_NEXT    | Finds nearest sample, frame, or format change
*                      searching forward. The current sample is
*                      included in the search. Use this flag with the
*                      FIND_ANY, FIND_KEY, or FIND_FORMAT flag.
*
* @flag FIND_PREV    | Finds nearest sample, frame, or format change
*                      searching backwards. The current sample is
*                      included in the search. Use this flag with the
*                      FIND_ANY, FIND_KEY, or FIND_FORMAT flag.
*
*
* @comm The FIND_KEY, FIND_ANY, and FIND_FORMAT flags are mutually exclusive.
*       The FIND_NEXT and FIND_PREV flags are also mutually exclusive.
*       For example:
*
* @ex       FIND_PREV|FIND_KEY      Returns the first key sample prior to or at
*                               <p lPos>.
*
*       FIND_PREV|FIND_ANY      Returns the first non-empty sample prior to
*                               or at <p lPos>.
*
*       FIND_NEXT|FIND_KEY      Returns the first key sample after <p lPos>,
*                               or -1 if a key sample does not follow <p lPos>.
*
*       FIND_NEXT|FIND_ANY      Returns the first non-empty sample after <p lPos>,
*                               or -1 if a sample does not exist after <p lPos>.
*
*       FIND_NEXT|FIND_FORMAT   Returns the first format change after or
*                               at <p lPos>, or -1 if the stream does not
*                               have format changes.
*
*       FIND_PREV|FIND_FORMAT   Returns the first format change prior to
*                               or at <p lPos>. If the stream does not
*                               have format changes, it returns the first sample
*
* @rdesc Returns the position found.  In many boundary cases, this
*	function will return -1; see the example above for details.
*
*************************************************************************/
STDAPI_(LONG) AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags)
{
    // Default to Find Previous Key Frame
    if ((lFlags & FIND_TYPE) == 0)
        lFlags |= FIND_KEY;
    if ((lFlags & FIND_DIR) == 0)
        lFlags |= FIND_PREV;

    return pavi->FindSample(lPos, lFlags);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamReadFormat
*
* @api LONG | AVIStreamReadFormat | Reads the stream format data.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lPos | Specifies the position in the stream
*       used to obtain the format data.
*
* @parm LPVOID | lpFormat | Specifies a pointer to a buffer
*       used to return the format data.
*
* @parm LONG FAR * | lpcbFormat | Specifies a pointer to a
*       location indicating the size of the memory block
*       referred to by <p lpFormat>. On return, the value is
*       changed to indicate the amount of data read. If
*       <p lpFormat> is NULL, this parameter can be used
*       to obtain the amount of memory needed to return the format.
*
* @comm This function will return part of the format even if the buffer
*	provided is not large enough to hold the entire format. In this case
*	the return value will be AVIERR_BUFFERTOOSMALL, and the location
*	referenced by <p lpcbFormat> will be filled in with the size
*	of the entire format.
*
*	This is useful because it allows you to use a buffer the
*	size of a <t BITMAPINFOHEADER> structure and
*	retrieve just the common part of the video format if you are not
*	interested in extended format information or palette information.
*
* @rdesc Returns zero if successful, otherwise it returns an error code.
*
*************************************************************************/
STDAPI AVIStreamReadFormat   (PAVISTREAM pavi, LONG lPos,
					  LPVOID lpFormat, LONG FAR *lpcbFormat)
{
//    if (pavi->StreamReadFormat == NULL)
//	return -1;

    return pavi->ReadFormat(lPos, lpFormat, lpcbFormat);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamSetFormat
*
* @api LONG | AVIStreamSetFormat | Sets the format of a stream at the
*      specified position.
*
* @parm PAVISTREAM | pavi | Specifies a handle to open stream.
*
* @parm LONG | lPos | Specifies the position in the stream to
*       receive the format.
*
* @parm LPVOID | lpFormat | Specifies a pointer to a structure
*       containing the new format.
*
* @parm LONG | cbFormat | Specifies the size of the block of memory
*       referred to by <p lpFormat> in bytes.
*
* @comm After creating a new stream with <f AVIFileCreateStream>,
*       call this function to set the stream's format.
*
*      The handler for writing AVI files does not, in general, accept
*      format changes. Aside from setting the initial format for a
*      stream, only changes in the palette of a video stream are allowed
*      in an AVI file. The palette change must be after
*      any frames already written to the AVI file.  Other handlers may
*     impose different restrictions.
*
* @rdesc Returns zero if successful, otherwise it returns an error code.
*
* @xref <f AVIFileCreateStream> <f AVIStreamReadFormat>
*
*************************************************************************/
STDAPI AVIStreamSetFormat   (PAVISTREAM pavi, LONG lPos,
					 LPVOID lpFormat, LONG cbFormat)
{
//    if (pavi->StreamSetFormat == NULL)
//	return -1;

    return pavi->SetFormat(lPos, lpFormat, cbFormat);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamReadData
*
* @api LONG | AVIStreamReadData | Reads optional header data from a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to used to return
*       the data read.
*
* @parm LONG FAR * | lpcbData | Points to a location which
*       specifies the buffer size used for <p lpData>.
*	If the read is successful, AVIFile changes this value
*       to indicate the amount of data written into the buffer for
*       <p lpData>.
*
* @comm This function only retrieves header information
*       from the stream. To read the actual multimedia content of the
*       stream, use <f AVIStreamRead>.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*        The return value AVIERR_NODATA indicates the system could not
*        find any data with the specified chunk ID.
*
* @xref <f AVIFileReadData> <f AVIStreamWriteData> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIStreamReadData     (PAVISTREAM pavi, DWORD ckid, LPVOID lpData, LONG FAR *lpcbData)
{
//    if (pavi->StreamReadData == NULL)
//	return -1;

    return pavi->ReadData(ckid, lpData, lpcbData);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamWriteData
*
* @api LONG | AVIStreamWriteData | Writes optional data to the stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to a buffer containing
*       the data to write.
*
* @parm LONG | cbData | Indicates the number of bytes of data to be copied
*	from <p lpData> into the stream.
*
* @comm This function only writes header information to the stream.
*       To write the actual multimedia content of the stream, use
*       <f AVIStreamWrite>. Use <f AVIFileWriteData> to write
*       data that applies to an entire file.
*
*       This call fails with a return value of AVIERR_READONLY unless
*       the file was opened with write permission.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileWriteData> <f AVIStreamReadData> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIStreamWriteData     (PAVISTREAM pavi, DWORD ckid, LPVOID lpData, LONG cbData)
{
    return pavi->WriteData(ckid, lpData, cbData);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamRead
*
* @api LONG | AVIStreamRead | Reads audio or video data from a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lStart | Specifies the starting sample to read.
*
* @parm LONG | lSamples | Specifies the number of samples to read.
*
* @parm LPVOID | lpBuffer | Specifies a pointer to a buffer used to
*       return the data.
*
* @parm LONG | cbBuffer | Specifies the size of buffer pointed to by <p lpBuffer>.
*
* @parm LONG FAR * | plBytes | Specifies a pointer to the location
*       used to return number of bytes of data written into the
*       buffer for <p lpBuffer>.  <p plBytes> can be NULL.
*
* @parm LONG FAR * | plSamples | Specifies a pointer to the location
*       used to return the number of samples written into the buffer for
*       for <p lpBuffer>.  <p plSamples> can be NULL.
*
* @comm If <p lpBuffer> is NULL, this function does not read
*       any data; it returns information about the size of data
*       that would be read.
*
*	See <f AVIStreamLength> for a discussion of how sample numbers
*	correspond to the data you want to read.
*
* @rdesc Returns zero if successful, or an error code.  Use <p plBytes>
*	and <p plSamples> to find out how much was actually read.
*
*	Possible errors include:
*
*	@flag AVIERR_BUFFERTOOSMALL | The buffer size <p cbBuffer> was
*	    too small to read in even a single sample of data.
*
*	@flag AVIERR_MEMORY | There was not enough memory for some
*	    reason to complete the read operation.
*
*	@flag AVIERR_FILEREAD | A disk error occurred while reading the
*	    file.
*
* @xref <f AVIFileGetStream> <f AVIStreamFindSample> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIStreamRead         (PAVISTREAM pavi,
					  LONG lStart, LONG lSamples,
					  LPVOID lpBuffer, LONG cbBuffer,
					  LONG FAR * plBytes, LONG FAR * plSamples)
{
//    if (pavi->StreamRead == NULL)
//	return -1;

    return pavi->Read(lStart, lSamples, lpBuffer, cbBuffer, plBytes, plSamples);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamWrite
*
* @api LONG | AVIStreamWrite | Writes data to a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lStart | Specifies the starting sample to write.
*
* @parm LONG | lSamples | Specifies the number of samples to write.
*
* @parm LPVOID | lpBuffer | Specifies a pointer to buffer
*       containing the data to write.
*
* @parm LONG | cbBuffer | Specifies the size of buffer used by <p lpBuffer>.
*
* @parm DWORD | dwFlags | Specifies any flags associated with this data.
*       The following flags are defined:
*
* @flag AVIIF_KEYFRAME | Indicates this data does not rely on preceding
*       data in the file.
*
* @parm LONG FAR * | plSampWritten | Specifies a pointer to a location
*       used to return the number of samples written. This can be set
*       to NULL.
*
* @parm LONG FAR * | plBytesWritten | Specifies a pointer to a location
*       used to return the number of bytes written. This can be set
*       to NULL.
*
* @comm The default AVI file handler only supports writing to the end
*	of a stream.  The WAVE file handler supports writing anywhere.
*
*	This function overwrites existing data, rather than inserting
*	new data.
*
*	See <f AVIStreamLength> for a discussion of how sample numbers
*	correspond to the data you want to read.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileGetStream> <f AVIFileCreateStream> <f AVIStreamRead>
*
*************************************************************************/
STDAPI AVIStreamWrite        (PAVISTREAM pavi,
			      LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer,
			      DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten)
{
//    if (pavi->StreamWrite == NULL)
//	return -1;

    return pavi->Write(lStart, lSamples, lpBuffer, cbBuffer,
		       dwFlags, plSampWritten, plBytesWritten);
}

/**************************************************************************
* @doc INTERNAL AVIStreamDelete
*
* @api LONG | AVIStreamDelete | Deletes data from a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lStart | Specifies the starting sample to delete.
*
* @parm LONG | lSamples | Specifies the number of samples to delete.
*
* @devnote This isn't implemented by anybody yet.  Should it be?  Wave files,
*	for instance, would have to copy lots of data around....
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref
*
*************************************************************************/
STDAPI AVIStreamDelete       (PAVISTREAM pavi, LONG lStart, LONG lSamples)
{
//    if (pavi->StreamDelete == NULL)
//	return -1;

    return pavi->Delete(lStart, lSamples);
}

#if 0
// !!! should this exist?
STDAPI AVIStreamClone	 (PAVISTREAM pavi, PAVISTREAM FAR *ppaviNew)
{
//    if (pavi->StreamClone == NULL)
//	return -1;

    return pavi->Clone(ppaviNew);
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIStreamStart
*
* @api LONG | AVIStreamStart | Returns the starting sample of the stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @rdesc Returns the starting sample number for the stream, or -1 on error.
*
* @comm See <f AVIStreamLength> for a discussion of how sample numbers
*	correspond to the data you want to read.
*
* @xref <f AVIStreamSampleToTime> <f AVIStreamLength>
*
*************************************************************************/
STDAPI_(LONG) AVIStreamStart        (PAVISTREAM pavi)
{
    AVISTREAMINFO	    avistream;

    pavi->Info(&avistream, sizeof(avistream));

    return (LONG) avistream.dwStart;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamLength
*
* @api LONG | AVIStreamLength | Returns the length of the stream in samples.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @devnote Currently, this doesn't call a handler function at all.
*
* @rdesc Returns the stream's length in samples, or -1 on error.
*
* @comm Values in samples can be converted to milliseconds using
*	the <f AVIStreamSampleToTime> function.
*
*	For video streams, each sample generally corresponds to a
*	frame of video.  There may, however, be sample numbers for
*	which no video data is actually present: If <f AVIStreamRead>
*	is called at those positions, it will return a data length
*	of zero bytes.  You can use <f AVIStreamFindSample> with the
*	FIND_ANY flag to find sample numbers which actually have data.
*
*	For audio streams, each sample corresponds to one "block"
*	of data.  Note the conflicting terminology here: if you're
*	working with 22KHz ADPCM data, each block of audio data is
*	256 bytes, corresponding to about 500 "audio samples" which
*	will be presented to the speaker each 22000th of a second.
*	From the point of view of the AVIFile APIs, however, each 256-byte
*	block is a single sample, because they cannot be subdivided.
*
*	Note that the stream's starting position may not be zero; see
*	<f AVIStreamStart>.  Valid positions within a stream range from
*	start to start+length; there is no actual data present at position
*	start+length, but that corresponds to a time after the last data
*	has been rendered.
*
* @xref <f AVIStreamInfo>
*
*************************************************************************/
STDAPI_(LONG) AVIStreamLength       (PAVISTREAM pavi)
{
    AVISTREAMINFO	    avistream;
    HRESULT		    hr;

    hr = pavi->Info(&avistream, sizeof(avistream));

    if (hr != NOERROR) {
	DPF("Error in AVIStreamLength!\n");
	return 1;
    }

    return (LONG) avistream.dwLength;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamTimeToSample
*
* @api LONG | AVIStreamTimeToSample | Converts from milliseconds to samples.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lTime | Specifies the time in milliseconds.
*
* @devnote Currently, this doesn't call a handler function at all.
*
* @comm Samples typically correspond to audio samples or video frames.
*       Other stream types might support different formats than these.

* @rdesc Returns the converted time, or -1 on error.
*
* @xref AVIStreamSampleToTime
*
*************************************************************************/
STDAPI_(LONG) AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime)
{
    AVISTREAMINFO	    avistream;
    HRESULT		    hr;
    LONG		    lSample;

    // Invalid time
    if (lTime < 0)
	return -1;

    hr = pavi->Info(&avistream, sizeof(avistream));

    if (hr != NOERROR || avistream.dwScale == 0) {
	DPF("Error in AVIStreamTimeToSample!\n");
	return lTime;
    }

    // This is likely to overflow if we're not careful for long AVIs
    // so keep the 1000 inside the brackets.

    if (avistream.dwRate / avistream.dwScale < 1000)
	lSample =  muldivrd32(lTime, avistream.dwRate, avistream.dwScale * 1000);
    else
	lSample =  muldivru32(lTime, avistream.dwRate, avistream.dwScale * 1000);

    lSample = min(max(lSample, (LONG) avistream.dwStart),
		  (LONG) (avistream.dwStart + avistream.dwLength));

    return lSample;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamSampleToTime
*
* @api LONG | AVIStreamSampleToTime | Converts from samples to milliseconds.
*   Samples can correspond to blocks of audio samples, video frames, or other format
*   depending on the stream type.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lSample | Specifies the position information.
*
* @rdesc Returns the converted time, or -1 on error.
*
* @xref <f AVIStreamTimeToSample>
*
*************************************************************************/
STDAPI_(LONG) AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample)
{
    AVISTREAMINFO	    avistream;
    HRESULT		    hr;

    hr = pavi->Info(&avistream, sizeof(avistream));

    if (hr != NOERROR || avistream.dwRate == 0) {
	DPF("Error in AVIStreamSampleToTime!\n");
	return lSample;
    }

    lSample = min(max(lSample, (LONG) avistream.dwStart),
		  (LONG) (avistream.dwStart + avistream.dwLength));

    // lSample * 1000 would overflow too easily
    if (avistream.dwRate / avistream.dwScale < 1000)
	return muldivrd32(lSample, avistream.dwScale * 1000, avistream.dwRate);
    else
	return muldivru32(lSample, avistream.dwScale * 1000, avistream.dwRate);
}


/**************************************************************************
* @doc EXTERNAL AVIStreamOpenFromFile
*
* @api LONG | AVIStreamOpenFromFile | This function provides a convenient
*      way to open a single stream from a file.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer to the location
*       used to return the new stream handle.
*
* @parm LPCSTR | szFile | Specifies a zero-terminated string containing
*       the name of the file to open.
*
* @parm DWORD | fccType | Specifies a four-character code
*       indicating the type of stream to be opened.
*       Zero indicates that any stream can be opened. The following
*       definitions apply to the data commonly
*       found in AVI streams:
*
* @flag streamtypeAUDIO | Indicates an audio stream.
* @flag streamtypeMIDI | Indicates a MIDI stream.
* @flag streamtypeTEXT | Indicates a text stream.
* @flag streamtypeVIDEO | Indicates a video stream.
*
* @parm LONG | lParam | Indicates which stream of the type specified in
*	<p fccType> should actually be accessed.
*
* @parm UINT | mode | Specifies the mode to use when opening the file.
*       This function can only open existing streams so the OF_CREATE
*       mode flag cannot be used. See
*       <f OpenFile> for more information about the available flags.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a class ID
*       identifying the handler you want to use. If NULL, the system
*       chooses one from the registration database based on the file
*       extension or the file's RIFF type.
*
* @comm Balance each call to <f AVIStreamOpenFromFile> with a
*       call to <f AVIStreamRelease> using the stream handle returned.
*
*	This function calls <f AVIFileOpen>, <f AVIFileGetStream>, and
*       <f AVIFileRelease>.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileOpen> <f AVIFileGetStream>
*
*************************************************************************/
STDAPI AVIStreamOpenFromFile(PAVISTREAM FAR *ppavi,
				  LPCSTR szFile,
				  DWORD fccType, LONG lParam,
				  UINT mode, CLSID FAR *pclsidHandler)
{
    PAVIFILE	pfile;
    HRESULT	hr;

    hr = AVIFileOpen(&pfile, szFile, mode, pclsidHandler);

    if (!FAILED(GetScode(hr))) {
	hr  = AVIFileGetStream(pfile, ppavi, fccType, lParam);

        AVIFileRelease(pfile);  // the stream still has a reference to the file
    }

    return hr;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamCreate
*
* @api LONG | AVIStreamCreate | Creates a stream not associated with any
*	file.
*
* @parm PAVISTREAM FAR * | ppavi | Pointer to a location to return the
*	new stream handle.
*
* @parm LONG | lParam1 | Specifies stream-handler specific information.
*
* @parm LONG | lParam2 | Specifies stream-handler specific information.
*
* @parm CLSID FAR * | pclsidHandler | Pointer to the class ID used
*       for the stream.
*
* @comm Balance each call to <f AVIStreamCreate> with a
*       call to <f AVIStreamRelease>.
*
*	You should not need to call this function; functions like
*	<f CreateEditableStream> and <f AVIMakeCompressedStream>
*	use it internally.
*
* @rdesc Returns zero if successful; otherwise returns an error code.
*
* @xref <f AVIFileOpen> <f AVIFileGetStream>
*
*************************************************************************/
STDAPI AVIStreamCreate (PAVISTREAM FAR *ppavi, LONG lParam1, LONG lParam2,
		      CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    HRESULT hr;

    if (!iInit) {
	return ResultFromScode(E_UNEXPECTED);
    }

    if (pclsidHandler)
	clsid = *pclsidHandler;
    else {
	return ResultFromScode(REGDB_E_CLASSNOTREG);
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIStream,
					 (void FAR* FAR*)ppavi))))
	return hr;

    if (FAILED(GetScode(hr = (*ppavi)->Create(lParam1, lParam2)))) {
	(*ppavi)->Release();
	// AVIStreamExit();
    }

    return AVIERR_OK;
}


/**************************************************************************
* @doc EXTERNAL AVIStreamBeginStreaming
*
* @api LONG | AVIStreamBeginStreaming | Specifies the parameters for
*      streaming and lets a stream handler prepare for streaming.
*
* @parm PAVISTREAM | pavi | Specifies a pointer to a stream.
*
* @parm LONG | lStart | Specifies the starting point for streaming.
*
* @parm LONG | lEnd | Specifies the ending point for streaming.
*
* @parm LONG | lRate | Specifies the speed at which the file will be
*	read relative to its natural speed.  Specify 1000 for the normal speed.
*
* @comm Many stream implementations ignore this function.
*
* @rdesc Returns zero if successful; otherwise returns an error code.
*
* @xref <f AVIStreamEndStreaming>
*
*************************************************************************/
STDAPI AVIStreamBeginStreaming(PAVISTREAM   pavi,
			       LONG	    lStart,
			       LONG	    lEnd,
			       LONG	    lRate)
{
    IAVIStreaming FAR * pi;
    HRESULT hr;

    if (FAILED(GetScode(pavi->QueryInterface(IID_IAVIStreaming,
					     (void FAR* FAR*) &pi))))
	return AVIERR_OK;

    hr = pi->Begin(lStart, lEnd, lRate);

    pi->Release();

    return hr;
}


/**************************************************************************
* @doc EXTERNAL AVIStreamEndStreaming
*
* @api LONG | AVIStreamEndStreaming | Ends streaming.
*
* @parm PAVISTREAM | pavi | Specifies a pointer to a stream.
*
* @comm Many stream implementations ignore this function.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref AVIStreamBeginStreaming
*
*************************************************************************/
STDAPI AVIStreamEndStreaming(PAVISTREAM   pavi)
{
    IAVIStreaming FAR * pi;
    HRESULT hr;

    if (FAILED(GetScode(pavi->QueryInterface(IID_IAVIStreaming, (LPVOID FAR *) &pi))))
	return AVIERR_OK;

    hr = pi->End();

    pi->Release();

    return hr;
}

#if 0
/*******************************************************************
* @doc INTERNAL AVIStreamHasChanged
*
* @api LONG | AVIStreamHasChanged | This function forces an update
* of the strem information for the specified stream.
*
* @parm PAVISTREAM | pavi | Interface pointer for an AVI stream instance.
*
* @rdesc Returns AVIERR_OK on success.
*
****************************************************************/
STDAPI AVIStreamHasChanged(PAVISTREAM pavi)
{
    pavi->lFrame = -4224;   // bogus value

    AVIStreamInfo(pavi, &pavi->avistream, sizeof(pavi->avistream));

    // !!! Only need to do this if format changes?
    AVIReleaseCachedData(pavi);

    return AVIERR_OK;
}
#endif

static SZCODE aszRegCompressors[] = "AVIFile\\Compressors\\%.4ls";

/*******************************************************************
* @doc EXTERNAL AVIMakeCompressedStream
*
* @api HRESULT | AVIMakeCompressedStream | Returns a pointer to a
*      compressed stream created from an uncompressed stream.
*      The uncompressed stream is compressed using
*      the compression options specified.
*
* @parm PAVISTREAM FAR * | ppsCompressed | Specifies a pointer to
*       the location used to return the compressed stream pointer.
*
* @parm PAVISTREAM | psSource | Specifies a pointer to the stream to be compressed.
*
* @parm AVICOMPRESSOPTIONS FAR * | lpOptions | Specifies a pointer to a
*       structure indicating the type compression to use and the options
*       to apply.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a
*       class ID used to create the stream.
*
* @comm This supports both audio and video compression. Applications
*       can use the created stream for reading or writing.
*
*   For video compression, either specify a handler to use or specify
*   the format for the compressed data.
*
*   For audio compression, you can only specify a format for the compressed
*   data.
*
* @rdesc Returns AVIERR_OK on success, or an error code.
*	Possible errors include:
*
*   @flag AVIERR_NOCOMPRESSOR | No suitable compressor can be found.
*
*   @flag AVIERR_MEMORY | There was not enough memory to complete the operation.
*
*   @flag AVIERR_UNSUPPORTED | Compression is not supported for this type
*	of data.  This error may be returned if you try to compress
*	data that is not audio or video.
*
*
*
****************************************************************/
STDAPI AVIMakeCompressedStream(
		PAVISTREAM FAR *	    ppsCompressed,
		PAVISTREAM		    psSource,
		AVICOMPRESSOPTIONS FAR *    lpOptions,
		CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    char    achKey[100];
    char    achClass[100];
    LONG    lcbClass;
    AVISTREAMINFO strhdr;
    HRESULT hr;


    *ppsCompressed = NULL;

    if (pclsidHandler) {
	clsid = *pclsidHandler;
    } else {
	if (FAILED(GetScode(hr = AVIStreamInfo(psSource,
					       &strhdr,
					       sizeof(strhdr)))))
	    return hr;

	// Look up the stream type in the registration database to find
	// the appropriate compressor....
	wsprintf(achKey, aszRegCompressors, (LPSTR) &strhdr.fccType);

	lcbClass = sizeof(achClass);
	RegQueryValue(HKEY_CLASSES_ROOT, achKey, achClass, &lcbClass);

	if (FAILED(GetScode(CLSIDFromString(achClass, &clsid))))
	    return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIStream,
					 (void FAR* FAR*)ppsCompressed))))
	return hr;  // !!! PropagateHResult?

    if (FAILED(GetScode(hr = (*ppsCompressed)->Create((LONG) psSource,
						  (LONG) lpOptions)))) {
	(*ppsCompressed)->Release();
	*ppsCompressed = NULL;
	return hr;
    }

    return AVIERR_OK;
}


typedef struct {
    char	achClsid[64];
    char	achExtString[128];
} TEMPFILTER, FAR * LPTEMPFILTER;

SZCODE aszAnotherExtension[] = ";*.%s";

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | atol | local version of atol
 *
 ***************************************************************************/

static LONG NEAR PASCAL atol(char FAR *sz)
{
    LONG l = 0;

    while (*sz)
    	l = l*10 + *sz++ - '0';
    	
    return l;    	
}	



/*******************************************************************
* @doc EXTERNAL AVIBuildFilter
*
* @api HRESULT | AVIBuildFilter | Builds a filter specification for passing
*   to <f GetOpenFileName> or <f GetSaveFileName>.
*
* @parm LPSTR | lpszFilter | Pointer to buffer where the filter string
*   should be returned.
*
* @parm LONG | cbFilter | Size of buffer pointed to by <p lpszFilter>.
*
* @parm BOOL | fSaving | Indicates whether the filter should include only
*   formats that can be written, or all formats that can be read.
*
* @rdesc Returns AVIERR_OK on success.
*
* @comm This function does not check if the DLLs referenced
*       in the registration database actually exist.
*
****************************************************************/
STDAPI AVIBuildFilter(LPSTR lpszFilter, LONG cbFilter, BOOL fSaving)
{
#define MAXFILTERS  256
    LPTEMPFILTER    lpf;
    int		    i;
    int		    cf = 0;
    HKEY    hkey;
    LONG    lRet;
    DWORD   dwSubKey;
    char    ach[128];
    char    ach2[128];
    char    achExt[10];
    LONG    cb;
    char    achAllFiles[40];
    int	    cbAllFiles;

    // This string has a NULL in it, so remember its length for real....
    cbAllFiles = LoadString(ghMod,
			    IDS_ALLFILES,
			    achAllFiles,
			    sizeof(achAllFiles));
    for (i = 0; i < cbAllFiles; i++)
	if (achAllFiles[i] == '@')
	    achAllFiles[i] = '\0';


    lpf = (LPTEMPFILTER) GlobalAllocPtr(GHND, sizeof(TEMPFILTER) * MAXFILTERS);

    if (!lpf) {
	return ResultFromScode(AVIERR_MEMORY);
    }

    lRet = RegOpenKey(HKEY_CLASSES_ROOT, aszRegExt, &hkey);

    if (lRet != ERROR_SUCCESS) {

    }

    // Make sure that AVI files come first in the list....
    // !!! Should use StringFromClsid here!
    _fstrcpy(lpf[1].achClsid, "{00020000-0000-0000-C000-000000000046}");
    cf = 1;

    //
    // First, scan through the Extensions list looking for all of the
    // handlers that are installed
    //
    for (dwSubKey = 0; ; dwSubKey++) {
	lRet = RegEnumKey(hkey, dwSubKey, achExt, sizeof(achExt));

	if (lRet != ERROR_SUCCESS) {
	    break;
	}

	cb = sizeof(ach);
	lRet = RegQueryValue(hkey, achExt, ach, &cb);
	
	if (lRet != ERROR_SUCCESS) {
	    break;
	}

	//
	// See if we've seen this handler before
	//
	for (i = 1; i <= cf; i++) {
	    if (_fstrcmp(ach, lpf[i].achClsid) == 0) {
		break;

	    }
	}

	//
	// If not, add it to our list of handlers
	//
	if (i == cf + 1) {
	    if (cf == MAXFILTERS) {
		DPF("Too many filters!\n");
		continue;
	    }
	
	    _fstrcpy(lpf[i].achClsid, ach);
	
	    cb = sizeof(ach);
	    wsprintf(ach2, "%s\\AVIFile", (LPSTR) ach);
	    lRet = RegQueryValue(hkey, ach2, ach, &cb);
	    if (lRet == 0) {
		lRet = atol(ach);

		if (fSaving) {
		    if (!(lRet & AVIFILEHANDLER_CANWRITE))
			continue;
		} else {
		    if (!(lRet & AVIFILEHANDLER_CANREAD))
			continue;
		}
	    }

	    cf++;
	}
	
	wsprintf(ach, aszAnotherExtension, (LPSTR) achExt);
	
	_fstrcat(lpf[i].achExtString, lpf[i].achExtString[0] ?
						ach : ach + 1);
	
	_fstrcat(lpf[0].achExtString, lpf[0].achExtString[0] ?
						ach : ach + 1);
    }

    RegCloseKey(hkey);

    lRet = RegOpenKey(HKEY_CLASSES_ROOT, aszRegClsid, &hkey);

    if (lRet != ERROR_SUCCESS) {
	
    }

    //
    // Now, scan through our list of handlers and build up the
    // filter to use....
    //
    for (i = 0; i <= cf; i++) {
	if (i == 0) {
	    cb = wsprintf(lpszFilter, "All multimedia files") + 1;  // !!!
	} else {
	    cb = sizeof(ach);
	    lRet = RegQueryValue(hkey, lpf[i].achClsid, ach, &cb);

	    if (cbFilter < (LONG)(_fstrlen(lpf[i].achExtString) +
			    (LONG)_fstrlen(ach) + 10)) {
		break; // !!!
	    }

	    cb = wsprintf(lpszFilter, "%s", // "%s (%s)", Todd doesn't like this
			  (LPSTR) ach, (LPSTR) lpf[i].achExtString) + 1;
	}

	cbFilter -= cb;
	lpszFilter += cb;

	_fstrncpy(lpszFilter, lpf[i].achExtString, (int) cbFilter);
	cbFilter -= _fstrlen(lpf[i].achExtString) + 1;
	lpszFilter += _fstrlen(lpf[i].achExtString) + 1;

	if (cbFilter <= 0) {
	    GlobalFreePtr(lpf);
	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}
    }

    if (cbFilter > cbAllFiles) {
	_fmemcpy(lpszFilter, achAllFiles, cbAllFiles);
	cbFilter -= cbAllFiles;
	lpszFilter += cbAllFiles;
    }

    RegCloseKey(hkey);
	
    *lpszFilter++ = '\0';
    --cbFilter;

    GlobalFreePtr(lpf);

    return AVIERR_OK;
}

/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * ICSAMPLE=1
 *
 ****************************************************************************/

#ifdef DEBUG

//
// I wish languages would make up their mind about defines!!!!!
//
#ifndef WINDLL
#define WINDLL
#endif

#ifndef _WINDLL
#define _WINDLL
#endif

#ifndef __WINDLL
#define __WINDLL
#endif

#include <stdarg.h>

#define MODNAME "AVIFILE"
static int iDebug = -1;

void cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

    if (iDebug == -1)
        iDebug = GetProfileIntA("Debug", MODNAME, 0);

    if (iDebug < 1)
        return;

    va_list va;
    va_start(va, szFormat);

    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va);
    va_end(va);
//  lstrcatA(ach, "\r\r\n");
    OutputDebugStringA(ach);
}

void cdecl dprintf2(LPSTR szFormat, ...)
{
    char ach[128];

    if (iDebug == -1)
        iDebug = GetProfileIntA("Debug", MODNAME, 0);

    if (iDebug < 2)
        return;

    va_list va;
    va_start(va, szFormat);
    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va);
    va_end(va);
//  lstrcatA(ach, "\r\r\n");
    OutputDebugStringA(ach);
}

void cdecl dprintf3(LPSTR szFormat, ...)
{
    char ach[128];

    if (iDebug == -1)
        iDebug = GetProfileIntA("Debug", MODNAME, 0);

    if (iDebug < 3)
        return;

    va_list va;
    va_start(va, szFormat);
    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va);
    va_end(va);

//  lstrcatA(ach, "\r\r\n");
    OutputDebugStringA(ach);
}

#endif

#ifdef DEBUG

/* _Assert(szExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
void FAR PASCAL
_Assert(char *szExp, char *szFile, int iLine)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		id;
	void FAR PASCAL DebugBreak(void);

        /* display error message */

        if (szExp)
            wsprintfA(ach, "(%s)\nFile %s, line %d", (LPSTR)szExp, (LPSTR)szFile, iLine);
        else
            wsprintfA(ach, "File %s, line %d", (LPSTR)szFile, iLine);

	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed",
#ifdef BIDI
		MB_RTL_READING |
#endif
		MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{
	case IDABORT:
                FatalAppExit(0, "Good Bye");
		break;

	case IDRETRY:
		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:
		/* ignore the assertion failure */
		break;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\aviidx.cpp ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   AVIIDX.C - AVI Index stuff

*****************************************************************************/

#include <win32.h>      // Win16/32 porting
#include <avifmt.h>     // for stream type
#include "aviidx.h"

#ifdef AVIIDX_READONLY
    #include "common.h"     // for DEBUG
#else
    #include "debug.h"      // for DEBUG
#endif

/***************************************************************************
 ***************************************************************************/

#define INDEXALLOC      512
#define STACK           _based(_segname("_STACK"))

/***************************************************************************
 ***************************************************************************/

//
// used by SearchIndex() to return where a sample is
//
typedef struct {
    LONG    lx;             // index position
    LONG    lPos;           // position in samples.
    LONG    lSize;          // size in samples.
    LONG    lOffset;        // file offset.
    LONG    lLength;        // size in bytes.
}   IDXPOS;

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PAVIINDEX | IndexAddFileIndex
 *
 *  add a bunch of entries from a AVIFILE index to the index.
 *
 ***************************************************************************/

EXTERN_C PAVIINDEX IndexAddFileIndex(PAVIINDEX px, AVIINDEXENTRY _huge *pidx, LONG cnt, LONG lAdjust, BOOL fRle)
{
    LONG        lx;
    LONG        l;
    LONG        lxRec;
    DWORD       ckid;
    UINT        stream;
    DWORD       offset;
    DWORD       length;
    UINT        flags;

    Assert(px);
    Assert(pidx);

    if (px == NULL || pidx == NULL)
        return NULL;

    Assert(sizeof(AVIINDEXENTRY) > sizeof(AVIIDX));

    //
    // grow the index if needed.
    //
    if (px->nIndex + cnt > px->nIndexSize) {

        LONG grow = px->nIndex + cnt - px->nIndexSize;
        LPVOID p;

        if (grow < INDEXALLOC)
            grow = INDEXALLOC;

        p = (LPVOID)GlobalReAllocPtr(px,sizeof(AVIINDEX) +
                (px->nIndexSize + grow) * sizeof(AVIIDX),
		GMEM_MOVEABLE | GMEM_SHARE);

	if (!p)
            return NULL;
	
        px = (PAVIINDEX)p;
        px->nIndexSize += grow;
    }

    for (lxRec=-1,l=0; l < cnt; l++,pidx++) {

        lx = px->nIndex + l;

        //
        // adjust the offset to be absolute
        //
        offset = pidx->dwChunkOffset + lAdjust;
        length = pidx->dwChunkLength;
        ckid   = pidx->ckid;
        stream = StreamFromFOURCC(ckid);
        flags  = 0;

        if (ckid == listtypeAVIRECORD)
            stream = STREAM_REC;

        if (ckid == listtypeAVIRECORD)
            lxRec = lx;

        //
        // handle over flows in a "sane" way.
        //
        if (offset >= MAX_OFFSET)
            break;

        if (stream >= MAX_STREAM)
            break;

        if (length >= MAX_LENGTH)
            length = MAX_LENGTH-1;

        if (pidx->dwFlags & AVIIF_KEYFRAME)
            flags |= IDX_KEY;
        else
            flags |= IDX_NONKEY;

        //
        // length == 0 samples are not real
        //
        if (length == 0)
            flags &= ~(IDX_NONKEY|IDX_KEY);

        //
        // mark palette changes
        //
        if (TWOCCFromFOURCC(ckid) == cktypePALchange) {
            flags |= IDX_PAL;
            flags &= ~(IDX_NONKEY|IDX_KEY);
        }

        //
        // fix up bogus index's by adding any missing KEYFRAME
        // bits. ie this only applies for RLE files.
        //
        if (fRle && length > 0 && TWOCCFromFOURCC(ckid) == cktypeDIBbits)
            flags |= IDX_KEY;

        //
        // do we need to support these?
        //
        if (fRle && TWOCCFromFOURCC(ckid) == aviTWOCC('d', 'x'))
            flags |= IDX_HALF;

        //
        // audio is always a key.
        //
        if (TWOCCFromFOURCC(ckid) == cktypeWAVEbytes)
            flags |= IDX_KEY|IDX_NONKEY;    //hack to get audio back!

        //
        // make sure records are marked as contining a key
        //
        //if (lxRec > 0 && (flags & IDX_KEY))
        //  IndexSetKey(px, lxRec);

        IndexSetFlags(px,lx,flags);
        IndexSetOffset(px,lx,offset);
        IndexSetLength(px,lx,length);
        IndexSetStream(px,lx,stream);

    }

    cnt = l;
    px->nIndex += cnt;

    return px;
}

/***************************************************************************
 ***************************************************************************/

static LONG FAR PASCAL mmioReadProc(HMMIO hmmio, LONG lSeek, LONG lRead, LPVOID lpBuffer)
{
    if (mmioSeek(hmmio, lSeek, SEEK_SET) == -1)
        return -1;

    if (mmioRead(hmmio, (HPSTR)lpBuffer, lRead) != lRead)
        return -1;

    return lRead;
}

/***************************************************************************
 ***************************************************************************/

static LONG FAR PASCAL mmioWriteProc(HMMIO hmmio, LONG lSeek, LONG lWrite, LPVOID lpBuffer)
{
    if (mmioSeek(hmmio, lSeek, SEEK_SET) == -1)
        return -1;

    if (mmioWrite(hmmio, (HPSTR)lpBuffer, lWrite) != lWrite)
        return -1;

    return lWrite;
}

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PSTREAMINDEX | MakeStreamIndex
 *
 *  makes a STREAMINDEX structure that will be used later to read/find
 *  samples in a stream.
 *
 ***************************************************************************/

EXTERN_C PSTREAMINDEX MakeStreamIndex(PAVIINDEX px, UINT stream, LONG lStart, LONG lSampleSize, HANDLE hFile, STREAMIOPROC ReadProc, STREAMIOPROC WriteProc)
{
    LONG         lPos;
    LONG         lx;
    PSTREAMINDEX psx;

    Assert(px);

    if (px == NULL)
        return NULL;

    psx = (PSTREAMINDEX)LocalAlloc(LPTR, sizeof(STREAMINDEX));

    if (psx == NULL)
        return NULL;

    //!!! fixed length sample streams should never have this

    if (lSampleSize != 0 && lStart < 0) {
#ifdef DEBUG
        AssertSz(0, "Audio streams should not have initial frames");
#endif
        lStart = 0;
    }

    psx->px             = px;
    psx->lStart         = lStart;
    psx->lSampleSize    = lSampleSize;
    psx->lMaxSampleSize = 0;
    psx->stream         = stream;
    psx->flags          = 0;

    psx->lStart         = lStart;
    psx->lxStart        = IndexFirst(px, stream);

    psx->lPos           = lStart;
    psx->lx             = psx->lxStart;

    psx->lFrames        = 0;
    psx->lKeyFrames     = 0;
    psx->lPalFrames     = 0;
    psx->lNulFrames     = 0;

    psx->hFile          = hFile;

    if (ReadProc == NULL)
        psx->Read       = (STREAMIOPROC)mmioReadProc;
    else
        psx->Read       = ReadProc;

    if (WriteProc == NULL)
        psx->Write      = (STREAMIOPROC)mmioWriteProc;
    else
        psx->Write      = WriteProc;

    lPos = lStart;

    for (lx = psx->lxStart; lx >= 0 && lx < px->nIndex; lx=IndexNext(px, lx, 0)) {

        if (psx->lMaxSampleSize < IndexLength(px, lx))
            psx->lMaxSampleSize = IndexLength(px, lx);

        //
        // make sure the start sample is a key frame (unless it's wave data!)
        //
        if (lPos == 0 || (lPos >= 0 && lPos == psx->lStart)) {
	    if ((IndexFlags(px, lx) & (IDX_KEY|IDX_NONKEY)) !=
						(IDX_KEY|IDX_NONKEY)) {
		IndexSetKey(px, lx);
	    }
	}

        //
	// make sure sample size is correct
	//
        if (psx->lSampleSize &&
                ((IndexLength(px, lx) % lSampleSize) != 0)) {
            DPF("Bad chunk size found: forcing sample size to 0.\n");
            psx->lSampleSize = 0;
	}

        //
        //  or all the flags together so we can see what a stream has.
        //
        psx->flags |= IndexFlags(px, lx);

        //
        //  check for all key frames.
        //
        if (IndexFlags(px, lx) & IDX_KEY)
            psx->lKeyFrames++;

        //
        //  check for all palette changes
        //
        if (IndexFlags(px, lx) & IDX_PAL)
            psx->lPalFrames++;

        //
        //  check for empty frames
        //
        if (IndexLength(px, lx) == 0)
            psx->lNulFrames++;

        //
        // advance the position
        //
        if (!(IndexFlags(px,lx) & IDX_NOTIME)) {
            if (lSampleSize)
                lPos += IndexLength(px, lx) / lSampleSize;
            else
                lPos++;
        }

        psx->lFrames++;
    }

    //
    //  correct the length
    //
    psx->lEnd = lPos;

    DPF("MakeStreamIndex  stream=#%d lStart=%ld, lEnd=%ld\n", stream, psx->lStart, psx->lEnd);
    DPF("                 lFrames = %ld, lKeys = %ld, lPals = %ld, lEmpty = %ld\n", psx->lFrames, psx->lKeyFrames, psx->lPalFrames, psx->lNulFrames);

    return psx;
}

#ifndef AVIIDX_READONLY

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PAVIINDEX | IndexGetFileIndex
 *
 *     make a file index out of a in memory index
 *
 ***************************************************************************/

EXTERN_C LONG IndexGetFileIndex(PAVIINDEX px, LONG l, LONG cnt, PAVIINDEXENTRY pidx, LONG lAdjust)
{
    LONG            lx;
    DWORD           ckid;
    UINT            stream;
    DWORD           offset;
    DWORD           length;
    UINT            flags;
    DWORD           dwFlags;

    Assert(pidx);
    Assert(px);

    if (pidx == NULL || px == NULL)
        return NULL;

    Assert(sizeof(AVIINDEXENTRY) > sizeof(AVIIDX));

    for (lx=l; lx < px->nIndex && lx < l+cnt; lx++) {
        //
        // adjust the offset to be relative
        //
        offset = IndexOffset(px,lx) + lAdjust;
        length = IndexLength(px,lx);
        stream = IndexStream(px,lx);
        flags  = IndexFlags(px, lx);

        if (length == MAX_LENGTH-1) {
        }

        ckid = MAKEAVICKID(0, stream);
        dwFlags = 0;

        //
        //  set the flags, there are only a few flags in file index's
        //  AVIIF_KEYFRAME, AVIIF_LIST, AVIIF_NOTIME
        //
        if (flags & IDX_KEY)
            dwFlags |= AVIIF_KEYFRAME;

        if (flags & IDX_PAL)
            dwFlags |= AVIIF_NOTIME;

        if (stream == STREAM_REC)
            dwFlags |= AVIIF_LIST;

        //
        //  now figure out the ckid
        //
        if (stream == STREAM_REC)
            ckid = listtypeAVIRECORD;

        else if ((flags & (IDX_KEY|IDX_NONKEY)) == (IDX_KEY|IDX_NONKEY))
            ckid |= MAKELONG(0, aviTWOCC('w', 'b'));

        else if (flags & IDX_PAL)
            ckid |= MAKELONG(0, aviTWOCC('p', 'c'));

        else if (flags & IDX_HALF)
            ckid |= MAKELONG(0, aviTWOCC('d', 'x'));

        else if (flags & IDX_KEY)
            ckid |= MAKELONG(0, aviTWOCC('d', 'b'));

        else
            ckid |= MAKELONG(0, aviTWOCC('d', 'c'));

        //
        // set the info
        //
        pidx->dwChunkOffset = offset;
        pidx->dwChunkLength = length;
        pidx->dwFlags       = dwFlags;
        pidx->ckid          = ckid;

        pidx++;
    }

    return lx - l;  // return count copied
}

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PAVIINDEX | IndexCreate | make a index.
 *
 ***************************************************************************/

EXTERN_C PAVIINDEX IndexCreate(void)
{
    PAVIINDEX px;

    px = (PAVIINDEX)GlobalAllocPtr(GHND | GMEM_SHARE,
        sizeof(AVIINDEX) + INDEXALLOC * sizeof(AVIIDX));

    if (px == NULL)
        return NULL;

    px->nIndex      = 0;          // index size
    px->nIndexSize  = INDEXALLOC; // allocated size

    return px;
}

#endif // AVIIDX_READONLY

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | IndexFirst | returns the first index entry for a stream
 *
 * @rdesc returns the first index entry, -1 for error
 *
 ***************************************************************************/

EXTERN_C LONG IndexFirst(PAVIINDEX px, UINT stream)
{
    LONG l;

    Assert(px);

    for (l=0; l<px->nIndex; l++) {

        if (IndexStream(px, l) == stream)
            return l;
    }

    return ERR_IDX;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | IndexNext | go forward in a index
 *
 ***************************************************************************/

EXTERN_C LONG IndexNext(PAVIINDEX px, LONG l, UINT f)
{
    BYTE bStream;

    Assert(px);

    if (l < 0 || l >= px->nIndex)
        return ERR_IDX;

    bStream = IndexStream(px, l);

    for (l++; l<px->nIndex; l++) {

        if (IndexStream(px, l) != bStream)
            continue;

        if (!f || (IndexFlags(px, l) & f))
            return l;
    }

    return ERR_IDX;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | IndexPrev | step backward in a stream
 *
 ***************************************************************************/
EXTERN_C LONG IndexPrev(PAVIINDEX px, LONG l, UINT f)
{
    BYTE bStream;

    Assert(px);

    if (l < 0 || l >= px->nIndex)
        return ERR_IDX;

    bStream = IndexStream(px, l);

    for (l--; l>=0; l--) {

        if (IndexStream(px, l) != bStream)
            continue;

        if (!f || (IndexFlags(px, l) & f))
            return l;
    }

    return ERR_IDX;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INLINE BOOL StreamNext(PSTREAMINDEX psx, LONG FAR& l, LONG FAR& lPos, UINT flags)
{
    BYTE                bStream = psx->stream;
    LONG                lSampleSize = psx->lSampleSize;
    LONG                lSave = l;
    LONG                lPosSave = lPos;
    PAVIINDEX           px = psx->px;

    Assert(px && l >= 0 && l < px->nIndex);

    if (lSampleSize == 0) {

        lPos += 1;
        l++;

        for (; l<px->nIndex; l++) {

            if (IndexStream(px, l) != bStream)
                continue;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;

	    if (!(IndexFlags(px, l) & IDX_NOTIME))
		lPos += 1;
        }
    }
    else {

        lPos += IndexLength(px, l) / lSampleSize;
        l++;

        for (; l<px->nIndex; l++) {

            if (IndexStream(px, l) != bStream)
                continue;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;

            lPos += IndexLength(px, l) / lSampleSize;
        }
    }

    lPos = lPosSave;
    l    = lSave;

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INLINE BOOL StreamPrev(PSTREAMINDEX psx, LONG FAR& l, LONG FAR& lPos, UINT flags)
{
    BYTE                bStream = psx->stream;
    LONG                lSampleSize = psx->lSampleSize;
    LONG                lSave = l;
    LONG                lPosSave = lPos;
    PAVIINDEX           px = psx->px;

    Assert(px && l >= 0 && l < px->nIndex);

    if (lSampleSize == 0) {

        for (l--;l>=0;l--) {

            if (IndexStream(px, l) != bStream)
                continue;

	    if (!(IndexFlags(px, l) & IDX_NOTIME))
		lPos -= 1;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;
        }
    }
    else {
        for (l--;l>=0;l--) {

            if (IndexStream(px, l) != bStream)
                continue;

            lPos -= IndexLength(px, l) / lSampleSize;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;
        }
    }

    lPos = lPosSave;
    l    = lSave;

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static LONG SearchIndex(PSTREAMINDEX psx,LONG lPos,UINT uFlags,IDXPOS FAR *pos)
{
    LONG                l;
    LONG                lScan;
    LONG                lFound;
    LONG                lFoundPos;
    LONG                lLen;
    UINT                flags;
    PAVIINDEX           px = psx->px;

    Assert(psx);
    Assert(psx->px);

    if (psx == NULL)
        return ERR_POS;

    if (lPos < psx->lStart)
        return ERR_POS;

    if (lPos >= psx->lEnd)
        return ERR_POS;

    //
    // figure out where to start in the index.
    //
    if (psx->lx != -1) {
        lScan  = psx->lPos;
        l      = psx->lx;
    }
    else {
        DPF3("Starting index search at begining\n");
        lScan = psx->lStart;

        for (l=0; l<px->nIndex; l++)
            if (IndexStream(px, l) == (UINT)psx->stream)
                break;
    }

    Assert(l >= 0 && l < px->nIndex);
    Assert(IndexStream(px, l) == psx->stream);

#ifdef DEBUG
    if (!(uFlags & FIND_DIR))
        uFlags |= FIND_PREV;

    switch (uFlags & (FIND_TYPE|FIND_DIR)) {
        case FIND_NEXT|FIND_KEY:    DPF3("SearchIndex(%d): %ld next key, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_NEXT|FIND_ANY:    DPF3("SearchIndex(%d): %ld next any, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_NEXT|FIND_FORMAT: DPF3("SearchIndex(%d): %ld next fmt, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_NEXT:             DPF3("SearchIndex(%d): %ld next    , start=%ld",psx->stream, lPos, lScan); break;

        case FIND_PREV|FIND_KEY:    DPF3("SearchIndex(%d): %ld prev key, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_PREV|FIND_ANY:    DPF3("SearchIndex(%d): %ld prev any, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_PREV|FIND_FORMAT: DPF3("SearchIndex(%d): %ld prev fmt, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_PREV:             DPF3("SearchIndex(%d): %ld prev    , start=%ld",psx->stream, lPos, lScan); break;
    }

    LONG time = timeGetTime();
#endif

    lLen = psx->lSampleSize == 0 ? 1 : IndexLength(px, l) / psx->lSampleSize;

    if (lScan+lLen <= lPos) {
        //
        // search forward for this position
        //
        while (lScan <= lPos) {

            lFound = l;
            lFoundPos = lScan;

            if (lScan == lPos)
                break;

            if (!StreamNext(psx, l, lScan, IDX_KEY|IDX_NONKEY))
                break;
        }

        if ((lScan > lPos) && !(uFlags & FIND_NEXT)) {
            lScan = lFoundPos;
            l     = lFound;
        }
    }
    else if (lScan > lPos) {
        //
        // search backward for this position
        //
        while (lScan > lPos) {

            lFound = l;
            lFoundPos = lScan;

            if (!StreamPrev(psx, l, lScan, IDX_KEY|IDX_NONKEY))
                break;
        }

        if (uFlags & FIND_NEXT) {
            lScan = lFoundPos;
            l     = lFound;
        }
    }
    else {
        Assert(lScan <= lPos && lPos < lScan+lLen);
    }

    Assert(l >= 0 && l < px->nIndex);
    Assert(IndexStream(px, l) == psx->stream);

    //
    //  cache what we found.
    //
    psx->lx   = l;
    psx->lPos = lScan;

    if (uFlags & FIND_TYPE) {

        switch (uFlags & FIND_TYPE) {
            case FIND_ANY:      flags = IDX_KEY|IDX_NONKEY; break;
            case FIND_FORMAT:   flags = IDX_PAL;            break;
            case FIND_KEY:      flags = IDX_KEY;            break;
        }

        if (!(IndexFlags(px, l) & flags)) {

            if (!(uFlags & FIND_NEXT)) {
                if (!StreamPrev(psx, l, lScan, flags)) {
                    DPF3("!, EOI, time = %ld\n", timeGetTime() - time);
                    return ERR_POS;
                }
            }
            else {
                if (!StreamNext(psx, l, lScan, flags)) {
                    DPF3("!, EOI, time = %ld\n", timeGetTime() - time);
                    return ERR_POS;
                }
            }
        }

        Assert(l >= 0 && l < px->nIndex);
        Assert(IndexStream(px, l) == psx->stream);
        Assert(IndexFlags(px, l) & flags);
    }

    Assert(lScan >= psx->lStart && lScan < psx->lEnd);

    DPF3("!, found %ld, time = %ld\n", lScan, timeGetTime() - time);

    if (pos == NULL)
        return lScan;

    if (psx->lSampleSize != 0) {

        lLen = IndexLength(px, l);

        if (lLen == MAX_LENGTH-1)
            lLen = 0x7FFFFFFF;

        if (psx->lSampleSize > 1)
            lLen /= psx->lSampleSize;
    }
    else {
        lLen = 1;
    }

    pos->lx      = l;
    pos->lPos    = lScan;
    pos->lSize   = lLen;
    pos->lOffset = IndexOffset(px, l);
    pos->lLength = IndexLength(px, l);

    //
    //  if the FIND_TYPE is not one of FIND_ANY, FIND_KEY, FIND_FORMAT
    //  make sure we realy found the wanted sample.
    //
    if ((uFlags & FIND_TYPE) == 0) {
        if (lPos < lScan || lPos >= lScan+lLen) {
            pos->lOffset = -1;
            pos->lLength = 0;
            pos->lSize   = 0;
            pos->lPos    = lPos;
        }
        else if (psx->lSampleSize > 0) {
            pos->lOffset += (lPos - lScan) * psx->lSampleSize;
            pos->lLength -= (lPos - lScan) * psx->lSampleSize;
            pos->lSize   -= (lPos - lScan);
            pos->lPos     = lPos;
        }
    }

    return pos->lPos;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | FindSample | find a sample in a stream
 *
 ***************************************************************************/

EXTERN_C LONG StreamFindSample(PSTREAMINDEX psx,LONG lPos,UINT uFlags)
{
    Assert(psx);
    Assert(psx->px);

    if (lPos < psx->lStart)
        return ERR_POS;

    if (lPos >= psx->lEnd)
        return ERR_POS;

    if ((uFlags & FIND_RET) == FIND_POS) {

        switch (uFlags & FIND_TYPE) {
            case FIND_FORMAT:
                if (psx->lPalFrames == 0) {
                    if ((uFlags & FIND_NEXT) && lPos > psx->lStart)
                        return ERR_POS;
                    else
                        return psx->lStart;
                }
                break;

            case FIND_ANY:
                if (psx->lNulFrames == 0) {
                    return lPos;
                }
                break;

            case FIND_KEY:
                if (psx->lKeyFrames == psx->lFrames) {
                    return lPos;
                }
                break;

            default:
                return lPos;
        }

        return SearchIndex(psx, lPos, uFlags, NULL);
    }
    else {
        IDXPOS pos;

        if (SearchIndex(psx, lPos, uFlags, &pos) == ERR_POS)
            return ERR_POS;

        switch (uFlags & FIND_RET) {
            case FIND_POS:
                return pos.lPos;

            case FIND_OFFSET:
                return pos.lOffset + 8;

            case FIND_LENGTH:
                return pos.lLength;

            case FIND_SIZE:
                return pos.lSize;

            case FIND_INDEX:
                return pos.lx;
        }
    }

    return ERR_POS;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | StreamRead | read from a stream
 *
 ***************************************************************************/

EXTERN_C LONG StreamRead(
    PSTREAMINDEX  psx,
    LONG          lStart,
    LONG          lSamples,
    LPVOID        lpBuffer,
    LONG          cbBuffer)
{
    LONG          lBytes;
    LONG          lSampleSize;
    LONG          lSeek;
    LONG          lRead;
    IDXPOS        pos;

    Assert(psx);
    Assert(psx->px);
    Assert(psx->hFile);
    Assert(psx->Read);

    if (lStart < psx->lStart)
        return -1;

    if (lStart >= psx->lEnd)
        return -1;

    //
    // find nearest chunk
    //
    if (SearchIndex(psx, lStart, FIND_PREV, &pos) == ERR_POS)
        return -1;

    //
    // only continue if the sample we want is in here.
    //
    if (lStart < pos.lPos || lStart >= pos.lPos + pos.lSize)
        return 0;

    //
    // if they give us a NULL buffer dummy up the cbBuffer so we return
    // what we would have read if we had enough room
    //
    if (lpBuffer == NULL && cbBuffer == 0 && lSamples != 0)
        cbBuffer = 0x7FFFFFFF;

    if (lSampleSize = psx->lSampleSize) {

        // If they wanted to read/write only a "convenient amount",
        // pretend the buffer is only large enough to hold the
        // rest of this chunk.

        if (lSamples == -1l)
            cbBuffer = min(cbBuffer, pos.lLength);

        /* Fixed-length samples, if lSamples is zero, just fill the buffer. */

        if (lSamples > 0)
            lSamples = min(lSamples, cbBuffer / lSampleSize);
        else
            lSamples = cbBuffer / lSampleSize;

        lBytes = lSamples * lSampleSize;
    } else {
        lBytes = pos.lLength;
    }

    if (lpBuffer == NULL)
        return lBytes;

    if (cbBuffer < lBytes)
        return -1;   // buffer is too small

#define WORDALIGN(x) ((x) + ((x) & 1))
    
    if (lSampleSize == 0)
    {
        DWORD adw[2];
        psx->Read(psx->hFile, pos.lOffset, sizeof(adw), adw);
        Assert(StreamFromFOURCC(adw[0]) == psx->stream);
        Assert(WORDALIGN(adw[1]) == WORDALIGN((DWORD)pos.lLength));
	pos.lLength = adw[1];	// !!! Make netware video work!
	lBytes = pos.lLength;
    }
    else
    {
#ifdef DEBUG
        IDXPOS x;
        DWORD  adw[2];
        SearchIndex(psx, lStart, FIND_PREV|FIND_ANY, &x);
        psx->Read(psx->hFile, x.lOffset, sizeof(adw), adw);
        Assert(StreamFromFOURCC(adw[0]) == psx->stream);
        Assert(WORDALIGN(adw[1]) == WORDALIGN((DWORD)x.lLength));
#endif
    }

    cbBuffer = lBytes;
    lBytes = 0;

    while (cbBuffer > 0) {

        lSeek = pos.lOffset + 8;
        lRead = min(pos.lLength,cbBuffer);

	if (lRead <= 0) {
            DPF3("!!!! lRead <= 0 in AVIStreamRead\n");
	    break;
        }

        DPF3("StreamRead: %ld bytes @%ld\n", lRead, lSeek);

        if (psx->Read(psx->hFile, lSeek, lRead, lpBuffer) != lRead)
            return -1;

	lBytes   += lRead;
	cbBuffer -= lRead;

	if (cbBuffer > 0) {
	    if (lSampleSize == 0) {
		DPF("%ld bytes to read, but sample size is 0!\n", cbBuffer);
		break;
	    }

            lpBuffer = (LPVOID) (((BYTE _huge *)lpBuffer) + lRead);

            lStart += lRead / lSampleSize;
            lStart = SearchIndex(psx, lStart, FIND_PREV, &pos);

            if (lStart == ERR_POS)
		break;
        }
    }

    //
    // success return number of bytes read
    //
    return lBytes;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | StreamWrite | write to a stream
 *
 ***************************************************************************/

EXTERN_C LONG StreamWrite(
    PSTREAMINDEX  psx,
    LONG          lStart,
    LONG          lSamples,
    LPVOID        lpBuffer,
    LONG          cbBuffer)
{
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avilibcf.cpp ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#include <win32.h>
//#include <mmddk.h>
#include <compobj.h>
#include <avifmt.h>
#include "avifile.h"
#include "avifilei.h"
#include "avicmprs.h"
#include "unmarsh.h"
#include "editstrm.h"

/*	-	-	-	-	-	-	-	-	*/

HRESULT CAVIFileCF::Create(
	const CLSID FAR&	rclsid,
	REFIID	riid,
	LPVOID FAR*	ppv)
{
	CAVIFileCF FAR*	pAVIFileCF;
	IUnknown FAR*	pUnknown;
	HRESULT hresult;

	pAVIFileCF = new FAR CAVIFileCF(rclsid, &pUnknown);
	if (pAVIFileCF == NULL)
		return ResultFromScode(E_OUTOFMEMORY);
	hresult = pUnknown->QueryInterface(riid, ppv);
	if (FAILED(GetScode(hresult)))
		delete pAVIFileCF;
	return hresult;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFileCF::CAVIFileCF(
	const CLSID FAR&	rclsid,
	IUnknown FAR* FAR*	ppUnknown) :
	m_Unknown(this),
	m_Factory(this)
{
	m_clsid = rclsid;
	*ppUnknown = &m_Unknown;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFileCF::CUnknownImpl::CUnknownImpl(
	CAVIFileCF FAR*	pAVIFileCF)
{
	m_pAVIFileCF = pAVIFileCF;
	m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CUnknownImpl::QueryInterface(
	REFIID	iid,
	LPVOID FAR*	ppv)
{
	if (iid == IID_IUnknown)
		*ppv = &m_pAVIFileCF->m_Unknown;
	else if (iid == IID_IClassFactory)
		*ppv = &m_pAVIFileCF->m_Factory;
	else
		return ResultFromScode(E_NOINTERFACE);
	AddRef();
	return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CUnknownImpl::AddRef()
{
	return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CUnknownImpl::Release()
{
	if (!--m_refs) {
		delete this;
		return 0;
	}
	return m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFileCF::CFactoryImpl::CFactoryImpl(
	CAVIFileCF FAR*	pAVIFileCF)
{
	m_pAVIFileCF = pAVIFileCF;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CFactoryImpl::QueryInterface(
	REFIID	iid,
	LPVOID FAR*	ppv)
{
	return m_pAVIFileCF->m_Unknown.QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CFactoryImpl::AddRef()
{
	return m_pAVIFileCF->m_Unknown.AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CFactoryImpl::Release()
{
	return m_pAVIFileCF->m_Unknown.Release();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CFactoryImpl::CreateInstance(
	IUnknown FAR*	pUnknownOuter,
	REFIID	riid,
	LPVOID FAR*	ppv)
{
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVIFile)) {
		return CAVIFile::Create(pUnknownOuter, riid, ppv);
	} else 
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVICmprsStream)) {
		return CAVICmpStream::Create(pUnknownOuter, riid, ppv);
	} else 
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVISimpleUnMarshal)) {
		return CUnMarshal::Create(pUnknownOuter, riid, ppv);
	} else 
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_EditStream)) {
		return CEditStream::NewInstance(pUnknownOuter, riid, ppv);
	} else {
		return ResultFromScode(CO_E_CANTDETERMINECLASS); // !!!
	}
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CFactoryImpl::LockServer(
	BOOL	fLock)
{
	fLocked = fLock;
	return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avimem.h ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993. All rights reserved.
*/

#ifdef __cplusplus
class FAR CAVIMemStream : public IAVIStream {
public:
    CAVIMemStream();
public:
    STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
    STDMETHODIMP_(ULONG) AddRef();	\
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHODIMP Info        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize);
    STDMETHODIMP_(LONG)  FindSample (THIS_ LONG lPos, LONG lFlags);
    STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *cbFormat);
    STDMETHODIMP SetFormat   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer,
			      DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);
    STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
    STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);
    
public:
    ULONG	m_refs;

    LPVOID	m_lpMemory;

    LPVOID	m_lpFormat;
    LONG	m_cbFormat;
    LPVOID	m_lpData;
    LONG	m_cbData;

    AVISTREAMINFO     m_avistream;      // stream info
};
#endif

#ifdef __cplusplus
extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\buffer.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#include "fileshar.h"
    
#pragma warning(disable:4200)

typedef struct {
    LONG    lOffset;
    LONG    lLength;
    LPVOID  lpBuffer;
} BUFFER;

typedef struct {
    int	    nBuffers;
    LONG    lBufSize;
    LPVOID  lpBufMem;
    HSHFILE hshfile;
    BOOL    fStreaming;
    BOOL    fUseDOSBuf;
    PAVIINDEX px;
    LONG      lx;
    LONG    lFileLength;
    int	    iNextBuf;
    BUFFER  aBuf[];
} BUFSYSTEM, *PBUFSYSTEM;

PBUFSYSTEM FAR PASCAL InitBuffered(int nBuffers, LONG lBufSize,
				    HSHFILE hshfile,
                                    PAVIINDEX px);

LONG FAR PASCAL BufferedRead(PBUFSYSTEM pb, LONG l, LONG cb, LPVOID lp);

LONG FAR PASCAL BeginBufferedStreaming(PBUFSYSTEM pb, BOOL fForward);
LONG FAR PASCAL EndBufferedStreaming(PBUFSYSTEM pb);

void FAR PASCAL EndBuffered(PBUFSYSTEM pb);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\aviopts.c ===
/****************************************************************************
 *
 *  AVIOPTS.C
 *
 *  routine for bringing up the compression options dialog
 *
 *      AVISaveOptions()
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <mmreg.h>
#include <msacm.h>
#include <compman.h>
#include "avifile.h"
#include "aviopts.h"
#include "aviopts.dlg"

#ifdef WIN32
	//!!! ACK the ACM does not work on NT
	#define acmGetVersion()	0
        #define acmFormatChoose(x) 1  // some error.
        #define ICCompressorChoose(hwnd,a,b,c,d,e) 0
        #define ICCompressorFree(x)
#endif

/****************************************************************************
 ***************************************************************************/

extern HINSTANCE ghMod;

LONG FAR PASCAL _export AVICompressOptionsDlgProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);

/****************************************************************************
 ***************************************************************************/


int  gnNumStreams = 0;			// how many streams in array
int  gnCurStream = 0;			// which stream's options we're setting
PAVISTREAM FAR *gapAVI;	        	// array of stream pointers
LPAVICOMPRESSOPTIONS FAR *gapOpt;	// array of option structures to fill
UINT	  guiFlags;
COMPVARS  gCompVars;                    // for ICCompressorChoose

/****************************************************************************
 ***************************************************************************/
/*************************************************************
* @doc EXTERNAL AVISaveOptions
*
* @api BOOL | AVISaveOptions | This function gets the save options for 
*      a file and returns them in a buffer.
*
* @parm HWND | hwnd | Specifies the parent window handle for the Compression Options 
*       dialog box.
*
* @parm UINT | uiFlags | Specifies the flags for displaying the 
*       Compression Options dialog box. The following flags are defined: 
*
* @flag ICMF_CHOOSE_KEYFRAME | Displays a "Key frame every" box for 
*       the video options. This is the same flag used in <f ICCompressorChoose>.
*
* @flag ICMF_CHOOSE_DATARATE | Displays a "Data rate" box for the video
*       options. This is the same flag used in <f ICCompressorChoose>.
*
* @flag ICMF_CHOOSE_PREVIEW | Displays a "Preview" button for 
*       the video options. This button previews the compression 
*       using a frame from the stream. This is the same flag 
*      used in <f ICCompressorChoose>.
*
* @parm int | nStreams | Specifies the number of streams 
*       that will have their options set by the dialog box.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer to an 
*       array of stream interface pointers. The <p nStreams> 
*       parameter indicates the number of pointers in the array.
*
* @parm LPAVICOMPRESSOPTIONS FAR * | plpOptions | Specifies a pointer 
*       to an array of <t LPAVICOMPRESSOPTIONS> pointers 
*       to hold the compression options set by the dialog box. The 
*       <p nStreams> parameter indicates the number of 
*       pointers in the array.
*
* @rdesc Returns TRUE if the user pressed OK, FALSE for CANCEL or an error.
* 
* @comm This function presents a standard Compression Options dialog
*       box using <p hwnd> as the parent window handle. When the 
*       user is finished selecting the compression options for 
*       each stream, the options are returned in the <t AVICOMPRESSOPTIONS> 
*       structures in the array referenced by <p lpOptions>. The caller 
*       must pass the interface pointers for the streams 
*       in the array referenced by <p ppavi>.
*
******************************************************************/
STDAPI_(BOOL) AVISaveOptions(HWND hwnd, UINT uiFlags, int nStreams, PAVISTREAM FAR *ppavi, LPAVICOMPRESSOPTIONS FAR *plpOptions)
{
    BOOL        f;
    AVICOMPRESSOPTIONS FAR *aOptions;
    int		i;

    /* Save the stream pointer */
    gnNumStreams = nStreams;
    gnCurStream = -1;
    gapAVI = ppavi;
    gapOpt = plpOptions;
    guiFlags = uiFlags;

    //
    // Remember the old compression options in case we cancel and need to 
    // restore them
    //
    aOptions = (AVICOMPRESSOPTIONS FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(AVICOMPRESSOPTIONS));
    if (!aOptions)
	return FALSE;
    for (i = 0; i < nStreams; i++)
	aOptions[i] = *plpOptions[i];

    f = DialogBox (ghMod, "AVICompressOptionsDialog", hwnd,
		(DLGPROC)AVICompressOptionsDlgProc);
 
    //
    // The user cancelled... put the old compression options back.
    //
    if (f == 0)
        for (i = 0; i < nStreams; i++)
	    *plpOptions[i] = aOptions[i];
	
    // Couldn't bring up the dialog
    if (f == -1)
	f = 0;

    GlobalFreePtr(aOptions);

    // !!! Returning TRUE doesn't guarantee something actually changed...
    return f;
}

/*************************************************************
* @doc EXTERNAL AVISaveOptionsFree
*
* @api LONG | AVISaveOptionsFree | This function frees the resources allocated
*      by <f AVISaveOptions>.
*
* @parm int | nStreams | Specifies the number of <t AVICOMPRESSOPTIONS>
*       structures in the array passed in as the next parameter.
*
* @parm LPAVICOMPRESSOPTIONS FAR * | plpOptions | Specifies a pointer 
*       to an array of <t LPAVICOMPRESSOPTIONS> pointers 
*       to hold the compression options set by the dialog box. The 
*       resources in each of these structures that were allocated by
*       <f AVISaveOptions> will be freed.
*
* @rdesc This function always returns AVIERR_OK (zero)
* 
* @comm This function frees the resources allocated by <f AVISaveOptions>.
**************************************************************/
STDAPI AVISaveOptionsFree(int nStreams, LPAVICOMPRESSOPTIONS FAR *plpOptions)
{
    for (; nStreams > 0; nStreams--) {
	if (plpOptions[nStreams-1]->lpParms)
	    GlobalFreePtr(plpOptions[nStreams-1]->lpParms);
	plpOptions[nStreams-1]->lpParms = NULL;
	if (plpOptions[nStreams-1]->lpFormat)
	    GlobalFreePtr(plpOptions[nStreams-1]->lpFormat);
	plpOptions[nStreams-1]->lpFormat = NULL;
    }
    return AVIERR_OK;
}

/****************************************************************************
 	Bring up the compression options for the current stream
 ***************************************************************************/
BOOL StreamOptions(HWND hwnd) {
    AVISTREAMINFO	avis;
    BOOL		f = FALSE;
    LONG		lTemp;
    UINT		w;
    
    // Get the stream type
    if (AVIStreamInfo(gapAVI[gnCurStream], &avis, sizeof(avis)) != 0)
        return FALSE;

    //
    // Video stream -- bring up the video compression dlg
    //
    if (avis.fccType == streamtypeVIDEO) {

        // The structure we have now is not filled in ... init it
        if (!(gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_VALID)) {
	    _fmemset(gapOpt[gnCurStream], 0,
		    sizeof(AVICOMPRESSOPTIONS));
	    gapOpt[gnCurStream]->fccHandler = comptypeDIB;
	    gapOpt[gnCurStream]->dwQuality = DEFAULT_QUALITY;
        }

        _fmemset(&gCompVars, 0, sizeof(gCompVars));
        gCompVars.cbSize = sizeof(gCompVars);
        gCompVars.dwFlags = ICMF_COMPVARS_VALID;
        gCompVars.fccHandler = gapOpt[gnCurStream]->fccHandler;
        gCompVars.lQ = gapOpt[gnCurStream]->dwQuality;
        gCompVars.lpState = gapOpt[gnCurStream]->lpParms;
        gCompVars.cbState = gapOpt[gnCurStream]->cbParms;
        gCompVars.lKey =
	    (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_KEYFRAMES)?
	    (gapOpt[gnCurStream]->dwKeyFrameEvery) : 0;
        gCompVars.lDataRate =
	    (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_DATARATE) ?
	    (gapOpt[gnCurStream]->dwBytesPerSecond / 1024) : 0;
    
        // !!! Don't pass flags verbatim if others are defined!!!
        f = ICCompressorChoose(hwnd, guiFlags, NULL,
		    gapAVI[gnCurStream], &gCompVars, NULL);

        /* Set the options to our new values */
        gapOpt[gnCurStream]->lpParms = gCompVars.lpState;
        gapOpt[gnCurStream]->cbParms = gCompVars.cbState;
	gCompVars.lpState = NULL;	// so it won't be freed
        gapOpt[gnCurStream]->fccHandler = gCompVars.fccHandler;
        gapOpt[gnCurStream]->dwQuality = gCompVars.lQ;
        gapOpt[gnCurStream]->dwKeyFrameEvery = gCompVars.lKey;
        gapOpt[gnCurStream]->dwBytesPerSecond = gCompVars.lDataRate
	    * 1024;
        if (gCompVars.lKey)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_KEYFRAMES;
        else
	    gapOpt[gnCurStream]->dwFlags &=~AVICOMPRESSF_KEYFRAMES;
        if (gCompVars.lDataRate)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_DATARATE;
        else
	    gapOpt[gnCurStream]->dwFlags &=~AVICOMPRESSF_DATARATE;

        // If they pressed OK, we have valid stuff in here now.
        if (f)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_VALID;
	
        // Close the stuff opened by ICCompressorChoose
        ICCompressorFree(&gCompVars);

    //
    // Bring up the ACM format dialog and stuff it in our
    // compression options structure
    //
    } else if (avis.fccType == streamtypeAUDIO) {

        ACMFORMATCHOOSE acf;
	LONG lsizeF = 0;

        if (acmGetVersion() < 0x02000000L) {
	    char achACM[160];
	    char achACMV[40];
	    
	    LoadString(ghMod, IDS_BADACM, achACM, sizeof(achACM));
	    LoadString(ghMod, IDS_BADACMV, achACMV, sizeof(achACMV));

	    MessageBox(hwnd, achACM, achACMV, MB_OK | MB_ICONHAND);
	    return FALSE;
        }

        _fmemset(&acf, 0, sizeof(acf));	// or ACM blows up
        acf.cbStruct = sizeof(ACMFORMATCHOOSE);
        // If our options struct has valid data, use it to init
        // the acm dialog with, otherwise pick a default.
        acf.fdwStyle = (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_VALID)
			       ? ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT : 0;
        acf.hwndOwner = hwnd;

	// Make sure the AVICOMPRESSOPTIONS has a big enough lpFormat
	acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, (LPVOID)&lTemp);
	if ((gapOpt[gnCurStream]->cbFormat == 0 ||
			gapOpt[gnCurStream]->lpFormat == NULL) && lTemp) {
	    gapOpt[gnCurStream]->lpFormat =
			GlobalAllocPtr(GMEM_MOVEABLE, lTemp);
	    gapOpt[gnCurStream]->cbFormat = lTemp;
	} else if (gapOpt[gnCurStream]->cbFormat < (DWORD)lTemp && lTemp) {
	    gapOpt[gnCurStream]->lpFormat =
			GlobalReAllocPtr(gapOpt[gnCurStream]->lpFormat, lTemp,
				GMEM_MOVEABLE);
	    gapOpt[gnCurStream]->cbFormat = lTemp;
	}
	
	if (!gapOpt[gnCurStream]->lpFormat)
	    return FALSE;

        acf.pwfx = gapOpt[gnCurStream]->lpFormat;
        acf.cbwfx = gapOpt[gnCurStream]->cbFormat;

	//
	// Only ask for choices that we can actually convert to
	//
	AVIStreamReadFormat(gapAVI[gnCurStream],
		AVIStreamStart(gapAVI[gnCurStream]), NULL, &lsizeF);

	// !!! Work around ACM bug by making sure our format is big enough
	lsizeF = max(lsizeF, sizeof(WAVEFORMATEX));
	acf.pwfxEnum = (LPWAVEFORMATEX)
		       GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, lsizeF);
	
	if (acf.pwfxEnum) {
	    AVIStreamReadFormat(gapAVI[gnCurStream],
		AVIStreamStart(gapAVI[gnCurStream]), acf.pwfxEnum, &lsizeF);
	    acf.fdwEnum |= ACM_FORMATENUMF_CONVERT;
	}

        // If they pressed OK, we now have valid stuff in here!
        w = acmFormatChoose(&acf);

	if (w == MMSYSERR_NOERROR)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_VALID;
	else if (w != ACMERR_CANCELED) {
	    MessageBeep(0); // !!! Should really be a message box!
	}

	if (acf.pwfxEnum)
	    GlobalFreePtr(acf.pwfxEnum);

	f = (w == MMSYSERR_NOERROR);
    }

    return f;
}

void NEAR PASCAL NewStreamChosen(HWND hwnd)
{
    BOOL	    f;
    AVISTREAMINFO   avis;
    DWORD	    dw;
    HIC		    hic;
    ICINFO	    icinfo;
    ACMFORMATDETAILS acmfmt;
    ACMFORMATTAGDETAILS	aftd;
    LONG	    lsizeF;
    LPBITMAPINFOHEADER lp = NULL;
    char	    szFFDesc[80];
    char	    szDesc[120];

    // Set the interleave options for the selection we're leaving
    // !!! This code also appears in the OK button
    if (gnCurStream >= 0) {		// there is a previous sel
	if (IsDlgButtonChecked(hwnd, IDC_intINTERLEAVE)) {
	    dw = (DWORD)GetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT,
		    NULL, FALSE);
	    gapOpt[gnCurStream]->dwInterleaveEvery = dw;
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_INTERLEAVE;
	} else {
	    dw = (DWORD)GetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT,
		    NULL, FALSE);
	    gapOpt[gnCurStream]->dwInterleaveEvery = dw;
	    gapOpt[gnCurStream]->dwFlags &=~AVICOMPRESSF_INTERLEAVE;
	}
    }

    gnCurStream = (int)SendDlgItemMessage(hwnd, IDC_intCHOOSESTREAM,
			    CB_GETCURSEL, 0, 0L);
    if (gnCurStream < 0)
	return;

    if (AVIStreamInfo(gapAVI[gnCurStream], &avis, sizeof(avis)) != 0)
	return;

    //
    // Show a string describing the current format
    //
    szDesc[0] = '\0';

    lsizeF = 0;
    AVIStreamReadFormat(gapAVI[gnCurStream],
	    AVIStreamStart(gapAVI[gnCurStream]), NULL, &lsizeF);
    if (lsizeF) {
	lp = (LPBITMAPINFOHEADER)GlobalAllocPtr(GHND, lsizeF);
	if (lp) {
	    if (AVIStreamReadFormat(gapAVI[gnCurStream],
				    AVIStreamStart(gapAVI[gnCurStream]),
				    lp, &lsizeF) == AVIERR_OK) {
		if (avis.fccType == streamtypeVIDEO) {
		    wsprintf(szDesc, "%ldx%ldx%d\n", lp->biWidth,
			     lp->biHeight, lp->biBitCount);
		    if (lp->biCompression == BI_RGB) {
			LoadString(ghMod, IDS_FFDESC, szFFDesc,
				   sizeof(szFFDesc));
			lstrcat(szDesc, szFFDesc);
		    } else {
			hic = ICDecompressOpen(ICTYPE_VIDEO,avis.fccHandler,
					       lp, NULL);
			if (hic) {
			    if (ICGetInfo(hic, &icinfo,sizeof(icinfo)) != 0)
				lstrcat(szDesc, icinfo.szDescription);
			    ICClose(hic);
			}
		    }
		} else if (avis.fccType == streamtypeAUDIO) {
		    _fmemset(&acmfmt, 0, sizeof(acmfmt));
		    acmfmt.pwfx = (LPWAVEFORMATEX) lp;
		    acmfmt.cbStruct = sizeof(ACMFORMATDETAILS);
		    acmfmt.dwFormatTag = acmfmt.pwfx->wFormatTag;
		    acmfmt.cbwfx = lsizeF;
		    aftd.cbStruct = sizeof(aftd);
		    aftd.dwFormatTag = acmfmt.pwfx->wFormatTag;
		    aftd.fdwSupport = 0;

		    if ((acmFormatTagDetails(NULL, 
					     &aftd,
					     ACM_FORMATTAGDETAILSF_FORMATTAG) == 0) && 
			(acmFormatDetails(NULL, &acmfmt,
					  ACM_FORMATDETAILSF_FORMAT) == 0)) {
			wsprintf(szDesc, "%s %s", (LPSTR) acmfmt.szFormat,
				 (LPSTR) aftd.szFormatTag);
		    }
		}
	    }
		
	    GlobalFreePtr(lp);
	}
    }
    SetDlgItemText(hwnd, IDC_intFORMAT, szDesc);

    //
    // AUDIO and VIDEO streams have a compression dialog
    //
    if (avis.fccType == streamtypeAUDIO ||
		    avis.fccType == streamtypeVIDEO)
	EnableWindow(GetDlgItem(hwnd, IDC_intOPTIONS), TRUE);
    else
	EnableWindow(GetDlgItem(hwnd, IDC_intOPTIONS), FALSE);

    //
    // Every stream but the first has an interleave options
    //
    if (gnCurStream > 0) {
	EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVE), TRUE);
	EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVEEDIT),
		    TRUE);
	EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVETEXT),
		    TRUE);
	// Set the interleave situation for this stream
	f = (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_INTERLEAVE)
		    != 0;
	dw = gapOpt[gnCurStream]->dwInterleaveEvery;
	CheckDlgButton(hwnd, IDC_intINTERLEAVE, f);
	SetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT, (int)dw, FALSE);
    } else {
	EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVE),FALSE);
	EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVEEDIT),
		    FALSE);
	EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVETEXT),
		    FALSE);
    }
    
}


/*--------------------------------------------------------------+
* Dialog Proc for the main compression options dialog		*
+--------------------------------------------------------------*/
LONG FAR PASCAL _export AVICompressOptionsDlgProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
{
  int   nVal;
  AVISTREAMINFO avis;
  DWORD dw;
  
  switch(msg){
    case WM_INITDIALOG:

	    //
	    // If we've only got one stream to set the options for, it seems
	    // strange to bring up a box to let you choose which stream you want.
	    // Let's skip straight to the proper options dlg box.
	    //
	    if (gnNumStreams == 1) {
		gnCurStream = 0;
		EndDialog(hwnd, StreamOptions(hwnd));
		return TRUE;
	    }

            /* Add the list of streams to the drop-down box */
            for (nVal = 0; nVal < gnNumStreams; nVal++) {
		// Get the name of this stream
		AVIStreamInfo(gapAVI[nVal], &avis, sizeof(avis));
                SendDlgItemMessage(hwnd, IDC_intCHOOSESTREAM, CB_ADDSTRING, 0,
                                (LONG) (LPSTR)avis.szName);
	    }

            // Set our initial selection to the first item
            SendDlgItemMessage(hwnd, IDC_intCHOOSESTREAM, CB_SETCURSEL, 0, 0L);
	    // Make sure we see it
            SendMessage(hwnd, WM_COMMAND, IDC_intCHOOSESTREAM,
            	MAKELONG(GetDlgItem(hwnd, IDC_intCHOOSESTREAM), CBN_SELCHANGE));

            return TRUE;
	    
    case WM_COMMAND:
	switch(wParam){
            case IDOK:
		// Set the interleave options for the selection we're on
		// !!! This code also appears in the SELCHANGE code
		if (gnCurStream >= 0) {		// there is a valid selection
    		    if (IsDlgButtonChecked(hwnd, IDC_intINTERLEAVE)) {
		        dw = (DWORD)GetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT,
				NULL, FALSE);
		        gapOpt[gnCurStream]->dwInterleaveEvery = dw;
		        gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_INTERLEAVE;
		    } else {
			// why not remember edit box entry anyway?
		        dw = (DWORD)GetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT,
				NULL, FALSE);
		        gapOpt[gnCurStream]->dwInterleaveEvery = dw;
		        gapOpt[gnCurStream]->dwFlags &=~AVICOMPRESSF_INTERLEAVE;
		    }
		}
		// fall through	(AAAAaaaahhhhh.....)

	    case IDCANCEL:
                EndDialog(hwnd, wParam == IDOK);
                break;

            case IDC_intOPTIONS:
		StreamOptions(hwnd);
		break;

	    //
	    // Somebody chose a new stream.  Do we need to grey InterleaveOpts?
	    // Set the current stream.
	    //
            case IDC_intCHOOSESTREAM:
                if (HIWORD(lParam) != CBN_SELCHANGE)
                    break;

		NewStreamChosen(hwnd);
                break;

	    case IDC_intINTERLEAVE:
		break;

	    default:
		break;
	}
	break;
	    
    default:
	return FALSE;
  }
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\aviopts.h ===
/*--------------------------------------------------------------+
| IntOpts.h - Header file for Interleaving options dialog	|
|								|
|(C) Copyright Microsoft Corporation 1991.  All rights reserved.|
+--------------------------------------------------------------*/

/*
 * Defines
 */

#define comptypeNONE            0

#include "avifile.rc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avimem.cpp ===
/****************************************************************************
 *
 *  AVIMEM.C
 *
 *  routine for putting a stream interface on top of data in memory
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <compman.h>
#include <compobj.h>
#include <avifmt.h>
#include "avifile.h"
#include "avifilei.h"
#include "avimem.h"

#define WIDTHBYTES(i)       ((UINT)((i+31)&(~31))/8)
#define DIBWIDTHBYTES(lpbi) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(lpbi)->biBitCount)

STDAPI AVIMakeStreamFromClipboard(UINT cfFormat, HANDLE hGlobal, PAVISTREAM FAR *ppstream)
{
    CAVIMemStream FAR*	pAVIStream;
    HRESULT		hr;
    LPVOID		lp;

    if (cfFormat != CF_DIB && cfFormat != CF_WAVE)
	return ResultFromScode(AVIERR_UNSUPPORTED);
    
    pAVIStream = new FAR CAVIMemStream();
    if (!pAVIStream)
	return ResultFromScode(E_OUTOFMEMORY);

    lp = GlobalAllocPtr(GMEM_MOVEABLE, GlobalSize(hGlobal));
    if (!lp)
	return ResultFromScode(E_OUTOFMEMORY);

    hmemcpy(lp, GlobalLock(hGlobal), GlobalSize(hGlobal));
	
    pAVIStream->Create((LONG) cfFormat, (LONG) lp);
    
    hr = pAVIStream->QueryInterface(IID_IAVIStream, (LPVOID FAR *) ppstream);
    if (FAILED(GetScode(hr)))
	delete pAVIStream;
    return hr;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIMemStream::CAVIMemStream()
{
    m_lpData = NULL;
    m_lpMemory = NULL;
    m_lpFormat = NULL;
    m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIMemStream::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
    if (iid == IID_IUnknown)
	*ppv = this;
    else if (iid == IID_IAVIStream)
	*ppv = this;
    else
	return ResultFromScode(E_NOINTERFACE);
    AddRef();
    return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIMemStream::AddRef()
{
    uUseCount++;
    return ++m_refs;
}


/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIMemStream::Create(LONG lParam1, LONG lParam2)
{
    UINT    cfFormat = (UINT) lParam1;
    m_lpMemory = (LPVOID) lParam2;

    if (cfFormat == CF_DIB) {
	LPBITMAPINFOHEADER lpbi;
	
	m_lpFormat = m_lpMemory;
	lpbi = (LPBITMAPINFOHEADER) m_lpFormat;

	if (lpbi->biSizeImage == 0) {
	    if (lpbi->biCompression = BI_RGB) {
		lpbi->biSizeImage = DIBWIDTHBYTES(lpbi) *
				    lpbi->biHeight;
	    }
	}

	_fmemset(&m_avistream, 0, sizeof(m_avistream));
	m_avistream.fccType = streamtypeVIDEO;
	m_avistream.fccHandler = 0;
	m_avistream.dwStart = 0;
	m_avistream.dwLength = 1;
	m_avistream.dwScale = 1;
	m_avistream.dwRate = 15;
	m_avistream.dwSampleSize = 0;
	SetRect(&m_avistream.rcFrame, 0, 0,
		(int) lpbi->biWidth,
		(int) lpbi->biHeight);
	
	m_cbFormat = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);
	m_lpData = (LPBYTE) m_lpMemory + m_cbFormat;
	m_cbData = lpbi->biSizeImage;
    } else if (cfFormat == CF_WAVE) {
	DWORD _huge * lpdw;
	LPWAVEFORMAT lpwf;
#define ckidWAVEFORMAT          mmioFOURCC('f', 'm', 't', ' ')
#define ckidWAVEDATA	        mmioFOURCC('d', 'a', 't', 'a')

	lpdw = (DWORD _huge *) ((LPBYTE) m_lpMemory + 12);

	while (*lpdw != ckidWAVEFORMAT)
	    lpdw = (DWORD _huge *)
		   (((BYTE _huge *) lpdw) + lpdw[1] + sizeof(DWORD) * 2);
	
	m_lpFormat = (LPBYTE) (lpdw + 2);
	m_cbFormat = lpdw[1];

	do {
	    lpdw = (DWORD _huge *)
		   (((BYTE _huge *) lpdw) + lpdw[1] + sizeof(DWORD) * 2);
	} while (*lpdw != ckidWAVEDATA);
	
	m_lpData = (LPBYTE) (lpdw + 2);
	m_cbData = lpdw[1];

	lpwf = (LPWAVEFORMAT) m_lpFormat;
	
	_fmemset(&m_avistream, 0, sizeof(m_avistream));
	m_avistream.fccType = streamtypeAUDIO;
	m_avistream.fccHandler = 0;
	m_avistream.dwStart = 0;
	m_avistream.dwSampleSize = lpwf->nBlockAlign;
	m_avistream.dwLength = m_cbData / m_avistream.dwSampleSize;
	m_avistream.dwScale = lpwf->nBlockAlign;
	m_avistream.dwRate = lpwf->nAvgBytesPerSec;
    }

    return 0;
}

STDMETHODIMP_(ULONG) CAVIMemStream::Release()
{
    uUseCount--;
    if (!--m_refs) {
	if (m_lpMemory) {
	    GlobalFreePtr(m_lpMemory);
	}

	delete this;
	return 0;
    }

    return m_refs;
}


STDMETHODIMP CAVIMemStream::Info(AVISTREAMINFO FAR * psi, LONG lSize)
{
    hmemcpy(psi, &m_avistream, min(lSize, sizeof(m_avistream)));
    
//    return sizeof(m_avistream);
    return ResultFromScode(0);
}

STDMETHODIMP CAVIMemStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    if (lpFormat) {
	hmemcpy(lpFormat, m_lpFormat, min(*lpcbFormat, (LONG) m_cbFormat));
    }
    
    *lpcbFormat = m_cbFormat;
    return AVIERR_OK;
}

STDMETHODIMP CAVIMemStream::Read(
                      LONG       lStart,
                      LONG       lSamples,
                      LPVOID     lpBuffer,
                      LONG       cbBuffer,
                      LONG FAR * plBytes,
                      LONG FAR * plSamples)
{
    // !!! CONVENIENT?
    if (lStart + lSamples > (LONG) m_avistream.dwLength)
	lSamples = (LONG) m_avistream.dwLength - lStart;
	
    if (lSamples == 0 || lStart >= (LONG) m_avistream.dwLength) {
	if (plBytes)
	    *plBytes = 0;
	if (plSamples)
	    *plSamples = 0;
    }
    
    if (m_avistream.dwSampleSize) {
	if (lSamples > 0)
	    lSamples = min(lSamples, cbBuffer / (LONG) m_avistream.dwSampleSize);
	else
	    lSamples = cbBuffer / m_avistream.dwSampleSize;

	if (plBytes)
	    *plBytes = lSamples * m_avistream.dwSampleSize;

	if (plSamples)
	    *plSamples = lSamples;

	hmemcpy(lpBuffer,
		(BYTE _huge *) m_lpData + lStart * m_avistream.dwSampleSize,
		lSamples * m_avistream.dwSampleSize);
	
	if (cbBuffer < (LONG) m_avistream.dwSampleSize)
	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
    } else {
	if (plBytes)
	    *plBytes = m_cbData;

	if (plSamples)
	    *plSamples = 1;
	if (lpBuffer) {
	    hmemcpy(lpBuffer, m_lpData, min(cbBuffer, m_cbData));

	    if (cbBuffer < m_cbData)
		return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}
    }
    
    return AVIERR_OK;
}

STDMETHODIMP_(LONG) CAVIMemStream::FindSample(LONG lPos, LONG lFlags)
{
    if (lFlags & FIND_FORMAT) {
	if (lFlags & FIND_PREV)
	    return 0;
	else {
	    if (lPos > 0)
		return -1;
	    else
		return 0;   
	}
    }
    return lPos;
}


STDMETHODIMP CAVIMemStream::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Write(LONG lStart,
						     LONG lSamples,
						     LPVOID lpBuffer,
						     LONG cbBuffer,
						     DWORD dwFlags,
						     LONG FAR *plSampWritten,
						     LONG FAR *plBytesWritten)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Delete(LONG lStart,LONG lSamples)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::ReadData(DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::WriteData(DWORD fcc, LPVOID lp, LONG cb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#if 0
STDMETHODIMP CAVIMemStream::Clone(PAVISTREAM FAR * ppaviNew)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#endif


STDMETHODIMP CAVIMemStream::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avisave.c ===
/****************************************************************************
 *
 *  AVISAVE.C
 *
 *  routine for writing Standard AVI files
 *
 *      AVISave()
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <compobj.h>
#include <valid.h>
#include <compman.h>
#include "avifmt.h"
#include "avifile.h"
#include "avicmprs.h"
#include "debug.h"
//extern LONG FAR PASCAL muldiv32(LONG,LONG,LONG);

/************************************************************************/
/* Auto-doc for the AVICOMPRESSOPTIONS structure.  Make sure it matches	*/
/* the declarations in avifile.h !!!                                    */
/************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL AVICOMPRESSOPTIONS
 * 
 * @types AVICOMPRESSOPTIONS | This structure contains information
 *	       about a stream and how it is to be compressed and saved. 
 *        This structure passes data to <f AVIMakeCompressedStream> 
 *        (or <f AVISave> which uses <f AVIMakeCompressedStream>).
 * 
 * @field DWORD | fccType | Specifies a four-character code 
 *        indicating the stream type. The following 
 *        constants have been defined for the data commonly 
 *        found in AVI streams:
 *
 * @flag  streamtypeAUDIO | Indicates an audio stream.
 * @flag  streamtypeMIDI | Indicates a MIDI stream.
 * @flag  streamtypeTEXT | Indicates a text stream.
 * @flag  streamtypeVIDEO | Indicates a video stream.
 * 
 * @field DWORD | fccHandler | For a video stream, specifies the 
 *        four-character code for the compressor handler that 
 *        will compress this stream when it is saved 
 *        (For example, mmioFOURCC('M','S','V','C')). 
*         This member is not used for audio streams.
 * 
 * @field DWORD | dwKeyFrameEvery | Specifies the maximum period 
 *        between key frames. This member is used only 
 *        if the AVICOMPRESSF_KEYFRAMES flag is set, otherwise 
 *        every frame is a key frame. 
 * 
 * @field DWORD | dwQuality | Specifies the quality value passed 
 *        to a video compressor. This member is not used for 
 *        an audio compressor.
 * 
 * @field DWORD | dwBytesPerSecond | Specifies the data rate a video
 *	       compressor should use.  This member is used only 
 *        if the AVICOMPRESSF_DATARATE flag is set.
 * 
 * @field DWORD | dwFlags | Specifies the flags used for compression:
 * 
 *   @flag AVICOMPRESSF_INTERLEAVE | Indicates this stream is to be interleaved
 *         every <e AVICOMPRESSOPTIONS.dwInterleaveEvery> frames 
 *         with respect to the first stream.
 * 
 *   @flag AVICOMPRESSF_KEYFRAMES | Indicates this video stream 
 *         is to be saved with key frames at least 
 *         every <e AVICOMPRESSOPTIONS.dwKeyFrameEvery> frames.
 *	   By default, every frame will be a key frame.
 * 
 *   @flag AVICOMPRESSF_DATARATE | Indicates this video stream 
 *         is to be compressed with the data rate 
 *         specified in <e AVICOMPRESSOPTIONS.dwBytesPerSecond>.
 * 
 *   @flag AVICOMPRESSF_VALID | Indicates this structure contains 
 *         valid data. If this flag is set, AVIFile uses the structure 
 *         data to set the default compression values for <f AVISaveOptions>.  
 *         If an empty structure is passed and this flag is not set, 
 *         some defaults will be chosen.
 * 
 * @field LPVOID | lpFormat | Specifies a pointer to a structure 
 *        defining the data format. For an audio stream, 
 *        this is an <t LPWAVEFORMAT> structure.
 * 
 * @field DWORD | cbFormat | Specifies the size of the data referenced by 
 *	       <e AVICOMPRESSOPTIONS.lpFormat>
 * 
 * @field LPVOID | lpParms | Used internally to store compressor 
 *        specific data.
 * 
 * @field DWORD | cbParms | Specifies the size of the data referenced by 
 *        <e AVICOMPRESSOPTIONS.lpParms>
 * 
 * @field DWORD | dwInterleaveEvery | Specifies how often 
 *        to interleave stream data with the data 
 *        from the first stream.  Used only if the
 *	       AVICOMPRESSF_INTERLEAVE flag is set.
 * 
 ***************************************************************************/

/*******************************************************************
* @doc EXTERNAL AVISave
*
* @api LONG | AVISave | This function is used to save an AVI file.
*
* @parm LPCSTR | szFile | Specifies a zero-terminated string 
*       containing the name of the file to save.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to the
*       file handler used to write the file. The file will
*       be created by calling <f AVIFileOpen> using this handler. If
*       a handler is not specified, a default one is selected based 
*       upon the file extension.
*
* @parm AVISAVECALLBACK | lpfnCallback | Specifies a far pointer to 
 *      a callback function for the save operation.
*
* @parm int | nStreams | Specifies the number of streams saved in the 
*       the file. 
*
* @parm PAVISTREAM | pavi | Specifies a pointer an AVI stream. 
*       This parameter is paired with <p lpOptions>. The parameter 
*       pair can be repeated as a variable number of arguments.
*
* @parm LPAVICOMPRESSOPTIONS | lpOptions | Specifies a pointer to an 
*       <t AVICOMPRESSOPTIONS> structure containing the compression 
*       options for the stream referenced by <p pavi>.
*       This parameter is paired with <p pavi>. The parameter 
*       pair can be repeated as a variable number of arguments.
*
* @parm .| . . | Additional streams can be appened 
*       by including more <p pavi> and <p lpOptions> parameter pairs.
*
* @rdesc Returns AVIERR_OK if successful; otherwise it returns an error code.
*
* @comm This function saves an AVI sequence to the file
*       specified by <p szFile>. The <p pavi> and <p lpOptions> parameters 
*       define the streams saved. If saving more than one stream, 
*       repeat the <p pavi> and <p lpOptions> parameter pair for 
*       each additional stream.
*
*      A callback function can be supplied in <p lpfnCallback> to 
*      display status information and let the user cancel the 
*      save operation.  The callback uses the following format:
*
*      LONG FAR PASCAL SaveCallback(int nPercent)
*	
*	    The <p nPercent> parameter specifies the percentage of the 
*      file saved.
*
*	    The callback function should return AVIERR_OK if the
*      operation should continue and AVIERR_USERABORT if the 
*      user wishes to abort the save operation.
*    
*
* @xref <f AVISaveV> <f AVISaveOptions>
*
*******************************************************************/
EXTERN_C HRESULT CDECL AVISave(LPCSTR               szFile,
		    CLSID FAR *pclsidHandler,   
                    AVISAVECALLBACK     lpfnCallback,
		    int			nStreams,
                    PAVISTREAM          pavi,
                    LPAVICOMPRESSOPTIONS lpOptions,
		    ...
		    )
{
    PAVISTREAM FAR 		*apavi;
    LPAVICOMPRESSOPTIONS FAR	*alpOptions;
    int	i;
    HRESULT	hr;

    //
    // We were passed arguments of the form PAVI, OPTIONS, PAVI, OPTIONS, etc.
    // for AVISaveV, we need to separate these into an array of PAVI's and
    // an array of LPAVICOMPRESSOPTIONS.
    //

    apavi = (PAVISTREAM FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(PAVISTREAM));
    alpOptions = (LPAVICOMPRESSOPTIONS FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(LPAVICOMPRESSOPTIONS));
    if (!apavi || !alpOptions)
	return ResultFromScode(AVIERR_MEMORY);

    for (i = 0; i < nStreams; i++) {
	apavi[i] = *(PAVISTREAM FAR *)((LPBYTE)&pavi +
		(sizeof(PAVISTREAM) + sizeof(LPAVICOMPRESSOPTIONS)) * i);
	alpOptions[i] = *(LPAVICOMPRESSOPTIONS FAR *)((LPBYTE)&lpOptions +
		(sizeof(PAVISTREAM) + sizeof(LPAVICOMPRESSOPTIONS)) * i);
    }

    hr = AVISaveV(szFile, pclsidHandler, lpfnCallback, nStreams, apavi,
			alpOptions);

    GlobalFreePtr(apavi);
    GlobalFreePtr(alpOptions);
    return hr;
}

BOOL FAR PASCAL DummySaveCallback(int iProgress)
{
    return FALSE;   // do nothing, allow save to continue
}

/**********************************************************************
* @doc EXTERNAL AVISaveV
*
* @api LONG | AVISaveV | This function is used to save an AVI file.
*
* @parm LPCSTR | szFile | Specifies a zero-terminated string 
*       containing the name of the file to save.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to the
*       file handler used to write the file. The file will
*       be created by calling <f AVIFileOpen> using this handler. If
*       a handler is not specified, a default one is selected based upon 
*       the file extension.
*
* @parm AVISAVECALLBACK | lpfnCallback | Specifies a pointer to a callback
*       function used to display status information and let the use 
*       cancel the save operation.
*
* @parm int | nStreams | Specifies the number of streams to save.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer to an 
*       array of <t PAVISTREAM> pointers. The array uses one pointer 
*       for each stream.
*
* @parm LPAVICOMPRESSOPTIONS FAR * | plpOptions | Specifies a pointer 
*       to an array of <t LPAVICOMPRESSOPTIONS> pointers. The 
*       uses one pointer for each stream.
*
* @rdesc Returns AVIERR_OK on success, an error code otherwise.
*
* @comm This function is equivalent to <f AVISave> except 
*       the streams are passed in an array instead of as a
*       variable number of arguments. (<f AVISaveV> is to <f AVISave> 
*       as <f wvsprintf> is to <f wsprintf>.)
*
* @xref <f AVISave> <f AVISaveOptions>
*
********************************************************************/
STDAPI AVISaveV(LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
                    AVISAVECALLBACK     lpfnCallback,
		    int			nStreams,
		    PAVISTREAM FAR *	ppavi,
		    LPAVICOMPRESSOPTIONS FAR * plpOptions)
{
    int		    stream;
    MainAVIHeader   hdrNew;
    PAVIFILE	    pfilesave = 0;
    HRESULT	    hr;
    AVISTREAMINFO   strhdr;
    AVIFILEINFO	    finfo;
    LONG	    cbFormat;
    DWORD	    dwSamplesRead;
    LPVOID	    lpBuffer = 0;
    DWORD	    dwBufferSize;
    LONG	    l;
    DWORD	    dwSize;
    DWORD	    dwFlags;
    WORD	    cktype;
    LPBITMAPINFOHEADER lpbi;
    DWORD	    dwInterleaveEvery = 0;

#define MAXSTREAMS  64
    
    int		    iVideoStream = -1;
    PAVISTREAM	    apavi[MAXSTREAMS];
    PAVISTREAM	    apaviNew[MAXSTREAMS];
    LONG	    lDone[MAXSTREAMS];
    LONG	    lInterval;
    

    if (nStreams > MAXSTREAMS)
	return ResultFromScode(AVIERR_INTERNAL);
    for (stream = 0; stream < nStreams; stream++) {
	apavi[stream] = NULL;
	apaviNew[stream] = NULL;
    }

    //
    // Open file and write out the main header
    //
    DPF("Creating new file\n");
    
    hr = AVIFileOpen(&pfilesave, szFile, OF_CREATE | OF_WRITE | OF_SHARE_EXCLUSIVE, pclsidHandler);
    if (hr != 0)
	goto Error;

    AVIFileInfo(pfilesave, &finfo, sizeof(finfo));

    DPF("Creating compressed streams\n");
    
    for (stream = 0; stream < nStreams; stream++) {
	if (!IsValidInterface(ppavi[stream])) {
	    hr = ResultFromScode(AVIERR_INTERNAL);
	    goto Error;
	}

	hr = AVIStreamInfo(ppavi[stream], &strhdr, sizeof(strhdr));

	if (hr != AVIERR_OK) {
	    DPF("Error from AVIStreamInfo!\n");
	    goto Error;
	}

	// Find the video stream....
	if (strhdr.fccType == streamtypeVIDEO) {
	    if (iVideoStream < 0) {
		iVideoStream = stream;
	    }
	} else if (strhdr.fccType == streamtypeAUDIO) {
	    if (dwInterleaveEvery == 0) {
		// Should the interleave factor be in the options at all?
		if (plpOptions && plpOptions[stream] &&
			plpOptions[stream]->dwFlags & AVICOMPRESSF_INTERLEAVE)
		    dwInterleaveEvery = plpOptions[stream]->dwInterleaveEvery;
	    }
	}

	apavi[stream] = NULL;
	
	if (plpOptions && plpOptions[stream] &&
		    (plpOptions[stream]->fccHandler ||
		     plpOptions[stream]->lpFormat)) {
	    DWORD   dwKeyFrameEvery = plpOptions[stream]->dwKeyFrameEvery;

	    if (finfo.dwCaps & AVIFILECAPS_ALLKEYFRAMES)
		plpOptions[stream]->dwKeyFrameEvery = 1;
	    
	    // If they've given compression options for this stream,
	    // use them....
	    hr = AVIMakeCompressedStream(&apavi[stream],
					 ppavi[stream],
					 plpOptions[stream],
					 NULL);

	    plpOptions[stream]->dwKeyFrameEvery = dwKeyFrameEvery;
	    
	    if (hr != 0) {
		DPF("AVISave: Failed to create compressed stream!\n");
		apavi[stream] = NULL;
		goto Error;	// !!!
	    } else {
		hr = AVIStreamInfo(apavi[stream], &strhdr, sizeof(strhdr));
		if (hr != 0) {
		    DPF("AVISave: Failed to create compressed stream!\n");
		    AVIStreamClose(apavi[stream]);
		    apavi[stream] = NULL;
		    goto Error;	// !!!
		}
	    }
	}

	if (apavi[stream] == NULL) {
	    // otherwise just copy the stream over....
	    apavi[stream] = ppavi[stream];
	    AVIStreamAddRef(apavi[stream]);
	}

	lDone[stream] = AVIStreamStart(apavi[stream]);
    }

    // Put the video stream first, so interleaving will work.
    // !!!
    if (iVideoStream > 0) {
	PAVISTREAM p;

	p = apavi[iVideoStream];
	apavi[iVideoStream] = apavi[0];
	apavi[0] = p;
	iVideoStream = 0;
    }
    
    if (lpfnCallback == NULL)
	lpfnCallback = &DummySaveCallback;

    /* pick a good buffer size and go for it.... */
    dwBufferSize = 32768L;

    lpBuffer = GlobalAllocPtr(GMEM_MOVEABLE, dwBufferSize);
    if (!lpBuffer) {
	hr = ResultFromScode(AVIERR_MEMORY);
	goto Error;
    }

    //
    // Construct AVI file header
    //
    AVIStreamInfo(apavi[0], &strhdr, sizeof(strhdr));
    hdrNew.dwMicroSecPerFrame = muldiv32(1000000L, strhdr.dwScale, strhdr.dwRate);
    hdrNew.dwMaxBytesPerSec = 0;      
    hdrNew.dwPaddingGranularity = 0;  
                       
    hdrNew.dwFlags = AVIF_HASINDEX;	       
    hdrNew.dwFlags &= ~(AVIF_ISINTERLEAVED | AVIF_WASCAPTUREFILE |
					AVIF_MUSTUSEINDEX);
    
    hdrNew.dwTotalFrames = strhdr.dwLength;       // !!!
    hdrNew.dwInitialFrames = 0;			  // !!!
    
    hdrNew.dwStreams = nStreams;	       
    hdrNew.dwSuggestedBufferSize = 32768; 
		       
    if (iVideoStream >= 0) {
	cbFormat = dwBufferSize;
	hr = AVIStreamReadFormat(apavi[iVideoStream],
				 AVIStreamStart(apavi[iVideoStream]),
				 lpBuffer,
				 &cbFormat);

	if (cbFormat < sizeof(BITMAPINFOHEADER)) {
	    hr = ResultFromScode(AVIERR_INTERNAL);
	}

	if (hr != 0) {
	    DPF("AVISave: Error from initial ReadFormat!\n");
	    goto Error;
	}
	
	lpbi = (LPBITMAPINFOHEADER) lpBuffer;

	hdrNew.dwWidth = lpbi->biWidth;
	hdrNew.dwHeight = lpbi->biHeight;
	lInterval = 1;
    } else {
	hdrNew.dwWidth = 0;
	hdrNew.dwHeight = 0;
	lInterval = AVIStreamTimeToSample(apavi[0], 500);
    }
		           
    //
    // Loop through streams and write out stream header
    //
    for (stream = 0; stream < nStreams; stream++) {
	// DPF2("Making stream %d header LIST\n", stream);

        AVIStreamInfo(apavi[stream], &strhdr, sizeof(strhdr));
	strhdr.dwInitialFrames = 0;

	// If we're interleaving, skew the audio by 3/4 of a second.
	if (dwInterleaveEvery > 0 && stream > 0) {
	    if (strhdr.fccType == streamtypeAUDIO) {
		strhdr.dwInitialFrames = AVIStreamTimeToSample(apavi[0], 750);
		DPF("Stream %d has %lu initial frames\n", stream, strhdr.dwInitialFrames);
	    }
	}
	
	
	//
	// Get stream format and write it out
	//
	cbFormat = dwBufferSize;
	hr = AVIStreamReadFormat(apavi[stream], AVIStreamStart(apavi[stream]),
				 lpBuffer, &cbFormat);
	if (hr != AVIERR_OK)
	    goto Error;

	// !!! Overflow?
	if (!cbFormat) {
	    // !!!
	}
	
	hr = AVIFileCreateStream(pfilesave, &apaviNew[stream], &strhdr);

#if 0
	if (hr != AVIERR_OK || apaviNew[stream] == NULL)
	    goto Error;
#else
	// If we can't make a stream, continue with the other streams....
	if (hr != AVIERR_OK || apaviNew[stream] == NULL) {
	    int i;

	    DPF("AVISave: Couldn't create stream in new file!\n");
	    AVIStreamClose(apavi[stream]);
	    
	    for (i = stream + 1; i < nStreams; i++) {
		apavi[stream] = apavi[stream + 1];
	    }
	    --nStreams;
	    --stream;
	    continue;
	}    
#endif

	hr = AVIStreamSetFormat(apaviNew[stream], 0, lpBuffer, cbFormat);
	if (hr != AVIERR_OK) {
	    DPF("Initial set format failed!\n");
	    goto Error;
	}
	
	cbFormat = dwBufferSize;
	hr = AVIStreamReadData(apavi[stream], ckidSTREAMHANDLERDATA,
				     lpBuffer, &cbFormat);
	// !!! overflow?
	
	if (hr == AVIERR_OK && cbFormat) {
	    /* 
	    ** Make the stream Data data chunk
	    */
	    // DPF2("Making stream %ld Data data chunk\n", stream);
	    hr = AVIStreamWriteData(apaviNew[stream], ckidSTREAMHANDLERDATA,
			lpBuffer, cbFormat);
	    if (hr != AVIERR_OK)
		goto Error;
	}

	if (strhdr.dwInitialFrames > hdrNew.dwInitialFrames)
	    hdrNew.dwInitialFrames = strhdr.dwInitialFrames;

	// !!! Should call ReadExtra and WriteExtra to move over information!
    }

    if (nStreams <= 0) {
	DPF("No streams at all accepted by the file!\n");
	goto Error;
    }
    
    //
    // We've written the header.  Now, there are two possibilities:
    //
    // 1.) File is interleaved.  We loop in time from beginning to end,
    //	    then loop through the streams and write out any data for the
    //	    current time.
    //
    // 2.) File is not interleaved.  We loop through the streams and
    //	    write each one out separately.
    //

    if (dwInterleaveEvery > 0) {
	DPF("Saving interleaved: factor = %lu, intial = %lu, total = %lu\n", dwInterleaveEvery, hdrNew.dwInitialFrames, hdrNew.dwTotalFrames);
    
	if (dwInterleaveEvery == 1) {
	    hdrNew.dwFlags |= AVIF_ISINTERLEAVED;
	    AVIFileEndRecord(pfilesave); // Make first record....
	}

	//
	// Interleaved case: loop from start to end...
	//
	for (l = - (LONG) hdrNew.dwInitialFrames;
		l < (LONG) hdrNew.dwTotalFrames;
		l += lInterval) {
	    //
	    // Loop through all of the streams to see what needs to be
	    // done at this time...
	    //	   
	    for (stream = 0; stream < nStreams; stream++) {
		LONG	lPos;
		LONG	lPosNext;
		
		LONG	lStart;
		LONG	lEnd;

		hr = AVIStreamInfo(apaviNew[stream], &strhdr, sizeof(strhdr));

		if (hr != AVIERR_OK)
		    goto Error;

		if (l < - (LONG) strhdr.dwInitialFrames)
		    continue;
		
		// !!! Better use of TWOCCs...
		if (strhdr.fccType == streamtypeAUDIO)
		    cktype = cktypeWAVEbytes;
		else if (strhdr.fccType == streamtypeVIDEO) {
		    if (strhdr.fccHandler == comptypeDIB)
			cktype = cktypeDIBbits;
		    else
			cktype = cktypeDIBcompressed;
		} else
		    cktype = aviTWOCC('x', 'x');

		//
		// Time is based on the first stream:
		// Right now, we want to write out any data in the current
		// stream that lines up between time <l> and <l+1> in the
		// first stream.
		//
		lPos = l + strhdr.dwInitialFrames;
		lPosNext = lPos + lInterval;

		lStart = lDone[stream];
		
		if (l >= (LONG) hdrNew.dwTotalFrames - lInterval) {
		    // If this is going to be the last time through the
		    // interleave loop, make sure everything gets written.
		    lEnd = AVIStreamEnd(apavi[stream]);
		} else {
		    //
		    // Complication: to make the audio come in bigger chunks,
		    // we only write it out every once in a while.
		    //
		    if (strhdr.fccType == streamtypeAUDIO && stream != 0) {
			if ((lPos % dwInterleaveEvery) != 0)
			    continue;

			lPosNext = lPos + dwInterleaveEvery;
		    }

		    if (stream != 0) {
			//
			// Figure out the data for this stream that needs to be
			// written this time....
			//
			lEnd = AVIStreamSampleToSample(apavi[stream], apavi[0], lPosNext);
		    } else {
			lEnd = min(lPosNext, (LONG) hdrNew.dwTotalFrames);
		    }
		}

		lDone[stream] = lEnd;

		//
		// Loop until we've read all we want.
		//
		while (lEnd > lStart) {
		    // !!! Right here, we should call AVIStreamGetFormat
		    // and then call AVIStreamSetFormat on the new
		    // streams.
		    // !!! Whose job is it to tell if the format has really
		    // changed?
		    cbFormat = dwBufferSize;
		    hr = AVIStreamReadFormat(apavi[stream],
					lStart,
					lpBuffer,
					&cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamReadFormat failed!\n");
			goto Error;
		    }
		    
		    hr = AVIStreamSetFormat(apaviNew[stream],
					   lStart,
					   lpBuffer,
					   cbFormat);
		    if (hr != AVIERR_OK) {
			// !!! Oh, well: we couldn't write the palette change...
			DPF("AVIStreamSetFormat failed!\n");
		    }

ReadAgain0:
		    cbFormat = dwBufferSize;
		    dwSamplesRead = 0;
		   
		    hr = AVIStreamRead(apavi[stream], lStart,
					    lEnd - lStart,
					    lpBuffer, dwBufferSize,
					    &dwSize, &dwSamplesRead);

		    if (// dwSamplesRead == 0 &&
			    (GetScode(hr) == AVIERR_BUFFERTOOSMALL)) {
			//
			// The frame didn't fit in our buffer.
			// Make a bigger buffer.
			//
			dwBufferSize *= 2;
			DPF("Resizing buffer to be %lx bytes\n", dwBufferSize);
			lpBuffer = GlobalReAllocPtr(lpBuffer, dwBufferSize, GMEM_MOVEABLE);
			if (lpBuffer)
			    goto ReadAgain0;

			hr = ResultFromScode(AVIERR_MEMORY);
		    }

		    if (hr != 0) {
			DPF("AVISave: Error %08lx reading stream %d, position %ld!\n", (DWORD) hr, stream, lStart);
			goto Error;
		    }

		    dwFlags = 0; 

		    if (AVIStreamFindSample(apavi[stream], lStart, 
				FIND_KEY | FIND_PREV) == lStart)
			dwFlags |= AVIIF_KEYFRAME;
		    
		    hr = AVIStreamWrite(apaviNew[stream],
					  -1, dwSamplesRead,
					  lpBuffer, dwSize,
					  // cktype, // !!!
					  dwFlags, 0L, 0L);

		    if (hr != AVIERR_OK)
			goto Error;

		    lStart += dwSamplesRead;
		}
	    }

	    //
	    // Mark the end of the frame, in case we're writing out
	    // the "strict" interleaved format with LIST 'rec' chunks...
	    //
	    if (dwInterleaveEvery == 1) {
		hr = AVIFileEndRecord(pfilesave);
		if (hr != AVIERR_OK) {
		    DPF("AVISave: Error from EndRecord!\n");
		    goto Error;
		}
	    }

	    // Give the application a chance to update status and the user
	    // a chance to abort... 
	    if (lpfnCallback((int)
			     muldiv32(l + hdrNew.dwInitialFrames, 100,
				      hdrNew.dwInitialFrames +
					      hdrNew.dwTotalFrames))) {
		hr = ResultFromScode(AVIERR_USERABORT);
		DPF("AVISave: Aborted!\n");
		goto Error;
	    }
	}
    } else {
	//
	// Non-interleaved case: loop through the streams and write 
	// each one out by itself.
	//
	DPF("Saving non-interleaved.\n");
    
	for (stream = 0; stream < nStreams; stream++) {
	    if (lpfnCallback(MulDiv(stream, 100, nStreams))) {
		hr = ResultFromScode(AVIERR_USERABORT);
		goto Error;
	    }
		    
            AVIStreamInfo(apavi[stream], &strhdr, sizeof(strhdr));

	    DPF("Saving stream %d: start=%lx, len=%lx\n", stream, strhdr.dwStart, strhdr.dwLength);
	    
	    // !!! Need better cktype handling....
	    if (strhdr.fccType == streamtypeAUDIO)
		cktype = cktypeWAVEbytes;
	    else if (strhdr.fccType == streamtypeVIDEO) {
		if (strhdr.fccHandler == comptypeDIB)
		    cktype = cktypeDIBbits;
		else
		    cktype = cktypeDIBcompressed;
	    } else
		cktype = aviTWOCC('x', 'x');

	    //
	    // As usual, there are two possibilities:
	    //
	    // 1.) "wave-like" data, where lots of samples can be in
	    // a single chunk.  In this case, we write out big chunks
	    // with many samples at a time.
	    //
	    // 2.) "video-like" data, where each sample is a different
	    // size, and thus each must be written individually.
	    //
	    if (strhdr.dwSampleSize != 0) {
		/* It's wave-like data: lots of samples per chunk */

		l = strhdr.dwStart;
		while (l < (LONG) strhdr.dwLength) {
		    DWORD	dwRead;
		    
		    // Make the format of the new stream
		    // match the old one at every point....
		    //
		    // !!! Whose job is it to tell if the format has really
		    // changed?
		    cbFormat = dwBufferSize;
		    hr = AVIStreamReadFormat(apavi[stream],
					l,
					lpBuffer,
					&cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamReadFormat failed!\n");
			goto Error;
		    }

		    hr = AVIStreamSetFormat(apaviNew[stream],
				       l,
				       lpBuffer,
				       cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamSetFormat failed!\n");
			// !!! Oh, well: we couldn't write the palette change...
		    }


		    //
		    // Read some data...
		    //
ReadAgain1:
		    dwSize = dwBufferSize;
		    dwSamplesRead = 0;
		    dwRead = min(dwBufferSize / strhdr.dwSampleSize,
				 strhdr.dwLength - (DWORD) l);

		    hr = AVIStreamRead(apavi[stream], l, dwRead,
				       lpBuffer, dwBufferSize,
				       &dwSize, &dwSamplesRead);

		    if (dwSamplesRead == 0 &&
				(GetScode(hr) == AVIERR_BUFFERTOOSMALL)) {
			//
			// The frame didn't fit in our buffer.
			// Make a bigger buffer.
			//
			dwBufferSize *= 2;
			lpBuffer = GlobalReAllocPtr(lpBuffer, dwBufferSize, GMEM_MOVEABLE);
			if (lpBuffer)
			    goto ReadAgain1;
		    }

		    // !!! Check if format has changed

		    dwFlags = 0; // !!! KEYFRAME?

		    DPF("Save: Read %lx/%lx samples at %lx\n", dwSamplesRead, dwRead, l);
		    
		    if (hr != AVIERR_OK) {
			DPF("Save: Read failed! (%08lx) pos=%lx, len=%lx\n", (DWORD) hr, l, dwRead);

			goto Error;
		    }

		    if (dwSamplesRead == 0) {
			DPF("Ack: Read zero samples!");
			
			if (l + 1 == (LONG) strhdr.dwLength) {
			    DPF("Pretending it's OK, since this was the last one....");
			    break;
			}

			hr = ResultFromScode(AVIERR_FILEREAD);
			goto Error;
		    }
		    
		    l += dwSamplesRead;

		    //
		    // Write the data out...
		    //
		    hr = AVIStreamWrite(apaviNew[stream],
					  -1, dwSamplesRead,
					  lpBuffer, dwSize,
// !!!					  cktype, // !!!TWOCCFromFOURCC(ckid),
					  dwFlags, 0L, 0L);

		    if (hr != AVIERR_OK) {
			DPF("AVIStreamWrite failed! (%08lx)\n", (DWORD) hr);

			goto Error;
		    }
		    
		    if (lpfnCallback(MulDiv(stream, 100, nStreams) +
			   (int) muldiv32(l, 100,
					   nStreams * strhdr.dwLength))) {
			hr = ResultFromScode(AVIERR_USERABORT);
			goto Error;
		    }
		}
	    } else {
		/* It's video-like data: one sample (frame) per chunk */

		for (l = strhdr.dwStart;
			l < (LONG) strhdr.dwLength;
			l++) {
		    // !!! Right here, we should call AVIStreamGetFormat
		    // and then call AVIStreamSetFormat on the new
		    // streams.
		    // !!! Whose job is it to tell if the format has really
		    // changed?
		    
		    cbFormat = dwBufferSize;
		    hr = AVIStreamReadFormat(apavi[stream],
					l,
					lpBuffer,
					&cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamReadFormat failed!\n");
			goto Error;
		    }

		    hr = AVIStreamSetFormat(apaviNew[stream],
				       l,
				       lpBuffer,
				       cbFormat);
		    if (hr != AVIERR_OK) {
			// !!! Oh, well: we couldn't write the palette change...
			DPF("AVIStreamSetFormat failed!\n");
		    }


    ReadAgain:
		    dwSize = dwBufferSize;
		    /* Write out a single frame.... */
		    dwSamplesRead = 0;
		    hr = AVIStreamRead(apavi[stream], l, 1,
					    lpBuffer, dwBufferSize,
					    &dwSize, &dwSamplesRead);

		    // !!! Check if format has changed (palette change)

		    if (dwSamplesRead == 0 &&
				(GetScode(hr) == AVIERR_BUFFERTOOSMALL)) {
			//
			// The frame didn't fit in our buffer.
			// Make a bigger buffer.
			//
			dwBufferSize *= 2;
			lpBuffer = GlobalReAllocPtr(lpBuffer, dwBufferSize, GMEM_MOVEABLE);
			if (lpBuffer)
			    goto ReadAgain;
		    }

		    if (dwSamplesRead != 1) {
			hr = ResultFromScode(AVIERR_FILEREAD);
			goto Error;
		    }

		    dwFlags = 0; // !!!!

		    //
		    // Check whether this should be marked a key frame.
		    //
		    // !!! shouldn't this be returned from AVIStreamRead()?
		    //
		    if (AVIStreamFindSample(apavi[stream], l, 
				FIND_KEY | FIND_PREV) == l)
			dwFlags |= AVIIF_KEYFRAME;

		    //
		    // Write the chunk out.
		    //
		    hr = AVIStreamWrite(apaviNew[stream],
					  -1, dwSamplesRead,
					  lpBuffer, dwSize,
// !!!					  cktype, // !!!TWOCCFromFOURCC(ckid),
					  dwFlags, 0L, 0L);

		    if (hr != AVIERR_OK)
			goto Error;

		    //
		    // Video frames can be big, so call back every time.
		    //
		    if (lpfnCallback(MulDiv(stream, 100, nStreams) +
			   (int) muldiv32(l, 100, nStreams * strhdr.dwLength))) {
			hr = ResultFromScode(AVIERR_USERABORT);
			goto Error;
		    }
		}
	    }
	}
    }

Error:
    //
    // We're done, one way or another.
    //
    
    /* Free buffer */
    if (lpBuffer) {
	GlobalFreePtr(lpBuffer);
    }

    // If everything's OK so far, finish writing the file.
    // Close the file, free resources associated with writing it.
    if (pfilesave) {
	// Release all of our new streams
	for (stream = 0; stream < nStreams; stream++) {
	    if (apaviNew[stream])
		AVIStreamClose(apaviNew[stream]);
	}
	
	if (hr != AVIERR_OK)
	    AVIFileClose(pfilesave);
	else {
	    // !!! ACK: AVIFileClose doesn't return an error! How do I tell
	    // if it worked?
	    // !!! does this mean I need a Flush() call?
	    /* hr = */ AVIFileClose(pfilesave);
	}
	
    }

    // Release all of our streams
    for (stream = 0; stream < nStreams; stream++) {
	if (apavi[stream])
	    AVIStreamClose(apavi[stream]);
    }
    
    if (hr != 0) {
	DPF("AVISave: Returning error %08lx\n", (DWORD) hr);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\avireg.h ===
// we do this thing so we register InprocServer or InprocServer32
#ifdef WIN32
    #define S32 "32"
#else
    #define S32
#endif

// !!! Lots of these strings should be resources!
#define MAX_RC_CONSTANT		0

#ifdef RCINVOKED
STRINGTABLE MOVEABLE DISCARDABLE
END
#else
#define MAKERESOURCE(i)	    ((char *) (i))
static char * aszReg[] = {
     "Interface\\{00020020-0000-0000-C000-000000000046}", "AVIFile Interface 1.1",
     "Interface\\{00020020-0000-0000-C000-000000000046}\\ProxyStubClsid","{0002000d-0000-0000-C000-000000000046}",

     "Interface\\{00020021-0000-0000-C000-000000000046}", "AVIStream Interface",
     "Interface\\{00020021-0000-0000-C000-000000000046}\\ProxyStubClsid","{0002000d-0000-0000-C000-000000000046}",

     "Clsid\\{0002000d-0000-0000-C000-000000000046}","IAVIStream & IAVIFile Proxy",
     "Clsid\\{0002000d-0000-0000-C000-000000000046}\\InprocServer" S32,"avifile.dll",

     "Clsid\\{00020000-0000-0000-C000-000000000046}","Microsoft AVI Files",
     "Clsid\\{00020000-0000-0000-C000-000000000046}\\InprocServer" S32,"avifile.dll",
     "Clsid\\{00020000-0000-0000-C000-000000000046}\\AVIFile", "7",

     "Clsid\\{00020003-0000-0000-C000-000000000046}","Microsoft Wave File",
     "Clsid\\{00020003-0000-0000-C000-000000000046}\\InprocServer" S32,"wavefile.dll",
     "Clsid\\{00020003-0000-0000-C000-000000000046}\\AVIFile", "7",

     "Clsid\\{00020001-0000-0000-C000-000000000046}","AVI Compressed Stream",
     "Clsid\\{00020001-0000-0000-C000-000000000046}\\InprocServer" S32,"avifile.dll",

#ifdef DEBUG
     "Clsid\\{00020004-0000-0000-C000-000000000046}","Nigel's lyric files",
     "Clsid\\{00020004-0000-0000-C000-000000000046}\\InprocServer" S32,"lyrfile.dll",
     "Clsid\\{00020004-0000-0000-C000-000000000046}\\AVIFile", "1",
#endif
     
     "Clsid\\{00020006-0000-0000-C000-000000000046}","DIB Sequences",
     "Clsid\\{00020006-0000-0000-C000-000000000046}\\InprocServer" S32,"dseqfile.dll",
     "Clsid\\{00020006-0000-0000-C000-000000000046}\\AVIFile", "7",

     "Clsid\\{0002000A-0000-0000-C000-000000000046}","TGA Sequences",
     "Clsid\\{0002000A-0000-0000-C000-000000000046}\\InprocServer" S32,"tgafile.dll",
     "Clsid\\{0002000A-0000-0000-C000-000000000046}\\AVIFile", "7",

     "Clsid\\{00020009-0000-0000-C000-000000000046}","Simple AVIFile unmarshaller",
     "Clsid\\{00020009-0000-0000-C000-000000000046}\\InprocServer" S32,"avifile.dll",

     "Clsid\\{00020007-0000-0000-C000-000000000046}","Autodesk FLx",
     "Clsid\\{00020007-0000-0000-C000-000000000046}\\InprocServer" S32,"flifile.dll",
     "Clsid\\{00020007-0000-0000-C000-000000000046}\\AVIFile", "1",

#ifdef DEBUG
     "Clsid\\{0002000E-0000-0000-C000-000000000046}","Various Medbits Formats",
     "Clsid\\{0002000E-0000-0000-C000-000000000046}\\InprocServer" S32,"mbitfile.dll",
     "Clsid\\{0002000E-0000-0000-C000-000000000046}\\AVIFile", "1",

     "Clsid\\{00020008-0000-0000-C000-000000000046}","QuickTime Movies",
     "Clsid\\{00020008-0000-0000-C000-000000000046}\\InprocServer" S32,"qtfile.dll",
     "Clsid\\{00020008-0000-0000-C000-000000000046}\\AVIFile", "1",

     "Clsid\\{5C2B8200-E2C8-1068-B1CA-6066188C6002}","JPEG (JFIF) Files",
     "Clsid\\{5C2B8200-E2C8-1068-B1CA-6066188C6002}\\InprocServer" S32,"jfiffile.dll",
     "Clsid\\{5C2B8200-E2C8-1068-B1CA-6066188C6002}\\AVIFile", "3",
#endif
     
     "Clsid\\{0002000F-0000-0000-C000-000000000046}","ACM Compressed Audio Stream",
     "Clsid\\{0002000F-0000-0000-C000-000000000046}\\InprocServer" S32,"acmcmprs.dll",

     "AVIFile","Video for Windows 1.1 Information",
     "AVIFile\\RIFFHandlers\\AVI","{00020000-0000-0000-C000-000000000046}",
     "AVIFile\\RIFFHandlers\\WAVE","{00020003-0000-0000-C000-000000000046}",

     "AVIFile\\Extensions\\AVI","{00020000-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\WAV","{00020003-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\DIB","{00020006-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\BMP","{00020006-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\FLI","{00020007-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\FLC","{00020007-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\TGA","{0002000A-0000-0000-C000-000000000046}",
#ifdef DEBUG
     "AVIFile\\Extensions\\LYR","{00020004-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\GIF","{0002000E-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\PCX","{0002000E-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\MOV","{00020008-0000-0000-C000-000000000046}",
     "AVIFile\\Extensions\\JPG","{5C2B8200-E2C8-1068-B1CA-6066188C6002}",
#endif
     "AVIFile\\Compressors\\vids","{00020001-0000-0000-C000-000000000046}",
     "AVIFile\\Compressors\\auds","{0002000F-0000-0000-C000-000000000046}",

     NULL, NULL};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\debug.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


#ifdef DEBUG
    void CDECL dprintf(LPSTR, ...);
    void CDECL dprintf2(LPSTR, ...);
    void CDECL dprintf3(LPSTR, ...);
    #define DPF dprintf
    #define DPF2 dprintf2
    #define DPF3 dprintf3
#else
    #define DPF ; / ## /
    #define DPF2 ; / ## /
    #define DPF3 ; / ## /
#endif

#undef Assert
#undef AssertSz

#ifdef DEBUG
	/* Assert() macros */
        #define AssertSz(x,sz)           ((x) ? (void)0 : (void)_Assert(sz, __FILE__, __LINE__))
        #define Assert(expr)             AssertSz(expr, #expr)

        extern void FAR PASCAL _Assert(char *szExp, char *szFile, int iLine);
#else
	/* Assert() macros */
        #define AssertSz(expr)           ((void)0)
        #define Assert(expr)             ((void)0)
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\buffer.c ===
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include "debug.h"
#include "aviidx.h"
#include "buffer.h"
#include "avifile.h"

#ifndef WIN32
LONG    glDosBufUsage;
LPVOID  glpDosBuf;
LONG    glDosBufSize;
#endif

// Idea: keep a bunch (five, maybe) of buffers.

PBUFSYSTEM PASCAL InitBuffered(int nBuffers,
				LONG lBufSize,
                                HSHFILE hshfile,
                                PAVIINDEX px)
{
    PBUFSYSTEM pb = (PBUFSYSTEM)LocalAlloc(LPTR,
            sizeof(BUFSYSTEM) + sizeof(BUFFER) * nBuffers);

    int		i;
    LONG	l;

    if (!pb)
        return NULL;

    DPF("InitBuffered (%04x): %dx%ldK, pIndex = %08lx\n", pb, nBuffers, lBufSize / 1024, (DWORD) (LPVOID) px);

    pb->nBuffers = nBuffers;
    pb->lBufSize = lBufSize;

    pb->px = px;
    pb->lx = 0;

    pb->lpBufMem = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, lBufSize * nBuffers);

    if (!pb->lpBufMem) {
	DPF("Couldn't allocate buffer memory!\n");
	EndBuffered(pb);
	return NULL;
    }

    pb->hshfile = hshfile;
    
    l = shfileSeek(hshfile, 0, SEEK_CUR);
    pb->lFileLength = shfileSeek(hshfile, 0, SEEK_END);
    shfileSeek(hshfile, l, SEEK_SET);

    for (i = 0; i < nBuffers; i++) {
	pb->aBuf[i].lpBuffer = (BYTE _huge *) pb->lpBufMem + i * lBufSize;
        pb->aBuf[i].lOffset  = -1;
    }

    return pb;
}

LONG FAR PASCAL BufferedRead(PBUFSYSTEM pb, LONG lPos, LONG cb, LPVOID lp)
{
    int	    i;
    LPVOID  lpCopy;
    LONG    cbCopy;
    LONG    cbRead = cb;
    LONG    l;

#if 0
    if (cb > pb->lBufSize) {
        if (shfileSeek(pb->hshfile, lPos, SEEK_SET) == -1)
            return 0;

        if (shfileRead(pb->hshfile, lp, cb) != cb)
            return 0;

        return cb;
    }
#endif
    
    while (cb > 0) {

	if (lPos >= pb->lFileLength)
	    break;
	
	// Find a buffer.
	for (i = 0; i < pb->nBuffers; i++) {
	    if (pb->aBuf[i].lOffset < 0)
		continue;

	    if (pb->aBuf[i].lOffset <= lPos &&
			pb->aBuf[i].lOffset + pb->aBuf[i].lLength > lPos)
		break;
	}

        // If we didn't find a buffer with valid data, read more.

	if (i >= pb->nBuffers) {
	    i = pb->iNextBuf;

            if (pb->px) {

                LONG off,len;

                for (l = pb->lx; l>=0 && l<pb->px->nIndex; ) {

                    off = IndexOffset(pb->px, l);
                    len = IndexLength(pb->px, l) + 2*sizeof(DWORD);

                    if (off <= lPos && lPos < off + len)
                        break;

                    if (lPos < off)
                        l--;
                    else
                        l++;
                }

                if (l == pb->px->nIndex || l < 0) {
                    DPF("Ran out of index!\n");
                    goto ack;
                }

                if (len > pb->lBufSize) {
                    DPF("Chunk is bigger than buffer.\n");
                    goto ack;
                }

                pb->aBuf[i].lOffset = off;
                pb->aBuf[i].lLength = len;

                DPF2("Buffer: Reading %lx bytes at %lx\n", pb->aBuf[i].lLength, pb->aBuf[i].lOffset);

                //
                //  read as many records that will fit in our buffer
                //
                //  we should scan backward!
                //
                for (l++; l<pb->px->nIndex; l++) {

                    off = IndexOffset(pb->px, l);
                    len = IndexLength(pb->px, l) + 2*sizeof(DWORD);

                    if (off < pb->aBuf[i].lOffset + pb->aBuf[i].lLength)
                        continue;

                    if (off != pb->aBuf[i].lOffset + pb->aBuf[i].lLength)
                        break;

                    if (pb->aBuf[i].lLength + len > pb->lBufSize)
                        break;

                    pb->aBuf[i].lLength += len;

                    DPF2("        Reading %lx bytes at %lx\n", pb->aBuf[i].lLength, pb->aBuf[i].lOffset);
                }

                if (l < pb->px->nIndex)
                    pb->lx = l;     // save this for next time.

	    } else
	    {
ack:
		// Always read aligned with the buffer size....
                pb->aBuf[i].lOffset = lPos - (lPos % pb->lBufSize);

		pb->aBuf[i].lLength =
			min(pb->lFileLength - pb->aBuf[i].lOffset,
                                      pb->lBufSize);

                DPF("Buffer: Reading %lx bytes at %lx\n", pb->aBuf[i].lLength, pb->aBuf[i].lOffset);
            }

            shfileSeek(pb->hshfile, pb->aBuf[i].lOffset, SEEK_SET);
	    if (glpDosBuf) {
		if (shfileRead(pb->hshfile,
			       glpDosBuf,
			       pb->aBuf[i].lLength) != pb->aBuf[i].lLength)
                    return 0;
		hmemcpy(pb->aBuf[i].lpBuffer, glpDosBuf, pb->aBuf[i].lLength);
	    } else {
		if (shfileRead(pb->hshfile,
			       pb->aBuf[i].lpBuffer,
			       pb->aBuf[i].lLength) != pb->aBuf[i].lLength)
                    return 0;
	    }

	    // !!! We should use an LRU algorithm or something here....
	    pb->iNextBuf = (i + 1) % pb->nBuffers;
	}

	lpCopy = (BYTE _huge *) pb->aBuf[i].lpBuffer + lPos - pb->aBuf[i].lOffset;

	cbCopy = min(cb, pb->aBuf[i].lLength - (lPos - pb->aBuf[i].lOffset));

	hmemcpy(lp, lpCopy, cbCopy);

	lp = (BYTE _huge *) lp + cbCopy;
	cb -= cbCopy;
	lPos += cbCopy;
    }

    return cbRead;
}

LONG FAR PASCAL BeginBufferedStreaming(PBUFSYSTEM pb, BOOL fForward)
{
    if (pb->fStreaming++)
	return 0;

    DPF("Streaming....\n");
    
#ifndef WIN32
    if (pb->px) {
	if (glDosBufSize < pb->lBufSize && GetProfileInt("avifile", "dosbuffer", 1)) {
	    LPVOID lpDosBuf;
	    
	    lpDosBuf = (LPVOID)MAKELONG(0, LOWORD(GlobalDosAlloc(pb->lBufSize)));
	    
	    if (!lpDosBuf) {
		DPF("Couldn't get DOS buffer!\n");
            } else {
                GlobalReAlloc((HANDLE)HIWORD(lpDosBuf), 0, GMEM_MODIFY|GMEM_SHARE);

		if (glpDosBuf)
                    GlobalDosFree(HIWORD(glpDosBuf));

                glpDosBuf = lpDosBuf;
                glDosBufSize = pb->lBufSize;
	    }
        }

	if (glpDosBuf && (glDosBufSize >= pb->lBufSize)) {
	    pb->fUseDOSBuf = TRUE;
	    glDosBufUsage++;
	} else
	    pb->fUseDOSBuf = FALSE;	
    }
#endif

    return 0;
}

LONG FAR PASCAL EndBufferedStreaming(PBUFSYSTEM pb)
{
    if (!pb->fStreaming)
	return AVIERR_INTERNAL;
    
    if (--pb->fStreaming)
	return 0;

    DPF("No longer streaming....\n");
    
#ifndef WIN32
    if (pb->fUseDOSBuf) {
	if (--glDosBufUsage == 0) {
	    if (glpDosBuf)
		GlobalDosFree(HIWORD(glpDosBuf));

	    glpDosBuf = NULL;
	}

	pb->fUseDOSBuf = FALSE;
    }
#endif

    return 0;
}


void FAR PASCAL EndBuffered(PBUFSYSTEM pb)
{
    DPF("Freeing bufsystem %04x....\n", pb);
    
    if (pb->lpBufMem)
	GlobalFreePtr(pb->lpBufMem);

#ifndef WIN32
    if (pb->fUseDOSBuf) {
	if (--glDosBufUsage == 0) {
	    if (glpDosBuf)
		GlobalDosFree(HIWORD(glpDosBuf));

	    glpDosBuf = NULL;
	    glDosBufSize = 0;
	}
    }
#endif

    LocalFree((HLOCAL)pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\editstrm.cpp ===
/****************************************************************************
 *
 *  EDITSTRM.C
 *
 *  routines for reading Standard AVI files
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <compman.h>
#include "avifile.h"
#include <storage.h>
#include "editstrm.h"

#ifdef DEBUG
    static void CDECL dprintf(LPSTR, ...);
    #define DPF dprintf
#else
    #define DPF ; / ## /
#endif

/*
 * memcopy.asm
 */
#ifdef WIN32
#define MemCopy(dst, src, cnt) memmove(dst,src,cnt)
#else
EXTERN_C LONG FAR PASCAL MemCopy(HPSTR, HPSTR, DWORD);
#endif



STDAPI EditStreamCut(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Cut(plStart, plLength, ppResult);

    pedit->Release();

    return hr;
}

STDAPI EditStreamCopy(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Copy(plStart, plLength, ppResult);

    pedit->Release();

    return hr;
}

STDAPI EditStreamPaste(PAVISTREAM pavi, LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lLength)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Paste(plPos, plLength, pstream, lStart, lLength);

    pedit->Release();

    return hr;
}

STDAPI EditStreamClone(PAVISTREAM pavi, PAVISTREAM FAR *ppResult)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Clone(ppResult);

    pedit->Release();

    return hr;
}

STDAPI EditStreamSetInfo(PAVISTREAM pavi, AVISTREAMINFO FAR *lpInfo, LONG cbInfo)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->SetInfo(lpInfo, cbInfo);

    pedit->Release();

    return hr;
}

STDAPI EditStreamSetName(PAVISTREAM pavi, LPCSTR lpszName)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;
    AVISTREAMINFO   info;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    pavi->Info(&info, sizeof(info));
    _fstrncpy(info.szName, lpszName, sizeof(info.szName));
    hr = pedit->SetInfo(&info, sizeof(info));

    pedit->Release();

    return hr;
}

// #define EDITCHECK

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#define USUAL_ALLOC	16
#define EXTRA_ALLOC	8
HRESULT CEditStream::AllocEditSpace(LONG l, LONG cNew)
{
    LPEDIT  p;
    LONG    size;

    if (cedits + cNew > maxedits) {
	size = maxedits + max(cNew + EXTRA_ALLOC, USUAL_ALLOC);

	p = (LPEDIT) GlobalReAllocPtr(edits, size * sizeof(EDIT), GHND | GMEM_SHARE);

	if (!p)
	    return ResultFromScode(AVIERR_MEMORY);

	edits = p;
	maxedits = size;
    }

    if (l < cedits)
	MemCopy((HPSTR) &edits[l + cNew],
		(HPSTR) &edits[l],
		(cedits - l) * sizeof(EDIT));

    cedits += cNew;

    return AVIERR_OK;
}

HRESULT CEditStream::PossiblyRemoveEdit(LONG l)
{
    if (edits[l].lLength > 0)
	return AVIERR_OK;

    if (edits[l].pavi)
	AVIStreamRelease(edits[l].pavi);

    --cedits;

    if (l < cedits)
	MemCopy((HPSTR) &edits[l],
		(HPSTR) &edits[l + 1],
		(cedits - l) * sizeof(EDIT));

    return AVIERR_OK;
}

CEditStream FAR * CEditStream::NewEditStream(PAVISTREAM psSource)
{
    CEditStream FAR * pedit;

    pedit = new CEditStream;

    if (pedit)
	(pedit->Create)((LONG) psSource, 0);
    // !!! error check

    return pedit;
}

STDAPI CreateEditableStream(
		PAVISTREAM FAR *	    ppsEditable,
		PAVISTREAM		    psSource)
{
    // First, check if the stream is already editable....

    if (psSource) {
	PAVIEDITSTREAM	paviedit = NULL;

	psSource->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &paviedit);

	if (paviedit) {
	    paviedit->Clone(ppsEditable);
	    paviedit->Release();
	    return AVIERR_OK;
	}
    }

    *ppsEditable = (PAVISTREAM) CEditStream::NewEditStream(psSource);

    if (!*ppsEditable)
	return ResultFromScode(AVIERR_MEMORY);

    return AVIERR_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//  EditStreamOpen()
//
//  open a single stream of a particular type from a AVI file.
//
//  params:
//      szFile      - AVI file name
//      fccType     - stream type 0 for any type
//      iStream     - zero based stream number
//
//  returns:
//      a PAVISTREAM for the specifed stream or NULL.
//
//  example:
//
//      EditStreamOpen(pavi, "Foo.avi", 0, 0)
//
//          will open stream 0 (the first stream)
//
//      EditStreamOpen(pavi, "Foo.avi", 1)
//
//          will open stream 1
//
//      EditStreamOpenStream(pavi, "Foo.avi", 'vids', 0)
//
//          will open the first video stream
//
//      AVIOpenStream(pavi, "Foo.avi", 'auds', 0)
//
//          will open the first audio stream
//
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::Create(LONG lParam1, LONG lParam2)
{


    this->edits = (LPEDIT) GlobalAllocPtr(GHND | GMEM_SHARE, USUAL_ALLOC * sizeof(EDIT));
    if (this->edits == NULL)
	return ResultFromScode(AVIERR_MEMORY);

    this->maxedits = USUAL_ALLOC;
    this->ulRefCount = 1;

    this->pgf = NULL;
    this->psgf = NULL;
    this->lpbiLast = NULL;
    this->fFullFrames = FALSE;
    this->edits[0].pavi = (PAVISTREAM)lParam1;
    _fmemset(&this->sinfo, 0, sizeof(this->sinfo));
    this->cedits = 1;
    if (this->edits[0].pavi) {
	AVIStreamAddRef(this->edits[0].pavi);
	this->edits[0].lStart = AVIStreamStart(this->edits[0].pavi);
	this->edits[0].lLength = AVIStreamLength(this->edits[0].pavi);

	AVIStreamInfo(this->edits[0].pavi, &this->sinfo, sizeof(this->sinfo));
	
	CheckEditList();
    } else {
	this->edits[0].lStart = 0;
	this->edits[0].lLength = 0;
    }

    DPF("Edit   %08lx: Usage++=%lx\n", (DWORD) (LPVOID) this, 1L);

    //
    // all done return success.
    //
    return 0; // success
}

///////////////////////////////////////////////////////////////////////////
//
//  EditStreamAddRef()
//
//      increase the reference count of the stream
//
///////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CEditStream::AddRef()
{
    DPF("Edit   %08lx: Usage++=%lx\n", (DWORD) (LPVOID) this, this->ulRefCount + 1);

    return ++this->ulRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
//  EditStreamRelease()
//
//      close a EditStream stream
//
///////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CEditStream::Release()
{
    LONG	l;

    DPF("Edit   %08lx: Usage--=%lx\n", (DWORD) (LPVOID) this, this->ulRefCount - 1);
    if (--this->ulRefCount)
	return this->ulRefCount;

    // free edits....
    for (l = 0; l < this->cedits; l++) {
	if (this->edits[l].pavi)
	    AVIStreamRelease(this->edits[l].pavi);
    }

    GlobalFreePtr(this->edits);

    this->edits = 0;

    if (this->pgf)
	AVIStreamGetFrameClose(this->pgf);

    delete this;

    return 0;
}

LPBITMAPINFOHEADER NEAR PASCAL CEditStream::CallGetFrame(
						      PAVISTREAM p,
						      LONG l)
{
    if (psgf != p) {
	PGETFRAME   pgfNew;
	
	pgfNew = AVIStreamGetFrameOpen(p, NULL);
	
	if (!pgfNew)
	    return NULL;

	if (pgf) {
#ifdef DEBUG
	    DPF("Trying to SetFormat %dx%dx%d '%4.4s'\n",
	    	    (int)lpbiLast->biWidth,
		    (int)lpbiLast->biHeight,
		    (int)lpbiLast->biBitCount,
		    (lpbiLast->biCompression == BI_RGB  ? (LPSTR)"None" :
		    lpbiLast->biCompression == BI_RLE8 ? (LPSTR)"Rle8" :
			lpbiLast->biCompression == BI_RLE4 ? (LPSTR)"Rle4" :
			    (LPSTR)&lpbiLast->biCompression));
#endif	

            if (pgfNew->SetFormat(lpbiLast, NULL, 0, 0, -1, -1) != AVIERR_OK) {
		DPF("Couldn't AVIStreamGetFrameSetFormat!\n");
		AVIStreamGetFrameClose(pgfNew);
		return NULL;
	    }
		
	    AVIStreamGetFrameClose(pgf);
	}

	pgf = pgfNew;
	psgf = p;

    }

    lpbiLast = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pgf, l);

    if (lpbiLast)
	sinfo.dwSuggestedBufferSize = lpbiLast->biSizeImage;

    return lpbiLast;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    PAVISTREAM	p;
    LONG	l;
    HRESULT	hr;

    if ((lPos < (LONG) sinfo.dwStart) ||
		(lPos >= (LONG) (sinfo.dwStart + sinfo.dwLength))) {
	return ResultFromScode(AVIERR_BADPARAM);
    }
	
    hr = ResolveEdits(lPos, &p, &l, NULL, FALSE);

    if (hr != 0) {
	DPF("ReadFormat: ResolveEdits failed!\n");
	return hr;
    }

    if (fFullFrames) {
	LPBITMAPINFOHEADER  lpbi;
	LONG		    lSize;

	// This isn't really right: we really need to make the formats
	// agree.  Should we just get the format from the first frame?
	
	lpbi = CallGetFrame(p, l);

	if (!lpbi) {
	    DPF("ReadFormat: GetFrame failed!\n");
	    return ResultFromScode(E_FAIL);
	}

	lSize = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	if (lpFormat)
	    hmemcpy(lpFormat, lpbi, min(*lpcbFormat, lSize));

	*lpcbFormat = lSize;
	return 0;
    } else {
	return AVIStreamReadFormat(p, l, lpFormat, lpcbFormat);
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::Info(AVISTREAMINFO FAR * psi, LONG lSize)
{

    if (psi)
	hmemcpy(psi, &sinfo, min(lSize, sizeof(sinfo)));
    return 0; // !!! sizeof(pavi->sinfo);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

LONG STDMETHODCALLTYPE CEditStream::FindSample(LONG lPos, LONG lFlags)
{
    PAVISTREAM	p;
    LONG	l;
    LONG	edit;
    LONG	lRet;
    HRESULT	hr;

    if ((lPos < (LONG) sinfo.dwStart) ||
		(lPos >= (LONG) (sinfo.dwStart + sinfo.dwLength))) {
	return -1;
    }
	
    hr = ResolveEdits(lPos, &p, &l, &edit, TRUE);

    if (hr != 0) {
	DPF("FindSample: error from ResolveEdits!\n");
	return -1;
    }

    if (lFlags & FIND_FORMAT) {
	// !!!!  This isn't right, obviously.
	if (lFlags & FIND_PREV)
	    return 0;
	else
	    return -1;
    }

    if (this->fFullFrames) {
	return lPos;
    }

    // !!! This won't really work, especially for searching forward.
    lRet = AVIStreamFindSample(p, l, lFlags);

#ifdef DEBUG
    if (lRet < edits[edit].lStart) {
	DPF("We were about to return a key frame before a segment: returning %ld instead of %ld.\n", edits[edit].lStart, lRet);
    }
#endif

    // DPF("FindSample: lPos = %ld, Key = %ld\n", lPos, lPos - (l - lRet));
    return lPos - (l - lRet);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::Read(
                 LONG       lStart,
                 LONG       lSamples,
                 LPVOID     lpBuffer,
                 LONG       cbBuffer,
                 LONG FAR * plBytes,
                 LONG FAR * plSamples)
{
    PAVISTREAM	p;
    LONG	l;
    LONG	edit;
    LONG	lSamplesRead;
    LONG	lBytesRead;
    LONG	lSamplesThisTime;
    HRESULT	hr;

    if (plBytes)
	*plBytes = 0;
    if (plSamples)
	*plSamples = 0;

#ifdef TOOMUCHDEBUG
    if (lpBuffer) {
	DPF("Read %08lx: Start = %ld Length = %ld\n", (DWORD) (LPVOID) this, lStart, lSamples);
    }
#endif

    if ((lStart < (LONG) sinfo.dwStart) ||
		(lStart >= (LONG) (sinfo.dwStart + sinfo.dwLength))) {
	DPF("Read at position %ld, start = %lu, len = %lu\n", lStart, sinfo.dwStart, sinfo.dwStart + sinfo.dwLength);
	
	return ResultFromScode(AVIERR_BADPARAM);
    }
	
    while (lSamples) {
	hr = ResolveEdits(lStart, &p, &l, &edit, FALSE);

	if (hr != 0) {
	    DPF("Read: ResolveEdits failed!\n");
	    return ResultFromScode(E_FAIL);
	}
	
	// Don't read past the end of this edit.
	if ((l - this->edits[edit].lStart) + lSamples > this->edits[edit].lLength)
	    lSamplesThisTime = this->edits[edit].lLength - (l - this->edits[edit].lStart);
	else
	    lSamplesThisTime = lSamples;


	if (this->fFullFrames) {
	    LPBITMAPINFOHEADER  lpbi;
	    LPVOID		    lp;

	    lpbi = CallGetFrame(p, l);

	    if (!lpbi) {
		DPF("Read: GetFrame failed!\n");
		return ResultFromScode(E_FAIL);
	    }

	    //
	    // a NULL buffer means return the size buffer needed to read
	    // the given sample.
	    //
	    if (lpBuffer == NULL)
		goto exit;

	    lp = (LPBYTE) lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	    if (cbBuffer >= (LONG) lpbi->biSizeImage) {
		hmemcpy(lpBuffer, lp, lpbi->biSizeImage);
    exit:
		if (plBytes)
		    *plBytes = lpbi->biSizeImage;

		if (plSamples)
		    *plSamples = 1;

		return 0;
	    }
	    if (plBytes)
		*plBytes = 0;

	    if (plSamples)
		*plSamples = 0;

	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	} else {
	    hr = AVIStreamRead(p, l, lSamplesThisTime, lpBuffer, cbBuffer,
			       &lBytesRead, &lSamplesRead);

	    if (hr != NOERROR)
		return hr;
	
	    if (plBytes)
		*plBytes += lBytesRead;
	    if (plSamples)
		*plSamples += lSamplesRead;

	    lpBuffer = (BYTE _huge *) lpBuffer + lBytesRead;
	    lStart += lSamplesThisTime;
	    lSamples -= lSamplesThisTime;
	    cbBuffer -= lBytesRead;

	    // If we've read up to the end of the file,
	    // stop now, rather than return an error....
	    if (lStart >= (LONG) (this->sinfo.dwLength + this->sinfo.dwStart))
		break;
	}
    }

#ifdef TOOMUCHDEBUG
    if (lpBuffer && plBytes) {
	DPF("Read %08lx:  Bytes Read = %ld\n", (DWORD) (LPVOID) this, *plBytes);
    }
#endif

    return 0;
}

void CEditStream::CheckEditList()
{
#ifdef EDITCHECK
    LONG    lTotal = 0;
    LONG    l;

    DPF("Edit list %08lx: %s\n", (DWORD) this, fFullFrames ? (LPSTR) " (Using full frames)" : (LPSTR) "");

    for (l = 0; l < cedits; l++) {
	DPF("\t\t%ld:\t%08lx\t%ld\t%ld\n", l, (DWORD) (LPVOID) edits[l].pavi, edits[l].lStart, edits[l].lLength);
	lTotal += edits[l].lLength;
    }

    if (lTotal != (LONG) sinfo.dwLength) {
	* (LPSTR) 0 = 0;
    }
#endif
}

HRESULT CEditStream::ResolveEdits(LONG lPos, PAVISTREAM FAR *ppavi,
		  LONG FAR *plPos, LONG FAR *pl, BOOL fAllowEnd)
{
    LONG    edit;

    //
    // Search edit list, get position...
    //

    if (lPos < (LONG) this->sinfo.dwStart) {
	DPF("ResolveEdits: Read at %ld, before start at %ld\n", lPos, this->sinfo.dwStart);
	return ResultFromScode(AVIERR_BADPARAM);
    }

    lPos -= (LONG) this->sinfo.dwStart;

    for (edit = 0; edit < this->cedits; edit++) {
	if (lPos < this->edits[edit].lLength) {
	    *ppavi = this->edits[edit].pavi;
	    *plPos = lPos + this->edits[edit].lStart;
	    if (pl)
		*pl = edit;
	    return 0;
	}

	lPos -= this->edits[edit].lLength;
    }

    // Normally, we don't return a position at the end of an edit--we instead
    // go to the next thing.
    if (lPos == 0 && fAllowEnd) {
	edit--;
	*ppavi = this->edits[edit].pavi;
	*plPos = this->edits[edit].lStart + this->edits[edit].lLength;
	if (pl)
	    *pl = edit;
	return 0;
    }

    *ppavi = 0;
    *plPos = 0;
    if (pl)
	*pl = 0;

    return ResultFromScode(AVIERR_BADPARAM);
}

//
// Cut:
//
// Takes start, length to cut out
//
// returns actual start, length cut, along with new stream
//
STDMETHODIMP CEditStream::Cut(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    HRESULT	hr = AVIERR_OK;
    PAVISTREAM	p;
    LONG	l;
    LONG		edit;
    LONG	lStart, lLength;

    l = AVIStreamLength(this);

    if (ppResult)
	*ppResult = 0;

    if (!plStart || !plLength) {
	return ResultFromScode(AVIERR_BADPARAM);
    }

    if (*plStart < 0) {
	return ResultFromScode(AVIERR_BADPARAM);
    }

    if (*plLength < 0 || *plStart + *plLength > l) {
	if (*plStart >= l)
	    return ResultFromScode(AVIERR_BADPARAM);
	*plLength = l - *plStart;
    }

#ifdef KEYALWAYS
    // Make cut end at key frame
    for (l = *plStart + *plLength; l < AVIStreamLength(this); l++) {
	if (AVIStreamFindSample(this, l, 0) == l)
	    break;
    }
    *plLength = l - *plStart;
#else
    // we cut whatever they ask us to....
#endif

    // Make a copy of the section being cut out
    if (ppResult) {
	// This will make cut start at key frame if it needs to
	hr = this->Copy(plStart, plLength, ppResult);

	if (hr != AVIERR_OK)
	    return hr;
    }

    lLength = *plLength;
    lStart = *plStart;

#ifndef KEYALWAYS
    if (!this->fFullFrames &&
	lStart + lLength < AVIStreamLength(this) &&
	AVIStreamFindSample(this, lStart + lLength, 0) != lStart + lLength) {
	DPF("Cut: Converting stream to full frames\n");
	this->fFullFrames = TRUE;
	this->sinfo.dwFormatChangeCount++;
	this->sinfo.fccHandler = 0;
    }
#endif

    // Now do the actual cut
    hr = ResolveEdits(lStart, &p, &l, &edit, FALSE);

    if (hr != NOERROR)
	return hr;

    if (this->edits[edit].lStart + this->edits[edit].lLength > l + lLength) {
	// The part cut out is entirely within this edit.
	if (this->edits[edit].lStart == l) {
	    // The part cut out is the start of this edit
	    this->edits[edit].lStart = l + lLength;
	    this->edits[edit].lLength -= lLength;
	} else {
	    hr = AllocEditSpace(edit, 1);

	    if (hr == AVIERR_OK) {
		this->edits[edit] = this->edits[edit+1];
		if (this->edits[edit].pavi)
		    AVIStreamAddRef(this->edits[edit].pavi);
		this->edits[edit].lStart = this->edits[edit+1].lStart;
		this->edits[edit].lLength = l - this->edits[edit].lStart;
		this->edits[edit+1].lStart = l + lLength;
		this->edits[edit+1].lLength -= lLength +
					       this->edits[edit].lLength;
	    }
	}
    } else if (this->edits[edit].lStart + this->edits[edit].lLength == l + lLength) {
	// The part cut out is the end of this edit
	this->edits[edit].lLength = l - this->edits[edit].lStart;
    } else {
	LONG lTemp = lLength;
	
	// We're cutting out more than this one edit.
	// First, cut out the rest of this edit.
	lTemp -= this->edits[edit].lStart + this->edits[edit].lLength - l;
	this->edits[edit].lLength = l - this->edits[edit].lStart;

	edit++;

	// As long as subsequent edits are still shorter than the cut,
	// kill them..
	while (edit < this->cedits &&
	       this->edits[edit].lLength < lTemp) {
	    lTemp -= this->edits[edit].lLength;
	    this->edits[edit].lLength = 0;
	    edit++;
	}

	if (edit < this->cedits) {
	    this->edits[edit].lStart += lTemp;
	    this->edits[edit].lLength -= lTemp;
	}
    }

    if (hr == AVIERR_OK) {
	this->sinfo.dwLength -= lLength;
	this->sinfo.dwEditCount++;

	CheckEditList();
    } else {
	if (ppResult)
	    AVIStreamRelease(*ppResult);
    }
    return hr;
}

//
// Copy:
//
// Takes start, length to cut out
//
// returns actual start, length cut, along with new stream
//
//

STDMETHODIMP CEditStream::Copy(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    PAVISTREAM	p1;
    LONG	l1;
    LONG	edit1;
    PAVISTREAM	p2;
    LONG	l2;
    LONG	edit2;
    LONG	l;
    CEditStream FAR *p;
    HRESULT	hr;
    LONG	lStart, lLength;

    l1 = AVIStreamLength(this);

    // If start, length < 0, pick some defaults
    if (*plStart < 0)
	*plStart = 0;

    if (*plLength < 0)
	*plLength = l1 - *plStart;

    // Make sure the start position is within range
    if (*plStart > l1) {
	if (ppResult)
	    *ppResult = 0;
	return ResultFromScode(AVIERR_BADPARAM);
    }

    // Make sure the length is within range
    if (*plStart + *plLength > l1)
	*plLength = l1 - *plStart;

#ifdef KEYALWAYS
    // Make copy start at key frame
    lStart = AVIStreamFindSample(this, *plStart, 0);
    *plLength += *plStart - lStart;
    *plStart = lStart;
#endif

    lLength = *plLength;
    lStart = *plStart;

    p = NewEditStream(NULL);
    *ppResult = (PAVISTREAM) p;
    if (!p)
	return ResultFromScode(AVIERR_MEMORY);

    hmemcpy(&p->sinfo, &this->sinfo, sizeof(p->sinfo));

    if (lLength <= 0)
	lLength = (LONG) (p->sinfo.dwLength + p->sinfo.dwStart) - lStart;

    hr = ResolveEdits(lStart, &p1, &l1, &edit1, FALSE);
    hr = ResolveEdits(lStart + lLength, &p2, &l2, &edit2, TRUE);

    if (edit1 == edit2) {
	p->edits[0].pavi = p1;
	if (p1)
	    AVIStreamAddRef(p1);
	p->edits[0].lStart = l1;
	p->edits[0].lLength = lLength;
    } else {
	hr = p->AllocEditSpace(1, edit2 - edit1);

	for (l = 0; l <= edit2 - edit1; l++) {
	    if (l == 0) {
		p->edits[l].pavi = p1;
		if (p1)
		    AVIStreamAddRef(p1);
		p->edits[l].lStart = l1;
		p->edits[l].lLength = this->edits[edit1].lStart +
				      this->edits[edit1].lLength - l1;
	    } else if (l < edit2 - edit1) {
		p->edits[l] = this->edits[l+edit1];
		if (p->edits[l].pavi)
		    AVIStreamAddRef(p->edits[l].pavi);
	    } else {
		p->edits[l] = this->edits[edit2];
		if (p->edits[l].pavi)
		    AVIStreamAddRef(p->edits[l].pavi);
		p->edits[l].lLength = l2 - p->edits[l].lStart;
	    }
	}
	
	p->PossiblyRemoveEdit(edit2 - edit1);	
	p->PossiblyRemoveEdit(0);
    }

#ifndef KEYALWAYS
    l1 = AVIStreamFindSample(p->edits[0].pavi, p->edits[0].lStart, 0);
    DPF("edit starts at %ld, key at %ld\n", p->edits[0].lStart, l1);
    if (l1 != p->edits[0].lStart) {
	p->fFullFrames = TRUE;
	DPF("Copy: Converting new stream to full frames\n");
    }
#endif

    AVIStreamInfo(this->edits[0].pavi, &p->sinfo, sizeof(p->sinfo));
    p->sinfo.dwStart = 0;
    p->sinfo.dwLength = (DWORD) lLength;
    p->sinfo.dwEditCount = 0;
    p->sinfo.dwFormatChangeCount = 0;
    if (p->fFullFrames)
	p->sinfo.fccHandler = 0;

    p->CheckEditList();
    CheckEditList();

    return AVIERR_OK;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
inline BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
        lpbi1->biCompression == lpbi2->biCompression   &&
        lpbi1->biSize        == lpbi2->biSize          &&
        lpbi1->biWidth       == lpbi2->biWidth         &&
        lpbi1->biHeight      == lpbi2->biHeight        &&
        lpbi1->biBitCount    == lpbi2->biBitCount;
}

BOOL AreVideoStreamsCompatible(PAVISTREAM ps1, PAVISTREAM ps2)
{
    LONG	cb1, cb2;
    BITMAPINFOHEADER	bih1, bih2;
	
    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), NULL, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), NULL, &cb2);

    if (cb1 != cb2)
	return FALSE;

    cb1 = sizeof(bih1);
    cb2 = sizeof(bih2);
    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), &bih1, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), &bih2, &cb2);

    if (DibEq(&bih1, &bih2))
	return TRUE;

    return FALSE;
}

BOOL AreAudioStreamsCompatible(PAVISTREAM ps1, PAVISTREAM ps2)
{
    LONG	cb1, cb2;
    LPVOID	lpf;
    BOOL	f;

    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), NULL, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), NULL, &cb2);

    if (cb1 != cb2)
	return FALSE;

    lpf = GlobalAllocPtr(GHND, cb1 + cb2);

    if (!lpf)
	return FALSE; // !!!

    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), lpf, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), (BYTE FAR *)lpf + cb1, &cb2);

    f = !_fmemcmp(lpf, (BYTE FAR *)lpf + cb1, (UINT) cb1);

    GlobalFreePtr(lpf);

    return f;
}

//
// Paste:
//
//     Takes stream to paste, along with start and length within that stream,
//	and also target stream and position within the stream to do the paste.
//
//	Returns position and length pasted.
//
STDMETHODIMP CEditStream::Paste(LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lLength)
{
    PAVISTREAM	p;
    LONG	l;
    LONG	edit;
    HRESULT	hr;
    LONG	lPos;
    CEditStream	FAR *pnew;
    AVISTREAMINFO   strinfo;

    AVIStreamInfo(pstream, &strinfo, sizeof(strinfo));

    if (this->sinfo.fccType == 0) {
	AVIStreamInfo(pstream, &this->sinfo, sizeof(this->sinfo));
	this->sinfo.dwLength = 0;
	this->sinfo.dwStart = *plPos;
    }

    if (*plPos > (LONG) (sinfo.dwLength + sinfo.dwStart)) {
	// !!! We should handle this case....
	return ResultFromScode(AVIERR_BADPARAM);
    }


#ifdef KEYALWAYS
    // Make paste go before a key frame...
    *plPos = AVIStreamFindSample(this, *plPos, 0);
#endif
    lPos = *plPos;

    if (strinfo.fccType != this->sinfo.fccType) {
	DPF("Paste: Incompatible stream types!\n");
	return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if (lLength <= 0 || ((lStart + lLength) >
			 (LONG) (strinfo.dwStart + strinfo.dwLength))) {
	if (lStart >= (LONG) (strinfo.dwLength + strinfo.dwStart))
	    return ResultFromScode(AVIERR_BADPARAM);

	lLength = (LONG) (strinfo.dwLength + strinfo.dwStart) - lStart;
    }

    if ((DWORD) lPos + (DWORD) lLength > 0x80000000) {
	DPF("Paste result would be more than 2 billion frames!\n");
	return ResultFromScode(AVIERR_MEMORY);
    }

    // !!! What if the frame rates don't match?

#define SIZEMISMATCH(rc1, rc2) \
    (((rc1.right - rc1.left) != (rc2.right - rc2.left)) || \
     ((rc1.bottom - rc1.top) != (rc2.bottom - rc2.top)))

    if (strinfo.fccType == streamtypeVIDEO &&
		SIZEMISMATCH(strinfo.rcFrame, this->sinfo.rcFrame)) {
	// !!! It would be nice if this worked.
	DPF("Paste: Video streams are different sizes!\n");
	return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if (this->sinfo.fccType == streamtypeAUDIO) {
	if (!AreAudioStreamsCompatible((PAVISTREAM) this, pstream)) {
	    DPF("Paste: Audio streams are different formats!\n");
	    return ResultFromScode(AVIERR_UNSUPPORTED);
	}
    }

    pnew = NULL;
    pstream->QueryInterface(CLSID_EditStream, (LPVOID FAR *) &pnew);

#ifndef KEYALWAYS
    if (this->sinfo.fccType == streamtypeVIDEO) {
	if (!this->fFullFrames) {
	    if ((!AVIStreamIsKeyFrame(pstream, lStart) ||
		 (pnew && pnew->fFullFrames)) ||
		((lPos < (LONG) (sinfo.dwLength + sinfo.dwStart)) &&
		 !AVIStreamIsKeyFrame((PAVISTREAM) this, lPos)) ||
		!AreVideoStreamsCompatible((PAVISTREAM) this, pstream)) {

		// !!! What if we're pasting, say, an 8-bit and a 32-bit
		// movie together?  Do we have to pick a common format
		// to convert to?
		CallGetFrame(this->edits[0].pavi, this->edits[0].lStart);
		if (CallGetFrame(pstream, lStart) == NULL) {
		    DPF("Paste: Can't make a common format!\n");
		    if (pnew)
			pnew->Release();
		
		    return ResultFromScode(AVIERR_BADFORMAT);
		}

		this->fFullFrames = TRUE;
		DPF("Paste: Converting stream to full frames\n");
		this->sinfo.dwFormatChangeCount++;

		// ??? !!! Call get frame once, just so it's been done....
	    }
	} else {
	    if (CallGetFrame(pstream, lStart) == NULL) {
		DPF("Paste: Can't make a common format!\n");
		if (pnew)
		    pnew->Release();
		
		return ResultFromScode(AVIERR_BADFORMAT);
	    }
	}
    }
#endif

    // Find where to do the paste...
    hr = ResolveEdits(lPos, &p, &l, &edit, TRUE);

    // Report back the size of what we pasted...
    if (plLength)
	*plLength = lLength;

    if (pnew) {
	LONG	lNew;

	// The inserted stream is itself an edit list; take advantage
	// of this fact.
	hr = AllocEditSpace(edit, 1 + pnew->cedits);

	this->edits[edit].pavi = this->edits[edit + 1 + pnew->cedits].pavi;
	if (this->edits[edit].pavi)
	    AVIStreamAddRef(this->edits[edit].pavi);
	this->edits[edit].lStart = this->edits[edit + 1 + pnew->cedits].lStart;
	this->edits[edit].lLength = l - this->edits[edit].lStart;

	// !!! We're ignoring lStart and lLength!
	for (lNew = 0; lNew < pnew->cedits; lNew++) {
	    this->edits[edit + 1 + lNew] = pnew->edits[lNew];
	    AVIStreamAddRef(pnew->edits[lNew].pavi);
	}

	this->edits[edit + pnew->cedits + 1].lStart = l;
	this->edits[edit + pnew->cedits + 1].lLength -= this->edits[edit].lLength;

	// Get rid of zero-length edits....
	PossiblyRemoveEdit(edit + pnew->cedits + 1);
	
	PossiblyRemoveEdit(edit);
	
	this->sinfo.dwLength += lLength;
	pnew->CheckEditList();

	pnew->Release();
    } else {
	// Just insert the stream as a blob.
	hr = AllocEditSpace(edit, 2);

	this->edits[edit].pavi = this->edits[edit+2].pavi;
	if (this->edits[edit].pavi)
	    AVIStreamAddRef(this->edits[edit].pavi);
	this->edits[edit].lStart = this->edits[edit+2].lStart;
	this->edits[edit].lLength = l - this->edits[edit+2].lStart;

	this->edits[edit+ 1].pavi = pstream;
	if (pstream)
	    AVIStreamAddRef(pstream);
	this->edits[edit + 1].lStart = lStart;
	this->edits[edit + 1].lLength = lLength;

	this->edits[edit + 2].lStart = l;
	this->edits[edit + 2].lLength -= this->edits[edit].lLength;
	// No addref here, since the edit we're splitting had a ref already
	
	this->sinfo.dwLength += lLength;

	// Get rid of zero-length edits....
	PossiblyRemoveEdit(edit + 2);
	
	PossiblyRemoveEdit(edit);
    }

    CheckEditList();
    this->sinfo.dwEditCount++;

    return AVIERR_OK;
}

STDMETHODIMP CEditStream::Clone(PAVISTREAM FAR *ppResult)
{
    CEditStream FAR *	pnew;
    HRESULT		hr;
    LONG		l;

    pnew = NewEditStream(NULL);
    *ppResult = (PAVISTREAM) pnew;
    if (!pnew)
	return ResultFromScode(AVIERR_MEMORY);

    if (this->cedits > 1) {
	hr = pnew->AllocEditSpace(1, this->cedits - 1);
	if (hr != NOERROR) {
	    // !!! Clean things up
	    return hr;
	}
    }

    for (l = 0; l < this->cedits; l++) {
	pnew->edits[l] = this->edits[l];
	if (pnew->edits[l].pavi)
	    AVIStreamAddRef(pnew->edits[l].pavi);
    }

    pnew->sinfo = this->sinfo;
    pnew->fFullFrames = this->fFullFrames;

    pnew->CheckEditList();

    return AVIERR_OK;
}

STDMETHODIMP CEditStream::SetInfo(AVISTREAMINFO FAR * lpInfo, LONG cbInfo)
{
    if ((cbInfo < sizeof(AVISTREAMINFO)) ||
	(IsBadReadPtr(lpInfo, sizeof(AVISTREAMINFO))))
	return ResultFromScode(AVIERR_BADPARAM);

    // Things we don't copy:
    // fccType
    // fccHandler
    // dwFlags
    // dwCaps
    // dwLength
    // dwInitialFrames
    // dwSuggestedBufferSize
    // dwSampleSize
    // dwEditCount
    // dwFormatChangeCount

    this->sinfo.wPriority = lpInfo->wPriority;
    this->sinfo.wLanguage = lpInfo->wLanguage;
    this->sinfo.dwScale   = lpInfo->dwScale;
    this->sinfo.dwRate    = lpInfo->dwRate;
    this->sinfo.dwStart   = lpInfo->dwStart;  // !!! ???
    this->sinfo.dwQuality = lpInfo->dwQuality;
    this->sinfo.rcFrame   = lpInfo->rcFrame;

    if (lpInfo->szName[0])
	_fmemcpy(this->sinfo.szName, lpInfo->szName, sizeof(this->sinfo.szName));

    // The stream has been changed....
    ++this->sinfo.dwEditCount;

    return NOERROR;
}



//
//
//   Extra unimplemented functions.....
//
//
//
HRESULT STDMETHODCALLTYPE CEditStream::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (riid == IID_IUnknown)
	*ppvObj = ((IUnknown FAR *) (IAVIStream FAR *) this);
    else if (riid == IID_IAVIStream)
	*ppvObj = ((IAVIStream FAR *) this);
    else if (riid == IID_IAVIEditStream)
	*ppvObj = ((IAVIEditStream FAR *) this);
#if 0
    else if ((riid == IID_IMarshal) && CanMarshalSimply()) // !!!! Remove once fixed!
	*ppvObj = ((IMarshal FAR *) this);
#endif
    else if (riid == CLSID_EditStream)
	*ppvObj = this;
    else {                 // unsupported interface
        *ppvObj = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CEditStream::ReadData     (DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::SetFormat    (LONG lPos, LPVOID lpFormat, LONG cbFormat)
{
    // !!! We could set the whole format of the stream here, and do mapping....

    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::WriteData    (DWORD fcc, LPVOID lp, LONG cb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Write        (LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags, LONG FAR *plSampWritten, LONG FAR *plBytesWritten)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Delete       (LONG lStart, LONG lSamples)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT CEditStream::NewInstance(IUnknown FAR* pUnknownOuter,
			       REFIID riid,
			       LPVOID FAR* ppv)
{
    CEditStream FAR *	pedit;
    HRESULT		hr;

    pedit = new CEditStream;

    if (pedit)
	(pedit->Create)(NULL, 0);
    // !!! error check

    hr = pedit->QueryInterface(riid, ppv);

    if (FAILED(GetScode(hr)))
	delete pedit;

    return hr;
}

BOOL CEditStream::CanMarshalSimply()
{
    LONG	l;
    LPUNKNOWN	punk;

    for (l = 0; l < this->cedits; l++) {
	punk = NULL;

	this->edits[l].pavi->QueryInterface(CLSID_AVISimpleUnMarshal,
					    (LPVOID FAR *) &punk);

	if (!punk)
	    return FALSE;
	
	punk->Release();
    }

    return TRUE;
}

STDMETHODIMP CEditStream::GetUnmarshalClass (REFIID riid, LPVOID pv,
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPCLSID pCid)
{
    if (CanMarshalSimply()) {
	DPF("UnMarshalClass called (simple)\n");

	*pCid = CLSID_AVISimpleUnMarshal;
    } else {
	DPF("UnMarshalClass called (not simple)\n");

	*pCid = CLSID_EditStream;
    }
    return NOERROR;
}

STDMETHODIMP CEditStream::GetMarshalSizeMax (REFIID riid, LPVOID pv,
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPDWORD pSize)
{
    if (CanMarshalSimply())
	*pSize = 4;
    else
	*pSize = 0;

    return NOERROR;
}

STDMETHODIMP CEditStream::MarshalInterface (LPSTREAM pStm, REFIID riid,
		    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags)
{
    HRESULT	hr;

    if ((riid != IID_IAVIStream && riid != IID_IAVIFile && riid != IID_IUnknown))
        return ResultFromScode(E_INVALIDARG);

    if (CanMarshalSimply()) {
	LPUNKNOWN pUnk = (LPUNKNOWN) (PAVISTREAM) this;
	
	DPF("MarshalInterface called (simple): Marshalling %lx\n", (DWORD) pUnk);
	if ((hr = pStm->Write(&pUnk, sizeof(pUnk), NULL)) == NOERROR)
	    AddRef();
    } else {

	DPF("MarshalInterface called (not simple)\n");
	hr = ResultFromScode(AVIERR_UNSUPPORTED);

    }

    DPF("Returns %lx\n", (DWORD) (LPVOID) hr);

    return hr;
}

STDMETHODIMP CEditStream::UnmarshalInterface (LPSTREAM pStm, REFIID riid,
		    LPVOID FAR* ppv)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CEditStream::ReleaseMarshalData (LPSTREAM pStm)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CEditStream::DisconnectObject (DWORD dwReserved)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}



HRESULT STDMETHODCALLTYPE CEditStream::Reserved1()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved2()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved3()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved4()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved5()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}



/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * ICSAMPLE=1
 *
 ****************************************************************************/

#ifdef DEBUG

#define MODNAME "EditStrm"
static BOOL  fDebug = -1;

static void cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

#ifdef WIN32
    va_list va;
    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    va_start(va, szFormat);
    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va);
    va_end(va);
//  lstrcatA(ach, "\r\r\n");

    OutputDebugStringA(ach);
#else
    if (fDebug == -1)
        fDebug = GetProfileInt("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpy(ach, MODNAME ": ");

    wvsprintf(ach+lstrlen(ach),szFormat,(LPSTR)(&szFormat+1));
//  lstrcat(ach, "\r\r\n");

    OutputDebugString(ach);
#endif
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\classobj.cpp ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#include <win32.h>
#include <shellapi.h>

#include <compobj.h>

#define INITGUID        // make DECLARE_GUILD()
#include <initguid.h>

#ifdef WIN32
//
// !!!for some reason we can't link to GUID's in Win32!!!
//
#include <coguid.h>
#endif

#include <avifmt.h>
#include "avifile.h"
#include "avifilei.h"
#include "avicmprs.h"
#include "avifps.h"
#include "editstrm.h"

#include "debug.h"

extern "C"	HINSTANCE	ghMod;
		HINSTANCE	ghMod;

/*      -       -       -       -       -       -       -       -       */

EXTERN_C int CALLBACK LibMain(
        HINSTANCE       hInstance,
        UINT            uDataSeg,
        UINT            cbHeapSize,
        LPCSTR          pszCmdLine)
{
	// save our module handle
	ghMod = hInstance;
	return TRUE;
}

EXTERN_C int CALLBACK WEP(BOOL fSystemExit)
{
	return TRUE;
}

/*	-	-	-	-	-	-	-	-	*/

STDAPI DllGetClassObject(
	const CLSID FAR&	rclsid,
	const IID FAR&	riid,
	void FAR* FAR*	ppv)
{
	HRESULT	hresult;

	DPF("DllGetClassObject\n");

	if (rclsid == CLSID_AVIFile ||
#if 0
	    rclsid == CLSID_AVISimpleUnMarshal ||
#endif
	    rclsid == CLSID_AVICmprsStream) {
	    hresult = CAVIFileCF::Create(rclsid, riid, ppv);
	    return hresult;
	} else if (rclsid == CLSID_AVIStreamPS) {
	    return (*ppv = (LPVOID)new CPSFactory()) != NULL
		? NOERROR : ResultFromScode(E_OUTOFMEMORY);
	} else {
	    return ResultFromScode(E_UNEXPECTED);
	}
}

/*      -       -       -       -       -       -       -       -       */

#ifdef WIN32

EXTERN_C BOOL WINAPI DLLEntryPoint(HINSTANCE hModule, ULONG Reason, LPVOID pv)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            LibMain(hModule, 0, 0, NULL);
            break;

        case DLL_PROCESS_DETACH:
            WEP(FALSE);
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_THREAD_ATTACH:
            break;
    }

    return TRUE;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\editstrm.h ===
DEFINE_AVIGUID(CLSID_EditStream,        0x0002000A, 0, 0);

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

typedef struct {
    PAVISTREAM	    pavi;
    LONG	    lStart;
    LONG	    lLength;
    LONG	    unused;	// pad to power of two in size....
    RECT	    rcSource;
    RECT	    rcDest;
} EDIT, FAR * LPEDIT;

class FAR CEditStream : public virtual IAVIStream,
			public virtual IAVIEditStream,
			public virtual IMarshal {
public:
    static CEditStream FAR * NewEditStream(PAVISTREAM psSource);
    
    STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
    STDMETHODIMP_(ULONG) AddRef();	\
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHODIMP Info        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize);
    STDMETHODIMP_(LONG)  FindSample (THIS_ LONG lPos, LONG lFlags);
    STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *cbFormat);
    STDMETHODIMP SetFormat   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer,
			      DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);
    STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
    STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);

    STDMETHODIMP Cut(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);
    STDMETHODIMP Copy(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);
    STDMETHODIMP Paste(LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lLength);
    STDMETHODIMP Clone(PAVISTREAM FAR *ppResult);
    STDMETHODIMP SetInfo(AVISTREAMINFO FAR *lpInfo, LONG cbInfo);
    
    // *** IMarshal methods ***

    static HRESULT NewInstance(IUnknown FAR* pUnknownOuter,
			       REFIID riid,
			       LPVOID FAR* ppv);
    BOOL CanMarshalSimply();

    STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPCLSID pCid);
    STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPDWORD pSize);
    STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags);
    STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			LPVOID FAR* ppv);
    STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
    STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);

    
private:
    CEditStream() {
	cedits = 0;
	maxedits = 0;
	edits = NULL;
	pgf = NULL;
	psgf = NULL;
	fFullFrames = FALSE;
    };
    
    HRESULT ResolveEdits(LONG lPos,
		  PAVISTREAM FAR *ppavi, LONG FAR *plPos,
		  LONG FAR *pl, BOOL fAllowEnd);
    HRESULT PossiblyRemoveEdit(LONG l);
    HRESULT AllocEditSpace(LONG l, LONG cNew);
    LPBITMAPINFOHEADER NEAR PASCAL CEditStream::CallGetFrame(
						      PAVISTREAM p,
						      LONG l);
    void CheckEditList();
    
public:
    ULONG			ulRefCount;
    //
    // instance data
    //
    AVISTREAMINFO		sinfo;    
    LONG    			cedits;
    LONG    			maxedits;
    BOOL			fFullFrames;
    EDIT _huge *		edits;

    //
    // cached PGETFRAME
    PGETFRAME			pgf;
    PAVISTREAM			psgf;
    LPBITMAPINFOHEADER		lpbiLast;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\device.cpp ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#include <win32.h>
#include <compobj.h>
#include <avifmt.h>
#include "avifile.h"
#include "avifilei.h"
#include "debug.h"

/*	-	-	-	-	-	-	-	-	*/

UINT	uUseCount;
BOOL	fLocked;

/*	-	-	-	-	-	-	-	-	*/

STDAPI DllCanUnloadNow(
	void)
{
	return ResultFromScode((fLocked || uUseCount) ? S_FALSE : S_OK);
}

/*	-	-	-	-	-	-	-	-	*/

HRESULT CAVIFile::Create(
	IUnknown FAR*	pUnknownOuter,
	const IID FAR&	riid,
	void FAR* FAR*	ppv)
{
	IUnknown FAR*	pUnknown;
	CAVIFile FAR*	pAVIFile;
	HRESULT	hresult;

	pAVIFile = new FAR CAVIFile(pUnknownOuter, &pUnknown);
	if (!pAVIFile)
		return ResultFromScode(E_OUTOFMEMORY);
	hresult = pUnknown->QueryInterface(riid, ppv);
	if (FAILED(GetScode(hresult)))
		delete pAVIFile;
	return hresult;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CAVIFile(
	IUnknown FAR*	pUnknownOuter,
	IUnknown FAR* FAR*	ppUnknown) :
	m_Unknown(this),
	m_AVIFile(this),
	m_Marshal(this)
{
	hshfile = 0;
	achFile[0] = '\0';
	fInRecord = FALSE;
	lWriteLoc = 0;
	fDirty = 0;
	extra.lp = 0;
	extra.cb = 0;
	_fmemset(&avihdr, 0, sizeof(avihdr));
	avihdr.dwStreams = 0;
	lHeaderSize = 0;
        px = NULL;
	pb = NULL;

	if (pUnknownOuter) {
	    DPF("(F) Being aggregated!\n");
	    m_pUnknownOuter = pUnknownOuter;
	} else
	    m_pUnknownOuter = &m_Unknown;
	*ppUnknown = &m_Unknown;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CUnknownImpl::CUnknownImpl(
	CAVIFile FAR*	pAVIFile)
{
	m_pAVIFile = pAVIFile;
	m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFile::CUnknownImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	if (iid == IID_IUnknown || iid == CLSID_AVISimpleUnMarshal)
		*ppv = &m_pAVIFile->m_Unknown;
	else if (iid == IID_IAVIFile)
		*ppv = &m_pAVIFile->m_AVIFile;
#if 0
	else if (iid == IID_IMarshal) {
		DPF("(F) QueryInterface (IMarshal)\n");
		*ppv = &m_pAVIFile->m_Marshal;
	}
#endif
	else
		return ResultFromScode(E_NOINTERFACE);
	AddRef();
	return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFile::CUnknownImpl::AddRef()
{
	DPF2("File   %lx: Usage++=%lx\n", (DWORD) (LPVOID) this, m_refs + 1);

	if (m_pAVIFile->hshfile)
	    shfileAddRef(m_pAVIFile->hshfile);
	uUseCount++;
	return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CAVIFileImpl::CAVIFileImpl(
	CAVIFile FAR*	pAVIFile)
{
	m_pAVIFile = pAVIFile;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CAVIFileImpl::~CAVIFileImpl()
{
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFile::CAVIFileImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	return m_pAVIFile->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFile::CAVIFileImpl::AddRef()
{
	return m_pAVIFile->m_pUnknownOuter->AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFile::CAVIFileImpl::Release()
{
	return m_pAVIFile->m_pUnknownOuter->Release();
}

/*	-	-	-	-	-	-	-	-	*/


/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CAVIStream(
	IUnknown FAR*	pUnknownOuter,
	IUnknown FAR* FAR*	ppUnknown) :
	m_Unknown(this),
	m_AVIStream(this),
	m_Marshal(this),
	m_Streaming(this)
{
	paviBase = NULL;
	hshfile = 0;
	lpFormat = NULL;
	cbFormat = 0;
	lpData = NULL;
	cbData = 0;
	extra.lp = NULL;
        extra.cb = 0;
        psx = NULL;
	lPal = 0;
	pb = NULL;
	fInit = FALSE;

	if (pUnknownOuter) {
	    DPF("(S) Being aggregated!\n");
	    m_pUnknownOuter = pUnknownOuter;
	}
	else
		m_pUnknownOuter = &m_Unknown;
	*ppUnknown = &m_Unknown;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CUnknownImpl::CUnknownImpl(
	CAVIStream FAR*	pAVIStream)
{
	m_pAVIStream = pAVIStream;
	m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIStream::CUnknownImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	if (iid == IID_IUnknown || iid == CLSID_AVISimpleUnMarshal)
		*ppv = &m_pAVIStream->m_Unknown;
	else if (iid == IID_IAVIStream)
		*ppv = &m_pAVIStream->m_AVIStream;
	else if (iid == IID_IAVIStreaming)
		*ppv = &m_pAVIStream->m_Streaming;
#if 0
	else if (iid == IID_IMarshal) {
		DPF("(S) QueryInterface (IMarshal)\n");
		*ppv = &m_pAVIStream->m_Marshal;
	}
#endif
	else
		return ResultFromScode(E_NOINTERFACE);
	AddRef();
	return NULL;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CUnknownImpl::AddRef()
{
	uUseCount++;
	if (m_pAVIStream->hshfile)
	    shfileAddRef(m_pAVIStream->hshfile);
	if (m_refs < 20) {
	    DPF2("Stream %lx: Usage++=%lx\n", (DWORD) (LPVOID) this, m_refs + 1);
	}
	
	return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CAVIStreamImpl::CAVIStreamImpl(
	CAVIStream FAR*	pAVIStream)
{
	m_pAVIStream = pAVIStream;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CAVIStreamImpl::~CAVIStreamImpl()
{
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIStream::CAVIStreamImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CAVIStreamImpl::AddRef()
{
	return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CAVIStreamImpl::Release()
{
	return m_pAVIStream->m_pUnknownOuter->Release();
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CStreamingImpl::CStreamingImpl(
	CAVIStream   FAR*	pAVIStream)
{
	m_pAVIStream = pAVIStream;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CStreamingImpl::~CStreamingImpl()
{
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIStream::CStreamingImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CStreamingImpl::AddRef()
{
	return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CStreamingImpl::Release()
{
	return m_pAVIStream->m_pUnknownOuter->Release();
}

/*	-	-	-	-	-	-	-	-	*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\enumfetc.h ===
/*************************************************************************
** 
**    OLE 2 Utility Code
**    
**    enumfetc.c
**    
**    Private definitions, structures, types, and function prototypes for the
**    CEnumFormatEtc implementation of the IEnumFORMATETC interface.
**    This file is part of the OLE 2.0 User Interface support library.
**    
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#ifndef __ENUMFETC_H__
#define __ENUMFETC_H__

#ifndef RC_INVOKED
#pragma message ("INCLUDING ENUMFETC.H from " __FILE__)
#endif  /* RC_INVOKED */

  
STDAPI_(LPENUMFORMATETC)        
  OleStdEnumFmtEtc_Create(WORD wCount, LPFORMATETC lpEtc);

#endif // __ENUMFETC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\enumfetc.c ===
/*************************************************************************
** 
**    OLE 2 Utility Code
**    
**    enumfetc.c
**    
**    This file contains a standard implementation of IEnumFormatEtc
**    interface.  
**    This file is part of the OLE 2.0 User Interface support library.
**    
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#define STRICT  1
#include <win32.h>
#include <shellapi.h>
#include <ole2.h>

#include "enumfetc.h"

STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);

typedef struct tagOleStdEnumFmtEtc {
  IEnumFORMATETCVtbl FAR* lpVtbl;
  ULONG m_dwRefs;      /* referance count */
  WORD m_wIndex;       /* current index in list */
  WORD m_wCount;       /* how many items in list */
  LPFORMATETC m_lpEtc;  /* list of formatetc */
} OLESTDENUMFMTETC, FAR* LPOLESTDENUMFMTETC;

VOID  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC pEtc);

STDMETHODIMP OleStdEnumFmtEtc_QueryInterface(
        LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt,
                                  LPFORMATETC rgelt, ULONG FAR* pceltFetched);
STDMETHODIMP  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt);
STDMETHODIMP  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis,
                                     LPENUMFORMATETC FAR* ppenum);
                       
static IEnumFORMATETCVtbl g_EnumFORMATETCVtbl = {
        OleStdEnumFmtEtc_QueryInterface,
        OleStdEnumFmtEtc_AddRef,
        OleStdEnumFmtEtc_Release,
        OleStdEnumFmtEtc_Next,
        OleStdEnumFmtEtc_Skip,
        OleStdEnumFmtEtc_Reset,
        OleStdEnumFmtEtc_Clone,
};

/////////////////////////////////////////////////////////////////////////////

        
STDAPI_(LPENUMFORMATETC)        
  OleStdEnumFmtEtc_Create(WORD wCount, LPFORMATETC lpEtc)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPMALLOC lpMalloc=NULL;
  LPOLESTDENUMFMTETC lpEF=NULL;
  DWORD dwSize;
  WORD i;
  HRESULT hRes;

  hRes = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
  if (hRes != NOERROR) {
    return NULL;
  }

  lpEF = (LPOLESTDENUMFMTETC)lpMalloc->lpVtbl->Alloc(lpMalloc,
                                                 sizeof(OLESTDENUMFMTETC));
  if (lpEF == NULL) {
    goto errReturn;
  }

  lpEF->lpVtbl = &g_EnumFORMATETCVtbl;
  lpEF->m_dwRefs = 1;
  lpEF->m_wCount = wCount;
  lpEF->m_wIndex = 0;
  
  dwSize = sizeof(FORMATETC) * lpEF->m_wCount;

  lpEF->m_lpEtc = (LPFORMATETC)lpMalloc->lpVtbl->Alloc(lpMalloc, dwSize);
  if (lpEF->m_lpEtc == NULL) {
    goto errReturn;
  }

  for (i=0; i<wCount; i++) {
    OleStdCopyFormatEtc(
            (LPFORMATETC)&(lpEF->m_lpEtc[i]), (LPFORMATETC)&(lpEtc[i]));
  }

  return (LPENUMFORMATETC)lpEF;
  
errReturn:
  if (lpEF != NULL) {
    lpMalloc->lpVtbl->Free(lpMalloc, lpEF);
  }
  
  if (lpMalloc != NULL) {
    lpMalloc->lpVtbl->Release(lpMalloc);
  }
  
  return NULL;

} /* OleStdEnumFmtEtc_Create()
   */


VOID
  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC lpEF)
//----------------------------------------------------------------------------
// 
//----------------------------------------------------------------------------
{
    LPMALLOC lpMalloc=NULL;
    WORD i;

    if (lpEF != NULL) {

        if (CoGetMalloc(MEMCTX_TASK, &lpMalloc) == NOERROR) {

            /* OLE2NOTE: we MUST free any memory that was allocated for
            **    TARGETDEVICES contained within the FORMATETC elements.
            */
            for (i=0; i<lpEF->m_wCount; i++) {
                OleStdFree(lpEF->m_lpEtc[i].ptd);
            }

            if (lpEF->m_lpEtc != NULL) {
                lpMalloc->lpVtbl->Free(lpMalloc, lpEF->m_lpEtc);
            }

            lpMalloc->lpVtbl->Free(lpMalloc, lpEF);
            lpMalloc->lpVtbl->Release(lpMalloc);
        }
    }
} /* OleStdEnumFmtEtc_Destroy()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_QueryInterface(
                LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  *ppobj = NULL;
  
  if (IsEqualIID(riid,&IID_IUnknown) || IsEqualIID(riid,&IID_IEnumFORMATETC)){
    *ppobj = (LPVOID)lpEF;
  }

  if (*ppobj == NULL) return ResultFromScode(S_FALSE);
  else{
    OleStdEnumFmtEtc_AddRef(lpThis);
    return NOERROR;
  }
  
} /* OleStdEnumFmtEtc_QueryInterface()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  return lpEF->m_dwRefs++;

} /* OleStdEnumFmtEtc_AddRef()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  DWORD dwRefs = --lpEF->m_dwRefs;

  if (dwRefs == 0) 
    OleStdEnumFmtEtc_Destroy(lpEF);

  return dwRefs;

} /* OleStdEnumFmtEtc_Release()
   */


STDMETHODIMP 
  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt, LPFORMATETC rgelt,
                      ULONG FAR* pceltFetched)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  WORD wOffset;

  if (rgelt == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }
  
  while (i < celt) {
    wOffset = lpEF->m_wIndex + (WORD)i;

    if (wOffset < lpEF->m_wCount) {
      OleStdCopyFormatEtc(
            (LPFORMATETC)&(rgelt[i]), (LPFORMATETC)&(lpEF->m_lpEtc[wOffset]));
      lpEF->m_wIndex ++;
      i++;
    }else{
      break;
    }
  }

  if (pceltFetched != NULL) {
    *pceltFetched = i;
  }

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Next()
   */


STDMETHODIMP 
  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  WORD wOffset;

  while (i < celt) {
    wOffset = lpEF->m_wIndex + (WORD)i;

    if (wOffset < lpEF->m_wCount) {
      lpEF->m_wIndex ++;
      i++;
    }else{
      break;
    }
  }

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Skip()
   */


STDMETHODIMP 
  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  lpEF->m_wIndex = 0;

  return NOERROR;
} /* OleStdEnumFmtEtc_Reset()
   */


STDMETHODIMP 
  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis, LPENUMFORMATETC FAR* ppenum)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;

  if (ppenum == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }
  
  *ppenum = OleStdEnumFmtEtc_Create(lpEF->m_wCount, lpEF->m_lpEtc);

  return (*ppenum != NULL ? NOERROR : ResultFromScode(E_OUTOFMEMORY));

} /* OleStdEnumFmtEtc_Clone()
   */



/* OleStdMalloc
** ------------
**    allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize)
{
    LPVOID pout;
    LPMALLOC pmalloc;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != S_OK) {
//        OleDbgAssertSz(0, szAssertMemAlloc);
        return NULL;
    }

    pout = (LPVOID)pmalloc->lpVtbl->Alloc(pmalloc, ulSize);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }

    return pout;
}

/*
 * OleStdCopyTargetDevice()
 *
 * Purpose:
 *  duplicate a TARGETDEVICE struct. this function allocates memory for 
 *  the copy. the caller MUST free the allocated copy when done with it 
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  ptdSrc      pointer to source TARGETDEVICE
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc
 *    if ptdSrc==NULL then retuns NULL is returned.
 *    if ptdSrc!=NULL and memory allocation fails, then NULL is returned
 */
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc)
{
  DVTARGETDEVICE FAR* ptdDest = NULL;

  if (ptdSrc == NULL) {
    return NULL;
  }

  if ((ptdDest = (DVTARGETDEVICE FAR*)OleStdMalloc(ptdSrc->tdSize)) != NULL) {
    hmemcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
  }

  return ptdDest;
} 



/*
 * OleStdCopyFormatEtc()
 *
 * Purpose:
 *  Copies the contents of a FORMATETC structure. this function takes 
 *  special care to copy correctly copying the pointer to the TARGETDEVICE 
 *  contained within the source FORMATETC structure.
 *  if the source FORMATETC has a non-NULL TARGETDEVICE, then a copy
 *  of the TARGETDEVICE will be allocated for the destination of the 
 *  FORMATETC (petcDest).
 *
 *  OLE2NOTE: the caller MUST free the allocated copy of the TARGETDEVICE 
 *  within the destination FORMATETC when done with it 
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  petcDest      pointer to destination FORMATETC
 *  petcSrc       pointer to source FORMATETC
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc; retuns NULL if not successful
 */
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
  if ((petcDest == NULL) || (petcSrc == NULL)) {
    return FALSE;
  }

  petcDest->cfFormat = petcSrc->cfFormat;
  petcDest->ptd      = OleStdCopyTargetDevice(petcSrc->ptd);
  petcDest->dwAspect = petcSrc->dwAspect;
  petcDest->lindex   = petcSrc->lindex;
  petcDest->tymed    = petcSrc->tymed;

  return TRUE;
      
}

/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL) 
        return;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != S_OK) {
//        OleDbgAssertSz(0, szAssertMemAlloc);
        return;
    }

    pmalloc->lpVtbl->Free(pmalloc, pmem);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\extra.h ===
#include "fileshar.h"

typedef struct {
    LPVOID	lp;
    LONG	cb;
} EXTRA, FAR * LPEXTRA;

HRESULT ReadExtra(LPEXTRA extra,
		DWORD ckid,
	       LPVOID lpData,
	       LONG FAR *lpcbData);
HRESULT WriteExtra(LPEXTRA extra,
		DWORD ckid,
		LPVOID lpData,
		LONG cbData);

HRESULT ReadIntoExtra(LPEXTRA extra,
		   HSHFILE hshfile,
		   MMCKINFO FAR *lpck);

LONG FindChunkAndKeepExtras(LPEXTRA extra, HSHFILE hshfile,
			MMCKINFO FAR* lpck, MMCKINFO FAR* lpckParent,
			UINT uFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\fakefile.h ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

/*
** _StdClassImplementations
** Defines the standard implementations for a class object.
*/

#define	_StdClassImplementations(Impl)	\
	STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
	STDMETHODIMP_(ULONG) AddRef();	\
	STDMETHODIMP_(ULONG) Release()


/*	-	-	-	-	-	-	-	-	*/

class FAR CFakeFile : IAVIFile {
public:
    CFakeFile(int nStreams, PAVISTREAM FAR * papStreams);

    _StdClassImplementations(CUnknownImpl);

    STDMETHODIMP Open		    (THIS_
				     LPCSTR szFile,
				     UINT mode);
    STDMETHODIMP Info                 (THIS_
				     AVIFILEINFO FAR * pfi,
				     LONG lSize);
    STDMETHODIMP GetStream            (THIS_
				     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
				     LONG lParam);
    STDMETHODIMP CreateStream         (THIS_
				     PAVISTREAM FAR * ppStream,
				     AVISTREAMINFO FAR * psi);
    STDMETHODIMP Save                 (THIS_
				     LPCSTR szFile,
				     AVICOMPRESSOPTIONS FAR *lpOptions,
				     AVISAVECALLBACK lpfnCallback);
    STDMETHODIMP WriteData            (THIS_
				     DWORD ckid,
				     LPVOID lpData,
				     LONG cbData);
    STDMETHODIMP ReadData             (THIS_
				     DWORD ckid,
				     LPVOID lpData,
				     LONG FAR *lpcbData);
    STDMETHODIMP EndRecord            (THIS);
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);

public:
    IUnknown FAR*	m_pUnknownOuter;
    
    //
    //  AVIFile instance data
    //
    AVIFILEINFO FARSTRUCT	avihdr;         // file info
    ULONG			m_refs;
    PAVISTREAM NEAR *		aps;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\extra.cpp ===
#include <win32.h>
#include "avifile.h"
#include "extra.h"
#include "debug.h"

HRESULT ReadExtra(LPEXTRA extra,
	       DWORD ckid,
	       LPVOID lpData,
	       LONG FAR *lpcbData)
{
#define lpdw ((DWORD FAR *) lp)
    LPBYTE lp = (LPBYTE) extra->lp;
    LONG cb = extra->cb;
    LONG cbData;
    
    while (cb >= 2 * sizeof(DWORD)) {
	cbData = (LONG) lpdw[1];
	if (lpdw[0] == ckid) {
	    if (lpData) {
		hmemcpy(lpData, lp + 2 * sizeof(DWORD), min(cbData, *lpcbData));
	    }

	    *lpcbData = cbData;

	    return ResultFromScode(AVIERR_OK);
	}
	
	if (cbData & 1)
	    cbData++;
    
	cb -= cbData + sizeof(DWORD) * 2;
	lp += cbData + sizeof(DWORD) * 2;
    }
#undef lpdw
    *lpcbData = 0;
    return ResultFromScode(AVIERR_NODATA);
}

HRESULT WriteExtra(LPEXTRA extra,
		DWORD ckid,
		LPVOID lpData,
		LONG cbData)
{
    LPBYTE lp;
    
    cbData += sizeof(DWORD) * 2;
    if (extra->lp) {
	lp = (LPBYTE) GlobalReAllocPtr(extra->lp, extra->cb + cbData, GMEM_MOVEABLE | GMEM_SHARE);
    } else {
	lp = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbData);
    }

    if (!lp)
	return ResultFromScode(AVIERR_MEMORY);

    // !!! Should go and get rid of other chunks with same type!
    
    // build RIFF chunk in block
    ((DWORD FAR *) (lp + extra->cb))[0] = ckid;
    ((DWORD FAR *) (lp + extra->cb))[1] = cbData - sizeof(DWORD) * 2;
    
    hmemcpy(lp + extra->cb + sizeof(DWORD) * 2,
	    lpData,
	    cbData - sizeof(DWORD) * 2);

    if (cbData & 1)
	cbData++;
    
    extra->lp = lp;
    extra->cb += cbData;
    
    return ResultFromScode(AVIERR_OK);
}

HRESULT ReadIntoExtra(LPEXTRA extra,
		   HSHFILE hshfile,
		   MMCKINFO FAR * lpck)
{
    LPBYTE lp;
    LONG    cbData = lpck->cksize + sizeof(DWORD) * 2;
    
    DPF("ReadIntoExtra: now %ld bytes.\n", extra->cb + cbData);
    if (extra->lp) {
	lp = (LPBYTE) GlobalReAllocPtr(extra->lp, extra->cb + cbData, GMEM_MOVEABLE | GMEM_SHARE);
    } else {
	lp = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbData);
    }

    if (!lp)
	return ResultFromScode(AVIERR_MEMORY);

    extra->lp = lp;

    // build RIFF chunk in block
    ((DWORD FAR *) (lp + extra->cb))[0] = lpck->ckid;
    ((DWORD FAR *) (lp + extra->cb))[1] = lpck->cksize;

    cbData += (cbData & 1);

    shfileSeek(hshfile, lpck->dwDataOffset, SEEK_SET);
    if (shfileRead(hshfile, (HPSTR) lp + extra->cb + sizeof(DWORD) * 2, lpck->cksize) !=
		(LONG) lpck->cksize)
	return ResultFromScode(AVIERR_FILEREAD);
    
    extra->cb += cbData;
    
    return ResultFromScode(AVIERR_OK);
}


LONG FindChunkAndKeepExtras(LPEXTRA extra, HSHFILE hshfile, 
			MMCKINFO FAR* lpck, MMCKINFO FAR* lpckParent,
			UINT uFlags)
{
    FOURCC		ckidFind;	// chunk ID to find (or NULL)
    FOURCC		fccTypeFind;	// form/list type to find (or NULL)
    LONG		lRet;

    /* figure out what chunk id and form/list type to search for */
    if (uFlags & MMIO_FINDCHUNK)
	ckidFind = lpck->ckid, fccTypeFind = NULL;
    else if (uFlags & MMIO_FINDRIFF)
	ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else if (uFlags & MMIO_FINDLIST)
	ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
	ckidFind = fccTypeFind = (FOURCC) -1; // keep looking indefinitely
    
    for (;;) {
	lRet = shfileDescend(hshfile, lpck, lpckParent, 0);
	if (lRet) {
	    if (uFlags == 0 && lRet == MMIOERR_CHUNKNOTFOUND)
		lRet = 0;
	    return lRet;
	}

	if ((!ckidFind || lpck->ckid == ckidFind) &&
		    (!fccTypeFind || lpck->fccType == fccTypeFind))
	    return 0;

	if (lpck->ckid != mmioFOURCC('J', 'U', 'N', 'K')) {
	    lRet = (LONG) ReadIntoExtra(extra, hshfile, lpck);
	    if (lRet != AVIERR_OK)
		return lRet;
	}

	shfileAscend(hshfile, lpck, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\fileshar.h ===
#if !defined _FILESHAR_H
#define _FILESHAR_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

DECLARE_HANDLE(HSHFILE);

HSHFILE WINAPI shfileOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags);
UINT WINAPI shfileClose(HSHFILE hsh, UINT uFlags);
LONG WINAPI shfileRead(HSHFILE hsh, HPSTR pch, LONG cch);
LONG WINAPI shfileWrite(HSHFILE hsh, const char _huge* pch, LONG cch);
LONG WINAPI shfileSeek(HSHFILE hsh, LONG lOffset, int iOrigin);
LONG WINAPI shfileFlush(HSHFILE hsh, UINT uFlags);


LONG WINAPI shfileAddRef(HSHFILE hsh);
LONG WINAPI shfileRelease(HSHFILE hsh);

#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

MMRESULT WINAPI
shfileDescend(HSHFILE hshfile, LPMMCKINFO lpck, const LPMMCKINFO lpckParent, UINT wFlags);
MMRESULT WINAPI
shfileAscend(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags);
MMRESULT WINAPI
shfileCreateChunk(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // _FILESHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\getframe.cpp ===
/****************************************************************************
 *
 *  GETFRAME.CPP
 *
 *  this file contains the GetFrame APIs
 *
 *      AVIStreamGetFrameOpen
 *      AVIStreamGetFrameClose
 *      AVIStreamGetFrame
 *
 *  it also contains the default GetFrame implemenation
 *
 *      GetFrameDef
 *
 ***************************************************************************/

#include <win32.h>
#include <compobj.h>
#include <compman.h>
#include <memory.h>             // for _fmemset

#include "avifile.h"
#include "debug.h"              // for good ol' DPF()

/****************************************************************************
 *
 ***************************************************************************/

//!!! ACK
#define AVISF_VIDEO_PALCHANGES          0x00010000

#define ERR_FAIL   ResultFromScode(E_FAIL)
#define ERR_MEMORY ResultFromScode(E_OUTOFMEMORY)

#define WIDTHBYTES(i)       ((UINT)((i+31)&(~31))/8)
#define DIBWIDTHBYTES(lpbi) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(lpbi)->biBitCount)

/****************************************************************************
 *
 *  class for default IGetFrame
 *
 ***************************************************************************/

class FAR GetFrameDef : public IGetFrame
{
public:
    GetFrameDef(IAVIStream FAR *pavi=NULL);

public:
    // IUnknown stuff

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IGetFrame stuff.

    STDMETHODIMP Begin              (LONG lStart, LONG lEnd, LONG lRate);
    STDMETHODIMP End                ();

    STDMETHODIMP SetFormat          (LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy);

    STDMETHODIMP_(LPVOID) GetFrame  (LONG lPos);

private:
    ~GetFrameDef();
    void FreeStuff();

    // for AddRef
    ULONG   ulRefCount;

    // instance data.
    BOOL                        fBegin;         // inside of Begin/End
    BOOL                        fFmtChanges;    // file has format changes.

    PAVISTREAM			pavi;
    LONG                        lFrame;         // last frame decompressed

    LPVOID                      lpBuffer;       // read buffer.
    LONG                        cbBuffer;       // size of read buffer
    LPVOID                      lpFormat;       // stream format
    LONG                        cbFormat;       // size of format

    LPVOID                      lpFrame;        // the frame (format)
    LPVOID                      lpBits;         // the frame (bits)
    HIC                         hic;            // decompress handle

    BOOL                        fDecompressEx;  // using ICDecompressEx
    int                         x,y,dx,dy;      // where to decompress

    // to watch for the format changing.
    DWORD			dwFormatChangeCount;
    DWORD			dwEditCount;
};

/****************************************************************************

 IUnknown stuff.

 ***************************************************************************/

STDMETHODIMP GetFrameDef::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (riid == IID_IGetFrame ||
        riid == IID_IUnknown) {     //!!! should we do Unknown or pass on?

        *ppv = (LPVOID)this;
        AddRef();
        return ResultFromScode(S_OK);
    }
    else if (pavi) {
        return pavi->QueryInterface(riid, ppv);
    }
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) GetFrameDef::AddRef()
{
    return ulRefCount++;
}

STDMETHODIMP_(ULONG) GetFrameDef::Release()
{
    if (--ulRefCount == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/****************************************************************************
 ***************************************************************************/

GetFrameDef::GetFrameDef(IAVIStream FAR *pavi)
{
    this->pavi = pavi;

    ulRefCount = 1;

    fBegin = FALSE;
    fFmtChanges = FALSE;
    fDecompressEx = FALSE;

    lFrame = -4242;

    lpBuffer = NULL;
    lpFormat = NULL;
    cbBuffer = 0;
    cbFormat = 0;

    lpFrame = NULL;
    lpBits  = NULL;
    hic     = NULL;

    if (this->pavi == NULL)
        return;

    pavi->AddRef();
}

/****************************************************************************
 ***************************************************************************/

GetFrameDef::~GetFrameDef()
{
    FreeStuff();

    if (pavi)
        pavi->Release();
}

/****************************************************************************
 ***************************************************************************/

void GetFrameDef::FreeStuff()
{
    if (this->lpFrame && this->lpFrame != this->lpFormat) {
        GlobalFreePtr(this->lpFrame);
        this->lpFrame = 0;
    }

    if (this->lpFormat) {
        GlobalFreePtr(this->lpFormat);
        this->lpFormat = 0;
    }

    if (this->hic) {

        if (this->fDecompressEx)
            ICDecompressExEnd(this->hic);
        else
            ICDecompressEnd(this->hic);

        ICClose(this->hic);
        this->hic = 0;
    }
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP GetFrameDef::SetFormat(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy)
{
    LPBITMAPINFOHEADER	lpbiC;
    LPBITMAPINFOHEADER	lpbiU;
    DWORD		dw;
    DWORD		fccHandler;
    AVISTREAMINFO       info;
    BOOL                fScreen;

    //
    // lpbi == 1 means choose a format for the screen.
    //
    // !!!we need a flag or something to do this.
    //
    if (fScreen = (lpbi == (LPBITMAPINFOHEADER)1))
        lpbi = NULL;

    //
    // get the vital stats
    //
    _fmemset(&info, 0, sizeof(info));
    pavi->Info(&info, sizeof(info));

    //
    //  is this a video stream?
    //
    if (info.fccType != streamtypeVIDEO)
        return ERR_FAIL;

    this->fBegin = FALSE;
    this->fFmtChanges = (info.dwFlags & AVISF_VIDEO_PALCHANGES) != 0;

    this->dwEditCount = info.dwEditCount;
    this->dwFormatChangeCount = info.dwFormatChangeCount;

    //
    // get the stream format
    //
    if (this->lpFormat == NULL) {

        //
        // alocate a read buffer.
        //
        this->cbBuffer = (LONG)info.dwSuggestedBufferSize;

	if (this->cbBuffer == 0)
	    this->cbBuffer = 1024;

        AVIStreamFormatSize(this->pavi,
			    AVIStreamStart(this->pavi),
                            &this->cbFormat);

        this->lpFormat = GlobalAllocPtr(GHND,this->cbFormat + this->cbBuffer);

	if (this->lpFormat == NULL)
	    goto error;

	AVIStreamReadFormat(this->pavi, AVIStreamStart(this->pavi),
			    this->lpFormat, &this->cbFormat);

	this->lpBuffer = (LPBYTE)this->lpFormat+this->cbFormat;
    }

    lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;

    //
    // do standard BITMAPINFO header cleanup!
    //
    if (lpbiC->biClrUsed == 0 && lpbiC->biBitCount <= 8)
	lpbiC->biClrUsed = (1 << (int)lpbiC->biBitCount);

    if (lpbiC->biSizeImage == 0 && lpbiC->biCompression == BI_RGB)
	lpbiC->biSizeImage = DIBWIDTHBYTES(lpbiC) * lpbiC->biHeight;

    //
    // if the stream is uncompressed, we dont need a decompress buffer
    // make sure the caller hs not suggested a format first.
    //
    if (lpbiC->biCompression == 0 && lpBits == NULL) {

	if (lpbi == NULL ||
	   (lpbi->biCompression == lpbiC->biCompression &&
	    lpbi->biWidth	== lpbiC->biWidth &&
	    lpbi->biHeight	== lpbiC->biHeight &&
	    lpbi->biBitCount	== lpbi->biBitCount)) {


	    this->lpBits = (LPBYTE)lpbiC + (int)lpbiC->biSize +
		(int)lpbiC->biClrUsed * sizeof(RGBQUAD);

	    goto done;
	}
    }

    //
    // alocate the decompress buffer.
    //
    if (this->lpFrame == NULL) {

        this->lpFrame = GlobalAllocPtr(GHND,
            sizeof(BITMAPINFOHEADER)+256*sizeof(RGBQUAD));

        if (this->lpFrame == NULL) {
	    DPF("GetFrameInit: Can't allocate frame buffer!\n");
	    goto error;
        }
    }

    lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;
    lpbiU = (LPBITMAPINFOHEADER)this->lpFrame;

    if (this->hic == NULL) {

        if (lpbiC->biCompression == 0)
            fccHandler = mmioFOURCC('D','I','B',' ');
        else if (lpbiC->biCompression == BI_RLE8)
            fccHandler = mmioFOURCC('R','L','E',' ');
        else
            fccHandler = info.fccHandler;

        if (lpbi) {
            if (lpbi->biWidth == 0)
                lpbi->biWidth = lpbiC->biWidth;

            if (lpbi->biHeight == 0)
                lpbi->biHeight = lpbiC->biHeight;
        }

        this->hic = ICDecompressOpen(ICTYPE_VIDEO, /*info.fccType,*/
                                   fccHandler,lpbiC,lpbi);

        if (this->hic == NULL) {
	    DPF("GetFrameInit: Can't find decompressor!\n");
	    goto error;
        }
    }

    if (lpbi) {
        if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
            lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);
	
        hmemcpy(lpbiU,lpbi,lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD));

        if (lpbi->biBitCount <= 8) {
            ICDecompressGetPalette(this->hic,lpbiC,lpbiU);
        }
    } else if (fScreen) {

        ICGetDisplayFormat(this->hic, lpbiC, lpbiU, 0, dx, dy);

    } else {
        dw = ICDecompressGetFormat(this->hic,lpbiC,lpbiU);

	if ((LONG)dw < ICERR_OK)
	    goto error;
    }

    //
    // do standard BITMAPINFO header cleanup!
    //
    if (lpbiU->biClrUsed == 0 && lpbiU->biBitCount <= 8)
        lpbiU->biClrUsed = (1 << (int)lpbiU->biBitCount);

    if (lpbiU->biSizeImage == 0 && lpbiU->biCompression == BI_RGB)
        lpbiU->biSizeImage = DIBWIDTHBYTES(lpbiU) * lpbiU->biHeight;

    //
    // if we were passed a bits pointer, use it else re-alloc lpFrame
    // to contain the bits too.
    //
    if (lpBits) {
        this->lpBits = lpBits;
    }
    else {
        this->lpFrame = GlobalReAllocPtr(this->lpFrame,lpbiU->biSize +
            lpbiU->biSizeImage +
            lpbiU->biClrUsed * sizeof(RGBQUAD), GMEM_MOVEABLE);

        if (this->lpFrame == NULL) {
            DPF("GetFrameInit: Can't resize frame buffer!\n");
	    goto error;
        }

        lpbiU = (LPBITMAPINFOHEADER)this->lpFrame;

        this->lpBits = (LPBYTE)lpbiU + (int)lpbiU->biSize +
                (int)lpbiU->biClrUsed * sizeof(RGBQUAD);
    }

    //
    // use ICDecompressEx if we need to.  we need DecompressEx if
    // we are decompressing into a smaller area of the DIB, not the
    // whole surface.
    //
    if (dx == -1)
        dx = (int)lpbiU->biWidth;

    if (dy == -1)
        dy = (int)lpbiU->biHeight;

    this->fDecompressEx = (x != 0 || y != 0 ||
        dy != (int)lpbiU->biHeight || dx != (int)lpbiU->biWidth);

    if (this->fDecompressEx) {

        this->x = x;
        this->y = y;
        this->dx = dx;
        this->dy = dy;

        dw = ICDecompressExBegin(this->hic, 0,
            lpbiC, NULL, 0, 0, lpbiC->biWidth, lpbiC->biHeight,
            lpbiU, NULL, x, y, dx, dy);
    }
    else {
        dw = ICDecompressBegin(this->hic,lpbiC,lpbiU);
    }

    if (dw != ICERR_OK) {
        DPF("GetFrameSetFormat: ICDecompressBegin failed!\n");
	goto error;
    }

done:
    this->lFrame = -4224;   // bogus value
    return AVIERR_OK;

error:
    FreeStuff();
    return ERR_FAIL;
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP GetFrameDef::Begin(LONG lStart, LONG lEnd, LONG lRate)
{
    fBegin = TRUE;
    GetFrame(lStart);

    return AVIERR_OK;
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP GetFrameDef::End()
{
    fBegin = FALSE;
    return AVIERR_OK;
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP_(LPVOID) GetFrameDef::GetFrame(LONG lPos)
{
    LPBITMAPINFOHEADER	    lpbiC;
    LPBITMAPINFOHEADER	    lpbiU;
    LONG                    l;
    LONG                    lKey;
    LONG		    lBytes;
    LONG		    lSize;
    LONG		    lRead;
    LONG                    err;
    AVISTREAMINFO           info;
    HRESULT		    hr;

    if (!this->pavi) {
	DPF("AVIStreamGetFrame: bad pointer\n");
	return NULL;
    }

    if (this->lpFormat == NULL) {
        return NULL;
    }

    //
    // if we are not in a Begin/End pair check for the format changing etc.
    //
    if (!this->fBegin) {

        _fmemset(&info, 0, sizeof(info));
        this->pavi->Info(&info, sizeof(info));

        if (info.dwFormatChangeCount != dwFormatChangeCount) {

            DPF("AVIStreamGetFrame: format has changed\n");

            BITMAPINFOHEADER bi = *((LPBITMAPINFOHEADER)this->lpFrame);

            FreeStuff();    // nuke it all.

            if (SetFormat(&bi, NULL, 0, 0, -1, -1) != 0 &&
                SetFormat(NULL, NULL, 0, 0, -1, -1) != 0)

                return NULL;
        }

        if (info.dwEditCount != dwEditCount) {
            DPF("AVIStreamGetFrame: stream has been edited (%lu)\n", info.dwEditCount);
            dwEditCount = info.dwEditCount;
            this->lFrame = -4224;     // Invalidate the cached frame
        }
    }

    //
    // quick check for the last frame.
    //
    if (this->lFrame == lPos)
        return this->hic ? this->lpFrame : this->lpFormat;

    //
    // locate the nearest key frame.
    //
    lKey = AVIStreamFindSample(this->pavi, lPos, FIND_KEY|FIND_PREV);

    //
    // either lPos was out of range or some internal error!
    //
    if (lKey == -1) {
	DPF("AVIStreamGetFrame: Couldn't find key frame!\n");
	return NULL;
    }

    //
    // we need to go back to the specifed key frame
    // or our current frame witch ever is closer
    //
    if (this->lFrame < lPos && this->lFrame >= lKey)
        lKey = this->lFrame + 1;

    lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;
    lpbiU = (LPBITMAPINFOHEADER)this->lpFrame;

    //
    // decompress frame data from key frame to current frame.
    //
    for (l=lKey; l<=lPos; l++) {

        //
	// go read the format and call ICDecompressGetPalette() so
	// if the palette changes things will work.
	//
        if (this->fFmtChanges) {

            AVIStreamReadFormat(this->pavi, l, lpbiC, &this->cbFormat);
	
	    if (lpbiU && lpbiU->biBitCount <= 8) {
                ICDecompressGetPalette(this->hic,lpbiC,lpbiU);
	    }
	}

try_read_again:
        hr = AVIStreamRead(this->pavi, l, 1,
            this->lpBuffer, this->cbBuffer, &lBytes, &lRead);

        //
        // the read failed, mabey our buffer was too small
        // or it was a real error.
        //
        if (hr != NOERROR) {

            DPF("AVIStreamGetFrame: AVIStreamRead returns %lx\n", (DWORD) hr);

            lSize = 0;
            hr = AVIStreamSampleSize(this->pavi, l, &lSize);

            if (lSize > this->cbBuffer) {
                LPVOID lp;

                DPF("AVIStreamGetFrame: re-sizing read buffer from %ld to %ld\n", this->cbBuffer, lSize);

		lp = GlobalReAllocPtr(this->lpFormat,this->cbFormat+lSize,0);

                if (lp == NULL) {
                    DPF("AVIStreamGetFrame: Couldn't resize buffer\n");
                    return NULL;
                }

		this->lpFormat = lp;
		lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;
		this->lpBuffer = (LPBYTE)lp + this->cbFormat;
                this->cbBuffer = lSize;

                goto try_read_again;
            }
	}

	if (lRead != 1) {
	    DPF("AVIStreamGetFrame: AVIStreamRead failed!\n");
	    return NULL;
	}

	if (lBytes == 0)
	    continue;

	lpbiC->biSizeImage = lBytes;

	if (this->hic == NULL) {
	    this->lFrame = lPos;
	    return this->lpFormat;
	}
	else if (this->fDecompressEx) {
            err = ICDecompressEx(this->hic,0,
                lpbiC,this->lpBuffer,
                0,0,(int)lpbiC->biWidth,(int)lpbiC->biHeight,
                lpbiU,this->lpBits,
                this->x,this->y,this->dx,this->dy);
        }
        else {
            err = ICDecompress(this->hic,0,
                lpbiC,this->lpBuffer,lpbiU,this->lpBits);
        }

        // !!! Error check?

        if (err < 0)
            ;
    }

    this->lFrame = lPos;
    return this->hic ? this->lpFrame : this->lpFormat;
}

/********************************************************************
* @doc EXTERNAL AVIStreamGetFrameOpen
*
* @api PGETFRAME | AVIStreamGetFrameOpen | This functions prepares 
*      to decompress video frames from the stream specified.
*
* @parm PAVISTREAM | pavi | Specifies a pointer to the 
*       stream used as the video source.
*
* @parm LPBITMAPINFOHEADER | lpbiWanted | Specifies a pointer to 
*       a structure defining the desired  video format.  If this is NULL,
*       a default format is used.
*
* @rdesc Returns a GetFrame object, which can be used with
*	<f AVIStreamGetFrame>.
*
*	If the system can't find decompressor that can decompress the stream
*	to the format given, or to any RGB format, the function returns NULL.
*
* @comm The <p pavi> parameter must specify a video stream.
*
*	This is essentially just a helper function to handle a simple form
*	of decompression.
*
* @xref <f AVIStreamGetFrame> <f AVIStreamGetFrameClose>
**********************************************************************/
STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(PAVISTREAM pavi, LPBITMAPINFOHEADER lpbiWanted)
{
    PGETFRAME pgf=NULL;

    //
    // first ask the IAVIStream object if it can handle IGetFrame and
    // if it can let it do it.
    //
    pavi->QueryInterface(IID_IGetFrame, (LPVOID FAR *)&pgf);

    if (pgf == NULL) {
        //
        // the stream can't do it, make our own object.
        //
        pgf = new GetFrameDef(pavi);
    }

    //
    // set the format the caller wants
    //
    if (pgf->SetFormat(lpbiWanted, NULL, 0, 0, -1, -1)) {
        DPF("AVIStreamGetFrameOpen: unable to set format\n");
        pgf->Release();
        return NULL;
    }

    return pgf;
}

/********************************************************************
* @doc EXTERNAL AVIStreamGetFrameClose
*
* @api LONG | AVIStreamGetFrameClose | This function releases resources
*	used to decompress video frames.
*
* @parm PGETFRAME | pget | Specifies a handle returned from <f AVIStreamGetFrameOpen>.
*	After calling this function, the handle is invalid.
*
* @rdesc Returns an error code.
*
* @xref <f AVIStreamGetFrameOpen> <f AVIStreamGetFrame>
**********************************************************************/
STDAPI AVIStreamGetFrameClose(PGETFRAME pgf)
{
    if (pgf)
        pgf->Release();

    return AVIERR_OK;
}

/********************************************************************
* @doc EXTERNAL AVIStreamGetFrame
*
* @api LPVOID | AVIStreamGetFrame | This function returns a pointer to
*	a decompressed frame of video.
*
* @parm PGETFRAME | pgf | Specifies a pointer to a GetFrame object.
*
* @parm LONG | lPos | Specifies the position of desired frame in samples.
*
* @rdesc Returns NULL on error; otherwise it returns a far pointer 
*        to the frame data.  The returned data is a packed DIB.
*
* @comm The returned frame is valid only until the next call
*	to <f AVIStreamGetFrame> or <f AVIStreamGetFrameClose>.
*
* @xref <f AVIStreamGetFrameOpen>
**********************************************************************/
STDAPI_(LPVOID) AVIStreamGetFrame(PGETFRAME pgf, LONG lPos)
{
    if (pgf == NULL)
        return NULL;

    return pgf->GetFrame(lPos);
}

// !!! Do we need an AVIStreamGetFrameSetFormat?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\fileshar.c ===
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "debug.h"
#include "fileshar.h"

#define MAXTASKS    10

#ifdef WIN32
#define CurrentProcess()    ((HANDLE) GetCurrentProcess())
#else
#define CurrentProcess()    ((HANDLE) GetCurrentPDB())
#endif

typedef struct {
    char	szFile[256];
    DWORD	dwOpenFlags;
    MMIOINFO	mmioinfo;

    HANDLE	htask;
    HMMIO	hmmio;
    int		i;
    LONG	lOffset;
    
    HANDLE	ahtask[MAXTASKS];
    HMMIO	ahmmio[MAXTASKS];
    ULONG	ulRef[MAXTASKS];
} SHFILE, FAR * PSHFILE;


BOOL GetProperTask(PSHFILE psh)
{
    HANDLE	htask = CurrentProcess();
    int		i;

    if (htask == psh->htask)
	return (psh->hmmio != 0) && (psh->hmmio != (HMMIO) -1);

    for (i = 0; i < MAXTASKS; i++) {
	if (psh->ahtask[i] == htask) {
Success:
	    psh->hmmio = psh->ahmmio[i];
	    psh->htask = htask;
	    psh->i = i;
	    mmioSeek(psh->hmmio, psh->lOffset, SEEK_SET);
	    return (psh->hmmio != 0) && (psh->hmmio != (HMMIO) -1);
	}
    }

    for (i = 0; i < MAXTASKS; i++) {
	if (psh->ahtask[i] == 0) {
	    DPF("Re-opening handle %lx in task %x\n", psh, htask);
	    psh->ahmmio[i] = mmioOpen(psh->szFile, NULL, psh->dwOpenFlags);
	    psh->ahtask[i] = htask;
	    if (psh->ahmmio[i] == 0) {
		DPF("mmioOpen failed in GetProperTask!\n");
		return FALSE;
	    }

	    goto Success;
	}
    }

    DPF("File handle open in too many tasks!\n");

    return FALSE;
}


HSHFILE WINAPI shfileOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags)
{
    PSHFILE psh = (PSHFILE) GlobalAllocPtr(GHND | GMEM_SHARE, sizeof(SHFILE));

    if (!psh)
	return NULL;

    lstrcpy(psh->szFile, szFileName);
    psh->dwOpenFlags = dwOpenFlags;

    psh->hmmio = mmioOpen(szFileName, lpmmioinfo, dwOpenFlags);

    DPF("Opening handle %lx ('%s') in task %x, mode = %lx\n", psh, szFileName, CurrentProcess(), psh->dwOpenFlags);
    
    if (psh->hmmio == 0) {
	DPF("mmioOpen failed!\n");
	GlobalFreePtr(psh);
	return NULL;
    }

    psh->ahmmio[0] = psh->hmmio;
    psh->ahtask[0] = psh->htask = CurrentProcess();
    psh->ulRef[0] = 1; // !!! 0?

    return (HSHFILE) GlobalPtrHandle(psh);
}

UINT WINAPI shfileClose(HSHFILE hsh, UINT uFlags)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);
    int i;

    for (i = 0; i < MAXTASKS; i++) {
	if (psh->ahtask[i] && psh->ahmmio[i]) {
	    DPF("Handle %lx closed with ref count %ld in task %x\n", psh, psh->ulRef[i], psh->ahtask[i]);
    
	    mmioClose(psh->ahmmio[i], 0);
	}
    }
    GlobalFreePtr(psh);

    return 0;
}

LONG WINAPI shfileRead(HSHFILE hsh, HPSTR pch, LONG cch)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);

    if (!GetProperTask(psh))
	return -1;
    
    return mmioRead(psh->hmmio, pch, cch);
}

LONG WINAPI shfileWrite(HSHFILE hsh, const char _huge* pch, LONG cch)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);

    if (!GetProperTask(psh))
	return -1;

    return mmioWrite(psh->hmmio, pch, cch);
}

LONG WINAPI shfileSeek(HSHFILE hsh, LONG lOffset, int iOrigin)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);

    if (!GetProperTask(psh))
	return -1;

    psh->lOffset = mmioSeek(psh->hmmio, lOffset, iOrigin);

    return psh->lOffset;
}

LONG WINAPI shfileFlush(HSHFILE hsh, UINT uFlags)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);

    return 0;
}

LONG WINAPI shfileAddRef(HSHFILE hsh)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);

    if (!GetProperTask(psh))
	return -1;
    
    ++psh->ulRef[psh->i];

    // DPF("Handle %lx in task %x: ref++ == %ld\n", psh, psh->htask, psh->ulRef[psh->i]);
    return 0;
}

LONG WINAPI shfileRelease(HSHFILE hsh)
{
    PSHFILE psh = (PSHFILE) GlobalLock((HGLOBAL) hsh);

    if (!GetProperTask(psh))
	return -1;

    if (--psh->ulRef[psh->i] <= 0) {
	DPF("Closing handle %lx in task %x\n", psh, psh->htask);

	psh->ahmmio[psh->i] = 0;
	psh->ahtask[psh->i] = 0;
	psh->ulRef[psh->i] = 0;

	mmioClose(psh->hmmio, 0);
	psh->hmmio = 0;
	psh->htask = 0;
    } else {
	// DPF("Handle %lx in task %x: ref-- == %ld\n", psh, psh->htask, psh->ulRef[psh->i]);
    }


    return 0;
}

static	BYTE bPad;

MMRESULT WINAPI
shfileDescend(HSHFILE hshfile, LPMMCKINFO lpck, const LPMMCKINFO lpckParent, UINT wFlags)
{
	FOURCC		ckidFind;	// chunk ID to find (or NULL)
	FOURCC		fccTypeFind;	// form/list type to find (or NULL)

	/* figure out what chunk id and form/list type to search for */
	if (wFlags & MMIO_FINDCHUNK)
		ckidFind = lpck->ckid, fccTypeFind = NULL;
	else
	if (wFlags & MMIO_FINDRIFF)
		ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
	else
	if (wFlags & MMIO_FINDLIST)
		ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
	else
		ckidFind = fccTypeFind = NULL;
	
	lpck->dwFlags = 0L;

	while (TRUE)
	{
		UINT		w;

		/* read the chunk header */
		if (shfileRead(hshfile, (HPSTR) lpck, 2 * sizeof(DWORD)) !=
		    2 * sizeof(DWORD))
			return MMIOERR_CHUNKNOTFOUND;

		/* store the offset of the data part of the chunk */
		if ((lpck->dwDataOffset = shfileSeek(hshfile, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		
		/* check for unreasonable chunk size */
		/* see if the chunk is within the parent chunk (if given) */
		if ((lpckParent != NULL) && ((	lpck->dwDataOffset - 8L) >=
		     (lpckParent->dwDataOffset + lpckParent->cksize)))
			return MMIOERR_CHUNKNOTFOUND;

		/* if the chunk if a 'RIFF' or 'LIST' chunk, read the
		 * form type or list type
		 */
		if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{
			if (shfileRead(hshfile, (HPSTR) &lpck->fccType,
				     sizeof(DWORD)) != sizeof(DWORD))
				return MMIOERR_CHUNKNOTFOUND;
		}
		else
			lpck->fccType = NULL;

		/* if this is the chunk we're looking for, stop looking */
		if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		     ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
			break;
		
		/* ascend out of the chunk and try again */
		if ((w = shfileAscend(hshfile, lpck, 0)) != 0)
			return w;
	}

	return 0;
}

MMRESULT WINAPI
shfileAscend(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags)
{
	if (lpck->dwFlags & MMIO_DIRTY)
	{
		/* <lpck> refers to a chunk created by shfileCreateChunk();
		 * check that the chunk size that was written when
		 * shfileCreateChunk() was called is the real chunk size;
		 * if not, fix it
		 */
		LONG		lOffset;	// current offset in file
		LONG		lActualSize;	// actual size of chunk data

		if ((lOffset = shfileSeek(hshfile, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
			return MMIOERR_CANNOTWRITE;

		if (LOWORD(lActualSize) & 1)
		{
			/* chunk size is odd -- write a null pad byte */
			if (shfileWrite(hshfile, (HPSTR) &bPad, sizeof(bPad))
					!= sizeof(bPad))
				return MMIOERR_CANNOTWRITE;
			
		}

		if (lpck->cksize == (DWORD)lActualSize)
			return 0;

		/* fix the chunk header */
		lpck->cksize = lActualSize;
		if (shfileSeek(hshfile, lpck->dwDataOffset
				- sizeof(DWORD), SEEK_SET) == -1)
			return MMIOERR_CANNOTSEEK;
		if (shfileWrite(hshfile, (HPSTR) &lpck->cksize,
				sizeof(DWORD)) != sizeof(DWORD))
			return MMIOERR_CANNOTWRITE;
	}

	/* seek to the end of the chunk, past the null pad byte
	 * (which is only there if chunk size is odd)
	 */
	if (shfileSeek(hshfile, lpck->dwDataOffset + lpck->cksize
		+ (lpck->cksize & 1L), SEEK_SET) == -1)
		return MMIOERR_CANNOTSEEK;

	return 0;
}

MMRESULT WINAPI
shfileCreateChunk(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags)
{
	int		iBytes;			// bytes to write
	LONG		lOffset;	// current offset in file

	/* store the offset of the data part of the chunk */
	if ((lOffset = shfileSeek(hshfile, 0L, SEEK_CUR)) == -1)
		return MMIOERR_CANNOTSEEK;
	lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

	/* figure out if a form/list type needs to be written */
	if (wFlags & MMIO_CREATERIFF)
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
	else
	if (wFlags & MMIO_CREATELIST)
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	else
		iBytes = 2 * sizeof(DWORD);

	/* write the chunk header */
	if (shfileWrite(hshfile, (HPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
		return MMIOERR_CANNOTWRITE;

	lpck->dwFlags = MMIO_DIRTY;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\fakefile.cpp ===
/****************************************************************************
 *
 *  FAKEFILE.C
 *
 *  routines for simulating the IAVIFile interface from a bunch of streams 
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include "avifile.h"
#include "fakefile.h"
#include "debug.h"

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/*	-	-	-	-	-	-	-	-	*/

/**************************************************************************
* @doc EXTERNAL AVIMakeFileFromStreams
*
* @api HRESULT | AVIMakeFileFromStreams | Constructs an AVIFile interface
*	pointer out of separate streams. If <f AVIFileGetStream>
*	is called with the returned file interface pointer, it will 
*  return the specified
*	streams.
*
* @parm PAVIFILE FAR * | ppfile | Specifies a pointer to the location 
*       used to return the new file interface pointer.
*
* @parm int | nStreams | Specifies the number of streams in 
*       the array of stream interface pointers referenced by 
*       <p papStreams>.
*
* @parm PAVISTREAM FAR * | papStreams | Specifies a pointer to 
*       an array of stream interface pointers.
*
* @comm Use <f AVIFileRelease> to close the file. This function is 
*       useful for putting streams onto the Clipboard.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileClose> <f AVIFileGetStream>
*
*************************************************************************/
STDAPI AVIMakeFileFromStreams(PAVIFILE FAR *	ppfile,
			       int		nStreams,
			       PAVISTREAM FAR *	papStreams)
{
    CFakeFile FAR*	pAVIFile;

    pAVIFile = new FAR CFakeFile(nStreams, papStreams);
    if (!pAVIFile)
	return ResultFromScode(E_OUTOFMEMORY);

    *ppfile = (PAVIFILE) (LPVOID) pAVIFile;

    AVIFileAddRef(*ppfile);
    
    return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

CFakeFile::CFakeFile(int nStreams, PAVISTREAM FAR * papStreams)
{
    int     i;
    AVISTREAMINFO si;
    
    m_pUnknownOuter = this;
    m_refs = 0;

    _fmemset(&avihdr, 0, sizeof(avihdr));
    aps = 0;

    avihdr.dwStreams = nStreams;

    if (nStreams > 0) {
	aps = (PAVISTREAM NEAR *) LocalAlloc(LPTR, nStreams * sizeof(PAVISTREAM));


	// make sure none of the streams go away without our consent
	for (i = 0; i < nStreams; i++) {
	    aps[i] = papStreams[i];
	    AVIStreamAddRef(aps[i]);
	    // !!! should error check here, to make sure streams are valid
	    
	    aps[i]->Info(&si, sizeof(si));

	    if (i == 0) {
		avihdr.dwScale  = si.dwScale;
		avihdr.dwRate   = si.dwRate;
	    }
	    
	    avihdr.dwLength = max(avihdr.dwLength,
				  (DWORD) AVIStreamSampleToSample(aps[0],
								  aps[i],
								  si.dwLength));
	    avihdr.dwWidth  = max((DWORD) si.rcFrame.right, avihdr.dwWidth);
	    avihdr.dwHeight  = max((DWORD) si.rcFrame.bottom, avihdr.dwHeight);
	}
    }
}

STDMETHODIMP CFakeFile::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
    if (iid == IID_IUnknown)
	*ppv = this;
    else if (iid == IID_IAVIFile)
	*ppv = this;
    else
	return ResultFromScode(E_NOINTERFACE);
    
    AddRef();
    return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CFakeFile::AddRef()
{
    DPF("Fake   %lx: Usage++=%lx\n", (DWORD) (LPVOID) this, m_refs + 1);
    
    return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CFakeFile::Open(LPCSTR szFile, UINT mode)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::GetStream(PAVISTREAM FAR * ppavi,
				DWORD fccType,
				LONG lParam)
{
    HRESULT		    hr;
    int			    i;

    if (fccType == 0) {
	// just return nth stream
	if (lParam < (LONG) avihdr.dwStreams) {
	    *ppavi = aps[lParam];
	    AVIStreamAddRef(*ppavi);
	    return AVIERR_OK;
	} else {
	    *ppavi = NULL;
	    return ResultFromScode(AVIERR_UNSUPPORTED);
	}   
    }

    // otherwise loop through and find the one we want...
    for (i = 0; i < (int) avihdr.dwStreams; i++) {
	AVISTREAMINFO	strhdr;
	
	hr = AVIStreamInfo(aps[i], &strhdr, sizeof(strhdr));

	if (strhdr.fccType == fccType) {
	    if (lParam == 0) {
		*ppavi = aps[i];
		AVIStreamAddRef(*ppavi);
		return AVIERR_OK;
	    }

	    --lParam;
	}
    }

    // !!!
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Save(LPCSTR szFile,
				   AVICOMPRESSOPTIONS FAR *lpOptions,
				   AVISAVECALLBACK lpfnCallback)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::CreateStream(PAVISTREAM FAR *ppstream,
		       AVISTREAMINFO FAR *psi)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#if 0
STDMETHODIMP CFakeFile::AddStream(PAVISTREAM pstream,
		       PAVISTREAM FAR *ppstreamNew)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif

STDMETHODIMP CFakeFile::WriteData(DWORD ckid,
		       LPVOID lpData,
		       LONG cbData)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::ReadData(DWORD ckid,
		      LPVOID lpData,
		      LONG FAR *lpcbData)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::EndRecord(void)
{
    return ResultFromScode(AVIERR_OK);
}


STDMETHODIMP CFakeFile::Info(
		  AVIFILEINFO FAR * pfi,
		  LONG lSize)
{
    hmemcpy(pfi, &avihdr, min(lSize,sizeof(avihdr)));
//    return sizeof(avihdr);
    return 0;
}



STDMETHODIMP_(ULONG) CFakeFile::Release()
{
    int		i;

    DPF("Fake   %lx: Usage--=%lx\n", (DWORD) (LPVOID) this, m_refs - 1);
    
    if (!--m_refs) {
	LONG lRet = AVIERR_OK;

	if (aps) {
	    // Release our hold on the sub-streams
	    for (i = 0; i < (int) avihdr.dwStreams; i++) {
		AVIStreamClose(aps[i]);
	    }

	    LocalFree((HLOCAL) aps);
	}

	delete this;
	return 0;
    }
    return m_refs;
}


STDMETHODIMP CFakeFile::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\riffdisp.h ===
/****************************************************************************
 *
 *  MODULE  : RIFFDISP.H
 *
 ****************************************************************************/

#ifdef OFN_READONLY
    BOOL  FAR PASCAL GetOpenFileNamePreview(LPOPENFILENAME lpofn);
#endif

/****************************************************************************
 ****************************************************************************/

HANDLE FAR PASCAL GetRiffPicture(LPSTR szFile);
BOOL   FAR PASCAL GetRiffTitle(LPSTR szFile, LPSTR szTitle, int iLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\muldiv32.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

neg32       macro hi, lo
        neg lo
        adc hi,0                ; carry set unless lo zero
        neg hi
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; long muldiv32(long, long, long)
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; lResult = (lNumber * lNumerator) / lDenominator with correct rounding
;
; Entry:
;       lNumber = number to multiply by nNumerator
;       lNumerator = number to multiply by nNumber
;       lDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
;
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Fri 05-Oct-1990 -by- Rob Williams [Robwi] 
;   Behavior consistent with MulDiv16 routine (signed, no int 0 on overflow)
;   Stole muldiv16 psuedocode
;
;   Wed 14-June-1990 -by-  Todd Laney [ToddLa]
;   converted it to 386/286 code. (by checking __WinFlags)
;
;   Tue 08-May-1990 -by-  Rob Williams [Robwi]
;   Wrote it.
;
;----------------------------Pseudo-Code--------------------------------;
; long FAR PASCAL muldiv32(long, long, long)
; long l;
; long Numer;
; long Denom;
; {
;
;   Sign = sign of Denom;   // Sign will keep track of final sign //
;
;
;   if (Denom < 0)
;   {
;	negate Denom;	// make sure Denom is positive //
;   }
;
;   if (l < 0)
;   {
;	negate l;	// make sure l is positive //
;   }
;
;   make Sign reflect any sign change;
;
;
;   if (Numer < 0)
;   {
;	negate Numer;	// make sure Numer is positive //
;   }
;
;   make Sign reflect any sign change;
;
;   Numer *= l;
;   Numer += (Denom/2); // adjust for rounding //
;
;   if (overflow)   // check for overflow, and handle divide by zero //
;   {
;	jump to md5;
;   }
;
;   result = Numer/Denom;
;
;   if (overflow)   // check again to see if overflow occured //
;   {
;	jump to md5;
;   }
;
;   if (Sign is negative)   // put sign on the result //
;   {
;	negate result;
;   }
;
;md6:
;   return(result);
;
;md5:
;   DX = 7FFF;	    // indicate overflow by //
;   AX = 0xFFFF     // return largest integer //
;   if (Sign is negative)
;   {
;	DX = 0x8000;	// with correct sign //
;	AX = 0x0000;	
;   }
;
;   jump to md6;
; }
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      md32_1
        jmp     NEAR PTR muldiv32_286
md32_1:
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     md386_1
        neg     ebx

md386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     md386_2
        neg     eax

md386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     md386_3
        neg     edx

md386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get half of the demoninator to adjust for rounding
        sar     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        sal     ebx,1               ; restore the demoninator
        or      bx,cx               ; fix bottom bit
        cmp     edx,ebx             ; check for overflow
        jae     md386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      md386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     md386_6
        neg     eax

md386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

md386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     md386_6
        not     eax
        jmp     md386_6

        .286

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     md286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


md286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     md286_2
        neg32   dx, ax

md286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     md286_3
        neg32   cx, bx

md286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sar     si, 1                   ; get half of the demoninator 
        rcr     di, 1                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        sal     di, 1                   ; restore the demoninator
        rcl     si, 1

        or      di, lDenominator.lo     ; fix bottom bit

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      md286_5                 ; overflow
        jb      md286_7                 ; no overflow
        cmp     cx, di       
        jae     md286_5                 ; overflow

md286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      md286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     md286_6
        neg32   dx,ax

md286_6:

cEnd

md286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     md286_6
        not     dx
        not     ax
        jmp     md286_6

cProc   muldivru32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      mdru32_1
        jmp     NEAR PTR muldivru32_286
mdru32_1:
        errn$   muldivru32_386
cEnd    <nogen>

cProc   muldivru32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     mdru386_1
        neg     ebx

mdru386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     mdru386_2
        neg     eax

mdru386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     mdru386_3
        neg     edx

mdru386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get demoninator - 1 to adjust for rounding
        sub     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        add     ebx,1               ; restore the demoninator
        cmp     edx,ebx             ; check for overflow
        jae     mdru386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      mdru386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     mdru386_6
        neg     eax

mdru386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

mdru386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     mdru386_6
        not     eax
        jmp     mdru386_6

        .286

cProc   muldivru32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     mdru286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


mdru286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     mdru286_2
        neg32   dx, ax

mdru286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     mdru286_3
        neg32   cx, bx

mdru286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sub     di, 1                   ; get demoninator - 1 
        sbb     si, 0                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        add	di, 1                   ; restore the demoninator
        adc     si, 0

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      mdru286_5                 ; overflow
        jb      mdru286_7                 ; no overflow
        cmp     cx, di       
        jae     mdru286_5                 ; overflow

mdru286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      mdru286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     mdru286_6
        neg32   dx,ax

mdru286_6:

cEnd

mdru286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     mdru286_6
        not     dx
        not     ax
        jmp     mdru286_6

cProc   muldivrd32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      mdrd32_1
        jmp     NEAR PTR muldivrd32_286
mdrd32_1:
        errn$   muldivrd32_386
cEnd    <nogen>

cProc   muldivrd32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     mdrd386_1
        neg     ebx

mdrd386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     mdrd386_2
        neg     eax

mdrd386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     mdrd386_3
        neg     edx

mdrd386_3:
        mul     edx                 ; multiply

        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      mdrd386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     mdrd386_6
        neg     eax

mdrd386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

mdrd386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     mdrd386_6
        not     eax
        jmp     mdrd386_6

        .286

cProc   muldivrd32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     mdrd286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


mdrd286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     mdrd286_2
        neg32   dx, ax

mdrd286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     mdrd286_3
        neg32   cx, bx

mdrd286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      mdrd286_5                 ; overflow
        jb      mdrd286_7                 ; no overflow
        cmp     cx, di       
        jae     mdrd286_5                 ; overflow

mdrd286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      mdrd286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     mdrd286_6
        neg32   dx,ax

mdrd286_6:

cEnd

mdrd286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     mdrd286_6
        not     dx
        not     ax
        jmp     mdrd286_6


;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  -by-  Charles Whitmer [chuckwh]
; Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\unmarsh.h ===
/*	-	-	-	-	-	-	-	-	*/

class FAR CUnMarshal : IMarshal {
public:
    static HRESULT Create(IUnknown FAR* pUnknownOuter, const IID FAR& riid, void FAR* FAR* ppv);
    
private:
    CUnMarshal(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
    
public:
    STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
	    
    // *** IMarshal methods ***
    STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPCLSID pCid);
    STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPDWORD pSize);
    STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags);
    STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			LPVOID FAR* ppv);
    STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
    STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);

    IUnknown FAR*	m_pUnknownOuter;
    ULONG	m_refs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\memcopy.asm ===
; mem.asm:
;
; masm -Mx -Zi -DSEGNAME=????? asm.asm
;
	TITLE MEM.ASM

;****************************************************************
;* MEM.ASM - Assembly mem-copy routines				*
;*		for 80286 and 80386				*
;****************************************************************
;

?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention
PMODE=1

.xlist
include cmacros.inc
include windows.inc
.list

	externA	    __WinFlags	    ; in KERNEL
	externA	    __AHINCR	    ; in KERNEL
	externA	    __AHSHIFT	    ; in KERNEL

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG	struc
lo	dw	?
hi	dw	?
LONG	ends

FARPOINTER	struc
off	dw	?
sel	dw	?
FARPOINTER	ends

; -------------------------------------------------------
;		DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin Data
sEnd Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,DATA

;---------------------------Public-Routine------------------------------;
; hmemcpy
;
;   copy memory
;
; Entry:
;	lpSrc	HPSTR to copy from
;	lpDst	HPSTR to copy to
;	cbMem	DWORD count of bytes to move
;
;	NOTE: overlapped copies will work iff lpSrc.sel == lpDst.sel
;		[This is a lie.	 They will always work.]
;
; Returns:
;	destination pointer
; Error Returns:
;	None
; Registers Preserved:
;	BP,DS,SI,DI
; Registers Destroyed:
;	AX,BX,CX,DX,FLAGS
; Calls:
;	nothing
; History:
;
;	Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;	Tue 16-Oct-1990 16:41:00 -by-  David Maymudes [DavidMay]
;	Modified 286 case to work correctly with cbMem >= 64K.
;	Changed name to hmemcpy.
;	Changed 386 case to copy by longwords
;-----------------------------------------------------------------------;

cProc MemCopy,<FAR,PASCAL,PUBLIC,NODATA>,<>
;	 ParmD	 lpDst
;	 ParmD	 lpSrc
;	 ParmD	 cbMem
cBegin	<nogen>
        mov     ax,__WinFlags
        test    ax,WF_CPU286
        jz      fmemcpy386
	jmp	FAR PTR	fmemcpy286
cEnd <nogen>

cProc fmemcpy386,<FAR,PASCAL,PUBLIC,NODATA>,<ds>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	.386
	push	edi
	push	esi
	cld

	mov	ecx,cbMem
	jecxz	mc386_exit

	movzx	edi,di
	movzx	esi,si
	lds	si,lpSrc
	les	di,lpDst
;
; calculate differance of pointers in "selector" space
;
	mov	ax,si		; DX:AX = lpSrc
	mov	dx,ds

	mov	bx,es		; BX = selector of ptr B

	mov	cx,__AHSHIFT	; number of selector bits per 64K 'segment'
	shr	dx,cl		; linearize ptr A
	shr	bx,cl		; linearize ptr B
;
; DX and BX contain normalized selectors
;
        mov     ecx,cbMem

        sub     ax,di
        sbb     dx,bx              ; do long subtraction.
        jnc     mc_copy_forward

	add	ax,cx
	adc	dx,cbMem.hi
        jnc     mc_copy_forward    ; carry, so >0, thus they do hit.

	std
	add	edi,ecx
	add	esi,ecx

	sub	edi,4
	sub	esi,4

	push	ecx
	shr	ecx,2		; get count in DWORDs
	rep	movs dword ptr es:[edi], dword ptr ds:[esi]
	db	67H		; Fix strange 386 bug
	add	edi,3
	add	esi,3
	pop	ecx
	and	ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]
	db	67H		; Fix strange 386 bug
	jmp	mc386_exit

mc_copy_forward:
	push	ecx
	shr	ecx,2		; get count in DWORDs
	rep	movs dword ptr es:[edi], dword ptr ds:[esi]
	db	67H
	pop	ecx
	and	ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]
	db	67H
	nop
mc386_exit:
	cld
	pop	esi
	pop	edi
	mov	dx,lpDst.sel	; return destination address
	mov	ax,lpDst.off
	.286
cEnd

cProc fmemcpy286,<FAR,PASCAL,PUBLIC,NODATA>,<ds,si,di>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	mov	cx,cbMem.lo	; CX holds count
	or	cx,cbMem.hi	; or with high word
	jnz	@f
	jmp	empty_copy
@@:
	lds	si,lpSrc	  ; DS:SI = src
	les	di,lpDst	  ; ES:DI = dst
;
; calculate differance of pointers in "selector" space
;
	mov	ax,si		; DX:AX = lpSrc
	mov	dx,ds

	mov	bx,es		; BX = selector of ptr B

	mov	cx,__AHSHIFT	; number of selector bits per 64K 'segment'
	shr	dx,cl		; linearize ptr A
	shr	bx,cl		; linearize ptr B
;
; DX and BX contain normalized selectors
;
        mov     cx,cbMem.lo

	sub	ax,di
	sbb	dx,bx		; do long subtraction.
        jnc     forward_copy    ; difference is positive, so copy forward

; see if the blocks intersect: is source + count > dest?
; equivalently, is source-dest + count > 0 ?
;	sub	ax,cx
;	sbb	dx,0
;	jnc	next		; This looks wrong.  Recheck!

	add	ax,cx
	adc	dx,cbMem.hi
        jc      reverse_copy    ; carry, so >0, thus they do hit.

forward_copy:
	jmp	next
	
reverse_copy:
; first, we have to set ds:si and es:di to the _ends_ of the blocks

        sub     cx,1
	sbb	cbMem.hi,0	; subtract 2 from (long) count
	
	xor	ax,ax		
	add	si,cx
	adc	ax,cbMem.hi

	push	cx
	mov	cx,__AHSHIFT
	shl	ax,cl
	pop	cx
	mov	bx,ds
	add	ax,bx		; advance DS
	mov	ds,ax

	xor	ax,ax
	add	di,cx
	adc	ax,cbMem.hi

	push	cx
	mov	cx,__AHSHIFT
	shl	ax,cl
	pop	cx
	mov	bx,es
	add	ax,bx		; advance ES
	mov	es,ax

        add     cx,1
	adc	cbMem.hi,0	; restore count
;
;	DS:SI += Count
;	ES:DI += Count
;	While Count != 0 Do
;		Num = MIN(Count,SI+1,DI+1)
;		Reverse Copy "Num" Bytes from DS:SI to ES:DI
;			(SI -= Num, DI -= Num)
;		Count -= Num
;		If Count == 0 Then
;			BREAK
;		If SI == 0xFFFF Then
;			DS -= __AHINCR
;		If DI == 0xFFFF Then
;			ES -= __AHINCR
;
next_r:
	mov	ax,si
	sub	ax,di
	sbb	bx,bx
	and	ax,bx
	add	ax,di		; AX = MIN(SI, DI)
	
	test	cbMem.hi,-1	; is high word not zero?
	jnz	@f		; at least 64k to go

        dec     cx
	sub	ax,cx
	sbb	bx,bx
	and	ax,bx
        add     ax,cx
        inc     cx
@@:
	xor	bx,bx
        add     ax,1            ; AX = Num = MIN(Count-1,SI,DI)+1
	adc	bx,0		; bx==1 if exactly 64k

	xchg	ax,cx
	sub	ax,cx		; Count -= Num
	sbb	cbMem.hi,bx

	std
	shr	bx,1
        rcr     cx,1            ; if bx==1, then cx ends up 0x8000
        dec     si
        dec     di
	rep	movsw
        inc     si              ; realign pointers
	inc	di
        adc     cl,cl
        rep     movsb           ; move last byte, if necessary
	cld

	mov	cx,ax		; restore cx
	or	ax,cbMem.hi

	jz	done		; If Count == 0 Then BREAK

	cmp	si,-1		; if SI wraps, update DS
        jne     @f
	mov	ax,ds
	sub	ax,__AHINCR
	mov	ds,ax		; update DS if appropriate
@@:
	cmp	di,-1		; if DI wraps, update ES
        jne     next_r
	mov	ax,es
	sub	ax,__AHINCR
	mov	es,ax		; update ES if appropriate
	jmp	next_r

;
;	While Count != 0 Do
;		If (Count + SI > 65536) OR (Count + DI > 65536) Then
;			Num = Min(65536-SI, 65536-DI)
;		Else
;			Num = Count
;		Copy "Num" Bytes from DS:SI to ES:DI (SI += Num, DI += Num)
;		Count -= Num
;		If Count == 0 Then
;			BREAK
;		If SI == 0 Then
;			DS += __AHINCR
;		If DI == 0 Then
;			ES += __AHINCR
;
next:
;;;;;;;;mov     ax,cx
;;;;;;;;dec     ax

	mov	ax,di
	not	ax		; AX = 65535-DI

	mov	dx,si
	not	dx		; DX = 65535-SI

	sub	ax,dx
	sbb	bx,bx
	and	ax,bx
	add	ax,dx		; AX = MIN(AX,DX) = MIN(65535-SI,65535-DI)

	; problem: ax might have wrapped to zero

	test	cbMem.hi,-1
	jnz	plentytogo	; at least 64k still to copy
	
	dec	cx		; this is ok, since high word is zero
	sub	ax,cx
	sbb	bx,bx
	and	ax,bx
	add	ax,cx		; AX = MIN(AX,CX)
	inc	cx

plentytogo:
	xor	bx,bx
	add	ax,1		; AX = Num = MIN(count,65536-SI,65536-DI)
				; we must check the carry here!
	adc	bx,0		; BX could be 1 here, if CX==0 indicating
				; exactly 64k to copy
	xchg	ax,cx
	sub	ax,cx		; Count -= Num
	sbb	cbMem.hi,bx

	shr	bx,1
	rcr	cx,1		; if bx==1, then cx ends up 0x8000
	rep	movsw
        adc     cl,cl
        rep     movsb           ; move last byte, if necessary

	mov	cx,ax		; put low word of count back in cx
	or	ax,cbMem.hi

	jz	done		; If Count == 0 Then BREAK

	or	si,si		; if SI wraps, update DS
	jnz	@f
	mov	ax,ds
	add	ax,__AHINCR
	mov	ds,ax		; update DS if appropriate
@@:
	or	di,di		; if DI wraps, update ES
	jnz	next
	mov	ax,es
	add	ax,__AHINCR
	mov	es,ax		; update ES if appropriate
	jmp	next
;
; Restore registers and return
;
done:
empty_copy:
	mov	dx,lpDst.sel	; return destination address
	mov	ax,lpDst.off
cEnd

sEnd

sEnd CodeSeg
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\olepriv.h ===
//
// Major ugliness warning:
//
// These are definitions stolen from the 32-bit OLE headers and
// munged to have the word FAR in all of the right places.
//



interface IRpcProxyBuffer;
interface IRpcChannelBuffer;
interface IRpcStubBuffer;
interface IPSFactoryBuffer;

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//
//  Contents: Interface header file for IRpcProxyBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IRpcProxyBuffer__
#define __IRpcProxyBuffer__


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


EXTERN_C const IID IID_IRpcProxyBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IRpcProxyBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Connect
    (
	IRpcChannelBuffer FAR *pRpcChannelBuffer
    ) = 0;
    
    virtual void STDMETHODCALLTYPE Disconnect
    (
        void
    ) = 0;
    
};

#else 

/* C Language Binding */

typedef struct IRpcProxyBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IRpcProxyBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );
    
    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IRpcProxyBuffer FAR * This
    );
    
    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IRpcProxyBuffer FAR * This
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *Connect)
    (
        IRpcProxyBuffer FAR * This,
	IRpcChannelBuffer FAR *pRpcChannelBuffer
    );
    
    void (STDMETHODCALLTYPE FAR *Disconnect)
    (
        IRpcProxyBuffer FAR * This
    );
    
} IRpcProxyBufferVtbl;

interface IRpcProxyBuffer
{
    IRpcProxyBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IRpcProxyBuffer__*/


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//
//  Contents: Interface header file for IRpcChannelBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IRpcChannelBuffer__
#define __IRpcChannelBuffer__

/* Forward declaration */
// typedef interface IRpcChannelBuffer IRpcChannelBuffer;


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


typedef unsigned long RPCOLEDATAREP;

typedef enum tagRPCFLG
#if 0
  {
	RPCFLG_ASYNCHRONOUS = 1073741824,
	RPCFLG_INPUT_SYNCHRONOUS = 536870912
  }
#endif
RPCFLG;


typedef struct tagRPCOLEMESSAGE
  {
  void FAR *reserved1;
  RPCOLEDATAREP dataRepresentation;
  void FAR *Buffer;
  ULONG cbBuffer;
  ULONG iMethod;
  void FAR *reserved2[5];
  ULONG rpcFlags;
  }
RPCOLEMESSAGE;


typedef RPCOLEMESSAGE FAR *PRPCOLEMESSAGE;


EXTERN_C const IID IID_IRpcChannelBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IRpcChannelBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetBuffer
    (
	RPCOLEMESSAGE FAR *pMessage,
	REFIID riid
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SendReceive
    (
	RPCOLEMESSAGE FAR *pMessage,
	ULONG FAR *pStatus
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE FreeBuffer
    (
	RPCOLEMESSAGE FAR *pMessage
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetDestCtx
    (
	DWORD FAR *pdwDestContext,
	void FAR * FAR *ppvDestContext
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsConnected
    (
        void
    ) = 0;
    
};

#else 

/* C Language Binding */

typedef struct IRpcChannelBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IRpcChannelBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );
    
    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IRpcChannelBuffer FAR * This
    );
    
    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IRpcChannelBuffer FAR * This
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *GetBuffer)
    (
        IRpcChannelBuffer FAR * This,
	RPCOLEMESSAGE FAR *pMessage,
	REFIID riid
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *SendReceive)
    (
        IRpcChannelBuffer FAR * This,
	RPCOLEMESSAGE FAR *pMessage,
	ULONG FAR *pStatus
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *FreeBuffer)
    (
        IRpcChannelBuffer FAR * This,
	RPCOLEMESSAGE FAR *pMessage
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *GetDestCtx)
    (
        IRpcChannelBuffer FAR * This,
	DWORD FAR *pdwDestContext,
	void FAR * FAR *ppvDestContext
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *IsConnected)
    (
        IRpcChannelBuffer FAR * This
    );
    
} IRpcChannelBufferVtbl;

interface IRpcChannelBuffer
{
    IRpcChannelBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IRpcChannelBuffer__*/


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//
//  Contents: Interface header file for IRpcStubBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IRpcStubBuffer__
#define __IRpcStubBuffer__

/* Forward declaration */
// typedef interface IRpcStubBuffer IRpcStubBuffer;


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


EXTERN_C const IID IID_IRpcStubBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IRpcStubBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Connect
    (
	IUnknown FAR *pUnkServer
    ) = 0;
    
    virtual void STDMETHODCALLTYPE Disconnect
    (
        void
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Invoke
    (
	RPCOLEMESSAGE FAR *_prpcmsg,
	IRpcChannelBuffer FAR *_pRpcChannelBuffer
    ) = 0;
    
    virtual IRpcStubBuffer  FAR *STDMETHODCALLTYPE IsIIDSupported
    (
	REFIID riid
    ) = 0;
    
    virtual ULONG STDMETHODCALLTYPE CountRefs
    (
        void
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DebugServerQueryInterface
    (
	void FAR * FAR *ppv
    ) = 0;
    
    virtual void STDMETHODCALLTYPE DebugServerRelease
    (
	void FAR *pv
    ) = 0;
    
};

#else 

/* C Language Binding */

typedef struct IRpcStubBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IRpcStubBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );
    
    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IRpcStubBuffer FAR * This
    );
    
    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IRpcStubBuffer FAR * This
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *Connect)
    (
        IRpcStubBuffer FAR * This,
	IUnknown FAR *pUnkServer
    );
    
    void (STDMETHODCALLTYPE FAR *Disconnect)
    (
        IRpcStubBuffer FAR * This
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *Invoke)
    (
        IRpcStubBuffer FAR * This,
	RPCOLEMESSAGE FAR *_prpcmsg,
	IRpcChannelBuffer FAR *_pRpcChannelBuffer
    );
    
    IRpcStubBuffer  FAR *(STDMETHODCALLTYPE FAR *IsIIDSupported)
    (
        IRpcStubBuffer FAR * This,
	REFIID riid
    );
    
    ULONG (STDMETHODCALLTYPE FAR *CountRefs)
    (
        IRpcStubBuffer FAR * This
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *DebugServerQueryInterface)
    (
        IRpcStubBuffer FAR * This,
	void FAR * FAR *ppv
    );
    
    void (STDMETHODCALLTYPE FAR *DebugServerRelease)
    (
        IRpcStubBuffer FAR * This,
	void FAR *pv
    );
    
} IRpcStubBufferVtbl;

interface IRpcStubBuffer
{
    IRpcStubBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IRpcStubBuffer__*/


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//
//  Contents: Interface header file for IPSFactoryBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IPSFactoryBuffer__
#define __IPSFactoryBuffer__

/* Forward declaration */
// typedef interface IPSFactoryBuffer IPSFactoryBuffer;


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


EXTERN_C const IID IID_IPSFactoryBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IPSFactoryBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE CreateProxy
    (
	IUnknown FAR *pUnkOuter,
	REFIID riid,
	IRpcProxyBuffer FAR * FAR *ppProxy,
	void FAR * FAR *ppv
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CreateStub
    (
	REFIID riid,
	IUnknown FAR *pUnkServer,
	IRpcStubBuffer FAR * FAR *ppStub
    ) = 0;
    
};

#else 

/* C Language Binding */

typedef struct IPSFactoryBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IPSFactoryBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );
    
    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IPSFactoryBuffer FAR * This
    );
    
    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IPSFactoryBuffer FAR * This
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *CreateProxy)
    (
        IPSFactoryBuffer FAR * This,
	IUnknown FAR *pUnkOuter,
	REFIID riid,
	IRpcProxyBuffer FAR * FAR *ppProxy,
	void FAR * FAR *ppv
    );
    
    HRESULT (STDMETHODCALLTYPE FAR *CreateStub)
    (
        IPSFactoryBuffer FAR * This,
	REFIID riid,
	IUnknown FAR *pUnkServer,
	IRpcStubBuffer FAR * FAR *ppStub
    );
    
} IPSFactoryBufferVtbl;

interface IPSFactoryBuffer
{
    IPSFactoryBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IPSFactoryBuffer__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\ole2stub.asm ===
page    ,132
        title   OLE2STUB.ASM
;***********************************************************************
;*								       *
;*  MODULE      : OLE2STUB.ASM                                          *
;*								       *
;*  DESCRIPTION : Provide functions to allow run-time linking to       *
;*							   the ACM.    *
;*								       *
;*  COPYRIGHT   : Copyright 1991, Microsoft Corp.  All Rights Reserved.*
;*								       *
;*	Author: David Maymudes					       *
;*	Based on similar code for MMSYSTEM by: 			       *
;*               Todd Laney and Matt Saettler - Multimedia Systems     *
;*								       *
;***********************************************************************

;-----------------------------------------------------------------------
;
; Documentation (such as it is)
;
;------------------------------------------------------------------------
;
; Call function as you normally would.  Include OLE2.H normally.
; However, instead of linking to OLE2.LIB, link to OLE2STUB.OBJ
;
; All functions will return error conditions if OLE2.DLL is not present.
;
; Because I'm lazy, the calling routine has to load the module into
; memory before calling any of this.
;------------------------------------------------------------------------

page

        .286
	?PLM=1	    ; PASCAL Calling convention is DEFAULT
        ?WIN=0      ; Windows calling convention

        .xlist
	include cmacros.inc
	.list

;*********************************************************************
;               CONSTANT DECLARATIONS
;*********************************************************************

ifndef FALSE
FALSE	 	equ	0
endif
ifndef NULL
NULL	 	equ	0
endif
ifndef MMSYSERR_ERROR
MMSYSERR_ERROR 	equ	1
endif

;*********************************************************************
;               EXTERN DECLARATIONS
;*********************************************************************

	externFP   OutputDebugString
	externFP   _wsprintf
	externFP   GetProcAddress
        externFP   GetModuleHandle

;ifdef DEBUG
;        externFP    __dprintf               ; in DPRINTF.C
;endif

;*********************************************************************
;               STRUCTURE DECLARATIONS
;*********************************************************************

LONG    struc
	lo      dw      ?
	hi      dw      ?
LONG    ends

FARPOINTER      struc
	off     dw      ?
	sel     dw      ?
FARPOINTER      ends

PROCENTRY	struc
	curproc		dd	?	; see parameters to macros, below
        ordinal         dw      ?
	numparms	dw	?
        errret          dd      ?

ifdef DEBUG
	szProc		db	?
endif
PROCENTRY	ends

MODENTRY	struc
	hModule		dw	?
	szModule	db	?
MODENTRY	ends

;*********************************************************************
;               DATA SEGMENT DECLARATIONS
;*********************************************************************

ifndef SEGNAME
        SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

page

;*********************************************************************
;                  MACRO DECLARATIONS
;*********************************************************************

;
;------------------------------------------------------------------------------
;
; MACRO DOUT
;
; Parms:
;
;  text		Text to output using OutputDebugString when DEBUG is defined
;		Text is automatically appended with CR/LF
;

DOUT macro text
        local   string_buffer

ifdef DEBUG		; only do output if DEBUG is defined

_DATA segment
string_buffer label byte
        db      "&text&",13,10,0
_DATA ends
        pusha
        push    DataBASE
        push    DataOFFSET string_buffer
        call    OutputDebugString
        popa
endif
        endm

;
;------------------------------------------------------------------------------
;
; MACRO Begin_Module_Table
;
; Parms:
;
; Module_Name 	Name of Module to Run-Time-Link
;
; defines <Module_Name>_Proc Macro
;
; Use End_Module_Table to close

Begin_Module_Table MACRO Module_Name

sBegin DATA

ifdef DEBUG
	public Module_Name&_Module_Table
endif

Module_Name&_Module_Table label word
	dw	-1		; hModule
	db	"&Module_Name&",0

sEnd Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

ifdef DEBUG			; make public so debugger is aware of it
        public load&Module_Name
endif

;
; entry:
;	DS:BX	--> ProcEntry for API being called
;
load&Module_Name& proc far
	; stack frame is not modified or copied
	; vars are still in place

	mov	ax,DataOFFSET Module_Name&_Module_Table
        jmp     LoadModuleStub

load&Module_Name& endp

sEnd CodeSeg

page

;
;------------------------------------------------------------------------------
;
; MACRO <Module_Name>_Proc
;
; Parms:
;
; Name of procedure	Name of procedure to emulate
; ordinal of exported proc
; # of stack parms	use 0 for CDECL routines
; error return value	default error value for use by FailAPIStub
; fail proc		defaults to FailAPIStub if not specified
;			use custom 'fail' proc to replace functionlity
;			if specified module/proc not found in system
;
Module_Name&_Proc macro ProcName, Ordinal, sizestack, errret, failproc

sBegin Data

ifdef DEBUG
        public Module_Name&&Ordinal&
endif

Module_Name&&Ordinal& label word
ifb     <failproc>
        dd      load&Module_Name
        dw      &Ordinal
        dw      &sizestack
        dd      &errret
else
        dd      load&Module_Name
        dw      &Ordinal
        dw      -1
        dd      &failproc
endif

ifdef DEBUG
	db	"&ProcName&",0
endif

sEnd    Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

public &ProcName&

&ProcName& proc far
	; stack frame is not modified or copied
	; vars are still in place

        mov     bx,DataOFFSET Module_Name&&Ordinal&
        jmp     [bx].curproc                            ; current proc

&ProcName& endp
	
sEnd    CodeSeg

        endm
        endm

page
;------------------------------------------------------------------------------
;
; MACRO End_Module_Table
;
; Parms
; Module_Name	Must be the same as in Begin_Module_Table
;

End_Module_Table macro Module_Name

        purge   Module_Name&_Proc

        endm


;-----------------------------------------------------------------------------
;
;  Helper routines for SHELL
;
;-----------------------------------------------------------------------------
sBegin CodeSeg
        assumes cs,CodeSeg
	assumes ds,Data
	assumes es,nothing

;-----------------------------------------------------------------------------
;
; FailApiStub
;
;  Default handler if Module or Proc Address is not found.
;
;  returns default error code
;
;  entry:
;	DS:BX	--> PROCENTRY
;

FailApiStub proc far

	pop	dx		        ; get return addr
	pop	ax

	add	sp,[bx].numparms	; remove params from stack

	push	ax			; restore return addr
	push	dx
	mov	ax,[bx].errret.lo	; return fail code
	mov	dx,[bx].errret.hi
        retf

FailApiStub endp

;-----------------------------------------------------------------------------
;
; LoadModuleStub
;
;  Initial handler for all procs.  Attempts to load module (if not already
;  loaded) and then gets proc address.  If any errors, sets curproc to
;  failproc for 'unavailable' processing.
;
;  If successful, then sets curproc to imported function and calls it.
;
; entry:
;	DS:BX --> PROCENTRY
;	DS:AX --> MODENTRY
;
; NOTE:  Assumes module is already loaded
;
;     To be totally general:
;       if can't GetModuleHandle(),
;	needs to do a OpenFile(OF_EXIST,...) + LoadLibrary()
;	needs to FreeLibrary() all DLLs at end/exit
;
LoadModuleStub proc far

ifdef DEBUG
	pusha
	sub	sp,128
	mov	si,sp

	mov	di,ax			; DS:DI --> MODENTRY
	
        push    [bx].ordinal            ; %d

	lea	ax,[bx].szProc		; %ls
	push	ds
	push	ax

	lea	ax,[di].szModule	; %ls
	push	ds
        push    ax

        lea     ax,format_string        ; format string
	push	cs
        push    ax

        push    ss                      ; buffer
	push	si
	call	_wsprintf
        add     sp,9*2                  ; clear 9 words

        cCall   OutputDebugString,<ss,si>

	add	sp,128
	popa
        jmp     short @f
format_string:
        db      "Linking %ls!%ls@%d",13,10,0
@@:
endif
	pusha
	
	mov	si,ax			; ds:[si] --> MODENTRY
	mov	di,bx			; ds:[di] --> PROCENTRY

	mov	ax,[si].hModule		
	or	ax,ax
	jz	LoadModuleStubFail	; module does not exist

	cmp	ax,-1
	jne	LoadModuleStubGetProc	

	lea	ax,[si].szModule
	cCall	GetModuleHandle, <ds,ax>
	mov	[si].hModule,ax
	or	ax,ax
	jz	LoadModuleStubLoad

LoadModuleStubGetProc:
        cCall   GetProcAddress,<ax,0,[di].ordinal>
	or	dx,dx
	jz	LoadModuleStubFail

LoadModuleStubDone:
	mov	[di].curproc.lo,ax
	mov	[di].curproc.hi,dx

	popa
	jmp	[bx].curproc

LoadModuleStubLoad:
	
	;; call load library here after verifying with OpenFile()
	;

	; for now, fall through to error

LoadModuleStubFail:
        DOUT    <*** API not found! ***>

        mov     ax,CodeSegOFFSET FailApiStub
        mov     dx,cs

        cmp     [di].numparms,-1            ; do we have a fail proc?
        jne     LoadModuleStubDone          ; no...use FailApiStub

        mov     ax,[di].errret.lo           ; yes..it is stored in errret
        mov     dx,[di].errret.hi
        jmp     short LoadModuleStubDone    ; use it
	
LoadModuleStub endp

sEnd CodeSeg

page
;*********************************************************************
;                    CODE and DATA
;*********************************************************************


;
; Define OLE2 Run-Time-Load Table

Begin_Module_Table OLE2

OLE2_Proc OleInitialize           2,	4,	8000ffffh
OLE2_Proc OleUninitialize         3,	0,	8000ffffh
OLE2_Proc ReleaseStgMedium        32,	4,	8000ffffh
OLE2_Proc OleSetClipboard         49,	4,	8000ffffh
OLE2_Proc OleGetClipboard         50,	4,	8000ffffh
OLE2_Proc OleFlushClipboard       76,	0,	8000ffffh

;
; end the OLE2 R-T-L table

End_Module_Table OLE2

;*********************************************************************
;                    STUB ROUTINES
;*********************************************************************

; no stub routines for OLE2.


;*********************************************************************
;                    'C' RUNTIME HACK
;*********************************************************************

if 0 ;--- dont want this for nt

sBegin Code
        assumes cs,Code
        assumes ds,nothing
        assumes es,nothing

        externFP    GlobalAlloc
        externFP    GlobalLock
        externFP    GlobalFree

.386

;
; stutpid hack to get GetDGOUP to work!!!
;
public ___ExportedStub
___ExportedStub:
        mov     ax,DataBASE



%out ***************** WHY IS THE C RUNTIME BROKEN???


GMEM_MOVEABLE equ  0002h

public __fmalloc

__fmalloc proc far

        pop     eax
        pop     bx
        push    bx
        push    eax

GMEM_SHARE    equ  2000h
GMEM_MOVEABLE equ  0002h

        cCall   GlobalAlloc, <GMEM_MOVEABLE+GMEM_SHARE, 0, bx>
        cCall   GlobalLock, <ax>

        retf

__fmalloc endp

public __ffree

__ffree proc far

        pop     eax     ; return addr
        pop     ebx     ; sel:off
        push    ebx
        push    eax

        shr     ebx,16
        cCall   GlobalFree, <bx>
        retf

__ffree endp

sEnd

endif

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\unmarsh.cpp ===
/****************************************************************************
 *
 *  UNMARSH.CPP
 *
 *  unmarshalling stub
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <storage.h>
#include <avifmt.h>
#include "avifile.h"
#include "avifilei.h"
#include "unmarsh.h"
#include "debug.h"


HRESULT CUnMarshal::Create(
	IUnknown FAR*	pUnknownOuter,
	const IID FAR&	riid,
	void FAR* FAR*	ppv)
{
	IUnknown FAR*	pUnknown;
	CUnMarshal FAR*	pUnMarshal;
	HRESULT	hresult;

	DPF("Creating Simple UnMarshal Instance....\n");
	pUnMarshal = new FAR CUnMarshal(pUnknownOuter, &pUnknown);
	if (!pUnMarshal)
		return ResultFromScode(E_OUTOFMEMORY);
	hresult = pUnknown->QueryInterface(riid, ppv);
	if (FAILED(GetScode(hresult)))
		delete pUnMarshal;
	return hresult;
}

CUnMarshal::CUnMarshal(
	IUnknown FAR*	pUnknownOuter,
	IUnknown FAR* FAR*	ppUnknown)
{
	if (pUnknownOuter)
		m_pUnknownOuter = pUnknownOuter;
	else
		m_pUnknownOuter = this;
	*ppUnknown = this;
}

STDMETHODIMP CUnMarshal::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	if (iid == IID_IUnknown)
	    *ppv = this;
	else if (iid == IID_IMarshal) {
	    *ppv = this;
	} else
		return ResultFromScode(E_NOINTERFACE);
	AddRef();
	return NULL;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CUnMarshal::AddRef()
{
	uUseCount++;
	return ++m_refs;
}



STDMETHODIMP_(ULONG) CUnMarshal::Release()
{
    uUseCount--;
    if (!--m_refs) {

	delete this;
	return 0;
    }
    return m_refs;
}


// *** IMarshal methods ***
STDMETHODIMP CUnMarshal::GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPCLSID pCid)
{
    HRESULT hr = NOERROR;

    return hr;
}

STDMETHODIMP CUnMarshal::GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPDWORD pSize)
{
    HRESULT hr = NOERROR;

    return hr;
}

STDMETHODIMP CUnMarshal::MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
		    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags)
{
    HRESULT hr = NOERROR;

    return hr;
}

STDMETHODIMP CUnMarshal::UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
		    LPVOID FAR* ppv)
{
    HRESULT hr;
    IUnknown FAR * punk;

    hr = pStm->Read(&punk,sizeof(punk),NULL);
    
    DPF("Unmarshalling %08lx\n", (DWORD) (LPVOID) punk);
    
    if (hr == NOERROR) {
	hr = punk->QueryInterface(riid, ppv);

	if (hr == NOERROR)
	    punk->Release();
    }

    return hr;
}

STDMETHODIMP CUnMarshal::ReleaseMarshalData (THIS_ LPSTREAM pStm)
{
    HRESULT hr = NOERROR;

    return hr;
}

STDMETHODIMP CUnMarshal::DisconnectObject (THIS_ DWORD dwReserved)
{
    HRESULT hr = NOERROR;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\rlea.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  RLEA.ASM - helper routines for RLE stuff
;
; Created: Thu 27-Jun-1991
; Author:  Todd Laney [ToddLa]
;
; Copyright (c) 1991 Microsoft Corporation
;
; Exported Functions:   none
;
; Public Functions:     DecodeRle386
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
; History:
;       Thu 15-Aug-1991 13:45:58 -by-  Todd Laney [ToddLa]
;       Created.
;
;-----------------------------------------------------------------------;

	.xlist
	include cmacros.inc
        include windows.inc
        .list

RLE_ESCAPE  equ 0
RLE_EOL     equ 0
RLE_EOF     equ 1
RLE_JMP     equ 2

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG	struc
lo	dw	?
hi	dw	?
LONG	ends

FARPOINTER	struc
off	dw	?
sel	dw	?
FARPOINTER      ends

wptr    equ     <word ptr>
bptr    equ     <byte ptr>

min_ax  macro   REG
        sub     ax,REG
	cwd
	and	ax,dx
        add     ax,REG
	endm

max_ax  macro   REG
        sub     ax,REG
	cwd
	not	dx
        and     ax,dx
        add     ax,REG
	endm

; -------------------------------------------------------
;		DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

sBegin  Data

sEnd  Data

; -------------------------------------------------------
;               CODE SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Macro---------------------------------------;
; NOP32 - 32 bit NOP
;
;   put after all string instructions that use esi or edi to fix a wierd
;   386 stepping bug
;
;-----------------------------------------------------------------------;
NOP32   macro
        db      67h
        nop
        endm

;---------------------------Macro---------------------------------------;
; ReadRLE
;
;   read a WORD from rle data
;
; Entry:
;	DS:ESI --> rle data
; Returns:
;	AX - word at DS:[ESI]
;	DS:ESI advanced
; History:
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
ReadRLE macro
if 0    ; lets work on the wierd 386 step
        lods    wptr ds:[esi]
else
        mov     ax, wptr ds:[esi]
        add     esi,2
endif
        endm

;---------------------------Public-Routine------------------------------;
; DecodeRle386
;
;   copy a rle bitmap to a DIB
;
; Entry:
;       pBits       - pointer to rle bits
; Returns:
;       none
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   DecodeRle386, <NEAR, PASCAL, PUBLIC>, <ds>
	ParmD	lpbi
	ParmD	pDest
	ParmD	pBits
cBegin
.386
	push	edi
	push	esi

        xor     edi,edi
        xor     esi,esi
        xor     eax,eax
        xor     ecx,ecx

	lds	si,lpbi

	mov	ax,wptr [si].biWidth
	add	ax,3
	and	ax,not 3
	movzx	ebx,ax		    ; ebx is next_scan

	les	di,pDest
        lds     si,pBits
        assumes ds,nothing

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; Start of RLE decoding
;
;   DS:SI   --> RLE bits
;   ES:DI   --> screen output (points to start of scan)
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
	align	4
RleBltStart:
        mov     edx,edi             ; save start of scan

	align	4
RleBltAlign:
        inc     esi                 ; !!! re-align source
        and     si,not 1

	align	4
RleBltNext:
        ReadRLE                     ; al=count ah=color

        or      al,al               ; is it a escape?
	jz	short RleBltEscape

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a encoded run (al != 0)
;
;   al - run length
;   ah - run color
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
RleBltEncodedRun:
        mov     cl,al
	mov	al,ah

	shr	cx,1
        rep     stos wptr es:[edi]
        NOP32
	jnc	short RleBltNext

        stos    bptr es:[edi]
        NOP32

        jmp     short RleBltNext

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a RLE escape code (al=0)
; Possibilities are:
;       . End of Line            -  ah = 0
;       . End of RLE             -  ah = 1
;       . Delta                  -  ah = 2
;       . Unencoded run          -  ah = 3 or more
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
	align	4
RleBltEscape:
        cmp     ah,al
	je	short RleBltEOL

        inc     al
        cmp     ah,al
	je	short RleBltEOF

        inc     al
        cmp     ah,al
	je	short RleBltDelta
        errn$   RleBltUnencodedRun

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a un-encoded run (ah >= 3)
;
;   ah          is pixel count
;   DS:SI   --> pixels
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
RleBltUnencodedRun:
	mov	cl,ah

	shr	cx,1
        rep     movs wptr es:[edi], wptr ds:[esi]
        NOP32
        jnc     short RleBltAlign

	movs	bptr es:[edi], bptr ds:[esi]
        NOP32
	jmp	short RleBltAlign

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a delta jump, the next two bytes contain the jump values
; note the the jump values are unsigned bytes, x first then y
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
	align	4
RleBltDelta:
        ReadRLE                     ; al = deltaX, ah = deltaY

        or      ah,ah
        jnz     RleBltDeltaXY

RleBltDeltaX:
	add	edi,eax
        jmp     short RleBltNext

	align	4
RleBltDeltaXY:
        add     edi,ebx
        add     edx,ebx
        dec     ah
        jnz     RleBltDeltaXY

	add	edi,eax
        jmp     short RleBltNext

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a end of line marker, point ES:DI to the begining of the
; next scan
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
RleBltEOL:
        mov     edi,edx             ; go back to start of scan
        add     edi,ebx             ; advance to next scan
        jmp     short RleBltStart   ; go get some more

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a end of rle marker, clean up and exit.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
RleBltEOF:
        errn$   RleBltExit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
RleBltExit:
	pop	esi
        pop     edi
.286
cEnd

;---------------------------Macro---------------------------------------;
; ReadRle286
;
;   read a WORD from rle data
;
; Entry:
;       DS:SI --> rle data
; Returns:
;       AX - word at DS:[SI]
;       DS:SI advanced
; History:
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
ReadRle286 macro
        lods    wptr ds:[si]
        endm

;---------------------------Public-Routine------------------------------;
; DecodeRle286
;
;   copy a rle bitmap to a DIB
;
; Entry:
;       pBits       - pointer to rle bits
; Returns:
;       none
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   DecodeRle286, <NEAR, PASCAL, PUBLIC>, <ds>
	ParmD	lpbi
	ParmD	pDest
	ParmD	pBits
cBegin
	push	di
	push	si

        xor     di,di
        xor     si,si
        xor     ax,ax
        xor     cx,cx

	lds	si,lpbi

	mov	ax,wptr [si].biWidth
	add	ax,3
	and	ax,not 3
	mov	bx,ax		    ; bx is next_scan

	les	di,pDest
        lds     si,pBits
        assumes ds,nothing

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; Start of RLE decoding
;
;   DS:SI   --> RLE bits
;   ES:DI   --> screen output (points to start of scan)
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286Start:
	mov	dx,di		    ; save start of scan

Rle286Next:
        ReadRLE286                  ; al=count ah=color

        or      al,al               ; is it a escape?
        jz      Rle286Escape

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a encoded run (al != 0)
;
;   al - run length
;   ah - run color
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286EncodedRun:
        mov     cl,al
	mov	al,ah

	shr	cx,1
	rep	stos wptr es:[di]
	adc	cl,cl
	rep	stos bptr es:[di]

        jmp     short Rle286Next

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a RLE escape code (al=0)
; Possibilities are:
;       . End of Line            -  ah = 0
;       . End of RLE             -  ah = 1
;       . Delta                  -  ah = 2
;       . Unencoded run          -  ah = 3 or more
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286Escape:
        cmp     ah,al
        je      Rle286EOL

        inc     al
        cmp     ah,al
        je      Rle286EOF

        inc     al
        cmp     ah,al
        je      Rle286Delta
        errn$   Rle286UnencodedRun

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a un-encoded run (ah >= 3)
;
;   ah          is pixel count
;   DS:SI   --> pixels
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286UnencodedRun:
	mov	cl,ah

	shr	cx,1
	rep	movs wptr es:[di], wptr ds:[si]
	adc	cl,cl
        rep     movs bptr es:[di], bptr ds:[si]

	inc	si			  ; !!! re-align source
	and	si,not 1
        jmp     short Rle286Next

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a delta jump, the next two bytes contain the jump values
; note the the jump values are unsigned bytes, x first then y
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286Delta:
        ReadRLE286                  ; al = deltaX, ah = deltaY

        or      ah,ah
        jnz     Rle286DeltaXY

Rle286DeltaX:
	add	di,ax
        jmp     short Rle286Next

Rle286DeltaXY:
        add     di,bx
        add     dx,bx
        dec     ah
        jnz     Rle286DeltaXY

	add	di,ax
        jmp     short Rle286Next

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a end of line marker, point ES:DI to the begining of the
; next scan
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286EOL:
        mov     di,dx             ; go back to start of scan
        add     di,bx             ; advance to next scan
        jmp     short Rle286Start ; go get some more

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; We have found a end of rle marker, clean up and exit.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286EOF:
        errn$   Rle286Exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
Rle286Exit:
	pop	si
	pop	di
cEnd

sEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\avifile.16\riffdisp.c ===
/****************************************************************************
 *
 *  MODULE  : RIFFDISP.C
 *
 ****************************************************************************/

#include <windows.h>
#include <win32.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <drawdib.h>
#include "riffdisp.h"
#include "avifile.h"

static  HWND        hwndPreview;
static  HANDLE      hdibPreview;
static  char        achPreview[80];
static  HFONT       hfontPreview;

static  HDRAWDIB    hdd;

#define GetHInstance()  (HINSTANCE)(SELECTOROF((LPVOID)&hwndPreview))

#define DibSizeImage(lpbi) (\
    (DWORD)(UINT)((((int)lpbi->biBitCount*(int)lpbi->biWidth+31)&~31)>>3) * \
    (DWORD)(UINT)lpbi->biHeight)

#define DibSize(lpbi) \
    (lpbi->biSize + ((int)lpbi->biClrUsed * sizeof(RGBQUAD)) + lpbi->biSizeImage)

#define DibNumColors(lpbi) \
    (lpbi->biBitCount <= 8 ? (1 << (int)lpbi->biBitCount) : 0)

/***************************************************************************
 *
 ****************************************************************************/

//#define FOURCC_RIFF mmioFOURCC('R','I','F','F')
#define FOURCC_AVI  mmioFOURCC('A','V','I',' ')
#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')

BOOL   PreviewOpen(HWND hwnd);
BOOL   PreviewFile(HWND hwnd, LPSTR szFile);
BOOL   PreviewPaint(HWND hwnd);
BOOL   PreviewClose(HWND hwnd);

HANDLE ReadDisp(LPSTR lpszFile, int cf, LPSTR pv, int iLen);
HANDLE ReadInfo(LPSTR lpszFile, FOURCC fcc, LPSTR pv, int iLen);
HANDLE GetRiffDisp(LPSTR lpszFile, LPSTR szText, int iLen);

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewOpen(HWND hwnd)
{
    LOGFONT lf;

    if (hwndPreview)
        return FALSE;

    hwndPreview = hwnd;

    hdd = DrawDibOpen();

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf, 0);
    hfontPreview = CreateFontIndirect(&lf);
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewClose(HWND hwnd)
{
    if (hwndPreview != hwnd)
        return FALSE;

    if (hdibPreview)
        GlobalFree(hdibPreview);

    if (hfontPreview)
        DeleteObject(hfontPreview);

    if (hdd)
        DrawDibClose(hdd);

    achPreview[0] = 0;
    hdd           = NULL;
    hwndPreview   = NULL;
    hdibPreview   = NULL;
    hfontPreview  = NULL;
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewFile(HWND hwnd, LPSTR szFile)
{
    if (hwndPreview != hwnd)
        return FALSE;

    achPreview[0] = 0;

    if (hdibPreview)
        GlobalFree(hdibPreview);

    hdibPreview = NULL;

    if (szFile)
    {
        hdibPreview = GetRiffDisp(szFile, achPreview, sizeof(achPreview));
    }

    PreviewPaint(hwnd);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewPaint(HWND hwnd)
{
    RECT    rc;
    RECT    rcPreview;
    RECT    rcImage;
    RECT    rcText;
    HDC     hdc;
    HBRUSH  hbr;
    int     dx;
    int     dy;
    LPBITMAPINFOHEADER lpbi;

    if (hwndPreview != hwnd)
        return FALSE;

    //
    // locate the preview in the lower corner of the dialog (below the
    // cancel button)
    //
//////!!! find a better way to do this.
    GetClientRect(hwnd, &rcPreview);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc);
    ScreenToClient(hwnd, (LPPOINT)&rc);
    ScreenToClient(hwnd, (LPPOINT)&rc+1);

    rcPreview.top   = rc.bottom + (rc.bottom - rc.top) + 12;
    rcPreview.left  = rc.left;
    rcPreview.right = rc.right;
    rcPreview.bottom -= 4;          // leave a little room at the bottom
//////

    hdc = GetDC(hwnd);
    hbr = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLOR, (WPARAM)hdc, MAKELONG(hwnd, CTLCOLOR_DLG));
    SelectObject(hdc, hfontPreview);
    SetStretchBltMode(hdc, COLORONCOLOR);

    InflateRect(&rcPreview, 4, 1);
    FillRect(hdc, &rcPreview, hbr);
    IntersectClipRect(hdc, rcPreview.left, rcPreview.top, rcPreview.right, rcPreview.bottom);
    InflateRect(&rcPreview, -4, -1);

    //
    // compute the text rect, using DrawText
    //
    rcText = rcPreview;
    rcText.bottom = rcText.top;

    DrawText(hdc, achPreview, -1, &rcText, DT_CALCRECT|DT_LEFT|DT_WORDBREAK);

    //
    // compute the image size
    //
    if (hdibPreview && hdd)
    {
        lpbi = (LPVOID)GlobalLock(hdibPreview);

#if 0
        //
        // DISP(CF_DIB) chunks are messed up they contain a DIB file! not
        // a CF_DIB, skip over the header if it is there.
        //
        if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
            (LPSTR)lpbi += sizeof(BITMAPFILEHEADER);
#endif

        rcImage = rcPreview;

        //
        //  if wider than preview area scale to fit
        //
        if ((int)lpbi->biWidth > rcImage.right - rcImage.left)
        {
            rcImage.bottom = rcImage.top + MulDiv((int)lpbi->biHeight,rcImage.right-rcImage.left,(int)lpbi->biWidth);
        }
        //
        //  if x2 will fit then use it
        //
        else if ((int)lpbi->biWidth * 2 < rcImage.right - rcImage.left)
        {
            rcImage.right  = rcImage.left + (int)lpbi->biWidth*2;
            rcImage.bottom = rcImage.top + (int)lpbi->biHeight*2;
        }
        //
        //  else center the image in the preview area
        //
        else
        {
            rcImage.right  = rcImage.left + (int)lpbi->biWidth;
            rcImage.bottom = rcImage.top + (int)lpbi->biHeight;
        }

	if (rcImage.bottom > rcPreview.bottom - (rcText.bottom - rcText.top))
	{
	    rcImage.bottom = rcPreview.bottom - (rcText.bottom - rcText.top);

	    rcImage.right = rcPreview.left + MulDiv((int)lpbi->biWidth,rcImage.bottom-rcImage.top,(int)lpbi->biHeight);
	    rcImage.left = rcPreview.left;
	}
    }
    else
    {
        SetRectEmpty(&rcImage);
    }

    //
    //  now center
    //
    dx = ((rcPreview.right - rcPreview.left) - (rcText.right - rcText.left))/2;
    OffsetRect(&rcText, dx, 0);

    dx = ((rcPreview.right - rcPreview.left) - (rcImage.right - rcImage.left))/2;
    OffsetRect(&rcImage, dx, 0);

    dy  = rcPreview.bottom - rcPreview.top;
    dy -= rcImage.bottom - rcImage.top;
    dy -= rcText.bottom - rcText.top;

    if (dy < 0)
        dy = 0;
    else
        dy = dy / 2;

    OffsetRect(&rcImage, 0, dy);
    OffsetRect(&rcText, 0, dy + rcImage.bottom - rcImage.top + 2);

    //
    //  now draw
    //
    DrawText(hdc, achPreview, -1, &rcText, DT_LEFT|DT_WORDBREAK);

    if (hdibPreview && hdd)
    {
        DrawDibDraw(hdd,
                    hdc,
                    rcImage.left,
                    rcImage.top,
                    rcImage.right  - rcImage.left,
                    rcImage.bottom - rcImage.top,
                    lpbi,
                    NULL,
                    0,
                    0,
                    -1,
                    -1,
                    0);

        InflateRect(&rcImage, 1, 1);
        FrameRect(hdc, &rcImage, GetStockObject(BLACK_BRUSH));
    }

    ReleaseDC(hwnd, hdc);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

static UINT    (CALLBACK *lpfnOldHook)(HWND, UINT, WPARAM, LPARAM);

    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
    /* Edit controls */
#define edt1        0x0480

#define ID_TIMER    1234
#define PREVIEWWAIT 1000

WORD FAR PASCAL _export GetFileNamePreviewHook(HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
{
    int i;
    char ach[80];

    switch (msg) {
        case WM_COMMAND:
            switch (wParam)
            {
                case lst1:
                    if (HIWORD(lParam) == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        SetTimer(hwnd, ID_TIMER, PREVIEWWAIT, NULL);
                    }
                    break;

                case IDOK:
                case IDCANCEL:
                    KillTimer(hwnd, ID_TIMER);
                    PreviewFile(hwnd, NULL);
                    break;

                case cmb1:
                case cmb2:
                case lst2:
                    if (HIWORD(lParam) == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        PreviewFile(hwnd, NULL);
                    }
                    break;
            }
            break;

        case WM_TIMER:
            if (wParam == ID_TIMER)
            {
                KillTimer(hwnd, ID_TIMER);

                ach[0] = 0;
                i = (int)SendDlgItemMessage(hwnd, lst1, LB_GETCURSEL, 0, 0L);
                SendDlgItemMessage(hwnd, lst1, LB_GETTEXT, i, (LONG)(LPSTR)ach);
                PreviewFile(hwnd, ach);
                return TRUE;
            }
            break;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        case WM_PAINT:
            PreviewPaint(hwnd);
            break;

        case WM_INITDIALOG:
            PreviewOpen(hwnd);

            if (!lpfnOldHook)
                return TRUE;

            break;

        case WM_DESTROY:
            PreviewClose(hwnd);
            break;
    }

    if (lpfnOldHook)
        return (*lpfnOldHook)(hwnd, msg, wParam, lParam);
    else
        return FALSE;
}

/**************************************************************************
* @doc EXTERNAL AVIGetStream
*
* @api BOOL | GetOpenFileNamePreview | This function is similar 
*      to <f GetOpenFileName> defined in COMMDLG.DLL except that 
*      it has a preview window to display the movie about to be opened.
*
* @parm LPOPENFILENAME | lpofn | Points to an <t OPENFILENAME> structure 
*       used to initialize the dialog box. On return, the structure 
*       contains information about the user's file selection.
*
* @rdesc Returns true if a file was opened.
*
* @comm For more information on this function, see the description for 
*       <f GetOpenFileName>.
*
* @xref <f GetOpenFileName>
*
*************************************************************************/
BOOL FAR PASCAL GetOpenFileNamePreview(LPOPENFILENAME lpofn)
{
    BOOL fHook;
    BOOL f;

    if (hwndPreview)
        return GetOpenFileName(lpofn);

    fHook = (BOOL)(lpofn->Flags & OFN_ENABLEHOOK);

    if (fHook)
        lpfnOldHook = lpofn->lpfnHook;

    (FARPROC)lpofn->lpfnHook = MakeProcInstance((FARPROC)GetFileNamePreviewHook, GetHInstance());
    lpofn->Flags |= OFN_ENABLEHOOK;

    f = GetOpenFileName(lpofn);

    FreeProcInstance((FARPROC)lpofn->lpfnHook);

    if (fHook)
        lpofn->lpfnHook = lpfnOldHook;
    else
        lpofn->Flags &= ~OFN_ENABLEHOOK;

    return f;
}

HANDLE AVIFirstFrame(LPSTR szFile)
{
    HANDLE h = NULL;
    LPBITMAPINFOHEADER lpbi;
    DWORD dwSize;
    PAVISTREAM pavi;
    PGETFRAME pg;

    if (AVIStreamOpenFromFile(&pavi, szFile, streamtypeVIDEO, 0, OF_READ, NULL) == AVIERR_OK)
    {
	pg = AVIStreamGetFrameOpen(pavi, NULL);
	if (pg) {
	    lpbi = AVIStreamGetFrame(pg, 0);

	    if (lpbi)
	    {
		dwSize = lpbi->biSize + lpbi->biSizeImage + lpbi->biClrUsed * sizeof(RGBQUAD);
		h = GlobalAlloc(GHND, dwSize);

		if (h)
		    hmemcpy(GlobalLock(h), lpbi, dwSize);
	    }

	    AVIStreamGetFrameClose(pg);
	}
        AVIStreamClose(pavi);
    }

    return h;
}

/****************************************************************************
 *
 *  get both the DISP(CF_DIB) and the DISP(CF_TEXT) info in one pass, this is
 *  much faster than doing multiple passes over the file.
 *
 ****************************************************************************/

HANDLE GetRiffDisp(LPSTR lpszFile, LPSTR szText, int iLen)
{
    HMMIO       hmmio;
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    MMCKINFO    ckRIFF;
    HANDLE	h = NULL;
    LONG        lSize;
    DWORD       dw;
    HCURSOR     hcur = NULL;

    if (szText)
        szText[0] = 0;

    /* Open the file */
    hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);

    if (hmmio == NULL)
        return NULL;

    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    while (!mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            if (hcur == NULL)
                hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);

            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and lock it down */
                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;
            }
            else if ((int)dw == CF_TEXT && szText[0] == 0)
            {
                if (lSize > iLen-1)
                    lSize = iLen-1;

                szText[lSize] = 0;

                if (mmioRead(hmmio, szText, lSize) != lSize)
                    goto error;
            }
        }
        else if (ck.ckid    == FOURCC_LIST &&
                 ck.fccType == FOURCC_INFO &&
                 szText[0]  == 0)
        {
            while (!mmioDescend(hmmio, &ckINFO, &ck, 0))
            {
                switch (ckINFO.ckid)
                {
                    case FOURCC_INAM:
//                  case FOURCC_ISBJ:

                        lSize = ck.cksize;

                        if (lSize > iLen-1)
                            lSize = iLen-1;

                        szText[lSize] = 0;

                        if (mmioRead(hmmio, szText, lSize) != lSize)
                            goto error;

                        break;
                }

                if (mmioAscend(hmmio, &ckINFO, 0))
                    break;
            }
        }

        //
        // if we have both a picture and a title, then exit.
        //
        if (h != NULL && szText[0] != 0)
            break;

        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
        GlobalFree(h);

    h = NULL;
    ckRIFF.fccType = 0;

exit:
    mmioClose(hmmio, 0);

    //
    // !!!we need a way to preview other file types!
    // !!!what about text.
    //
    if (h == NULL && ckRIFF.fccType == FOURCC_AVI)
    {
        if (hcur == NULL)
            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

        h = AVIFirstFrame(lpszFile);
    }

    //
    // verify and correct the DIB
    //
    if (h)
    {
        LPBITMAPINFOHEADER lpbi;

        lpbi = (LPVOID)GlobalLock(h);

        if (lpbi->biSize < sizeof(BITMAPINFOHEADER))
            goto error;

        if (lpbi->biClrUsed == 0)
            lpbi->biClrUsed = DibNumColors(lpbi);

        if (lpbi->biSizeImage == 0)
            lpbi->biSizeImage = DibSizeImage(lpbi);

        if (DibSize(lpbi) > GlobalSize(h))
            goto error;
    }

    if (hcur)
        SetCursor(hcur);

    return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\compman.h ===
/*
*  Header file for comunication with AVI installable compressors/decompressors
*
*  Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.
*
* Win16:
*
* Installable compressors should be listed in SYSTEM.INI as
* follows:
*
* [Drivers]
*      VIDC.MSSQ = mssqcomp.drv
*      VIDC.XXXX = foodrv.drv
*
* Win32: (NT)
*
* Installable compressors should be listed in the registration database
* under the key
*   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32
*      VIDC.MSSQ = mssqcomp.dll
*      VIDC.XXXX = foodrv.dll
*
*
* That is, an identifying FOURCC should be the key, and the value
* should be the driver filename
*
*/

#ifndef _INC_COMPMAN
#define _INC_COMPMAN

#ifndef RC_INVOKED
#ifndef VFWAPI
#ifdef _WIN32
    #define VFWAPI  WINAPI
#ifdef WINAPIV
    #define VFWAPIV WINAPIV
#else
    #define VFWAPIV FAR CDECL
#endif
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/************************************************************************

    messages and structures.

************************************************************************/

#if !defined HTASK
    #define HTASK HANDLE
#endif
#include "compddk.h"            // include this file for the messages.

// begin_vfw32

/************************************************************************

    ICM function declarations
	
************************************************************************/

BOOL    
VFWAPI 
ICInfo(
    IN DWORD fccType, 
    IN DWORD fccHandler, 
    OUT ICINFO FAR * lpicinfo
    );

BOOL    
VFWAPI 
ICInstall(
    IN DWORD fccType, 
    IN DWORD fccHandler, 
    IN LPARAM lParam, 
    IN LPSTR szDesc, 
    IN UINT wFlags
    );

BOOL    
VFWAPI 
ICRemove(
    IN DWORD fccType, 
    IN DWORD fccHandler, 
    IN UINT wFlags
    );

LRESULT 
VFWAPI 
ICGetInfo(
    IN HIC hic, 
    OUT ICINFO FAR *picinfo, 
    IN DWORD cb
    );

HIC     
VFWAPI 
ICOpen(
    IN DWORD fccType, 
    IN DWORD fccHandler, 
    IN UINT wMode
    );

HIC     
VFWAPI 
ICOpenFunction(
    IN DWORD fccType, 
    IN DWORD fccHandler, 
    IN UINT wMode, 
    IN FARPROC lpfnHandler
    );

LRESULT 
VFWAPI 
ICClose(
    IN HIC hic
    );

LRESULT 
VFWAPI  
ICSendMessage(
    IN HIC hic, 
    IN UINT msg, 
    IN DWORD_PTR dw1, 
    IN DWORD_PTR dw2
    );
#ifndef _WIN32
//this function is unsupported on Win32 as it is non-portable.
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...);
#endif


/* Values for wFlags of ICInstall() */
#define ICINSTALL_UNICODE       0x8000

#define ICINSTALL_FUNCTION      0x0001  // lParam is a DriverProc (function ptr)
#define ICINSTALL_DRIVER        0x0002  // lParam is a driver name (string)
#define ICINSTALL_HDRV          0x0004  // lParam is a HDRVR (driver handle)

#define ICINSTALL_DRIVERW       0x8002  // lParam is a unicode driver name

/************************************************************************

    query macros

************************************************************************/
#define ICMF_CONFIGURE_QUERY     0x00000001
#define ICMF_ABOUT_QUERY         0x00000001

#define ICQueryAbout(hic) \
    (ICSendMessage(hic, ICM_ABOUT, (DWORD_PTR) -1, ICMF_ABOUT_QUERY) == ICERR_OK)

#define ICAbout(hic, hwnd) \
    ICSendMessage(hic, ICM_ABOUT, (DWORD_PTR)(UINT_PTR)(hwnd), 0)

#define ICQueryConfigure(hic) \
    (ICSendMessage(hic, ICM_CONFIGURE, (DWORD_PTR) -1, ICMF_CONFIGURE_QUERY) == ICERR_OK)

#define ICConfigure(hic, hwnd) \
    ICSendMessage(hic, ICM_CONFIGURE, (DWORD_PTR)(UINT_PTR)(hwnd), 0)

/************************************************************************

    get/set state macros
	
************************************************************************/

#define ICGetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_GETSTATE, (DWORD_PTR)(LPVOID)(pv), (DWORD_PTR)(cb))

#define ICSetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_SETSTATE, (DWORD_PTR)(LPVOID)(pv), (DWORD_PTR)(cb))

#define ICGetStateSize(hic) \
    (DWORD) ICGetState(hic, NULL, 0)

/************************************************************************

    get value macros

************************************************************************/
static DWORD dwICValue;

#define ICGetDefaultQuality(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTQUALITY, (DWORD_PTR)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

#define ICGetDefaultKeyFrameRate(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTKEYFRAMERATE, (DWORD_PTR)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

/************************************************************************

    draw window macro
	
************************************************************************/
#define ICDrawWindow(hic, prc) \
    ICSendMessage(hic, ICM_DRAW_WINDOW, (DWORD_PTR)(LPVOID)(prc), sizeof(RECT))

/************************************************************************

    compression functions

************************************************************************/
/*
 *  ICCompress()
 *
 *  compress a single frame
 *
 */
DWORD 
VFWAPIV 
ICCompress(
    IN     HIC                 hic,
    IN     DWORD               dwFlags,        // flags
    IN     LPBITMAPINFOHEADER  lpbiOutput,     // output format
    OUT    LPVOID              lpData,         // output data
    IN     LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    IN     LPVOID              lpBits,         // frame data to compress
    OUT    LPDWORD             lpckid,         // ckid for data in AVI file
    OUT    LPDWORD             lpdwFlags,      // flags in the AVI index.
    IN     LONG                lFrameNum,      // frame number of seq.
    IN     DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    IN     DWORD               dwQuality,      // quality within one frame
    IN     LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    IN     LPVOID              lpPrev          // previous frame
    );

/*
 *  ICCompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_BEGIN, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICCompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICCompressGetFormat()
 *
 *  get the output format, (format of compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICCompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_FORMAT, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICCompressGetFormatSize(hic, lpbi) \
    (DWORD) ICCompressGetFormat(hic, lpbi, NULL)

/*
 *  ICCompressSize()
 *
 *  return the maximal size of a compressed frame
 *
 */
#define ICCompressGetSize(hic, lpbiInput, lpbiOutput) \
    (DWORD) ICSendMessage(hic, ICM_COMPRESS_GET_SIZE, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICCompressEnd(hic) \
    ICSendMessage(hic, ICM_COMPRESS_END, 0, 0)

/************************************************************************

    decompression functions

************************************************************************/

/*
 *  ICDecompress()
 *
 *  decompress a single frame
 *
 */
#define ICDECOMPRESS_HURRYUP    0x80000000L     // don't draw just buffer (hurry up!)

DWORD 
VFWAPIV 
ICDecompress(
    IN  HIC                 hic,
    IN  DWORD               dwFlags,    // flags (from AVI index...)
    IN  LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
                                        // biSizeImage has the chunk size
    IN  LPVOID              lpData,     // data
    IN  LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    OUT LPVOID              lpBits
    );

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_BEGIN, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressGetFormat()
 *
 *  get the output format, (format of un-compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICDecompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ((LONG) ICSendMessage(hic, ICM_DECOMPRESS_GET_FORMAT, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput)))

#define ICDecompressGetFormatSize(hic, lpbi) \
    ICDecompressGetFormat(hic, lpbi, NULL)

/*
 *  ICDecompressGetPalette()
 *
 *  get the output palette
 *
 */
#define ICDecompressGetPalette(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_GET_PALETTE, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICDecompressSetPalette(hic, lpbiPalette) \
    ICSendMessage(hic, ICM_DECOMPRESS_SET_PALETTE, (DWORD_PTR)(LPVOID)(lpbiPalette), 0)

#define ICDecompressEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESS_END, 0, 0)

/************************************************************************

    decompression (ex) functions

************************************************************************/

// end_vfw32

#ifdef _WIN32

// begin_vfw32

//
// on Win16 these functions are macros that call ICMessage. ICMessage will
// not work on NT. rather than add new entrypoints we have given
// them as static inline functions
//

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
static __inline LRESULT VFWAPI
ICDecompressEx(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX, (DWORD_PTR)&ic, sizeof(ic));
}


/*
 *  ICDecompressExBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
static __inline LRESULT VFWAPI
ICDecompressExBegin(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_BEGIN, (DWORD_PTR)&ic, sizeof(ic));
}

/*
 *  ICDecompressExQuery()
 *
 */
static __inline LRESULT VFWAPI
ICDecompressExQuery(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_QUERY, (DWORD_PTR)&ic, sizeof(ic));
}

// end_vfw32

#else

// these macros need to be functions for WIN32 because ICMessage is
// essentially unsupportable on NT

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
#define ICDecompressEx(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX, sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressExBegin(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX_BEGIN, sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

/*
 *  ICDecompressExQuery()
 *
 */
#define ICDecompressExQuery(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX_QUERY,  sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))
#endif

// begin_vfw32

#define ICDecompressExEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESSEX_END, 0, 0)

/************************************************************************

    drawing functions

************************************************************************/

/*
 *  ICDrawBegin()
 *
 *  start decompressing data with format (lpbiInput) directly to the screen
 *
 *  return zero if the decompressor supports drawing.
 *
 */

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND

DWORD 
VFWAPIV 
ICDrawBegin(
    IN HIC                 hic,
    IN DWORD               dwFlags,        // flags
    IN HPALETTE            hpal,           // palette to draw with
    IN HWND                hwnd,           // window to draw to
    IN HDC                 hdc,            // HDC to draw to
    IN int                 xDst,           // destination rectangle
    IN int                 yDst,
    IN int                 dxDst,
    IN int                 dyDst,
    IN LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
    IN int                 xSrc,           // source rectangle
    IN int                 ySrc,
    IN int                 dxSrc,
    IN int                 dySrc,
    IN DWORD               dwRate,         // frames/second = (dwRate/dwScale)
    IN DWORD               dwScale
    );

/*
 *  ICDraw()
 *
 *  decompress data directly to the screen
 *
 */

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen

DWORD 
VFWAPIV 
ICDraw(
    IN HIC                 hic,
    IN DWORD               dwFlags,        // flags
    IN LPVOID              lpFormat,       // format of frame to decompress
    IN LPVOID              lpData,         // frame data to decompress
    IN DWORD               cbData,         // size of data
    IN LONG                lTime           // time to draw this frame
    );

// end_vfw32

#ifdef _WIN32

// begin_vfw32

// ICMessage is not supported on Win32, so provide a static inline function
// to do the same job
static __inline LRESULT VFWAPI
ICDrawSuggestFormat(
            HIC hic,
            LPBITMAPINFOHEADER lpbiIn,
            LPBITMAPINFOHEADER lpbiOut,
            int dxSrc,
            int dySrc,
            int dxDst,
            int dyDst,
            HIC hicDecomp)
{
    ICDRAWSUGGEST ic;

    ic.lpbiIn = lpbiIn;
    ic.lpbiSuggest = lpbiOut;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    ic.hicDecompressor = hicDecomp;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DRAW_SUGGESTFORMAT, (DWORD_PTR)&ic, sizeof(ic));
}

// end_vfw32

#else
#define ICDrawSuggestFormat(hic,lpbiIn,lpbiOut,dxSrc,dySrc,dxDst,dyDst,hicDecomp) \
        ICMessage(hic, ICM_DRAW_SUGGESTFORMAT, sizeof(ICDRAWSUGGEST),   \
            (LPBITMAPINFOHEADER)(lpbiIn),(LPBITMAPINFOHEADER)(lpbiOut), \
            (int)(dxSrc),(int)(dySrc),(int)(dxDst),(int)(dyDst), (HIC)(hicDecomp))
#endif

// begin_vfw32

/*
 *  ICDrawQuery()
 *
 *  determines if the compressor is willing to render the specified format.
 *
 */
#define ICDrawQuery(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), 0L)

#define ICDrawChangePalette(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_CHANGEPALETTE, (DWORD_PTR)(LPVOID)(lpbiInput), 0L)

#define ICGetBuffersWanted(hic, lpdwBuffers) \
    ICSendMessage(hic, ICM_GETBUFFERSWANTED, (DWORD_PTR)(LPVOID)(lpdwBuffers), 0)

#define ICDrawEnd(hic) \
    ICSendMessage(hic, ICM_DRAW_END, 0, 0)

#define ICDrawStart(hic) \
    ICSendMessage(hic, ICM_DRAW_START, 0, 0)

#define ICDrawStartPlay(hic, lFrom, lTo) \
    ICSendMessage(hic, ICM_DRAW_START_PLAY, (DWORD_PTR)(lFrom), (DWORD_PTR)(lTo))

#define ICDrawStop(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP, 0, 0)

#define ICDrawStopPlay(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP_PLAY, 0, 0)

#define ICDrawGetTime(hic, lplTime) \
    ICSendMessage(hic, ICM_DRAW_GETTIME, (DWORD_PTR)(LPVOID)(lplTime), 0)

#define ICDrawSetTime(hic, lTime) \
    ICSendMessage(hic, ICM_DRAW_SETTIME, (DWORD_PTR)lTime, 0)

#define ICDrawRealize(hic, hdc, fBackground) \
    ICSendMessage(hic, ICM_DRAW_REALIZE, (DWORD_PTR)(UINT_PTR)(HDC)(hdc), (DWORD_PTR)(BOOL)(fBackground))

#define ICDrawFlush(hic) \
    ICSendMessage(hic, ICM_DRAW_FLUSH, 0, 0)

#define ICDrawRenderBuffer(hic) \
    ICSendMessage(hic, ICM_DRAW_RENDERBUFFER, 0, 0)

/************************************************************************

    Status callback functions

************************************************************************/

/*
 *  ICSetStatusProc()
 *
 *  Set the status callback function
 *
 */

// end_vfw32

#ifdef _WIN32

// begin_vfw32

// ICMessage is not supported on NT
static __inline LRESULT VFWAPI
ICSetStatusProc(
            HIC hic,
            DWORD dwFlags,
            LRESULT lParam,
            LONG (CALLBACK *fpfnStatus)(LPARAM, UINT, LONG) )
{
    ICSETSTATUSPROC ic;

    ic.dwFlags = dwFlags;
    ic.lParam = lParam;
    ic.Status = fpfnStatus;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_SET_STATUS_PROC, (DWORD_PTR)&ic, sizeof(ic));
}

// end_vfw32

#else

#define ICSetStatusProc(hic, dwFlags, lParam, fpfnStatus) \
    ICMessage(hic, ICM_SET_STATUS_PROC, sizeof(ICSETSTATUSPROC), \
        (DWORD)(dwFlags), \
	(LRESULT)(lParam), \
	(LONG ((CALLBACK *) ()))(fpfnStatus))
#endif

// begin_vfw32

/************************************************************************

helper routines for DrawDib and MCIAVI...

************************************************************************/

#define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \
    ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS)

#define ICDrawOpen(fccType, fccHandler, lpbiIn) \
    ICLocate(fccType, fccHandler, lpbiIn, NULL, ICMODE_DRAW)

HIC  
VFWAPI 
ICLocate(
    IN DWORD fccType, 
    IN DWORD fccHandler, 
    IN LPBITMAPINFOHEADER lpbiIn, 
    IN LPBITMAPINFOHEADER lpbiOut, 
    IN WORD wFlags
    );

HIC  
VFWAPI 
ICGetDisplayFormat(
    IN HIC hic, 
    IN LPBITMAPINFOHEADER lpbiIn, 
    OUT LPBITMAPINFOHEADER lpbiOut, 
    IN int BitDepth, 
    IN int dx, 
    IN int dy
    );

/************************************************************************
Higher level functions
************************************************************************/

HANDLE 
VFWAPI 
ICImageCompress(
    IN HIC                 hic,        // compressor to use
    IN UINT                uiFlags,    // flags (none yet)
    IN LPBITMAPINFO        lpbiIn,     // format to compress from
    IN LPVOID              lpBits,     // data to compress
    IN LPBITMAPINFO        lpbiOut,    // compress to this (NULL ==> default)
    IN LONG                lQuality,   // quality to use
    IN OUT LONG FAR *      plSize      // compress to this size (0=whatever)
    );

HANDLE 
VFWAPI 
ICImageDecompress(
    IN HIC                 hic,        // compressor to use
    IN UINT                uiFlags,    // flags (none yet)
    IN LPBITMAPINFO        lpbiIn,     // format to decompress from
    IN LPVOID              lpBits,     // data to decompress
    IN LPBITMAPINFO        lpbiOut     // decompress to this (NULL ==> default)
    );

//
// Structure used by ICSeqCompressFrame and ICCompressorChoose routines
// Make sure this matches the autodoc in icm.c!
//
typedef struct {
    LONG		cbSize;		// set to sizeof(COMPVARS) before
					// calling ICCompressorChoose
    DWORD		dwFlags;	// see below...
    HIC			hic;		// HIC of chosen compressor
    DWORD               fccType;	// basically ICTYPE_VIDEO
    DWORD               fccHandler;	// handler of chosen compressor or
					// "" or "DIB "
    LPBITMAPINFO	lpbiIn;		// input format
    LPBITMAPINFO	lpbiOut;	// output format - will compress to this
    LPVOID		lpBitsOut;
    LPVOID		lpBitsPrev;
    LONG		lFrame;
    LONG		lKey;		// key frames how often?
    LONG		lDataRate;	// desired data rate KB/Sec
    LONG		lQ;		// desired quality
    LONG		lKeyCount;
    LPVOID		lpState;	// state of compressor
    LONG		cbState;	// size of the state
} COMPVARS, FAR *PCOMPVARS;

// FLAGS for dwFlags element of COMPVARS structure:
// set this flag if you initialize COMPVARS before calling ICCompressorChoose
#define ICMF_COMPVARS_VALID	0x00000001	// COMPVARS contains valid data

//
//  allows user to choose compressor, quality etc...
//
BOOL 
VFWAPI 
ICCompressorChoose(
    IN     HWND        hwnd,               // parent window for dialog
    IN     UINT        uiFlags,            // flags
    IN     LPVOID      pvIn,               // input format (optional)
    IN     LPVOID      lpData,             // input data (optional)
    IN OUT PCOMPVARS   pc,                 // data about the compressor/dlg
    IN     LPSTR       lpszTitle           // dialog title (optional)
    );

// defines for uiFlags
#define ICMF_CHOOSE_KEYFRAME	0x0001	// show KeyFrame Every box
#define ICMF_CHOOSE_DATARATE	0x0002	// show DataRate box
#define ICMF_CHOOSE_PREVIEW	0x0004	// allow expanded preview dialog
#define ICMF_CHOOSE_ALLCOMPRESSORS	0x0008	// don't only show those that
						// can handle the input format
						// or input data

BOOL 
VFWAPI 
ICSeqCompressFrameStart(
    IN PCOMPVARS pc, 
    IN LPBITMAPINFO lpbiIn
    );

void 
VFWAPI 
ICSeqCompressFrameEnd(
    IN PCOMPVARS pc
    );

LPVOID 
VFWAPI 
ICSeqCompressFrame(
    IN  PCOMPVARS               pc,         // set by ICCompressorChoose
    IN  UINT                    uiFlags,    // flags
    IN  LPVOID                  lpBits,     // input DIB bits
    OUT BOOL FAR                *pfKey,     // did it end up being a key frame?
    IN OUT LONG FAR             *plSize     // size to compress to/of returned image
    );

void 
VFWAPI 
ICCompressorFree(
    IN PCOMPVARS pc
    );

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* _INC_COMPMAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\compddk.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
 *
 *  Compddk.h - include file for implementing installable compressors
 *
 *  Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.
 *
 **********************************************************************
 *
 * To register FOURCC's for codec types please obtain a
 * copy of the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 *
*/

#ifndef _INC_COMPDDK
#define _INC_COMPDDK	50	/* version number */

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack(1)         /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif
#ifndef _WIN32					// ;Internal
#define ICMODE_INTERNALF_FUNCTION32	0x8000	// ;Internal
#define ICMODE_INTERNALF_MASK		0x8000	// ;Internal
#endif						// ;Internal

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD ;Internal
#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format ;Internal
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats ;Internal

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame ;Internal
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS               (ICM_USER+20)   // decompress a frame to screen ;Internal
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time ;Internal

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames ;Internal
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
// end_vfw32
#else
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
#endif
// begin_vfw32
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;

// end_vfw32

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack()          /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_COMPDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\compmn16.h ===
/***************************************************************************
 *
 *  compdef.h
 *
 *  Copyright (c) 1993-1994  Microsoft Corporation
 *
 *  32-bit Thunks for msvideo.dll
 *
 *  Structures for mapping compression manager calls
 *
 **************************************************************************/

/**************************************************************************\

 Thunking of compman APIs

 Functions:

    ICInstall is NOT supported from 16-bit to 32-bit

    ICRemove is also NOT supported

    ICInfo - tries the 32-bit side first

    Handles

        Are pointers to the PIC table.

        The 16-bit side handle manager will store these and call us back
        with our 32-bit handles so the thunking routines here receive
        real 32-bit handles.

        There is NO handle cleanup (why not ???) on task termination

/*
 *  Make sure the compiler doesn't think it knows better about packing
 *  The 16-bit stack is effectively pack(2)
 */

#pragma pack(2)

/*
 *  Note that everything is in the reverse order to keep with the PASCAL
 *  calling convention on the other side
 */


/****************************************************************************

   compman entry point parameter lists

 ****************************************************************************/

typedef struct tICINFO16 {
    DWORD   dwSize;                 // sizeof(ICINFOA)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
}   ICINFO16;

#define ICINFOA ICINFO16

typedef struct {
#ifdef ICINFOA
    ICINFOA  *lpicinfo;  // Why is there no ASCII 32-bit API?
#else
    ICINFO   *lpicinfo;  // Why is there no ASCII 32-bit API?
#endif
    DWORD    fccHandler;
    DWORD    fccType;
} UNALIGNED *PICInfoParms16;

typedef struct {
    DWORD    dw2;
    DWORD    dw1;
    WORD     msg;
    DWORD    hic;
} UNALIGNED *PICSendMessageParms16;

typedef struct {
    WORD     wMode;
    DWORD    fccHandler;
    DWORD    fccType;
} UNALIGNED *PICOpenParms16;

typedef struct {
    DWORD    hic;
} UNALIGNED *PICCloseParms16;

typedef struct {
    DWORD    dwFlags;
    WORD     hpal;
    WORD     hwnd;
    WORD     hdc;
    short    xDst;
    short    yDst;
    short    dxDst;
    short    dyDst;
    LPBITMAPINFOHEADER lpbi;
    short    xSrc;
    short    ySrc;
    short    dxSrc;
    short    dySrc;
    DWORD    dwRate;
    DWORD    dwScale;
} ICDRAWBEGIN16;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\compman.c ===
//////////////////////////////////////////////////////////////////////////////o
//
//  Compman.c
//
//      Manager routines for compressing/decompressing/and choosing compressors.
//
//      (C) Copyright Microsoft Corp. 1991-1995.  All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////

/*
 * This code contains 16 thunk code for NT. If the 16 bit open fails
 * we will try and open a 32 bit codec.  (The reason for not trying the 32
 * bit codec first is an attempt to keep most things on the 16 bit side.
 * The performance under NT appears reasonable, and for frame specific
 * operations it reduces the number of 16/32 transitions.
 */



#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <win32.h>

#ifdef _WIN32
 #include <mmddk.h>  // needed for definition of DRIVERS_SECTION
BOOL IsAdmin(void);
#endif

#ifdef NT_THUNK16
#include "thunks.h"    // Define the thunk stuff
#endif

#ifdef _WIN32
#ifdef DEBUGLOAD
#define ICEnterCrit(p)  \
		    if (!(gdwLoadFlags & ICLOAD_CALLED)) {  \
			OutputDebugStringA("ICOPEN Crit Sec not setup (ENTER)\n"); \
			DebugBreak(); \
		    }                 \
		    (EnterCriticalSection(p))

#define ICLeaveCrit(p)  \
		    if (!(gdwLoadFlags & ICLOAD_CALLED)) {  \
			OutputDebugStringA("ICOPEN Crit Sec not setup (LEAVE)\n"); \
			DebugBreak(); \
		    }                 \
		    (LeaveCriticalSection(p))

#else

#define ICEnterCrit(p)  (EnterCriticalSection(p))
#define ICLeaveCrit(p)  (LeaveCriticalSection(p))
#endif

#else

// non-win32 code has no critsecs
#define ICEnterCrit(p)
#define ICLeaveCrit(p)

#endif

#include <profile.h>

//
// define these before compman.h, so our functions get declared right.
//
#ifndef _WIN32
#define VFWAPI  FAR PASCAL _loadds
#define VFWAPIV FAR CDECL  _loadds
#endif

#include <vfw.h>
#include "icm.rc"

#ifndef _WIN32
#define LoadLibraryA    LoadLibrary
#define CharLowerA      AnsiLower
#endif

#ifndef streamtypeVIDEO
    #define streamtypeVIDEO mmioFOURCC('v', 'i', 'd', 's')
#endif

#define ICTYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')
#define ICTYPE_ACM  mmioFOURCC('a', 'u', 'd', 'c')
#define SMAG        mmioFOURCC('S', 'm', 'a', 'g')

#define IC_INI      TEXT("Installable Compressors")

//STATICDT TCHAR   sz44s[]           = TEXT("%4.4hs");
STATICDT TCHAR   szMSACM[]         = TEXT("MSACM");
STATICDT TCHAR   szVIDC[]          = TEXT("VIDC");

STATICDT TCHAR   gszIniSect[]       = IC_INI;
STATICDT TCHAR   gszSystemIni[]     = TEXT("SYSTEM.INI");
STATICDT TCHAR   gszDrivers[]       = DRIVERS_SECTION;


STATICDT TCHAR   szNull[]          = TEXT("");
STATICDT TCHAR   szICKey[]         = TEXT("%4.4hs.%4.4hs");
STATICDT TCHAR   szMSVideo[]       = TEXT("MSVideo");
STATICDT SZCODEA szDriverProc[]    = "DriverProc";

#ifdef _WIN32
// Use a mapping to get stuff into and out of the registry
BOOL myWritePrivateProfileString(

    LPCTSTR  lpszSection,       // address of section name
    LPCTSTR  lpszKey,           // address of key name
    LPCTSTR  lpszString         // address of string to add
);

DWORD myGetPrivateProfileString(

    LPCTSTR  lpszSection,       // address of section name
    LPCTSTR  lpszKey,           // address of key name
    LPCTSTR  lpszDefault,       // address of default string
    LPTSTR   lpszReturnBuffer,  // address of destination buffer
    DWORD    cchReturnBuffer    // size of destination buffer
    );

#endif

#ifdef DEBUG
    #define DPF( x ) dprintfc x
    #define DEBUG_RETAIL
#else
    #define DPF(x)
#endif

#ifdef DEBUG_RETAIL
    STATICFN void CDECL dprintfc(LPSTR, ...);
    static  char gszModname[] = "COMPMAN";
    #define MODNAME gszModname

    #define RPF( x ) dprintfc x
    #define ROUT(sz) {static SZCODEA ach[] = sz; dprintfc(ach); }
    void  ICDebugMessage(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2);
    LRESULT ICDebugReturn(LRESULT err);
#ifdef _WIN32
    #define DebugErr(flags, sz) {static SZCODEA ach[] = "COMPMAN: "sz; OutputDebugStringA(ach); }
#else
    #define DebugErr(flags, sz) {static SZCODE ach[] = "COMPMAN: "sz; DebugOutput(flags | DBF_MMSYSTEM, ach); }
#endif

#else     // !DEBUG_RETAIL
    #define RPF(x)
    #define ROUT(sz)
    #define ICDebugMessage(hic, msg, dw1, dw2)
    #define ICDebugReturn(err)  err
    #define DebugErr(flags, sz)
#endif

#ifndef WF_WINNT
#define WF_WINNT 0x4000
#endif

#ifdef _WIN32
#define IsWow() FALSE
#else
#define IsWow() ((BOOL) (GetWinFlags() & WF_WINNT))
#define GetDriverModuleHandle(h) (IsWow() ? h : GetDriverModuleHandle(h))
#endif

// HACK!
//
//
#if defined _WIN32 && !defined UNICODE
 #pragma message ("hack! use DrvGetModuleHandle on Chicago")
 #undef GetDriverModuleHandle
 #define GetDriverModuleHandle(h) DrvGetModuleHandle(h)
 extern HMODULE _stdcall DrvGetModuleHandle(HDRVR);
#endif

__inline void ictokey(DWORD fccType, DWORD fcc, LPTSTR sz)
{
    int i = wsprintf(sz, szICKey, (LPSTR)&(fccType),(LPSTR)&(fcc));

    while (i>0 && sz[i-1] == ' ')
	sz[--i] = 0;
}

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

#ifdef DEBUG_RETAIL
STATICFN void ICDump(void);
#endif

//
//  the following array is used for 'installed' converters
//
//  converters are either driver handles or indexes into this array
//
//  'function' converters are installed into this array, 'driver' converters
//  are installed in SYSTEM.INI
//

#define MAX_CONVERTERS 75           // maximum installed converters.

typedef struct  {
    DWORD       dwSmag;             // 'Smag'
    HTASK       hTask;              // owner task.
    DWORD       fccType;            // converter type ie 'vidc'
    DWORD       fccHandler;         // converter id ie 'rle '
    HDRVR       hDriver;            // handle of driver
    LPARAM      dwDriver;           // driver id for functions
    DRIVERPROC  DriverProc;         // function to call
#ifdef NT_THUNK16
    DWORD       h32;                // 32-bit driver handle
#endif
}   IC, *PIC;

IC aicConverters[MAX_CONVERTERS];
int giMaxConverters = 0;             // High water mark of installed converters

/*
 * We dynamically allocate a buffer used in ICInfo to read all the
 * installable compressor definitions from system.ini.
 * The buffer is freed when the driver is unloaded (in IC_Unload).
 * The previous code had a buffer which was only freed when the executable
 * was unloaded, and not freed on DLL unload.
 */
static LPVOID lpICInfoMem = NULL;

/*****************************************************************************
 ****************************************************************************/

LRESULT CALLBACK DriverProcNull(DWORD_PTR dwDriverID, HANDLE hDriver, UINT wMessage, LPARAM dwParam1, LPARAM dwParam2)
{
    DPF(("codec called after it has been removed with ICRemove\r\n"));
    return ICERR_UNSUPPORTED;
}


/*****************************************************************************
 ****************************************************************************/

#if defined _WIN32
STATICFN HDRVR LoadDriver(LPWSTR szDriver, DRIVERPROC FAR *lpDriverProc);
#else
STATICFN HDRVR LoadDriver(LPSTR szDriver, DRIVERPROC FAR *lpDriverProc);
#endif
STATICFN void FreeDriver(HDRVR hDriver);

/*****************************************************************************

    driver cache - to make enuming/loading faster we keep the last N
    module's open for a while.

 ****************************************************************************/

#define NEVERCACHECODECS    // turn caching off for M6....

#if defined _WIN32 || defined NEVERCACHECODECS
#define CacheModule(x)
#else
#define N_MODULES   10      //!!!????

HMODULE ahModule[N_MODULES];
int     iModule = 0;

STATICFN void CacheModule(HMODULE hModule)
{
    char ach[128];

    //
    // what if this module is in the list currently?
    //
#if 0
    // we dont do this so unused compressors will fall off the end....
    int i;

    for (i=0; i<N_MODULES; i++)
    {
	if (ahModule[i] && ahModule[i] == hModule)
	    return;
    }
#endif

    //
    // add this module to the cache
    //
    if (hModule)
    {
	extern HMODULE ghInst;          // in MSVIDEO/init.c
	int iUsage;

	GetModuleFileNameA(hModule, ach, sizeof(ach));
	DPF(("Loading module: %s\r\n", (LPSTR)ach));
#ifndef _WIN32  // On NT GetModuleUsage always returns 1.  So... we cache
	iUsage = GetModuleUsage(ghInst);
#endif
	LoadLibraryA(ach);

#ifndef _WIN32  // On NT GetModuleUsage always returns 1.  So... we cache
	//
	// dont cache modules that link to MSVIDEO
	// we should realy do a toolhelp thing!
	// or force apps to call VFWInit and VFWExit()
	//
	// The NT position is more awkward..!
	//
	if (iUsage != GetModuleUsage(ghInst))
	{
	    DPF(("Not caching this module because it links to MSVIDEO\r\n"));
	    FreeLibrary(hModule);
	    return;
	}
#endif
    }

    //
    // free module in our slot.
    //
    if (ahModule[iModule] != NULL)
    {
#ifdef DEBUG
	GetModuleFileNameA(ahModule[iModule], ach, sizeof(ach));
	DPF(("Freeing module: %s  Handle==%8x\r\n", (LPSTR)ach, ahModule[iModule]));
	if (hModule!=NULL) {
	    GetModuleFileNameA(hModule, ach, sizeof(ach));
	    DPF(("Replacing with: %s  Handle==%8x\r\n", (LPSTR)ach, hModule));
	} else
	    DPF(("Slot now empty\r\n"));
#endif
	FreeLibrary(ahModule[iModule]);
    }

    ahModule[iModule] = hModule;
    iModule++;

    if (iModule >= N_MODULES)
	iModule = 0;
}
#endif


/*****************************************************************************
 ****************************************************************************/

/*****************************************************************************
 * FixFOURCC - clean up a FOURCC
 ****************************************************************************/

INLINE STATICFN DWORD Fix4CC(DWORD fcc)
{
    int i;

    if (fcc > 256)
    {
	AnsiLowerBuff((LPSTR)&fcc, sizeof(fcc));

	for (i=0; i<4; i++)
	{
	    if (((LPSTR)&fcc)[i] == 0)
		for (; i<4; i++)
		    ((LPSTR)&fcc)[i] = ' ';
	}
    }

    return fcc;
}

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api PIC | FindConverter |
 *      search the converter list for a un-opened converter
 *
 ****************************************************************************/

STATICFN PIC FindConverter(DWORD fccType, DWORD fccHandler)
{
    int i;
    PIC pic;

    // By running the loop to <= giMaxConverters we allow an empty slot to
    // be found.
    for (i=0; i<=giMaxConverters; i++)
    {
	pic = &aicConverters[i];

	if (pic->fccType  == fccType &&
	    pic->fccHandler  == fccHandler &&
	    pic->dwDriver == 0L)
	{
	    if (pic->DriverProc != NULL && IsBadCodePtr((FARPROC)pic->DriverProc))
	    {
		pic->DriverProc = NULL;
		ICClose((HIC)pic);
		DPF(("NO driver for fccType=%4.4hs, Handler=%4.4hs\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
		return NULL;
	    }

	    if ((0 == fccType + fccHandler)
	      && (i < (MAX_CONVERTERS-1))
	      && (i==giMaxConverters))
	    {
		++giMaxConverters;     // Up the high water mark
	    }
	    DPF(("Possible driver for fccType=%4.4hs, Handler=%4.4hs,  Slot %d\n", (LPSTR)&fccType, (LPSTR)&fccHandler, i));
	    return pic;
	}
    }

    DPF(("FindConverter: NO drivers for fccType=%4.4hs, Handler=%4.4hs\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
    return NULL;
}


#ifdef _WIN32

/*
 * we need to hold a critical section around the ICOpen code to protect
 * multi-thread simultaneous opens. This critsec is initialized by
 * ICDllEntryPoint (called from video\init.c at dll attach time) and is deleted
 * by ICDllEntryPoint (called from video\init.c at dll detach time).
 */
CRITICAL_SECTION ICOpenCritSec;

#ifdef DEBUGLOAD
// There is a suspicion that a nasty problem exists on NT whereby the DLL
// load/unload routines might not be called in certain esoteric cases.  As
// we rely on these routines to set up the ICOpenCritSec code has been
// added to verify that the critical section has indeed been set up.  On
// LOAD we turn one bit on in a global variable.  On UNLOAD we turn that
// bit off and turn another bit on.
DWORD gdwLoadFlags = 0;
#define ICLOAD_CALLED   0x00010000
#define ICUNLOAD_CALLED 0x00000001
#endif

//
//  We load/unload wow32.dll here.  This is used in the thunking code which
//  just does GetModuleHandle on it.  This is not really necessary in
//  Daytona but is in Chicago.
//
//  WORSE: IT IS IMPERATIVE TO NOT DO THIS ON DAYTONA.  The Daytona code
//  uses the fact the WOW32.DLL is loaded in the context of this process
//  as the indication that it is executing in the WOW process.

#ifdef CHICAGO
HMODULE hWow32 = NULL;
#endif

#endif

#ifdef _WIN32
//--------------------------------------------------------------------------;
//
//  BOOL ICDllEntryPoint [32-bit]
//
//  Description:
//      Called by msvideo's DllEntryPoint
//
//  History:
//      11/02/94    [frankye]
//
//--------------------------------------------------------------------------;
#ifdef LS_THUNK32
BOOL PASCAL ls_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
BOOL PASCAL sl_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#endif
BOOL WINAPI ICDllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
	case DLL_PROCESS_ATTACH:
	{
	    //DPFS(dbgInit, 0, "ICDllEntryPoint(DLL_PROCESS_ATTACH)");

#ifdef DEBUGLOAD
	    if (gdwLoadFlags & ICLOAD_CALLED) {
#ifdef DEBUG
		DPF(("!IC open crit sec already set up"));
#endif
	    }
	    gdwLoadFlags |= ICLOAD_CALLED;
	    gdwLoadFlags &= ~ICUNLOAD_CALLED;
#endif

	    InitializeCriticalSection(&ICOpenCritSec);

#ifdef LS_THUNK32
	    hWow32 = LoadLibrary(TEXT("WOW32.DLL"));
	    ls_ThunkConnect32(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, fdwReason);
	    sl_ThunkConnect32(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, fdwReason);
#endif

	    return TRUE;
	}

	case DLL_PROCESS_DETACH:
	{
	    //DPFS(dbgInit, 0, "ICDllEntryPoint(DLL_PROCESS_DETACH)");

#ifdef LS_THUNK32
	    ls_ThunkConnect32(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, fdwReason);
	    sl_ThunkConnect32(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, fdwReason);
	    if (NULL != hWow32) FreeLibrary(hWow32);
#endif

	    DeleteCriticalSection(&ICOpenCritSec);

#ifdef DEBUGLOAD
	    gdwLoadFlags |= ICUNLOAD_CALLED;
	    gdwLoadFlags &= ~ICLOAD_CALLED;
#endif
	
	    if (lpICInfoMem) {
		GlobalFreePtr(lpICInfoMem);
		lpICInfoMem = NULL;
	    }

#ifdef CHICAGO
	    dbgCheckShutdown();
#endif
	    return TRUE;
	}

    }

    return TRUE;
}

#else
//--------------------------------------------------------------------------;
//
//  BOOL ICDllEntryPoint [16-bit]
//
//  Description:
//      Called by msvideo's DllEntryPoint
//
//  History:
//      11/02/94    [frankye]
//
//--------------------------------------------------------------------------;
BOOL FAR PASCAL ls_ThunkConnect16(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
BOOL FAR PASCAL sl_ThunkConnect16(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
BOOL FAR PASCAL ICDllEntryPoint(DWORD dwReason, HINSTANCE hinstDLL, WORD wDS, WORD wHeapSize, DWORD dwReserved1, WORD wReserved2)
{
    PICMGARB pig;

    DPFS(dbgInit, 0, "ICDllEntryPoint()");

    switch (dwReason)
    {
	case 1:
	{
	    if (NULL == (pig = pigFind()))
	    {
		if (NULL == (pig = pigNew()))
		{
		    return FALSE;
		}
	    }

#ifdef LS_THUNK16
	    ls_ThunkConnect16(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, dwReason);
	    sl_ThunkConnect16(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, dwReason);
#endif
	
	    if (1 == ++pig->cUsage)
	    {
		DPFS(dbgInit, 0, "ICProcessAttach: New process %08lXh", pig->pid);
		//
		//  We can do one-time-per-process init here...
		//
	    }

	    return TRUE;
	}

	case 0:
	{
	    if (NULL == (pig = pigFind()))
	    {
		DPF(0, "!ICProcessDetach: ERROR: Being freed by process %08lXh in which it was not loaded", GetCurrentProcessId());
		DebugErr(DBF_ERROR, "ICProcessDetach: ERROR: Being freed by a process in which it was not loaded");
		return FALSE;
	    }

	    if (0 == --pig->cUsage)
	    {
		//
		//  We can do one-time-per-process termination here...
		//
		DPFS(dbgInit, 0, "ICProcessDetach: Terminating for process %08lXh", pig->pid);
#ifdef NT_THUNK16
		genthunkTerminate(pig);
#endif
		pigDelete(pig);
		
		dbgCheckShutdown();
	    }

#ifdef LS_THUNK16
	    ls_ThunkConnect16(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, dwReason);
	    sl_ThunkConnect16(TEXT("MSVIDEO.DLL"), TEXT("MSVFW32.DLL"), hinstDLL, dwReason);
#endif
	    return TRUE;
	}

    }

    return TRUE;
}

#endif
/*****************************************************************************
 ****************************************************************************/

__inline BOOL ICValid(HIC hic)
{
    PIC pic = (PIC)hic;

    if (pic <  &aicConverters[0] ||
	pic >= &aicConverters[MAX_CONVERTERS] ||
	pic->dwSmag != SMAG)
    {
	DebugErr(DBF_ERROR, "Invalid HIC\r\n");
	return FALSE;
    }

    return TRUE;
}

/*****************************************************************************
 ****************************************************************************/

#define V_HIC(hic)              \
    if (!ICValid(hic))          \
	return ICERR_BADHANDLE;

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api BOOL | ICCleanup | This function is called when a task exits or
 *      MSVIDEO.DLL is being unloaded.
 *
 * @parm HTASK | hTask | the task being terminated, NULL if DLL being unloaded
 *
 * @rdesc Returns nothing
 *
 * @comm  currently MSVIDEO only calles this function from it's WEP()
 *
 ****************************************************************************/

void FAR PASCAL ICCleanup(HTASK hTask)
{
    int i;
    PIC pic;

    //
    // free all HICs
    //
    for (i=0; i < giMaxConverters; i++)
    {
	pic = &aicConverters[i];

	if (pic->dwDriver != 0L && (pic->hTask == hTask || hTask == NULL))
	{
	    ROUT("Decompressor left open, closing\r\n");
	    ICClose((HIC)pic);
	}
    }

#ifdef N_MODULES
    //
    // free the module cache.
    //
    for (i=0; i<N_MODULES; i++)
	CacheModule(NULL);
#endif
}

/*****************************************************************************
 * @doc EXTERNAL IC  ICAPPS
 *
 * @api BOOL | ICInstall | This function installs a new compressor
 *      or decompressor.
 *
 * @parm DWORD | fccType | Specifies a four-character code indicating the
 *       type of data used by the compressor or decompressor.  Use 'vidc'
 *       for a video compressor or decompressor.
 *
 * @parm DWORD | fccHandler | Specifies a four-character code identifying
 *      a specific compressor or decompressor.
 *
 * @parm LPARAM | lParam | Specifies a pointer to a zero-terminated
 *       string containing the name of the compressor or decompressor,
 *       or it specifies a far pointer to a function used for compression
 *       or decompression. The contents of this parameter are defined
 *       by the flags set for <p wFlags>.
 *
 * @parm LPSTR | szDesc | Specifies a pointer to a zero-terminated string
 *        describing the installed compressor. Not use.
 *
 * @parm UINT | wFlags | Specifies flags defining the contents of <p lParam>.
 * The following flags are defined:
 *
 * @flag ICINSTALL_DRIVER | Indicates <p lParam> is a pointer to a zero-terminated
 *      string containing the name of the compressor to install.
 *
 * @flag ICINSTALL_FUNCTION | Indicates <p lParam> is a far pointer to
 *       a compressor function.  This function should
 *       be structured like the <f DriverProc> entry
 *       point function used by compressors.
 *
 * @rdesc Returns TRUE if successful.
 *
 * @comm  Applications must still open the installed compressor or
 *        decompressor before it can use the compressor or decompressor.
 *
 *        Usually, compressors and decompressors are installed by the user
 *        with the Drivers option of the Control Panel.
 *
 *        If your application installs a function as a compressor or
 *        decompressor, it should remove the compressor or decompressor
 *        with <f ICRemove> before it terminates. This prevents other
 *        applications from trying to access the function when it is not
 *        available.
 *
 *
 * @xref <f ICRemove>
 ****************************************************************************/
BOOL VFWAPI ICInstall(DWORD fccType, DWORD fccHandler, LPARAM lParam, LPSTR szDesc, UINT wFlags)
{
    TCHAR achKey[20];
    TCHAR buf[256];
    DWORD n;
    PIC  pic;

    ICEnterCrit(&ICOpenCritSec);
    fccType    = Fix4CC(fccType);
    fccHandler = Fix4CC(fccHandler);

    if ((pic = FindConverter(fccType, fccHandler)) == NULL)
	pic = FindConverter(0L, 0L);

    if (wFlags & ICINSTALL_DRIVER)
    {
	//
	//  dwConverter is the file name of a driver to install.
	//
	ictokey(fccType, fccHandler, achKey);

#ifdef UNICODE
	if (wFlags & ICINSTALL_UNICODE) {
	    lstrcpy(buf, (LPWSTR)lParam);
	    n = lstrlen(buf) + 1;    // Point past the terminating zero;
	    if (szDesc)
	    {
		lstrcpyn(buf+n, (LPWSTR)szDesc, NUMELMS(buf)-n);
		n += lstrlen(buf+n);
	    }
	    buf[n]=0;  // Always guarantee a second string - even if a null one
	} else {
	    // Convert the ANSI strings to UNICODE
	    n = 1 + wsprintf(buf, TEXT("%hs"), (LPSTR) lParam);
	    if (szDesc) {
		n += 1 + wsprintf(buf+n, TEXT("%hs"), szDesc);
	    }
	}
	// Buf now contains two strings, the second of which may be null (the description)
#else
	lstrcpy(buf, (LPSTR)lParam);

	if (szDesc)
	{
	    lstrcat(buf, TEXT(" "));
	    lstrcat(buf, szDesc);
	}
#endif

	ICLeaveCrit(&ICOpenCritSec);
	// Data is written (via the inifilemapping) to
	// HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Drivers32
	// HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Drivers.desc
	if (myWritePrivateProfileString(gszDrivers,achKey,buf))
	{
	    // delete the installable compressors entry for this driver
	    myWritePrivateProfileString(gszIniSect,achKey,NULL);
	    return TRUE;
	}

	return(FALSE);
    }
    else if (wFlags & ICINSTALL_FUNCTION)
    {
	if (pic == NULL)
	{
	    ICLeaveCrit(&ICOpenCritSec);
	    return FALSE;
	}

	pic->dwSmag     = SMAG;
	pic->fccType    = fccType;
	pic->fccHandler = fccHandler;
	pic->dwDriver   = 0L;
	pic->hDriver    = NULL;
	pic->DriverProc = (DRIVERPROC)lParam;
	DPF(("ICInstall, fccType=%4.4hs, Handler=%4.4hs,  Pic %x\n", (LPSTR)&fccType, (LPSTR)&fccHandler, pic));

	ICLeaveCrit(&ICOpenCritSec);

	return TRUE;
    }

#if 0
    else if (wFlags & ICINSTALL_HDRV)
    {
	if (pic == NULL)
	{
	    ICLeaveCrit(&ICOpenCritSec);
	    return FALSE;
	}

	pic->fccType  = fccType;
	pic->fccHandler  = fccHandler;
	pic->hDriver  = (HDRVR)lParam;
	pic->dwDriver = 0L;
	pic->DrvProc  = NULL;

	ICLeaveCrit(&ICOpenCritSec);

	return TRUE;
    }
#endif

    ICLeaveCrit(&ICOpenCritSec);

    return FALSE;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api BOOL | ICRemove | This function removes an installed compressor.
 *
 * @parm DWORD | fccType | Specifies a four-character code indicating the
 * type of data used by the compressor.  Use 'vidc' for video compressors.
 *
 * @parm DWORD | fccHandler | Specifies a four-character code identifying
 * a specific compressor.
 *
 * @parm UINT | wFlags | Not used.
 *
 * @rdesc Returns TRUE if successful.
 *
 * @xref <f ICInstall>
 ****************************************************************************/
BOOL VFWAPI ICRemove(DWORD fccType, DWORD fccHandler, UINT wFlags)
{
    TCHAR achKey[20];
    PIC  pic;

    ICEnterCrit(&ICOpenCritSec);
    fccType    = Fix4CC(fccType);
    fccHandler = Fix4CC(fccHandler);

    if (pic = FindConverter(fccType, fccHandler))
    {
	int i;

	//
	// we should realy keep usage counts!!!
	//
	for (i=0; i<giMaxConverters; i++)
	{
	    if (pic->DriverProc == aicConverters[i].DriverProc)
	    {
		DPF(("ACK! Handler is in use\r\n"));
		pic->DriverProc = (DRIVERPROC)DriverProcNull;
	    }
	}

	ICClose((HIC)pic);
    }
    else
    {
	// Remove the information
	ictokey(fccType, fccHandler, achKey);
	myWritePrivateProfileString(gszIniSect,achKey,NULL);
	myWritePrivateProfileString(gszDrivers,achKey,NULL);
    }

    ICLeaveCrit(&ICOpenCritSec);

    return TRUE;
}

//
//  Internal routine to enumerate all the installed drivers
//

BOOL ReadDriversInfo()
{
    LPSTR psz = NULL; // THIS IS ALWAYS an ANSI string pointer!
    if (lpICInfoMem == NULL) {
	UINT cbBuffer = 125 * sizeof(TCHAR);
	UINT cchBuffer;

	ICEnterCrit(&ICOpenCritSec);
	for (;;)
	{
	    lpICInfoMem = GlobalAllocPtr(GMEM_SHARE | GHND, cbBuffer);

	    if (!lpICInfoMem) {
		DPF(("Out of memory for SYSTEM.INI keys\r\n"));
		ICLeaveCrit(&ICOpenCritSec);
		return FALSE;
	    }

	    cchBuffer = (UINT)myGetPrivateProfileString(gszDrivers,
						      NULL,
						      szNull,
						      lpICInfoMem,
						      cbBuffer / sizeof(TCHAR));

	    if (cchBuffer < ((cbBuffer/sizeof(TCHAR)) - 5)) {
		cchBuffer += (UINT)myGetPrivateProfileString(gszIniSect,
						      NULL,
						      szNull,
						      (LPTSTR)lpICInfoMem + cchBuffer,
						      (cbBuffer/sizeof(TCHAR)) - cchBuffer);
		//
		// if all of the INI data fit, we can
		// leave the loop
		//
		if (cchBuffer < ((cbBuffer/sizeof(TCHAR)) - 5))
		    break;
	    }

	    GlobalFreePtr(lpICInfoMem), lpICInfoMem = NULL;

	    //
	    //  if cannot fit drivers section in 32k, then something is horked
	    //  with the section... so let's bail.
	    //
	    if (cbBuffer >= 0x8000) {
		DPF(("SYSTEM.INI keys won't fit in 32K????\r\n"));
		ICLeaveCrit(&ICOpenCritSec);
		return FALSE;
	    }

	    //
	    // double the size of our buffer and try again.
	    //
	    cbBuffer *= 2;
	    DPF(("Increasing size of SYSTEM.INI buffer to %d\r\n", cbBuffer));
	}

#if defined UNICODE
	// convert the INI data from UNICODE to ANSI
	//
	psz = GlobalAllocPtr (GMEM_SHARE | GHND, cchBuffer + 7);
	if ( ! psz) {
	    GlobalFreePtr (lpICInfoMem), lpICInfoMem = NULL;
	    ICLeaveCrit(&ICOpenCritSec);
	    return FALSE;
	}

	mmWideToAnsi (psz, lpICInfoMem, cchBuffer+2);
	GlobalFreePtr (lpICInfoMem);
	lpICInfoMem = psz;
#endif

	// convert codec information to lowercase
	for (psz = lpICInfoMem; *psz != 0; psz += lstrlenA(psz) + 1)
	{
#if 0  // we only put valid codecs into lpICInfoMem these days
	    if (psz[4] != '.')
		continue;
#endif

	    // convert this piece to lowercase
	    CharLowerA (psz);
	    DPF(("Compressor: %hs\n", psz));
	}
	ICLeaveCrit(&ICOpenCritSec);
    }
    return (lpICInfoMem != NULL);
}


/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api BOOL | ICInfo | This function returns information about
 *      specific installed compressors, or it enumerates
 *      the compressors installed.
 *
 * @parm DWORD | fccType | Specifies a four-character code indicating
 *       the type of compressor.  To match all compressor types specify zero.
 *
 * @parm DWORD | fccHandler | Specifies a four-character code identifying
 *       a specific compressor, or a number between 0 and the number
 *       of installed compressors of the type specified by <t fccType>.
 *
 * @parm ICINFO FAR * | lpicinfo | Specifies a far pointer to a
 *       <t ICINFO> structure used to return
 *      information about the compressor.
 *
 * @comm This function does not return full informaiton about
 *       a compressor or decompressor. Use <f ICGetInfo> for full
 *       information.
 *
 * @rdesc Returns TRUE if successful.
 ****************************************************************************/
#ifdef NT_THUNK16
BOOL VFWAPI ICInfoInternal(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo);

// If we are compiling the thunks, then the ICINFO entry point calls
// the 32 bit thunk, or calls the real ICInfo code (as ICInfoInternal).
// We deliberately give precedence to 16 bit compressors, although this
// ordering can be trivially changed.
// ??: Should we allow an INI setting to change the order?

BOOL VFWAPI ICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo)
{
#ifdef DEBUG
    BOOL fResult;
#endif
    //
    //  See if there is a 32-bit compressor we can use
    //
    if (ICInfoInternal(fccType, fccHandler, lpicinfo)) {
	return(TRUE);
    }

#ifdef DEBUG
    fResult = (ICInfo32(fccType, fccHandler, lpicinfo));
    DPF(("ICInfo32 returned %s\r\n", (fResult ? "TRUE" : "FALSE")));
    return fResult;
#else
    return (ICInfo32(fccType, fccHandler, lpicinfo));
#endif
}

// Now map ICInfo calls to ICInfoInternal for the duration of the ICInfo
// routine.  This affects the two recursive calls within ICInfo.
#define ICInfo ICInfoInternal

#endif // NT_THUNK16


BOOL VFWAPI ICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo)
{
    LPSTR psz = NULL; // THIS IS ALWAYS an ANSI string pointer!
    TCHAR buf[128];
    TCHAR achKey[20];
    int  i;
    int  iComp;
    PIC  pic;

    if (lpicinfo == NULL)
	return FALSE;

    if (fccType > 0 && fccType < 256) {
	DPF(("fcctype invalid (%d)\n", fccType));
	return FALSE;
    }

    fccType    = Fix4CC(fccType);
    fccHandler = Fix4CC(fccHandler);

    if (fccType != 0 && fccHandler > 256)
    {
	//
	//  the user has given us a specific fccType and fccHandler
	//  get the info and return.
	//
	if (pic = FindConverter(fccType, fccHandler))
	{
	    ICGetInfo((HIC)pic, lpicinfo, sizeof(ICINFO));
	    return TRUE;
	}
	else
	{
	    lpicinfo->dwSize            = sizeof(ICINFO);
	    lpicinfo->fccType           = fccType;
	    lpicinfo->fccHandler        = fccHandler;
	    lpicinfo->dwFlags           = 0;
	    lpicinfo->dwVersionICM      = ICVERSION;
	    lpicinfo->dwVersion         = 0;
	    lpicinfo->szDriver[0]       = 0;
	    lpicinfo->szDescription[0]  = 0;
	    lpicinfo->szName[0]         = 0;
	    DPF(("ICInfo, fccType=%4.4hs, Handler=%4.4hs\n", (LPSTR)&fccType, (LPSTR)&fccHandler));

	    ictokey(fccType, fccHandler, achKey);

	    if (!myGetPrivateProfileString(gszDrivers,achKey,szNull,buf,NUMELMS(buf)) &&
		!myGetPrivateProfileString(gszIniSect,achKey,szNull,buf,NUMELMS(buf)))
	    {
		DPF(("NO information in DRIVERS section\n"));
		return FALSE;
	    }

	    for (i=0; buf[i] && buf[i] != TEXT(' '); ++i)
		lpicinfo->szDriver[i] = buf[i];

	    lpicinfo->szDriver[i] = 0;

	    //
	    // the driver must be opened to get description
	    //
	    lpicinfo->szDescription[0] = 0;

	    return TRUE;
	}
    }
    else
    {
	//
	//  the user has given us a specific fccType and a
	//  ordinal for fccHandler, enum the compressors, looking for
	//  the nth compressor of 'fccType'
	//

	iComp = (int)fccHandler;

	//
	//  walk the installed converters.
	//
	for (i=0; i < giMaxConverters; i++)
	{
	    pic = &aicConverters[i];

	    if (pic->fccType != 0 &&
		(fccType == 0 || pic->fccType == fccType) &&
		pic->dwDriver == 0L && iComp-- == 0)
	    {
		return ICInfo(pic->fccType, pic->fccHandler, lpicinfo);
	    }
	}

	//
	// read all the keys. from [Drivers] and [Instalable Compressors]
	// if we havent read them before.
	//
	// NOTE: what we get back will always be ANSI or WIDE depending
	// on whether UNICODE is defined.  If WIDE, we convert to
	// ANSI before exiting the if statement.
	//

	if (lpICInfoMem == NULL) {
	    if (!ReadDriversInfo())
		return(FALSE);
	}

	// set our pointer psz to point to the beginning of
	// the buffer of INI information we just read.
	// remember that we KNOW that this is ANSI data now.
	//
	//assert (sizeof(*psz) == 1);
	//assert (lpICInfoMem != NULL);

	// loop through the buffer until we get to a double '\0'
	// which indicates the end of the data.
	//
	for (psz = lpICInfoMem; *psz != 0; psz += lstrlenA(psz) + 1)
	{
#if 0       // there can only be valid codec in the memory block
	    if (psz[4] != '.')
		continue;
#endif

	    // convert this piece to lowercase and check to see
	    // if it matches the requested type signature
	    //
	    // NO.  Done when first read.  CharLowerA (psz);

	    // if this is a match, and it's the one we wanted,
	    // return its ICINFO
	    //
	    if ((fccType == 0 || fccType == *(DWORD UNALIGNED FAR *)psz)
	      && iComp-- == 0)
	    {
		return ICInfo(*(DWORD UNALIGNED FAR *)psz,
			      *(DWORD UNALIGNED FAR *)&psz[5],
			      lpicinfo);
	    }
	}

#ifdef DAYTONA
	// If we get to here, then the index is higher than the number
	// of installed compressors.
	//
	// Write the number of compressors found into the structure.
	// This value is used by the NT thunks to pass back to the 16
	// bit side the maximum number of 32 bit compressors.

	lpicinfo->fccHandler = (int)fccHandler-iComp;

// LATER: we MUST enumerate the count of installed msvideo drivers
// as well.  However, lets see if this fixes the Adobe Premiere problem.
#endif

	//
	// now walk the msvideo drivers. these are listed in system.ini
	// like so:
	//
	//      [Drivers]
	//          MSVideo = driver
	//          MSVideo1 = driver
	//          MSVideoN =
	//
	if (fccType == 0 || fccType == ICTYPE_VCAP)
	{
	    lstrcpy(achKey, szMSVideo);

	    if (iComp > 0)
		wsprintf(achKey+lstrlen(achKey), (LPVOID)"%d", iComp);

	    if (!myGetPrivateProfileString(gszDrivers,achKey,szNull,buf,NUMELMS(buf)))
		return FALSE;

	    lpicinfo->dwSize            = sizeof(ICINFO);
	    lpicinfo->fccType           = ICTYPE_VCAP;
	    lpicinfo->fccHandler        = iComp;
	    lpicinfo->dwFlags           = 0;
	    lpicinfo->dwVersionICM      = ICVERSION;    //??? right for video?
	    lpicinfo->dwVersion         = 0;
	    lpicinfo->szDriver[0]       = 0;
	    lpicinfo->szDescription[0]  = 0;
	    lpicinfo->szName[0]         = 0;

	    for (i=0; buf[i] && buf[i] != TEXT(' '); i++)
		lpicinfo->szDriver[i] = buf[i];

	    lpicinfo->szDriver[i] = 0;
	    return TRUE;
	}

	return FALSE;
    }
}
#undef ICInfo

BOOL VFWAPI ICInfoInternal(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo)
{
    return(ICInfo(fccType, fccHandler, lpicinfo));
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICGetInfo | This function obtains information about
 *      a compressor.
 *
 * @parm HIC | hic | Specifies a handle to a compressor.
 *
 * @parm ICINFO FAR * | lpicinfo | Specifies a far pointer to <t ICINFO> structure
 *       used to return information about the compressor.
 *
 * @parm DWORD | cb | Specifies the size, in bytes, of the structure pointed to
 *       by <p lpicinfo>.
 *
 * @rdesc Return the number of bytes copied into the data structure,
 *        or zero if an error occurs.
 *
 * @comm Use <f ICInfo> for full information about a compressor.
 *
 ****************************************************************************/
LRESULT VFWAPI ICGetInfo(HIC hic, ICINFO FAR *picinfo, DWORD cb)
{
    PIC pic = (PIC)hic;
    LRESULT dw;

    V_HIC(hic);

    picinfo->dwSize            = sizeof(ICINFO);
    picinfo->fccType           = 0;
    picinfo->fccHandler        = 0;
    picinfo->dwFlags           = 0;
    picinfo->dwVersionICM      = ICVERSION;
    picinfo->dwVersion         = 0;
    picinfo->szDriver[0]       = 0;
    picinfo->szDescription[0]  = 0;
    picinfo->szName[0]         = 0;

#ifdef NT_THUNK16
    if (!Is32bitHandle(hic))
#endif //NT_THUNK16

    if (pic->hDriver)
    {
       #if defined _WIN32 && ! defined UNICODE
	char szDriver[NUMELMS(picinfo->szDriver)];

	GetModuleFileName (GetDriverModuleHandle (pic->hDriver),
	    szDriver, sizeof(szDriver));

	mmAnsiToWide (picinfo->szDriver, szDriver, NUMELMS(szDriver));
       #else
	GetModuleFileName(GetDriverModuleHandle (pic->hDriver),
	    picinfo->szDriver, sizeof(picinfo->szDriver));
       #endif
    }

    dw = ICSendMessage((HIC)pic, ICM_GETINFO, (DWORD_PTR)picinfo, cb);

    return dw;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICSendMessage | This function sends a
 *      message to a compressor.
 *
 * @parm HIC  | hic  | Specifies the handle of the
 *       compressor to receive the message.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dw1 | Specifies additional message-specific information.
 *
 * @parm DWORD | dw2 | Specifies additional message-specific information.
 *
 * @rdesc Returns a message-specific result.
 ****************************************************************************/
LRESULT VFWAPI ICSendMessage(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    PIC pic = (PIC)hic;
    LRESULT l;

    V_HIC(hic);
#ifdef NT_THUNK16

    //
    // If it's a 32-bit handle then send it to the 32-bit code
    // We need to take some extra care with ICM_DRAW_SUGGESTFORMAT
    // which can include a HIC in the ICDRAWSUGGEST structure.
    //

#define ICD(dw1)  ((ICDRAWSUGGEST FAR *)(dw1))

    if (pic->h32) {
	if ((msg == ICM_DRAW_SUGGESTFORMAT)
	    && (((ICDRAWSUGGEST FAR *)dw1)->hicDecompressor))
	{
	    // We are in the problem area.
	    //   IF the hicDecompressor field is NULL, pass as is.
	    //   IF it identifies a 32 bit decompressor, translate the handle
	    //   OTHERWISE... what?  We have a 32 bit compressor, that is
	    //      being told it can use a 16 bit decompressor!!
	    if ( ((PIC) (((ICDRAWSUGGEST FAR *)dw1)->hicDecompressor))->h32)
	    {
		ICD(dw1)->hicDecompressor
			= (HIC)((PIC)(ICD(dw1)->hicDecompressor))->h32;
	    } else
	    {
		ICD(dw1)->hicDecompressor = NULL;  // Sigh...
	    }

	}
	return ICSendMessage32(pic->h32, msg, dw1, dw2);
    }

#endif //NT_THUNK16

    ICDebugMessage(hic, msg, dw1, dw2);

    l = pic->DriverProc(pic->dwDriver, (HDRVR)1, msg, dw1, dw2);

#if 1 //!!! is this realy needed!  !!!yes I think it is
    //
    // special case some messages and give default values.
    //
    if (l == ICERR_UNSUPPORTED)
    {
	switch (msg)
	{
	    case ICM_GETDEFAULTQUALITY:
		*((LPDWORD)dw1) = ICQUALITY_HIGH;
		l = ICERR_OK;
		break;

	    case ICM_GETDEFAULTKEYFRAMERATE:
		*((LPDWORD)dw1) = 15;
		l = ICERR_OK;
		break;
	}
    }
#endif

    return ICDebugReturn(l);
}

#ifndef _WIN32
/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICMessage | This function sends a
 *      message and a variable number of arguments to a compressor.
 *      If a macro is defined for the message you want to send,
 *      use the macro rather than this function.
 *
 * @parm HIC  | hic  | Specifies the handle of the
 *       compressor to receive the message.
 *
 * @parm UINT | msg | Specifies the message to send.
 *
 * @parm UINT | cb  | Specifies the size, in bytes, of the
 *       optional parameters. (This is usually the size of the data
 *       structure used to store the parameters.)
 *
 * @parm . | . . | Represents the variable number of arguments used
 *       for the optional parameters.
 *
 * @rdesc Returns a message-specific result.
 ****************************************************************************/
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...)
{
    // NOTE no LOADDS!
#ifndef _WIN32
    return ICSendMessage(hic, msg, (DWORD_PTR)(LPVOID)(&cb+1), cb);
#else
    va_list va;

    va_start(va, cb);
    va_end(va);

    // nice try, but doesn't work. va is larger than 4 bytes.
    return ICSendMessage(hic, msg, (DWORD_PTR)va, cb);
#endif
}

// on Win32, ICMessage is not supported. All compman.h macros that call
// it are defined in compman.h as static inline functions

#endif







/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICOpen | This function opens a compressor or decompressor.
 *
 * @parm DWORD | fccType | Specifies the type of compressor
 *      the caller is trying to open.  For video, this is ICTYPE_VIDEO.
 *
 * @parm DWORD | fccHandler | Specifies a single preferred handler of the
 *      given type that should be tried first.  Typically, this comes
 *      from the stream header in an AVI file.
 *
 * @parm UINT | wMode | Specifies a flag to defining the use of
 *       the compressor or decompressor.
 *       This parameter can contain one of the following values:
 *
 * @flag ICMODE_COMPRESS | Advises a compressor it is opened for compression.
 *
 * @flag ICMODE_FASTCOMPRESS | Advise a compressor it is open
 *       for fast (real-time) compression.
 *
 * @flag ICMODE_DECOMPRESS | Advises a decompressor it is opened for decompression.
 *
 * @flag ICMODE_FASTDECOMPRESS | Advises a decompressor it is opened
 *       for fast (real-time) decompression.
 *
 * @flag ICMODE_DRAW | Advises a decompressor it is opened
 *       to decompress an image and draw it directly to hardware.
 *
 * @flag ICMODE_QUERY | Advise a compressor or decompressor it is opened
 *       to obtain information.
 *
 * @rdesc Returns a handle to a compressor or decompressor
 *        if successful, otherwise it returns zero.
 ****************************************************************************/

/* Helper functions for compression library */
HIC VFWAPI ICOpen(DWORD fccType, DWORD fccHandler, UINT wMode)
{
    ICOPEN      icopen;
    ICINFO      icinfo;
    PIC         pic, picT;
    LRESULT     dw;

    ICEnterCrit(&ICOpenCritSec);

    AnsiLowerBuff((LPSTR) &fccType, sizeof(DWORD));
    AnsiLowerBuff((LPSTR) &fccHandler, sizeof(DWORD));
    icopen.dwSize  = sizeof(ICOPEN);
    icopen.fccType = fccType;
    icopen.fccHandler = fccHandler;
    icopen.dwFlags = wMode;
    icopen.dwError = 0;

    DPF(("ICOpen('%4.4hs','%4.4hs)'\r\n", (LPSTR)&fccType, (LPSTR)&fccHandler));

    if (!ICInfo(fccType, fccHandler, &icinfo))
    {
	RPF(("Unable to locate Compression module '%4.4hs' '%4.4hs'\r\n", (LPSTR)&fccType, (LPSTR)&fccHandler));

	ICLeaveCrit(&ICOpenCritSec);

        if((fccHandler == mmioFOURCC('i', 'v', '5', '0') || 
            fccHandler == mmioFOURCC('i', 'v', '4', '1')) &&
           fccType == mmioFOURCC('v', 'i', 'd', 'c'))
        {
            void IndeoAppCompat();
            IndeoAppCompat();
        }
            
	return NULL;
    }

    pic = FindConverter(0L, 0L);

    if (pic == NULL)
    {
	ICLeaveCrit(&ICOpenCritSec);
	return NULL;
    }

#ifdef NT_THUNK16
    // Try and open on the 32 bit side first.
    // This block and the one below can be interchanged to alter the order
    // in which we try and open the compressor.

    pic->dwSmag     = SMAG;
    pic->hTask      = (HTASK)GetCurrentTask();
    pic->h32 = ICOpen32(fccType, fccHandler, wMode);

    if (pic->h32 != 0) {
	pic->fccType    = fccType;
	pic->fccHandler = fccHandler;
	pic->dwDriver   = (DWORD_PTR) -1;
	pic->DriverProc = NULL;
	ICLeaveCrit(&ICOpenCritSec);  // A noop for 16 bit code...but...
	return (HIC)pic;
    }
    // Try and open on the 16 bit side
#endif //NT_THUNK16

    pic->dwSmag     = SMAG;
    pic->hTask      = GetCurrentTask();

    if (icinfo.szDriver[0])
    {
#ifdef DEBUG
	DWORD time = timeGetTime();
	//char ach[80];
#endif
	pic->hDriver = LoadDriver(icinfo.szDriver, &pic->DriverProc);

#ifdef DEBUG
	time = timeGetTime() - time;
	DPF(("ICOPEN: LoadDriver(%ls) (%ldms)  Module Handle==%8x\r\n", (LPSTR)icinfo.szDriver, time, pic->hDriver));
	//wsprintfA(ach, "COMPMAN: LoadDriver(%ls) (%ldms)\r\n", (LPSTR)icinfo.szDriver, time);
	//OutputDebugStringA(ach);
#endif

	if (pic->hDriver == NULL)
	{
	    pic->dwSmag = 0;
	    ICLeaveCrit(&ICOpenCritSec);
	    return NULL;
	}

	//
	// now try to open the driver as a codec.
	//
	pic->dwDriver = ICSendMessage((HIC)pic, DRV_OPEN, 0, (DWORD_PTR)(LPVOID)&icopen);

	//
	//  we want to be able to install 1.0 draw handlers in SYSTEM.INI as:
	//
	//      VIDS.SMAG = SMAG.DRV
	//
	//  but old driver's may not open iff fccType == 'vids' only if
	//  fccType == 'vidc'
	//
	//  they also may not like ICMODE_DRAW
	//
	if (pic->dwDriver == 0 &&
	    icopen.dwError != 0 &&
	    fccType == streamtypeVIDEO)
	{
	    if (wMode == ICMODE_DRAW)
		icopen.dwFlags = ICMODE_DECOMPRESS;

	    icopen.fccType = ICTYPE_VIDEO;
	    pic->dwDriver = ICSendMessage((HIC)pic, DRV_OPEN, 0, (DWORD_PTR)(LPVOID)&icopen);
	}

	if (pic->dwDriver == 0)
	{
	    ICClose((HIC)pic);
	    ICLeaveCrit(&ICOpenCritSec);
	    return NULL;
	}

	// open'ed ok mark these
	pic->fccType    = fccType;
	pic->fccHandler = fccHandler;
    }
    else if (picT = FindConverter(fccType, fccHandler))
    {
	picT->dwSmag = SMAG;
	dw = ICSendMessage((HIC)picT, DRV_OPEN, 0, (DWORD_PTR)(LPVOID)&icopen);

	if (dw == 0)
	{
	    pic->dwSmag = 0;
	    ICLeaveCrit(&ICOpenCritSec);
	    return NULL;
	}

	*pic = *picT;
	pic->dwDriver = dw;
    }

    ICLeaveCrit(&ICOpenCritSec);
    return (HIC)pic;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICOpenFunction | This function opens
 *      a compressor or decompressor defined as a function.
 *
 * @parm DWORD | fccType | Specifies the type of compressor
 *      the caller is trying to open.  For video, this is ICTYPE_VIDEO.
 *
 * @parm DWORD | fccHandler | Specifies a single preferred handler of the
 *      given type that should be tried first.  Typically, this comes
 *      from the stream header in an AVI file.
 *
 * @parm UINT | wMode | Specifies a flag to defining the use of
 *       the compressor or decompressor.
 *       This parameter can contain one of the following values:
 *
 * @flag ICMODE_COMPRESS | Advises a compressor it is opened for compression.
 *
 * @flag ICMODE_FASTCOMPRESS | Advises a compressor it is open
 *       for fast (real-time) compression.
 *
 * @flag ICMODE_DECOMPRESS | Advises a decompressor it is opened for decompression.
 *
 * @flag ICMODE_FASTDECOMPRESS | Advises a decompressor it is opened
 *       for fast (real-time) decompression.
 *
 * @flag ICMODE_DRAW | Advises a decompressor it is opened
 *       to decompress an image and draw it directly to hardware.
 *
 * @flag ICMODE_QUERY | Advises a compressor or decompressor it is opened
 *       to obtain information.
 *
 * @parm FARPROC | lpfnHandler | Specifies a pointer to the function
 *       used as the compressor or decompressor.
 *
 * @rdesc Returns a handle to a compressor or decompressor
 *        if successful, otherwise it returns zero.
 ****************************************************************************/

HIC VFWAPI ICOpenFunction(DWORD fccType, DWORD fccHandler, UINT wMode, FARPROC lpfnHandler)
{
    ICOPEN      icopen;
    PIC         pic;
    LRESULT     dw;

    if (IsBadCodePtr(lpfnHandler))
	return NULL;

#ifdef NT_THUNK16
    // lpfnHandler points to 16 bit code that will be used as a compressor.
    // We do not want this to go over to the 32 bit side, so only open on
    // the 16 bit side.
#endif // NT_THUNK16

    ICEnterCrit(&ICOpenCritSec);

    AnsiLowerBuff((LPSTR) &fccType, sizeof(DWORD));
    AnsiLowerBuff((LPSTR) &fccHandler, sizeof(DWORD));
    icopen.dwSize  = sizeof(ICOPEN);
    icopen.fccType = fccType;
    icopen.fccHandler = fccHandler;
    icopen.dwFlags = wMode;

    pic = FindConverter(0L, 0L);

    if (pic == NULL) {
	ICLeaveCrit(&ICOpenCritSec);
	return NULL;
    }

    pic->dwSmag   = SMAG;
    pic->fccType  = fccType;
    pic->fccHandler  = fccHandler;
    pic->dwDriver = 0L;
    pic->hDriver  = NULL;
    pic->DriverProc  = (DRIVERPROC)lpfnHandler;

    dw = ICSendMessage((HIC)pic, DRV_OPEN, 0, (DWORD_PTR)(LPVOID)&icopen);

    if (dw == 0)
    {
	ICClose((HIC) pic);
	ICLeaveCrit(&ICOpenCritSec);
	return NULL;
    }

    pic->dwDriver = dw;

    ICLeaveCrit(&ICOpenCritSec);
    return (HIC)pic;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICClose | This function closes a compressor or decompressor.
 *
 * @parm HIC | hic | Specifies a handle to a compressor or decompressor.
 *
 * @rdesc Returns ICERR_OK if successful, otherwise it returns an error number.
 *
 ****************************************************************************/

LRESULT VFWAPI ICClose(HIC hic)
{
    PIC pic = (PIC)hic;

    V_HIC(hic);

#ifdef NT_THUNK16
    if (pic->h32 != 0) {
	LRESULT lres = ICClose32(pic->h32);
	pic->h32 = 0;       // Next user of this slot does not want h32 set
	return(lres);
    }
#endif //NT_THUNK16

#ifdef DEBUG
    {
    char ach[80];

    if (pic->hDriver)
	GetModuleFileNameA(GetDriverModuleHandle (pic->hDriver), ach, sizeof(ach));
    else
	ach[0] = 0;

    DPF(("ICClose(%04X) %4.4hs.%4.4hs %s\r\n", hic, (LPSTR)&pic->fccType, (LPSTR)&pic->fccHandler, (LPSTR)ach));
    }
#endif

#ifdef DEBUG
    ICDump();
#endif

    ICEnterCrit(&ICOpenCritSec);

    if (pic->dwDriver)
    {
	if (pic->DriverProc)
	    ICSendMessage((HIC)pic, DRV_CLOSE, 0, 0);
    }

    if (pic->hDriver)
	FreeDriver(pic->hDriver);

    pic->dwSmag   = 0L;
    pic->fccType  = 0L;
    pic->fccHandler  = 0L;
    pic->dwDriver = 0;
    pic->hDriver = NULL;
    pic->DriverProc = NULL;

    ICLeaveCrit(&ICOpenCritSec);

    return ICERR_OK;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

/****************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICCompress | This function compresses a single video
* image.
*
* @parm HIC | hic | Specifies the handle of the compressor to
*       use.
*
* @parm DWORD | dwFlags | Specifies applicable flags for the compression.
*       The following flag is defined:
*
* @flag ICCOMPRESS_KEYFRAME | Indicates that the compressor
*       should make this frame a key frame.
*
* @parm LPBITMAPINFOHEADER | lpbiOutput | Specifies a far pointer
*       to a <t BITMAPINFO> structure holding the output format.
*
* @parm LPVOID | lpData | Specifies a far pointer to output data buffer.
*
* @parm LPBITMAPINFOHEADER | lpbiInput | Specifies a far pointer
*       to a <t BITMAPINFO> structure containing the input format.
*
* @parm LPVOID | lpBits | Specifies a far pointer to the input data buffer.
*
* @parm LPDWORD | lpckid | Not used.
*
* @parm LPDWORD | lpdwFlags | Specifies a far pointer to a <t DWORD>
*       holding the return flags used in the AVI index. The following
*       flag is defined:
*
* @flag AVIIF_KEYFRAME | Indicates this frame should be used as a key-frame.
*
* @parm LONG | lFrameNum | Specifies the frame number.
*
* @parm DWORD | dwFrameSize | Specifies the requested frame size in bytes.
*       If set to zero, the compressor chooses the frame size.
*
* @parm DWORD | dwQuality | Specifies the requested quality value for the frame.
*
* @parm LPBITMAPINFOHEADER | lpbiPrev | Specifies a far pointer to
*       a <t BITMAPINFO> structure holding the previous frame's format.
*       This parameter is not used for fast temporal compression.
*
* @parm LPVOID | lpPrev | Specifies a far pointer to the
*       previous frame's data buffer. This parameter is not used for fast
*       temporal compression.
*
* @comm The <p lpData> buffer should be large enough to hold a compressed
*       frame. You can obtain the size of this buffer by calling
*       <f ICCompressGetSize>.
*
* Set the <p dwFrameSize> parameter to a requested frame
*     size only if the compressor returns the VIDCF_CRUNCH flag in
*     response to <f ICGetInfo>. If this flag is not set, or if a data
*     rate is not specified, set this parameter to zero.
*
*     Set the <p dwQuality> parameter to a quality value only
*     if the compressor returns the VIDCF_QUALITY flag in response
*     to <f ICGetInfo>. Without this flag, set this parameter to zero.
*
* @rdesc This function returns ICERR_OK if successful. Otherwise,
*        it returns an error code.
*
* @xref <f ICCompressBegin> <f ICCompressEnd> <f ICCompressGetSize> <f ICGetInfo>
*
**********************************************************************/
DWORD VFWAPIV ICCompress(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    LPBITMAPINFOHEADER  lpbiOutput,     // output format
    LPVOID              lpData,         // output data
    LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    LPVOID              lpBits,         // frame data to compress
    LPDWORD             lpckid,         // ckid for data in AVI file
    LPDWORD             lpdwFlags,      // flags in the AVI index.
    LONG                lFrameNum,      // frame number of seq.
    DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    DWORD               dwQuality,      // quality
    LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    LPVOID              lpPrev)         // previous frame
{
#ifdef _WIN32
    // We cannot rely on the stack alignment giving us the right layout
    ICCOMPRESS icc;
    icc.dwFlags     =  dwFlags;
    icc.lpbiOutput  =  lpbiOutput;
    icc.lpOutput    =  lpData;
    icc.lpbiInput   =  lpbiInput;
    icc.lpInput     =  lpBits;
    icc.lpckid      =  lpckid;
    icc.lpdwFlags   =  lpdwFlags;
    icc.lFrameNum   =  lFrameNum;
    icc.dwFrameSize =  dwFrameSize;
    icc.dwQuality   =  dwQuality;
    icc.lpbiPrev    =  lpbiPrev;
    icc.lpPrev      =  lpPrev;
    return (DWORD) ICSendMessage(hic, ICM_COMPRESS, (DWORD_PTR)(LPVOID)&icc, sizeof(ICCOMPRESS));
    // NOTE: We do NOT copy any results from this temporary structure back
    // to the input variables.
#else
    return ICSendMessage(hic, ICM_COMPRESS, (DWORD_PTR)(LPVOID)&dwFlags, sizeof(ICCOMPRESS));
#endif
}

/************************************************************************

    decompression functions

************************************************************************/

/*******************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICDecompress | The function decompresses a single video frame.
*
* @parm HIC | hic | Specifies a handle to the decompressor to use.
*
* @parm DWORD | dwFlags | Specifies applicable flags for decompression.
*       The following flags are defined:
*
* @flag ICDECOMPRESS_HURRYUP | Indicates the decompressor should try to
*       decompress at a faster rate. When an application uses this flag,
*       it should not draw the decompressed data.
*
* @flag ICDECOMPRESS_UPDATE | Indicates that the screen is being updated.
*
* @flag ICDECOMPRESS_PREROLL | Indicates that this frame will not actually
*            be drawn, because it is before the point in the movie where play
*            will start.
*
* @flag ICDECOMPRESS_NULLFRAME | Indicates that this frame does not actually
*            have any data, and the decompressed image should be left the same.
*
* @flag ICDECOMPRESS_NOTKEYFRAME | Indicates that this frame is not a
*            key frame.
*
* @parm LPBITMAPINFOHEADER | lpbiFormat | Specifies a far pointer
*       to a <t BITMAPINFO> structure containing the format of
*       the compressed data.
*
* @parm LPVOID | lpData | Specifies a far pointer to the input data.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a far pointer to a
*       <t BITMAPINFO> structure containing the output format.
*
* @parm LPVOID | lpBits | Specifies a far pointer to a data buffer for the
*       decompressed data.
*
* @comm The <p lpBits> parameter should point to a buffer large
*       enough to hold the decompressed data. Applications can obtain
*       the size of this buffer with <f ICDecompressGetSize>.
*
* @rdesc Returns ICERR_OK on success, otherwise it returns an error code.
*
* @xref <f ICDecompressBegin< <f ICDecompressEnd> <f ICDecompressGetSize>
*
********************************************************************/
DWORD VFWAPIV ICDecompress(
    HIC                 hic,
    DWORD               dwFlags,    // flags (from AVI index...)
    LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
				    // biSizeImage has the chunk size
				    // biCompression has the ckid (AVI only)
    LPVOID              lpData,     // data
    LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    LPVOID              lpBits)
{
#ifdef _WIN32
    ICDECOMPRESS icd;
    // We cannot rely on the stack alignment giving us the right layout
    icd.dwFlags    = dwFlags;

    icd.lpbiInput  = lpbiFormat;

    icd.lpInput    = lpData;

    icd.lpbiOutput = lpbi;
    icd.lpOutput   = lpBits;
    icd.ckid       = 0;
    return (DWORD) ICSendMessage(hic, ICM_DECOMPRESS, (DWORD_PTR)(LPVOID)&icd, sizeof(ICDECOMPRESS));
#else
    return ICSendMessage(hic, ICM_DECOMPRESS, (DWORD_PTR)(LPVOID)&dwFlags, sizeof(ICDECOMPRESS));
#endif
}

/************************************************************************

    drawing functions

************************************************************************/

/**********************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICDrawBegin | This function starts decompressing
* data directly to the screen.
*
* @parm HIC | hic | Specifies a handle to the decompressor to use.
*
* @parm DWORD | dwFlags | Specifies flags for the decompression. The
*       following flags are defined:
*
* @flag ICDRAW_QUERY | Determines if the decompressor can handle
*       the decompression.  The driver does not actually decompress the data.
*
* @flag ICDRAW_FULLSCREEN | Tells the decompressor to draw
*       the decompressed data on the full screen.
*
* @flag ICDRAW_HDC | Indicates the decompressor should use the window
*       handle specified by <p hwnd> and the display context
*       handle specified by <p hdc> for drawing the decompressed data.
*
* @flag ICDRAW_ANIMATE | Indicates the palette might be animated.
*
* @flag ICDRAW_CONTINUE | Indicates drawing is a
*       continuation of the previous frame.
*
* @flag ICDRAW_MEMORYDC | Indicates the display context is offscreen.
*
* @flag ICDRAW_UPDATING | Indicates the frame is being
*       updated rather than played.
*
* @parm HPALETTE | hpal | Specifies a handle to the palette used for drawing.
*
* @parm HWND | hwnd | Specifies a handle for the window used for drawing.
*
* @parm HDC | hdc | Specifies the display context used for drawing.
*
* @parm int | xDst | Specifies the x-position of the upper-right
*       corner of the destination rectangle.
*
* @parm int | yDst | Specifies the y-position of the upper-right
*       corner of the destination rectangle.
*
* @parm int | dxDst | Specifies the width of the destination rectangle.
*
* @parm int | dyDst | Specifies the height of the destination rectangle.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a far pointer to
*       a <t BITMAPINFO> structure containing the format of
*       the input data to be decompressed.
*
* @parm int | xSrc | Specifies the x-position of the upper-right corner
*       of the source rectangle.
*
* @parm int | ySrc | Specifies the y-position of the upper-right corner
*       of the source rectangle.
*
* @parm int | dxSrc | Specifies the width of the source rectangle.
*
* @parm int | dySrc | Specifies the height of the source rectangle.
*
* @parm DWORD | dwRate | Specifies the data rate. The
*       data rate in frames per second equals <p dwRate> divided
*       by <p dwScale>.
*
* @parm DWORD | dwScale | Specifies the data rate.
*
* @comm Decompressors use the <p hwnd> and <p hdc> parameters
*       only if an application sets ICDRAW_HDC flag in <p dwFlags>.
*       It will ignore these parameters if an application sets
*       the ICDRAW_FULLSCREEN flag. When an application uses the
*       ICDRAW_FULLSCREEN flag, it should set <p hwnd> and <p hdc>
*       to NULL.
*
*       The destination rectangle is specified only if ICDRAW_HDC is used.
*       If an application sets the ICDRAW_FULLSCREEN flag, the destination
*       rectangle is ignored and its parameters can be set to zero.
*
*       The source rectangle is relative to the full video frame.
*       The portion of the video frame specified by the source
*       rectangle will be stretched to fit in the destination rectangle.
*
* @rdesc Returns ICERR_OK if it can handle the decompression, otherwise
*        it returns ICERR_UNSUPPORTED.
*
* @xref <f ICDraw> <f ICDrawEnd>
*
*********************************************************************/
DWORD VFWAPIV ICDrawBegin(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    HPALETTE            hpal,           // palette to draw with
    HWND                hwnd,           // window to draw to
    HDC                 hdc,            // HDC to draw to
    int                 xDst,           // destination rectangle
    int                 yDst,
    int                 dxDst,
    int                 dyDst,
    LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
    int                 xSrc,           // source rectangle
    int                 ySrc,
    int                 dxSrc,
    int                 dySrc,
    DWORD               dwRate,         // frames/second = (dwRate/dwScale)
    DWORD               dwScale)
{
#ifdef _WIN32
    ICDRAWBEGIN icdraw;
    icdraw.dwFlags   =  dwFlags;
    icdraw.hpal      =  hpal;
    icdraw.hwnd      =  hwnd;
    icdraw.hdc       =  hdc;
    icdraw.xDst      =  xDst;
    icdraw.yDst      =  yDst;
    icdraw.dxDst     =  dxDst;
    icdraw.dyDst     =  dyDst;
    icdraw.lpbi      =  lpbi;
    icdraw.xSrc      =  xSrc;
    icdraw.ySrc      =  ySrc;
    icdraw.dxSrc     =  dxSrc;
    icdraw.dySrc     =  dySrc;
    icdraw.dwRate    =  dwRate;
    icdraw.dwScale   =  dwScale;

    return (DWORD) ICSendMessage(hic, ICM_DRAW_BEGIN, (DWORD_PTR)(LPVOID)&icdraw, sizeof(ICDRAWBEGIN));
#else
    return ICSendMessage(hic, ICM_DRAW_BEGIN, (DWORD_PTR)(LPVOID)&dwFlags, sizeof(ICDRAWBEGIN));
#endif
}

/**********************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICDraw | This function decompress an image for drawing.
*
* @parm HIC | hic | Specifies a handle to an decompressor.
*
* @parm DWORD | dwFlags | Specifies any flags for the decompression.
*       The following flags are defined:
*
* @flag ICDRAW_HURRYUP | Indicates the decompressor should
*       just buffer the data if it needs it for decompression
*       and not draw it to the screen.
*
* @flag ICDRAW_UPDATE | Tells the decompressor to update the screen based
*       on data previously received. Set <p lpData> to NULL when
*       this flag is used.
*
* @flag ICDRAW_PREROLL | Indicates that this frame of video occurs before
*       actual playback should start. For example, if playback is to
*       begin on frame 10, and frame 0 is the nearest previous keyframe,
*       frames 0 through 9 are sent to the driver with the ICDRAW_PREROLL
*       flag set. The driver needs this data so it can displya frmae 10
*       properly, but frames 0 through 9 need not be individually displayed.
*
* @flag ICDRAW_NULLFRAME | Indicates that this frame does not actually
*            have any data, and the previous frame should be redrawn.
*
* @flag ICDRAW_NOTKEYFRAME | Indicates that this frame is not a
*            key frame.
*
* @parm LPVOID | lpFormat | Specifies a far pointer to a
*       <t BITMAPINFOHEADER> structure containing the input
*       format of the data.
*
* @parm LPVOID | lpData | Specifies a far pointer to the actual input data.
*
* @parm DWORD | cbData | Specifies the size of the input data (in bytes).
*
* @parm LONG | lTime | Specifies the time to draw this frame based on the
*       time scale sent with <f ICDrawBegin>.
*
* @comm This function is used to decompress the image data for drawing
* by the decompressor.  Actual drawing of frames does not occur
* until <f ICDrawStart> is called. The application should be sure to
* pre-buffer the required number of frames before drawing is started
* (you can obtain this value with <f ICGetBuffersWanted>).
*
* @rdesc Returns ICERR_OK on success, otherwise it returns an appropriate error
* number.
*
* @xref <f ICDrawBegin> <f ICDrawEnd> <f ICDrawStart> <f ICDrawStop> <f ICGetBuffersRequired>
*
**********************************************************************/
DWORD VFWAPIV ICDraw(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    LPVOID              lpFormat,       // format of frame to decompress
    LPVOID              lpData,         // frame data to decompress
    DWORD               cbData,         // size in bytes of data
    LONG                lTime)          // time to draw this frame (see drawbegin dwRate and dwScale)
{
#ifdef _WIN32
    ICDRAW  icdraw;
    icdraw.dwFlags  =   dwFlags;
    icdraw.lpFormat =   lpFormat;
    icdraw.lpData   =   lpData;
    icdraw.cbData   =   cbData;
    icdraw.lTime    =   lTime;

    return (DWORD) ICSendMessage(hic, ICM_DRAW, (DWORD_PTR)(LPVOID)&icdraw, sizeof(ICDRAW));
#else
    return ICSendMessage(hic, ICM_DRAW, (DWORD_PTR)(LPVOID)&dwFlags, sizeof(ICDRAW));
#endif
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICGetDisplayFormat | This function returns the "best"
 *      format available for displaying a compressed image. The function
 *      will also open a compressor if a handle to an open compressor
 *      is not specified.
 *
 * @parm HIC | hic | Specifies the decompressor that should be used.  If
 *      this is NULL, an appropriate compressor will be opened and returned.
 *
 * @parm LPBITMAPINFOHEADER | lpbiIn | Specifies a pointer to
 *       <t BITMAPINFOHEADER> structure containing the compressed format.
 *
 * @parm LPBITMAPINFOHEADER | lpbiOut | Specifies a pointer
 *       to a buffer used to return the decompressed format.
 *            The buffer should be large enough for a <t BITMAPINFOHEADER>
 *       structure and 256 color entries.
 *
 * @parm int | BitDepth | If non-zero, specifies the preferred bit depth.
 *
 * @parm int | dx | If non-zero, specifies the width to which the image
 *      is to be stretched.
 *
 * @parm int | dy | If non-zero, specifies the height to which the image
 *      is to be stretched.
 *
 * @rdesc Returns a handle to a decompressor if successful, otherwise, it
 *        returns zero.
 ****************************************************************************/

HIC VFWAPI ICGetDisplayFormat(HIC hic, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, int BitDepth, int dx, int dy)
{
    LRESULT dw;
    HDC hdc;
    BOOL fNukeHic = (hic == NULL);
    static int ScreenBitDepth = -1;
    // HACK: We link to some internal DrawDib stuff to find out whether
    // the current display driver is using 565 RGB dibs....
    extern UINT FAR GetBitmapType(VOID);
#define BM_16565        0x06        // most HiDAC cards
#define HACK_565_DEPTH  17

    if (hic == NULL)
	hic = ICDecompressOpen(ICTYPE_VIDEO, 0L, lpbiIn, NULL);

    if (hic == NULL)
	return NULL;

    //
    // dx = 0 and dy = 0 means don't stretch.
    //
    if (dx == (int)lpbiIn->biWidth && dy == (int)lpbiIn->biHeight)
	dx = dy = 0;

    //
    // ask the compressor if it likes the format.
    //
    dw = ICDecompressQuery(hic, lpbiIn, NULL);

    if (dw != ICERR_OK)
    {
	DPF(("Decompressor did not recognize the input data format\r\n"));
	goto error;
    }

try_again:
    //
    //  ask the compressor first. (so it can set the palette)
    //  this is a HACK, we will send the ICM_GET_PALETTE message later.
    //
    dw = ICDecompressGetFormat(hic, lpbiIn, lpbiOut);

    //
    // init the output format
    //
    *lpbiOut = *lpbiIn;
    lpbiOut->biSize = sizeof(BITMAPINFOHEADER);
    lpbiOut->biCompression = BI_RGB;

    //
    // default to the screen depth.
    //
    if (BitDepth == 0)
    {
	if (ScreenBitDepth < 0)
	{
	    hdc = GetDC(NULL);
	    ScreenBitDepth = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
	    ReleaseDC(NULL, hdc);

	    if (ScreenBitDepth == 15)
		ScreenBitDepth = 16;

	    if (ScreenBitDepth < 8)
		ScreenBitDepth = 8;

	    //
	    // only try 16 bpp if the display supports drawing it.
	    //
	    if (ScreenBitDepth == 16)
	    {
		lpbiOut->biBitCount = 16;

		if (!DrawDibProfileDisplay(lpbiOut))
		    ScreenBitDepth = 24;
	    }

	    if (ScreenBitDepth > 24)
	    {
		lpbiOut->biBitCount = 32;

		if (!DrawDibProfileDisplay(lpbiOut))
		    ScreenBitDepth = 24;
	    }

	    if (ScreenBitDepth == 16 && GetBitmapType() == BM_16565) {
		// If the display is really 565, take this into account.
		ScreenBitDepth = HACK_565_DEPTH;
	    }
	}
#ifdef DEBUG
	ScreenBitDepth = mmGetProfileIntA("DrawDib",
				       "ScreenBitDepth",
				       ScreenBitDepth);
#endif
	BitDepth = ScreenBitDepth;
    }

    //
    //  always try 8bit first for '8' bit data
    //
    if (lpbiIn->biBitCount == 8)
	BitDepth = 8;

    //
    // lets suggest a format to the device.
    //
try_bit_depth:
    if (BitDepth != HACK_565_DEPTH) {
	lpbiOut->biSize = sizeof(BITMAPINFOHEADER);
	lpbiOut->biCompression = BI_RGB;
	lpbiOut->biBitCount = (WORD) BitDepth;
    } else {
#ifndef BI_BITFIELDS
#define BI_BITFIELDS  3L
#endif
	// For RGB565, we need to use BI_BITFIELDS.
	lpbiOut->biSize = sizeof(BITMAPINFOHEADER);
	lpbiOut->biCompression = BI_BITFIELDS;
	lpbiOut->biBitCount = 16;
	((LPDWORD)(lpbiOut+1))[0] = 0x00F800;
	((LPDWORD)(lpbiOut+1))[1] = 0x0007E0;
	((LPDWORD)(lpbiOut+1))[2] = 0x00001F;
	// Set lpbiOut->biClrUsed = 3?
    }

    //
    // should we suggest a stretched decompress
    //
    if (dx > 0 && dy > 0)
    {
	lpbiOut->biWidth  = dx;
	lpbiOut->biHeight = dy;
    }

    lpbiOut->biSizeImage = (DWORD)(UINT)DIBWIDTHBYTES(*lpbiOut) *
			   (DWORD)(UINT)lpbiOut->biHeight;

    //
    // ask the compressor if it likes the suggested format.
    //
    dw = ICDecompressQuery(hic, lpbiIn, lpbiOut);

    //
    // if it likes it then return success.
    //
    if (dw == ICERR_OK)
	goto success;

//  8:   8, 16,24,32,X
//  16:  16,565,24,32,X
//  565: 565,16,24,32,X
//  24:  24,32,16,X
//  32:  32,24,16,X

    //
    // try another bit depth in this order 8,16,RGB565,24,32
    //
    if (BitDepth <= 8)
    {
	BitDepth = 16;
	goto try_bit_depth;
    }

    if (ScreenBitDepth == HACK_565_DEPTH) {
	// If the screen is RGB565, we try 565 before 555.
	if (BitDepth == 16) {
	    BitDepth = 24;
	    goto try_bit_depth;
	}

	if (BitDepth == HACK_565_DEPTH) {
	    BitDepth = 16;
	    goto try_bit_depth;
	}
    }

    if (BitDepth == 16) {
	// otherwise, we try 565 after 555.
	BitDepth = HACK_565_DEPTH;
	goto try_bit_depth;
    }

    if (BitDepth == HACK_565_DEPTH) {
	BitDepth = 24;
	goto try_bit_depth;
    }
	
    if (BitDepth == 24)
    {
	BitDepth = 32;
	goto try_bit_depth;
    }

    if (BitDepth != 32)
    {
	BitDepth = 32;
	goto try_bit_depth;
    }

    if (dx > 0 && dy > 0)
    {
#ifndef DAYTONA // it is not clear that this is correct for Daytona
		// while we work it out disable the code, but match blues
		// as closely as possible.
	//
	// If it's already stretched "pretty big", try decompressing
	// stretched by two, and then stretching/shrinking from there.
	// Otherwise, give up and try decompressing normally.
	//
	if ((dx > (lpbiIn->biWidth * 3) / 2) &&
	    (dy > (lpbiIn->biHeight * 3) / 2) &&
	    ((dx != lpbiIn->biWidth * 2) || (dy != lpbiIn->biHeight * 2))) {
	    dx = (int) lpbiIn->biWidth * 2;
	    dy = (int) lpbiIn->biHeight * 2;
	} else {
	    dx = 0;
	    dy = 0;
	}
	
	//
	// try to find a non stretched format.  but don't let the
	// device dither if we are going to stretch!
	//  - note that this only applies for palettised displays.
	// for 16-bit displays we need to restart to ensure we get the
	// right format (555, 565). On 4-bit displays we can also restart
	// (ask DavidMay about the 4-bit cases).
	//
	    BitDepth = 0;
#else
	    dx = 0;
	    dy = 0;
	    if ((lpbiIn->biBitCount > 8) && (ScreenBitDepth == 8))
		BitDepth = 16;
	    else
		BitDepth = 0;
#endif

	goto try_again;
    }
    else
    {
	//
	// let the compressor suggest a format
	//
	dw = ICDecompressGetFormat(hic, lpbiIn, lpbiOut);

	if (dw == ICERR_OK)
	    goto success;
    }

error:
    if (hic && fNukeHic)
	ICClose(hic);

    return NULL;

success:
    if (lpbiOut->biBitCount == 8)
	ICDecompressGetPalette(hic, lpbiIn, lpbiOut);

    return hic;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICLocate | This function finds a compressor or decompressor
 *      that can handle images with the formats specified, or it finds a
 *      driver that can decompress an image with a specified
 *      format directly to hardware. Applications must close the
 *      compressor when it has finished using the compressor.
 *
 * @parm DWORD | fccType | Specifies the type of compressor
 *      the caller is trying to open.  For video, this is ICTYPE_VIDEO.
 *
 * @parm DWORD | fccHandler | Specifies a single preferred handler of the
 *      given type that should be tried first.  Typically, this comes
 *      from the stream header in an AVI file.
 *
 * @parm LPBITMAPINFOHEADER | lpbiIn | Specifies a pointer to
 *       <t BITMAPINFOHEADER> structure defining the input format.
 *            A compressor handle will not be returned unless it
 *       can handle this format.
 *
 * @parm LPBITMAPINFOHEADER | lpbiOut | Specifies zero or a pointer to
 *       <t BITMAPINFOHEADER> structure defining an optional decompressed
 *            format. If <p lpbiOut> is nonzero, a compressor handle will not
 *       be returned unless it can create this output format.
 *
 * @parm WORD | wFlags | Specifies a flag to defining the use of the compressor.
 *       This parameter must contain one of the following values:
 *
 * @flag ICMODE_COMPRESS | Indicates the compressor should
 *       be able to compress an image with a format defined by <p lpbiIn>
 *       to the format defined by <p lpbiOut>.
 *
 * @flag ICMODE_DECOMPRESS | Indicates the decompressor should
 *       be able to decompress an image with a format defined by <p lpbiIn>
 *       to the format defined by <p lpbiOut>.
 *
 * @flag ICMODE_FASTDECOMPRESS | Has the same definition as ICMODE_DECOMPRESS except the
 *       decompressor is being used for a real-time operation and should trade off speed
 *       for quality if possible.
 *
 * @flag ICMODE_FASTCOMPRESS | Has the same definition as ICMODE_COMPRESS except the
 *       compressor is being used for a real-time operation and should trade off speed
 *       for quality if possible.
 *
 * @flag ICMODE_DRAW | Indicates the decompressor should
 *       be able to decompress an image with a format defined by <p lpbiIn>
 *       and draw it directly to hardware.
 *
 * @rdesc Returns a handle to a compressor or decompressor
 *        if successful, otherwise it returns zero.
 ****************************************************************************/
HIC VFWAPI ICLocate(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags)
{
    HIC hic=NULL;
    int i;
    ICINFO icinfo;
    UINT msg;

    if (fccType == 0)
	return NULL;

    switch (wFlags)
    {
	case ICMODE_FASTCOMPRESS:
	case ICMODE_COMPRESS:
	    msg = ICM_COMPRESS_QUERY;
	    break;

	case ICMODE_FASTDECOMPRESS:
	case ICMODE_DECOMPRESS:
	    msg = ICM_DECOMPRESS_QUERY;
	    break;

	case ICMODE_DRAW:
	    msg = ICM_DRAW_QUERY;
	    break;

	default:
	    return NULL;
    }

    if (fccHandler)
    {
	hic = ICOpen(fccType, fccHandler, wFlags);

	if (hic && ICSendMessage(hic, msg, (DWORD_PTR)lpbiIn, (DWORD_PTR)lpbiOut) == ICERR_OK)
	    return hic;
	else if (hic)
	    ICClose(hic);
    }

    if (fccType == ICTYPE_VIDEO && lpbiIn)
    {
	DWORD fccHandler = lpbiIn->biCompression;

	// They're decompressed already.. use our RLE handler so we don't
	// waste time looking for a decompressor or fail and think we don't
	// support these formats!
	if (fccHandler == BI_RLE8 || fccHandler == BI_RGB)
	    fccHandler = mmioFOURCC('M', 'R', 'L', 'E');

	if (fccHandler > 256)
	{
	    if (fccHandler == mmioFOURCC('C', 'R', 'A', 'M'))
		fccHandler = mmioFOURCC('M', 'S', 'V', 'C');
	
	    hic = ICOpen(fccType, fccHandler, wFlags);

	    if (hic && ICSendMessage(hic, msg, (DWORD_PTR)lpbiIn, (DWORD_PTR)lpbiOut) == ICERR_OK)
		return hic;
	    else if (hic)
		ICClose(hic);
	}
    }

    //
    // Search through all of the compressors, to see if one can do what we
    // want.
    //
    for (i=0; ICInfo(fccType, i, &icinfo); i++)
    {
      // Protect against arbitrary 3rd party code crashing us
      try {
	hic = ICOpen(fccType, icinfo.fccHandler, wFlags);

	if (hic == NULL)
	    continue;

	if (ICSendMessage(hic, msg, (DWORD_PTR)lpbiIn, (DWORD_PTR)lpbiOut) != ICERR_OK)
	{
	    ICClose(hic);
	    continue;
	}
	} except (EXCEPTION_EXECUTE_HANDLER) {
	    if (hic) {
		ICClose(hic);
		hic = NULL;
	    }
	}
	if (hic) {
	    return hic;
	}
	return hic;
    }

    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api HDRVR | LoadDriver | load a driver
 *
 * Note: on chicago, the string szDriver may not be longer than
 *       the number of characters in ICINFO.szDriver
 *
 ****************************************************************************/
#if defined _WIN32
STATICFN HDRVR LoadDriver(LPWSTR szDriver, DRIVERPROC FAR *lpDriverProc)
#else
STATICFN HDRVR LoadDriver(LPSTR szDriver, DRIVERPROC FAR *lpDriverProc)
#endif
{
    HMODULE hModule;
    UINT u;
    DRIVERPROC DriverProc;
    BOOL fWow;
    HDRVR hDriver;

    fWow = IsWow();

    if (fWow)
    {
	u = SetErrorMode(SEM_NOOPENFILEERRORBOX);

       #if defined _WIN32 && ! defined UNICODE
	{
	char ach[NUMELMS(((ICINFO *)0)->szDriver)]; // same size as PICINFO.szDriver

	hModule = LoadLibrary (mmWideToAnsi(ach, szDriver, NUMELMS(ach)));
	}
       #else
	hModule = LoadLibrary(szDriver);
       #endif

	SetErrorMode(u);

	if (hModule <= (HMODULE)HINSTANCE_ERROR)
	    return NULL;
	hDriver = (HDRVR) hModule;
    }
    else
    {
	hDriver = OpenDriver (szDriver, NULL, 0);
	if (!hDriver)
	    return NULL;
	hModule = GetDriverModuleHandle (hDriver);
    }
    DPF(("LoadDriver: %ls, handle %8x   hModule %8x\n", szDriver, hDriver, hModule));

    DriverProc = (DRIVERPROC)GetProcAddress(hModule, szDriverProc);

    if (DriverProc == NULL)
    {
	if (fWow)
	{
	    FreeLibrary(hModule);
	}
	else
	{
	    CloseDriver (hDriver, 0L, 0L);
	}
	DPF(("Freeing library %8x as no driverproc found\r\n",hModule));
	return NULL;
    }

#if ! defined _WIN32
    if (fWow && GetModuleUsage(hModule) == 1)   //!!!this is not exacly like USER
    {
	if (!DriverProc(0, (HDRVR)1, DRV_LOAD, 0L, 0L))
	{
	    DPF(("Freeing library %8x as driverproc returned an error\r\n",hModule));
	    FreeLibrary(hModule);
	    return NULL;
	}

	DriverProc(0, (HDRVR)1, DRV_ENABLE, 0L, 0L);
    }

    CacheModule (hModule);
#endif

    *lpDriverProc = DriverProc;
    return hDriver;
}

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api void | FreeDriver | unload a driver
 *
 ****************************************************************************/

STATICFN void FreeDriver(HDRVR hDriver)
{
    if (!IsWow())
    {
	DPF(("FreeDriver, driver handle is %x\n", hDriver));
	CloseDriver (hDriver, 0L, 0L);
    }
#ifndef _WIN32
    else
    {
	// This cannot be WIN32 code due to the definition of IsWow()
	if (GetModuleUsage((HMODULE) hDriver) == 1)
	{
	    DRIVERPROC DriverProc;

	    DriverProc = (DRIVERPROC)GetProcAddress((HMODULE) hDriver, szDriverProc);

	    if (DriverProc)
	    {
		DriverProc(0, (HDRVR)1, DRV_DISABLE, 0L, 0L);
		DriverProc(0, (HDRVR)1, DRV_FREE, 0L, 0L);
	    }
	}

	FreeLibrary((HMODULE) hDriver);
	DPF(("Freeing library %8x in FreeDriver\r\n",hDriver));
    }
#endif
}

#ifdef DEBUG_RETAIL

/************************************************************************

    messages.

************************************************************************/

static const struct {
    UINT  msg;
    char *szMsg;
}   aMsg[] = {

DRV_OPEN                        , "DRV_OPEN",
DRV_CLOSE                       , "DRV_CLOSE",
ICM_GETSTATE                    , "ICM_GETSTATE",
ICM_SETSTATE                    , "ICM_SETSTATE",
ICM_GETINFO                     , "ICM_GETINFO",
ICM_CONFIGURE                   , "ICM_CONFIGURE",
ICM_ABOUT                       , "ICM_ABOUT",
ICM_GETERRORTEXT                , "ICM_GETERRORTEXT",
ICM_GETFORMATNAME               , "ICM_GETFORMATNAME",
ICM_ENUMFORMATS                 , "ICM_ENUMFORMATS",
ICM_GETDEFAULTQUALITY           , "ICM_GETDEFAULTQUALITY",
ICM_GETQUALITY                  , "ICM_GETQUALITY",
ICM_SETQUALITY                  , "ICM_SETQUALITY",
ICM_COMPRESS_GET_FORMAT         , "ICM_COMPRESS_GET_FORMAT",
ICM_COMPRESS_GET_SIZE           , "ICM_COMPRESS_GET_SIZE",
ICM_COMPRESS_QUERY              , "ICM_COMPRESS_QUERY",
ICM_COMPRESS_BEGIN              , "ICM_COMPRESS_BEGIN",
ICM_COMPRESS                    , "ICM_COMPRESS",
ICM_COMPRESS_END                , "ICM_COMPRESS_END",
ICM_DECOMPRESS_GET_FORMAT       , "ICM_DECOMPRESS_GET_FORMAT",
ICM_DECOMPRESS_QUERY            , "ICM_DECOMPRESS_QUERY",
ICM_DECOMPRESS_BEGIN            , "ICM_DECOMPRESS_BEGIN",
ICM_DECOMPRESS                  , "ICM_DECOMPRESS",
ICM_DECOMPRESS_END              , "ICM_DECOMPRESS_END",
ICM_DECOMPRESS_GET_PALETTE      , "ICM_DECOMPRESS_GET_PALETTE",
ICM_DECOMPRESS_SET_PALETTE      , "ICM_DECOMPRESS_SET_PALETTE",
ICM_DECOMPRESSEX_QUERY          , "ICM_DECOMPRESSEX_QUERY",
ICM_DECOMPRESSEX_BEGIN          , "ICM_DECOMPRESSEX_BEGIN",
ICM_DECOMPRESSEX                , "ICM_DECOMPRESSEX",
ICM_DECOMPRESSEX_END            , "ICM_DECOMPRESSEX_END",
ICM_DRAW_QUERY                  , "ICM_DRAW_QUERY",
ICM_DRAW_BEGIN                  , "ICM_DRAW_BEGIN",
ICM_DRAW_GET_PALETTE            , "ICM_DRAW_GET_PALETTE",
ICM_DRAW_UPDATE                 , "ICM_DRAW_UPDATE",
ICM_DRAW_START                  , "ICM_DRAW_START",
ICM_DRAW_STOP                   , "ICM_DRAW_STOP",
ICM_DRAW_BITS                   , "ICM_DRAW_BITS",
ICM_DRAW_END                    , "ICM_DRAW_END",
ICM_DRAW_GETTIME                , "ICM_DRAW_GETTIME",
ICM_DRAW                        , "ICM_DRAW",
ICM_DRAW_WINDOW                 , "ICM_DRAW_WINDOW",
ICM_DRAW_SETTIME                , "ICM_DRAW_SETTIME",
ICM_DRAW_REALIZE                , "ICM_DRAW_REALIZE",
ICM_GETBUFFERSWANTED            , "ICM_GETBUFFERSWANTED",
ICM_GETDEFAULTKEYFRAMERATE      , "ICM_GETDEFAULTKEYFRAMERATE",
0                               , NULL
};

static const struct {
    LRESULT err;
    char *szErr;
}   aErr[] = {

ICERR_DONTDRAW              , "ICERR_DONTDRAW",
ICERR_NEWPALETTE            , "ICERR_NEWPALETTE",
ICERR_UNSUPPORTED           , "ICERR_UNSUPPORTED",
ICERR_BADFORMAT             , "ICERR_BADFORMAT",
ICERR_MEMORY                , "ICERR_MEMORY",
ICERR_INTERNAL              , "ICERR_INTERNAL",
ICERR_BADFLAGS              , "ICERR_BADFLAGS",
ICERR_BADPARAM              , "ICERR_BADPARAM",
ICERR_BADSIZE               , "ICERR_BADSIZE",
ICERR_BADHANDLE             , "ICERR_BADHANDLE",
ICERR_CANTUPDATE            , "ICERR_CANTUPDATE",
ICERR_ERROR                 , "ICERR_ERROR",
ICERR_BADBITDEPTH           , "ICERR_BADBITDEPTH",
ICERR_BADIMAGESIZE          , "ICERR_BADIMAGESIZE",
ICERR_OK                    , "ICERR_OK"
};

STATICDT BOOL  cmfDebug = -1;
STATICDT DWORD dwTime;

void ICDebugMessage(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    int i;

    if (!cmfDebug)
	return;

    for (i=0; aMsg[i].msg && aMsg[i].msg != msg; i++)
	;

    if (aMsg[i].msg == 0)
	RPF(("ICM(%04X,ICM_%04X,%08lX,%08lX) ", hic, msg, dw1, dw2));
    else
	RPF(("ICM(%04X,%s,%08lX,%08lX) ", hic, (LPSTR)aMsg[i].szMsg, dw1, dw2));

    dwTime = timeGetTime();
}

LRESULT ICDebugReturn(LRESULT err)
{
    int i;

    if (!cmfDebug)
	return err;

    dwTime = timeGetTime() - dwTime;

    for (i=0; aErr[i].err && aErr[i].err != err; i++)
	;

    if (aErr[i].err != err)
	RPF(("! : 0x%08lX (%ldms)\r\n", err, dwTime));
    else
	RPF(("! : %s (%ldms)\r\n", (LPSTR)aErr[i].szErr, dwTime));

    return err;
}

STATICFN void ICDump()
{
    int i;
    PIC pic;
    TCHAR ach[80];

    DPF(("ICDump ---------------------------------------\r\n"));

    for (i=0; i<giMaxConverters; i++)
    {
	pic = &aicConverters[i];

	if (pic->fccType == 0)
	    continue;

	if (pic->dwSmag == 0)
	    continue;

	if (pic->hDriver)
	    GetModuleFileName(GetDriverModuleHandle (pic->hDriver), ach, NUMELMS(ach));
	else
	    ach[0] = 0;

#ifdef _WIN32
	DPF(("  HIC: %04X %4.4hs.%4.4hs hTask=%04X Proc=%08lx %ls\r\n", (HIC)pic, (LPSTR)&pic->fccType, (LPSTR)&pic->fccHandler, pic->hTask, pic->DriverProc, ach));
#else
	DPF(("  HIC: %04X %4.4s.%4.4s hTask=%04X Proc=%08lx %s\r\n", (HIC)pic, (LPSTR)&pic->fccType, (LPSTR)&pic->fccHandler, pic->hTask, pic->DriverProc, (LPSTR)ach));
#endif
    }

    DPF(("----------------------------------------------\r\n"));
}

#endif

/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * COMPMAN=1
 *
 ****************************************************************************/

char szDebug[] = "Debug";
#ifdef DEBUG_RETAIL


STATICFN void cdecl dprintfc(LPSTR szFormat, ...)
{
    char ach[128];

#ifdef _WIN32
    va_list va;
    if (cmfDebug == -1)
	cmfDebug = mmGetProfileIntA(szDebug, MODNAME, 0);

    if (!cmfDebug)
	return;

    va_start(va, szFormat);
    if (szFormat[0] == '!')
	ach[0]=0, szFormat++;
    else
	wsprintfA(ach, "%s: (tid %x) ", MODNAME, GetCurrentThreadId());

    wvsprintfA(ach+lstrlenA(ach),szFormat,va);
    va_end(va);
//  lstrcatA(ach, "\r\r\n");
#else  // Following is WIN16 code...
    if (cmfDebug == -1)
	cmfDebug = GetProfileIntA("Debug",MODNAME, 0);

    if (!cmfDebug)
	return;

    if (szFormat[0] == '!')
	ach[0]=0, szFormat++;
    else
	lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)(&szFormat+1));
//  lstrcatA(ach, "\r\r\n");
#endif

    OutputDebugStringA(ach);
}

#endif

#ifdef _WIN32
#define FADMIN_NOT_CACHED 15
int fIsAdmin = FADMIN_NOT_CACHED;   // any arbitrary value that will not be TRUE or FALSE
BOOL IsAdmin(void)
{
    BOOL IsMember;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID        AdminSid;

#ifdef DEBUG_RETAIL
    // see if we should run as a normal user.
    // ADMINs can pretend to be normal users; vice versa does not work
    // Hence you have to pass the security checks below to be recognised
    // as an admin
    if (mmGetProfileIntA(MODNAME, "NormalUser", FALSE)) {
	DPF(("Forcing NON admin"));
	return(FALSE);
    }
#endif

    // If we have cached a value, return the cached value
    if (FADMIN_NOT_CACHED != fIsAdmin) {
	return(fIsAdmin);
    }

    if (!AllocateAndInitializeSid(&sia,                            // identifier authority
				  2,                               // subauthority count
				  SECURITY_BUILTIN_DOMAIN_RID,     // subauthority 0
				  DOMAIN_ALIAS_RID_ADMINS,         // subauthority 1
				  0,0,0,0,0,0,                     // subauthority 2-7
				  &AdminSid)) {                     // result target
	//
	// Failed, don't assume we are an admin.
	//

	return FALSE;
    } else if (!CheckTokenMembership(NULL,
				AdminSid,
				&IsMember)) {
	//
	// Failed, don't assume we are an admin.
	//

	FreeSid(AdminSid);

	return FALSE;
    } else {
	//
	// We have a definitive answer, set the cached value.
	//

	fIsAdmin = IsMember;

	FreeSid(AdminSid);
	
	return fIsAdmin;
    }

    // NOT REACHED

    return FALSE;
}
#endif // _WIN32

#ifdef DAYTONA

#define KEYSECTION TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\")


LONG OpenUserKey(PHKEY pKey, LPCTSTR lp, LPCTSTR pSection)
{
    DWORD disposition;
    TCHAR section[256];
    lstrcpy(section, KEYSECTION);
    lstrcat(section, pSection);
    if (lp) {
	// Note: we should never need to create the user section in order
	// to query the data.  If the section does not exist, then nothing is
	// the right thing to return.
	return(RegCreateKeyExW(HKEY_CURRENT_USER, section, 0, NULL, 0,
				    KEY_SET_VALUE, NULL, pKey, &disposition));
    } else {
	// We are only reading what is there...
	return(RegOpenKeyExW(HKEY_CURRENT_USER, section, 0, KEY_QUERY_VALUE, pKey));
    }
}

LONG OpenSystemKey(PHKEY pKey, LPCTSTR lp, LPCTSTR pSection)
{
    DWORD disposition;
    TCHAR section[256];
    lstrcpy(section, KEYSECTION);
    lstrcat(section, pSection);
    if (lp) {
	return(RegCreateKeyExW(HKEY_LOCAL_MACHINE, section, 0, NULL, 0,
		    KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, pKey, &disposition));
    } else {
	// We are only reading what is there...
	return(RegOpenKeyExW(HKEY_LOCAL_MACHINE, section, 0, KEY_QUERY_VALUE, pKey));
    }
}


// Use a mapping to get the stuff into the registry
BOOL myWritePrivateProfileString(

    LPCTSTR  lpszSection,       // address of section name
    LPCTSTR  lpszKeyName,       // address of key name
    LPCTSTR  lpszString         // address of string to add
)
{
	if (IsAdmin()) {
	    return WritePrivateProfileString(lpszSection, lpszKeyName, lpszString, gszSystemIni);
	} else /* NOT ADMIN */ {
	    // write to HKEY_CURRENT_USER
	    // Data is written to

	    HKEY key;

	    // If we have something to write, then we must create the key
	    // If we are about to delete something that might not exist we only
	    // want to open the key.  Hence OpenUserKey needs to know if lpszString is NULL
	    if (ERROR_SUCCESS == OpenUserKey(&key, lpszString, lpszSection)) {
		
		// We have access.  Now write the data
		if (lpszString) {
		    LPCTSTR lpStr;
		    RegSetValueEx(key, lpszKeyName, 0, REG_SZ,
			(LPCVOID)lpszString, sizeof(TCHAR)*(lstrlen(lpszString)+1));
		    lpStr = lpszString + 1 + lstrlen(lpszString);

		    // Is there an associated description ??
		    if (*(lpStr)) {
			HKEY key2;
			DWORD disposition;
			TCHAR section[256];
			// Write the description
			lstrcpy(section, KEYSECTION);
			lstrcat(section, TEXT("Drivers.desc"));
			if (ERROR_SUCCESS ==
			    (RegCreateKeyExW(HKEY_CURRENT_USER, section, 0, NULL, 0,
						KEY_SET_VALUE, NULL, &key2, &disposition))) {

			    RegSetValueEx(key2, lpszString, 0, REG_SZ,
				(LPCVOID)lpStr, sizeof(TCHAR)*(lstrlen(lpStr)+1));
			    RegCloseKey(key2);
			}
		    }
		} else {
		    // delete the data
		    RegDeleteValue(key, lpszKeyName);
		}

		RegCloseKey(key);
		return(TRUE);
	    }
	    return(FALSE);
	}

}


DWORD myGetPrivateProfileString(

    LPCTSTR  lpszSection,       // address of section name
    LPCTSTR  lpszKey,           // address of key name
    LPCTSTR  lpszDefault,       // address of default string
    LPTSTR  lpszReturnBuffer,   // address of destination buffer
    DWORD  cchReturnBuffer)     // size of destination buffer
{
    // Whether we are an admin or not we have to read data from HKEY_CURRENT_USER
    // first as that overrides the SYSTEM installed details.
    // If we are enumerating the section, then we want to delete duplicate definitions
    // in the system block.  This is where the complexity enters.

    DWORD dwType;
    HKEY key;
    UINT nSize;
    UINT nRet=ERROR_NO_MORE_ITEMS;
    LPTSTR lpBuf;
    LPVOID lpEnd;
    UINT size = cchReturnBuffer * sizeof(TCHAR);

    lpBuf = lpszReturnBuffer;
    lpEnd = ((LPBYTE)lpBuf)+size;

#define CUSERDRIVERS 20

    if (!lpszKey) {

	// Will enumerate the list of installed drivers - first USER
	// then SYSTEM.  User installed drivers take precendence (if
	// there is duplication).  We used to read the whole section,
	// but we are only interested in fcctype.fcchandler type entries.
	// Therefore, any that do not match this pattern are skipped.

	UINT   cch1, count;
	TCHAR section[256];
	LPTSTR aszUserDrivers[CUSERDRIVERS];
	UINT cUserDrivers=0;
	UINT iKey;

#ifdef DEBUG
	memset(lpszReturnBuffer, 0xfe, cchReturnBuffer*sizeof(TCHAR));
	// verify that we do not write more data than we should
#endif

#if 0
// This is the old code.  Use this to verify that the registry enumeration is
// correct.
	// Check that the registry enumeration code produces the same result
	cch1 = GetPrivateProfileString(lpszSection, lpszKey, lpszDefault,
			    lpszReturnBuffer, cchReturnBuffer, gszSystemIni);
#endif
	// Read the user section
	// then read the system section, skipping codecs already found
	if (ERROR_SUCCESS == OpenUserKey(&key, NULL, lpszSection)) {

	    for (iKey = 0; ; ++iKey) {

		// Calculate - in characters - how much space is left in the
		// name buffer
		nSize = (UINT) (UINT_PTR) ((LPTSTR)lpEnd-lpBuf);

		// Enumerate the name.  We do not at this point need the values
		// associated with the names, only the list of installed driver types
		nRet = RegEnumValue(key, iKey, lpBuf, &nSize, NULL,
			    &dwType, NULL, NULL);
		if (nRet!= ERROR_SUCCESS) break;  // bail out

		// If this is not xxxx.yyyy then ignore it.
		if ((nSize != sizeof(FOURCC)+sizeof(FOURCC)+1)
		   || (lpBuf[4] != TEXT('.')))
		{
		    continue;
		}
		
		if (cUserDrivers<CUSERDRIVERS) {
		    // Remember the name of this driver
		    aszUserDrivers[cUserDrivers++] = lpBuf;
		} else {
		    // Too many user installed drivers... let there be duplicates
		}
		lpBuf += nSize+1;  // Step over this name and its terminating null
	    }
	    RegCloseKey(key);
	}

	// Unless we ran out of room we need to read the system section
	if (nRet == ERROR_NO_MORE_ITEMS)
	if (ERROR_SUCCESS == OpenSystemKey(&key, NULL, lpszSection)) {

	    for (iKey = 0; ; ++iKey) {

		// Calculate - in characters - how much space is left in the
		// name buffer
		nSize = (DWORD) (DWORD_PTR) ((LPTSTR)lpEnd-lpBuf);

		// Enumerate the name.  We do not at this point need the values
		// associated with the names, only the list of installed driver types
		nRet = RegEnumValue(key, iKey, lpBuf, &nSize, NULL,
			    &dwType, NULL, NULL);
		if (nRet!= ERROR_SUCCESS) break;  // bail out

		// If this is not xxxx.yyyy then ignore it.
		if (nSize != sizeof(FOURCC)+sizeof(FOURCC)+1) {
		    continue;
		}
		
		// If we have already found this driver in the user section, then
		// ignore the system definition
		for (count=0; count<cUserDrivers; ++count) {
		    if (0 == lstrcmpi(lpBuf, aszUserDrivers[count])) {
			*lpBuf = 0;       // wipeout the last value
			goto skipped;
		    }
		}
		lpBuf += nSize+1;  // Step over this name and its terminating null
		skipped: ;
	    }
	    RegCloseKey(key);
	}

	if (ERROR_MORE_DATA == nRet) {
	    // we ran out of room
	    nSize = cchReturnBuffer-2;  // same return as GetPrivateProfileString
	} else if (nRet == ERROR_NO_MORE_ITEMS) {
	    // Success.  Calculate the number of characters in the buffer
	    *lpBuf = 0;  // Write a second terminating zero
	    // Now calculate how many characters we are returning, excluding one
	    // of the two terminating zeros
	    nSize = (DWORD) (DWORD_PTR) (lpBuf-lpszReturnBuffer);
	} else {
	    // something went wrong.  No data, or another error, return nothing
	    // Make sure the buffer has a double terminating null
	    *lpBuf++ = 0;
	    *lpBuf++ = 0;
	    nSize=0;
	}

	return(nSize);
    } else {
	// Not enumerating.  We have a specific value to look for
	if (ERROR_SUCCESS == OpenUserKey(&key, NULL, lpszSection)) {

	    // Calculate - in bytes - how much space is in the buffer
	    nSize = (DWORD) (DWORD_PTR) ((LPBYTE)lpEnd-(LPBYTE)lpBuf);

	    // Get the data
	    nRet = RegQueryValueEx(key, lpszKey, NULL,
					&dwType, (LPBYTE)lpBuf, &nSize);
	    RegCloseKey(key);
	}
	// If we could not find the data in the user key then try SYSTEM
	if ((ERROR_SUCCESS != nRet) && (ERROR_MORE_DATA != nRet)) {
	    // Try the system key
	    if (ERROR_SUCCESS == OpenSystemKey(&key, NULL, lpszSection)) {

		// Calculate - in bytes - how much space is in the buffer
		nSize = (DWORD) (DWORD_PTR) ((LPBYTE)lpEnd-(LPBYTE)lpBuf);

		// Get the data
		nRet = RegQueryValueEx(key, lpszKey, NULL,
					&dwType, (LPBYTE)lpBuf, &nSize);
		RegCloseKey(key);
	    }
	}
	if (ERROR_MORE_DATA == nRet) {
	    return(cchReturnBuffer-1);  // not enough room for the data
	}
	if (nRet != ERROR_SUCCESS) {
	    return(0);  // cannot find the data
	}
	if (REG_SZ != dwType) {
	    return(0);  // we must have string data
	}
	//RegQueryValueEx returns length in bytes and includes the terminating zero
	return (DWORD) (nSize/sizeof(TCHAR) - 1);
    }
}

#endif

// Display an apps help message to the user before his app crashes
// because Indeo5 was removed from XP. ApphelpShowDialog()
// is a private API, so we launch appshelp directly to avoid calling
// private APIs from dshow which is redisted outside the OS. This code
// is duplicated in compman.c and intel.cpp
// 
void IndeoAppCompat()
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    HWND                hwndForeground;
    static  int         nCallAhui=0;

    TCHAR szCmdLine[MAX_PATH * 2];
    UINT cch = GetSystemDirectory(szCmdLine, MAX_PATH);
    if(!cch) {
        return;
    }
    lstrcat(szCmdLine, TEXT("\\ahui.exe /HTMLHELPID:0x5349 /SEVERITY:0x1 ")
            TEXT("/GUID:{1A42E45A-C662-4F47-BC71-91C6872347A7}"));

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    //
    // Only call once. Calling mulitple times increase the bad app to freak out.
    //
    if ( nCallAhui++ != 0 ) {
        return;
    }

    hwndForeground = GetForegroundWindow();

    if ( NULL != hwndForeground ) {
        //
        // Temporarily deactivate foreground window in case it's in fullscreen mode
        //
        SendMessage( hwndForeground, WM_ACTIVATEAPP, FALSE, 0);
    }

    //
    // post the message via ahui
    //
    if (CreateProcess(NULL,
                      szCmdLine,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &StartupInfo, &ProcessInfo)) {
        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }

    //
    // reactivate the foreground
    //
    if ( NULL != hwndForeground ) {
        SendMessage( hwndForeground, WM_ACTIVATEAPP, TRUE, 0);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\compmani.h ===
//==========================================================================;
//
//  compmani.h
//
//  Copyright (c) 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Internal COMPMAN header file. Defines some internal
//      data structures and things not needed outside of COMPMAN itself.
//
//  History:
//	07/07/94    frankye
//
//==========================================================================;

#if !defined NUMELMS
  #define NUMELMS(aa)           (sizeof(aa)/sizeof((aa)[0]))
  #define FIELDOFF(type,field)  (&(((type)0)->field))
  #define FIELDSIZ(type,field)  (sizeof(((type)0)->field))
#endif

//--------------------------------------------------------------------------;
//
//  ICMGARB structure
//
//
//	This structure contains information (ICM Garbage) that is global but
//	on a per-process basis.  Currently this is required only for 16-bit
//	builds and the structues are maintained in a linked list whose head
//	is pointed to by the gplig global variable.
//
//--------------------------------------------------------------------------;

typedef struct tICMGARB
{
    struct tICMGARB*pigNext;		// next garb structure
    DWORD           pid;                // process id associated with this garb
    UINT            cUsage;             // usage count for this process

    //
    //	16-to-32 thunk related data
    //
    BOOL	    fThunksInitialized;
    BOOL	    fThunkError;
    DWORD	    dwMsvfw32Handle;
    LPVOID          lpvThunkEntry;

} ICMGARB, *PICMGARB, FAR *LPICMGARB;

extern PICMGARB gplig;

//--------------------------------------------------------------------------;
//
//  misc data structures
//
//--------------------------------------------------------------------------;

//
//
//
typedef struct  {
    DWORD       dwSmag;             // 'Smag'
    HTASK       hTask;              // owner task.
    DWORD       fccType;            // converter type ie 'vidc'
    DWORD       fccHandler;         // converter id ie 'rle '
    HDRVR       hDriver;            // handle of driver
    LPARAM      dwDriver;           // driver id for functions
    DRIVERPROC  DriverProc;         // function to call
    DWORD	dnDevNode;	    // devnode id iff pnp driver
#ifdef NT_THUNK16
    //
    //	h32	: 32-bit driver handle
    //	lpstd	: 16:16 ptr to current status thunk descriptor
    //
    DWORD       h32;
    struct tICSTATUSTHUNKDESC FAR* lpstd;
#endif
}   IC, *PIC;

//
//  This structure is similar in use to the ICINFO structure except
//  that it is only used internally and not passed to apps.
//
//  !!! If you add anything to this structure that requires thunking,
//  then you're going to need to thunk it in thunk.c
//
typedef struct {
    DWORD	dnDevNode;	    // devnode id iff pnp driver
} ICINFOI, NEAR *NPICINFOI, *PICINFOI, FAR *LPICINFOI ;


//--------------------------------------------------------------------------;
//
//  GetCurrentProcessId prototype
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  DWORD GetCurrentProcessId
//
//  Description:
//	This function returns the current process id
//
//  Arguments:
//
//  Return (DWORD):
//	Id of current process
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//	WIN32:
//	This function exists in the 32-bit kernels on both Chicago and
//	Daytona and we provide no prototype for WIN32 compiles.
//
//	16-bit Chicago:
//	It is exported as in internal API by the 16-bit Chicago kernel.
//	We provide the prototype here and import it in the def file.
//
//	16-bit Daytona:
//	Has no such 16-bit function and really doesn't need one since all
//	16-bit tasks are part of the same process under Daytona.  Therefore
//	we just #define this to return (1) for 16-bit non-Chicago builds.
//
//--------------------------------------------------------------------------;
#ifndef _WIN32
#ifdef  CHICAGO
DWORD WINAPI GetCurrentProcessId(void);
#else
#define GetCurrentProcessId() (1)
#endif
#endif

//--------------------------------------------------------------------------;
//
//  Thunk initialization and termination function protos
//
//--------------------------------------------------------------------------;
PICMGARB WINAPI thunkInitialize(VOID);
VOID WINAPI thunkTerminate(PICMGARB pid);

//--------------------------------------------------------------------------;
//
//  pig function protos
//
//--------------------------------------------------------------------------;
PICMGARB FAR PASCAL pigNew(void);
PICMGARB FAR PASCAL pigFind(void);
void FAR PASCAL pigDelete(PICMGARB pig);

//--------------------------------------------------------------------------;
//
//  misc function protos
//
//--------------------------------------------------------------------------;
BOOL VFWAPI ICInfoInternal(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo, ICINFOI FAR * lpicinfoi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif



#ifndef _WIN32
#ifndef LPCTSTR
#define LPCTSTR LPCSTR
#endif
#ifndef TCHAR
#define TCHAR char
#endif
#endif

    
//--------------------------------------------------------------------------;
//
//  The following is the only stuff that should need to be changed when
//  moving this debug code from one project component to another.
//
//--------------------------------------------------------------------------;

//
//  DEBUG_MODULE_NAME is the module name of the component you are
//  building.  In the [debug] section of WIN.INI you can add
//  an entry MYMODULE=n to set the debug level for you module.
//  You can use debug statements like:
//	DPF(2, "My debug string");
//  This output would appear only if MYMODULE=n appears in WIN.INI
//  and n>=2.
//
#ifdef _WIN32
#define DEBUG_MODULE_NAME       "MSVFW32"    // key name and prefix for output
#else
#define DEBUG_MODULE_NAME       "MSVIDEO"   // key name and prefix for output
#endif

//
//  You can also specify certain types of debug information.  For example,
//  you may have much debug output that is associated only with initialization.
//  By adding an entry to the following enumeration, and then adding the
//  corresponding string to the following array of strings, you can specify
//  a debug level for different types of debug information.  Using the
//  initialization example, you can add an entry like "MYMODULENAME_dbgInit=n"
//  to the [debug] section to set a debug level for debug information
//  associated only with initialization.  You would use debug statements like:
//	DPFS(dbgInit, 3, "My debug string");
//  This output would appear only if MYMODULENAME_dbgInit=n appears in WIN.INI
//  and n>=3.  This would be usefull when you only want to debug the logic
//  associated only with a certain part of you program.
//
//  DO NOT CHANGE the first entry in the enum and the aszDbgSpecs.
//
enum {
    dbgNone=0,
    dbgInit,
    dbgThunks
};

#ifdef _INC_DEBUG_CODE
LPCTSTR aszDbgSpecs[] = {
    "\0",
    "_dbgInit",
    "_dbgThunks"
};
#endif

//--------------------------------------------------------------------------;
//
//  You should NOT need to modify anthing below here when
//  moving this debug code from one project component to another.
//
//--------------------------------------------------------------------------;


//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define DEBUG_QUOTE(x)      #x
#define DEBUG_QQUOTE(y)     DEBUG_QUOTE(y)
#define REMIND(sz)          __FILE__ "(" DEBUG_QQUOTE(__LINE__) ") : " sz

#ifdef DEBUG
    BOOL WINAPI DbgEnable(UINT uDbgSpec, BOOL fEnable);
    UINT WINAPI DbgGetLevel(UINT uDbgSpec);
    UINT WINAPI DbgSetLevel(UINT uDbgSpec, UINT uLevel);
    VOID WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintfS(UINT uDbgSpec, UINT uDbgLevel, LPSTR szFmt, ...);
    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPFS	dprintfS
    #define DPF		dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPFS()
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef RDEBUG
    #define DebugErr(flags, sz)         {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx);}
    #define DebugErr1(flags, sz, a)     {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a);}
    #define DebugErr2(flags, sz, a, b)  {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a, b);}
#else
    #define DebugErr(flags, sz)
    #define DebugErr1(flags, sz, a)
    #define DebugErr2(flags, sz, a, b)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\thunk.c ===
//==========================================================================;
//  COMMENTS DO NOT YET APPLY TO MSVIDEO.DLL/MSVFW32.DLL
//  thunk.c
//
//  Copyright (c) 1991-1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      This module contains routines for thunking the
//      ICM APIs (messages) from 16-bit Windows to 32-bit WOW.
//
//  History:
//
//==========================================================================;


//  This stuff is not going to work 64-bit
#pragma warning(disable:4312)


/*

    WOW Thunking design:

        Thunks are generated as follows :

        16-bit :
           acmBootDrivers->acmInitThunks :

               Generate calls to 32-bit drivers if we're in WOW call across
               to KERNEL to find thunking entry points.

               If we're thunking 'load' all the 32-bit ACM drivers as well as
               the 16-bit ones.

               Priority is always to find a 32-bit driver first but this is
               done via searching for one on open.

               The internal flag ACM_DRIVERADDF_32BIT is specified when
               calling IDriverAdd and this flag is stored in the ACMDRIVERID
               structure.

           IDriverAdd->IDriverLoad->IDriverLoad32

               The 16-bit side calls the 32-bit side passing in the driver
               alias which is used to compare against the aliases on the 32
               bit side and the 32-bit HACMDRIVERID is passed back for the
               relevant driver and stored in the hdrvr field of the
               ACMDRIVERID structure.

           IDriverOpen->IDriverOpen32

               The parameters are passed to the 32-bit side using the hdrvr
               field deduced from the HACMDRIVERID as the 32-bit HACMDRIVERID.

           IDriverMessageId->IDriverMessageId32 :

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure) then call IDriverMessageId32.  The hadid for
               the 32-bit driver is stored in the hdrvr field of ACMDRIVERID
               on the 16-bit side.

           IDriverMessage->IDriverMessage32

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure pointed to by the ACMDRIVER structure) then call
               IDriverMessage32.  The had for the 32-bit driver is stored
               in the hdrvr field of ACMDRIVER on the 16-bit side.

           Stream headers

               These must be persistent on the 32-bit side too and kept
               in synch.

               They are allocated on the 32-bit side for ACMDM_STREAM_PREPARE
               and freed on ACMDM_STREAM_UNPREPARE.  While in existence
               the 32-bit stream header is stored in the dwDriver field in

*/
//==========================================================================;

#define _INC_COMPMAN

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <win32.h>
#include <vfw.h>
#include <msviddrv.h>
#ifdef _WIN32
#ifdef DAYTONA
    #include <wownt32.h>
#endif
    #include <stdlib.h>        // for mbstowcs and wcstombs
#endif // _WIN32

#ifdef _WIN32
#include "compmn16.h"
#endif
#include "compmani.h"
#include "thunk.h"

#include "debug.h"



#ifdef NT_THUNK32

//==========================================================================;
//
//
//	--- === 32 BIT SIDE === ---
//
//
//==========================================================================;


/* -------------------------------------------------------------------------
** Handle and memory mapping functions.
** -------------------------------------------------------------------------
*/

LPWOWHANDLE32          lpWOWHandle32;
LPWOWHANDLE16          lpWOWHandle16;
LPGETVDMPOINTER        GetVDMPointer;
LPWOWCALLBACK16	       lpWOWCallback16;
int                    ThunksInitialized;

//
//  These wrap around whatever mapping mechanism is used on the platform
//  we are compiling for.
//
INLINE PVOID ptrFixMap16To32(const VOID * pv, DWORD cb);
INLINE VOID  ptrUnFix16(const VOID * pv);


#ifdef CHICAGO
//
//  -= Chicago implementation of memory mapping functions =-
//

//
//  Thunk helper routines in Chicago kernel
//
extern PVOID WINAPI MapSL(const VOID * pv);
extern PVOID WINAPI MapSLFix(const VOID * pv);
extern VOID  WINAPI UnMapSLFixArray(DWORD dwCnt, const VOID * lpSels[]);

PVOID INLINE ptrFixMap16To32(const VOID * pv, DWORD cb)
{
    return MapSLFix(pv);
}

VOID INLINE ptrUnFix16(const VOID * pv)
{
    UnMapSLFixArray(1, &pv);
}


#else	// CHICAGO ELSE

//
//  -= Daytona implementation of memory mapping functions =-
//
//  Use #define to avoid having a function call

#define ptrFixMap16To32(spv, cb)	\
	    GetVDMPointer( (DWORD) (DWORD_PTR) (spv), (cb), TRUE )

//PVOID ptrFixMap16To32(const VOID * pv, DWORD cb)
//{
//    return GetVDMPointer( (DWORD)pv, cb, TRUE );
//}

//
// The unfix routine is a total noop.
// We should really call WOWGetVDMPointerUnfix...
//

#define ptrUnFix16(spv)

//VOID ptrUnFix16(const VOID * pv)
//{
//    return;
//}

#endif	// !CHICAGO


//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

//
//  16-bit structures
//

typedef struct {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO16;

//
//  Useful functions
//

//
//  CopyAlloc - allocate a new piece of memory, and copy the data in
//  Must use LocalFree to release the memory later
//
PVOID CopyAlloc(PVOID   pvSrc, UINT    uSize)
{
    PVOID   pvDest;

    pvDest = (PVOID)LocalAlloc(LMEM_FIXED, uSize);

    if (pvDest != NULL) {
        CopyMemory(pvDest, pvSrc, uSize);
    }

    return pvDest;
}

/*
 *  Copy data from source to dest where source is a 32bit pointer
 *  and dest is a 16bit pointer
 */
void CopyTo16Bit(LPVOID Dest16, LPVOID Src32, DWORD Length)
{
    PVOID Dest32;

    if (Src32 == NULL) {
        return;
    }

    Dest32 = ptrFixMap16To32(Dest16, Length);

    CopyMemory(Dest32, Src32, Length);

    ptrUnFix16(Dest16);
}


/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer
 */
void CopyTo32Bit(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return;
    }

    Src32 = ptrFixMap16To32(Src16, Length);

    CopyMemory(Dest32, Src32, Length);

    ptrUnFix16(Src16);
}
#ifdef _INC_COMPMAN


/*--------------------------------------------------------------------------*\
|                                                                            |
| Now thunk the compman functions                                            |
|                                                                            |
|                                                                            |
|                                                                            |
|                                                                            |
\*--------------------------------------------------------------------------*/

/*
 *  Convert ICDRAWBEGIN structures
 */

INLINE STATICFN void ConvertICDRAWBEGIN(ICDRAWBEGIN *DrawBegin32,
                                        LPBITMAPINFOHEADER lpBmi,
                                        DWORD dw)
{
    ICDRAWBEGIN16 DrawBegin16;

    CopyTo32Bit(&DrawBegin16, (LPVOID)dw, sizeof(ICDRAWBEGIN16));

    DrawBegin32->dwFlags = DrawBegin16.dwFlags;
    DrawBegin32->hpal = ThunkHPAL(DrawBegin16.hpal);
    if (DrawBegin16.dwFlags & ICDRAW_HDC) {
	DrawBegin32->hwnd = ThunkHWND(DrawBegin16.hwnd);
	DrawBegin32->hdc = ThunkHDC(DrawBegin16.hdc);
    }
    DrawBegin32->xDst = (int)DrawBegin16.xDst;
    DrawBegin32->yDst = (int)DrawBegin16.yDst;
    DrawBegin32->dxDst = (int)DrawBegin16.dxDst;
    DrawBegin32->dyDst = (int)DrawBegin16.dyDst;

    CopyTo32Bit(lpBmi, DrawBegin16.lpbi, sizeof(BITMAPINFOHEADER));

    DrawBegin32->lpbi = lpBmi;
    DrawBegin32->xSrc = (int)DrawBegin16.xSrc;
    DrawBegin32->ySrc = (int)DrawBegin16.ySrc;
    DrawBegin32->dxSrc = (int)DrawBegin16.dxSrc;
    DrawBegin32->dySrc = (int)DrawBegin16.dySrc;
    DrawBegin32->dwRate = DrawBegin16.dwRate;
    DrawBegin32->dwScale = DrawBegin16.dwScale;
}


/*
 *  Following logic copied from mvdm\wow32\wstruc.c - however since we
 *  don't have the usage parameter we're a bit stuck on the size of the
 *  entries.
 *
 *  See also the video for windows documentation - only a limited range of
 *  bitmap types are discussed.
 */

INT GetBMI16Size(UNALIGNED BITMAPINFOHEADER *pbmi16)
{
   int      nHdrSize;
   int      nEntSize;
   int      nEntries;
   int      nBitCount;
   DWORD    dwClrUsed;

   nHdrSize = (int)pbmi16->biSize;

  /*
   *  We don't have some of the info we need so assume RGBQUAD
   */

   nEntSize = sizeof(RGBQUAD);

   nBitCount = pbmi16->biBitCount;
   dwClrUsed = pbmi16->biClrUsed;

/* the following block of code should be this:
 *
 *  if ( nBitCount > 8 ) {  // true colour
 *      nEntries = 0; (ordinary case)
 *	nEntries = 3; (BI_BITFIELDS case)
 *  }
 *  else if ( dwClrUsed ) {
 *      nEntries = dwClrUsed;
 *  }
 *  else {
 *      nEntries = 1 << nBitCount;
 *  }
 *
 *  but due to the fact that many apps don't initialize the biBitCount &
 *  biClrUsed fields (especially biClrUsed) we have to do the following
 *  sanity checking instead.  v-cjones
 */

   if ( nBitCount <= 8 ) {
       nEntries = 1 << nBitCount;
       // sanity check for apps (lots) that don't init the dwClrUsed field
       if(dwClrUsed) {
           nEntries = (int)min((DWORD)nEntries, dwClrUsed);
       }
   } else {
       if (pbmi16->biCompression == BI_BITFIELDS)
	   nEntries = 3;
       else
	   nEntries = 0;
   }

   return ( nHdrSize + (nEntries * nEntSize) );
}

INLINE LPBITMAPINFO CopyBitmapInfo(DWORD Bi16)
{
    UNALIGNED BITMAPINFOHEADER *pbmi16;
    LPBITMAPINFO    lpbmi;

    pbmi16 = ptrFixMap16To32((PVOID)Bi16, 0);

    if ((int)pbmi16->biSize == 0) {
        pbmi16->biSize = sizeof(BITMAPINFOHEADER);
	DPF(0, "WARNING: null bitmap info size, setting it correctly");
    }

    lpbmi = (LPBITMAPINFO)CopyAlloc((LPVOID)pbmi16, GetBMI16Size(pbmi16));

    ptrUnFix16((PVOID)Bi16);

    return (lpbmi);
}

/*
 * Allocate a BITMAPINFO structure to contain 256 colours
 */
INLINE LPBITMAPINFO AllocBitmapInfo()
{
    return (PVOID)LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFOHEADER)+
                                         (sizeof(RGBQUAD)*256));
}

INLINE LPBITMAPINFOHEADER CopyBitmapInfoHeader(DWORD Bi16)
{
    UNALIGNED BITMAPINFOHEADER *pbmi16;
    LPBITMAPINFOHEADER lpbmi;

    pbmi16 = ptrFixMap16To32((PVOID)Bi16, 0);

    lpbmi = (LPBITMAPINFOHEADER)CopyAlloc((LPVOID)pbmi16, pbmi16->biSize);

    ptrUnFix16((PVOID)Bi16);

    return (lpbmi);
}



DWORD CopyICINFOTo16bit(DWORD dw, ICINFO *IcInfoCopy, DWORD Length)
{
    ICINFO16 IcInfo;
    LONG   ReturnCode;

   /*
    *  Make a copy since the behaviour of wcstombs is undefined
    *  for overlapping input and output
    */

    memcpy(&IcInfo, IcInfoCopy, FIELD_OFFSET(ICINFO, szName[0]));

   /*
    *  Massage the strings
    */

    wcstombs(IcInfo.szName,
             IcInfoCopy->szName,
             sizeof(IcInfo.szName));
    // HACK : overwrite the last five characters with "[32]\0"

    if ((IcInfo.szName[0]))
    {
        UINT n = min(sizeof(IcInfo.szName)-5, lstrlenA(IcInfo.szName));
        IcInfo.szName[n++] = '[';
        IcInfo.szName[n++] = '3';
        IcInfo.szName[n++] = '2';
        IcInfo.szName[n++] = ']';
        IcInfo.szName[n]   = '\0';
    }

    wcstombs(IcInfo.szDescription,
             IcInfoCopy->szDescription,
             sizeof(IcInfo.szDescription));
    // HACK : overwrite the last five characters with "[32]\0"
    if ((IcInfo.szDescription[0]))
    {
        UINT n = min(sizeof(IcInfo.szDescription)-5, lstrlenA(IcInfo.szDescription));
        IcInfo.szDescription[n++] = '[';
        IcInfo.szDescription[n++] = '3';
        IcInfo.szDescription[n++] = '2';
        IcInfo.szDescription[n++] = ']';
        IcInfo.szDescription[n]   = '\0';
    }

    wcstombs(IcInfo.szDriver,
             IcInfoCopy->szDriver,
             sizeof(IcInfo.szDriver));


    IcInfo.dwSize = sizeof(IcInfo);

    ReturnCode = min(Length, IcInfo.dwSize);

    CopyTo16Bit((LPVOID)dw, &IcInfo, ReturnCode);

    return ReturnCode;
}

/*
*  We need to convert the various fields in the ICDECOMPRESS/EX
*  structure(s).  Fortunately(?) the EX structure is a simple
*  extension.
*/
typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    short               xDst;       // destination rectangle
    short               yDst;
    short               dxDst;
    short               dyDst;

    short               xSrc;       // source rectangle
    short               ySrc;
    short               dxSrc;
    short               dySrc;

} ICDECOMPRESSEX16;

STATICFN DWORD DoICM_DecompressX(DWORD hic, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    ICDECOMPRESSEX16 UNALIGNED     *lpicdmpr16;
    ICDECOMPRESSEX                  ICDecompressEx;
    LRESULT                         l;
    BOOL			    fQuery = TRUE;

    /* Copy the standard or extended structure */
    lpicdmpr16 = ptrFixMap16To32( (PVOID)dwP1, (DWORD) dwP2 );
    ICDecompressEx.dwFlags = lpicdmpr16->dwFlags;


    ICDecompressEx.lpbiSrc = (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)(DWORD_PTR)lpicdmpr16->lpbiSrc);
    if (NULL == ICDecompressEx.lpbiSrc) {
	ptrUnFix16( (PVOID)dwP1 );
        return (DWORD)ICERR_MEMORY;
    }

    ICDecompressEx.lpbiDst =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)(DWORD_PTR)lpicdmpr16->lpbiDst);

    if ((NULL == ICDecompressEx.lpbiDst) && (msg != ICM_DECOMPRESSEX_QUERY)) {
        LocalFree( (HLOCAL)ICDecompressEx.lpbiSrc );
	ptrUnFix16( (PVOID)dwP1 );
        return (DWORD)ICERR_MEMORY;
    }

    if (msg == ICM_DECOMPRESSEX || msg == ICM_DECOMPRESS) {
	// map the source and destination pointers
	ICDecompressEx.lpSrc = ptrFixMap16To32(lpicdmpr16->lpSrc,
					       ICDecompressEx.lpbiSrc->biSizeImage);

	ICDecompressEx.lpDst = ptrFixMap16To32(lpicdmpr16->lpDst,
					       ICDecompressEx.lpbiDst->biSizeImage);
	fQuery = FALSE;	 // remember
    } else { // it is a query and we do not map the pointers
	ICDecompressEx.lpSrc = NULL;
	ICDecompressEx.lpDst = NULL;
    }

    if (dwP2 == sizeof(ICDECOMPRESSEX16) ) {

        ICDecompressEx.xDst     = (int)lpicdmpr16->xDst;
        ICDecompressEx.yDst     = (int)lpicdmpr16->yDst;
        ICDecompressEx.dxDst    = (int)lpicdmpr16->dxDst;
        ICDecompressEx.dyDst    = (int)lpicdmpr16->dyDst;

        ICDecompressEx.xSrc     = (int)lpicdmpr16->xSrc;
        ICDecompressEx.ySrc     = (int)lpicdmpr16->ySrc;
        ICDecompressEx.dxSrc    = (int)lpicdmpr16->dxSrc;
        ICDecompressEx.dySrc    = (int)lpicdmpr16->dySrc;
	dwP2 = sizeof(ICDecompressEx);  // Make the size relate to 32 bit
    }


    l = ICSendMessage( (HIC)hic, (UINT)msg, (LPARAM)&ICDecompressEx, dwP2 );

    /* I don't think the following is needed // FrankYe 11/18/94
    // If we do, don't just uncomment this.  You gotta use biUnMapSL
    if ( l == ICERR_OK) {

        CopyTo16Bit( lpicdmpr16->lpbiDst, ICDecompressEx.lpbiDst,
                     sizeof(BITMAPINFOHEADER) );
    }
    */

    LocalFree( (HLOCAL)ICDecompressEx.lpbiSrc );
    if (ICDecompressEx.lpbiDst) {
	LocalFree( (HLOCAL)ICDecompressEx.lpbiDst );
    }
    if (!fQuery) {
	ptrUnFix16( lpicdmpr16->lpSrc );
	ptrUnFix16( lpicdmpr16->lpDst );
    }
    ptrUnFix16( (PVOID)dwP1 );

    return (DWORD) l;
}


/*
 *  Generate our thunks - refer to msvideo!compman.c for definitions of
 *  functions.
 *
 *  NOTE - we often rely here on the fact that most of the message
 *  parameter structures are identical for 16 and 32-bit - ie they
 *  contain DWORDs and 32-bit pointers.
 */

//--------------------------------------------------------------------------;
//
//  LONG thkStatusProc32
//
//	When a client calls the 16-bit ICSetStatusProc while using a
//	32-bit codec, this function is set as the StatusProc in 32-bit codec.
//	This function will then thunk down to 16-bits and call the
//	client's StatusProc.
//
//  Arguments:
//	LPARAM lParam : contains linear ptr to an ICSTATUSTHUNKDESC.  The
//	    ICSTATUSTHUNKDESC is created during the call to ICSetStatusProc.
//
//	UINT uMsg :
//
//	LONG l :
//
//  Return value:
//	LONG :
//
//--------------------------------------------------------------------------;

LONG CALLBACK thkStatusProc32(LPARAM lParam, UINT uMsg, LONG l)
{
    LPICSTATUSTHUNKDESC lpstd;
    LONG lr;

    DPFS(dbgThunks, 4, "thkStatusProc32()");

    lpstd = (LPICSTATUSTHUNKDESC)lParam;
    ASSERT( lpstd->fnStatusProcS );
    ASSERT( lpstd->pfnthkStatusProc16S );


    lr = 0;

    //
    //	TODO: Thunk error string for ICSTATUS_ERROR.  Currently I'm not
    //	    sure if ICSTATUS_ERROR is documented.
    //
//#pragma message(REMIND("thkStatusProc32: thunk ICSTATUS_ERROR"))
    if (ICSTATUS_ERROR == uMsg) {
	//
	//  Is l supposed to be an LPSTR to an error string???
	//
	l = (LONG)0;
    }

    //
    //
    //
    lpstd->uMsg = uMsg;
    lpstd->l    = l;

    lr = lpWOWCallback16(lpstd->pfnthkStatusProc16S, (DWORD)lpstd->lpstdS);

    return (lr);
}

//--------------------------------------------------------------------------;
//
//  LRESULT thkSetStatusProc
//
//	This function is called as a result of thunking up from a call to
//	the 16-bit ICSetStatusProc.  It will call the 32-bit ICSetStatusProc
//	to install thkStatusProc32.
//
//  Arguments:
//	HIC hic : handle to 32-bit codec
//
//	LPARAM lParam : contains linear ptr to an ICSTATUSTHUNKDESC.  The
//	    ICSTATUSTHUNKDESC is created in the call to the 16-bit
//	    ICSetStatusProc.  This will be set as the lParam to be passed
//	    to our thkStatusProc32.
//
//  Return value:
//	LRESULT :
//
//--------------------------------------------------------------------------;

LRESULT WINAPI thkSetStatusProc(HIC hic, LPICSTATUSTHUNKDESC lpstd)
{
    DPFS(dbgThunks, 3, "thkSetStatusProc()");

    return ICSetStatusProc(hic, 0L, (LPARAM)lpstd, thkStatusProc32);
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
LRESULT FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO16 FAR * lpicInfo)
{
    ICINFO ReturnedICInfo;
    StartThunk(ICInfo);

    //DPF2(("Calling ICInfo %4.4hs %4.4hs %8X", &fccType, &fccHandler, lpicInfo));

    ReturnedICInfo.fccHandler = 0;  // Initialise...
    ReturnCode = ICInfo(fccType, fccHandler, &ReturnedICInfo);

    CopyICINFOTo16bit((DWORD)(DWORD_PTR)lpicInfo, &ReturnedICInfo, sizeof(ReturnedICInfo));
    EndThunk()
}

LRESULT FAR PASCAL ICInfoInternal32(DWORD fccType, DWORD fccHandler, ICINFO16 FAR * lpicInfo, ICINFOI FAR * lpicInfoI)
{
    return ICInfo32(fccType, fccHandler, lpicInfo);
#if 0
    ICINFO  ReturnedICInfo;
    ICINFOI ReturnedICInfoI;

    StartThunk(ICInfo);

    // DPF(1, "Calling ICInfo %4.4hs %4.4hs %8X", &fccType, &fccHandler, lpicInfo);

    ReturnedICInfo.fccHandler = 0;  // Initialise...
    ReturnCode = ICInfoInternal(fccType, fccHandler, &ReturnedICInfo, &ReturnedICInfoI);

    if (NULL != lpicInfoI) {
	//
	//  Assuming no members of ICINFOI need special thunking
	//
	CopyTo16Bit(lpicInfoI, &ReturnedICInfoI, sizeof(*lpicInfoI));
    }

    CopyICINFOTo16bit((DWORD)(DWORD_PTR)lpicInfo, &ReturnedICInfo, sizeof(ReturnedICInfo));

    EndThunk()
#endif
}

LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    StartThunk(ICSendMessage);
    DPF(2,"Calling ICSendMessage %4X %4X %8X %8X",
              hic, msg, dwP1, dwP2);

    switch (msg) {
    case ICM_GETSTATE:
    case ICM_SETSTATE:

        if (dwP1 == 0) {
            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       dwP1,
                                       dwP2);
        } else {
            PVOID pState;
           /*
            *  Create some aligned memory to return or pass on the data
            */
            pState = (PVOID)LocalAlloc(LPTR, dwP2);

            if (pState == NULL) {
                ReturnCode = 0;
            } else {

                if ((UINT)msg == ICM_SETSTATE) {
                    // Copy the data from 16 bit land
                    CopyTo32Bit(pState, (LPVOID)dwP1, (DWORD) dwP2);
                }
                ReturnCode = ICSendMessage((HIC)(DWORD)hic, (UINT)msg,
                                           (DWORD_PTR)pState, dwP2);

               /*
                *  Copy back the state, if the driver returned any data
                */

                if (ReturnCode > 0 && (UINT)msg == ICM_GETSTATE) {
                    CopyTo16Bit((LPVOID)dwP1, pState,
                                min((DWORD)ReturnCode, (DWORD) dwP2));
                }

                LocalFree((HLOCAL)pState);
            }
        }
        break;

    case ICM_GETINFO:
        {
            ICINFO IcInfo;

            ReturnCode = ICGetInfo((HIC)(DWORD)hic, &IcInfo, sizeof(IcInfo));

            if (ReturnCode != 0) {
                ReturnCode = CopyICINFOTo16bit((DWORD) (DWORD_PTR) dwP1, &IcInfo, (DWORD) ReturnCode);
            }
        }


        break;

    case ICM_CONFIGURE:
    case ICM_ABOUT:

       /*
        *  dwP1 = -1 is a special value asking if config is supported,
        *  otherwise it's a window handle
        */

        ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                   (UINT)msg,
                                   dwP1 == (DWORD_PTR)-1 ?
                                       (DWORD_PTR)-1 :
                                       (DWORD_PTR)ThunkHWND(LOWORD(dwP1)),
                                   dwP2);


        break;

    case ICM_COMPRESS:
        {
            if (dwP2 != sizeof(ICCOMPRESS)) {  // validation code
                ReturnCode = ICERR_BADSIZE;
            } else {

                DWORD dwFlags;
                LPDWORD lpdwFlags16, lpckid16;
                LPBITMAPINFOHEADER  lpbih16;

		LPVOID lpInput, lpOutput, lpPrev;

                DWORD ckid;

                ICCOMPRESS IcCompress;

                ReturnCode = ICERR_OK;

               /*
                *  We need to convert the various fields in the ICCOMPRESS
                *  structure
                */

                CopyTo32Bit( &IcCompress, (LPVOID)dwP1, (DWORD) dwP2 );

                IcCompress.lpbiInput =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)(DWORD_PTR)IcCompress.lpbiInput);
                if (NULL == IcCompress.lpbiInput) {
                    ReturnCode = ICERR_MEMORY;
                    break;
                }

                lpbih16 = IcCompress.lpbiOutput;
                IcCompress.lpbiOutput =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)(DWORD_PTR)IcCompress.lpbiOutput);
                if (NULL == IcCompress.lpbiOutput) {
                    LocalFree((HLOCAL)IcCompress.lpbiInput);
                    ReturnCode = ICERR_MEMORY;
                    break;
                }

		lpInput = IcCompress.lpInput;
                IcCompress.lpInput = ptrFixMap16To32(IcCompress.lpInput, IcCompress.lpbiInput->biSizeImage);

		lpOutput = IcCompress.lpOutput;
                IcCompress.lpOutput = ptrFixMap16To32(IcCompress.lpOutput, IcCompress.lpbiOutput->biSizeImage);

		lpPrev = NULL;
		if (IcCompress.lpbiPrev) {

		    IcCompress.lpbiPrev =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)(DWORD_PTR)IcCompress.lpbiPrev);
                    if (NULL == IcCompress.lpbiPrev) {
                        LocalFree((HLOCAL)IcCompress.lpbiOutput);
                        LocalFree((HLOCAL)IcCompress.lpbiInput);
			ptrUnFix16(lpOutput);
			ptrUnFix16(lpInput);
                        ReturnCode = ICERR_MEMORY;
                        break;
                    }


		    lpPrev = IcCompress.lpPrev;
                    IcCompress.lpPrev = ptrFixMap16To32(IcCompress.lpPrev, IcCompress.lpbiPrev->biSizeImage);
                }

		lpdwFlags16 = IcCompress.lpdwFlags;
		if (lpdwFlags16 != NULL) {
		    CopyTo32Bit(&dwFlags, lpdwFlags16, sizeof(DWORD));
		    IcCompress.lpdwFlags = &dwFlags;
		}

                if (IcCompress.lpckid != NULL) {
                    lpckid16 = IcCompress.lpckid;
                    IcCompress.lpckid = &ckid;
                }


                ReturnCode = ICSendMessage((HIC)(DWORD)hic, (UINT)msg,
                                           (DWORD_PTR)&IcCompress, dwP2);

                if (ReturnCode == ICERR_OK) {

                    CopyTo16Bit( lpbih16, IcCompress.lpbiOutput,
                                 sizeof(BITMAPINFOHEADER) );

                    if (lpdwFlags16 != NULL) {
                        CopyTo16Bit(lpdwFlags16, &dwFlags, sizeof(DWORD));
                    }

                    if (IcCompress.lpckid != NULL) {
                        CopyTo16Bit(lpckid16, &ckid, sizeof(DWORD));
                    }
                }

                /*
                ** Free the bitmap info storage regardless of the return code
                */

                if (NULL != IcCompress.lpbiPrev) {
                    LocalFree((HLOCAL)IcCompress.lpbiPrev);
                }

                LocalFree((HLOCAL)IcCompress.lpbiOutput);
                LocalFree((HLOCAL)IcCompress.lpbiInput);

		if (NULL != lpPrev)
		{
		    ptrUnFix16(lpPrev);
		}
		ptrUnFix16(lpOutput);
		ptrUnFix16(lpInput);
            }

        }
        break;


    case ICM_COMPRESS_GET_SIZE:
    case ICM_COMPRESS_BEGIN:
    case ICM_COMPRESS_QUERY:

    case ICM_DECOMPRESS_BEGIN:
    case ICM_DECOMPRESS_GET_PALETTE:
    case ICM_DECOMPRESS_SET_PALETTE:  // only takes one BitmapInfoHeader
    case ICM_DECOMPRESS_QUERY:

        {
            LPBITMAPINFO bmi1, bmi2;

	    bmi1 = bmi2 = NULL;
	    if (dwP1 != 0) {
		bmi1 = CopyBitmapInfo((DWORD) (DWORD_PTR) dwP1);
	    }
	    if (dwP2 != 0) {
		bmi2 = CopyBitmapInfo((DWORD) (DWORD_PTR) dwP2);
	    }

            if ( (NULL == bmi1  &&  0 != dwP1) || (NULL == bmi2  &&  0 != dwP2) )
	    {
		if (NULL != bmi1) LocalFree((HLOCAL)bmi1);
		if (NULL != bmi2) LocalFree((HLOCAL)bmi2);
                ReturnCode = (UINT)msg == ICM_COMPRESS_GET_SIZE ? 0 : ICERR_MEMORY;
		
            } else {

                ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                           (UINT)msg,
                                           (DWORD_PTR)bmi1,
                                           (DWORD_PTR)bmi2);

                if (bmi2 != NULL) {

                    // We might have to return data to the 16 bit side.
                    // The messages for which we have to do this are:
                    //      ICM_DECOMPRESS_QUERY (iff retcode == ICERR_OK)
                    //      ICM_DECOMPRESS_GET_PALETTE (iff retcode >= 0)

                    if (((ReturnCode == ICERR_OK) && (msg == ICM_DECOMPRESS_QUERY))
                        || ((ReturnCode >= 0) && (msg == ICM_DECOMPRESS_GET_PALETTE)))
                    {
                        CopyTo16Bit((LPVOID)dwP2, bmi2, GetBMI16Size((LPBITMAPINFOHEADER)bmi2));
                    }
                    LocalFree((HLOCAL)bmi2);
                }

            }

            if (bmi1 != NULL) {
                LocalFree((HLOCAL)bmi1);
            }
        }
        break;

    case ICM_COMPRESS_END:
    case ICM_DECOMPRESS_END:
    case ICM_DECOMPRESSEX_END:
    case ICM_DRAW_END:
    case ICM_DRAW_FLUSH:
    case ICM_DRAW_START:         //??
    case ICM_DRAW_STOP:          //??
    case ICM_DRAW_SETTIME:
    case ICM_DRAW_RENDERBUFFER:
    case ICM_SETQUALITY:

        ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                   (UINT)msg,
                                   dwP1,
                                   dwP2);
        break;

    case ICM_DRAW_GETTIME:
    case ICM_GETBUFFERSWANTED:
    case ICM_GETDEFAULTQUALITY:
    case ICM_GETDEFAULTKEYFRAMERATE:
    case ICM_GETQUALITY:
        {
            DWORD dwReturn;

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD_PTR)&dwReturn,
                                       dwP2);

            // Note: although the definition of these messages state
            // that dwParam2 is not used, trouble will brew if the
            // decompressor ever tries to use dwParam2.  We cannot
            // thunk non-standard uses of this parameter.

            if (ReturnCode == ICERR_OK) {
                CopyTo16Bit((LPVOID)dwP1, &dwReturn, sizeof(DWORD));
            }

        }
        break;

    case ICM_COMPRESS_GET_FORMAT:
    case ICM_DECOMPRESS_GET_FORMAT:

       /*
        *  This is a tricky one - we first have to find the size of
        *  the output format so we can get a copy of the (aligned)
        *  version before passing it back to the app
        */

        {
            LPBITMAPINFO bmi1, bmi2;

            if ( dwP1 == 0L ) {
                ReturnCode = ICERR_OK;
                break;
            }

            bmi1 = CopyBitmapInfo((DWORD) (DWORD_PTR) dwP1);

            if (bmi1 == NULL) {
                ReturnCode = ICERR_MEMORY;
            } else {

                ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                           (UINT)msg,
                                           (DWORD_PTR)bmi1,
                                           0);

                if (ReturnCode > 0 && dwP2 != 0) {
                    bmi2 = LocalAlloc(LMEM_FIXED, ReturnCode);

                    if (bmi2 == NULL) {
                       /*
                        *  Can't do anything!!! - there's not good return code
                        */

                        ReturnCode = ICERR_MEMORY;
                    } else {
                        DWORD Length;

                        Length = (DWORD) ReturnCode; /* preserve length */

                        ReturnCode =
                            ICSendMessage((HIC)(DWORD)hic,
                                          (UINT)msg,
                                          (DWORD_PTR)bmi1,
                                          (DWORD_PTR)bmi2);

                        if (ReturnCode >= 0) {
                            CopyTo16Bit((LPVOID)dwP2, bmi2, Length);
                        }

                        LocalFree((HLOCAL)bmi2);
                    }
                }

                LocalFree((HLOCAL)bmi1);
            }

        }
        break;

    case ICM_DECOMPRESS:
        if (dwP2 != sizeof(ICDECOMPRESS)) {
            ReturnCode = ICERR_BADSIZE;
        } else {
            ReturnCode = DoICM_DecompressX(hic, msg, dwP1, dwP2);
        }
        break;

    case ICM_DECOMPRESSEX:
    case ICM_DECOMPRESSEX_BEGIN:
    case ICM_DECOMPRESSEX_QUERY:
        if (dwP2 != sizeof(ICDECOMPRESSEX16)) {
            ReturnCode = ICERR_BADSIZE;
        } else {
            ReturnCode = DoICM_DecompressX(hic, msg, dwP1, dwP2);
        }
        break;

    case ICM_DRAW:

       /*
        *  We can't support unknown extensions
        */

        if (dwP2 != sizeof(ICDRAW)) {
            ReturnCode = ICERR_BADSIZE;
        } else {
            ICDRAW ICDraw;
            BITMAPINFOHEADER bmi;
	    LPVOID lpData;

            CopyTo32Bit(&ICDraw, (LPVOID)dwP1, (DWORD) dwP2);

           /*
            *  We have to assume this is a draw for video
            */

            CopyTo32Bit(&bmi, ICDraw.lpFormat, sizeof(BITMAPINFOHEADER));

            ICDraw.lpFormat = (LPVOID)&bmi;

	    lpData = ICDraw.lpData;
            ICDraw.lpData = ptrFixMap16To32(ICDraw.lpData, ICDraw.cbData);

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD_PTR)&ICDraw,
                                       dwP2);
	    ptrUnFix16(lpData);
        }
        break;

    case ICM_DRAW_BEGIN:
        {
            ICDRAWBEGIN InputFormat;
            BITMAPINFOHEADER bmihInput;

            ConvertICDRAWBEGIN(&InputFormat, &bmihInput, (DWORD) (DWORD_PTR) dwP1);

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD_PTR)&InputFormat,
                                       dwP2);
        }
        break;

    case ICM_DRAW_CHANGEPALETTE:
    case ICM_DRAW_QUERY:
        {
            LPBITMAPINFO lpbi;

            lpbi = CopyBitmapInfo((DWORD) (DWORD_PTR) dwP1);

            if (lpbi == NULL) {
                ReturnCode = ICERR_MEMORY;
            } else {
                ReturnCode = ICSendMessage((HIC)(DWORD_PTR)hic,
                                           (UINT)msg,
                                           (DWORD_PTR)lpbi,
                                           dwP2);

                LocalFree((HLOCAL)lpbi);
            }
        }
        break;

    case ICM_DRAW_REALIZE:

        ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                   (UINT)msg,
                                   (DWORD_PTR)ThunkHDC(LOWORD(dwP1)),
                                   dwP2);

        break;

    case ICM_DRAW_WINDOW:
        {
            RECT_SHORT SRect;
            RECT Rect;

            CopyTo32Bit(&SRect, (LPVOID)dwP1, sizeof(SRect));

            SHORT_RECT_TO_RECT(Rect, SRect);

            ReturnCode = ICSendMessage((HIC)(DWORD_PTR)hic,
                                       (UINT)msg,
                                       (DWORD_PTR)&Rect,
                                       dwP2);
        }
        break;

    // The next three messages are INTERNAL ones
    case ICM_GETERRORTEXT:
        break;

    case ICM_GETFORMATNAME:
        break;

    case ICM_ENUMFORMATS:
        break;

    case ICM_COMPRESS_FRAMES_INFO:
        {
            ICCOMPRESSFRAMES icf32;

	    // We might explode if we get too small a length and start treating
	    // some of the elements as pointers anyway.  Just fail the call.
	    // (WIN95C bug 8615).
	    // dwP2 is the length of the 16 bit structure and we only know
	    // the size of the 32 bit structure, but thankfully they're the
	    // same.
	    if (dwP2 < sizeof(ICCOMPRESSFRAMES)) {
		ReturnCode = ICERR_BADPARAM;
		break;
	    }

	    CopyTo32Bit(&icf32, (LPBYTE)dwP1, (DWORD) dwP2);

            // Now fix up the 32 bit structure
            icf32.PutData = icf32.GetData = NULL;  // For safety.  should not be used for this message

            if (icf32.lpbiOutput) {
                icf32.lpbiOutput = CopyBitmapInfoHeader((DWORD)(DWORD_PTR)icf32.lpbiOutput);
            }
            if (icf32.lpbiInput) {
                icf32.lpbiInput = CopyBitmapInfoHeader((DWORD)(DWORD_PTR)icf32.lpbiInput);
            }
	
// According to the documentation, lInput and lOutput are undefined.  Treating
// them as pointers is as scary as a really scary thing.
#if 0
	    lInput = icf32.lInput;
            icf32.lInput = (LPARAM)ptrFixMap16To32((LPVOID)icf32.lInput, icf32.lpbiInput->biSizeImage);

	    lOutput = icf32.lOutput;
            icf32.lOutput = (LPARAM)ptrFixMap16To32((LPVOID)icf32.lOutput, icf32.lpbiOutput->biSizeImage);
#endif
            // After the fixups have been done, call the actual routine
            ReturnCode = ICSendMessage((HIC)(DWORD_PTR)hic,
                                       (UINT)msg,
                                       (DWORD_PTR)&icf32,
                                       dwP2);

#if 0
	    ptrUnFix16((LPVOID)lOutput);
	    ptrUnFix16((LPVOID)lInput);
#endif
	
            if (icf32.lpbiOutput) {
                LocalFree(icf32.lpbiOutput);
            }
            if (icf32.lpbiInput) {
                LocalFree(icf32.lpbiInput);
            }
        }
        break;

    case ICM_DRAW_GET_PALETTE:
        {
            ReturnCode = ICSendMessage((HIC) hic,
                                       (UINT)msg,
                                       dwP1,
                                       dwP2);
            if ((ReturnCode != 0L) && (ReturnCode != ICERR_UNSUPPORTED)) {
#ifdef CHICAGO
		ReturnCode = (LRESULT)(WORD)ReturnCode;
#else

                FARPROC lpWOWHandle16;
                HMODULE hmodWow;

                if ( (hmodWow = GetModuleHandle( GET_MAPPING_MODULE_NAME ))
                   && (lpWOWHandle16 = GetProcAddress(hmodWow, "WOWHandle16"))) {
                    ReturnCode = (WORD)(lpWOWHandle16((HANDLE)ReturnCode, (WOW_HANDLE_TYPE)WOW_TYPE_HPALETTE));
                } else {
                    ReturnCode = ICERR_ERROR;
                }
#endif
            }
        }
        break;

    case ICM_DRAW_SUGGESTFORMAT:
        {
            ICDRAWSUGGEST icdrwsug;
            LPBITMAPINFOHEADER lpbiSuggest16;
            LPBITMAPINFOHEADER lpbiSuggest;

	    DPF(4, "!ICMSendMessage32: ICM_DRAW_SUGGESTFORMAT: dwP1=%08lXh, dwP2=%08lXh", dwP1, dwP2);

            //
	    CopyTo32Bit(&icdrwsug, (LPBYTE)dwP1, (DWORD) dwP2);

	    lpbiSuggest = NULL;
	    lpbiSuggest16 = icdrwsug.lpbiSuggest;
	    if (lpbiSuggest16) {
		lpbiSuggest = ptrFixMap16To32(lpbiSuggest16, 0);
	    }

            // Now fix up the 32 bit structure

            if (icdrwsug.lpbiIn) {
                icdrwsug.lpbiIn = CopyBitmapInfoHeader((DWORD)(DWORD_PTR)icdrwsug.lpbiIn);
            }

            if (icdrwsug.lpbiSuggest) {
                icdrwsug.lpbiSuggest = CopyBitmapInfoHeader((DWORD)(DWORD_PTR)icdrwsug.lpbiSuggest);
            }

            // After the fixups have been done, call the actual routine
            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD_PTR)&icdrwsug,
                                       dwP2);
            if (icdrwsug.lpbiIn) {
                LocalFree(icdrwsug.lpbiIn);
            }

            // We must return the 32 bit suggested format to 16 bit land
            if (icdrwsug.lpbiSuggest) {
                if (ReturnCode == ICERR_OK) {
		    CopyMemory( lpbiSuggest, icdrwsug.lpbiSuggest,
				lpbiSuggest->biSize);
                }
                LocalFree(icdrwsug.lpbiSuggest);
		ptrUnFix16(lpbiSuggest16);
            }
        }
        break;

    case ICM_SET_STATUS_PROC:
        // We do not need to support this under NT.  It is much
        // easier not to add the callback support... even if we could
        // guarantee to be on the right thread to actually do the callback.

	//
	// This message has its own thunk!
	//
	ASSERT( FALSE );


    default:
        ReturnCode = ICERR_UNSUPPORTED;
        break;
    }

EndThunk()
}

INLINE LRESULT FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode)
{
    StartThunk(ICOpen);

    DPF(1, "Calling ICOpen %4.4hs %4.4hs %4X", &fccType, &fccHandler, wMode);
    ReturnCode = (LONG_PTR)ICOpen(fccType, fccHandler, (UINT)wMode);
    EndThunk();
}

INLINE LRESULT FAR PASCAL ICClose32(DWORD hic)
{
    StartThunk(ICClose);
    ReturnCode = ICClose((HIC)hic);
    EndThunk();
}

#endif // _INC_COMPMAN


DWORD ICMThunk32(DWORD dwThunkId,DWORD dw1,DWORD dw2,DWORD dw3,DWORD dw4)
{
    //
    //  Make sure we've got thunking functionality
    //

#if 0
    {
        char    szBuffer[80];
        char    szMsg[32];


        switch (dwThunkId) {

        case compThunkICSendMessage32:
            lstrcpyA( szMsg, "ICSendMessage32" );
            break;

        case compThunkICInfoInternal32:
            lstrcpyA( szMsg, "ICInfoInternal32" );
            break;

        case compThunkICOpen32:
            lstrcpyA( szMsg, "ICOpen32" );
            break;

        case compThunkICClose32:
            lstrcpyA( szMsg, "ICClose32" );
            break;

        default:
            lstrcpyA( szMsg, "Unknown" );
            break;
        }

        wsprintfA( szBuffer, "%18.18s 0x%08X 0x%08X 0x%08X 0x%08X\r\n",
                   szMsg, dw1, dw2, dw3, dw4);

        OutputDebugStringA( szBuffer );

    }
#endif

    if (ThunksInitialized <= 0) {

        HMODULE hMod;

        if (ThunksInitialized == -1) {
            return (DWORD)ICERR_ERROR;
        }

        hMod = GetModuleHandle(GET_MAPPING_MODULE_NAME);
        if (hMod != NULL) {

            GetVDMPointer =
                (LPGETVDMPOINTER)GetProcAddress(hMod, GET_VDM_POINTER_NAME);
            lpWOWHandle32 =
                (LPWOWHANDLE32)GetProcAddress(hMod, GET_HANDLE_MAPPER32 );
            lpWOWHandle16 =
                (LPWOWHANDLE16)GetProcAddress(hMod, GET_HANDLE_MAPPER16 );
	    lpWOWCallback16 =
		(LPWOWCALLBACK16)GetProcAddress(hMod, GET_CALLBACK16);
        }

        if ( GetVDMPointer   == NULL ||
	     lpWOWHandle16   == NULL ||
	     lpWOWHandle32   == NULL ||
	     lpWOWCallback16 == NULL ) {

            ThunksInitialized = -1;
            return (DWORD)ICERR_ERROR;

        } else {
            ThunksInitialized = 1;
        }
    }

    //
    //  Perform the requested function
    //

    switch (dwThunkId) {

        case compThunkICSendMessage32:
            return (DWORD) ICSendMessage32(dw1, (UINT)dw2, dw3, dw4);
            break;

        case compThunkICInfoInternal32:
            return (DWORD) ICInfoInternal32(dw1, dw2, (ICINFOA FAR * )dw3, (ICINFOI FAR *)dw4);
            break;

        case compThunkICOpen32:
            return (DWORD) ICOpen32(dw1, dw2, (UINT)dw3);
            break;

        case compThunkICClose32:
            return (DWORD) ICClose32(dw1);
            break;

	case compThunkICOpenFunction32:
	{
	    DWORD fccType;
	    DWORD fccHandler;
	    UINT  uMode;
	    FARPROC lpfnHandler;

	    fccType	= dw1;
	    fccHandler	= dw2;
	    uMode	= (UINT)dw3;
	    lpfnHandler	= (FARPROC)dw4;

	    // !!! this won't work
	    return (DWORD) (DWORD_PTR) ICOpenFunction( fccType, fccHandler, uMode, lpfnHandler );
	    break;
	}

	case compThunkICSetStatusProc32:
	{
	    DWORD lpstdS;
	    DWORD cbStruct;
	    HIC   hic;
	    LPICSTATUSTHUNKDESC lpstd;
	    LRESULT lr;

	    hic      = (HIC)dw1;
	    lpstdS   = dw2;
	    cbStruct = dw3;
	
	    lpstd = ptrFixMap16To32((LPVOID)lpstdS, sizeof(*lpstd));

	    lr = thkSetStatusProc(hic, lpstd);

	    ptrUnFix16((LPVOID)lpstdS);

	    return (DWORD)lr;
	}

        default:
            return(0);
    }
}

#endif	// NT_THUNK32

#ifdef NT_THUNK16

//==========================================================================;
//
//
//	--- === 16 BIT SIDE === ---
//
//
//==========================================================================;

//
//  --== Global garbage ==--
//
DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
					      DWORD, DWORD,
					      LPVOID, DWORD, DWORD);
DWORD		(FAR PASCAL *lpfnFreeLibrary32W)(DWORD);
TCHAR		gszKernel[]             = TEXT("KERNEL");

TCHAR		gszLoadLibraryEx32W[]   = TEXT("LoadLibraryEx32W");
TCHAR		gszFreeLibrary32W[]     = TEXT("FreeLibrary32W");
TCHAR		gszGetProcAddress32W[]  = TEXT("GetProcAddress32W");
TCHAR		gszCallproc32W[]        = TEXT("CallProc32W");

TCHAR		gszThunkEntry[]         = TEXT("ICMThunk32");
TCHAR		gszMsvfw32[]            = TEXT("msvfw32.dll");

//
//  --==  ==--
//

//--------------------------------------------------------------------------;
//
//  PICMGARB thunkInitialize
//
//  Description:
//	Thunk initialization under NT WOW or Chicago 16-bit.
//
//  Arguments:
//
//  Return (PICMGARB):
//	NULL if thunks are not functional.  Otherwise, a pointer to the
//	ICMGARB structure for the current process is returned.
//
//  History:
//	07/07/94    frankye
//
//  Notes:
//	The lack of a pig for the current process implies that a thunk
//	is being called in the context of a process in which we were never
//	loaded.  If this happens, we allocate a new pig for this process
//	and continue the thunk initialization.  Since we were never
//	loaded in the process, we *probably* will never be freed.  We
//	cannot reliably determine when we can thunkTerminate in the process.
//
//--------------------------------------------------------------------------;
PICMGARB WINAPI thunkInitialize(VOID)
{
    HMODULE   hmodKernel;
    DWORD     (FAR PASCAL *lpfnLoadLibraryEx32W)(LPCSTR, DWORD, DWORD);
    LPVOID    (FAR PASCAL *lpfnGetProcAddress32W)(DWORD, LPCSTR);

    PICMGARB	pig;


    if (NULL == (pig = pigFind()))
    {
	DPF(0, "thunkInitialize: WARNING: ICM called from process %08lXh in which it was never loaded.", GetCurrentProcessId());
	DebugErr(DBF_WARNING, "thunkInitialize: WARNING: ICM called from process in which it was never loaded.");
	return NULL;
    }

    //
    //	If we've already tried and failed...
    //
    if (pig->fThunkError)
    {
	return NULL;
    }

    //
    //	If we already successfully initialized thunks...
    //
    if (pig->fThunksInitialized)
    {
	return pig;
    }

    //
    //	Try to initialize our connection the the 32-bit side...
    //
    DPFS(dbgInit, 1, "thunkInitialize()");

    //
    //	For now, we'll assume we hit an error...
    //
    pig->fThunkError = TRUE;

    //
    //  See if we can find the thunking routine entry points in KERNEL
    //
    hmodKernel = GetModuleHandle(gszKernel);

    if (hmodKernel == NULL)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't GetModuleHandle(kernel)");
        return NULL;
    }

    *(FARPROC *)&lpfnLoadLibraryEx32W =
        GetProcAddress(hmodKernel, gszLoadLibraryEx32W);

    if (lpfnLoadLibraryEx32W == NULL)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't GetProcAddress(kernel, LoadLibraryEx32W)");
        return NULL;
    }

    *(FARPROC *)&lpfnFreeLibrary32W =
        GetProcAddress(hmodKernel, gszFreeLibrary32W);

    if (lpfnFreeLibrary32W == NULL)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't GetProcAddress(kernel, FreeLibrary32W)");
        return NULL;
    }

    *(FARPROC *)&lpfnGetProcAddress32W = GetProcAddress(hmodKernel, gszGetProcAddress32W);

    if (lpfnGetProcAddress32W == NULL)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't GetProcAddress(kernel, GetProcAddress32W)");
        return NULL;
    }

    *(FARPROC *)&lpfnCallproc32W = GetProcAddress(hmodKernel, gszCallproc32W);

    if (lpfnCallproc32W == NULL)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't GetProcAddress(kernel, CallProc32W)");
        return NULL;
    }

    //
    //  See if we can get a pointer to our thunking entry points
    //
    pig->dwMsvfw32Handle = (*lpfnLoadLibraryEx32W)(gszMsvfw32, 0L, 0L);

    if (pig->dwMsvfw32Handle == 0)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't LoadLibraryEx32W(msvfw32.dll)");
        return NULL;
    }

    pig->lpvThunkEntry = (*lpfnGetProcAddress32W)(pig->dwMsvfw32Handle, gszThunkEntry);

    if (pig->lpvThunkEntry == NULL)
    {
	DPFS(dbgInit, 0, "thunkInitialize: Couldn't GetProcAddress32W(msvfw32, ICMThunk32)");
	(*lpfnFreeLibrary32W)(pig->dwMsvfw32Handle);
        return NULL;
    }

    pig->fThunkError = FALSE;
    pig->fThunksInitialized = TRUE;

    DPFS(dbgInit, 4, "thunkInitialize: Done!");

    return pig;
}

//--------------------------------------------------------------------------;
//
//  VOID thunkTerminate
//
//  Description:
//	Thunk termination under NT WOW or Chicago.  Called for each process
//	by 16-bit side to terminate thunks.
//
//  Arguments:
//	PICMGARB pig:
//
//  Return (VOID):
//
//  History:
//	07/07/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID WINAPI thunkTerminate(PICMGARB pig)
{
    ASSERT( NULL != pig );

    if (pig->fThunksInitialized)
    {
	lpfnFreeLibrary32W(pig->dwMsvfw32Handle);
	pig->fThunksInitialized = FALSE;
    }

    return;
}

//--------------------------------------------------------------------------;
//
//
//
//
//--------------------------------------------------------------------------;

/*
 *  Generate our thunks - refer to msvideo!compman.c for definitions of
 *  functions.
 *
 *  NOTE - we often rely here on the fact that most of the message
 *  parameter structures are identical for 16 and 32-bit - ie they
 *  contain DWORDs and 32-bit pointers.
 */

//--------------------------------------------------------------------------;
//
//  LONG thkStatusProc
//
//	This is reached by thunking down from the 32-bit thkStatusProc32.
//	It will call the client's StatusProc.
//
//  Arguments:
//	DWORD dwParam : contains segmented ptr to an ICSTATUSTHUNKDESC.
//	    The ICSTATUSTHUNKDESC is created during the call to ICSetStatusProc.
//
//  Return value:
//	LONG :
//
//--------------------------------------------------------------------------;

LONG FAR PASCAL _loadds thkStatusProc(DWORD dwParam)
{
    LPICSTATUSTHUNKDESC lpstd;

    DPFS(dbgThunks, 4, "thkStatusProc()");

    lpstd = (LPICSTATUSTHUNKDESC)dwParam;
    ASSERT( NULL != lpstd );
    ASSERT( NULL != lpstd->fnStatusProcS );

    return (lpstd->fnStatusProcS)(lpstd->lParam, (UINT)lpstd->uMsg, lpstd->l);
}

//--------------------------------------------------------------------------;
//
//  LRESULT ICSendSetStatusProc32
//
//  Called from 16-bit ICSendMessage to thunk the ICM_SET_STATUS_PROC
//  message to 32-bits
//
//  Arguments:
//	HIC hic :
//
//	LPICSETSTATUSPROC lpissp :
//
//	DWORD : cbStruct
//
//  Return value:
//	LRESULT :
//
//  Notes:
//	!!! For Daytona, we fail this.  If we ever decide to support this
//	on Daytona, then I think we have much more work to do since linear
//	addresses in use by the 32-bit codec may change when the status
//	callback thunks down to 16-bits.  On Chicago, all the linear addresses
//	our fixed when we convert from the segmented address to the linear
//	address.  WHY DOESN'T NT GIVE US AN EASY WAY TO FIX LINEAR ADDRESSES?
//
//--------------------------------------------------------------------------;

LRESULT WINAPI ICSendSetStatusProc32(HIC hic, ICSETSTATUSPROC FAR* lpissp, DWORD cbStruct)
{
#ifdef DAYTONA
    return ICERR_UNSUPPORTED;
#else
    PICMGARB		pig;
    PIC			pic;
    LPICSTATUSTHUNKDESC lpstd;
    LRESULT             lr;

    DPFS(dbgThunks, 4, "ICSendSetStatusProc32()");

    if (NULL == (pig = thunkInitialize())) {
	return ICERR_ERROR;
    }

    pic = (PIC)hic;

    //
    //	This should never fail since the structure was allocated by
    //	our own code in the ICSetStatusProc macro.
    //
    if (cbStruct < sizeof(*lpissp)) {
	ASSERT( FALSE );
	return ICERR_BADPARAM;
    }

    //
    //
    //
    if (NULL != pic->lpstd) {
	DPFS(dbgThunks, 1, "ICSendSetStatusProc32: replacing existing status proc!");
	GlobalUnfix(GlobalPtrHandle(pic->lpstd));
	GlobalFreePtr(pic->lpstd);
	pic->lpstd = NULL;
    }

    //
    //	Allocate a ICSTATUSTHUNKDESC status thunk descriptor.  We fix it
    //	in linear memory here so that it's linear address remains constant
    //	throughout it use.  It's linear address will be given to the 32-bit
    //	codec which will cache it for use in callbacks.
    //
    lpstd = (LPICSTATUSTHUNKDESC)GlobalAllocPtr(GHND, sizeof(*lpstd));
    if (NULL == lpstd) {
	return (ICERR_MEMORY);
    }
    GlobalFix(GlobalPtrHandle(lpstd));

    pic->lpstd = lpstd;

    lpstd->lpstdS		= lpstd;
    lpstd->dwFlags		= lpissp->dwFlags;
    lpstd->lParam		= lpissp->lParam;
    lpstd->fnStatusProcS	= lpissp->Status;
    lpstd->pfnthkStatusProc16S	= thkStatusProc;

    lr = (LRESULT)(*lpfnCallproc32W)(compThunkICSetStatusProc32,
				     (DWORD)pic->h32,
				     (DWORD)lpstd,
				     (DWORD)0,
				     (DWORD)0,
				     pig->lpvThunkEntry,
				     0L,    // Don't map pointers
				     5L);

    if (0 != lr) {
	DPFS(dbgThunks, 1, "ICSendSetStatusProc32: fail");
	GlobalUnfix(GlobalPtrHandle(pic->lpstd));
	GlobalFreePtr(pic->lpstd);
	pic->lpstd = NULL;
    }

    return lr;
#endif
}


BOOL FAR PASCAL ICInfoInternal32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo, ICINFOI FAR * lpicInfoI)
{
    PICMGARB	pig;

    DPFS(dbgThunks, 4, "ICInfoInternal32");

    if (NULL == (pig = thunkInitialize()))
    {
	return FALSE;
    }

    return (BOOL)(*lpfnCallproc32W)(compThunkICInfoInternal32,
				    (DWORD)fccType,
				    (DWORD)fccHandler,
				    (DWORD)lpicInfo,
				    (DWORD)lpicInfoI,
				    pig->lpvThunkEntry,
				    0L,    // Don't map pointers
				    5L);
}

LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2)
{
    PICMGARB	pig;

    DPFS(dbgThunks, 4, "ICSendMessage32(hic=%08lXh, msg=%04Xh, dwP1=%08lXh, dwP2=%08lXh)", hic, msg, dwP1, dwP2);

    if (NULL == (pig = thunkInitialize()))
    {
	switch (msg) {
	case ICM_GETSTATE:
	case ICM_SETSTATE:
	case ICM_GETINFO:
	case ICM_COMPRESS_GET_SIZE:
	    return 0;
	}
	return (LRESULT)ICERR_ERROR;
    }

    return (LRESULT)(*lpfnCallproc32W)(compThunkICSendMessage32,
				       (DWORD)hic,
				       (DWORD)msg,
				       (DWORD)dwP1,
				       (DWORD)dwP2,
				       pig->lpvThunkEntry,
				       0L,    // Don't map pointers
				       5L);
}

LRESULT FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode)
{
    PICMGARB	pig;

    DPFS(dbgThunks, 4, "ICOpen32");

    if (NULL == (pig = thunkInitialize()))
    {
	return NULL;
    }

    return (DWORD)(lpfnCallproc32W)(compThunkICOpen32,
				    (DWORD)fccType,
				    (DWORD)fccHandler,
				    (DWORD)wMode,
				    (DWORD)0L,
				    pig->lpvThunkEntry,
				    0L,    // Don't map pointers
				    5L);
}

LRESULT FAR PASCAL ICOpenFunction32(DWORD fccType, DWORD fccHandler, UINT wMode, FARPROC lpfnHandler)
{
    PICMGARB	pig;

    DPFS(dbgThunks, 4, "ICOpenFunction32");

    if (NULL == (pig = thunkInitialize()))
    {
	return NULL;
    }

    return (LRESULT)(lpfnCallproc32W)(compThunkICOpenFunction32,
				    (DWORD)fccType,
				    (DWORD)fccHandler,
				    (DWORD)wMode,
				    (DWORD)lpfnHandler,
				    pig->lpvThunkEntry,
				    0L,    // Don't map pointers
				    5L);
}

LRESULT FAR PASCAL ICClose32(DWORD hic)
{
    PICMGARB	pig;

    DPFS(dbgThunks, 4, "ICClose32");

    if (NULL == (pig = thunkInitialize()))
    {
	return (LRESULT)ICERR_ERROR;
    }

    return (DWORD)(lpfnCallproc32W)(compThunkICClose32,
				    (DWORD)hic,
				    (DWORD)0L,
				    (DWORD)0L,
				    (DWORD)0L,
				    pig->lpvThunkEntry,
				    0L,    // Don't map pointers
				    5L);
}

#endif // NT_THUNK16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\icm.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  ICM.C
//
//      Helper routines for compressing/decompressing/and choosing compressors.
//
//      (C) Copyright Microsoft Corp. 1991-1995.  All rights reserved.
//
//      You have a royalty-free right to use, modify, reproduce and
//      distribute the Sample Files (and/or any modified version) in
//      any way you find useful, provided that you agree that
//      Microsoft has no warranty obligations or liability for any
//      Sample Application Files.
//
//      If you did not get this from Microsoft Sources, then it may not be the
//      most current version.  This sample code in particular will be updated
//      and include more documentation.
//
//      Sources are:
//         CompuServe: WINSDK forum, MDK section.
//         Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4103)


//
// define these before compman.h, so our functions get declared right.
//
#ifndef _WIN32
#define VFWAPI  FAR PASCAL _loadds
#define VFWAPIV FAR CDECL  _loadds
#endif

#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>

#include <profile.h>

#ifdef DEBUG
static BOOL  fDebug = -1;
    static void CDECL dprintf(LPSTR, ...);
    #define DPF(x)  dprintf x
#else
    #define DPF(x)
#endif

// macro to get the number of chars (byte or word) in a buffer
//
#if !defined NUMELMS
    #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#define NOMMREG
#define NOMSACM
#define NOAVICAP
#include "icm.rc"

#define AVIStreamGetFrameOpen	XAVIStreamGetFrameOpen
#define AVIStreamGetFrame	XAVIStreamGetFrame
#define AVIStreamGetFrameClose	XAVIStreamGetFrameClose

HMODULE havifile;
PGETFRAME (STDAPICALLTYPE  *XAVIStreamGetFrameOpen)(PAVISTREAM pavi,
					 LPBITMAPINFOHEADER lpbiWanted);
LPVOID (STDAPICALLTYPE  *XAVIStreamGetFrame)(PGETFRAME pgf, LONG pos);
HRESULT (STDAPICALLTYPE  *XAVIStreamGetFrameClose)(PGETFRAME pgf);

#ifdef _WIN32
extern HANDLE ghInst;
#else
extern HINSTANCE ghInst;
#endif

///////////////////////////////////////////////////////////////////////////////
//  DIB Macros
///////////////////////////////////////////////////////////////////////////////

#define WIDTHBYTES(i)           ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DibWidthBytes(lpbi)     (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)((lpbi)->biBitCount))

#define DibSizeImage(lpbi)      ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)(UINT)((lpbi)->biHeight))
#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))

#define DibPtr(lpbi)            (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed)
#define DibColors(lpbi)         ((LPRGBQUAD)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

// !!! Someday write this so you don't have to call ICCompressorChoose if you
// !!! know what you want.  Choose would then call this.
// InitCompress(pc, hic/fccHandler, lQuality, lKey, lpbiIn, lpbiOut)

/*****************************************************************************
 * @doc EXTERNAL COMPVARS ICAPPS
 *
 * @types COMPVARS | This structure describes
 *	       compressor when using functions such as <f ICCompressorChoose>,
 *	<f ICSeqCompressFrame>, or <f ICCompressorFree>.
 *
 * @field LONG | cbSize | Set this to the size of this structure in bytes.
 *        This member must be set to validate the structure
 *        before calling any function using this structure.
 *
 * @field DWORD | dwFlags | Specifies the flags for this structure:
 *
 *   @flag ICMF_COMPVARS_VALID | Indicates this structure has valid data.
 *    Set this flag if you fill out this structure manually before
 *    calling any functions. Do not set this flag if you let
 *         <f ICCompressorChoose> initialize this structure.
 *
 * @field HIC | hic | Specifies the handle of the compressor to use.
 *	The <f ICCompressorChoose> function opens the chosen compressor and
 * returns the handle to the compressor in this
 *	member. The compressor is closed by <t ICCompressorFree>.
 *
 * @field DWORD | fccType | Specifies the type of compressor being used.
 *        Currently only ICTYPE_VIDEO is supported. This can be set to zero.
 *
 * @field DWORD | fccHandler | Specifies the four-character code
 *       of the compressor. NULL indicates the data is not
 *       to be recompressed and and 'DIB ' indicates the data is full framed
 *       (uncompressed). You can use this member to specify which
 *	      compressor is selected by default when the dialog box is
 *       displayed.
 *
 * @field LPBITMAPINFO | lpbiIn | Specifies the input format. Used internally.
 *
 * @field LPBITMAPINFO | lpbiOut | Specifies the output format. Ths member
 *        is set by <f ICCompressorChoose>. The <f ICSeqCompressFrameStart>
 *        function uses this member to determine the compressed output format.
 *        If you do not want to use the default format, specify
 *        the preferred one.
 *
 * @field LPVOID | lpBitsOut | Used internally for compression.
 *
 * @field LPVOID | lpBitsPrev | Used internally for temporal compression.
 *
 * @field LONG | lFrame | Used internally to count the number of frames
 *	compressed in a sequence.
 *
 * @field LONG | lKey | Set by <f ICCompressorChoose> to indicate the key frame
 *	rate selected in the dialog box.  The also specifies the rate that
 *	<f ICSeqCompressFrameStart> uses for making key frames.
 *
 * @field LONG | lDataRate | Set by <f ICCompressorChoose> to indicate the
 *	data rate selected in the dialog box. The units are kilobytes per second.
 *
 * @field LONG | lQ | Set by <f ICCompressChoose> to indicate the quality
 *	selected in the dialog box.  This also specifies the quality
 *	<f ICSeqCompressFrameStart> will use. ICQUALITY_DEFAULT specifies
 *	default quality.
 *
 * @field LONG | lKeyCount | Used internally to count key frames.
 *
 * @field LPVOID | lpState | Set by <f ICCompressorChoose> to the state selected
 * in the configuration dialog box for the compressor. The system
 * uses this information to restore the state of the dialog box if
 * it is redisplayed. Used internally.
 *
 * @field LONG | cbState | Used internally for the size of the state information.
 *
 ***************************************************************************/
/*******************************************************************
* @doc EXTERNAL ICCompressorFree ICAPPS
*
* @api void | ICCompressorFree | This function frees the resources
* 	in the <t COMPVARS> structure used by other IC functions.
*
* @parm PCOMPVARS | pc | Specifies a pointer to the <t COMPVARS>
*       structure containing the resources to be freed.
*
* @comm After using the <f ICCompressorChoose>, <f ICSeqCompressFrameStart>,
*       <f ICSeqCompressFrame>, and <f ICSeqCompressFrameEnd> functions, call
*       this function to release the resources in the <t COMPVARS> structure.
*
* @xref <f ICCompressChoose> <f ICSeqCompressFrameStart> <f ICSeqCompressFrame>
*	<f ICSeqCompressFrameEnd>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorFree
//
///////////////////////////////////////////////////////////////////////////////
void VFWAPI ICCompressorFree(PCOMPVARS pc)
{
    /* We were passed an invalid COMPPARMS */
    if (pc == NULL || pc->cbSize != sizeof(COMPVARS))
        return;

    // This function frees every thing in the structure (excuse my
    // french).

    /* Close the compressor */
    if (pc->hic) {
	ICClose(pc->hic);
	pc->hic = NULL;
    }

    /* Free the output format */
    if (pc->lpbiOut) {
	GlobalFreePtr(pc->lpbiOut);
	pc->lpbiOut = NULL;
    }

    /* Free the buffer for compressed image */
    if (pc->lpBitsOut) {
	GlobalFreePtr(pc->lpBitsOut);
	pc->lpBitsOut = NULL;
    }

    /* Free the buffer for the decompressed previous frame */
    if (pc->lpBitsPrev) {
	GlobalFreePtr(pc->lpBitsPrev);
	pc->lpBitsPrev = NULL;
    }

    /* Free the compressor state buffer */
    if (pc->lpState) {
	GlobalFreePtr(pc->lpState);
	pc->lpState = NULL;
    }

    /* This structure is no longer VALID */
    pc->dwFlags = 0;
}

/*******************************************************************
* @doc EXTERNAL ICSeqCompressFrameStart ICAPPS
*
* @api BOOL | ICSeqCompressFrameStart | This function initializes the system
*	prior to using <f ICSeqCompressFrame>.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS> structure
*       initialized with information for compression.
*
* @parm LPBITMAPINFO | lpbiIn | Specifies the format of the data to be
*       compressed.
*
* @rdesc Returns TRUE if successful; otherwise it returns FALSE.
*
* @comm Prior to using this function, use <f ICCompressorChoose> to let the
*       user specify a compressor, or initialize a <t COMPVARS> structure
*       manually. Use <f ICSeqCompressFrameStart>, <f ICSeqCompressFrame>
*       and <f ICSeqCompressFrameEnd> to compress a sequence of
*       frames to a specified data rate and number of key frames.
*       When finished comressing data, use
*       <f ICCompressorFree> to release the resources
*       specified in the <t COMPVARS> structure.
*
*       If you do not use <f ICCompressorChoose> you must
*       initialize the following members of the <t COMPVARS> structure:
*
*	<e COMPVARS.cbSize> Set to the sizeof(COMPVARS) to validate the structure.
*
*	<e COMPVARS.hic> Set to the handle of a compressor you have opened with
*		<f ICOpen>. You do not need to close it (<f ICCompressorFree>
*		will do this for you).
*
*	<e COMPVARS.lpbiOut> Optionally set this to force the compressor
*		to compress to a specific format instead of the default.
*		This will be freed by <f ICCompressorFree>.
*
*	<e COMPVARS.lKey> Set this to the key-frame frequency you want
*     or zero for none.
*
*	<e COMPVARS.lQ> Set this to the quality level to use or ICQUALITY_DEFAULT.
*
*	<e COMPVARS.dwFlags> Set ICMF_COMPVARS_VALID flag to indicate the structure is initialized.
*
* @xref <f ICCompressorChoose> <f ICSeqCompressFrame> <f ICSeqCompressFrameEnd>
*	<f ICCompressorFree>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICSeqCompressFrameStart
//
///////////////////////////////////////////////////////////////////////////////
BOOL VFWAPI ICSeqCompressFrameStart(PCOMPVARS pc, LPBITMAPINFO lpbiIn)
{
    DWORD       dwSize;
    ICINFO	icinfo;

    if (pc == NULL || pc->cbSize != sizeof(COMPVARS))
        return FALSE;

    if (pc->hic == NULL || lpbiIn == NULL)
        return FALSE;

    //
    // make sure the found compressor can handle something
    // if not, force back to the default setting
    //
    if (ICCompressQuery(pc->hic, lpbiIn, pc->lpbiOut) != ICERR_OK) {
        // If the input format has changed since the output was selected,
        // force a reinitialization of the output format
        if (pc->lpbiOut) {
            GlobalFreePtr (pc->lpbiOut);
            pc->lpbiOut = NULL;
        }
    }

    //
    // fill in defaults: key frame every frame, and default quality
    //
    if (pc->lKey < 0)
        pc->lKey = 1;

    if (pc->lQ == ICQUALITY_DEFAULT)
        pc->lQ = ICGetDefaultQuality(pc->hic);

    //
    // If no output format is given, use a default
    //
    if (pc->lpbiOut == NULL) {
	dwSize = ICCompressGetFormatSize(pc->hic, lpbiIn);
	if (!dwSize || !(pc->lpbiOut = (LPBITMAPINFO)GlobalAllocPtr(GMEM_MOVEABLE,dwSize)))
	    goto StartError;
	ICCompressGetFormat(pc->hic, lpbiIn, pc->lpbiOut);
    }
    pc->lpbiOut->bmiHeader.biSizeImage =
        ICCompressGetSize (pc->hic, lpbiIn, pc->lpbiOut);
    pc->lpbiOut->bmiHeader.biClrUsed = DibNumColors(&(pc->lpbiOut->bmiHeader));

    //
    // Set the input format and initialize the key frame count
    //
    pc->lpbiIn = lpbiIn;
    pc->lKeyCount = pc->lKey;
    pc->lFrame = 0;		// first frame we'll be compressing is 0

    if (ICCompressQuery(pc->hic, lpbiIn, pc->lpbiOut) != ICERR_OK)
        goto StartError;

    //
    // Allocate a buffer for the compressed bits
    //
    dwSize = pc->lpbiOut->bmiHeader.biSizeImage;

    // !!! Hack for VidCap... make it big enough for two RIFF structs and
    // !!! pad records.
    //
    dwSize += 2048 + 16;

    if (!(pc->lpBitsOut = GlobalAllocPtr(GMEM_MOVEABLE, dwSize)))
        goto StartError;

    //
    // Allocate a buffer for the decompressed previous frame if it can do
    // key frames and we want key frames and it needs such a buffer.
    //
    ICGetInfo(pc->hic, &icinfo, sizeof(icinfo));
    if ((pc->lKey != 1) && (icinfo.dwFlags & VIDCF_TEMPORAL) &&
		!(icinfo.dwFlags & VIDCF_FASTTEMPORALC)) {
        dwSize = lpbiIn->bmiHeader.biSizeImage;
        if (!(pc->lpBitsPrev = GlobalAllocPtr(GMEM_MOVEABLE, dwSize)))
            goto StartError;
    }

    //
    // now get compman ready for the big job
    //
    if (ICCompressBegin(pc->hic, lpbiIn, pc->lpbiOut) != ICERR_OK)
        goto StartError;

    //
    // Get ready to decompress previous frames if we're doing key frames
    // If we can't decompress, we must do all key frames
    //
    if (pc->lpBitsPrev) {
        if (ICDecompressBegin(pc->hic, pc->lpbiOut, lpbiIn) != ICERR_OK) {
	    pc->lKey = pc->lKeyCount = 1;
	    GlobalFreePtr(pc->lpBitsPrev);
	    pc->lpBitsPrev = NULL;
	}
    }

    return TRUE;

StartError:

    // !!! Leave stuff allocated because ICCompressorFree() will clear things
    return FALSE;
}

/*******************************************************************
* @doc EXTERNAL ICSeqCompressFrameEnd ICAPPS
*
* @api void | ICSeqCompressFrameEnd | This function terminates sequence
*	compression using <f ICSeqCompressFrame>.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS> structure
*       used during sequence compression.
*
* @comm Use <f ICCompressorChoose> to let the
*       user specify a compressor to use, or initialize a <t COMPVARS> structure
*       manually. Use <f ICSeqCompressFrameStart>, <f ICSeqCompressFrame>
*       and <f ICSeqCompressFrameEnd> functions to compress a sequence of
*       frames to a specified data rate and number of key frames. When
*       finished with compression, use <f ICCompressorFree> to
*       release the resources specified by the <t COMPVARS> structure.
*
* @xref <f ICCompressorChoose> <f ICSeqCompressFrame> <f ICCompressorFree>
*	<f ICSeqCompressFrameStart>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICSeqCompressFrameEnd
//
///////////////////////////////////////////////////////////////////////////////
void VFWAPI ICSeqCompressFrameEnd(PCOMPVARS pc)
{
    if (pc == NULL || pc->cbSize != sizeof(COMPVARS))
        return;

    // This function still leaves pc->hic and pc->lpbiOut alloced and open
    // since they were set by ICCompressorChoose

    // Seems we've already freed everything - don't call ICCompressEnd twice
    if (pc->lpBitsOut == NULL)
        return;

    /* Stop compressing */
    if (pc->hic) {
        ICCompressEnd(pc->hic);

        if (pc->lpBitsPrev)
            ICDecompressEnd(pc->hic);
    }

    /* Free the buffer for compressed image */
    if (pc->lpBitsOut) {
	GlobalFreePtr(pc->lpBitsOut);
	pc->lpBitsOut = NULL;
    }

    /* Free the buffer for the decompressed previous frame */
    if (pc->lpBitsPrev) {
	GlobalFreePtr(pc->lpBitsPrev);
	pc->lpBitsPrev = NULL;
    }
}

/*******************************************************************
* @doc EXTERNAL ICSeqCompressFrame ICAPPS
*
* @api LPVOID | ICSeqCompressFrame | This function compresses a
*  frame in a sequence of frames. The data rate for the sequence
*  as well as the key-frame frequency can be specified. Use this function
*  once for each frame to be compressed.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS> structure
*       initialized with information about the compression.
*
* @parm UINT | uiFlags | Specifies flags for this function. Set this
*       parameter to zero.
*
* @parm LPVOID | lpBits | Specifies a pointer the data bits to compress.
*       (The data bits excludes header or format information.)
*
* @parm BOOL FAR * | pfKey | Returns whether or not the frame was compressed
*       into a keyframe.
*
* @parm LONG FAR * | plSize | Specifies the maximum size desired for
*       the compressed image. The compressor might not be able to
*       compress the data to within this size. When the function
*       returns, the parameter points to the size of the compressed
*       image. Images sizes are specified in bytes.
*
* @rdesc Returns a pointer to the compressed bits.
*
* @comm Use <f ICCompressorChoose> to let the
*       user specify a compressor to use, or initialize a <t COMPVARS> structure
*       manually. Use <f ICSeqCompressFrameStart>, <f ICSeqCompressFrame>
*       and <f ICSeqCompressFrameEnd> functions to compress a sequence of
*       frames to a specified data rate and number of key frames. When
*       finished with compression, use <f ICCompressorFree> to
*       release the resources specified by the <t COMPVARS> structure.
*
*	Use this function repeatedly to compress a video sequence one
*  frame at a time. Use this function instead of <f ICCompress>
*  to compress a video sequence. This function supports creating key frames
*	in the compressed sequence at any frequency you like and handles
*  much of the initialization process.
* @xref <f ICCompressorChoose> <f ICSeqCompressFrameEnd> <f ICCompressorFree>
*	<f ICCompressorFreeStart>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICSeqCompressFrame
//
//      compresses a given image but supports KEY FRAMES EVERY
//
//  input:
//      pc          stuff
//      uiFlags     flags (not used, must be 0)
//      lpBits      input DIB bits
//      lQuality    the reqested compression quality
//      pfKey       did this frame end up being a key frame?
//
//  returns:
//      a HANDLE to the converted image.  The handle is a DIB in CF_DIB
//      format, ie a packed DIB.  The caller is responsible for freeing
//      the memory.   NULL is returned if error.
//
///////////////////////////////////////////////////////////////////////////////
LPVOID VFWAPI ICSeqCompressFrame(
    PCOMPVARS               pc,         // junk set up by Start()
    UINT                    uiFlags,    // flags
    LPVOID                  lpBits,     // input DIB bits
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize)	// requested size/size of returned image
{
    LONG    l;
    DWORD   dwFlags = 0;
    DWORD   ckid = 0;
    BOOL    fKey;
    LONG    lSize = plSize ? *plSize : 0;

    // Is it time to make a keyframe?
    // First frame will always be a keyframe cuz they initialize to the same
    // value.

    if (fKey = (pc->lKeyCount >= pc->lKey)) {
	// For compatibility with existing old apps
	dwFlags = AVIIF_KEYFRAME;
    }

    l = ICCompress(pc->hic,
            fKey ? ICCOMPRESS_KEYFRAME : 0,   // flags
            (LPBITMAPINFOHEADER)pc->lpbiOut,    // output format
            pc->lpBitsOut,  // output data
            (LPBITMAPINFOHEADER)pc->lpbiIn,     // format of frame to compress
            lpBits,         // frame data to compress
            &ckid,          // ckid for data in AVI file
            &dwFlags,       // flags in the AVI index.
            pc->lFrame,     // frame number of seq.
            lSize,          // reqested size in bytes. (if non zero)
            pc->lQ,         // quality
            fKey ? NULL : (LPBITMAPINFOHEADER)pc->lpbiIn, // fmt of prev frame
            fKey ? NULL : pc->lpBitsPrev); 		  // previous frame

    if (l < ICERR_OK)
        goto FrameError;

    /* Return the size of the compressed data */
    if (plSize)
	*plSize = pc->lpbiOut->bmiHeader.biSizeImage;
        // note: we do not reset biSizeImage... despite the fact that we
        // allocated this structure, we know its size, and after compression
        // the size is wrong!!

    /* Now decompress the frame into our buffer for the previous frame */
    if (pc->lpBitsPrev) {
	l = ICDecompress(pc->hic,
		 0,
		 (LPBITMAPINFOHEADER)pc->lpbiOut,
		 pc->lpBitsOut,
                 (LPBITMAPINFOHEADER)pc->lpbiIn,  // !!! should check for this.
		 pc->lpBitsPrev);

	if (l != ICERR_OK)
	    goto FrameError;
    }

    /* Was the compressed image a keyframe? */
    *pfKey = (BOOL)(dwFlags & AVIIF_KEYFRAME);

    /* After making a keyframe, reset our counter that tells us when we MUST */
    /* make another one.	*/
    if (*pfKey)
	pc->lKeyCount = 0;

    // Never make a keyframe again after the first one if we don't want them.
    // Increment our counter of how long its been since the last one if we do.
    if (pc->lKey)
        pc->lKeyCount++;
    else
	pc->lKeyCount = -1;

    // Next time we're called we're on the next frame
    pc->lFrame++;

    return (pc->lpBitsOut);

FrameError:

    return NULL;
}


/*******************************************************************
* @doc EXTERNAL ICImageCompress ICAPPS
*
* @api HANDLE | ICImageCompress | This function provides
*  convenient method of compressing an image to a given
*	size. This function does not require use of initialization functions.
*
* @parm HIC | hic | Specifies the handle to a compressor to
*       opened with <f ICOpen> or NULL. Use NULL to choose a
*       default compressor for your compression format.
*       Applications can use the compressor handle returned
*       by <f ICCompressorChoose> in the <e COMPVARS.hic> member
*       of the <t COMPVARS> structure if they want the user to
*       select the compressor. This compressor is already opened.
*
* @parm UINT | uiFlags | Specifies flags for this function.  Set this
*       to zero.
*
* @parm LPBITMAPINFO | lpbiIn | Specifies the input data format.
*
* @parm LPVOID | lpBits | Specifies a pointer to input data bits to compress.
*       (The data bits excludes header or format information.)
*
* @parm LPBITMAPINFO | lpbiOut | Specifies the compressed output format or NULL.
*       If NULL, the compressor uses  a default format.
*
* @parm LONG | lQuality | Specifies the quality value the compressor.
*
* @parm LONG FAR * | plSize | Specifies the maximum size desired for
*       the compressed image. The compressor might not be able to
*       compress the data to within this size. When the function
*       returns, the parameter points to the size of the compressed
*       image. Images sizes are specified in bytes.
*
*
* @rdesc Returns a handle to a compressed DIB. The image data follows the
*        format header.
*
* @comm This function returns a DIB with the format and image data.
*  To obtain the format information from the <t LPBITMAPINFOHEADER> structure,
*  use <f GlobalLock> to lock the data. Use <f GlobalFree> to free the
*  DIB when you have finished with it.
*
* @xref <f ICImageDecompress>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICImageCompress
//
//      compresses a given image.
//
//  input:
//      hic         compressor to use, if NULL is specifed a
//                  compressor will be located that can handle the conversion.
//      uiFlags     flags (not used, must be 0)
//      lpbiIn      input DIB format
//      lpBits      input DIB bits
//      lpbiOut     output format, if NULL is specifed the default
//                  format choosen be the compressor will be used.
//      lQuality    the reqested compression quality
//      plSize      the reqested size for the image/returned size
//
//  returns:
//      a handle to a DIB which is the compressed image.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE VFWAPI ICImageCompress(
    HIC                     hic,        // compressor (NULL if any will do)
    UINT                    uiFlags,    // flags
    LPBITMAPINFO	    lpbiIn,     // input DIB format
    LPVOID                  lpBits,     // input DIB bits
    LPBITMAPINFO	    lpbiOut,    // output format (NULL => default)
    LONG                    lQuality,   // the reqested quality
    LONG FAR *		    plSize)     // requested size for compressed frame
{
    LONG    l;
    BOOL    fNuke;
    DWORD   dwFlags = 0;
    DWORD   ckid = 0;
    LONG    lSize = plSize ? *plSize : 0;

    LPBITMAPINFOHEADER lpbi=NULL;

    //
    // either locate a compressor or use the one supplied.
    //
    if (fNuke = (hic == NULL))
    {
        hic = ICLocate(ICTYPE_VIDEO, 0L, (LPBITMAPINFOHEADER)lpbiIn,
		(LPBITMAPINFOHEADER)lpbiOut, ICMODE_COMPRESS);

        if (hic == NULL)
            return NULL;
    }

    //
    // make sure the found compressor can compress something ??? WHY BOTHER ???
    //
    if (ICCompressQuery(hic, lpbiIn, NULL) != ICERR_OK)
        goto error;

    if (lpbiOut)
    {
	l = lpbiOut->bmiHeader.biSize + 256 * sizeof(RGBQUAD);
    }
    else
    {
	//
	//  now make a DIB header big enough to hold the output format
	//
	l = ICCompressGetFormatSize(hic, lpbiIn);

	if (l <= 0)
	    goto error;
    }

    lpbi = (LPVOID)GlobalAllocPtr(GHND, l);

    if (lpbi == NULL)
        goto error;

    //
    //  if the compressor likes the passed format, use it else use the default
    //  format of the compressor.
    //
    if (lpbiOut == NULL || ICCompressQuery(hic, lpbiIn, lpbiOut) != ICERR_OK)
        ICCompressGetFormat(hic, lpbiIn, lpbi);
    else
        hmemcpy(lpbi, lpbiOut, lpbiOut->bmiHeader.biSize +
		lpbiOut->bmiHeader.biClrUsed * sizeof(RGBQUAD));

    lpbi->biSizeImage = ICCompressGetSize(hic, lpbiIn, lpbi);
    lpbi->biClrUsed = DibNumColors(lpbi);

    //
    // now resize the DIB to be the maximal size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi,DibSize(lpbi), 0);

    if (lpbi == NULL)
        goto error;

    //
    // now compress it.
    //
    if (ICCompressBegin(hic, lpbiIn, lpbi) != ICERR_OK)
        goto error;

    if (lpBits == NULL)
        lpBits = DibPtr((LPBITMAPINFOHEADER)lpbiIn);

    if (lQuality == ICQUALITY_DEFAULT)
        lQuality = ICGetDefaultQuality(hic);

    l = ICCompress(hic,
            0,              // flags
            (LPBITMAPINFOHEADER)lpbi,  // output format
            DibPtr(lpbi),   // output data
            (LPBITMAPINFOHEADER)lpbiIn,// format of frame to compress
            lpBits,         // frame data to compress
            &ckid,          // ckid for data in AVI file
            &dwFlags,       // flags in the AVI index.
            0,              // frame number of seq.
            lSize,          // requested size in bytes. (if non zero)
            lQuality,       // quality
            NULL,           // format of previous frame
            NULL);          // previous frame

    if (l < ICERR_OK) {
	DPF(("ICCompress returned %ld!\n", l));
        ICCompressEnd(hic);
        goto error;
    }

    // Return the size of the compressed data
    if (plSize)
	*plSize = lpbi->biSizeImage;

    if (ICCompressEnd(hic) != ICERR_OK)
        goto error;

    //
    // now resize the DIB to be the real size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi, DibSize(lpbi), 0);

    //
    // all done return the result to the caller
    //
    if (fNuke)
        ICClose(hic);

    GlobalUnlock(GlobalPtrHandle(lpbi));
    return GlobalPtrHandle(lpbi);

error:
    if (lpbi)
        GlobalFreePtr(lpbi);

    if (fNuke)
        ICClose(hic);

    return NULL;
}
/*******************************************************************
*
* @doc EXTERNAL ICImageDecompress ICAPPS
*
* @api HANDLE | ICImageDecompress | This function provides
*  convenient method of decompressing an image without
*	using initialization functions.
**
* @parm HIC | hic | Specifies the handle to a decompressor opened
*       with <f ICOpen> or NULL.  Use NULL to choose a default
*       decompressor for your format.
*
* @parm UINT | uiFlags | Specifies flags for this function.  Set this
*       to zero.
*
* @parm LPBITMAPINFO | lpbiIn | Specifies the compressed input data format.
*
* @parm LPVOID | lpBits | Specifies a pointer to input data bits to compress.
*       (The data bits excludes header or format information.)
*
* @parm LPBITMAPINFO | lpbiOut | Specifies the decompressed output format or NULL.
*       If NULL, the decompressor uses  a default format.
*
* @rdesc Returns a handle to an uncompressed DIB in the CF_DIB format,
*        or NULL for an error. The image data follows the format header.
*
* @comm This function returns a DIB with the format and image data.
*  To obtain the format information from the <t LPBITMAPINFOHEADER> structure,
*  use <f GlobalLock> to lock the data. Use <f GlobalFree> to free the
*  DIB when you have finished with it.
*

* @xref <f ICImageCompress>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICImageDecompress
//
//      decompresses a given image.
//
//  input:
//      hic         compressor to use, if NULL is specifed a
//                  compressor will be located that can handle the conversion.
//      uiFlags     flags (not used, must be 0)
//      lpbiIn      input DIB format
//      lpBits      input DIB bits
//      lpbiOut     output format, if NULL is specifed the default
//                  format choosen be the compressor will be used.
//
//  returns:
//      a HANDLE to the converted image.  The handle is a DIB in CF_DIB
//      format, ie a packed DIB.  The caller is responsible for freeing
//      the memory.   NULL is returned if error.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE VFWAPI ICImageDecompress(
    HIC                     hic,        // compressor (NULL if any will do)
    UINT                    uiFlags,    // flags
    LPBITMAPINFO            lpbiIn,     // input DIB format
    LPVOID                  lpBits,     // input DIB bits
    LPBITMAPINFO            lpbiOut)    // output format (NULL => default)
{
    LONG    l;
    BOOL    fNuke;
    DWORD   dwFlags = 0;
    DWORD   ckid = 0;

    LPBITMAPINFOHEADER lpbi=NULL;

    //
    // either locate a compressor or use the one supplied.
    //
    if (fNuke = (hic == NULL))
    {
        hic = ICLocate(ICTYPE_VIDEO, 0L, (LPBITMAPINFOHEADER)lpbiIn,
		(LPBITMAPINFOHEADER)lpbiOut, ICMODE_DECOMPRESS);

        if (hic == NULL)
            return NULL;
    }

    //
    // make sure the found compressor can decompress at all ??? WHY BOTHER ???
    //
    if (ICDecompressQuery(hic, lpbiIn, NULL) != ICERR_OK)
        goto error;

    if (lpbiOut)
    {
	l = lpbiOut->bmiHeader.biSize + 256 * sizeof(RGBQUAD);
    }
    else
    {
	//
	//  now make a DIB header big enough to hold the output format
	//
	l = ICDecompressGetFormatSize(hic, lpbiIn);

	if (l <= 0)
	    goto error;
    }

    lpbi = (LPVOID)GlobalAllocPtr(GHND, l);

    if (lpbi == NULL)
        goto error;

    //
    //  if we didn't provide an output format, use a default.
    //
    if (lpbiOut == NULL)
        ICDecompressGetFormat(hic, lpbiIn, lpbi);
    else
        hmemcpy(lpbi, lpbiOut, lpbiOut->bmiHeader.biSize +
		lpbiOut->bmiHeader.biClrUsed * sizeof(RGBQUAD));

    //
    // For decompress make sure the palette (ie color table) is correct
    // just in case they provided an output format and the decompressor used
    // that format but not their palette.
    //
    if (lpbi->biBitCount <= 8)
        ICDecompressGetPalette(hic, lpbiIn, lpbi);

    lpbi->biSizeImage = DibSizeImage(lpbi); // ICDecompressGetSize(hic, lpbi);
    lpbi->biClrUsed = DibNumColors(lpbi);

    //
    // now resize the DIB to be the right size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi,DibSize(lpbi),0);

    if (lpbi == NULL)
        goto error;

    //
    // now decompress it.
    //
    if (ICDecompressBegin(hic, lpbiIn, lpbi) != ICERR_OK)
        goto error;

    if (lpBits == NULL)
        lpBits = DibPtr((LPBITMAPINFOHEADER)lpbiIn);

    l = ICDecompress(hic,
            0,              // flags
            (LPBITMAPINFOHEADER)lpbiIn, // format of frame to decompress
            lpBits,         // frame data to decompress
            (LPBITMAPINFOHEADER)lpbi,   // output format
            DibPtr(lpbi));  // output data

    if (l < ICERR_OK) {
	ICDecompressEnd(hic);
        goto error;
    }

    if (ICDecompressEnd(hic) != ICERR_OK)
        goto error;

    //
    // now resize the DIB to be the real size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi,DibSize(lpbi),0);

    //
    // all done return the result to the caller
    //
    if (fNuke)
        ICClose(hic);

    GlobalUnlock(GlobalPtrHandle(lpbi));
    return GlobalPtrHandle(lpbi);

error:
    if (lpbi)
        GlobalFreePtr(lpbi);

    if (fNuke)
        ICClose(hic);

    return NULL;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorChooseStuff
//
///////////////////////////////////////////////////////////////////////////////

INT_PTR VFWAPI ICCompressorChooseDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

typedef struct {
    DWORD       fccType;
    DWORD       fccHandler;
    UINT        uiFlags;
    LPVOID      pvIn;
    LPVOID      lpData;
    HWND	hwnd;
    HIC         hic;
    LONG        lQ;
    LONG        lKey;
    LONG        lDataRate;
    ICINFO      icinfo;
    LPSTR       lpszTitle;
    PAVISTREAM  pavi;
    AVISTREAMINFOW info;
    HDRAWDIB	hdd;
    PGETFRAME	pgf;
    LPVOID	lpState;
    LONG	cbState;
    BOOL	fClosing;
} ICCompressorChooseStuff, FAR *PICCompressorChooseStuff;

/*******************************************************************
* @doc EXTERNAL ICCompressorChoose ICAPPS
*
* @api BOOL | ICCompressorChoose | Displays a dialog box for choosing a
*	compressor. It optionally provides a data rate box, key frame box, preview
*	window, and filtering to display only compressors that can handle a
*	specific format.
*
* @parm HWND | hwnd | Specifies the parent window for the dialog box.
*
* @parm UINT | uiFlags | Specifies flags for this function. The following
*      flags are defined:
*
* @flag ICMF_CHOOSE_KEYFRAME | Displays a check box and edit box to enter the
*	frequency of key frames.
*
* @flag ICMF_CHOOSE_DATARATE | Displays a check box and edit box to enter the
*	data rate for the movie.
*
* @flag ICMF_CHOOSE_PREVIEW | Displays a button to expand the dialog box to
*	     include a preview window. The preview window shows how
*       frames of your movie will appear when compressed with the
*       current settings.
*
* @flag ICMF_CHOOSE_ALLCOMPRESSORS | Indicates all compressors should
*       should appear in the selection list. If this flag is not specified,
*       just the compressors that can handle the input format appear in
*       the selection list.
*
* @parm LPVOID | pvIn | Specifies the uncompressed
*       data input format. This parameter is optional.
*
* @parm LPVOID | lpData | Specifies a <t PAVISTREAM> of type
*       streamtypeVIDEO to use in the preview window. This parameter
*       is optional.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS>
*      structure. The information returned initializes the
*      structure for use with other functions.
*
* @parm LPSTR | lpszTitle | Points to a optional zero-terminated string
*       containing a title for the dialog box.
*
* @rdesc Returns TRUE if the user chooses a compressor, and presses OK.  Returns
*	FALSE for an error, or if the user presses CANCEL.
*
* @comm This function lets the user select a compressor from a list.
*	Before using it, set the <e COMPVARS.cbSize> member of the <t COMPVARS>
*  structure to sizeof(COMPVARS). Initialize the rest of the structure
*  to zeros unless you want to specify some valid defaults for
*	the dialog box. If specifing defaults, set the <e COMPVARS.dwFlags>
*	member to ICMF_COMPVARS_VALID, and initialize the other members of
*  the structure. See <f ICSeqCompressorFrameStart> and <t COMPVARS>
*  for more information about initializing the structure.
*
* @xref <f ICCompressorFree> <f ICSeqCompressFrameStart> <f ICSeqCompressFrame>
*	<f ICSeqCompressFrameEnd>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorChoose
//
//      Brings up a dialog and allows the user to choose a compression
//      method and a quality level, and/or a key frame frequency.
//	All compressors in the system are displayed or can be optionally
//	filtered by "ability to compress" a specifed format.
//
//      the dialog allows the user to configure or bring up the compressors
//      about box.
//
//      A preview window can be provided to show a preview of a specific
//      compression.
//
//      the selected compressor is opened (via ICOpen) and returned to the
//      caller, it must be disposed of by calling ICCompressorFree.
//
//  input:
//      HWND    hwnd            parent window for dialog box.
//      UINT    uiFlags         flags
//      LPVOID  pvIn            input format (optional), only compressors that
//				handle this format will be displayed.
//      LPVOID  pavi 	        input stream for the options preview
//      PCOMPVARS pcj           returns COMPVARS struct for use with other APIs
//      LPSTR   lpszTitle	Optional title for dialog box
//
//  returns:
//      TRUE if dialog shown and user chose a compressor.
//      FALSE if dialog was not shown or user hit cancel.
//
///////////////////////////////////////////////////////////////////////////////

BOOL VFWAPI ICCompressorChoose(
    HWND        hwnd,               // parent window for dialog
    UINT        uiFlags,            // flags
    LPVOID      pvIn,               // input format (optional)
    LPVOID      pavi,               // input stream (for preview - optional)
    PCOMPVARS   pcj,                // state of compressor/dlg
    LPSTR       lpszTitle)          // dialog title (if NULL, use default)
{
    INT_PTR f;
    PICCompressorChooseStuff p;
    DWORD	dwSize;

    if (pcj == NULL || pcj->cbSize != sizeof(COMPVARS))
        return FALSE;

    //
    // !!! Initialize the structure - unless the user has already done it
    //
    if (!(pcj->dwFlags & ICMF_COMPVARS_VALID)) {
        pcj->hic = NULL;
        pcj->fccType = 0;
        pcj->fccHandler = 0;
        pcj->lQ = ICQUALITY_DEFAULT;
        pcj->lKey = -1;	// means default
        pcj->lDataRate = 300;
        pcj->lpbiOut = NULL;
        pcj->lpBitsOut = NULL;
        pcj->lpBitsPrev = NULL;
        pcj->dwFlags = 0;
        pcj->lpState = NULL;
        pcj->cbState = 0;
    }

    // Default type is a video compressor
    if (pcj->fccType == 0)
        pcj->fccType = ICTYPE_VIDEO;

    p = (LPVOID)GlobalAllocPtr(GHND, sizeof(ICCompressorChooseStuff));

    if (p == NULL)
        return FALSE;

    p->fccType    = pcj->fccType;
    p->fccHandler = pcj->fccHandler;
    p->uiFlags    = uiFlags;
    p->pvIn       = pvIn;
    p->lQ         = pcj->lQ;
    p->lKey       = pcj->lKey;
    p->lDataRate  = pcj->lDataRate;
    p->lpszTitle  = lpszTitle;
    p->pavi       = (PAVISTREAM)pavi;
    p->hdd        = NULL;
    p->lpState    = pcj->lpState;
    pcj->lpState = NULL;	// so it won't be freed
    p->cbState    = pcj->cbState;
    // !!! Validate this pointer
    // !!! AddRef if it is
    if (p->pavi) {
        if (p->pavi->lpVtbl->Info(p->pavi, &p->info, sizeof(p->info)) !=
		AVIERR_OK || p->info.fccType != streamtypeVIDEO)
	    p->pavi = NULL;
    }

    f = DialogBoxParam(ghInst, TEXT("ICCDLG"),
		hwnd, ICCompressorChooseDlgProc, (LPARAM)(LPVOID)p);

    // !!! Treat error like cancel
    if (f == -1)
	f = FALSE;

    //
    // if the user picked a compressor then return this info to the caller
    //
    if (f) {

	// If we are called twice in a row, we have good junk in here that
	// needs to be freed before we tromp over it.
	ICCompressorFree(pcj);

        pcj->lQ = p->lQ;
        pcj->lKey = p->lKey;
        pcj->lDataRate = p->lDataRate;
        pcj->hic = p->hic;
        pcj->fccHandler = p->fccHandler;
        pcj->lpState = p->lpState;
        pcj->cbState = p->cbState;

	pcj->dwFlags |= ICMF_COMPVARS_VALID;
    }

    GlobalFreePtr(p);

    if (!f)
	return FALSE;

    if (pcj->hic && pvIn) {  // hic is NULL if no compression selected

        /* Get the format we're going to compress into. */
        dwSize = ICCompressGetFormatSize(pcj->hic, pvIn);
        if (!dwSize || ((pcj->lpbiOut =
		(LPBITMAPINFO)GlobalAllocPtr(GMEM_MOVEABLE, dwSize)) == NULL)) {
            ICClose(pcj->hic);		// Close this since we're erroring
            pcj->hic = NULL;
            return FALSE;
        }
        ICCompressGetFormat(pcj->hic, pvIn, pcj->lpbiOut);
    }

    return TRUE;
}

void SizeDialog(HWND hwnd, WORD id) {
    RECT	rc;

    GetWindowRect(GetDlgItem(hwnd, id), &rc);

    /* First, get rc in Client co-ords */
    ScreenToClient(hwnd, (LPPOINT)&rc + 1);
    rc.top = 0;	rc.left = 0;

    /* Grow by non-client size */
    AdjustWindowRect(&rc, GetWindowLong(hwnd, GWL_STYLE),
	GetMenu(hwnd) !=NULL);

    /* That's the new size for the dialog */
    SetWindowPos(hwnd, NULL, 0, 0, rc.right-rc.left,
	        rc.bottom-rc.top,
	        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
}


void TermPreview(PICCompressorChooseStuff p)
{
    if (p->hdd)
        DrawDibClose(p->hdd);
    p->hdd = NULL;
}


BOOL InitPreview(HWND hwnd, PICCompressorChooseStuff p) {

    p->hdd = DrawDibOpen();
    if (!p->hdd)
	return FALSE;

    return TRUE;
}

#ifdef SAFETOYIELD
//
// Code to yield while we're not calling GetMessage.
// Dispatch all messages.  Pressing ESC or closing aborts.
//
BOOL WinYield(HWND hwnd)
{
    MSG msg;
    BOOL fAbort=FALSE;

    while(/* fWait > 0 && */ !fAbort && PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
	if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
            fAbort = TRUE;
	if (msg.message == WM_SYSCOMMAND && (msg.wParam & 0xFFF0) == SC_CLOSE)
	    fAbort = TRUE;

	if (msg.hwnd == hwnd) {
	    if (msg.message == WM_KEYDOWN ||
		msg.message == WM_SYSKEYDOWN ||
		msg.message == WM_HSCROLL ||
		msg.message == WM_PARENTNOTIFY ||
		msg.message == WM_LBUTTONDOWN) {
		PostMessage(hwnd, msg.message, msg.wParam, msg.lParam);
		return TRUE;
	    }
	}
	
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    return fAbort;
}
#endif

LONG CALLBACK _loadds PreviewStatusProc(LPARAM lParam, UINT message, LONG l)
{
    TCHAR   ach[100], achT[100];
    BOOL    f;
    PICCompressorChooseStuff p = (PICCompressorChooseStuff) lParam;

    if (message != ICSTATUS_STATUS) {
	DPF(("Status callback: lParam = %lx, message = %u, l = %lu\n", lParam, message, l));
    }

    // !!!!
    // !!!! Status messages need to be fixed!!!!!!
    // !!!!

    switch (message) {
	case ICSTATUS_START:
	    break;
	
	case ICSTATUS_STATUS:
            LoadString (ghInst, ID_FRAMECOMPRESSING, achT, NUMELMS(achT));
	    wsprintf(ach, achT, GetScrollPos(GetDlgItem(p->hwnd,
				ID_PREVIEWSCROLL), SB_CTL), l);
	
	    SetDlgItemText(p->hwnd, ID_PREVIEWTEXT, ach);
	    break;
	
	case ICSTATUS_END:
	    break;

	case ICSTATUS_YIELD:

	    break;
    }

#ifdef SAFETOYIELD
    f = WinYield(p->hwnd);
#else
    f = FALSE;
#endif

    if (f) {
	DPF(("Aborting from within status proc!\n"));
    }

    return f;
}


void Preview(HWND hwnd, PICCompressorChooseStuff p, BOOL fCompress)
{
    RECT	rc;
    HDC		hdc;
    int		pos;
    HANDLE	h;
    HCURSOR	hcur = NULL;
    LPBITMAPINFOHEADER	lpbi, lpbiU, lpbiC = NULL;
    TCHAR       ach[120], achT[100];
    LONG	lsizeD = 0;
    LONG	lSize;
    int		x;

    // Not previewing right now!
    if (!p->hdd || !p->pgf)
	return;

    pos = GetScrollPos(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL);
    lpbi = lpbiU = AVIStreamGetFrame(p->pgf, pos);
    if (!lpbi)
	return;

    //
    // What would the image look like compressed?
    //
    if (fCompress && ((INT_PTR)p->hic > 0)) {
	LRESULT		lRet;

	lRet = (LRESULT)ICSetStatusProc(p->hic, 0, (LPARAM)p, PreviewStatusProc);
	if (lRet != 0) {
	    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	}
	
	// !!! Gives whole data rate to this stream
	// !!! What to do if Rate or Scale is zero?
	lSize = (GetDlgItemInt(hwnd, ID_DATARATE, NULL, FALSE)  * 1024L) /
		    ((p->info.dwScale && p->info.dwRate) ?
		    (p->info.dwRate / p->info.dwScale) : 1L);
        h = ICImageCompress(p->hic,
	    0,
	    (LPBITMAPINFO)lpbi,
	    (LPBYTE)lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD),
	    NULL,
	    GetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL) * 100,
	    &lSize);
	if (hcur)
	    SetCursor(hcur);
        if (h)
            lpbiC = (LPBITMAPINFOHEADER)GlobalLock(h);
        // Use the compressed image if we have one.. else use the original frame
        if (lpbiC)
	    lpbi = lpbiC;
    }

    //
    // If we chose NO COMPRESSION, tell them the size of the data as its
    // compressed now.  Otherwise, use the size it will become when compressed
    // or the full frame size.
    //
    if (fCompress && (p->hic == 0)) {
	p->pavi->lpVtbl->Read(p->pavi, pos, 1, NULL, 0, &lsizeD, NULL);
    } else {
	lsizeD = (lpbiC ? lpbiC->biSizeImage : lpbiU->biSizeImage);
    }

    hdc = GetDC(GetDlgItem(hwnd, ID_PREVIEWWIN));
    GetClientRect(GetDlgItem(hwnd, ID_PREVIEWWIN), &rc);

    // Clip regions aren't set up right for windows in a dialog, so make sure
    // we'll only paint into the window and not spill around it.
    IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

    // Now go ahead and draw a miniature frame that preserves the aspect ratio
    // centred in our preview window
    x = MulDiv((int)lpbi->biWidth, 3, 4);
    if (x <= (int)lpbi->biHeight) {
	rc.left = (rc.right - MulDiv(rc.right, x, (int)lpbi->biHeight)) / 2;
	rc.right -= rc.left;
    } else {
	x = MulDiv((int)lpbi->biHeight, 4, 3);
	rc.top = (rc.bottom - MulDiv(rc.bottom, x, (int)lpbi->biWidth)) / 2;
	rc.bottom -= rc.top;
    }
    DrawDibDraw(p->hdd, hdc, rc.left, rc.top, rc.right - rc.left,
	rc.bottom - rc.top, lpbi, NULL, 0, 0, -1, -1, 0);

    // Print the sizes and ratio for this frame
    LoadString (ghInst, ID_FRAMESIZE, achT, NUMELMS(achT));
    wsprintf(ach, achT,
	GetScrollPos(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL),
	lsizeD,
	lpbiU->biSizeImage,
	lsizeD * 100 / lpbiU->biSizeImage);
    SetDlgItemText(hwnd, ID_PREVIEWTEXT, ach);
    if (lpbiC)
        GlobalFreePtr(lpbiC);
    ReleaseDC(GetDlgItem(hwnd, ID_PREVIEWWIN), hdc);
}


///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorChooseDlgProc
//
//  dialog box procedure for ICCompressorChoose, a pointer to a
//  ICCompressorChooseStuff pointer must be passed to initialize this
//  dialog.
//
//  NOTE: this dialog box procedure does not use any globals
//  so I did not bother to _export it or use MakeProcAddress() if
//  you change this code to use globals, etc, be aware of this fact.
//
///////////////////////////////////////////////////////////////////////////////

#ifdef _WIN32
// THIS IS A HACK.  We need to store the HIC for each item in a combo
// box.  We also need to store it's index.  On NT these two items cannot
// be stored in a DWORD.  Hence use a static array to contain the HIC
// elements which can then be referenced by the stored index.
// Look at the GetItemData and SetItemData routines.

#define MAX_COMPRESSORS 100
HIC aHic[MAX_COMPRESSORS];  // Hopefully, noone will have more than this

HIC GetHIC(HWND hwndCB, int index)
{
    index = (int) ComboBox_GetItemData(hwndCB,index);
    if (index>0 && index < MAX_COMPRESSORS) {
        return(aHic[index]);
    } else {
        return((HIC)-1);
    }
}

#else

#define GetHIC(hwnd,index) ((HIC)LOWORD(ComboBox_GetItemData((hwnd),(index))))

#endif

INT_PTR VFWAPI ICCompressorChooseDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int i,n;
    int pos;
    HWND hwndC;
    PICCompressorChooseStuff p;
    HIC hic;
    BOOL fConfig, fAbout, fQuality, fKey, fDataRate;
    BOOL fShowKeyFrame, fShowDataRate, fShowPreview;
    int nSelectMe = -1;
    TCHAR ach[128], achT[80];
    RECT	rc;
    UINT	id;
    HDC		hdc;
    BOOL	f = FALSE, fCanDecompress = FALSE;
    LONG	lsize;
    LPBITMAPINFOHEADER lpbi = NULL;
    BOOL	fStreamIsCompressed = FALSE;
    HRESULT	hr;

    p = (PICCompressorChooseStuff)GetWindowLongPtr(hwnd,DWLP_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
	    #define but &&
	    #define and &&
	    #define is ==
	    #define isnt !=

            if (lParam == 0)
                return FALSE;

            SetWindowLongPtr(hwnd,DWLP_USER,lParam);
            p = (PICCompressorChooseStuff)lParam;

	    p->hwnd = hwnd;
	
            // Let the user change the title of the dialog
            if (p->lpszTitle != NULL)
                SetWindowTextA(hwnd, p->lpszTitle);

#ifdef _WIN32
	    havifile = GetModuleHandleA("avifil32");
#else
	    havifile = GetModuleHandleA("avifile");
#endif

	    if (havifile) {
	        (FARPROC)AVIStreamGetFrameOpen =
			GetProcAddress((HINSTANCE)havifile,
			(LPCSTR)"AVIStreamGetFrameOpen");
	        (FARPROC)AVIStreamGetFrame =
			GetProcAddress((HINSTANCE)havifile,
			(LPCSTR)"AVIStreamGetFrame");
	        (FARPROC)AVIStreamGetFrameClose =
			GetProcAddress((HINSTANCE)havifile,
			(LPCSTR)"AVIStreamGetFrameClose");
	        if (p->pavi)
	            p->pgf = AVIStreamGetFrameOpen(p->pavi, NULL);
	    }

	    // We weren't passed in an input format but we have a PAVI we
	    // can get a format from
	    if (p->pvIn is NULL but p->pavi isnt NULL and p->pgf isnt NULL) {

		// We need to nuke pvIn later
		f = TRUE;

		// Find out if the AVI Stream is compressed or not
		p->pavi->lpVtbl->ReadFormat(p->pavi, 0, NULL, &lsize);
		if (lsize)
		    lpbi = (LPBITMAPINFOHEADER)GlobalAllocPtr(GMEM_MOVEABLE,
				lsize);
		if (lpbi) {
		    hr = p->pavi->lpVtbl->ReadFormat(p->pavi, 0, lpbi, &lsize);
		    if (hr == AVIERR_OK)
			fStreamIsCompressed = lpbi->biCompression != BI_RGB;
		    GlobalFreePtr(lpbi);
		}

		// Get the decompressed format of the AVI stream
		lpbi = AVIStreamGetFrame(p->pgf, 0);
		if (lpbi) {
		    lsize = lpbi->biSize +
				lpbi->biClrUsed * sizeof(PALETTEENTRY);
		    p->pvIn = (LPBITMAPINFOHEADER)GlobalAllocPtr(GMEM_MOVEABLE,
				lsize);
		    if (p->pvIn)
		        hmemcpy(p->pvIn, lpbi, lsize);
		}
	    }

            //
            // now fill the combo box with all compressors
            //
            hwndC = GetDlgItem(hwnd, ID_COMPRESSOR);

            for (i=0; ICInfo(p->fccType, i, &p->icinfo); i++)
            {
                hic = ICOpen(p->icinfo.fccType, p->icinfo.fccHandler,
			ICMODE_COMPRESS);

                if (hic)
                {
                    //
                    // skip this compressor if it can't handle the
                    // specifed format and we want to skip such compressors
                    //
                    if (!(p->uiFlags & ICMF_CHOOSE_ALLCOMPRESSORS) &&
			p->pvIn != NULL &&
                        ICCompressQuery(hic, p->pvIn, NULL) != ICERR_OK)
                    {
                        ICClose(hic);
                        continue;
                    }

                    //
                    // find out the compressor name.
                    //
                    ICGetInfo(hic, &p->icinfo, sizeof(p->icinfo));

                    //
                    // stuff it into the combo box and remember which one it was
                    //
#if defined _WIN32 && !defined UNICODE
                    //assert (NUMELMS(ach) >= NUMELMS(p->icinfo.szDescription));
                    mmWideToAnsi (ach, p->icinfo.szDescription,
                                  NUMELMS(p->icinfo.szDescription));
                    n = ComboBox_AddString(hwndC, ach);
#else
                    n = ComboBox_AddString(hwndC, p->icinfo.szDescription);
#endif

#ifdef _WIN32
        // Making a LONG out of a hic and an int just won't cut it
        // We have to use some auxiliary storage
	    	    if (i >= MAX_COMPRESSORS) {
#ifdef DEBUG
			UINT n = fDebug;
			fDebug = 1;
			DPF(("Overwriting array...i==%d\n",i));
			DebugBreak();
			fDebug = n;
#endif
		    }
                    aHic[i] = hic;
                    ComboBox_SetItemData(hwndC, n, i);
#else
                    ComboBox_SetItemData(hwndC, n, MAKELONG(hic, i));
#endif

		    // This compressor is the one we want to come up default ?
		    // Set its state
	    	    // !!! Combo Box better not be sorted!
		    // Convert both to upper case for an insensitive compare
		    AnsiUpperBuff((LPSTR)&p->icinfo.fccHandler, sizeof(FOURCC));
		    AnsiUpperBuff((LPSTR)&p->fccHandler, sizeof(FOURCC));
		    if (p->icinfo.fccHandler == p->fccHandler) {
		        nSelectMe = n;
			if (p->lpState)
			    ICSetState(hic, p->lpState, p->cbState);
		    }
                }
            }

	    //
	    // Next add a "No Recompression" item unless they passed in an
	    // uncompressed format
	    //
 	    if (fStreamIsCompressed || (p->pvIn &&
		    ((LPBITMAPINFOHEADER)p->pvIn)->biCompression != BI_RGB)) {
                LoadString (ghInst, ID_NOCOMPSTRING, ach, NUMELMS(ach));
                n = ComboBox_AddString(hwndC, ach);
#ifdef _WIN32
                aHic[MAX_COMPRESSORS - 1] = 0;
	        ComboBox_SetItemData(hwndC, n, MAX_COMPRESSORS - 1);
#else
	        ComboBox_SetItemData(hwndC, n, 0);
#endif
	        // Select "No Recompression" as the default if that was the one
		// last chosen.  This will also be the default choice (0).
		if (p->fccHandler == 0)
		    nSelectMe = n;
	    }
	    //
	    // Now add a "Full Frames (Uncompressed)" item unless we can't
	    // decompress this format and they don't want all choices anyway
	    //
            if (!(p->uiFlags & ICMF_CHOOSE_ALLCOMPRESSORS) && p->pvIn) {
		// If it's RGB, of course, just offer the option.
		if (((LPBITMAPINFOHEADER)p->pvIn)->biCompression != BI_RGB) {
		    if ((hic = ICLocate(ICTYPE_VIDEO, 0, p->pvIn, NULL,
			    ICMODE_DECOMPRESS)) == NULL)
			goto SkipFF;
		    else
			ICClose(hic);
		}
	    }

            LoadString (ghInst, ID_FULLFRAMESSTRING, ach, NUMELMS(ach));
            n = ComboBox_AddString(hwndC, ach);
#ifdef _WIN32
            aHic[MAX_COMPRESSORS - 2] = (HIC)-1;
	    ComboBox_SetItemData(hwndC, n, MAX_COMPRESSORS - 2);
#else
	    ComboBox_SetItemData(hwndC, n, MAKELONG(-1, 0));
#endif

	    // Select "Full Frames" if that was the last one chosen
	    // !!! Combo Box better not be sorted!
	    if (p->fccHandler == comptypeDIB)
		nSelectMe = n;
	    fCanDecompress = TRUE;

SkipFF:
	    // If we haven't selected anything yet, choose something at random.
	    if (nSelectMe == -1)
		nSelectMe = 0;

	    fShowKeyFrame = p->uiFlags & ICMF_CHOOSE_KEYFRAME;
	    fShowDataRate = p->uiFlags & ICMF_CHOOSE_DATARATE;
	    // Don't show a preview if we can't draw it!
	    fShowPreview  = (p->uiFlags & ICMF_CHOOSE_PREVIEW) && p->pavi &&
		fCanDecompress;

	    // Hide our secret small place holders
	    ShowWindow(GetDlgItem(hwnd, ID_CHOOSE_SMALL), SW_HIDE);
	    ShowWindow(GetDlgItem(hwnd, ID_CHOOSE_NORMAL), SW_HIDE);
	    ShowWindow(GetDlgItem(hwnd, ID_CHOOSE_BIG), SW_HIDE);

	    if (!fShowKeyFrame) {
		ShowWindow(GetDlgItem(hwnd, ID_KEYFRAME), SW_HIDE);
		ShowWindow(GetDlgItem(hwnd, ID_KEYFRAMEBOX), SW_HIDE);
		ShowWindow(GetDlgItem(hwnd, ID_KEYFRAMETEXT), SW_HIDE);
	    }

	    if (!fShowDataRate) {
		ShowWindow(GetDlgItem(hwnd, ID_DATARATE), SW_HIDE);
		ShowWindow(GetDlgItem(hwnd, ID_DATARATEBOX), SW_HIDE);
		ShowWindow(GetDlgItem(hwnd, ID_DATARATETEXT), SW_HIDE);
	    }

	    if (!fShowPreview) {
		ShowWindow(GetDlgItem(hwnd, ID_PREVIEW), SW_HIDE);
	    }

	    // We start without these
	    ShowWindow(GetDlgItem(hwnd, ID_PREVIEWWIN), SW_HIDE);
	    ShowWindow(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SW_HIDE);
	    ShowWindow(GetDlgItem(hwnd, ID_PREVIEWTEXT), SW_HIDE);

	    //
	    // What size dialog do we need?
	    //
	    if (!fShowPreview && (!fShowDataRate || !fShowKeyFrame))
		SizeDialog(hwnd, ID_CHOOSE_SMALL);
	    else
		SizeDialog(hwnd, ID_CHOOSE_NORMAL);

	    //
	    // Swap places for KeyFrameEvery and DataRate
	    //
	    if (fShowDataRate && !fShowKeyFrame) {
		GetWindowRect(GetDlgItem(hwnd, ID_KEYFRAME), &rc);
		ScreenToClient(hwnd, (LPPOINT)&rc);
		ScreenToClient(hwnd, (LPPOINT)&rc + 1);
		MoveWindow(GetDlgItem(hwnd, ID_DATARATE), rc.left, rc.top,
			rc.right - rc.left, rc.bottom - rc.top, FALSE);
		GetWindowRect(GetDlgItem(hwnd, ID_KEYFRAMEBOX), &rc);
		ScreenToClient(hwnd, (LPPOINT)&rc);
		ScreenToClient(hwnd, (LPPOINT)&rc + 1);
		MoveWindow(GetDlgItem(hwnd, ID_DATARATEBOX), rc.left, rc.top,
			rc.right - rc.left, rc.bottom - rc.top, FALSE);
		GetWindowRect(GetDlgItem(hwnd, ID_KEYFRAMETEXT), &rc);
		ScreenToClient(hwnd, (LPPOINT)&rc);
		ScreenToClient(hwnd, (LPPOINT)&rc + 1);
		MoveWindow(GetDlgItem(hwnd, ID_DATARATETEXT), rc.left, rc.top,
			rc.right - rc.left, rc.bottom - rc.top, TRUE);
	    }

	    //
	    // Restore the dlg to the settings found in the structure
	    //
	    SetScrollRange(GetDlgItem(hwnd, ID_QUALITY), SB_CTL, 0, 100, FALSE);
	    CheckDlgButton(hwnd, ID_KEYFRAMEBOX, (BOOL)(p->lKey != 0));
	    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAME), (BOOL)(p->lKey != 0));
	    CheckDlgButton(hwnd, ID_DATARATEBOX, (BOOL)(p->lDataRate));
	    EnableWindow(GetDlgItem(hwnd, ID_DATARATE), (BOOL)(p->lDataRate));
	    if (p->lKey == -1)	// we haven't chosen a key frame yet.  Later
				// we'll choose the compressor's default.
	    	SetDlgItemInt(hwnd, ID_KEYFRAME, 0, FALSE);
	    else
	    	SetDlgItemInt(hwnd, ID_KEYFRAME, (int)p->lKey, FALSE);
	    SetDlgItemInt(hwnd, ID_DATARATE, (int)p->lDataRate, FALSE);
	    ComboBox_SetCurSel(GetDlgItem(hwnd, ID_COMPRESSOR), nSelectMe);
            SendMessage(hwnd, WM_COMMAND,
              GET_WM_COMMAND_MPS(ID_COMPRESSOR, hwndC, CBN_SELCHANGE));

	    // We alloced this ourselves and need to free it now
	    if (f && p->pvIn)
		GlobalFreePtr(p->pvIn);

            return TRUE;

        case WM_PALETTECHANGED:

	    // It came from us.  Ignore it
            if ((HWND)wParam == hwnd)
                break;

	case WM_QUERYNEWPALETTE:

	    if (!p->hdd)
		break;

            hdc = GetDC(hwnd);

	    //
	    // Realize the palette of the first video stream
	    // !!! If first stream isn't video, we're DEAD!
	    //
            if (f = DrawDibRealize(p->hdd, hdc, FALSE))
                InvalidateRect(hwnd, NULL, FALSE);

            ReleaseDC(hwnd, hdc);

            return f;

	case WM_PAINT:
	    if (!p->hdd)
		break;
	    // Paint everybody else before the Preview window since that'll
	    // take awhile, and we don't want an ugly window during it.
	    DefWindowProc(hwnd, msg, wParam, lParam);
	    UpdateWindow(hwnd);
	    Preview(hwnd, p, TRUE);
	    return 0;

        case WM_HSCROLL:
#ifdef _WIN32
            id = GetWindowLong(GET_WM_HSCROLL_HWND(wParam, lParam), GWL_ID);
            pos = GetScrollPos(GET_WM_HSCROLL_HWND(wParam, lParam), SB_CTL);
#else
            id = GetWindowWord((HWND)HIWORD(lParam), GWW_ID);
            pos = GetScrollPos((HWND)HIWORD(lParam), SB_CTL);
#endif

            switch (GET_WM_HSCROLL_CODE(wParam, lParam))
            {
                case SB_LINEDOWN:       pos += 1; break;
                case SB_LINEUP:         pos -= 1; break;
                case SB_PAGEDOWN:       pos += (id == ID_QUALITY) ? 10 :
					(int)p->info.dwLength / 10; break;
                case SB_PAGEUP:         pos -= (id == ID_QUALITY) ? 10 :
					(int)p->info.dwLength / 10; break;
                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:  pos = GET_WM_HSCROLL_POS(wParam, lParam); break;
		case SB_ENDSCROLL:
		    Preview(hwnd, p, TRUE);	// Draw this compressed frame
		    return TRUE;	// don't fall through and invalidate
                default:
                    return TRUE;
            }

	    if (id == ID_QUALITY) {
                if (pos < 0)
                    pos = 0;
                if (pos > (ICQUALITY_HIGH/100))
                    pos = (ICQUALITY_HIGH/100);
                SetDlgItemInt(hwnd, ID_QUALITYTEXT, pos, FALSE);
                SetScrollPos(GET_WM_HSCROLL_HWND(wParam, lParam), SB_CTL, pos, TRUE);

            } else if (id == ID_PREVIEWSCROLL) {

		// !!! round off !!!
                if (pos < (int)p->info.dwStart)
                    pos = (int)p->info.dwStart;
                if (pos >= (int)p->info.dwStart + (int)p->info.dwLength)
                    pos = (int)(p->info.dwStart + p->info.dwLength - 1);
                SetScrollPos(GET_WM_HSCROLL_HWND(wParam, lParam), SB_CTL, pos, TRUE);

                LoadString (ghInst, ID_FRAME, achT, NUMELMS(achT));
		wsprintf(ach, achT, pos);
		SetDlgItemText(hwnd, ID_PREVIEWTEXT, ach);

		//Drawing while scrolling flashes palettes because they aren't
		//compressed.
		//Preview(hwnd, p, FALSE);
	    }

            break;

        case WM_COMMAND:
            hwndC = GetDlgItem(hwnd, ID_COMPRESSOR);
            n = ComboBox_GetCurSel(hwndC);
#ifdef _WIN32
            hic = (n == -1) ? NULL
                            : aHic[ComboBox_GetItemData(hwndC,n)];
#else
            hic = (n == -1) ? NULL : (HIC)LOWORD(ComboBox_GetItemData(hwndC,n));
#endif
	    if (!p->fClosing)
		p->hic = hic;

            switch ((int)GET_WM_COMMAND_ID(wParam, lParam))
            {
		// When data rate box loses focus, update our preview
		case ID_DATARATE:
		    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
			Preview(hwnd, p, TRUE);
		    break;

		// Enable the "data rate" edit box iff we've checked it
		case ID_DATARATEBOX:
    		    f = IsDlgButtonChecked(hwnd, ID_DATARATEBOX);
		    EnableWindow(GetDlgItem(hwnd, ID_DATARATE), f);
		    break;

		// Enable the "key frame" edit box iff we've checked it
		case ID_KEYFRAMEBOX:
    		    f = IsDlgButtonChecked(hwnd, ID_KEYFRAMEBOX);
		    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAME), f);
		    break;

                case ID_COMPRESSOR:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                        break;

                    if ((INT_PTR)p->hic > 0) {
                        ICGetInfo(p->hic, &p->icinfo, sizeof(p->icinfo));

                        fConfig  = (BOOL)ICQueryConfigure(p->hic);
                        fAbout   = ICQueryAbout(p->hic);
                        fQuality = (p->icinfo.dwFlags & VIDCF_QUALITY) != 0;
                        fKey     = (p->icinfo.dwFlags & VIDCF_TEMPORAL) != 0;
			// if they do quality we fake crunch
                        fDataRate= (p->icinfo.dwFlags &
					(VIDCF_QUALITY|VIDCF_CRUNCH)) != 0;
			// We haven't chosen a key frame rate yet. Use this
			// compressor's default.
			if (p->lKey == -1)
			    SetDlgItemInt(hwnd, ID_KEYFRAME,
				(int)ICGetDefaultKeyFrameRate(p->hic), FALSE);
		    } else {
			fConfig = fAbout = fQuality = fKey = fDataRate = FALSE;
		    }

                    EnableWindow(GetDlgItem(hwnd, ID_CONFIG), fConfig);
                    EnableWindow(GetDlgItem(hwnd, ID_ABOUT), fAbout);
                    EnableWindow(GetDlgItem(hwnd, ID_QUALITY), fQuality);
                    EnableWindow(GetDlgItem(hwnd, ID_QUALITYLABEL), fQuality);
                    EnableWindow(GetDlgItem(hwnd, ID_QUALITYTEXT), fQuality);
                    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAMEBOX), fKey);
                    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAME),
    			fKey && IsDlgButtonChecked(hwnd, ID_KEYFRAMEBOX));
                    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAMETEXT), fKey);
                    EnableWindow(GetDlgItem(hwnd, ID_DATARATEBOX), fDataRate);
                    EnableWindow(GetDlgItem(hwnd, ID_DATARATE),
    			fDataRate && IsDlgButtonChecked(hwnd, ID_DATARATEBOX));
                    EnableWindow(GetDlgItem(hwnd, ID_DATARATETEXT), fDataRate);

                    if (fQuality)
		    {
			if (p->lQ == ICQUALITY_DEFAULT && (INT_PTR)p->hic > 0)
			{
			    SetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL,
				(int)ICGetDefaultQuality(p->hic) / 100, TRUE);
			}
			else
			{
			    SetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL,
				(int)p->lQ / 100, TRUE);
			}

			pos = GetScrollPos(GetDlgItem(hwnd, ID_QUALITY),SB_CTL);
			SetDlgItemInt(hwnd, ID_QUALITYTEXT, pos, FALSE);
		    }

		    // redraw with new compressor
		    Preview(hwnd, p, TRUE);

                    break;

                case ID_CONFIG:
                    if ((INT_PTR)p->hic > 0) {
                        ICConfigure(p->hic, hwnd);
			Preview(hwnd, p, TRUE);
		    }
                    break;

                case ID_ABOUT:
                    if ((INT_PTR)p->hic > 0)
                        ICAbout(p->hic, hwnd);
                    break;

		case ID_PREVIEW:
		    ShowWindow(GetDlgItem(hwnd, ID_PREVIEW), SW_HIDE);
		    ShowWindow(GetDlgItem(hwnd, ID_PREVIEWWIN), SW_SHOW);
		    ShowWindow(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SW_SHOW);
		    ShowWindow(GetDlgItem(hwnd, ID_PREVIEWTEXT), SW_SHOW);
		    SizeDialog(hwnd, ID_CHOOSE_BIG);
		    // !!! truncation
	    	    SetScrollRange(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL,
			(int)p->info.dwStart,
			(int)(p->info.dwStart + p->info.dwLength - 1),
			FALSE);
                    SetScrollPos(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL,
			(int)p->info.dwStart, TRUE);
                    LoadString (ghInst, ID_FRAME, achT, NUMELMS(achT));
		    wsprintf(ach, achT, p->info.dwStart);
		    SetDlgItemText(hwnd, ID_PREVIEWTEXT, ach);
		    InitPreview(hwnd, p);
		    break;

                case IDOK:

		    // !!! We need to call ICInfo to get the FOURCC used
		    // in system.ini.  Calling ICGetInfo will return the
		    // FOURCC the compressor thinks it is, which won't
		    // work.
		    // Get the HIWORD before we nuke it.
#ifndef _WIN32
            	    i = HIWORD(ComboBox_GetItemData(hwndC, n));

		    //
		    // Don't close the current compressor in our CANCEL loop
		    //
                    ComboBox_SetItemData(hwndC, n, 0);
#else
            	    i = (int) ComboBox_GetItemData(hwndC, n);
		    aHic[i] = 0;
#endif

		    //
		    // Return the values of the dlg to the caller
		    //
                    p->hic = hic;

                    p->lQ = 100 *
			GetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL);

		    if (IsDlgButtonChecked(hwnd, ID_KEYFRAMEBOX))
		        p->lKey = GetDlgItemInt(hwnd, ID_KEYFRAME, NULL, FALSE);
		    else
			p->lKey = 0;

		    if (IsDlgButtonChecked(hwnd, ID_DATARATEBOX))
		        p->lDataRate = GetDlgItemInt(hwnd, ID_DATARATE, NULL,
				FALSE);
		    else
			p->lDataRate = 0;

		    // We've chosen a valid compressor.  Do stuff.
		    if ((INT_PTR)p->hic > 0) {

		        // !!! We need to call ICInfo to get the FOURCC used
		        // in system.ini.  Calling ICGetInfo will return the
		        // FOURCC the compressor thinks it is, which won't
		        // work.
                        ICInfo(p->fccType, i, &p->icinfo);
		        p->fccHandler = p->icinfo.fccHandler;	// identify it

			// Free the old state
			if (p->lpState)	{
			    GlobalFreePtr(p->lpState);
			p->lpState = NULL;
			}
			// Get the new state
			p->cbState = ICGetStateSize(p->hic);
			if (p->cbState) {	// Remember it's config state
			    p->lpState = GlobalAllocPtr(GMEM_MOVEABLE,
				p->cbState);
			    if (p->lpState) {
				ICGetState(p->hic, p->lpState, p->cbState);
			    }
			}
		    } else if ((INT_PTR)p->hic == -1) {	// "Full Frames"
			p->fccHandler = comptypeDIB;
			p->hic = 0;
		    } else {				// "No Compression"
			p->fccHandler = 0L;
			p->hic = 0;
		    }

                    // fall through

                case IDCANCEL:
		    p->fClosing = TRUE;
		
		    if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
		        p->hic = NULL;

                    n = ComboBox_GetCount(hwndC);
                    for (i=0; i<n; i++)
                    {
#ifdef _WIN32
			hic = (HIC) aHic[ComboBox_GetItemData(hwndC, i)];
#else
		    	hic = (HIC) LOWORD(ComboBox_GetItemData(hwndC,i));
#endif
			if ((INT_PTR)hic > 0) {
			    ICClose(hic);
			}
                    }

		    TermPreview(p);
		    if (p->pgf)
			AVIStreamGetFrameClose(p->pgf);
		    p->pgf = NULL;
                    EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
                    break;
            }
            break;
    }

    return FALSE;
}




/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * ICM=1
 *
 ****************************************************************************/

#ifdef DEBUG


#define MODNAME "ICM"
extern char szDebug[];   // in MSVIDEO

static void cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

#ifdef _WIN32
    va_list va;
    if (fDebug == -1)
        fDebug = mmGetProfileIntA(szDebug,MODNAME, FALSE);

    if (!fDebug)
        return;

    va_start(va, szFormat);
    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        wsprintfA(ach, MODNAME ": (tid %x) ", GetCurrentThreadId());

    wvsprintfA(ach+lstrlenA(ach),szFormat,va);
    va_end(va);
//  lstrcat(ach, "\r\r\n");
#else
    if (fDebug == -1)
        fDebug = GetProfileInt("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpy(ach, MODNAME ": ");

    wvsprintf(ach+lstrlen(ach),szFormat,(LPSTR)(&szFormat+1));
//  lstrcat(ach, "\r\r\n");
#endif

    OutputDebugStringA(ach);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman.16\compman.h ===
/*
*  Header file for comunication with AVI installable compressors/decompressors
*
*  Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.
*
* Win16:
*
* Installable compressors should be listed in SYSTEM.INI as
* follows:
*
* [Drivers]
*      VIDC.MSSQ = mssqcomp.drv
*      VIDC.XXXX = foodrv.drv
*
* Win32: (NT)
*
* Installable compressors should be listed in the registration database
* under the key
*   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32
*      VIDC.MSSQ = mssqcomp.dll
*      VIDC.XXXX = foodrv.dll
*
*
* That is, an identifying FOURCC should be the key, and the value
* should be the driver filename
*
*/

#ifndef _INC_COMPMAN
#define _INC_COMPMAN

#ifndef VFWAPI
#ifdef WIN32
    #define VFWAPI  __stdcall
    #define VFWAPIV __cdecl
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/************************************************************************

    messages and structures.

************************************************************************/

#ifndef HTASK
  #define HTASK HANDLE
#endif

#include <compddk.h>            // include this file for the messages.

/************************************************************************

    ICM function declarations
	
************************************************************************/

BOOL    VFWAPI ICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo);
BOOL    VFWAPI ICInstall(DWORD fccType, DWORD fccHandler, LPARAM lParam, LPSTR szDesc, UINT wFlags);
BOOL    VFWAPI ICRemove(DWORD fccType, DWORD fccHandler, UINT wFlags);
LRESULT VFWAPI ICGetInfo(HIC hic, ICINFO FAR *picinfo, DWORD cb);

HIC     VFWAPI ICOpen(DWORD fccType, DWORD fccHandler, UINT wMode);
HIC     VFWAPI ICOpenFunction(DWORD fccType, DWORD fccHandler, UINT wMode, FARPROC lpfnHandler);
LRESULT VFWAPI ICClose(HANDLE hic);

LRESULT VFWAPI  ICSendMessage(HIC hic, UINT msg, DWORD dw1, DWORD dw2);
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...);

#if 0  // Defined in COMPMAN.C
#ifdef WIN32
//
// note NT 1.0 MSVFW32.DLL does not have this function, so fake it
// with this bad function that will not work except on i386..
//
static LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...)
{
    return ICSendMessage(hic, msg, (DWORD)(LPVOID)(&cb+1), cb);
}
#endif
#endif

/* Values for wFlags of ICInstall() */
#define ICINSTALL_FUNCTION      0x0001  // lParam is a DriverProc (function ptr)
#define ICINSTALL_DRIVER        0x0002  // lParam is a driver name (string)
#define ICINSTALL_HDRV          0x0004  // lParam is a HDRVR (driver handle)

/************************************************************************

    query macros

************************************************************************/
#define ICMF_CONFIGURE_QUERY     0x00000001
#define ICMF_ABOUT_QUERY         0x00000001

#define ICQueryAbout(hic) \
    (ICSendMessage(hic, ICM_ABOUT, (DWORD) -1, ICMF_ABOUT_QUERY) == ICERR_OK)

#define ICAbout(hic, hwnd) \
    ICSendMessage(hic, ICM_ABOUT, (DWORD)(UINT)(hwnd), 0)

#define ICQueryConfigure(hic) \
    (ICSendMessage(hic, ICM_CONFIGURE, (DWORD) -1, ICMF_CONFIGURE_QUERY) == ICERR_OK)

#define ICConfigure(hic, hwnd) \
    ICSendMessage(hic, ICM_CONFIGURE, (DWORD)(UINT)(hwnd), 0)

/************************************************************************

    get/set state macros
	
************************************************************************/

#define ICGetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_GETSTATE, (DWORD)(LPVOID)(pv), (DWORD)(cb))

#define ICSetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_SETSTATE, (DWORD)(LPVOID)(pv), (DWORD)(cb))

#define ICGetStateSize(hic) \
    ICGetState(hic, NULL, 0)

/************************************************************************

    get value macros

************************************************************************/
static DWORD dwICValue;

#define ICGetDefaultQuality(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTQUALITY, (DWORD)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

#define ICGetDefaultKeyFrameRate(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTKEYFRAMERATE, (DWORD)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

/************************************************************************

    draw window macro
	
************************************************************************/
#define ICDrawWindow(hic, prc) \
    ICSendMessage(hic, ICM_DRAW_WINDOW, (DWORD)(LPVOID)(prc), sizeof(RECT))

/************************************************************************

    compression functions

************************************************************************/
/*
 *  ICCompress()
 *
 *  compress a single frame
 *
 */
DWORD VFWAPIV ICCompress(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    LPBITMAPINFOHEADER  lpbiOutput,     // output format
    LPVOID              lpData,         // output data
    LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    LPVOID              lpBits,         // frame data to compress
    LPDWORD             lpckid,         // ckid for data in AVI file
    LPDWORD             lpdwFlags,      // flags in the AVI index.
    LONG                lFrameNum,      // frame number of seq.
    DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    DWORD               dwQuality,      // quality within one frame
    LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    LPVOID              lpPrev);        // previous frame

/*
 *  ICCompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_BEGIN, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICCompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_QUERY, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICCompressGetFormat()
 *
 *  get the ouput format, (format of compressed data)
 *  if lpbiOuput is NULL return the size in bytes needed for format.
 *
 */
#define ICCompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_FORMAT, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

#define ICCompressGetFormatSize(hic, lpbi) \
    ICCompressGetFormat(hic, lpbi, NULL)

/*
 *  ICCompressSize()
 *
 *  return the maximal size of a compressed frame
 *
 */
#define ICCompressGetSize(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_SIZE, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

#define ICCompressEnd(hic) \
    ICSendMessage(hic, ICM_COMPRESS_END, 0, 0)

/************************************************************************

    decompression functions

************************************************************************/

/*
 *  ICDecompress()
 *
 *  decompress a single frame
 *
 */
#define ICDECOMPRESS_HURRYUP    0x80000000L     // don't draw just buffer (hurry up!)

DWORD VFWAPIV ICDecompress(
    HIC                 hic,
    DWORD               dwFlags,    // flags (from AVI index...)
    LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpData,     // data
    LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    LPVOID              lpBits);

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICDecompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_BEGIN, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICDecompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_QUERY, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressGetFormat()
 *
 *  get the ouput format, (format of un-compressed data)
 *  if lpbiOuput is NULL return the size in bytes needed for format.
 *
 */
#define ICDecompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ((LONG) ICSendMessage(hic, ICM_DECOMPRESS_GET_FORMAT, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput)))

#define ICDecompressGetFormatSize(hic, lpbi) \
    ICDecompressGetFormat(hic, lpbi, NULL)

/*
 *  ICDecompressGetPalette()
 *
 *  get the ouput palette
 *
 */
#define ICDecompressGetPalette(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_GET_PALETTE, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

#define ICDecompressSetPalette(hic, lpbiPalette) \
    ICSendMessage(hic, ICM_DECOMPRESS_SET_PALETTE, (DWORD)(LPVOID)(lpbiPalette), 0)

#define ICDecompressEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESS_END, 0, 0)

/************************************************************************

    decompression (ex) functions

************************************************************************/

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
#define ICDecompressEx(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX, sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICDecompressExBegin(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX_BEGIN, sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

/*
 *  ICDecompressExQuery()
 *
 */
#define ICDecompressExQuery(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX_QUERY,  sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

#define ICDecompressExEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESSEX_END, 0, 0)

/************************************************************************

    drawing functions

************************************************************************/

/*
 *  ICDrawBegin()
 *
 *  start decompressing data with format (lpbiInput) directly to the screen
 *
 *  return zero if the decompressor supports drawing.
 *
 */

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND

DWORD VFWAPIV ICDrawBegin(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        HPALETTE            hpal,           // palette to draw with
        HWND                hwnd,           // window to draw to
        HDC                 hdc,            // HDC to draw to
        int                 xDst,           // destination rectangle
        int                 yDst,
        int                 dxDst,
        int                 dyDst,
        LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
        int                 xSrc,           // source rectangle
        int                 ySrc,
        int                 dxSrc,
        int                 dySrc,
        DWORD               dwRate,         // frames/second = (dwRate/dwScale)
        DWORD               dwScale);

/*
 *  ICDraw()
 *
 *  decompress data directly to the screen
 *
 */

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen

DWORD VFWAPIV ICDraw(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        LPVOID		    lpFormat,       // format of frame to decompress
        LPVOID              lpData,         // frame data to decompress
        DWORD               cbData,         // size of data
        LONG                lTime);         // time to draw this frame

#define ICDrawSuggestFormat(hic,lpbiIn,lpbiOut,dxSrc,dySrc,dxDst,dyDst,hicDecomp) \
        ICMessage(hic, ICM_DRAW_SUGGESTFORMAT, sizeof(ICDRAWSUGGEST),   \
            (LPBITMAPINFOHEADER)(lpbiIn),(LPBITMAPINFOHEADER)(lpbiOut), \
            (int)(dxSrc),(int)(dySrc),(int)(dxDst),(int)(dyDst), (HIC)(hicDecomp))

/*
 *  ICDrawQuery()
 *
 *  determines if the compressor is willing to render the specified format.
 *
 */
#define ICDrawQuery(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_QUERY, (DWORD)(LPVOID)(lpbiInput), 0L)

#define ICDrawChangePalette(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_CHANGEPALETTE, (DWORD)(LPVOID)(lpbiInput), 0L)

#define ICGetBuffersWanted(hic, lpdwBuffers) \
    ICSendMessage(hic, ICM_GETBUFFERSWANTED, (DWORD)(LPVOID)(lpdwBuffers), 0)

#define ICDrawEnd(hic) \
    ICSendMessage(hic, ICM_DRAW_END, 0, 0)

#define ICDrawStart(hic) \
    ICSendMessage(hic, ICM_DRAW_START, 0, 0)

#define ICDrawStartPlay(hic, lFrom, lTo) \
    ICSendMessage(hic, ICM_DRAW_START_PLAY, (DWORD)(lFrom), (DWORD)(lTo))

#define ICDrawStop(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP, 0, 0)

#define ICDrawStopPlay(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP_PLAY, 0, 0)

#define ICDrawGetTime(hic, lplTime) \
    ICSendMessage(hic, ICM_DRAW_GETTIME, (DWORD)(LPVOID)(lplTime), 0)

#define ICDrawSetTime(hic, lTime) \
    ICSendMessage(hic, ICM_DRAW_SETTIME, (DWORD)lTime, 0)

#define ICDrawRealize(hic, hdc, fBackground) \
    ICSendMessage(hic, ICM_DRAW_REALIZE, (DWORD)(UINT)(HDC)(hdc), (DWORD)(BOOL)(fBackground))

#define ICDrawFlush(hic) \
    ICSendMessage(hic, ICM_DRAW_FLUSH, 0, 0)

#define ICDrawRenderBuffer(hic) \
    ICSendMessage(hic, ICM_DRAW_RENDERBUFFER, 0, 0)

/************************************************************************

    Status callback functions

************************************************************************/

/*
 *  ICSetStatusProc()
 *
 *  Set the status callback function
 *
 */
#define ICSetStatusProc(hic, dwFlags, lParam, fpfnStatus) \
    ICMessage(hic, ICM_SET_STATUS_PROC, sizeof(ICSETSTATUSPROC), \
        (DWORD)(dwFlags), \
	(LRESULT)(lParam), \
	(LONG ((CALLBACK *) ()))(fpfnStatus))

/************************************************************************

helper routines for DrawDib and MCIAVI...

************************************************************************/

#define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \
    ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS)

#define ICDrawOpen(fccType, fccHandler, lpbiIn) \
    ICLocate(fccType, fccHandler, lpbiIn, NULL, ICMODE_DRAW)

HIC  VFWAPI ICLocate(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags);
HIC  VFWAPI ICGetDisplayFormat(HIC hic, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, int BitDepth, int dx, int dy);

/************************************************************************
Higher level functions
************************************************************************/

HANDLE VFWAPI ICImageCompress(
        HIC                 hic,        // compressor to use
        UINT                uiFlags,    // flags (none yet)
        LPBITMAPINFO	    lpbiIn,     // format to compress from
        LPVOID              lpBits,     // data to compress
        LPBITMAPINFO        lpbiOut,    // compress to this (NULL ==> default)
        LONG                lQuality,   // quality to use
        LONG FAR *          plSize);     // compress to this size (0=whatever)

HANDLE VFWAPI ICImageDecompress(
        HIC                 hic,        // compressor to use
        UINT                uiFlags,    // flags (none yet)
        LPBITMAPINFO        lpbiIn,     // format to decompress from
        LPVOID              lpBits,     // data to decompress
        LPBITMAPINFO        lpbiOut);   // decompress to this (NULL ==> default)

//
// Structure used by ICSeqCompressFrame and ICCompressorChoose routines
// Make sure this matches the autodoc in icm.c!
//
typedef struct {
    LONG		cbSize;		// set to sizeof(COMPVARS) before
					// calling ICCompressorChoose
    DWORD		dwFlags;	// see below...
    HIC			hic;		// HIC of chosen compressor
    DWORD               fccType;	// basically ICTYPE_VIDEO
    DWORD               fccHandler;	// handler of chosen compressor or
					// "" or "DIB "
    LPBITMAPINFO	lpbiIn;		// input format
    LPBITMAPINFO	lpbiOut;	// output format - will compress to this
    LPVOID		lpBitsOut;
    LPVOID		lpBitsPrev;
    LONG		lFrame;
    LONG		lKey;		// key frames how often?
    LONG		lDataRate;	// desired data rate KB/Sec
    LONG		lQ;		// desired quality
    LONG		lKeyCount;
    LPVOID		lpState;	// state of compressor
    LONG		cbState;	// size of the state
} COMPVARS, FAR *PCOMPVARS;

// FLAGS for dwFlags element of COMPVARS structure:
// set this flag if you initialize COMPVARS before calling ICCompressorChoose
#define ICMF_COMPVARS_VALID	0x00000001	// COMPVARS contains valid data

//
//  allows user to choose compressor, quality etc...
//
BOOL VFWAPI ICCompressorChoose(
        HWND        hwnd,               // parent window for dialog
        UINT        uiFlags,            // flags
        LPVOID      pvIn,               // input format (optional)
        LPVOID      lpData,             // input data (optional)
        PCOMPVARS   pc,                 // data about the compressor/dlg
        LPSTR       lpszTitle);         // dialog title (optional)

// defines for uiFlags
#define ICMF_CHOOSE_KEYFRAME	0x0001	// show KeyFrame Every box
#define ICMF_CHOOSE_DATARATE	0x0002	// show DataRate box
#define ICMF_CHOOSE_PREVIEW	0x0004	// allow expanded preview dialog
#define ICMF_CHOOSE_ALLCOMPRESSORS	0x0008	// don't only show those that
						// can handle the input format
						// or input data

BOOL VFWAPI ICSeqCompressFrameStart(PCOMPVARS pc, LPBITMAPINFO lpbiIn);
void VFWAPI ICSeqCompressFrameEnd(PCOMPVARS pc);

LPVOID VFWAPI ICSeqCompressFrame(
    PCOMPVARS               pc,         // set by ICCompressorChoose
    UINT                    uiFlags,    // flags
    LPVOID                  lpBits,     // input DIB bits
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize);	// size to compress to/of returned image

void VFWAPI ICCompressorFree(PCOMPVARS pc);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* _INC_COMPMAN */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\thunks.h ===
/****************************************************************************
    thunks.h

    Contains definitions for thunking msvideo.dll (16bit) to the 32bit
    msvfw32.dll running on NT.

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    msvfw32.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)


//
// Functions to link and unlink to 32-bit side

BOOL _loadds FAR InitThunks(void);

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

//
// The prototypes for setting up thunks for the video api set (in AVICAP32)
//

LRESULT FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
LRESULT FAR PASCAL videoGetNumDevs32(void);
LRESULT FAR PASCAL videoClose32(HVIDEO hVideo);
LRESULT FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);

#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

//
// The prototypes for setting up thunks for the ICM_ api set (in MSVFW32)
//

LRESULT FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo);
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICClose32(DWORD hic);

#endif // _INC_COMPMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman.16\compddk.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
 *                                                                   
 *  Compddk.h - include file for implementing installable compressors
 *                                                                   
 *  Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved. 
 *  
 **********************************************************************
 * 
 * To register FOURCC's for codec types please obtain a
 * copy of the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 *
*/

#ifndef _INC_COMPDDK
#define _INC_COMPDDK	50	/* version number */

#ifndef RC_INVOKED
#ifndef WIN32
#pragma pack(1)         /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
    
#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD

#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS/* not used */ (ICM_USER+20)   // decompress a frame to screen
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT	    (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames
#define ICM_SET_STATUS_PROC	    (ICM_USER+72)   // set status callback

#define ICM_ENUM_FORMATS            (ICM_USER+80)   // enum all formats
#define ICM_GET_FORMAT_NAME         (ICM_USER+81)   // compress a bunch of frames

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
#ifdef WIN32
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
#else
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
#endif
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L
    
typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR) 
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress
    
    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;

#ifndef RC_INVOKED
#ifndef WIN32
#pragma pack()          /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_COMPDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman\thunk.h ===
/****************************************************************************
    thunk.h

    Contains definitions for msvideo thunks (16/32 bit)

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)

//
//
//
#ifdef _WIN32

#ifdef CHICAGO
//
//  Following pasted from wownt32.h
//

//
// 16 <--> 32 Handle mapping functions.
//
// NOTE:  While some of these functions perform trivial
// conversions, these functions must be used to maintain
// compatibility with future versions of Windows NT which
// may require different handle mapping.
//

typedef enum _WOW_HANDLE_TYPE { /* WOW */
    WOW_TYPE_HWND,
    WOW_TYPE_HMENU,
    WOW_TYPE_HDWP,
    WOW_TYPE_HDROP,
    WOW_TYPE_HDC,
    WOW_TYPE_HFONT,
    WOW_TYPE_HMETAFILE,
    WOW_TYPE_HRGN,
    WOW_TYPE_HBITMAP,
    WOW_TYPE_HBRUSH,
    WOW_TYPE_HPALETTE,
    WOW_TYPE_HPEN,
    WOW_TYPE_HACCEL,
    WOW_TYPE_HTASK,
    WOW_TYPE_FULLHWND
} WOW_HANDLE_TYPE;

#define ThunkHWND(h16) ((HWND)h16)
#define ThunkHDC(h16)  ((HDC)h16)
#define ThunkHPAL(h16) ((HPALETTE)h16)

#else

#include <wownt32.h>

#define ThunkHWND(h16) ((HWND)lpWOWHandle32((WORD)h16, WOW_TYPE_HWND))
#define ThunkHDC(h16)  ((HDC) lpWOWHandle32((WORD)h16, WOW_TYPE_HDC))
#define ThunkHPAL(h16) ((HPALETTE)lpWOWHandle32((WORD)h16, WOW_TYPE_HPALETTE))

#endif	// !CHICAGO

//
//  Thunking support
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_CALLBACK16                  "WOWCallback16"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
typedef HANDLE (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD   (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);
typedef DWORD  (APIENTRY *LPWOWCALLBACK16)(DWORD vpfn16, DWORD dwParam);



#define StartThunk(Function)                           \
          LRESULT  ReturnCode = 0;                        \
	  DPFS(dbgThunks, 2, "Entering function %s", #Function);

#define EndThunk()                                     \
          DPFS(dbgThunks, 2, "Returned %4X :%4X",      \
                   HIWORD(ReturnCode),                 \
                   LOWORD(ReturnCode));                \
          return ReturnCode;

#endif // _WIN32

/*
 *  Useful structures and mapping
 */

typedef struct {
    short left, top, right, bottom;
} RECT_SHORT;


#define SHORT_RECT_TO_RECT(OutRect, InRect)  \
    OutRect.left = (LONG)InRect.left;        \
    OutRect.top = (LONG)InRect.top;          \
    OutRect.right = (LONG)InRect.right;      \
    OutRect.bottom = (LONG)InRect.bottom;

#define RECT_TO_SHORT_RECT(OutRect, InRect)  \
    OutRect.left = (short)InRect.left;       \
    OutRect.top = (short)InRect.top;         \
    OutRect.right = (short)InRect.right;     \
    OutRect.bottom = (short)InRect.bottom;


//
//  Function ids across the thunking layer (used by 32 and 16 bit)
//
enum {
   vidThunkvideoMessage32=1,
   vidThunkvideoGetNumDevs32,
   vidThunkvideoOpen32,
   vidThunkvideoClose32,

   compThunkICInfoInternal32,
   compThunkICSendMessage32,
   compThunkICOpen32,
   compThunkICClose32,
   compThunkICOpenFunction32,
   compThunkICSetStatusProc32
};

#ifndef _WIN32
typedef struct _VIDTHUNK
{
//
//  Thunking stuff
//
    DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
                                                  DWORD, DWORD,
                                                  LPVOID, DWORD, DWORD);
    LPVOID          lpvThunkEntry;
    DWORD           dwVideo32Handle;


} VIDTHUNK, *PVIDTHUNK, FAR *LPVIDTHUNK;
#endif // !_WIN32

//
//  Some typedefs to assist with the ICM_SET_STATUS_PROC
//  thunk and callback thunk.
//
//  Convention:
//	"S" suffix indicates a 16:16 ptr (Segmented)
//	"L" suffix indicates a  0:32 ptr (Linear)
//	 no suffix indicates a native bitness pointer
//
typedef LONG (CALLBACK *ICSTATUSPROC)(LPARAM lParam, UINT uMsg, LONG l);
typedef struct tICSTATUSTHUNKDESC FAR * LPICSTATUSTHUNKDESC;


#ifdef _WIN32
typedef DWORD			LPVOIDS;
typedef LPICSTATUSTHUNKDESC	LPICSTATUSTHUNKDESCL;
typedef DWORD			LPICSTATUSTHUNKDESCS;
typedef ICSTATUSPROC		ICSTATUSPROCL;
typedef DWORD			ICSTATUSPROCS;

#else
typedef LPVOID			LPVOIDS;
typedef DWORD			LPICSTATUSTHUNKDESCL;
typedef LPICSTATUSTHUNKDESC	LPICSTATUSTHUNKDESCS;
typedef DWORD			ICSTATUSPROCL;
typedef ICSTATUSPROC		ICSTATUSPROCS;
#endif

typedef struct tICSTATUSTHUNKDESC {
    //
    //	segmented ptr to this struct
    //
    LPICSTATUSTHUNKDESCS    lpstdS;

    //
    //	segmented ptr to 16 bit callback stub
    //
    LPVOIDS		    pfnthkStatusProc16S;

    //
    //	from client's ICSETSTATUSPROC
    //
    DWORD		    dwFlags;
    LPARAM		    lParam;
    ICSTATUSPROCS	    fnStatusProcS;

    //
    //	to be sent to client's callback
    //
    DWORD		    uMsg;
    LONG		    l;
} ICSTATUSTHUNKDESC;


//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);

#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

#ifdef _WIN32
LRESULT FAR PASCAL ICInfoInternal32(DWORD fccType, DWORD fccHandler, ICINFO16 FAR * lpicinfo, ICINFOI FAR * lpicinfoi);
#else
BOOL    FAR PASCAL ICInfoInternal32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo, ICINFOI FAR * lpicinfoi);
#endif
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
LRESULT FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICOpenFunction32(DWORD fccType, DWORD fccHandler, UINT wMode, FARPROC lpfnHandler);
LRESULT FAR PASCAL ICClose32(DWORD hic);
LRESULT FAR PASCAL ICSendSetStatusProc32(HIC hic, ICSETSTATUSPROC FAR* lpissp, DWORD cbStruct);

#endif // _INC_COMPMAN

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman.16\compman.c ===
/*
 * This code contains thunk enabling.  If we fail to open on the 16 bit side,
 * we will try and open a 32 bit codec.  (The reason for not trying the 32
 * bit codec first is an attempt to keep most things on the 16 bit side.
 * The performance under NT appears reasonable, and for frame specific
 * operations it reduces the number of 16/32 transitions.
 */


#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <win32.h>
#ifdef WIN32
#include <mmddk.h>  // needed for definition of DRIVERS_SECTION
#endif

//
// define these before compman.h, so our functions get declared right.
//
#ifndef WIN32
#define VFWAPI  FAR PASCAL _loadds
#define VFWAPIV FAR CDECL  _loadds
#endif

#include "compman.h"
#include "icm.rc"

#ifdef WIN32
#include <wchar.h>
#endif

#ifndef NOTHUNKS
#include "thunks.h"    // Building
#endif //NOTHUNKS

#ifndef streamtypeVIDEO
    #define streamtypeVIDEO mmioFOURCC('v', 'i', 'd', 's')
#endif

#define ICTYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')
#define ICTYPE_ACM  mmioFOURCC('a', 'u', 'd', 'c')
#define SMAG        mmioFOURCC('S', 'm', 'a', 'g')
#define GONE        mmioFOURCC('G', 'o', 'n', 'e')

#define IC_INI      TEXT("Installable Compressors")

static TCHAR   szIniSect[]       = IC_INI;
static TCHAR   szDrivers[]       = DRIVERS_SECTION;
static TCHAR   szSystemIni[]     = TEXT("SYSTEM.INI");
static TCHAR   szNull[]          = TEXT("");
static TCHAR   sz44s[]           = TEXT("%4.4hs");
static TCHAR   szICKey[]         = TEXT("%4.4hs.%4.4hs");
static TCHAR   szMSVideo[]       = TEXT("MSVideo");
static TCHAR   szMSACM[]         = TEXT("MSACM");
static TCHAR   szVIDC[]          = TEXT("VIDC");
static SZCODEA szDriverProc[]    = "DriverProc";

#ifdef DEBUG
    #define DPF( x ) dprintfc x
    #define DEBUG_RETAIL
#else
    #define DPF(x)
#endif

#ifdef DEBUG_RETAIL
    static void CDECL dprintfc(LPSTR, ...);
    #define RPF( x ) dprintfc x
    #define ROUT(sz) {static SZCODE ach[] = sz; dprintfc(ach); }
    void  ICDebugMessage(HIC hic, UINT msg, DWORD dw1, DWORD dw2);
    LRESULT ICDebugReturn(LRESULT err);
    #define DebugErr(sz) {static SZCODE ach[] = "COMPMAN: "sz; DebugOutput(DBF_ERROR | DBF_MMSYSTEM, ach); }
#else
    #define RPF(x)
    #define ROUT(sz)
    #define ICDebugMessage(hic, msg, dw1, dw2)
    #define ICDebugReturn(err)  err
    #define DebugErr(sz)
#endif

#ifdef DEBUG_RETAIL
#else
    #define DebugErr(flags)
#endif

#ifndef WF_WINNT
#define WF_WINNT 0x4000
#endif

#ifdef WIN32
#define IsWow() FALSE
#else
#define IsWow() ((BOOL) (GetWinFlags() & WF_WINNT))
#define GetDriverModuleHandle(h) (IsWow() ? h : GetDriverModuleHandle(h))
#endif

__inline void ictokey(DWORD fccType, DWORD fcc, LPSTR sz)
{
    int i = wsprintf(sz, szICKey, (LPSTR)&(fccType),(LPSTR)&(fcc));

    while (i>0 && sz[i-1] == ' ')
	sz[--i] = 0;
}

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

static void ICDump(void);


//
//  the following array is used for 'installed' converters
//
//  converters are either driver handles or indexes into this array
//
//  'function' converters are installed into this array, 'driver' converters
//  are installed in SYSTEM.INI
//

#define MAX_CONVERTERS 75           // maximum installed converters.

typedef struct  {
    DWORD       dwSmag;             // 'Smag'
    HTASK       hTask;              // owner task.
    DWORD       fccType;            // converter type ie 'vidc'
    DWORD       fccHandler;         // converter id ie 'rle '
    HDRVR       hDriver;            // handle of driver
    DWORD       dwDriver;           // driver id for functions
    DRIVERPROC  DriverProc;         // function to call
#ifndef NOTHUNKS
    DWORD       h32;                // 32-bit driver handle
#endif //!NOTHUNKS
}   IC, *PIC;

IC aicConverters[MAX_CONVERTERS];

/*****************************************************************************
 ****************************************************************************/

LRESULT CALLBACK DriverProcNull(DWORD dwDriverID, HANDLE hDriver, UINT wMessage,DWORD dwParam1, DWORD dwParam2)
{
    DPF(("codec called after it has been removed with ICRemove\r\n"));
    return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 ****************************************************************************/

static HDRVR LoadDriver(LPSTR szDriver, DRIVERPROC FAR *lpDriverProc);
static void FreeDriver(HDRVR hDriver);

/*****************************************************************************

    driver cache - to make enuming/loading faster we keep the last N
    module's open for a while.

 ****************************************************************************/

#define N_MODULES   10      //!!!????

HMODULE ahModule[N_MODULES];
int     iModule = 0;

static void CacheModule(HMODULE hModule)
{
    TCHAR ach[128];

    //
    // what if this module is in the list currently?
    //
#if 0
    // we dont do this so unused compressors will fall off the end....
    int i;

    for (i=0; i<N_MODULES; i++)
    {
	if (ahModule[i] && ahModule[i] == hModule)
	    return;
    }
#endif

    //
    // add this module to the cache
    //
#ifndef WIN32  // On NT GetModuleUsage always returns 1.  So... we cache
    if (hModule)
    {
	extern HMODULE ghInst;          // in MSVIDEO/init.c
	int iUsage;

	GetModuleFileName(hModule, ach, sizeof(ach));
	DPF(("Loading module: %s\r\n", (LPSTR)ach));
	iUsage = GetModuleUsage(ghInst);
	LoadLibrary(ach);

	//
	// dont cache modules that link to MSVIDEO
	// we should realy do a toolhelp thing!
	// or force apps to call VFWInit and VFWExit()
	//
	if (iUsage != GetModuleUsage(ghInst))
	{
	    DPF(("Not caching this module because it links to MSVIDEO\r\n"));
	    FreeLibrary(hModule);
	    return;
	}
    }
#endif

    //
    // free module in our slot.
    //
    if (ahModule[iModule] != NULL)
    {
#ifdef DEBUG
	GetModuleFileName(ahModule[iModule], ach, sizeof(ach));
	DPF(("Freeing module: %s\r\n", (LPSTR)ach));
#endif
	FreeLibrary(ahModule[iModule]);
    }

    ahModule[iModule] = hModule;
    iModule++;

    if (iModule >= N_MODULES)
	iModule = 0;
}


/*****************************************************************************
 ****************************************************************************/

/*****************************************************************************
 * FixFOURCC - clean up a FOURCC
 ****************************************************************************/

static DWORD Fix4CC(DWORD fcc)
{
    int i;

    if (fcc > 256)
    {
	AnsiLowerBuff((LPSTR)&fcc, sizeof(fcc));

	for (i=0; i<4; i++)
	{
	    if (((LPSTR)&fcc)[i] == 0)
		for (; i<4; i++)
		    ((LPSTR)&fcc)[i] = ' ';
	}
    }

    return fcc;
}

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api PIC | FindConverter |
 *      search the converter list for a un-opened converter
 *
 ****************************************************************************/

static PIC FindConverter(DWORD fccType, DWORD fccHandler)
{
    int i;
    PIC pic;

    for (i=0; i<MAX_CONVERTERS; i++)
    {
	pic = &aicConverters[i];

	if (pic->fccType  == fccType &&
	    pic->fccHandler  == fccHandler &&
	    pic->dwDriver == 0L)
	{
	    if (pic->DriverProc != NULL && IsBadCodePtr((FARPROC)pic->DriverProc))
	    {
		pic->DriverProc = NULL;
		ICClose((HIC)pic);
                DPF(("NO driver for fccType=%4.4s, Handler=%4.4s\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
		return NULL;
	    }
            DPF(("Possible driver for fccType=%4.4s, Handler=%4.4s\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
	    return pic;
	}
    }

    return NULL;
}

#ifdef WIN32
/*
 * we need to hold a critical section around the ICOpen code to protect
 * multi-thread simultaneous opens. This critsec is initialized by
 * IC_Load (called from video\init.c at dll attach time) and is deleted
 * by IC_Unload (called from video\init.c at dll detach time).
 */
CRITICAL_SECTION ICOpenCritSec;

void
IC_Load(void)
{
    InitializeCriticalSection(&ICOpenCritSec);
}

void
IC_Unload(void)
{
    DeleteCriticalSection(&ICOpenCritSec);
}

#define ICEnterCrit(p)  (EnterCriticalSection(p))
#define ICLeaveCrit(p)  (LeaveCriticalSection(p))

#else

// non-win32 code has no critsecs
#define ICEnterCrit(p)
#define ICLeaveCrit(p)

#endif

/*****************************************************************************
 ****************************************************************************/

__inline BOOL ICValid(HIC hic)
{
    PIC pic = (PIC)hic;

    if (pic <  &aicConverters[0] ||
	pic >= &aicConverters[MAX_CONVERTERS] ||
	pic->dwSmag != SMAG)
    {
	DebugErr("Invalid HIC\r\n");
	return FALSE;
    }

    return TRUE;
}

/*****************************************************************************
 ****************************************************************************/

#define V_HIC(hic)              \
    if (!ICValid(hic))          \
	return ICERR_BADHANDLE;

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api BOOL | ICCleanup | This function is called when a task exits or
 *      MSVIDEO.DLL is being unloaded.
 *
 * @parm HTASK | hTask | the task being terminated, NULL if DLL being unloaded
 *
 * @rdesc Returns nothing
 *
 * @comm  currently MSVIDEO only calles this function from it's WEP()
 *
 ****************************************************************************/

void FAR PASCAL ICCleanup(HTASK hTask)
{
    int i;
    PIC pic;

    //
    // free all HICs
    //
    for (i=0; i < MAX_CONVERTERS; i++)
    {
	pic = &aicConverters[i];

	if (pic->dwDriver != 0L && (pic->hTask == hTask || hTask == NULL))
	{
	    ROUT("Decompressor left open, closing\r\n");
	    ICClose((HIC)pic);
	}
    }

    //
    // free the module cache.
    //
    for (i=0; i<N_MODULES; i++)
	CacheModule(NULL);
}

/*****************************************************************************
 * @doc EXTERNAL IC  ICAPPS
 *
 * @api BOOL | ICInstall | This function installs a new compressor
 *      or decompressor.
 *
 * @parm DWORD | fccType | Specifies a four-character code indicating the
 *       type of data used by the compressor or decompressor.  Use 'vidc'
 *       for a video compressor or decompressor.
 *
 * @parm DWORD | fccHandler | Specifies a four-character code identifying
 *      a specific compressor or decompressor.
 *
 * @parm LPARAM | lParam | Specifies a pointer to a zero-terminated
 *       string containing the name of the compressor or decompressor,
 *       or it specifies a far pointer to a function used for compression
 *       or decompression. The contents of this parameter are defined
 *       by the flags set for <p wFlags>.
 *
 * @parm LPSTR | szDesc | Specifies a pointer to a zero-terminated string
 *        describing the installed compressor. Not use.
 *
 * @parm UINT | wFlags | Specifies flags defining the contents of <p lParam>.
 * The following flags are defined:
 *
 * @flag ICINSTALL_DRIVER | Indicates <p lParam> is a pointer to a zero-terminated
 *      string containing the name of the compressor to install.
 *
 * @flag ICINSTALL_FUNCTION | Indicates <p lParam> is a far pointer to
 *       a compressor function.  This function should
 *       be structured like the <f DriverProc> entry
 *       point function used by compressors.
 *
 * @rdesc Returns TRUE if successful.
 *
 * @comm  Applications must still open the installed compressor or
 *        decompressor before it can use the compressor or decompressor.
 *
 *        Usually, compressors and decompressors are installed by the user
 *        with the Drivers option of the Control Panel.
 *
 *        If your application installs a function as a compressor or
 *        decompressor, it should remove the compressor or decompressor
 *        with <f ICRemove> before it terminates. This prevents other
 *        applications from trying to access the function when it is not
 *        available.
 *
 *
 * @xref <f ICRemove>
 ****************************************************************************/
BOOL VFWAPI ICInstall(DWORD fccType, DWORD fccHandler, LPARAM lParam, LPSTR szDesc, UINT wFlags)
{
    TCHAR achKey[20];
    TCHAR buf[128];
    PIC  pic;

    ICEnterCrit(&ICOpenCritSec);
    fccType    = Fix4CC(fccType);
    fccHandler = Fix4CC(fccHandler);

    DPF(("ICInstall, fccType=%4.4s, Handler=%4.4s, >>%s<<\n", (LPSTR)&fccType, (LPSTR)&fccHandler, szDesc));
    if ((pic = FindConverter(fccType, fccHandler)) == NULL)
	pic = FindConverter(0L, 0L);

    if (wFlags & ICINSTALL_DRIVER)
    {
	//
	//  dwConverter is the file name of a driver to install.
	//
	ictokey(fccType, fccHandler, achKey);

#ifdef WIN32
	if (szDesc)
	    wsprintf(buf, TEXT("%hs %hs"), (LPSTR) lParam, szDesc);
	else
	    wsprintf(buf, TEXT("%hs"), (LPSTR) lParam);
#else
	lstrcpy(buf, (LPSTR)lParam);

	if (szDesc)
	{
	    lstrcat(buf, TEXT(" "));
	    lstrcat(buf, szDesc);
	}
#endif

	ICLeaveCrit(&ICOpenCritSec);
	if (WritePrivateProfileString(szDrivers,achKey,buf,szSystemIni))
	{
	    WritePrivateProfileString(szIniSect,achKey,NULL,szSystemIni);
	    return TRUE;
	}
	else
	{
	    return(FALSE);
	}
    }
    else if (wFlags & ICINSTALL_FUNCTION)
    {
	if (pic == NULL)
	{
	    ICLeaveCrit(&ICOpenCritSec);
	    return FALSE;
	}

	pic->dwSmag     = SMAG;
	pic->fccType    = fccType;
	pic->fccHandler = fccHandler;
	pic->dwDriver   = 0L;
	pic->hDriver    = NULL;
	pic->DriverProc = (DRIVERPROC)lParam;

	ICLeaveCrit(&ICOpenCritSec);

	return TRUE;
    }
#if 0
    else if (wFlags & ICINSTALL_HDRV)
    {
	if (pic == NULL)
	{
	    ICLeaveCrit(&ICOpenCritSec);
	    return FALSE;
	}

	pic->fccType  = fccType;
	pic->fccHandler  = fccHandler;
	pic->hDriver  = (HDRVR)lParam;
	pic->dwDriver = 0L;
	pic->DrvProc  = NULL;

	ICLeaveCrit(&ICOpenCritSec);

	return TRUE;
    }
#endif
    ICLeaveCrit(&ICOpenCritSec);

    return FALSE;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api BOOL | ICRemove | This function removes an installed compressor.
 *
 * @parm DWORD | fccType | Specifies a four-character code indicating the
 * type of data used by the compressor.  Use 'vidc' for video compressors.
 *
 * @parm DWORD | fccHandler | Specifies a four-character code identifying
 * a specific compressor.
 *
 * @parm UINT | wFlags | Not used.
 *
 * @rdesc Returns TRUE if successful.
 *
 * @xref <f ICInstall>
 ****************************************************************************/
BOOL VFWAPI ICRemove(DWORD fccType, DWORD fccHandler, UINT wFlags)
{
    TCHAR achKey[20];
    PIC  pic;

    ICEnterCrit(&ICOpenCritSec);
    fccType    = Fix4CC(fccType);
    fccHandler = Fix4CC(fccHandler);

    DPF(("ICRemove, fccType=%4.4s, Handler=%4.4s\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
    if (pic = FindConverter(fccType, fccHandler))
    {
	int i;

	//
	// we should realy keep usage counts!!!
	//
	for (i=0; i<MAX_CONVERTERS; i++)
	{
	    if (pic->DriverProc == aicConverters[i].DriverProc)
	    {
		DPF(("ACK! Handler is in use\r\n"));
		pic->DriverProc = DriverProcNull;
	    }
	}

	ICClose((HIC)pic);
    }
    else
    {
	ictokey(fccType, fccHandler, achKey);
	WritePrivateProfileString(szIniSect,achKey,NULL,szSystemIni);
	WritePrivateProfileString(szDrivers,achKey,NULL,szSystemIni);
    }

    ICLeaveCrit(&ICOpenCritSec);

    return TRUE;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api BOOL | ICInfo | This function returns information about
 *      specific installed compressors, or it enumerates
 *      the compressors installed.
 *
 * @parm DWORD | fccType | Specifies a four-character code indicating
 *       the type of compressor.  To match all compressor types specify zero.
 *
 * @parm DWORD | fccHandler | Specifies a four-character code identifying
 *       a specific compressor, or a number between 0 and the number
 *       of installed compressors of the type specified by <t fccType>.
 *
 * @parm ICINFO FAR * | lpicinfo | Specifies a far pointer to a
 *       <t ICINFO> structure used to return
 *      information about the compressor.
 *
 * @comm This function does not return full informaiton about
 *       a compressor or decompressor. Use <f ICGetInfo> for full
 *       information.
 *
 * @rdesc Returns TRUE if successful.
 ****************************************************************************/

#ifndef NOTHUNKS
BOOL VFWAPI ICInfoInternal(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo);

// If we are compiling the thunks, then the ICINFO entry point calls
// the 32 bit thunk, or calls the real ICInfo code (as ICInfoInternal).
// We deliberately give precedence to 32 bit compressors, although this
// ordering can be trivially changed.
// ??: Should we allow an INI setting to change the order?

BOOL VFWAPI ICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo)
{
    BOOL fResult;

    fResult = (ICInfo32(fccType, fccHandler, lpicinfo));
    DPF(("ICInfo32 returned %ls\r\n", (fResult ? (LPSTR)"TRUE" : (LPSTR)"FALSE")));
    if (fResult) return fResult;

    // If we are enumerating the drivers, then we want to adjust the 16
    // bit index by the count of 32 bit drivers.  The thunk will have
    // passed back the number of 32 bit drivers installed in [Drivers32]
    // in ICINFO.fccHandler.
    if ((fccType==0) || (fccHandler < 256)) {
	DPF(("Enumerating... no 32 bit match, Count is %ld, max count is %ld\n", fccType, lpicinfo->fccHandler));

	if (fccHandler >= lpicinfo->fccHandler)
	    fccHandler -= lpicinfo->fccHandler;
	else
	    ; // This should be an assertion.  This leg is invalid.
    }

    //
    //  See if there is a 16-bit compressor we can use
    //  Because we always try 32 bit compressors first, if the user is
    //  enumerating the list of compressors we need to subtract the count
    //  of 32 bit compressors.
    //
    DPF(("ICInfo, fccType=%4.4hs, Handler=%4.4hs\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
    return (ICInfoInternal(fccType, fccHandler, lpicinfo));
}
// Now map all ICInfo calls to ICInfoInternal

#define ICInfo ICInfoInternal
#endif //NOTHUNKS

BOOL VFWAPI ICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo)
{
    char buf[128];
    static LPTSTR pszBuf = NULL;
    TCHAR achKey[20];
#ifdef WIN32
    TCHAR achTypeCopy[5];
    char newHandler[5];
    char newType[5];
#endif
    int  i;
    int  iComp;
    PIC  pic;

    DPF(("ICInfoInternal(16), fccType=%4.4hs, Handler=%4.4hs\n", (LPSTR)&fccType, (LPSTR)&fccHandler));
    if (lpicinfo == NULL)
	return FALSE;

    // THIS IS NOT REDUNDANT.  what if fccType == 0
    if (fccType > 0 && fccType < 256) {
        DPF(("fcctype invalid\r\n"));
        return FALSE;
    }

    fccType    = Fix4CC(fccType);
    fccHandler = Fix4CC(fccHandler);

    if (fccType != 0 && fccHandler > 256)
    {
	//
	//  the user has given us a specific fccType and fccHandler
	//  get the info and return.
	//
	if (pic = FindConverter(fccType, fccHandler))
	{
	    ICGetInfo((HIC)pic, lpicinfo, sizeof(ICINFO));
	    return TRUE;
	}
	else
	{
	    lpicinfo->dwSize            = sizeof(ICINFO);
	    lpicinfo->fccType           = fccType;
	    lpicinfo->fccHandler        = fccHandler;
	    lpicinfo->dwFlags           = 0;
	    lpicinfo->dwVersionICM      = ICVERSION;
	    lpicinfo->dwVersion         = 0;
	    lpicinfo->szDriver[0]       = 0;
	    lpicinfo->szDescription[0]  = 0;
	    lpicinfo->szName[0]         = 0;

	    ictokey(fccType, fccHandler, achKey);

	    if (!GetPrivateProfileString(szDrivers,achKey,szNull,buf,sizeof(buf)/sizeof(TCHAR),szSystemIni) &&
		!GetPrivateProfileString(szIniSect,achKey,szNull,buf,sizeof(buf)/sizeof(TCHAR),szSystemIni))
            {
                DPF(("NO information in DRIVERS section\n"));
		return FALSE;
            }

	    for (i=0; buf[i] && buf[i] != TEXT(' '); i++)
		lpicinfo->szDriver[i] = buf[i];

	    lpicinfo->szDriver[i] = 0;

	    //
	    // the driver must be opened to get description
	    //
	    lpicinfo->szDescription[0] = 0;

	    return TRUE;
	}
    }
    else
    {
	//
	//  the user has given us a specific fccType and a
	//  ordinal for fccHandler, enum the compressors, looking for
	//  the nth compressor of 'fccType'
	//

	iComp = (int)fccHandler;

	//
	//  walk the installed converters.
	//
	for (i=0; i < MAX_CONVERTERS; i++)
	{
	    pic = &aicConverters[i];

	    if (pic->fccType != 0 &&
		(fccType == 0 || pic->fccType == fccType) &&
		pic->dwDriver == 0L && iComp-- == 0)
	    {
		return ICInfo(pic->fccType, pic->fccHandler, lpicinfo);
	    }
	}

	//
	// read all the keys. from [Drivers] and [Installable Compressors]
	//

	if (pszBuf == NULL) {
	    UINT cbBuffer = 128 * sizeof(TCHAR);
	    UINT cchBuffer;
	
	    for (;;)
	    {
		pszBuf = GlobalAllocPtr(GMEM_SHARE | GHND, cbBuffer);

		if (!pszBuf) {
		    DPF(("Out of memory for SYSTEM.INI keys\r\n"));
		    return FALSE;
		}

		cchBuffer = (UINT)GetPrivateProfileString(szDrivers,
							  NULL,
							  szNull,
							  pszBuf,
							  cbBuffer / sizeof(TCHAR),
							  szSystemIni);

		if (cchBuffer < ((cbBuffer / sizeof(TCHAR)) - 5)) {
		    cchBuffer += (UINT)GetPrivateProfileString(szIniSect,
							  NULL,
							  szNull,
							  pszBuf + cchBuffer,
							  (cbBuffer / sizeof(TCHAR)) - cchBuffer,
							  szSystemIni);

		    if (cchBuffer < ((cbBuffer / sizeof(TCHAR)) - 5))
			break;
		}

		GlobalFreePtr(pszBuf);
		pszBuf = NULL;

		//
		//  if cannot fit drivers section in 32k, then something is horked
		//  with the section... so let's bail.
		//
		if (cbBuffer >= 0x8000) {
		    DPF(("SYSTEM.INI keys won't fit in 32K????\r\n"));
		    return FALSE;
		}
		
		cbBuffer *= 2;
		DPF(("Increasing size of SYSTEM.INI buffer to %d\r\n", cbBuffer));
	    }
	}


#ifdef WIN32
	/* make a widechar copy of the Ansi fccType so we can compare it with
	 * the wide copy returned from GetPrivateProfileString()
	 */
	MultiByteToWideChar(CP_ACP, 0, (LPSTR) &fccType, sizeof(fccType),
			    achTypeCopy, sizeof(achTypeCopy)/sizeof(TCHAR) );
#endif
	for (i=0; pszBuf[i] != 0; i += lstrlen(&pszBuf[i]) + 1)
	{
	    if (pszBuf[i+4]!=TEXT('.'))
		continue;
#ifdef WIN32
	    CharLower(&pszBuf[i]);

	    if ((fccType == 0 ||
		(wcsncmp(achTypeCopy, &pszBuf[i], sizeof(fccType)) == 0)) &&
		iComp-- == 0)
	    {
		WideCharToMultiByte(CP_ACP, 0, &pszBuf[i], sizeof(fccType),
			newType, sizeof(newType),NULL, NULL);

		WideCharToMultiByte(CP_ACP, 0, &pszBuf[i+5], sizeof(fccType),
			newHandler, sizeof(newHandler),NULL, NULL);

		return ICInfo(*(LPDWORD)&newType[0],*(LPDWORD)&newHandler[0], lpicinfo);
	    }
#else
	    AnsiLower(&pszBuf[i]);

	    if ((fccType == 0 || fccType == *(LPDWORD)&pszBuf[i]) && iComp-- == 0)
	    {
		return ICInfo(*(LPDWORD)&pszBuf[i],*(LPDWORD)&pszBuf[i+5], lpicinfo);
	    }
#endif
	}

	//
	// now walk the msvideo drivers. these are listed in system.ini
	// like so:
	//
	//      [Drivers]
	//          MSVideo = driver
	//          MSVideo1 = driver
	//          MSVideoN =
	//
	if (fccType == 0 || fccType == ICTYPE_VCAP)
	{
	    lstrcpy(achKey, szMSVideo);

	    if (iComp > 0)
		wsprintf(achKey+lstrlen(achKey), (LPVOID)"%d", iComp);

	    if (!GetPrivateProfileString(szDrivers,achKey,szNull,buf,sizeof(buf)/sizeof(TCHAR),szSystemIni))
		return FALSE;

	    lpicinfo->dwSize            = sizeof(ICINFO);
	    lpicinfo->fccType           = ICTYPE_VCAP;
	    lpicinfo->fccHandler        = iComp;
	    lpicinfo->dwFlags           = 0;
	    lpicinfo->dwVersionICM      = ICVERSION;    //??? right for video?
	    lpicinfo->dwVersion         = 0;
	    lpicinfo->szDriver[0]       = 0;
	    lpicinfo->szDescription[0]  = 0;
	    lpicinfo->szName[0]         = 0;

	    for (i=0; buf[i] && buf[i] != TEXT(' '); i++)
		lpicinfo->szDriver[i] = buf[i];

	    lpicinfo->szDriver[i] = 0;
	    return TRUE;
	}

	return FALSE;
    }
}
#undef ICInfo

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICGetInfo | This function obtains information about
 *      a compressor.
 *
 * @parm HIC | hic | Specifies a handle to a compressor.
 *
 * @parm ICINFO FAR * | lpicinfo | Specifies a far pointer to <t ICINFO> structure
 *       used to return information about the compressor.
 *
 * @parm DWORD | cb | Specifies the size, in bytes, of the structure pointed to
 *       by <p lpicinfo>.
 *
 * @rdesc Return the number of bytes copied into the data structure,
 *        or zero if an error occurs.
 *
 * @comm Use <f ICInfo> for full information about a compressor.
 *
 ****************************************************************************/
LRESULT VFWAPI ICGetInfo(HIC hic, ICINFO FAR *picinfo, DWORD cb)
{
    PIC pic = (PIC)hic;
    DWORD dw;

    V_HIC(hic);

    picinfo->dwSize            = sizeof(ICINFO);
    picinfo->fccType           = 0;
    picinfo->fccHandler        = 0;
    picinfo->dwFlags           = 0;
    picinfo->dwVersionICM      = ICVERSION;
    picinfo->dwVersion         = 0;
    picinfo->szDriver[0]       = 0;
    picinfo->szDescription[0]  = 0;
    picinfo->szName[0]         = 0;

#ifndef NOTHUNKS
    if (!Is32bitHandle(hic))
#endif //!NOTHUNKS
	if (pic->hDriver)
	{
	    GetModuleFileName(GetDriverModuleHandle(pic->hDriver),
		picinfo->szDriver, sizeof(picinfo->szDriver));
	}

    dw = ICSendMessage((HIC)pic, ICM_GETINFO, (DWORD)picinfo, cb);

    return dw;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICSendMessage | This function sends a
 *      message to a compressor.
 *
 * @parm HIC  | hic  | Specifies the handle of the
 *       compressor to receive the message.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dw1 | Specifies additional message-specific information.
 *
 * @parm DWORD | dw2 | Specifies additional message-specific information.
 *
 * @rdesc Returns a message-specific result.
 ****************************************************************************/
LRESULT VFWAPI ICSendMessage(HIC hic, UINT msg, DWORD dw1, DWORD dw2)
{
    PIC pic = (PIC)hic;
    LRESULT l;

#ifndef NOTHUNKS

    //
    // If it's a 32-bit handle then send it to the 32-bit code
    // We need to take some extra care with ICM_DRAW_SUGGESTFORMAT
    // which can include a HIC in the ICDRAWSUGGEST structure.
    //

#define ICD(dw1)  ((ICDRAWSUGGEST FAR *)(dw1))

    if (pic->h32) {

        ICDebugMessage(hic, msg, dw1, dw2);

	if ((msg == ICM_DRAW_SUGGESTFORMAT)
	    && (((ICDRAWSUGGEST FAR *)dw1)->hicDecompressor))
	{
	    // We are in the problem area.
	    //   IF the hicDecompressor field is NULL, pass as is.
	    //   IF it identifies a 32 bit decompressor, translate the handle
	    //   OTHERWISE... what?  We have a 32 bit compressor, that is
	    //      being told it can use a 16 bit decompressor!!
	    if ( ((PIC) (((ICDRAWSUGGEST FAR *)dw1)->hicDecompressor))->h32)
	    {
		ICD(dw1)->hicDecompressor
			= (HIC)((PIC)(ICD(dw1)->hicDecompressor))->h32;
	    } else
	    {
		ICD(dw1)->hicDecompressor = NULL;  // Sigh...
	    }

	}
	l = ICSendMessage32(pic->h32, msg, dw1, dw2);
        return ICDebugReturn(l);
    }

#endif //!NOTHUNKS

    V_HIC(hic);

    ICDebugMessage(hic, msg, dw1, dw2);

    l = pic->DriverProc(pic->dwDriver, (HDRVR)1, msg, dw1, dw2);

#if 1 //!!! is this realy needed!  !!!yes I think it is
    //
    // special case some messages and give default values.
    //
    if (l == ICERR_UNSUPPORTED)
    {
	switch (msg)
	{
	    case ICM_GETDEFAULTQUALITY:
		*((LPDWORD)dw1) = ICQUALITY_HIGH;
		l = ICERR_OK;
		break;

	    case ICM_GETDEFAULTKEYFRAMERATE:
		*((LPDWORD)dw1) = 15;
		l = ICERR_OK;
		break;
	}
    }
#endif

    return ICDebugReturn(l);
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICMessage | This function sends a
 *      message and a variable number of arguments to a compressor.
 *      If a macro is defined for the message you want to send,
 *      use the macro rather than this function.
 *
 * @parm HIC  | hic  | Specifies the handle of the
 *       compressor to receive the message.
 *
 * @parm UINT | msg | Specifies the message to send.
 *
 * @parm UINT | cb  | Specifies the size, in bytes, of the
 *       optional parameters. (This is usually the size of the data
 *       structure used to store the parameters.)
 *
 * @parm . | . . | Represents the variable number of arguments used
 *       for the optional parameters.
 *
 * @rdesc Returns a message-specific result.
 ****************************************************************************/
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...)
{
    // NOTE no LOADDS!
#ifndef WIN32
    return ICSendMessage(hic, msg, (DWORD)(LPVOID)(&cb+1), cb);
#else
    va_list va;

    va_start(va, cb);
    va_end(va);
    return ICSendMessage(hic, msg, (DWORD)(LPVOID)va, cb);
#endif
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICOpen | This function opens a compressor or decompressor.
 *
 * @parm DWORD | fccType | Specifies the type of compressor
 *      the caller is trying to open.  For video, this is ICTYPE_VIDEO.
 *
 * @parm DWORD | fccHandler | Specifies a single preferred handler of the
 *      given type that should be tried first.  Typically, this comes
 *      from the stream header in an AVI file.
 *
 * @parm UINT | wMode | Specifies a flag to defining the use of
 *       the compressor or decompressor.
 *       This parameter can contain one of the following values:
 *
 * @flag ICMODE_COMPRESS | Advises a compressor it is opened for compression.
 *
 * @flag ICMODE_FASTCOMPRESS | Advise a compressor it is open
 *       for fast (real-time) compression.
 *
 * @flag ICMODE_DECOMPRESS | Advises a decompressor it is opened for decompression.
 *
 * @flag ICMODE_FASTDECOMPRESS | Advises a decompressor it is opened
 *       for fast (real-time) decompression.
 *
 * @flag ICMODE_DRAW | Advises a decompressor it is opened
 *       to decompress an image and draw it directly to hardware.
 *
 * @flag ICMODE_QUERY | Advise a compressor or decompressor it is opened
 *       to obtain information.
 *
 * @rdesc Returns a handle to a compressor or decompressor
 *        if successful, otherwise it returns zero.
 ****************************************************************************/


INLINE PIC NEAR PASCAL ICOpenInternal(PIC pic, DWORD fccType, DWORD fccHandler,
                ICINFO FAR * picinfo, ICOPEN FAR * picopen, UINT wMode)
{
    PIC picT;

    if (picinfo->szDriver[0])
    {
#ifdef DEBUG
	DWORD time = timeGetTime();
	char ach[80];
#endif
	pic->hDriver = LoadDriver(picinfo->szDriver, &pic->DriverProc);

#ifdef DEBUG
	time = timeGetTime() - time;
	wsprintfA(ach, "COMPMAN: LoadDriver(%ls) (%ldms)\r\n", (LPSTR)picinfo->szDriver, time);
	OutputDebugStringA(ach);
#endif

	if (pic->hDriver == NULL)
	{
	    pic->dwSmag = 0;
	    return NULL;
	}

	//
	// now try to open the driver as a codec.
	//
	pic->dwDriver = ICSendMessage((HIC)pic, DRV_OPEN, 0, (DWORD)(LPVOID)picopen);

	//
	//  we want to be able to install 1.0 draw handlers in SYSTEM.INI as:
	//
	//      VIDS.SMAG = SMAG.DRV
	//
	//  but old driver's may not open iff fccType == 'vids' only if
	//  fccType == 'vidc'
	//
	//  they also may not like ICMODE_DRAW
	//
	if (pic->dwDriver == 0 &&
	    picopen->dwError != 0 &&
	    fccType == streamtypeVIDEO)
	{
	    if (wMode == ICMODE_DRAW)
		picopen->dwFlags = ICMODE_DECOMPRESS;

	    picopen->fccType = ICTYPE_VIDEO;
	    pic->dwDriver = ICSendMessage((HIC)pic, DRV_OPEN, 0, (DWORD)(LPVOID)picopen);
	}

	if (pic->dwDriver == 0)
	{
	    ICClose((HIC)pic);
	    return NULL;
	}

	// open'ed ok mark these
	pic->fccType    = fccType;
	pic->fccHandler = fccHandler;
    }
    else if (picT = FindConverter(fccType, fccHandler))
    {
        DWORD dw;
	picT->dwSmag = SMAG;
	dw = ICSendMessage((HIC)picT, DRV_OPEN, 0, (DWORD)(LPVOID)picopen);

	if (dw == 0)
	{
	    pic->dwSmag = 0;
	    return NULL;
	}

	*pic = *picT;
	pic->dwDriver = dw;
    }

    return pic;
}

/* Helper functions for compression library */
HIC VFWAPI ICOpen(DWORD fccType, DWORD fccHandler, UINT wMode)
{
    ICOPEN      icopen;
    ICINFO      icinfo;
    PIC         pic;
    HIC         hic = NULL;   // Initialise

    ICEnterCrit(&ICOpenCritSec);

    AnsiLowerBuff((LPSTR) &fccType, sizeof(DWORD));
    AnsiLowerBuff((LPSTR) &fccHandler, sizeof(DWORD));
    icopen.dwSize  = sizeof(ICOPEN);
    icopen.fccType = fccType;
    icopen.fccHandler = fccHandler;
    icopen.dwFlags = wMode;
    icopen.dwError = 0;

    DPF(("\nICOpen('%4.4s','%4.4s)'\r\n", (LPSTR)&fccType, (LPSTR)&fccHandler));

    if (!ICInfo(fccType, fccHandler, &icinfo))
    {
	RPF(("Unable to locate Compression module '%4.4s' '%4.4s'\r\n", (LPSTR)&fccType, (LPSTR)&fccHandler));

	ICLeaveCrit(&ICOpenCritSec);
	return NULL;
    }

    pic = FindConverter(0L, 0L);

    if (pic == NULL)
    {
	ICLeaveCrit(&ICOpenCritSec);
	return NULL;
    }


#ifndef NOTHUNKS
    // Try and open on the 32 bit side first.
    // This block and the one below can be interchanged to alter the order
    // in which we try and open the compressor.
    if (hic == NULL)
    {
	pic->dwSmag     = SMAG;
	pic->hTask      = (HTASK)GetCurrentTask();
	pic->h32 = ICOpen32(fccType, fccHandler, wMode);

	if (pic->h32 != 0) {
	    pic->fccType    = fccType;
	    pic->fccHandler = fccHandler;
	    pic->dwDriver   = (DWORD) -1;
	    pic->DriverProc = NULL;
	    hic = (HIC)pic;
	}
    }
#endif //NOTHUNKS

    // Open on the 32 bit side first, then try and open 16 bit...
    if (hic == NULL) {
        pic->dwSmag     = SMAG;
        pic->hTask      = (HTASK)GetCurrentTask();

        hic = (HIC)ICOpenInternal(pic, fccType, fccHandler, &icinfo, &icopen, wMode);
    }
    ICLeaveCrit(&ICOpenCritSec);

    return(hic);
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICOpenFunction | This function opens
 *      a compressor or decompressor defined as a function.
 *
 * @parm DWORD | fccType | Specifies the type of compressor
 *      the caller is trying to open.  For video, this is ICTYPE_VIDEO.
 *
 * @parm DWORD | fccHandler | Specifies a single preferred handler of the
 *      given type that should be tried first.  Typically, this comes
 *      from the stream header in an AVI file.
 *
 * @parm UINT | wMode | Specifies a flag to defining the use of
 *       the compressor or decompressor.
 *       This parameter can contain one of the following values:
 *
 * @flag ICMODE_COMPRESS | Advises a compressor it is opened for compression.
 *
 * @flag ICMODE_FASTCOMPRESS | Advise a compressor it is open
 *       for fast (real-time) compression.
 *
 * @flag ICMODE_DECOMPRESS | Advises a decompressor it is opened for decompression.
 *
 * @flag ICMODE_FASTDECOMPRESS | Advises a decompressor it is opened
 *       for fast (real-time) decompression.
 *
 * @flag ICMODE_DRAW | Advises a decompressor it is opened
 *       to decompress an image and draw it directly to hardware.
 *
 * @flag ICMODE_QUERY | Advise a compressor or decompressor it is opened
 *       to obtain information.
 *
 * @parm FARPROC | lpfnHandler | Specifies a pointer to the function
 *       used as the compressor or decompressor.
 *
 * @rdesc Returns a handle to a compressor or decompressor
 *        if successful, otherwise it returns zero.
 ****************************************************************************/

HIC VFWAPI ICOpenFunction(DWORD fccType, DWORD fccHandler, UINT wMode, FARPROC lpfnHandler)
{
    ICOPEN      icopen;
    PIC         pic;
    DWORD       dw;

    if (IsBadCodePtr(lpfnHandler))
	return NULL;

#ifndef NOTHUNKS
    // lpfnHandler points to 16 bit code that will be used as a compressor.
    // We do not want this to go over to the 32 bit side.
#endif

    AnsiLowerBuff((LPSTR) &fccType, sizeof(DWORD));
    AnsiLowerBuff((LPSTR) &fccHandler, sizeof(DWORD));
    icopen.dwSize  = sizeof(ICOPEN);
    icopen.fccType = fccType;
    icopen.fccHandler = fccHandler;
    icopen.dwFlags = wMode;

    pic = FindConverter(0L, 0L);

    if (pic == NULL)
	return NULL;

    pic->dwSmag   = SMAG;
    pic->fccType  = fccType;
    pic->fccHandler  = fccHandler;
    pic->dwDriver = 0L;
    pic->hDriver  = NULL;
    pic->DriverProc  = (DRIVERPROC)lpfnHandler;

    dw = ICSendMessage((HIC)pic, DRV_OPEN, 0, (DWORD)(LPVOID)&icopen);

    if (dw == 0)
    {
	ICClose((HIC) pic);
	return NULL;
    }

    pic->dwDriver = dw;

    return (HIC)pic;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api LRESULT | ICClose | This function closes a compressor or decompressor.
 *
 * @parm HIC | hic | Specifies a handle to a compressor or decompressor.
 *
 * @rdesc Returns ICERR_OK if successful, otherwise it returns an error number.
 *
 ****************************************************************************/

LRESULT VFWAPI ICClose(HIC hic)
{
    PIC pic = (PIC)hic;

    V_HIC(hic);

#ifndef NOTHUNKS
    if (pic->h32 != 0) {
	LRESULT lres = ICClose32(pic->h32);
        pic->dwSmag   = GONE;
        pic->fccType  = 0L;
        pic->fccHandler  = 0L;
        pic->dwDriver = 0;
        pic->hDriver = NULL;
        pic->DriverProc = NULL;
	pic->h32 = 0;       // Next user of this slot does not want h32 set
	return(lres);
    }
#endif //!NOTHUNKS

#ifdef DEBUG
    {
    char ach[80];

    if (pic->hDriver)
	GetModuleFileName(GetDriverModuleHandle (pic->hDriver), ach, sizeof(ach));
    else
	ach[0] = 0;

    DPF(("ICClose(%04X) %4.4s.%4.4s %s\r\n", hic, (LPSTR)&pic->fccType, (LPSTR)&pic->fccHandler, (LPSTR)ach));
    }
#endif

#ifdef DEBUG
    ICDump();
#endif

    ICEnterCrit(&ICOpenCritSec);

    if (pic->dwDriver)
    {
	if (pic->DriverProc)
	    ICSendMessage((HIC)pic, DRV_CLOSE, 0, 0);
    }

    if (pic->hDriver)
	FreeDriver(pic->hDriver);

    pic->dwSmag   = 0L;
    pic->fccType  = 0L;
    pic->fccHandler  = 0L;
    pic->dwDriver = 0;
    pic->hDriver = NULL;
    pic->DriverProc = NULL;

    ICLeaveCrit(&ICOpenCritSec);

    return ICERR_OK;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

/****************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICCompress | This function compresses a single video
* image.
*
* @parm HIC | hic | Specifies the handle of the compressor to
*       use.
*
* @parm DWORD | dwFlags | Specifies applicable flags for the compression.
*       The following flag is defined:
*
* @flag ICCOMPRESS_KEYFRAME | Indicates that the compressor
*       should make this frame a key frame.
*
* @parm LPBITMAPINFOHEADER | lpbiOutput | Specifies a far pointer
*       to a <t BITMAPINFO> structure holding the output format.
*
* @parm LPVOID | lpData | Specifies a far pointer to output data buffer.
*
* @parm LPBITMAPINFOHEADER | lpbiInput | Specifies a far pointer
*       to a <t BITMAPINFO> structure containing the input format.
*
* @parm LPVOID | lpBits | Specifies a far pointer to the input data buffer.
*
* @parm LPDWORD | lpckid | Not used.
*
* @parm LPDWORD | lpdwFlags | Specifies a far pointer to a <t DWORD>
*       holding the return flags used in the AVI index. The following
*       flag is defined:
*
* @flag AVIIF_KEYFRAME | Indicates this frame should be used as a key-frame.
*
* @parm LONG | lFrameNum | Specifies the frame number.
*
* @parm DWORD | dwFrameSize | Specifies the requested frame size in bytes.
*       If set to zero, the compressor chooses the frame size.
*
* @parm DWORD | dwQuality | Specifies the requested quality value for the frame.
*
* @parm LPBITMAPINFOHEADER | lpbiPrev | Specifies a far pointer to
*       a <t BITMAPINFO> structure holding the previous frame's format.
*       This parameter is not used for fast temporal compression.
*
* @parm LPVOID | lpPrev | Specifies a far pointer to the
*       previous frame's data buffer. This parameter is not used for fast
*       temporal compression.
*
* @comm The <p lpData> buffer should be large enough to hold a compressed
*       frame. You can obtain the size of this buffer by calling
*       <f ICCompressGetSize>.
*
* Set the <p dwFrameSize> parameter to a requested frame
*     size only if the compressor returns the VIDCF_CRUNCH flag in
*     response to <f ICGetInfo>. If this flag is not set, or if a data
*     rate is not specified, set this parameter to zero.
*
*     Set the <p dwQuality> parameter to a quality value only
*     if the compressor returns the VIDCF_QUALITY flag in response
*     to <f ICGetInfo>. Without this flag, set this parameter to zero.
*
* @rdesc This function returns ICERR_OK if successful. Otherwise,
*        it returns an error code.
*
* @xref <f ICCompressBegin> <f ICCompressEnd> <f ICCompressGetSize> <f ICGetInfo>
*
**********************************************************************/
DWORD VFWAPIV ICCompress(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    LPBITMAPINFOHEADER  lpbiOutput,     // output format
    LPVOID              lpData,         // output data
    LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    LPVOID              lpBits,         // frame data to compress
    LPDWORD             lpckid,         // ckid for data in AVI file
    LPDWORD             lpdwFlags,      // flags in the AVI index.
    LONG                lFrameNum,      // frame number of seq.
    DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    DWORD               dwQuality,      // quality
    LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    LPVOID              lpPrev)         // previous frame
{
#ifdef WIN32
    // We cannot rely on the stack alignment giving us the right layout
    ICCOMPRESS icc;
    icc.dwFlags     =  dwFlags;
    icc.lpbiOutput  =  lpbiOutput;
    icc.lpOutput    =  lpData;
    icc.lpbiInput   =  lpbiInput;
    icc.lpInput     =  lpBits;
    icc.lpckid      =  lpckid;
    icc.lpdwFlags   =  lpdwFlags;
    icc.lFrameNum   =  lFrameNum;
    icc.dwFrameSize =  dwFrameSize;
    icc.dwQuality   =  dwQuality;
    icc.lpbiPrev    =  lpbiPrev;
    icc.lpPrev      =  lpPrev;
    return ICSendMessage(hic, ICM_COMPRESS, (DWORD)(LPVOID)&icc, sizeof(ICCOMPRESS));
    // NOTE: We do NOT copy any results from this temporary structure back
    // to the input variables.
#else
    return ICSendMessage(hic, ICM_COMPRESS, (DWORD)(LPVOID)&dwFlags, sizeof(ICCOMPRESS));
#endif
}

/************************************************************************

    decompression functions

************************************************************************/

/*******************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICDecompress | The function decompresses a single video frame.
*
* @parm HIC | hic | Specifies a handle to the decompressor to use.
*
* @parm DWORD | dwFlags | Specifies applicable flags for decompression.
*       The following flags are defined:
*
* @flag ICDECOMPRESS_HURRYUP | Indicates the decompressor should try to
*       decompress at a faster rate. When an application uses this flag,
*       it should not draw the decompressed data.
*
* @flag ICDECOMPRESS_UPDATE | Indicates that the screen is being updated.
*
* @flag ICDECOMPRESS_PREROLL | Indicates that this frame will not actually
*            be drawn, because it is before the point in the movie where play
*            will start.
*
* @flag ICDECOMPRESS_NULLFRAME | Indicates that this frame does not actually
*            have any data, and the decompressed image should be left the same.
*
* @flag ICDECOMPRESS_NOTKEYFRAME | Indicates that this frame is not a
*            key frame.
*
* @parm LPBITMAPINFOHEADER | lpbiFormat | Specifies a far pointer
*       to a <t BITMAPINFO> structure containing the format of
*       the compressed data.
*
* @parm LPVOID | lpData | Specifies a far pointer to the input data.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a far pointer to a
*       <t BITMAPINFO> structure containing the output format.
*
* @parm LPVOID | lpBits | Specifies a far pointer to a data buffer for the
*       decompressed data.
*
* @comm The <p lpBits> parameter should point to a buffer large
*       enough to hold the decompressed data. Applications can obtain
*       the size of this buffer with <f ICDecompressGetSize>.
*
* @rdesc Returns ICERR_OK on success, otherwise it returns an error code.
*
* @xref <f ICDecompressBegin< <f ICDecompressEnd> <f ICDecompressGetSize>
*
********************************************************************/
DWORD VFWAPIV ICDecompress(
    HIC                 hic,
    DWORD               dwFlags,    // flags (from AVI index...)
    LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
				    // biSizeImage has the chunk size
				    // biCompression has the ckid (AVI only)
    LPVOID              lpData,     // data
    LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    LPVOID              lpBits)
{
#if 1
    ICDECOMPRESS icd;
    // We cannot rely on the stack alignment giving us the right layout
    icd.dwFlags    = dwFlags;

    icd.lpbiInput  = lpbiFormat;

    icd.lpInput    = lpData;

    icd.lpbiOutput = lpbi;
    icd.lpOutput   = lpBits;
    icd.ckid       = 0;
    return ICSendMessage(hic, ICM_DECOMPRESS, (DWORD)(LPVOID)&icd, sizeof(ICDECOMPRESS));
#else
    return ICSendMessage(hic, ICM_DECOMPRESS, (DWORD)(LPVOID)&dwFlags, sizeof(ICDECOMPRESS));
#endif
}

/************************************************************************

    drawing functions

************************************************************************/

/**********************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICDrawBegin | This function starts decompressing
* data directly to the screen.
*
* @parm HIC | hic | Specifies a handle to the decompressor to use.
*
* @parm DWORD | dwFlags | Specifies flags for the decompression. The
*       following flags are defined:
*
* @flag ICDRAW_QUERY | Determines if the decompressor can handle
*       the decompression.  The driver does not actually decompress the data.
*
* @flag ICDRAW_FULLSCREEN | Tells the decompressor to draw
*       the decompressed data on the full screen.
*
* @flag ICDRAW_HDC | Indicates the decompressor should use the window
*       handle specified by <p hwnd> and the display context
*       handle specified by <p hdc> for drawing the decompressed data.
*
* @flag ICDRAW_ANIMATE | Indicates the palette might be animated.
*
* @flag ICDRAW_CONTINUE | Indicates drawing is a
*       continuation of the previous frame.
*
* @flag ICDRAW_MEMORYDC | Indicates the display context is offscreen.
*
* @flag ICDRAW_UPDATING | Indicates the frame is being
*       updated rather than played.
*
* @parm HPALETTE | hpal | Specifies a handle to the palette used for drawing.
*
* @parm HWND | hwnd | Specifies a handle for the window used for drawing.
*
* @parm HDC | hdc | Specifies the display context used for drawing.
*
* @parm int | xDst | Specifies the x-position of the upper-right
*       corner of the destination rectangle.
*
* @parm int | yDst | Specifies the y-position of the upper-right
*       corner of the destination rectangle.
*
* @parm int | dxDst | Specifies the width of the destination rectangle.
*
* @parm int | dyDst | Specifies the height of the destination rectangle.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a far pointer to
*       a <t BITMAPINFO> structure containing the format of
*       the input data to be decompressed.
*
* @parm int | xSrc | Specifies the x-position of the upper-right corner
*       of the source rectangle.
*
* @parm int | ySrc | Specifies the y-position of the upper-right corner
*       of the source rectangle.
*
* @parm int | dxSrc | Specifies the width of the source rectangle.
*
* @parm int | dySrc | Specifies the height of the source rectangle.
*
* @parm DWORD | dwRate | Specifies the data rate. The
*       data rate in frames per second equals <p dwRate> divided
*       by <p dwScale>.
*
* @parm DWORD | dwScale | Specifies the data rate.
*
* @comm Decompressors use the <p hwnd> and <p hdc> parameters
*       only if an application sets ICDRAW_HDC flag in <p dwFlags>.
*       It will ignore these parameters if an application sets
*       the ICDRAW_FULLSCREEN flag. When an application uses the
*       ICDRAW_FULLSCREEN flag, it should set <p hwnd> and <p hdc>
*       to NULL.
*
*       The destination rectangle is specified only if ICDRAW_HDC is used.
*       If an application sets the ICDRAW_FULLSCREEN flag, the destination
*       rectangle is ignored and its parameters can be set to zero.
*
*       The source rectangle is relative to the full video frame.
*       The portion of the video frame specified by the source
*       rectangle will be stretched to fit in the destination rectangle.
*
* @rdesc Returns ICERR_OK if it can handle the decompression, otherwise
*        it returns ICERR_UNSUPPORTED.
*
* @xref <f ICDraw> <f ICDrawEnd>
*
*********************************************************************/
DWORD VFWAPIV ICDrawBegin(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    HPALETTE            hpal,           // palette to draw with
    HWND                hwnd,           // window to draw to
    HDC                 hdc,            // HDC to draw to
    int                 xDst,           // destination rectangle
    int                 yDst,
    int                 dxDst,
    int                 dyDst,
    LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
    int                 xSrc,           // source rectangle
    int                 ySrc,
    int                 dxSrc,
    int                 dySrc,
    DWORD               dwRate,         // frames/second = (dwRate/dwScale)
    DWORD               dwScale)
{
#ifdef WIN32
    ICDRAWBEGIN icdraw;
    icdraw.dwFlags   =  dwFlags;
    icdraw.hpal      =  hpal;
    icdraw.hwnd      =  hwnd;
    icdraw.hdc       =  hdc;
    icdraw.xDst      =  xDst;
    icdraw.yDst      =  yDst;
    icdraw.dxDst     =  dxDst;
    icdraw.dyDst     =  dyDst;
    icdraw.lpbi      =  lpbi;
    icdraw.xSrc      =  xSrc;
    icdraw.ySrc      =  ySrc;
    icdraw.dxSrc     =  dxSrc;
    icdraw.dySrc     =  dySrc;
    icdraw.dwRate    =  dwRate;
    icdraw.dwScale   =  dwScale;

    return ICSendMessage(hic, ICM_DRAW_BEGIN, (DWORD)(LPVOID)&icdraw, sizeof(ICDRAWBEGIN));
#else
    return ICSendMessage(hic, ICM_DRAW_BEGIN, (DWORD)(LPVOID)&dwFlags, sizeof(ICDRAWBEGIN));
#endif
}

/**********************************************************************
* @doc EXTERNAL IC ICAPPS
*
* @api DWORD | ICDraw | This function decompress an image for drawing.
*
* @parm HIC | hic | Specifies a handle to an decompressor.
*
* @parm DWORD | dwFlags | Specifies any flags for the decompression.
*       The following flags are defined:
*
* @flag ICDRAW_HURRYUP | Indicates the decompressor should
*       just buffer the data if it needs it for decompression
*       and not draw it to the screen.
*
* @flag ICDRAW_UPDATE | Tells the decompressor to update the screen based
*       on data previously received. Set <p lpData> to NULL when
*       this flag is used.
*
* @flag ICDRAW_PREROLL | Indicates that this frame of video occurs before
*       actual playback should start. For example, if playback is to
*       begin on frame 10, and frame 0 is the nearest previous keyframe,
*       frames 0 through 9 are sent to the driver with the ICDRAW_PREROLL
*       flag set. The driver needs this data so it can displya frmae 10
*       properly, but frames 0 through 9 need not be individually displayed.
*
* @flag ICDRAW_NULLFRAME | Indicates that this frame does not actually
*            have any data, and the previous frame should be redrawn.
*
* @flag ICDRAW_NOTKEYFRAME | Indicates that this frame is not a
*            key frame.
*
* @parm LPVOID | lpFormat | Specifies a far pointer to a
*       <t BITMAPINFOHEADER> structure containing the input
*       format of the data.
*
* @parm LPVOID | lpData | Specifies a far pointer to the actual input data.
*
* @parm DWORD | cbData | Specifies the size of the input data (in bytes).
*
* @parm LONG | lTime | Specifies the time to draw this frame based on the
*       time scale sent with <f ICDrawBegin>.
*
* @comm This function is used to decompress the image data for drawing
* by the decompressor.  Actual drawing of frames does not occur
* until <f ICDrawStart> is called. The application should be sure to
* pre-buffer the required number of frames before drawing is started
* (you can obtain this value with <f ICGetBuffersWanted>).
*
* @rdesc Returns ICERR_OK on success, otherwise it returns an appropriate error
* number.
*
* @xref <f ICDrawBegin> <f ICDrawEnd> <f ICDrawStart> <f ICDrawStop> <f ICGetBuffersRequired>
*
**********************************************************************/
DWORD VFWAPIV ICDraw(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    LPVOID              lpFormat,       // format of frame to decompress
    LPVOID              lpData,         // frame data to decompress
    DWORD               cbData,         // size in bytes of data
    LONG                lTime)          // time to draw this frame (see drawbegin dwRate and dwScale)
{
#ifdef WIN32
    ICDRAW  icdraw;
    icdraw.dwFlags  =   dwFlags;
    icdraw.lpFormat =   lpFormat;
    icdraw.lpData   =   lpData;
    icdraw.cbData   =   cbData;
    icdraw.lTime    =   lTime;

    return ICSendMessage(hic, ICM_DRAW, (DWORD)(LPVOID)&icdraw, sizeof(ICDRAW));
#else
    return ICSendMessage(hic, ICM_DRAW, (DWORD)(LPVOID)&dwFlags, sizeof(ICDRAW));
#endif
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICGetDisplayFormat | This function returns the "best"
 *      format available for display a compressed image. The function
 *      will also open a compressor if a handle to an open compressor
 *      is not specified.
 *
 * @parm HIC | hic | Specifies the decompressor that should be used.  If
 *      this is NULL, an appropriate compressor will be opened and returned.
 *
 * @parm LPBITMAPINFOHEADER | lpbiIn | Specifies a pointer to
 *       <t BITMAPINFOHEADER> structure containing the compressed format.
 *
 * @parm LPBITMAPINFOHEADER | lpbiOut | Specifies a pointer
 *       to a buffer used to return the decompressed format.
 *            The buffer should be large enough for a <t BITMAPINFOHEADER>
 *       structure and 256 color entries.
 *
 * @parm int | BitDepth | If non-zero, specifies the preferred bit depth.
 *
 * @parm int | dx | If non-zero, specifies the width to which the image
 *      is to be stretched.
 *
 * @parm int | dy | If non-zero, specifies the height to which the image
 *      is to be stretched.
 *
 * @rdesc Returns a handle to a decompressor if successful, otherwise, it
 *        returns zero.
 ****************************************************************************/

HIC VFWAPI ICGetDisplayFormat(HIC hic, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, int BitDepth, int dx, int dy)
{
    DWORD dw;
    HDC hdc;
    BOOL fNukeHic = (hic == NULL);
    static int ScreenBitDepth = -1;

    if (hic == NULL)
	hic = ICDecompressOpen(ICTYPE_VIDEO, 0L, lpbiIn, NULL);

    if (hic == NULL)
	return NULL;

    //
    // dy = 0 and dy = 0 means don't stretch.
    //
    if (dx == (int)lpbiIn->biWidth && dy == (int)lpbiIn->biHeight)
	dx = dy = 0;

    //
    // ask the compressor if it likes the format.
    //
    dw = ICDecompressQuery(hic, lpbiIn, NULL);

    if (dw != ICERR_OK)
    {
	DPF(("Decompressor did not recognize the input data format\r\n"));
	goto error;
    }

try_again:
    //
    //  ask the compressor first. (so it can set the palette)
    //  this is a HACK, we will send the ICM_GET_PALETTE message later.
    //
    dw = ICDecompressGetFormat(hic, lpbiIn, lpbiOut);

    //
    // init the output format
    //
    *lpbiOut = *lpbiIn;
    lpbiOut->biSize = sizeof(BITMAPINFOHEADER);
    lpbiOut->biCompression = BI_RGB;

    //
    // default to the screen depth.
    //
    if (BitDepth == 0)
    {
	if (ScreenBitDepth < 0)
	{
	    DWORD FAR PASCAL DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);

	    hdc = GetDC(NULL);
	    ScreenBitDepth = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
	    ReleaseDC(NULL, hdc);

	    if (ScreenBitDepth == 15)
		ScreenBitDepth = 16;

	    if (ScreenBitDepth < 8)
		ScreenBitDepth = 8;

	    //
	    // only try 16 bpp if the display supports drawing it.
	    //
	    if (ScreenBitDepth == 16)
	    {
		lpbiOut->biBitCount = 16;

		if (!DrawDibProfileDisplay(lpbiOut))
		    ScreenBitDepth = 24;
	    }

	    if (ScreenBitDepth > 24)
	    {
		lpbiOut->biBitCount = 32;

		if (!DrawDibProfileDisplay(lpbiOut))
		    ScreenBitDepth = 24;
	    }
	}
#ifdef DEBUG
	ScreenBitDepth = GetProfileInt(TEXT("DrawDib"),
				       TEXT("ScreenBitDepth"),
				       ScreenBitDepth);
#endif
	BitDepth = ScreenBitDepth;
    }

    //
    //  always try 8bit first for '8' bit data
    //
    if (lpbiIn->biBitCount == 8)
	BitDepth = 8;

    //
    // lets suggest a format to the device.
    //
try_bit_depth:
    lpbiOut->biSize = sizeof(BITMAPINFOHEADER);
    lpbiOut->biCompression = BI_RGB;
    lpbiOut->biBitCount = BitDepth;

    //
    // should we suggest a stretched decompress
    //
    if (dx > 0 && dy > 0)
    {
	lpbiOut->biWidth  = dx;
	lpbiOut->biHeight = dy;
    }

    lpbiOut->biSizeImage = (DWORD)(UINT)DIBWIDTHBYTES(*lpbiOut) *
			   (DWORD)(UINT)lpbiOut->biHeight;

    //
    // ask the compressor if it likes the suggested format.
    //
    dw = ICDecompressQuery(hic, lpbiIn, lpbiOut);

    //
    // if it likes it then return success.
    //
    if (dw == ICERR_OK)
	goto success;

//  8:   8, 16,24,32,X
//  16:  16,24,32,X
//  24:  24,32,16,X
//  32:  32,24,16,X

    //
    // try another bit depth in this order 8,16,24,32
    //
    if (BitDepth <= 8)
    {
	BitDepth = 16;
	goto try_bit_depth;
    }

    if (BitDepth == 16)
    {
	BitDepth = 24;
	goto try_bit_depth;
    }

    if (BitDepth == 24)
    {
	BitDepth = 32;
	goto try_bit_depth;
    }

    if (BitDepth != 32)
    {
	BitDepth = 32;
	goto try_bit_depth;
    }

    if (dx > 0 && dy > 0)
    {
	dx = 0;
	dy = 0;

	//
	// try to find a non stretched format.  but don't let the
	// device dither if we are going to stretch!
	//
	if (lpbiIn->biBitCount > 8)
	    BitDepth = 16;
	else
	    BitDepth = 0;

	goto try_again;
    }
    else
    {
	//
	// let the compressor suggest a format
	//
	dw = ICDecompressGetFormat(hic, lpbiIn, lpbiOut);

	if (dw == ICERR_OK)
	    goto success;
    }

error:
    if (hic && fNukeHic)
	ICClose(hic);

    return NULL;

success:
    if (lpbiOut->biBitCount == 8)
	ICDecompressGetPalette(hic, lpbiIn, lpbiOut);

    return hic;
}

/*****************************************************************************
 * @doc EXTERNAL IC ICAPPS
 *
 * @api HIC | ICLocate | This function finds a compressor or decompressor
 *      that can handle images with the formats specified, or it finds a
 *      driver that can decompress an image with a specified
 *      format directly to hardware. Applications must close the
 *      compressor when it has finished using the compressor.
 *
 * @parm DWORD | fccType | Specifies the type of compressor
 *      the caller is trying to open.  For video, this is ICTYPE_VIDEO.
 *
 * @parm DWORD | fccHandler | Specifies a single preferred handler of the
 *      given type that should be tried first.  Typically, this comes
 *      from the stream header in an AVI file.
 *
 * @parm LPBITMAPINFOHEADER | lpbiIn | Specifies a pointer to
 *       <t BITMAPINFOHEADER> structure defining the input format.
 *            A compressor handle will not be returned unless it
 *       can handle this format.
 *
 * @parm LPBITMAPINFOHEADER | lpbiOut | Specifies zero or a pointer to
 *       <t BITMAPINFOHEADER> structure defining an optional decompressed
 *            format. If <p lpbiOut> is nonzero, a compressor handle will not
 *       be returned unless it can create this output format.
 *
 * @parm WORD | wFlags | Specifies a flag to defining the use of the compressor.
 *       This parameter must contain one of the following values:
 *
 * @flag ICMODE_COMPRESS | Indicates the compressor should
 *       be able to compress an image with a format defined by <p lpbiIn>
 *       to the format defined by <p lpbiOut>.
 *
 * @flag ICMODE_DECOMPRESS | Indicates the decompressor should
 *       be able to decompress an image with a format defined by <p lpbiIn>
 *       to the format defined by <p lpbiOut>.
 *
 * @flag ICMODE_FASTDECOMPRESS | Has the same definition as ICMODE_DECOMPRESS except the
 *       decompressor is being used for a real-time operation and should trade off speed
 *       for quality if possible.
 *
 * @flag ICMODE_FASTCOMPRESS | Has the same definition as ICMODE_COMPRESS except the
 *       compressor is being used for a real-time operation and should trade off speed
 *       for quality if possible.
 *
 * @flag ICMODE_DRAW | Indicates the decompressor should
 *       be able to decompress an image with a format defined by <p lpbiIn>
 *       and draw it directly to hardware.
 *
 * @rdesc Returns a handle to a compressor or decompressor
 *        if successful, otherwise it returns zero.
 ****************************************************************************/
HIC VFWAPI ICLocate(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags)
{
    HIC hic=NULL;
    int i;
    ICINFO icinfo;
    UINT msg;

    if (fccType == 0)
	return NULL;

    switch (wFlags)
    {
	case ICMODE_FASTCOMPRESS:
	case ICMODE_COMPRESS:
	    msg = ICM_COMPRESS_QUERY;
	    break;

	case ICMODE_FASTDECOMPRESS:
	case ICMODE_DECOMPRESS:
	    msg = ICM_DECOMPRESS_QUERY;
	    break;

	case ICMODE_DRAW:
	    msg = ICM_DRAW_QUERY;
	    break;

	default:
	    return NULL;
    }

    if (fccHandler)
    {
	hic = ICOpen(fccType, fccHandler, wFlags);

	if (hic && ICSendMessage(hic, msg, (DWORD)lpbiIn, (DWORD)lpbiOut) == ICERR_OK)
	    return hic;
	else if (hic)
	    ICClose(hic);
    }

    if (fccType == ICTYPE_VIDEO && lpbiIn)
    {
	if (lpbiIn->biCompression > 256)
	{
	    hic = ICOpen(fccType, lpbiIn->biCompression, wFlags);

	    if (hic && ICSendMessage(hic, msg, (DWORD)lpbiIn, (DWORD)lpbiOut) == ICERR_OK)
		return hic;
	    else if (hic)
		ICClose(hic);
	}
    }

    //
    // Search through all of the compressors, to see if one can do what we
    // want.
    //
    for (i=0; ICInfo(fccType, i, &icinfo); i++)
    {
	hic = ICOpen(fccType, icinfo.fccHandler, wFlags);

	if (hic == NULL)
	    continue;

	if (ICSendMessage(hic, msg, (DWORD)lpbiIn, (DWORD)lpbiOut) != ICERR_OK)
	{
	    ICClose(hic);
	    continue;
	}
	return hic;
    }

    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api HDRVR | LoadDriver | load a driver
 *
 ****************************************************************************/

static HDRVR LoadDriver(LPSTR szDriver, DRIVERPROC FAR *lpDriverProc)
{
    HMODULE hModule;
    UINT u;
    DRIVERPROC DriverProc;
    BOOL fWow;
    HDRVR hDriver;

    fWow = IsWow();

    if (fWow)
    {
	u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
	hModule = LoadLibrary(szDriver);
	SetErrorMode(u);

	if (hModule <= HINSTANCE_ERROR)
	    return NULL;
	hDriver = (HMODULE) hModule;
    }
    else
    {
	hDriver = OpenDriver (szDriver, NULL, NULL);
	if (!hDriver)
	    return NULL;
	hModule = GetDriverModuleHandle (hDriver);
    }
    DPF(("LoadDriver: %s\r\n", szDriver));

    DriverProc = (DRIVERPROC)GetProcAddress(hModule, szDriverProc);

    if (DriverProc == NULL)
    {
	if (fWow)
	{
	    FreeLibrary(hModule);
	}
	else
	{
	    CloseDriver (hDriver, 0L, 0L);
	}
	return NULL;
    }

    if (fWow && GetModuleUsage(hModule) == 1)   //!!!this is not exacly like USER
    {
	if (!DriverProc(0, (HDRVR)1, DRV_LOAD, 0L, 0L))
	{
	    FreeLibrary(hModule);
	    return NULL;
	}

	DriverProc(0, (HDRVR)1, DRV_ENABLE, 0L, 0L);
    }

    CacheModule (hModule);

    *lpDriverProc = DriverProc;
    return hDriver;
}

/*****************************************************************************
 * @doc INTERNAL IC
 *
 * @api void | FreeDriver | unload a driver
 *
 ****************************************************************************/

static void FreeDriver(HDRVR hDriver)
{
    if (!IsWow())
    {
	CloseDriver (hDriver, 0L, 0L);
    }
    else
    {
	if (GetModuleUsage((HMODULE) hDriver) == 1)
	{
	    DRIVERPROC DriverProc;

	    DriverProc = (DRIVERPROC)GetProcAddress((HMODULE) hDriver, szDriverProc);

	    if (DriverProc)
	    {
		DriverProc(0, (HDRVR)1, DRV_DISABLE, 0L, 0L);
		DriverProc(0, (HDRVR)1, DRV_FREE, 0L, 0L);
	    }
	}

	FreeLibrary((HMODULE) hDriver);
    }
}

#ifdef DEBUG_RETAIL

/************************************************************************

    messages.

************************************************************************/

struct {
    UINT  msg;
    char *szMsg;
}   aMsg[] = {

DRV_OPEN                        , "DRV_OPEN",
DRV_CLOSE                       , "DRV_CLOSE",
ICM_GETSTATE                    , "ICM_GETSTATE",
ICM_SETSTATE                    , "ICM_SETSTATE",
ICM_GETINFO                     , "ICM_GETINFO",
ICM_CONFIGURE                   , "ICM_CONFIGURE",
ICM_ABOUT                       , "ICM_ABOUT",
ICM_GETERRORTEXT                , "ICM_GETERRORTEXT",
ICM_GETFORMATNAME               , "ICM_GETFORMATNAME",
ICM_ENUMFORMATS                 , "ICM_ENUMFORMATS",
ICM_GETDEFAULTQUALITY           , "ICM_GETDEFAULTQUALITY",
ICM_GETQUALITY                  , "ICM_GETQUALITY",
ICM_SETQUALITY                  , "ICM_SETQUALITY",
ICM_COMPRESS_GET_FORMAT         , "ICM_COMPRESS_GET_FORMAT",
ICM_COMPRESS_GET_SIZE           , "ICM_COMPRESS_GET_SIZE",
ICM_COMPRESS_QUERY              , "ICM_COMPRESS_QUERY",
ICM_COMPRESS_BEGIN              , "ICM_COMPRESS_BEGIN",
ICM_COMPRESS                    , "ICM_COMPRESS",
ICM_COMPRESS_END                , "ICM_COMPRESS_END",
ICM_DECOMPRESS_GET_FORMAT       , "ICM_DECOMPRESS_GET_FORMAT",
ICM_DECOMPRESS_QUERY            , "ICM_DECOMPRESS_QUERY",
ICM_DECOMPRESS_BEGIN            , "ICM_DECOMPRESS_BEGIN",
ICM_DECOMPRESS                  , "ICM_DECOMPRESS",
ICM_DECOMPRESS_END              , "ICM_DECOMPRESS_END",
ICM_DECOMPRESS_SET_PALETTE      , "ICM_DECOMPRESS_SET_PALETTE",
ICM_DECOMPRESS_GET_PALETTE      , "ICM_DECOMPRESS_GET_PALETTE",
ICM_DECOMPRESSEX_QUERY          , "ICM_DECOMPRESSEX_QUERY",
ICM_DECOMPRESSEX_BEGIN          , "ICM_DECOMPRESSEX_BEGIN",
ICM_DECOMPRESSEX                , "ICM_DECOMPRESSEX",
ICM_DECOMPRESSEX_END            , "ICM_DECOMPRESSEX_END",
ICM_DRAW_QUERY                  , "ICM_DRAW_QUERY",
ICM_DRAW_BEGIN                  , "ICM_DRAW_BEGIN",
ICM_DRAW_GET_PALETTE            , "ICM_DRAW_GET_PALETTE",
ICM_DRAW_UPDATE                 , "ICM_DRAW_UPDATE",
ICM_DRAW_START                  , "ICM_DRAW_START",
ICM_DRAW_STOP                   , "ICM_DRAW_STOP",
ICM_DRAW_BITS                   , "ICM_DRAW_BITS",
ICM_DRAW_END                    , "ICM_DRAW_END",
ICM_DRAW_GETTIME                , "ICM_DRAW_GETTIME",
ICM_DRAW                        , "ICM_DRAW",
ICM_DRAW_WINDOW                 , "ICM_DRAW_WINDOW",
ICM_DRAW_SETTIME                , "ICM_DRAW_SETTIME",
ICM_DRAW_REALIZE                , "ICM_DRAW_REALIZE",
ICM_GETBUFFERSWANTED            , "ICM_GETBUFFERSWANTED",
ICM_GETDEFAULTKEYFRAMERATE      , "ICM_GETDEFAULTKEYFRAMERATE",
ICM_COMPRESS_FRAMES_INFO        , "ICM_COMPRESS_FRAMES_INFO",
ICM_COMPRESS_FRAMES             , "ICM_COMPRESS_FRAMES",
ICM_SET_STATUS_PROC             , "ICM_SET_STATUS_PROC",
ICM_ENUM_FORMATS                , "ICM_ENUM_FORMATS",
ICM_GET_FORMAT_NAME             , "ICM_GET_FORMAT_NAME",
0                               , NULL
};

struct {
    LRESULT err;
    char *szErr;
}   aErr[] = {

ICERR_DONTDRAW              , "ICERR_DONTDRAW",
ICERR_NEWPALETTE            , "ICERR_NEWPALETTE",
ICERR_UNSUPPORTED           , "ICERR_UNSUPPORTED",
ICERR_BADFORMAT             , "ICERR_BADFORMAT",
ICERR_MEMORY                , "ICERR_MEMORY",
ICERR_INTERNAL              , "ICERR_INTERNAL",
ICERR_BADFLAGS              , "ICERR_BADFLAGS",
ICERR_BADPARAM              , "ICERR_BADPARAM",
ICERR_BADSIZE               , "ICERR_BADSIZE",
ICERR_BADHANDLE             , "ICERR_BADHANDLE",
ICERR_CANTUPDATE            , "ICERR_CANTUPDATE",
ICERR_ERROR                 , "ICERR_ERROR",
ICERR_BADBITDEPTH           , "ICERR_BADBITDEPTH",
ICERR_BADIMAGESIZE          , "ICERR_BADIMAGESIZE",
ICERR_OK                    , "ICERR_OK"
};

static BOOL  fDebug = -1;
static DWORD dwTime;

void ICDebugMessage(HIC hic, UINT msg, DWORD dw1, DWORD dw2)
{
    int i;

    if (!fDebug)
	return;

    for (i=0; aMsg[i].msg && aMsg[i].msg != msg; i++)
	;

    if (aMsg[i].msg == 0)
	RPF(("ICM(%04X,ICM_%04X,%08lX,%08lX)", hic, msg, dw1, dw2));
    else
	RPF(("ICM(%04X,%s,%08lX,%08lX)", hic, (LPSTR)aMsg[i].szMsg, dw1, dw2));

    dwTime = timeGetTime();
}

LRESULT ICDebugReturn(LRESULT err)
{
    int i;

    if (!fDebug)
	return err;

    dwTime = timeGetTime() - dwTime;

    for (i=0; aErr[i].err && aErr[i].err != err; i++)
	;

    if (aErr[i].err != err)
	RPF(("! : 0x%08lX (%ldms)\r\n", err, dwTime));
    else
	RPF(("! : %s (%ldms)\r\n", (LPSTR)aErr[i].szErr, dwTime));

    return err;
}

static void ICDump()
{
    int i;
    PIC pic;
    char ach[80];

    DPF(("ICDump ---------------------------------------\r\n"));

    for (i=0; i<MAX_CONVERTERS; i++)
    {
	pic = &aicConverters[i];

	if (pic->fccType == 0)
	    continue;

	if (pic->dwSmag == 0)
	    continue;

	if (pic->hDriver)
	    GetModuleFileName(GetDriverModuleHandle (pic->hDriver), ach, sizeof(ach));
	else
	    ach[0] = 0;

	DPF(("  HIC: %04X %4.4s.%4.4s hTask=%04X Proc=%08lx %s\r\n", (HIC)pic, (LPSTR)&pic->fccType, (LPSTR)&pic->fccHandler, pic->hTask, pic->DriverProc, (LPSTR)ach));
    }

    DPF(("----------------------------------------------\r\n"));
}

#endif

/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * COMPMAN=1
 *
 ****************************************************************************/

#ifdef DEBUG_RETAIL

#define MODNAME "COMPMAN"

static void cdecl dprintfc(LPSTR szFormat, ...)
{
    char ach[128];

#ifdef WIN32
    va_list va;
    if (fDebug == -1)
	fDebug = GetProfileIntA("Debug",MODNAME, FALSE);

    if (!fDebug)
	return;

    va_start(va, szFormat);
    if (szFormat[0] == '!')
	ach[0]=0, szFormat++;
    else
	lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,va);
    va_end(va);
//  lstrcatA(ach, "\r\r\n");
#else
    if (fDebug == -1) {
        fDebug = GetProfileIntA("Debug",MODNAME, FALSE);
        switch (fDebug) {
            case -1:
                OutputDebugStringA("fDebug still set at -1\n");
                break;
            case 0:
                OutputDebugStringA("fDebug set to 0\n");
                break;
            case 1:
                OutputDebugStringA("fDebug set to 1\n");
                break;
            case 2:
                OutputDebugStringA("fDebug set to 2\n");
                break;
            default:
                OutputDebugStringA("fDebug set to something else\n");
        }
    }

    if (!fDebug)
	return;

    if (szFormat[0] == '!')
	ach[0]=0, szFormat++;
    else
	lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)(&szFormat+1));
    lstrcatA(ach, "\r\r\n");
#endif

    OutputDebugStringA(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman.16\icm.c ===
//////////////////////////////////////////////////////////////////////////////o
//
//  ICM.C
//
//      Helper routines for compressing/decompressing/and choosing compressors.
//
//      (C) Copyright Microsoft Corp. 1991, 1992, 1993.  All rights reserved.
//
//      You have a royalty-free right to use, modify, reproduce and
//      distribute the Sample Files (and/or any modified version) in
//      any way you find useful, provided that you agree that
//      Microsoft has no warranty obligations or liability for any
//      Sample Application Files.
//
//      If you did not get this from Microsoft Sources, then it may not be the
//      most current version.  This sample code in particular will be updated
//      and include more documentation.
//
//      Sources are:
//         CompuServe: WINSDK forum, MDK section.
//         Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>

#ifdef DEBUG
    static void CDECL dprintf(LPSTR, ...);
    #define DPF(x)  dprintf x
#else
    #define DPF(x)
#endif


//
// define these before compman.h, so are functions get declared right.
//
#ifndef WIN32
#define VFWAPI  FAR PASCAL _loadds
#define VFWAPIV FAR CDECL  _loadds
#endif

#include <vfw.h>
#include "icm.rc"

#define AVIStreamGetFrameOpen   XAVIStreamGetFrameOpen
#define AVIStreamGetFrame   XAVIStreamGetFrame
#define AVIStreamGetFrameClose  XAVIStreamGetFrameClose

HMODULE havifile;
PGETFRAME (STDAPICALLTYPE  *XAVIStreamGetFrameOpen)(PAVISTREAM pavi,
                     LPBITMAPINFOHEADER lpbiWanted);
LPVOID (STDAPICALLTYPE  *XAVIStreamGetFrame)(PGETFRAME pgf, LONG pos);
HRESULT (STDAPICALLTYPE  *XAVIStreamGetFrameClose)(PGETFRAME pgf);

#ifdef WIN32
extern HANDLE ghInst;
#else
extern HINSTANCE ghInst;
#endif

///////////////////////////////////////////////////////////////////////////////
//  DIB Macros
///////////////////////////////////////////////////////////////////////////////

#define WIDTHBYTES(i)           ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DibWidthBytes(lpbi)     (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)((lpbi)->biBitCount))

#define DibSizeImage(lpbi)      ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)(UINT)((lpbi)->biHeight))
#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))

#define DibPtr(lpbi)            (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed)
#define DibColors(lpbi)         ((LPRGBQUAD)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

// !!! Someday write this so you don't have to call ICCompressorChoose if you
// !!! know what you want.  Choose would then call this.
// InitCompress(pc, hic/fccHandler, lQuality, lKey, lpbiIn, lpbiOut)


/*****************************************************************************
 * @doc EXTERNAL COMPVARS ICAPPS
 *
 * @types COMPVARS | This structure describes
 *         compressor when using functions such as <f ICCompressorChoose>,
 *  <f ICSeqCompressFrame>, or <f ICCompressorFree>.
 *
 * @field LONG | cbSize | Set this to the size of this structure in bytes.
 *        This member must be set to validate the structure
 *        before calling any function using this structure.
 *
 * @field DWORD | dwFlags | Specifies the flags for this structure:
 *
 *   @flag ICMF_COMPVARS_VALID | Indicates this structure has valid data.
 *    Set this flag if you fill out this structure manually before
 *    calling any functions. Do not set this flag if you let
 *         <f ICCompressorChoose> initialize this structure.
 *
 * @field HIC | hic | Specifies the handle of the compressor to use.
 *  The <f ICCompressorChoose> function opens the chosen compressor and
 * returns the handle to the compressor in this
 *  member. The compressor is closed by <t ICCompressorFree>.
 *
 * @field DWORD | fccType | Specifies the type of compressor being used.
 *        Currently only ICTYPE_VIDEO is supported. This can be set to zero.
 *
 * @field DWORD | fccHandler | Specifies the four-character code
 *       of the compressor. NULL indicates the data is not
 *       to be recompressed and and 'DIB ' indicates the data is full framed
 *       (uncompressed). You can use this member to specify which
 *        compressor is selected by default when the dialog box is
 *       displayed.
 *
 * @field LPBITMAPINFO | lpbiIn | Specifies the input format. Used internally.
 *
 * @field LPBITMAPINFO | lpbiOut | Specifies the output format. Ths member
 *        is set by <f ICCompressorChoose>. The <f ICSeqCompressFrameStart>
 *        function uses this member to determine the compressed output format.
 *        If you do not want to use the default format, specify
 *        the preferred one.
 *
 * @field LPVOID | lpBitsOut | Used internally for compression.
 *
 * @field LPVOID | lpBitsPrev | Used internally for temporal compression.
 *
 * @field LONG | lFrame | Used internally to count the number of frames
 *  compressed in a sequence.
 *
 * @field LONG | lKey | Set by <f ICCompressorChoose> to indicate the key frame
 *  rate selected in the dialog box.  The also specifies the rate that
 *  <f ICSeqCompressFrameStart> uses for making key frames.
 *
 * @field LONG | lDataRate | Set by <f ICCompressorChoose> to indicate the
 *  data rate selected in the dialog box. The units are kilobytes per second.
 *
 * @field LONG | lQ | Set by <f ICCompressChoose> to indicate the quality
 *  selected in the dialog box.  This also specifies the quality
 *  <f ICSeqCompressFrameStart> will use. ICQUALITY_DEFAULT specifies
 *  default quality.
 *
 * @field LONG | lKeyCount | Used internally to count key frames.
 *
 * @field LPVOID | lpState | Set by <f ICCompressorChoose> to the state selected
 *  in the configuration dialog box for the compressor. The system
 * uses this information to restore the state of the dialog box if
 * it is redisplayed. Used internally.
 *
 * @field LONG | cbState | Used internally for the size of the state information.
 *
 ***************************************************************************/
/*******************************************************************
* @doc EXTERNAL ICCompressorFree ICAPPS
*
* @api void | ICCompressorFree | This function frees the resources
*   in the <t COMPVARS> structure used by other IC functions.
*
* @parm PCOMPVARS | pc | Specifies a pointer to the <t COMPVARS>
*       structure containing the resources to be freed.
*
* @comm After using the <f ICCompressorChoose>, <f ICSeqCompressFrameStart>,
*       <f ICSeqCompressFrame>, and <f ICSeqCompressFrameEnd> functions, call
*       this function to release the resources in the <t COMPVARS> structure.
*
* @xref <f ICCompressChoose> <f ICSeqCompressFrameStart> <f ICSeqCompressFrame>
*   <f ICSeqCompressFrameEnd>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorFree
//
///////////////////////////////////////////////////////////////////////////////
void VFWAPI ICCompressorFree(PCOMPVARS pc)
{
    /* We were passed an invalid COMPPARMS */
    if (pc == NULL || pc->cbSize != sizeof(COMPVARS))
        return;

    // This function frees every thing in the structure (excuse my
    // french).

    /* Close the compressor */
    if (pc->hic) {
    ICClose(pc->hic);
    pc->hic = NULL;
    }

    /* Free the output format */
    if (pc->lpbiOut) {
    GlobalFreePtr(pc->lpbiOut);
    pc->lpbiOut = NULL;
    }

    /* Free the buffer for compressed image */
    if (pc->lpBitsOut) {
    GlobalFreePtr(pc->lpBitsOut);
    pc->lpBitsOut = NULL;
    }

    /* Free the buffer for the decompressed previous frame */
    if (pc->lpBitsPrev) {
    GlobalFreePtr(pc->lpBitsPrev);
    pc->lpBitsPrev = NULL;
    }

    /* Free the compressor state buffer */
    if (pc->lpState) {
    GlobalFreePtr(pc->lpState);
    pc->lpState = NULL;
    }

    /* This structure is no longer VALID */
    pc->dwFlags = 0;
}

/*******************************************************************
* @doc EXTERNAL ICSeqCompressFrameStart ICAPPS
*
* @api BOOL | ICSeqCompressFrameStart | This function initializes the system
*   prior to using <f ICSeqCompressFrame>.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS> structure
*       initialized with information for compression.
*
* @parm LPBITMAPINFO | lpbiIn | Specifies the format of the data to be
*       compressed.
*
* @rdesc Returns TRUE if successful; otherwise it returns FALSE.
*
* @comm Prior to using this function, use <f ICCompressorChoose> to let the
*       user specify a compressor, or initialize a <t COMPVARS> structure
*       manually. Use <f ICSeqCompressFrameStart>, <f ICSeqCompressFrame>
*       and <f ICSeqCompressFrameEnd> to compress a sequence of
*       frames to a specified data rate and number of key frames.
*       When finished comressing data, use
*       <f ICCompressorFree> to release the resources
*       specified in the <t COMPVARS> structure.
*
*       If you do not use <f ICCompressorChoose> you must
*       initialize the following members of the <t COMPVARS> structure:
*
*   <e COMPVARS.cbSize> Set to the sizeof(COMPVARS) to validate the structure.
*
*   <e COMPVARS.hic> Set to the handle of a compressor you have opened with
*       <f ICOpen>. You do not need to close it (<f ICCompressorFree>
*       will do this for you).
*
*   <e COMPVARS.lpbiOut> Optionally set this to force the compressor
*       to compress to a specific format instead of the default.
*       This will be freed by <f ICCompressorFree>.
*
*   <e COMPVARS.lKey> Set this to the key-frame frequency you want
*     or zero for none.
*
*   <e COMPVARS.lQ> Set this to the quality level to use or ICQUALITY_DEFAULT.
*
*   <e COMPVARS.dwFlags> Set ICMF_COMPVARS_VALID flag to indicate the structure is initialized.
*
* @xref <f ICCompressorChoose> <f ICSeqCompressFrame> <f ICSeqCompressFrameEnd>
*   <f ICCompressorFree>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICSeqCompressFrameStart
//
///////////////////////////////////////////////////////////////////////////////
BOOL VFWAPI ICSeqCompressFrameStart(PCOMPVARS pc, LPBITMAPINFO lpbiIn)
{
    DWORD       dwSize;
    ICINFO  icinfo;

    if (pc == NULL || pc->cbSize != sizeof(COMPVARS))
        return FALSE;

    if (pc->hic == NULL || lpbiIn == NULL)
        return FALSE;

    //
    // make sure the found compressor can handle something
    // if not, force back to the default setting
    //
    if (ICCompressQuery(pc->hic, lpbiIn, pc->lpbiOut) != ICERR_OK) {
        // If the input format has changed since the output was selected,
        // force a reinitialization of the output format
        if (pc->lpbiOut) {
            GlobalFreePtr (pc->lpbiOut);
            pc->lpbiOut = NULL;
        }
    }

    //
    // fill in defaults: key frame every frame, and default quality
    //
    if (pc->lKey < 0)
        pc->lKey = 1;

    if (pc->lQ == ICQUALITY_DEFAULT)
        pc->lQ = ICGetDefaultQuality(pc->hic);

    //
    // If no output format is given, use a default
    //
    if (pc->lpbiOut == NULL) {
    dwSize = ICCompressGetFormatSize(pc->hic, lpbiIn);
    if (!(pc->lpbiOut = (LPBITMAPINFO)GlobalAllocPtr(GMEM_MOVEABLE,dwSize)))
        goto StartError;
    ICCompressGetFormat(pc->hic, lpbiIn, pc->lpbiOut);
    }
    pc->lpbiOut->bmiHeader.biSizeImage =
        ICCompressGetSize (pc->hic, lpbiIn, pc->lpbiOut);
    pc->lpbiOut->bmiHeader.biClrUsed = DibNumColors(&(pc->lpbiOut->bmiHeader));

    //
    // Set the input format and initialize the key frame count
    //
    pc->lpbiIn = lpbiIn;
    pc->lKeyCount = pc->lKey;
    pc->lFrame = 0;     // first frame we'll be compressing is 0

    if (ICCompressQuery(pc->hic, lpbiIn, pc->lpbiOut) != ICERR_OK)
        goto StartError;

    //
    // Allocate a buffer for the compressed bits
    //
    dwSize = pc->lpbiOut->bmiHeader.biSizeImage;

    // !!! Hack for VidCap... make it big enough for two RIFF structs and
    // !!! pad records.
    //
    dwSize += 2048 + 16;

    if (!(pc->lpBitsOut = GlobalAllocPtr(GMEM_MOVEABLE, dwSize)))
        goto StartError;

    //
    // Allocate a buffer for the decompressed previous frame if it can do
    // key frames and we want key frames and it needs such a buffer.
    //
    ICGetInfo(pc->hic, &icinfo, sizeof(icinfo));
    if ((pc->lKey != 1) && (icinfo.dwFlags & VIDCF_TEMPORAL) &&
        !(icinfo.dwFlags & VIDCF_FASTTEMPORALC)) {
        dwSize = lpbiIn->bmiHeader.biSizeImage;
        if (!(pc->lpBitsPrev = GlobalAllocPtr(GMEM_MOVEABLE, dwSize)))
            goto StartError;
    }

    //
    // now get compman ready for the big job
    //
    if (ICCompressBegin(pc->hic, lpbiIn, pc->lpbiOut) != ICERR_OK)
        goto StartError;

    //
    // Get ready to decompress previous frames if we're doing key frames
    // If we can't decompress, we must do all key frames
    //
    if (pc->lpBitsPrev) {
        if (ICDecompressBegin(pc->hic, pc->lpbiOut, lpbiIn) != ICERR_OK) {
        pc->lKey = pc->lKeyCount = 1;
        GlobalFreePtr(pc->lpBitsPrev);
        pc->lpBitsPrev = NULL;
    }
    }

    return TRUE;

StartError:

    // !!! Leave stuff allocated because ICCompressorFree() will clear things
    return FALSE;
}

/*******************************************************************
* @doc EXTERNAL ICSeqCompressFrameEnd ICAPPS
*
* @api void | ICSeqCompressFrameEnd | This function terminates sequence
*   compression using <f ICSeqCompressFrame>.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS> structure
*       used during sequence compression.
*
* @comm Use <f ICCompressorChoose> to let the
*       user specify a compressor to use, or initialize a <t COMPVARS> structure
*       manually. Use <f ICSeqCompressFrameStart>, <f ICSeqCompressFrame>
*       and <f ICSeqCompressFrameEnd> functions to compress a sequence of
*       frames to a specified data rate and number of key frames. When
*       finished with compression, use <f ICCompressorFree> to
*       release the resources specified by the <t COMPVARS> structure.
*
* @xref <f ICCompressorChoose> <f ICSeqCompressFrame> <f ICCompressorFree>
*   <f ICSeqCompressFrameStart>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICSeqCompressFrameEnd
//
///////////////////////////////////////////////////////////////////////////////
void VFWAPI ICSeqCompressFrameEnd(PCOMPVARS pc)
{
    if (pc == NULL || pc->cbSize != sizeof(COMPVARS))
        return;

    // This function still leaves pc->hic and pc->lpbiOut alloced and open
    // since they were set by ICCompressorChoose

    // Seems we've already freed everything - don't call ICCompressEnd twice
    if (pc->lpBitsOut == NULL)
        return;

    /* Stop compressing */
    if (pc->hic) {
        ICCompressEnd(pc->hic);

        if (pc->lpBitsPrev)
            ICDecompressEnd(pc->hic);
    }

    /* Free the buffer for compressed image */
    if (pc->lpBitsOut) {
    GlobalFreePtr(pc->lpBitsOut);
    pc->lpBitsOut = NULL;
    }

    /* Free the buffer for the decompressed previous frame */
    if (pc->lpBitsPrev) {
    GlobalFreePtr(pc->lpBitsPrev);
    pc->lpBitsPrev = NULL;
    }
}

/*******************************************************************
* @doc EXTERNAL ICSeqCompressFrame ICAPPS
*
* @api LPVOID | ICSeqCompressFrame | This function compresses a
*  frame in a sequence of frames. The data rate for the sequence
*  as well as the key-frame frequency can be specified. Use this function
*  once for each frame to be compressed.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS> structure
*       initialized with information about the compression.
*
* @parm UINT | uiFlags | Specifies flags for this function. Set this
*       parameter to zero.
*
* @parm LPVOID | lpBits | Specifies a pointer the data bits to compress.
*       (The data bits excludes header or format information.)
*
* @parm BOOL FAR * | pfKey | Returns whether or not the frame was compressed
*       into a keyframe.
*
* @parm LONG FAR * | plSize | Specifies the maximum size desired for
*       the compressed image. The compressor might not be able to
*       compress the data to within this size. When the function
*       returns, the parameter points to the size of the compressed
*       image. Images sizes are specified in bytes.
*
* @rdesc Returns a pointer to the compressed bits.
*
* @comm Use <f ICCompressorChoose> to let the
*       user specify a compressor to use, or initialize a <t COMPVARS> structure
*       manually. Use <f ICSeqCompressFrameStart>, <f ICSeqCompressFrame>
*       and <f ICSeqCompressFrameEnd> functions to compress a sequence of
*       frames to a specified data rate and number of key frames. When
*       finished with compression, use <f ICCompressorFree> to
*       release the resources specified by the <t COMPVARS> structure.
*
*   Use this function repeatedly to compress a video sequence one
*  frame at a time. Use this function instead of <f ICCompress>
*  to compress a video sequence. This function supports creating key frames
*   in the compressed sequence at any frequency you like and handles
*  much of the initialization process.
* @xref <f ICCompressorChoose> <f ICSeqCompressFrameEnd> <f ICCompressorFree>
*   <f ICCompressorFreeStart>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICSeqCompressFrame
//
//      compresses a given image but supports KEY FRAMES EVERY
//
//  input:
//      pc          stuff
//      uiFlags     flags (not used, must be 0)
//      lpBits      input DIB bits
//      lQuality    the reqested compression quality
//      pfKey       did this frame end up being a key frame?
//
//  returns:
//      a HANDLE to the converted image.  The handle is a DIB in CF_DIB
//      format, ie a packed DIB.  The caller is responsible for freeing
//      the memory.   NULL is returned if error.
//
///////////////////////////////////////////////////////////////////////////////
LPVOID VFWAPI ICSeqCompressFrame(
    PCOMPVARS               pc,         // junk set up by Start()
    UINT                    uiFlags,    // flags
    LPVOID                  lpBits,     // input DIB bits
    BOOL FAR            *pfKey, // did it end up being a key frame?
    LONG FAR            *plSize)    // requested size/size of returned image
{
    LONG    l;
    DWORD   dwFlags = 0;
    DWORD   ckid = 0;
    BOOL    fKey;
    LONG    lSize = plSize ? *plSize : 0;

    // Is it time to make a keyframe?
    // First frame will always be a keyframe cuz they initialize to the same
    // value.
    fKey = (pc->lKeyCount >= pc->lKey);

    l = ICCompress(pc->hic,
            fKey ? ICCOMPRESS_KEYFRAME : 0,   // flags
            (LPBITMAPINFOHEADER)pc->lpbiOut,    // output format
            pc->lpBitsOut,  // output data
            (LPBITMAPINFOHEADER)pc->lpbiIn,     // format of frame to compress
            lpBits,         // frame data to compress
            &ckid,          // ckid for data in AVI file
            &dwFlags,       // flags in the AVI index.
            pc->lFrame,     // frame number of seq.
            lSize,          // reqested size in bytes. (if non zero)
            pc->lQ,         // quality
            fKey ? NULL : (LPBITMAPINFOHEADER)pc->lpbiIn, // fmt of prev frame
            fKey ? NULL : pc->lpBitsPrev);        // previous frame

    if (l < ICERR_OK)
        goto FrameError;

    /* Return the size of the compressed data */
    if (plSize)
    *plSize = pc->lpbiOut->bmiHeader.biSizeImage;

    /* Now decompress the frame into our buffer for the previous frame */
    if (pc->lpBitsPrev) {
    l = ICDecompress(pc->hic,
         0,
         (LPBITMAPINFOHEADER)pc->lpbiOut,
         pc->lpBitsOut,
                 (LPBITMAPINFOHEADER)pc->lpbiIn,  // !!! should check for this.
         pc->lpBitsPrev);

    if (l != ICERR_OK)
        goto FrameError;
    }

    /* Was the compressed image a keyframe? */
    *pfKey = (BOOL)(dwFlags & AVIIF_KEYFRAME);

    /* After making a keyframe, reset our counter that tells us when we MUST */
    /* make another one.    */
    if (*pfKey)
    pc->lKeyCount = 0;

    // Never make a keyframe again after the first one if we don't want them.
    // Increment our counter of how long its been since the last one if we do.
    if (pc->lKey)
        pc->lKeyCount++;
    else
    pc->lKeyCount = -1;

    // Next time we're called we're on the next frame
    pc->lFrame++;

    return (pc->lpBitsOut);

FrameError:

    return NULL;
}


/*******************************************************************
* @doc EXTERNAL ICImageCompress ICAPPS
*
* @api HANDLE | ICImageCompress | This function provides
*  convenient method of compressing an image to a given
*   size. This function does not require use of initialization functions.
*
* @parm HIC | hic | Specifies the handle to a compressor to be
*       opened with <f ICOpen> or NULL.  Use NULL to choose a
*       default compressor for your compression format.
*       Applications can use the compressor handle returned
*       by <f ICCompressorChoose> in the <e COMPVARS.hic> member
*       of the <t COMPVARS> structure if they want the user to
*       select the compressor.  This compressor is already opened.
*
* @parm UINT | uiFlags | Specifies flags for this function.  Set this
*       to zero.
*
* @parm LPBITMAPINFO | lpbiIn | Specifies the input data format.
*
* @parm LPVOID | lpBits | Specifies a pointer to input data bits to compress.
*       (The data bits exclude header or format information.)
*
* @parm LPBITMAPINFO | lpbiOut | Specifies the compressed output format or NULL.
*       If NULL, the compressor uses a default format.
*
* @parm LONG | lQuality | Specifies the quality value the compressor.
*
* @parm LONG FAR * | plSize | Specifies the maximum size desired for
*       the compressed image. The compressor might not be able to
*       compress the data to within this size. When the function
*       returns, the parameter points to the size of the compressed
*       image. Images sizes are specified in bytes.
*
*
* @rdesc Returns a handle to a compressed DIB. The image data follows the
*        format header.
*
* @comm This function returns a DIB with the format and image data.
*  To obtain the format information from the <t LPBITMAPINFOHEADER> structure,
*  use <f GlobalLock> to lock the data. Use <f GlobalFree> to free the
*  DIB when you have finished with it.
*
* @xref <f ICImageDecompress>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICImageCompress
//
//      compresses a given image.
//
//  input:
//      hic         compressor to use, if NULL is specifed a
//                  compressor will be located that can handle the conversion.
//      uiFlags     flags (not used, must be 0)
//      lpbiIn      input DIB format
//      lpBits      input DIB bits
//      lpbiOut     output format, if NULL is specifed the default
//                  format choosen be the compressor will be used.
//      lQuality    the reqested compression quality
//      plSize      the reqested size for the image/returned size
//
//  returns:
//      a handle to a DIB which is the compressed image.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE VFWAPI ICImageCompress(
    HIC                     hic,        // compressor (NULL if any will do)
    UINT                    uiFlags,    // flags
    LPBITMAPINFO        lpbiIn,     // input DIB format
    LPVOID                  lpBits,     // input DIB bits
    LPBITMAPINFO        lpbiOut,    // output format (NULL => default)
    LONG                    lQuality,   // the reqested quality
    LONG FAR *          plSize)     // requested size for compressed frame
{
    LONG    l;
    BOOL    fNuke;
    DWORD   dwFlags = 0;
    DWORD   ckid = 0;
    LONG    lSize = plSize ? *plSize : 0;

    LPBITMAPINFOHEADER lpbi=NULL;

    //
    // either locate a compressor or use the one supplied.
    //
    if (fNuke = (hic == NULL))
    {
        hic = ICLocate(ICTYPE_VIDEO, 0L, (LPBITMAPINFOHEADER)lpbiIn,
        (LPBITMAPINFOHEADER)lpbiOut, ICMODE_COMPRESS);

        if (hic == NULL)
            return NULL;
    }

    //
    // make sure the found compressor can compress something ??? WHY BOTHER ???
    //
    if (ICCompressQuery(hic, lpbiIn, NULL) != ICERR_OK)
        goto error;

    if (lpbiOut)
    {
    l = lpbiOut->bmiHeader.biSize + 256 * sizeof(RGBQUAD);
    }
    else
    {
    //
    //  now make a DIB header big enough to hold the output format
    //
    l = ICCompressGetFormatSize(hic, lpbiIn);

    if (l <= 0)
        goto error;
    }

    lpbi = (LPVOID)GlobalAllocPtr(GHND, l);

    if (lpbi == NULL)
        goto error;

    //
    //  if the compressor likes the passed format, use it else use the default
    //  format of the compressor.
    //
    if (lpbiOut == NULL || ICCompressQuery(hic, lpbiIn, lpbiOut) != ICERR_OK)
        ICCompressGetFormat(hic, lpbiIn, lpbi);
    else
        hmemcpy(lpbi, lpbiOut, lpbiOut->bmiHeader.biSize +
        lpbiOut->bmiHeader.biClrUsed * sizeof(RGBQUAD));

    lpbi->biSizeImage = ICCompressGetSize(hic, lpbiIn, lpbi);
    lpbi->biClrUsed = DibNumColors(lpbi);

    //
    // now resize the DIB to be the maximal size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi,DibSize(lpbi), 0);

    if (lpbi == NULL)
        goto error;

    //
    // now compress it.
    //
    if (ICCompressBegin(hic, lpbiIn, lpbi) != ICERR_OK)
        goto error;

    if (lpBits == NULL)
        lpBits = DibPtr((LPBITMAPINFOHEADER)lpbiIn);

    if (lQuality == ICQUALITY_DEFAULT)
        lQuality = ICGetDefaultQuality(hic);

    l = ICCompress(hic,
            0,              // flags
            (LPBITMAPINFOHEADER)lpbi,  // output format
            DibPtr(lpbi),   // output data
            (LPBITMAPINFOHEADER)lpbiIn,// format of frame to compress
            lpBits,         // frame data to compress
            &ckid,          // ckid for data in AVI file
            &dwFlags,       // flags in the AVI index.
            0,              // frame number of seq.
            lSize,          // requested size in bytes. (if non zero)
            lQuality,       // quality
            NULL,           // format of previous frame
            NULL);          // previous frame

    if (l < ICERR_OK) {
    DPF(("ICCompress returned %ld!\n", l));
        ICCompressEnd(hic);
        goto error;
    }

    // Return the size of the compressed data
    if (plSize)
    *plSize = lpbi->biSizeImage;

    if (ICCompressEnd(hic) != ICERR_OK)
        goto error;

    //
    // now resize the DIB to be the real size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi, DibSize(lpbi), 0);

    //
    // all done return the result to the caller
    //
    if (fNuke)
        ICClose(hic);

    return GlobalPtrHandle(lpbi);

error:
    if (lpbi)
        GlobalFreePtr(lpbi);

    if (fNuke)
        ICClose(hic);

    return NULL;
}
/*******************************************************************
*
* @doc EXTERNAL ICImageDecompress ICAPPS
*
* @api HANDLE | ICImageDecompress | This function provides
*  convenient method of decompressing an image without
*   using initialization functions.
**
* @parm HIC | hic | Specifies the handle to a decompressor opened
*       with <f ICOpen> or NULL.  Use NULL to choose a default
*       decompressor for your format.
*
* @parm UINT | uiFlags | Specifies flags for this function.  Set this
*       to zero.
*
* @parm LPBITMAPINFO | lpbiIn | Specifies the compressed input data format.
*
* @parm LPVOID | lpBits | Specifies a pointer to input data bits to compress.
*       (The data bits excludes header or format information.)
*
* @parm LPBITMAPINFO | lpbiOut | Specifies the decompressed output format or NULL.
*       If NULL, the decompressor uses  a default format.
*
* @rdesc Returns a handle to an uncompressed DIB in the CF_DIB format,
*        or NULL for an error. The image data follows the format header.
*
* @comm This function returns a DIB with the format and image data.
*  To obtain the format information from the <t LPBITMAPINFOHEADER> structure,
*  use <f GlobalLock> to lock the data. Use <f GlobalFree> to free the
*  DIB when you have finished with it.
*

* @xref <f ICImageCompress>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICImageDecompress
//
//      decompresses a given image.
//
//  input:
//      hic         compressor to use, if NULL is specifed a
//                  compressor will be located that can handle the conversion.
//      uiFlags     flags (not used, must be 0)
//      lpbiIn      input DIB format
//      lpBits      input DIB bits
//      lpbiOut     output format, if NULL is specifed the default
//                  format choosen be the compressor will be used.
//
//  returns:
//      a HANDLE to the converted image.  The handle is a DIB in CF_DIB
//      format, ie a packed DIB.  The caller is responsible for freeing
//      the memory.   NULL is returned if error.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE VFWAPI ICImageDecompress(
    HIC                     hic,        // compressor (NULL if any will do)
    UINT                    uiFlags,    // flags
    LPBITMAPINFO            lpbiIn,     // input DIB format
    LPVOID                  lpBits,     // input DIB bits
    LPBITMAPINFO            lpbiOut)    // output format (NULL => default)
{
    LONG    l;
    BOOL    fNuke;
    DWORD   dwFlags = 0;
    DWORD   ckid = 0;

    LPBITMAPINFOHEADER lpbi=NULL;

    //
    // either locate a compressor or use the one supplied.
    //
    if (fNuke = (hic == NULL))
    {
        hic = ICLocate(ICTYPE_VIDEO, 0L, (LPBITMAPINFOHEADER)lpbiIn,
        (LPBITMAPINFOHEADER)lpbiOut, ICMODE_DECOMPRESS);

        if (hic == NULL)
            return NULL;
    }

    //
    // make sure the found compressor can decompress at all ??? WHY BOTHER ???
    //
    if (ICDecompressQuery(hic, lpbiIn, NULL) != ICERR_OK)
        goto error;

    if (lpbiOut)
    {
    l = lpbiOut->bmiHeader.biSize + 256 * sizeof(RGBQUAD);
    }
    else
    {
    //
    //  now make a DIB header big enough to hold the output format
    //
    l = ICDecompressGetFormatSize(hic, lpbiIn);

    if (l <= 0)
        goto error;
    }

    lpbi = (LPVOID)GlobalAllocPtr(GHND, l);

    if (lpbi == NULL)
        goto error;

    //
    //  if we didn't provide an output format, use a default.
    //
    if (lpbiOut == NULL)
        ICDecompressGetFormat(hic, lpbiIn, lpbi);
    else
        hmemcpy(lpbi, lpbiOut, lpbiOut->bmiHeader.biSize +
        lpbiOut->bmiHeader.biClrUsed * sizeof(RGBQUAD));

    //
    // For decompress make sure the palette (ie color table) is correct
    // just in case they provided an output format and the decompressor used
    // that format but not their palette.
    //
    if (lpbi->biBitCount <= 8)
        ICDecompressGetPalette(hic, lpbiIn, lpbi);

    lpbi->biSizeImage = DibSizeImage(lpbi); // ICDecompressGetSize(hic, lpbi);
    lpbi->biClrUsed = DibNumColors(lpbi);

    //
    // now resize the DIB to be the right size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi,DibSize(lpbi),0);

    if (lpbi == NULL)
        goto error;

    //
    // now decompress it.
    //
    if (ICDecompressBegin(hic, lpbiIn, lpbi) != ICERR_OK)
        goto error;

    if (lpBits == NULL)
        lpBits = DibPtr((LPBITMAPINFOHEADER)lpbiIn);

    l = ICDecompress(hic,
            0,              // flags
            (LPBITMAPINFOHEADER)lpbiIn, // format of frame to decompress
            lpBits,         // frame data to decompress
            (LPBITMAPINFOHEADER)lpbi,   // output format
            DibPtr(lpbi));  // output data

    if (l < ICERR_OK) {
    ICDecompressEnd(hic);
        goto error;
    }

    if (ICDecompressEnd(hic) != ICERR_OK)
        goto error;

    //
    // now resize the DIB to be the real size.
    //
    lpbi = (LPVOID)GlobalReAllocPtr(lpbi,DibSize(lpbi),0);

    //
    // all done return the result to the caller
    //
    if (fNuke)
        ICClose(hic);

    return GlobalPtrHandle(lpbi);

error:
    if (lpbi)
        GlobalFreePtr(lpbi);

    if (fNuke)
        ICClose(hic);

    return NULL;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorChooseStuff
//
///////////////////////////////////////////////////////////////////////////////

BOOL VFWAPI ICCompressorChooseDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

typedef struct {
    DWORD       fccType;
    DWORD       fccHandler;
    UINT        uiFlags;
    LPVOID      pvIn;
    LPVOID      lpData;
    HWND    hwnd;
    HIC         hic;
    LONG        lQ;
    LONG        lKey;
    LONG        lDataRate;
    ICINFO      icinfo;
    LPSTR       lpszTitle;
    PAVISTREAM  pavi;
    AVISTREAMINFO info;
    HDRAWDIB    hdd;
    PGETFRAME   pgf;
    LPVOID  lpState;
    LONG    cbState;
    BOOL    fClosing;
} ICCompressorChooseStuff, FAR *PICCompressorChooseStuff;

/*******************************************************************
* @doc EXTERNAL ICCompressorChoose ICAPPS
*
* @api BOOL | ICCompressorChoose | Displays a dialog box for choosing a
*   compressor. It optionally provides a data rate box, key frame box, preview
*   window, and filtering to display only compressors that can handle a
*   specific format.
*
* @parm HWND | hwnd | Specifies the parent window for the dialog box.
*
* @parm UINT | uiFlags | Specifies flags for this function. The following
*      flags are defined:
*
* @flag ICMF_CHOOSE_KEYFRAME | Displays a check box and edit box to enter the
*   frequency of key frames.
*
* @flag ICMF_CHOOSE_DATARATE | Displays a check box and edit box to enter the
*   data rate for the movie.
*
* @flag ICMF_CHOOSE_PREVIEW | Displays a button to expand the dialog box to
*        include a preview window. The preview window shows how
*       frames of your movie will appear when compressed with the
*       current settings.
*
* @flag ICMF_CHOOSE_ALLCOMPRESSORS | Indicates all compressors should
*       should appear in the selection list. If this flag is not specified,
*       just the compressors that can handle the input format appear in
*       the selection list.
*
* @parm LPVOID | pvIn | Specifies the uncompressed
*       data input format. This parameter is optional.
*
* @parm LPVOID | lpData | Specifies a <t PAVISTREAM> of type
*       streamtypeVIDEO to use in the preview window. This parameter
*       is optional.
*
* @parm PCOMPVARS | pc | Specifies a pointer to a <t COMPVARS>
*      structure. The information returned initializes the
*      structure for use with other functions.
*
* @parm LPSTR | lpszTitle | Points to a optional zero-terminated string
*       containing a title for the dialog box.
*
* @rdesc Returns TRUE if the user chooses a compressor, and presses OK.  Returns
*   FALSE for an error, or if the user presses CANCEL.
*
* @comm This function lets the user select a compressor from a list.
*   Before using it, set the <e COMPVARS.cbSize> member of the <t COMPVARS>
*  structure to sizeof(COMPVARS). Initialize the rest of the structure
*  to zeros unless you want to specify some valid defaults for
*   the dialog box. If specifing defaults, set the <e COMPVARS.dwFlags>
*   member to ICMF_COMPVARS_VALID, and initialize the other members of
*  the structure. See <f ICSeqCompressorFrameStart> and <t COMPVARS>
*  for more information about initializing the structure.
*
* @xref <f ICCompressorFree> <f ICSeqCompressFrameStart> <f ICSeqCompressFrame>
*   <f ICSeqCompressFrameEnd>
*
*******************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorChoose
//
//      Brings up a dialog and allows the user to choose a compression
//      method and a quality level, and/or a key frame frequency.
//  All compressors in the system are displayed or can be optionally
//  filtered by "ability to compress" a specifed format.
//
//      the dialog allows the user to configure or bring up the compressors
//      about box.
//
//      A preview window can be provided to show a preview of a specific
//      compression.
//
//      the selected compressor is opened (via ICOpen) and returned to the
//      caller, it must be disposed of by calling ICCompressorFree.
//
//  input:
//      HWND    hwnd            parent window for dialog box.
//      UINT    uiFlags         flags
//      LPVOID  pvIn            input format (optional), only compressors that
//              handle this format will be displayed.
//      LPVOID  pavi            input stream for the options preview
//      PCOMPVARS pcj           returns COMPVARS struct for use with other APIs
//      LPSTR   lpszTitle   Optional title for dialog box
//
//  returns:
//      TRUE if dialog shown and user chose a compressor.
//      FALSE if dialog was not shown or user hit cancel.
//
///////////////////////////////////////////////////////////////////////////////

BOOL VFWAPI ICCompressorChoose(
    HWND        hwnd,               // parent window for dialog
    UINT        uiFlags,            // flags
    LPVOID      pvIn,               // input format (optional)
    LPVOID      pavi,               // input stream (for preview - optional)
    PCOMPVARS   pcj,                // state of compressor/dlg
    LPSTR       lpszTitle)          // dialog title (if NULL, use default)
{
    BOOL f;
    PICCompressorChooseStuff p;
    DWORD   dwSize;

    if (pcj == NULL || pcj->cbSize != sizeof(COMPVARS))
        return FALSE;

    //
    // !!! Initialize the structure
    //
    if (!(pcj->dwFlags & ICMF_COMPVARS_VALID)) {
        pcj->hic = NULL;
        pcj->fccType = 0;
        pcj->fccHandler = 0;
        pcj->lQ = ICQUALITY_DEFAULT;
        pcj->lKey = 1;
        pcj->lDataRate = 0;
        pcj->lpbiOut = NULL;
        pcj->lpBitsOut = NULL;
        pcj->lpBitsPrev = NULL;
        pcj->dwFlags = 0;
        pcj->lpState = NULL;
        pcj->cbState = 0;
    }

    // Default type is a video compressor
    if (pcj->fccType == 0)
        pcj->fccType = ICTYPE_VIDEO;

    p = (LPVOID)GlobalAllocPtr(GHND, sizeof(ICCompressorChooseStuff));

    if (p == NULL)
        return FALSE;

    p->fccType    = pcj->fccType;
    p->fccHandler = pcj->fccHandler;
    p->uiFlags    = uiFlags;
    p->pvIn       = pvIn;
    p->lQ         = pcj->lQ;
    p->lKey       = pcj->lKey;
    p->lDataRate  = pcj->lDataRate;
    p->lpszTitle  = lpszTitle;
    p->pavi       = (PAVISTREAM)pavi;
    p->hdd        = NULL;
    p->lpState    = pcj->lpState;
    pcj->lpState = NULL;    // so it won't be freed
    p->cbState    = pcj->cbState;
    // !!! Validate this pointer
    // !!! AddRef if it is
    if (p->pavi) {
        if (p->pavi->lpVtbl->Info(p->pavi, &p->info, sizeof(p->info)) !=
        AVIERR_OK || p->info.fccType != streamtypeVIDEO)
        p->pavi = NULL;
    }

    f = DialogBoxParam(ghInst, TEXT("ICCDLG"),
        hwnd, (DLGPROC)ICCompressorChooseDlgProc, (LPARAM)(LPVOID)p);

    // !!! Treat error like cancel
    if (f == -1)
    f = FALSE;

    //
    // if the user picked a compressor then return this info to the caller
    //
    if (f) {

    // If we are called twice in a row, we have good junk in here that
    // needs to be freed before we tromp over it.
    ICCompressorFree(pcj);

        pcj->lQ = p->lQ;
        pcj->lKey = p->lKey;
        pcj->lDataRate = p->lDataRate;
        pcj->hic = p->hic;
        pcj->fccHandler = p->fccHandler;
        pcj->lpState = p->lpState;
        pcj->cbState = p->cbState;

    pcj->dwFlags |= ICMF_COMPVARS_VALID;
    }

    GlobalFreePtr(p);

    if (!f)
    return FALSE;

    if (pcj->hic && pvIn) {  // hic is NULL if no compression selected

        /* Get the format we're going to compress into. */
        dwSize = ICCompressGetFormatSize(pcj->hic, pvIn);
        if ((pcj->lpbiOut =
        (LPBITMAPINFO)GlobalAllocPtr(GMEM_MOVEABLE, dwSize)) == NULL) {
            ICClose(pcj->hic);      // Close this since we're erroring
            pcj->hic = NULL;
            return FALSE;
        }
        ICCompressGetFormat(pcj->hic, pvIn, pcj->lpbiOut);
    }

    return TRUE;
}

void SizeDialog(HWND hwnd, WORD id) {
    RECT    rc;

    GetWindowRect(GetDlgItem(hwnd, id), &rc);

    /* First, get rc in Client co-ords */
    ScreenToClient(hwnd, (LPPOINT)&rc + 1);
    rc.top = 0; rc.left = 0;

    /* Grow by non-client size */
    AdjustWindowRect(&rc, GetWindowLong(hwnd, GWL_STYLE),
    GetMenu(hwnd) !=NULL);

    /* That's the new size for the dialog */
    SetWindowPos(hwnd, NULL, 0, 0, rc.right-rc.left,
            rc.bottom-rc.top,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
}


void TermPreview(PICCompressorChooseStuff p)
{
    if (p->hdd)
        DrawDibClose(p->hdd);
    p->hdd = NULL;
}


BOOL InitPreview(HWND hwnd, PICCompressorChooseStuff p) {

    p->hdd = DrawDibOpen();
    if (!p->hdd)
    return FALSE;
}

#ifdef SAFETOYIELD
//
// Code to yield while we're not calling GetMessage.
// Dispatch all messages.  Pressing ESC or closing aborts.
//
BOOL WinYield(HWND hwnd)
{
    MSG msg;
    BOOL fAbort=FALSE;

    while(/* fWait > 0 && */ !fAbort && PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
    if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
            fAbort = TRUE;
    if (msg.message == WM_SYSCOMMAND && (msg.wParam & 0xFFF0) == SC_CLOSE)
        fAbort = TRUE;

    if (msg.hwnd == hwnd) {
        if (msg.message == WM_KEYDOWN ||
        msg.message == WM_SYSKEYDOWN ||
        msg.message == WM_HSCROLL ||
        msg.message == WM_PARENTNOTIFY ||
        msg.message == WM_LBUTTONDOWN) {
        PostMessage(hwnd, msg.message, msg.wParam, msg.lParam);
        return TRUE;
        }
    }

    TranslateMessage(&msg);
    DispatchMessage(&msg);
    }
    return fAbort;
}
#endif

LONG CALLBACK _loadds PreviewStatusProc(LPARAM lParam, UINT message, LONG l)
{
    TCHAR   ach[100], achT[100];
    BOOL    f;
    PICCompressorChooseStuff p = (PICCompressorChooseStuff) lParam;

    if (message != ICSTATUS_STATUS) {
    DPF(("Status callback: lParam = %lx, message = %u, l = %lu\n", lParam, message, l));
    }

    // !!!!
    // !!!! Status messages need to be fixed!!!!!!
    // !!!!

    switch (message) {
    case ICSTATUS_START:
        break;

    case ICSTATUS_STATUS:
            LoadString (ghInst, ID_FRAMECOMPRESSING, achT, sizeof(achT));
        wsprintf(ach, achT, GetScrollPos(GetDlgItem(p->hwnd,
                ID_PREVIEWSCROLL), SB_CTL), l);

        SetDlgItemText(p->hwnd, ID_PREVIEWTEXT, ach);
        break;

    case ICSTATUS_END:
        break;

    case ICSTATUS_YIELD:

        break;
    }

#ifdef SAFETOYIELD
    f = WinYield(p->hwnd);
#else
    f = FALSE;
#endif;

    if (f) {
    DPF(("Aborting from within status proc!\n"));
    }

    return f;
}


void Preview(HWND hwnd, PICCompressorChooseStuff p, BOOL fCompress)
{
    RECT    rc;
    HDC     hdc;
    int     pos;
    HANDLE  h;
    HCURSOR hcur = NULL;
    LPBITMAPINFOHEADER  lpbi, lpbiU, lpbiC = NULL;
    TCHAR       ach[120], achT[100];
    LONG    lsizeD = 0;
    LONG    lSize;
    int     x;

    // Not previewing right now!
    if (!p->hdd || !p->pgf)
    return;

    pos = GetScrollPos(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL);
    lpbi = lpbiU = AVIStreamGetFrame(p->pgf, pos);
    if (!lpbi)
    return;

    //
    // What would the image look like compressed?
    //
    if (fCompress && (int)p->hic > 0) {
    LRESULT     lRet;

    lRet = ICSetStatusProc(p->hic, 0, p, PreviewStatusProc);
    if (lRet != 0) {
        hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    // !!! Gives whole data rate to this stream
    // !!! What to do if Rate or Scale is zero?
    lSize = (GetDlgItemInt(hwnd, ID_DATARATE, NULL, FALSE)  * 1024L) /
            ((p->info.dwScale && p->info.dwRate) ?
            (p->info.dwRate / p->info.dwScale) : 1L);
        h = ICImageCompress(p->hic,
        0,
        (LPBITMAPINFO)lpbi,
        (LPBYTE)lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD),
        NULL,
        GetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL) * 100,
        &lSize);
    if (hcur)
        SetCursor(hcur);
        if (h)
            lpbiC = (LPBITMAPINFOHEADER)GlobalLock(h);
        // Use the compressed image if we have one.. else use the original frame
        if (lpbiC)
        lpbi = lpbiC;
    }

    //
    // If we chose NO COMPRESSION, tell them the size of the data as its
    // compressed now.  Otherwise, use the size it will become when compressed
    // or the full frame size.
    //
    if (fCompress && (int)p->hic == 0) {
    p->pavi->lpVtbl->Read(p->pavi, pos, 1, NULL, 0, &lsizeD, NULL);
    } else {
    lsizeD = (lpbiC ? lpbiC->biSizeImage : lpbiU->biSizeImage);
    }

    hdc = GetDC(GetDlgItem(hwnd, ID_PREVIEWWIN));
    GetClientRect(GetDlgItem(hwnd, ID_PREVIEWWIN), &rc);

    // Clip regions aren't set up right for windows in a dialog, so make sure
    // we'll only paint into the window and not spill around it.
    IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

    // Now go ahead and draw a miniature frame that preserves the aspect ratio
    // centred in our preview window
    x = MulDiv((int)lpbi->biWidth, 3, 4);
    if (x <= (int)lpbi->biHeight) {
    rc.left = (rc.right - MulDiv(rc.right, x, (int)lpbi->biHeight)) / 2;
    rc.right -= rc.left;
    } else {
    x = MulDiv((int)lpbi->biHeight, 4, 3);
    rc.top = (rc.bottom - MulDiv(rc.bottom, x, (int)lpbi->biWidth)) / 2;
    rc.bottom -= rc.top;
    }
    DrawDibDraw(p->hdd, hdc, rc.left, rc.top, rc.right - rc.left,
    rc.bottom - rc.top, lpbi, NULL, 0, 0, -1, -1, 0);

    // Print the sizes and ratio for this frame
    LoadString (ghInst, ID_FRAMESIZE, achT, sizeof(achT));
    wsprintf(ach, achT,
    GetScrollPos(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL),
    lsizeD,
    lpbiU->biSizeImage,
    lsizeD * 100 / lpbiU->biSizeImage);
    SetDlgItemText(hwnd, ID_PREVIEWTEXT, ach);
    if (lpbiC)
        GlobalFreePtr(lpbiC);
    ReleaseDC(GetDlgItem(hwnd, ID_PREVIEWWIN), hdc);
}


///////////////////////////////////////////////////////////////////////////////
//
//  ICCompressorChooseDlgProc
//
//  dialog box procedure for ICCompressorChoose, a pointer to a
//  ICCompressorChooseStuff pointer must be passed to initialize this
//  dialog.
//
//  NOTE: this dialog box procedure does not use any globals
//  so I did not bother to _export it or use MakeProcAddress() if
//  you change this code to use globals, etc, be aware of this fact.
//
///////////////////////////////////////////////////////////////////////////////

BOOL VFWAPI ICCompressorChooseDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int i,n;
    int pos;
    HWND hwndC;
    PICCompressorChooseStuff p;
    HIC hic;
    BOOL fConfig, fAbout, fQuality, fKey, fDataRate;
    BOOL fShowKeyFrame, fShowDataRate, fShowPreview;
    int nSelectMe = -1;
    TCHAR ach[120], achT[80];
    RECT    rc;
    UINT    id;
    HDC     hdc;
    BOOL    f = FALSE, fCanDecompress = FALSE;
    LONG    lsize;
    LPBITMAPINFOHEADER lpbi = NULL;
    BOOL    fStreamIsCompressed = FALSE;
    HRESULT hr;

    p = (PICCompressorChooseStuff)GetWindowLong(hwnd,DWL_USER);


    switch (msg)
    {
        case WM_INITDIALOG:
        #define but &&
        #define and &&
        #define is ==
        #define isnt !=

            if (lParam == 0)
                return FALSE;

            SetWindowLong(hwnd,DWL_USER,lParam);
            p = (PICCompressorChooseStuff)lParam;

        p->hwnd = hwnd;

            // Let the user change the title of the dialog
            if (p->lpszTitle != NULL)
                SetWindowTextA(hwnd, p->lpszTitle);

        havifile = GetModuleHandle("avifile");

        if (havifile) {
            (FARPROC)AVIStreamGetFrameOpen =
            GetProcAddress((HINSTANCE)havifile,
            (LPCSTR)"AVIStreamGetFrameOpen");
            (FARPROC)AVIStreamGetFrame =
            GetProcAddress((HINSTANCE)havifile,
            (LPCSTR)"AVIStreamGetFrame");
            (FARPROC)AVIStreamGetFrameClose =
            GetProcAddress((HINSTANCE)havifile,
            (LPCSTR)"AVIStreamGetFrameClose");
            if (p->pavi)
                p->pgf = AVIStreamGetFrameOpen(p->pavi, NULL);
        }

        // We weren't passed in an input format but we have a PAVI we
        // can get a format from
        if (p->pvIn is NULL but p->pavi isnt NULL and p->pgf isnt NULL) {

        // We need to nuke pvIn later
        f = TRUE;

        // Find out if the AVI Stream is compressed or not
        p->pavi->lpVtbl->ReadFormat(p->pavi, 0, NULL, &lsize);
        if (lsize)
            lpbi = (LPBITMAPINFOHEADER)GlobalAllocPtr(GMEM_MOVEABLE,
                lsize);
        if (lpbi) {
            hr = p->pavi->lpVtbl->ReadFormat(p->pavi, 0, lpbi, &lsize);
            if (hr == AVIERR_OK)
            fStreamIsCompressed = lpbi->biCompression != BI_RGB;
            GlobalFreePtr(lpbi);
        }

        // Get the decompressed format of the AVI stream
        lpbi = AVIStreamGetFrame(p->pgf, 0);
        if (lpbi) {
            lsize = lpbi->biSize +
                lpbi->biClrUsed * sizeof(PALETTEENTRY);
            p->pvIn = (LPBITMAPINFOHEADER)GlobalAllocPtr(GMEM_MOVEABLE,
                lsize);
            if (p->pvIn)
                hmemcpy(p->pvIn, lpbi, lsize);
        }
        }

            //
            // now fill the combo box with all compressors
            //
            hwndC = GetDlgItem(hwnd, ID_COMPRESSOR);

            for (i=0; ICInfo(p->fccType, i, &p->icinfo); i++)
            {
                hic = ICOpen(p->icinfo.fccType, p->icinfo.fccHandler,
            ICMODE_COMPRESS);

                if (hic)
                {
                    //
                    // skip this compressor if it can't handle the
                    // specified format and we want to skip such compressors
                    //
                    if (!(p->uiFlags & ICMF_CHOOSE_ALLCOMPRESSORS) &&
            p->pvIn != NULL &&
                        ICCompressQuery(hic, p->pvIn, NULL) != ICERR_OK)
                    {
                        ICClose(hic);
                        continue;
                    }

                    //
                    // find out the compressor name.
                    //
                    ICGetInfo(hic, &p->icinfo, sizeof(p->icinfo));

                    //
                    // stuff it into the combo box and remember which one it was
                    //
                    n = ComboBox_AddString(hwndC,p->icinfo.szDescription);
#ifdef WIN32
barf    // Making a LONG out of a hic and an int just won't cut it
barf    // Look at the GetItemData's as well which will also break
#endif
                    ComboBox_SetItemData(hwndC, n, MAKELONG(hic, i));

            // This compressor is the one we want to come up default ?
            // Set its state
                // !!! Combo Box better not be sorted!
            // Convert both to upper case for an insensitive compare
            AnsiUpperBuff((LPSTR)&p->icinfo.fccHandler, sizeof(FOURCC));
            AnsiUpperBuff((LPSTR)&p->fccHandler, sizeof(FOURCC));
            if (p->icinfo.fccHandler == p->fccHandler) {
                nSelectMe = n;
            if (p->lpState)
                ICSetState(hic, p->lpState, p->cbState);
            }
                }
            }

        //
        // Next add a "No Recompression" item unless they passed in an
        // uncompressed format
        //
        if (!p->pvIn || fStreamIsCompressed ||
            ((LPBITMAPINFOHEADER)p->pvIn)->biCompression != BI_RGB) {
                LoadString (ghInst, ID_NOCOMPSTRING, ach, sizeof (ach));
                n = ComboBox_AddString(hwndC, ach);
            ComboBox_SetItemData(hwndC, n, 0);
            // Select "No Recompression" as the default if nobody else has
        // set it.
        if (nSelectMe == -1)
            nSelectMe = n;
        }
        //
        // Now add a "Full Frames (Uncompressed)" item unless we can't
        // decompress this format and they don't want all choices anyway
        //
            if (!(p->uiFlags & ICMF_CHOOSE_ALLCOMPRESSORS) && p->pvIn) {
        // If it's RGB, of course, just offer the option.
        if (((LPBITMAPINFOHEADER)p->pvIn)->biCompression != BI_RGB) {
            if ((hic = ICLocate(ICTYPE_VIDEO, 0, p->pvIn, NULL,
                ICMODE_DECOMPRESS)) == NULL)
            goto SkipFF;
            else
            ICClose(hic);
        }
        }

            LoadString (ghInst, ID_FULLFRAMESSTRING, ach, sizeof (ach));
            n = ComboBox_AddString(hwndC, ach);
        ComboBox_SetItemData(hwndC, n, MAKELONG(-1, 0));

        // Select "Full Frames" if that was the last one chosen
        // !!! Combo Box better not be sorted!
        if (nSelectMe == -1 &&
            (p->fccHandler == comptypeDIB || p->fccHandler == 0))
        nSelectMe = n;
        fCanDecompress = TRUE;

SkipFF:
        // If we haven't selected anything yet, choose something at random.
        if (nSelectMe == -1)
        nSelectMe = 0;

        fShowKeyFrame = p->uiFlags & ICMF_CHOOSE_KEYFRAME;
        fShowDataRate = p->uiFlags & ICMF_CHOOSE_DATARATE;
        // Don't show a preview if we can't draw it!
        fShowPreview  = (p->uiFlags & ICMF_CHOOSE_PREVIEW) && p->pavi &&
        fCanDecompress;

        // Hide our secret small place holders
        ShowWindow(GetDlgItem(hwnd, ID_CHOOSE_SMALL), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_CHOOSE_NORMAL), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_CHOOSE_BIG), SW_HIDE);

        if (!fShowKeyFrame) {
        ShowWindow(GetDlgItem(hwnd, ID_KEYFRAME), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_KEYFRAMEBOX), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_KEYFRAMETEXT), SW_HIDE);
        }

        if (!fShowDataRate) {
        ShowWindow(GetDlgItem(hwnd, ID_DATARATE), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_DATARATEBOX), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_DATARATETEXT), SW_HIDE);
        }

        if (!fShowPreview) {
        ShowWindow(GetDlgItem(hwnd, ID_PREVIEW), SW_HIDE);
        }

        // We start without these
        ShowWindow(GetDlgItem(hwnd, ID_PREVIEWWIN), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, ID_PREVIEWTEXT), SW_HIDE);

        //
        // What size dialog do we need?
        //
        if (!fShowPreview && (!fShowDataRate || !fShowKeyFrame))
        SizeDialog(hwnd, ID_CHOOSE_SMALL);
        else
        SizeDialog(hwnd, ID_CHOOSE_NORMAL);

        //
        // Swap places for KeyFrameEvery and DataRate
        //
        if (fShowDataRate && !fShowKeyFrame) {
        GetWindowRect(GetDlgItem(hwnd, ID_KEYFRAME), &rc);
        ScreenToClient(hwnd, (LPPOINT)&rc);
        ScreenToClient(hwnd, (LPPOINT)&rc + 1);
        MoveWindow(GetDlgItem(hwnd, ID_DATARATE), rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, FALSE);
        GetWindowRect(GetDlgItem(hwnd, ID_KEYFRAMEBOX), &rc);
        ScreenToClient(hwnd, (LPPOINT)&rc);
        ScreenToClient(hwnd, (LPPOINT)&rc + 1);
        MoveWindow(GetDlgItem(hwnd, ID_DATARATEBOX), rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, FALSE);
        GetWindowRect(GetDlgItem(hwnd, ID_KEYFRAMETEXT), &rc);
        ScreenToClient(hwnd, (LPPOINT)&rc);
        ScreenToClient(hwnd, (LPPOINT)&rc + 1);
        MoveWindow(GetDlgItem(hwnd, ID_DATARATETEXT), rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, TRUE);
        }

        //
        // Restore the dlg to the settings found in the structure
        //
        SetScrollRange(GetDlgItem(hwnd, ID_QUALITY), SB_CTL, 0, 100, FALSE);
        CheckDlgButton(hwnd, ID_KEYFRAMEBOX, (BOOL)(p->lKey));
        CheckDlgButton(hwnd, ID_DATARATEBOX, (BOOL)(p->lDataRate));
        SetDlgItemInt(hwnd, ID_KEYFRAME, (int)p->lKey, FALSE);
        SetDlgItemInt(hwnd, ID_DATARATE, (int)p->lDataRate, FALSE);
        ComboBox_SetCurSel(GetDlgItem(hwnd, ID_COMPRESSOR), nSelectMe);
            SendMessage(hwnd, WM_COMMAND, ID_COMPRESSOR,
        MAKELONG(hwndC, CBN_SELCHANGE));

        // We alloced this ourselves and need to free it now
        if (f && p->pvIn)
        GlobalFreePtr(p->pvIn);

            return TRUE;

        case WM_PALETTECHANGED:

        // It came from us.  Ignore it
            if (wParam == (WORD)hwnd)
                break;

    case WM_QUERYNEWPALETTE:

        if (!p->hdd)
        break;

            hdc = GetDC(hwnd);

        //
        // Realize the palette of the first video stream
        // !!! If first stream isn't video, we're DEAD!
        //
            if (f = DrawDibRealize(p->hdd, hdc, FALSE))
                InvalidateRect(hwnd, NULL, FALSE);

            ReleaseDC(hwnd, hdc);

            return f;

    case WM_PAINT:
        if (!p->hdd)
        break;
        // Paint everybody else before the Preview window since that'll
        // take awhile, and we don't want an ugly window during it.
        DefWindowProc(hwnd, msg, wParam, lParam);
        UpdateWindow(hwnd);
        Preview(hwnd, p, TRUE);
        return 0;

        case WM_HSCROLL:
#ifdef WIN32
            id = GetWindowLong((HWND)HIWORD(lParam), GWL_ID);
#else
            id = GetWindowWord((HWND)HIWORD(lParam), GWW_ID);
#endif
            pos = GetScrollPos((HWND)HIWORD(lParam), SB_CTL);

            switch (wParam)
            {
                case SB_LINEDOWN:       pos += 1; break;
                case SB_LINEUP:         pos -= 1; break;
                case SB_PAGEDOWN:       pos += (id == ID_QUALITY) ? 10 :
                    (int)p->info.dwLength / 10; break;
                case SB_PAGEUP:         pos -= (id == ID_QUALITY) ? 10 :
                    (int)p->info.dwLength / 10; break;
                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:  pos = LOWORD(lParam); break;
        case SB_ENDSCROLL:
            Preview(hwnd, p, TRUE); // Draw this compressed frame
            return TRUE;    // don't fall through and invalidate
                default:
                    return TRUE;
            }

        if (id == ID_QUALITY) {
                if (pos < 0)
                    pos = 0;
                if (pos > (ICQUALITY_HIGH/100))
                    pos = (ICQUALITY_HIGH/100);
                SetDlgItemInt(hwnd, ID_QUALITYTEXT, pos, FALSE);
                SetScrollPos((HWND)HIWORD(lParam), SB_CTL, pos, TRUE);

            } else if (id == ID_PREVIEWSCROLL) {

        // !!! round off !!!
                if (pos < (int)p->info.dwStart)
                    pos = (int)p->info.dwStart;
                if (pos >= (int)p->info.dwStart + (int)p->info.dwLength)
                    pos = (int)(p->info.dwStart + p->info.dwLength - 1);
                SetScrollPos((HWND)HIWORD(lParam), SB_CTL, pos, TRUE);

                LoadString (ghInst, ID_FRAME, achT, sizeof(achT));
        wsprintf(ach, achT, pos);
        SetDlgItemText(hwnd, ID_PREVIEWTEXT, ach);

        //Drawing while scrolling flashes palettes because they aren't
        //compressed.
        //Preview(hwnd, p, FALSE);
        }

            break;

        case WM_COMMAND:
            hwndC = GetDlgItem(hwnd, ID_COMPRESSOR);
            n = ComboBox_GetCurSel(hwndC);
            hic = (n == -1) ? NULL : (HIC)LOWORD(ComboBox_GetItemData(hwndC,n));
        if (!p->fClosing)
        p->hic = hic;

            switch ((int)wParam)
            {
        // When data rate box loses focus, update our preview
        case ID_DATARATE:
            if (HIWORD(lParam) == EN_KILLFOCUS)
            Preview(hwnd, p, TRUE);
            break;

                case ID_COMPRESSOR:
                    if (HIWORD(lParam) != CBN_SELCHANGE)
                        break;

                    if ((int)p->hic > 0) {
                        ICGetInfo(p->hic, &p->icinfo, sizeof(p->icinfo));

                        fConfig  = (BOOL)ICQueryConfigure(p->hic);
                        fAbout   = ICQueryAbout(p->hic);
                        fQuality = (p->icinfo.dwFlags & VIDCF_QUALITY) != 0;
                        fKey     = (p->icinfo.dwFlags & VIDCF_TEMPORAL) != 0;
            // if they do quality we fake crunch
                        fDataRate= (p->icinfo.dwFlags &
                    (VIDCF_QUALITY|VIDCF_CRUNCH)) != 0;
            } else {
            fConfig = fAbout = fQuality = fKey = fDataRate = FALSE;
            }

                    EnableWindow(GetDlgItem(hwnd, ID_CONFIG), fConfig);
                    EnableWindow(GetDlgItem(hwnd, ID_ABOUT), fAbout);
                    EnableWindow(GetDlgItem(hwnd, ID_QUALITY), fQuality);
                    EnableWindow(GetDlgItem(hwnd, ID_QUALITYLABEL), fQuality);
                    EnableWindow(GetDlgItem(hwnd, ID_QUALITYTEXT), fQuality);
                    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAMEBOX), fKey);
                    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAME), fKey);
                    EnableWindow(GetDlgItem(hwnd, ID_KEYFRAMETEXT), fKey);
                    EnableWindow(GetDlgItem(hwnd, ID_DATARATEBOX), fDataRate);
                    EnableWindow(GetDlgItem(hwnd, ID_DATARATE), fDataRate);
                    EnableWindow(GetDlgItem(hwnd, ID_DATARATETEXT), fDataRate);

                    if (fQuality)
            {
            if (p->lQ == ICQUALITY_DEFAULT && (int)p->hic > 0)
            {
                SetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL,
                (int)ICGetDefaultQuality(p->hic) / 100, TRUE);
            }
            else
            {
                SetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL,
                (int)p->lQ / 100, TRUE);
            }

            pos = GetScrollPos(GetDlgItem(hwnd, ID_QUALITY),SB_CTL);
            SetDlgItemInt(hwnd, ID_QUALITYTEXT, pos, FALSE);
            }

            // redraw with new compressor
            Preview(hwnd, p, TRUE);

                    break;

                case ID_CONFIG:
                    if ((int)p->hic > 0) {
                        ICConfigure(p->hic, hwnd);
            Preview(hwnd, p, TRUE);
            }
                    break;

                case ID_ABOUT:
                    if ((int)p->hic > 0)
                        ICAbout(p->hic, hwnd);
                    break;

        case ID_PREVIEW:
            ShowWindow(GetDlgItem(hwnd, ID_PREVIEW), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, ID_PREVIEWWIN), SW_SHOW);
            ShowWindow(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SW_SHOW);
            ShowWindow(GetDlgItem(hwnd, ID_PREVIEWTEXT), SW_SHOW);
            SizeDialog(hwnd, ID_CHOOSE_BIG);
            // !!! truncation
                SetScrollRange(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL,
            (int)p->info.dwStart,
            (int)(p->info.dwStart + p->info.dwLength - 1),
            FALSE);
                    SetScrollPos(GetDlgItem(hwnd, ID_PREVIEWSCROLL), SB_CTL,
            (int)p->info.dwStart, TRUE);
                    LoadString (ghInst, ID_FRAME, achT, sizeof(achT));
            wsprintf(ach, achT, p->info.dwStart);
            SetDlgItemText(hwnd, ID_PREVIEWTEXT, ach);
            InitPreview(hwnd, p);
            break;

                case IDOK:

            // !!! We need to call ICInfo to get the FOURCC used
            // in system.ini.  Calling ICGetInfo will return the
            // FOURCC the compressor thinks it is, which won't
            // work.
            // Get the HIWORD before we nuke it.
                    i = HIWORD(ComboBox_GetItemData(hwndC, n));

            //
            // Don't close the current compressor in our CANCEL loop
            //
                    ComboBox_SetItemData(hwndC, n, 0);

            //
            // Return the values of the dlg to the caller
            //
                    p->hic = hic;

                    p->lQ = 100 *
            GetScrollPos(GetDlgItem(hwnd, ID_QUALITY), SB_CTL);

            if (IsDlgButtonChecked(hwnd, ID_KEYFRAMEBOX))
                p->lKey = GetDlgItemInt(hwnd, ID_KEYFRAME, NULL, FALSE);
            else
            p->lKey = 0;

            if (IsDlgButtonChecked(hwnd, ID_DATARATEBOX))
                p->lDataRate = GetDlgItemInt(hwnd, ID_DATARATE, NULL,
                FALSE);
            else
            p->lDataRate = 0;

            // We've chosen a valid compressor.  Do stuff.
            if ((int)p->hic > 0) {

                // !!! We need to call ICInfo to get the FOURCC used
                // in system.ini.  Calling ICGetInfo will return the
                // FOURCC the compressor thinks it is, which won't
                // work.
                        ICInfo(p->fccType, i, &p->icinfo);
                p->fccHandler = p->icinfo.fccHandler;   // identify it

            // Free the old state
            if (p->lpState)
                GlobalFreePtr(p->lpState);
            p->lpState = NULL;
            // Get the new state
            p->cbState = ICGetStateSize(p->hic);
            if (p->cbState) {   // Remember it's config state
                p->lpState = GlobalAllocPtr(GMEM_MOVEABLE,
                p->cbState);
                if (p->lpState) {
                ICGetState(p->hic, p->lpState, p->cbState);
                }
            }
            } else if ((int)p->hic == -1) { // "Full Frames"
            p->fccHandler = comptypeDIB;
            p->hic = 0;
            } else {                // "No Compression"
            p->fccHandler = 0L;
            p->hic = 0;
            }

                    // fall through

                case IDCANCEL:
            p->fClosing = TRUE;

            if (wParam == IDCANCEL)
                p->hic = NULL;

                    n = ComboBox_GetCount(hwndC);
                    for (i=0; i<n; i++)
                    {
                        if ((int)(hic =
                (HIC)LOWORD(ComboBox_GetItemData(hwndC,i))) > 0)
                            ICClose(hic);
                    }

            TermPreview(p);
            if (p->pgf)
            AVIStreamGetFrameClose(p->pgf);
            p->pgf = NULL;
                    EndDialog(hwnd, wParam == IDOK);
                    break;
            }
            break;
    }

    return FALSE;
}




/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * ICSAMPLE=1
 *
 ****************************************************************************/

#ifdef DEBUG

static BOOL  fDebug = -1;

#define MODNAME "ICM"

static void cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

#ifdef WIN32
    va_list va;
    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    va_start(va, szFormat);
    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va);
    va_end(va);
//  lstrcat(ach, "\r\r\n");
#else
    if (fDebug == -1)
        fDebug = GetProfileInt("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpy(ach, MODNAME ": ");

    wvsprintf(ach+lstrlen(ach),szFormat,(LPSTR)(&szFormat+1));
//  lstrcat(ach, "\r\r\n");
#endif

    OutputDebugStringA(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dcilink.h ===
/*
 * Dynamically link to DCI entry points.
 * To implement dynamic linking
 * 1. include this file in DRAWDIB.C
 * 2. include a call in DRAWDIB.C to InitialiseDCI()
 * 3. include a call in DRAWDIB.C to TerminateDCI()
 * 	at the appropriate points.
 * There are no other changes.
 * To revert to static linking you can simply modify this file or
 * #define STATIC_LINK_TO_DCI during the compilation phase.
 * AND link to DCIMAN32.LIB
 *
 * IF the code adds calls to other DCI entry points they will have to be
 * added to this file.  You should find that out easily enough as there will
 * be an unresolved reference on linking (assuming that DCIMAN32.LIB is not
 * included in the libraries list).
 *
 * The process is straightforward.
 * string variables are defined to hold the
 *   names of the DCI function entry points.
 * function variables are defined for each entry point being indirected
 * the code is added to GetProcAddress for each entry
 * a #define is added to point the DCI entry point name at the function variable
 */

#ifdef STATIC_LINK_TO_DCI

#define InitialiseDCI() 1
#define TerminateDCI()

#else

static const char DCILIBRARY[] = "DCIMAN32.DLL";
static HINSTANCE  hlibDCI;
static BOOL       fDCILinked;
static UINT	  cDCIUsers; // Count of active DCI users

char szDCIOpenProvider[]  =  "DCIOpenProvider";
char szDCICloseProvider[] =  "DCICloseProvider";
char szDCICreatePrimary[] =  "DCICreatePrimary";
char szDCIEndAccess[]     =  "DCIEndAccess";
char szDCIBeginAccess[]   =  "DCIBeginAccess";
char szDCIDestroy[]       =  "DCIDestroy";

HDC 	(WINAPI *pfnDCIOpenProvider)(void);
void 	(WINAPI *pfnDCICloseProvider)(HDC hdc);
int 	(WINAPI *pfnDCICreatePrimary)(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
void 	(WINAPI *pfnDCIEndAccess)(LPDCISURFACEINFO pdci);
DCIRVAL (WINAPI *pfnDCIBeginAccess)(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
void 	(WINAPI *pfnDCIDestroy)(LPDCISURFACEINFO pdci);

BOOL InitialiseDCI(void);
__inline BOOL InitialiseDCI()	
{
    ++cDCIUsers;
    if (fDCILinked) {
	// Already linked
	return(TRUE);
    }
    hlibDCI = LoadLibraryA(DCILIBRARY);						
    if (hlibDCI) {									
        (FARPROC)pfnDCIOpenProvider  = GetProcAddress(hlibDCI, szDCIOpenProvider);	
        (FARPROC)pfnDCICloseProvider = GetProcAddress(hlibDCI, szDCICloseProvider);	
        (FARPROC)pfnDCICreatePrimary = GetProcAddress(hlibDCI, szDCICreatePrimary);	
        (FARPROC)pfnDCIEndAccess     = GetProcAddress(hlibDCI, szDCIEndAccess);	
        (FARPROC)pfnDCIBeginAccess   = GetProcAddress(hlibDCI, szDCIBeginAccess);	
        (FARPROC)pfnDCIDestroy       = GetProcAddress(hlibDCI, szDCIDestroy);	
        if (pfnDCIOpenProvider && 							
            pfnDCICloseProvider &&							
            pfnDCICreatePrimary &&							
            pfnDCIEndAccess &&    							
            pfnDCIBeginAccess &&  							
            pfnDCIDestroy) {							
    	    fDCILinked = TRUE;							
        } else {									
	    --cDCIUsers;
	    FreeLibrary(hlibDCI);							
	    hlibDCI = NULL;								
        }										
    }										
    return fDCILinked;

}

#define TerminateDCI() \
	if (hlibDCI && !--cDCIUsers) {\
	    FreeLibrary(hlibDCI);     \
	    fDCILinked = FALSE;       \
	    hlibDCI = NULL;	      \
	}


// Map the static names to the function pointers.

#define DCIOpenProvider  pfnDCIOpenProvider
#define DCICloseProvider pfnDCICloseProvider
#define DCICreatePrimary pfnDCICreatePrimary
#define DCIEndAccess     pfnDCIEndAccess
#define DCIBeginAccess   pfnDCIBeginAccess
#define DCIDestroy       pfnDCIDestroy

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman.16\thunks.h ===
/****************************************************************************
    thunks.h

    Contains definitions for thunking msvideo.dll (16bit) to the 32bit
    msvfw32.dll running on NT.

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    msvfw32.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)


//
// Functions to link and unlink to 32-bit side

BOOL _loadds FAR InitThunks(void);

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

//
// The prototypes for setting up thunks for the video api set (in AVICAP32)
//

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);

#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

//
// The prototypes for setting up thunks for the ICM_ api set (in MSVFW32)
//

BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo);
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICClose32(DWORD hic);

#endif // _INC_COMPMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\dispdb32\dispdb32.c ===
/******************************Module*Header*******************************\
* Module Name: dispdib32.c
*
* Fakes the display of full screen videos.
*
*
* Created: 23-03-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#include <windows.h>
#include "dispdib.h"
#include "drawdib.h"

/* -------------------------------------------------------------------------
** Private constants
** -------------------------------------------------------------------------
*/
#define CX_MAX_MOVIE_DEFAULT  640
#define CY_MAX_MOVIE_DEFAULT  480

/* -------------------------------------------------------------------------
** Private functions prototypes
** -------------------------------------------------------------------------
*/
LRESULT CALLBACK
FullScreenWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
KeyboardHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    );

UINT
DisplayDibEnter(
    LPBITMAPINFOHEADER lpbi,
    UINT wFlags
    );

void
DisplayDibLeave(
    UINT wFlags
    );

int
DisplayCalcMovieMultiplier(
    int cxOriginal,
    int cyOriginal,
    DWORD dwCompression
    );


/* -------------------------------------------------------------------------
** Debugging stuff
** -------------------------------------------------------------------------
*/
#if DBG

void
dprintf(
    LPSTR lpszFormat,
    ...
    );

int DebugLevel = 1;

#define  dpf( _x_ )                       dprintf _x_
#define dpf1( _x_ ) if (DebugLevel >= 1) {dprintf _x_ ;} else
#define dpf2( _x_ ) if (DebugLevel >= 2) {dprintf _x_ ;} else
#define dpf3( _x_ ) if (DebugLevel >= 3) {dprintf _x_ ;} else
#define dpf4( _x_ ) if (DebugLevel >= 4) {dprintf _x_ ;} else
#define dpf5( _x_ ) if (DebugLevel >= 5) {dprintf _x_ ;} else

#else

#define  dpf( _x_ )
#define dpf1( _x_ )
#define dpf2( _x_ )
#define dpf3( _x_ )
#define dpf4( _x_ )
#define dpf5( _x_ )

#endif



/* -------------------------------------------------------------------------
** Private Globals
** These are only valid in the process that started playing the movie.
** -------------------------------------------------------------------------
*/
HWND        hwndFullScreen;
HDC         hdcFullScreen;
HDRAWDIB    hdd;
BOOL        fClassRegistered;
int         dxScreen;
int         dyScreen;
int         iMovieSizeMultiplier;



/* -------------------------------------------------------------------------
** Global data shared between all processes that attach to this library.
** This is required to make the keyboard hook work correctly.
** -------------------------------------------------------------------------
*/
#pragma data_seg( ".sdata" )
BOOL    fStop;
HHOOK   hHookK;
#pragma data_seg()



/******************************Public*Routine******************************\
* DisplayDib
*
* Just call DisplayDibEx
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL
DisplayDib(
    LPBITMAPINFOHEADER lpbi,
    LPSTR lpBits,
    UINT wFlags
    )
{
    dpf(( "Down level api, use DisplayDibEx" ));
    return DisplayDibEx( lpbi, 0, 0, lpBits, wFlags );
}




/******************************Public*Routine******************************\
* @doc EXTERNAL DISPDIB
*
* @api UINT | DisplayDibEx | This function displays a 256-color bitmap on a
*    standard VGA display. It reduces the display resolution to 320-by-200
*    or 320-by-240 and uses the full screen to display the bitmap, clipping
*    and centering it as necessary. The function normally does not return to
*    the application until the user presses a key or clicks a mouse button.
*
*    To call <f DisplayDibEx>, an application must be the active
*    application. All inactive applications and GDI screen updates
*    are suspended while <f DisplayDib> temporarily reconfigures
*    the display.
*
* @parm LPBITMAPINFO | lpbi | Specifies a pointer to a <t BITMAPINFO>
*    header describing the bitmap to be displayed.
*
* @parm int | x | x position to place DIB iff DISPLAYDIB_NOCENTER flags is set
*      the lower left is (0,0)
*
* @parm int | y | y position to place DIB iff DISPLAYDIB_NOCENTER flags is set
*      the lower left is (0,0)
*
* @parm LPSTR | lpBits | Specifies a pointer to the bitmap bits. If this
*     parameter is NULL, the bits are assumed to follow the
*     <t BITMAPINFO> structure pointed to by <p lpbi>.
*
* @parm UINT | wFlags | Specifies options for displaying the bitmap. Use
*  the following flags:
*
* @flag  DISPLAYDIB_MODE_DEFAULT | Use the default mode (320 by 240)
*    to display the bitmap.
* @flag  DISPLAYDIB_MODE_320x200x8 | Use 320-by-200 mode to display
*    the bitmap.
* @flag  DISPLAYDIB_MODE_320x240x8 | Use 320-by-240 mode to display
*    the bitmap. This is the default.
* @flag  DISPLAYDIB_NOWAIT | Return immediately after displaying the
*  bitmap; don't wait for a key press or mouse click before returning.
* @flag  DISPLAYDIB_NOPALETTE      | Ignore the palette associated
*    with the bitmap. You can use this flag when displaying a series
*    of bitmaps that use a common palette.
* @flag  DISPLAYDIB_NOCENTER       | Don't center the image. The function
*  displays the bitmap in the lower-left corner of the display.
* @flag  DISPLAYDIB_NOIMAGE        | Don't draw image
* @flag  DISPLAYDIB_ZOOM2          | Stretch image by 2
* @flag  DISPLAYDIB_DONTLOCKTASK   | dont lock out other tasks
* @flag  DISPLAYDIB_TEST           | dont do any thing just test for support
* @flag  DISPLAYDIB_BEGIN          | Switch to the low-resolution
*    display mode and set the palette. The bitmap is not displayed.
*
*    If you are displaying a series of images that use the same palette,
*    you can call <f DisplayDib> with this flag to prepare the display for
*    the bitmaps, then make a series of <f DisplayDib> calls with the
*    DISPLAYDIB_NOPALETTE flag. This technique
*    eliminates the screen flicker that occurs when the display is
*    switched between the low-resolution and standard VGA modes.
*    To return the display to standard VGA mode, subsequently
*    call <f DisplayDib> with the DISPLAYDIB_END flag.
*
* @flag  DISPLAYDIB_END            | Switch back to standard VGA mode
*    and return without displaying a bitmap. Signifies the end of multiple
*    calls to <f DisplayDib>. With this flag, you can specify
*    NULL for the <p lpbi> and <p lpBits> parameters.
*
* @rdesc Returns zero if successful, otherwise returns an error code.
*  Error codes are as follows:
*
* @flag  DISPLAYDIB_NOTSUPPORTED   | <f DisplayDib> is not supported
*   in the current mode.
* @flag  DISPLAYDIB_INVALIDDIB     | The bitmap specified by
*   <p lpbi> is not a valid bitmap.
* @flag  DISPLAYDIB_INVALIDFORMAT  | The bitmap specified by
*   <p lpbi> specifes a type of bitmap that is not supported.
* @flag  DISPLAYDIB_INVALIDTASK    | The caller is an inactive application.
*   <f DisplayDib> can only be called by an active application.
*
* @comm The <f DisplayDib> function displays bitmaps described with
*    the Windows 3.0 <t BITMAPINFO> data structure in either BI_RGB
*    or BI_RLE8 format; it does not support bitmaps described with
*    the OS/2 <t BITMAPCOREHEADER> data structure.
*
*    When <f DisplayDib> switches to a low-resolution display, it
*    disables the current display driver. As a result, you cannot use GDI
*    functions to update the display while <f DisplayDib> is displaying a
*    bitmap.
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL
DisplayDibEx(
    LPBITMAPINFOHEADER lpbi,
    int x,
    int y,
    LPSTR lpBits,
    UINT wFlags
    )
{
    DWORD       wNumColors;
    LONG        yExt;
    LONG        xExt;
    int         xScreen,yScreen;

    /*
    ** If not already done so:
    **      Register our class and Create our window "fullscreen"
    */
    if (wFlags & DISPLAYDIB_BEGIN) {

        dpf4(( "DISPLAYDIB_BEGIN..." ));

        return DisplayDibEnter( lpbi, wFlags );
    }

    /*
    ** Just testing return OK
    */
    else if (wFlags & DISPLAYDIB_TEST) {

        dpf1(( "lpbi->biCompression = 0x%X = %c%c%c%c",
                lpbi->biCompression,
                *((LPSTR)&lpbi->biCompression + 0),
                *((LPSTR)&lpbi->biCompression + 1),
                *((LPSTR)&lpbi->biCompression + 2),
                *((LPSTR)&lpbi->biCompression + 3) ));

        dpf4(( "DISPLAYDIB_TEST... returning OK" ));
        return DISPLAYDIB_NOERROR;
    }

    /*
    ** Palette change message
    */
    else if ( (wFlags & (DISPLAYDIB_NOWAIT | DISPLAYDIB_NOIMAGE)) ==
              (DISPLAYDIB_NOWAIT | DISPLAYDIB_NOIMAGE) ) {

        PALETTEENTRY    ape[256];
        LPRGBQUAD       lprgb;
        int             i;

        lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi->biSize);

        for (i = 0; i < (int) lpbi->biClrUsed; i++) {
            ape[i].peRed = lprgb[i].rgbRed;
            ape[i].peGreen = lprgb[i].rgbGreen;
            ape[i].peBlue = lprgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }

        DrawDibChangePalette(hdd, 0, (int)lpbi->biClrUsed, (LPPALETTEENTRY)ape);

        return DISPLAYDIB_NOERROR;
    }

    /*
    ** Time to kill the window and the class
    */
    else if (wFlags & DISPLAYDIB_END) {

        dpf4(( "DISPLAYDIB_END..." ));
        DisplayDibLeave( wFlags );
        return DISPLAYDIB_NOERROR;
    }

    /*
    ** Do the drawing here !!
    */
    else if ( !fStop ) {

        /*
        ** If we were'nt asked to draw anything just return.
        */
        if ( wFlags & DISPLAYDIB_NOIMAGE ) {
            return DISPLAYDIB_NOERROR;
        }

        xExt = lpbi->biWidth;
        yExt = lpbi->biHeight;

        if ( wFlags & DISPLAYDIB_ZOOM2 ) {

            xExt <<= 1;
            yExt <<= 1;
        }
        else if ( iMovieSizeMultiplier ) {

            xExt <<= iMovieSizeMultiplier;
            yExt <<= iMovieSizeMultiplier;
        }

        wNumColors  = lpbi->biClrUsed;
        if (wNumColors == 0 && lpbi->biBitCount <= 8) {
            wNumColors = 1 << (UINT)lpbi->biBitCount;
        }

        /*
        ** setup pointers
        */
        if (lpBits == NULL) {
            lpBits = (LPBYTE)lpbi + lpbi->biSize + wNumColors * sizeof(RGBQUAD);
        }

        /*
        **  center the image
        */
        if (!(wFlags & DISPLAYDIB_NOCENTER)) {

            xScreen = ((int)dxScreen - xExt) / 2;
            yScreen = ((int)dyScreen - yExt) / 2;
        }
        else {

            xScreen = 0;
            yScreen = 0;
        }

        dpf5(( "Drawing to the screen..." ));
        DrawDibDraw( hdd, hdcFullScreen,
                     xScreen, yScreen, xExt, yExt,
                     lpbi, lpBits,
                     0, 0, lpbi->biWidth, lpbi->biHeight,
                     DDF_SAME_HDC | DDF_SAME_DRAW );

        return DISPLAYDIB_NOERROR;
    }

    /*
    ** The user pressed a key... time to stop
    */
    else {

        dpf4(( "The keyboard hook is telling us to stop..." ));
        DisplayDibLeave( wFlags );
        return DISPLAYDIB_NOTSUPPORTED;
    }

}



/*****************************Private*Routine******************************\
* DisplayDibEnter
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
UINT
DisplayDibEnter(
    LPBITMAPINFOHEADER lpbi,
    UINT wFlags
    )
{
    WNDCLASS    wc;
    HINSTANCE   hInst = GetModuleHandle( NULL );


    /*
    ** If our class isn't already registered with windows register it
    */
    fClassRegistered = GetClassInfo( hInst, TEXT("SJE_FULLSCREEN"), &wc );
    if ( fClassRegistered == FALSE ) {

        ZeroMemory( &wc, sizeof(wc) );

        wc.style         = CS_OWNDC;
        wc.lpfnWndProc   = FullScreenWndProc;
        wc.hInstance     = hInst;
        wc.hbrBackground = (HBRUSH)GetStockObject( BLACK_BRUSH );
        wc.lpszClassName = TEXT("SJE_FULLSCREEN");
        fClassRegistered = RegisterClass( &wc );
        dpf4(( "Class registered... %s", fClassRegistered ? "OK" : "FAILED" ));
    }


    if ( fClassRegistered ) {

        /*
        ** Do we already have a window ??
        */
        if ( hwndFullScreen == NULL ) {

            hwndFullScreen = CreateWindowEx(WS_EX_TOPMOST,
                                            TEXT("SJE_FULLSCREEN"),
                                            NULL,
                                            WS_POPUP,
                                            0, 0, 0, 0,
                                            NULL, NULL,
                                            hInst, NULL );

            dpf4(( "Window created... %s", hwndFullScreen ? "OK" : "FAILED" ));
        }

        if ( hwndFullScreen ) {

            LONG    yExt;
            LONG    xExt;
            MSG     msg;

            /*
            ** purge the queue of keyboard messages before installing
            ** the hook.
            */
            while ( PeekMessage( &msg, NULL, WM_KEYFIRST, WM_KEYLAST,
                                 PM_REMOVE | PM_NOYIELD ) );

            hHookK = SetWindowsHookEx( WH_KEYBOARD, KeyboardHookProc,
                                       GetModuleHandle(TEXT("DISPDB32.DLL")),
                                       0 );
            dpf4(( "Hook created... %s", hHookK ? "OK" : "FAILED" ));


            dxScreen = GetSystemMetrics( SM_CXSCREEN );
            dyScreen = GetSystemMetrics( SM_CYSCREEN );

            hdcFullScreen = GetDC( hwndFullScreen );
            hdd = DrawDibOpen();

            xExt = lpbi->biWidth;
            yExt = lpbi->biHeight;

            iMovieSizeMultiplier =
                DisplayCalcMovieMultiplier( xExt, yExt, lpbi->biCompression );

            if ( wFlags & DISPLAYDIB_ZOOM2 ) {

                xExt <<= 1;
                yExt <<= 1;
            }
            else if ( iMovieSizeMultiplier ) {

                xExt <<= iMovieSizeMultiplier;
                yExt <<= iMovieSizeMultiplier;
            }

            dpf1(( "Drawing at %d by %d... Flags = 0x%X", xExt, yExt, wFlags ));
            DrawDibBegin( hdd, hdcFullScreen, xExt, yExt,
                          lpbi, lpbi->biWidth, lpbi->biHeight, 0 );

            MoveWindow( hwndFullScreen, 0, 0, dxScreen, dyScreen, FALSE );
            ShowWindow( hwndFullScreen, SW_SHOW );
            UpdateWindow( hwndFullScreen );

            ShowCursor( FALSE );
            SetFocus( hwndFullScreen );
        }
    }

    fStop = FALSE;
    return hwndFullScreen != NULL ? DISPLAYDIB_NOERROR : DISPLAYDIB_NOTSUPPORTED;
}



/*****************************Private*Routine******************************\
* DisplayDibLeave
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
void
DisplayDibLeave(
    UINT wFlags
    )
{
    if (hwndFullScreen) {
        DestroyWindow( hwndFullScreen );
        hwndFullScreen = NULL;
    }

}

/*****************************Private*Routine******************************\
* DisplayCalcMovieMultiplier
*
* Determines the largest movie that the display is capable of displaying.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
DisplayCalcMovieMultiplier(
    int cxOriginal,
    int cyOriginal,
    DWORD dwCompression
    )
{
    SYSTEM_INFO     SysInfo;
    int             iMult;
    int             iMultTemp;
    int             cxOriginalSave, cyOriginalSave;


    /*
    ** For now, don't try to stretch 'cvid' compressed movies.  This is
    ** because it looks bad!!
    */
    if ( *((LPSTR)&dwCompression + 0) == 'c'
      && *((LPSTR)&dwCompression + 1) == 'v'
      && *((LPSTR)&dwCompression + 2) == 'i'
      && *((LPSTR)&dwCompression + 3) == 'd' ) {

        return 0;
    }


    GetSystemInfo( &SysInfo );
    iMultTemp = iMult = 0;
    cxOriginalSave = cxOriginal;
    cyOriginalSave = cyOriginal;

    switch ( SysInfo.wProcessorArchitecture ) {

    case PROCESSOR_ARCHITECTURE_INTEL:
        if ( SysInfo.wProcessorLevel <= 3 ) {
            break;
        }

        /*
        ** maybe later we will do something different for i486's
        ** for now they just fall through to the RISC / Pentium default
        ** case below.
        */

    default:

        while ( (cxOriginal <= CX_MAX_MOVIE_DEFAULT)
             && (cyOriginal <= CY_MAX_MOVIE_DEFAULT) ) {

            iMult = iMultTemp;
            iMultTemp++;

            cxOriginal = cxOriginalSave << iMultTemp;
            cyOriginal = cyOriginalSave << iMultTemp;
        }
        break;
    }

    return iMult;
}


/******************************Public*Routine******************************\
* FullScreenWndProc
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
FullScreenWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            RECT        rc;

            dpf4(( "Window needs painting" ));
            BeginPaint( hwnd, &ps );
            GetUpdateRect( hwnd, &rc, FALSE );
            FillRect( hdcFullScreen, &rc, GetStockObject( BLACK_BRUSH ) );
            EndPaint( hwnd, &ps );
        }
        break;

    case WM_PALETTECHANGED:
        if ( (HWND)wParam == hwnd ) {
            break;
        }

        /* fall thru */

    case WM_QUERYNEWPALETTE:
        if ( DrawDibRealize( hdd, hdcFullScreen, FALSE ) > 0 ) {
            InvalidateRect( hwnd, NULL, TRUE );
        }
        break;

    case WM_DESTROY:
        dpf4(( "Window destroyed releasing DC" ));
        ReleaseDC( hwnd, hdcFullScreen );
        DrawDibEnd( hdd );
        DrawDibClose( hdd );

        UnregisterClass( TEXT("SJE_FULLSCREEN"), GetModuleHandle( NULL ) );

        fClassRegistered = FALSE;
        fStop = FALSE;

        ShowCursor( TRUE );
        UnhookWindowsHookEx( hHookK );
        break;

    default:
        return DefWindowProc( hwnd, message, wParam, lParam );
    }

    return (LRESULT)FALSE;
}



/******************************Public*Routine******************************\
* KeyboardHookProc
*
*
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
KeyboardHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if ( nCode == HC_ACTION) {

        /*
        ** Only interested in keydowns
        */
        if ( !(lParam & 0x80000000) ) {
            dpf4(( "Stop requested from the keyboard hook" ));
            fStop = TRUE;
        }
    }

    return CallNextHookEx( hHookK, nCode, wParam, lParam );
}


#if DBG
/*****************************Private*Routine******************************\
* dprintf
*
* Standard debug out stuff
*
* History:
* 23-03-94 - StephenE - Created
*
\**************************************************************************/
void
dprintf(
    LPSTR lpszFormat,
    ...
    )
{
    char buf[512];
    UINT n;
    va_list va;

    n = wsprintfA(buf, "DISPDB32: (tid %x) ", GetCurrentThreadId());

    va_start(va, lpszFormat);
    n += wvsprintfA(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dith666.c ===
//////////////////////////////////////////////////////////////////////////////
//
//  DITH666.C  - full color dither (to a palette with 6 red, 6 green 6 blue
//               levels)
//
//  NOTE this file contains the 'C' code and DITH666A.ASM has the ASM code.
//
//  This file does the following dithering
//
//      32bpp   -> 8bpp
//      24bpp   -> 8bpp
//      16bpp   -> 8bpp
//
//      8bpp    -> 4bpp     N/I
//      16bpp   -> 4bpp     N/I
//      24bpp   -> 4bpp     N/I
//      32bpp   -> 4bpp     N/I
//
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"
#include "dither.h"

#ifdef _WIN32 // 'C' code for Win32
#define USE_C
#endif

#include "dith666.h"

int         giDitherTableUsage = 0;
LPVOID      glpDitherTable;

STATICFN void Get666Colors(LPBITMAPINFOHEADER lpbi);

//////////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither24(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither32(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTableInit()
//
//////////////////////////////////////////////////////////////////////////////

STATICFN LPVOID DitherTableInit()
{
#ifdef DEBUG
    DWORD time = timeGetTime();
#endif

#ifdef XDEBUG
    int X,Y;
    char aBuffer[100];
    char far *pBuffer = aBuffer;

    GetProfileString("DrawDib", "Matrix5", "", aBuffer, sizeof(aBuffer));

    if (aBuffer[0])
    {
        for(Y = 0;Y < 4;Y++)
        {
            for(X = 0;X < 4;X++)
            {
                while(!isdigit(*pBuffer))
                {
                        pBuffer++;
                }

                aHalftone4x4_5[X][Y] = *pBuffer - '0';
                pBuffer++;
            }
        }
    }
#endif

    if (aHalftone8[0][0][0][0] == (BYTE)-1)
    {
        int i,x,y;

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (i=0; i<256; i++)
                    aHalftone8[0][x][y][i] = (i/51 + (i%51 > aHalftone4x4[x][y]));

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (i=0; i<256; i++)
                    aHalftone8[1][x][y][i] = 6 * (i/51 + (i%51 > aHalftone4x4[x][y]));

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (i=0; i<256; i++)
                    aHalftone8[2][x][y][i] = 36 * (i/51 + (i%51 > aHalftone4x4[x][y]));
    }

#ifdef USE_C
    if (aHalftone5[0][0][0][0] == (BYTE)-1)
    {
        int i,x,y,z,n;

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (z=0; z<256; z++) {
                    n = (z >> 2) & 0x1F;
                    i = n > 0 ? n-1 : 0;
                    aHalftone5[0][x][y][z] = (i/6 + (i%6 > aHalftone4x4_5[x][y]));
                }

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (z=0; z<256; z++) {
                    n = (z & 0x1F);
                    i = n > 0 ? n-1 : 0;
                    aHalftone5[1][x][y][z] = 6 * (i/6 + (i%6 > aHalftone4x4_5[x][y]));
                }

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (z=0; z<256; z++) {
                    n = z & 0x1F;
                    i = n > 0 ? n-1 : 0;
                    aHalftone5[2][x][y][z] = 36 * (i/6 + (i%6 > aHalftone4x4_5[x][y]));
                }
    }
#endif

    DPF(("DitherTableInit() took %ldms", timeGetTime() - time));

    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither8Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    UINT x,y,i,r,g,b;
    BYTE FAR *pb;

    Get666Colors(lpbiOut);

    DitherTableInit();

    if (lpDitherTable == NULL)
        lpDitherTable = GlobalAllocPtr(GHND, 256*8*8);

    if (lpDitherTable == NULL)
        return (LPVOID)-1;

    pb = (LPBYTE)lpDitherTable;

    for (y=0; y<8; y++)
    {
        for (i=0; i<256; i++)
        {
            r = ((LPRGBQUAD)(lpbi+1))[i].rgbRed;
            g = ((LPRGBQUAD)(lpbi+1))[i].rgbGreen;
            b = ((LPRGBQUAD)(lpbi+1))[i].rgbBlue;

            for (x=0; x<8; x++)
            {
                *pb++ = DITH8(x,y,r,g,b);
            }
        }
    }

    *lpDitherProc = Dither8;

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither16Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get666Colors(lpbiOut);

    *lpDitherProc = Dither16;

    DitherTableInit();

#ifndef USE_C
    //
    // we dont need to re-init the dither table, unless it is not ours then
    // we should free it.
    //
    if (lpDitherTable && lpDitherTable != glpDitherTable)
    {
        DitherTerm(lpDitherTable);
        lpDitherTable = NULL;
    }

    //
    // we dont need to re-init table
    //
    if (lpDitherTable != NULL)
        return lpDitherTable;

    if (glpDitherTable)
    {
        giDitherTableUsage++;
        return glpDitherTable;
    }
    else
    {
        //
        //  build a table that maps a RGB555 directly to a palette index
        //  we actualy build 4 tables, we assume a 2x2 dither and build
        //  a table for each position in the matrix.
        //

        UINT x,y,r,g,b;
        BYTE FAR *pb;

#ifdef DEBUG
        DWORD time = timeGetTime();
#endif
        lpDitherTable = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, 32768l*4);

        if (lpDitherTable == NULL)
            return (LPVOID)-1;

        glpDitherTable = lpDitherTable;
        giDitherTableUsage = 1;

        for (y=0; y<2; y++)
        {
            if (y == 0)
                pb = (BYTE FAR *)lpDitherTable;
            else
                pb = (BYTE FAR *)((BYTE _huge *)lpDitherTable + 65536);

            for (r=0; r<32; r++)
                for (g=0; g<32; g++)
                    for (b=0; b<32; b++)
                        for (x=0; x<2; x++)
                            *pb++ = DITH31(x,y,r,g,b);
        }

        DPF(("Dither16Init() took %ldms", timeGetTime() - time));
    }
#endif
    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16Term(LPVOID lpDitherTable)
{
    if (giDitherTableUsage == 0 || --giDitherTableUsage > 0)
        return;

    if (glpDitherTable)
    {
        GlobalFreePtr(glpDitherTable);
        glpDitherTable = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither24Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get666Colors(lpbiOut);

    *lpDitherProc = Dither24;

    return DitherTableInit();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24Term(LPVOID lpDitherTable)
{
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither32Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get666Colors(lpbiOut);

    *lpDitherProc = Dither32;

    return DitherTableInit();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32Term(LPVOID lpDitherTable)
{
}

//////////////////////////////////////////////////////////////////////////////
//
//   GetDithColors() get the dither palette
//
//////////////////////////////////////////////////////////////////////////////

STATICFN void Get666Colors(LPBITMAPINFOHEADER lpbi)
{
    RGBQUAD FAR *prgb = (RGBQUAD FAR *)(((LPBYTE)lpbi) + (UINT)lpbi->biSize);
    int i;

    for (i=0; i<256; i++)
    {
        prgb[i].rgbRed   = pal666[i][0];
        prgb[i].rgbGreen = pal666[i][1];
        prgb[i].rgbBlue  = pal666[i][2];
        prgb[i].rgbReserved = 0;
    }

    lpbi->biClrUsed = 256;
}

#ifdef USE_C

//////////////////////////////////////////////////////////////////////////////
//
//  Dither24   - dither from 24 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    BYTE r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 24)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth*3+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*3 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*3;
    wWidthDst -= DstXE;

#define GET24() \
    b = *pbS++; \
    g = *pbS++; \
    r = *pbS++;

    for (y=0; y<DstYE; y++) {

        for (x=0; x<DstXE; x++) {
            GET24(); *pbD++ = DITH8(x,y,r,g,b);
        }

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither32  - dither from 32 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    BYTE r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 32)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth*4+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*4 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*4;
    wWidthDst -= DstXE;

#define GET32() \
    b = *pbS++; \
    g = *pbS++; \
    r = *pbS++; \
    pbS++;

    for (y=0; y<DstYE; y++) {

        for (x=0; x<DstXE; x++)
        {
            GET32();
            *pbD++ = DITH8(x,y,r,g,b);
        }

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Dither16  - dither from 16 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    WORD w;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 16)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth*2+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*2 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*2;
    wWidthDst -= DstXE;

#define GET16() \
    w = *((WORD _huge *)pbS)++;

    for (y=0; y<DstYE; y++) {

        for (x=0; x<DstXE; x++)
        {
            GET16();
            *pbD++ = DITH5(x,y,w);
        }

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\compman.16\vidthunk.h ===
/****************************************************************************
    vidthunk.h

    Contains definitions for msvideo thunks (16/32 bit)

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)

#ifdef WIN32
#include <wownt32.h>
//
//  Thunking support
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_CALLBACK16                  "WOWCallback16"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);
typedef DWORD   (APIENTRY *LPWOWCALLBACK16)(DWORD vpfn16, DWORD dwParam);

#define StartThunk(Function)                           \
          DWORD ReturnCode = 0;                        \
          DPF2(("Entering function %s", #Function));

#define EndThunk()                                     \
          DPF2(("Returned %4X :%4X",                   \
                   HIWORD(ReturnCode),                 \
                   LOWORD(ReturnCode)));               \
          return ReturnCode;

#define ThunkHWND(h16) ((HWND)lpWOWHandle32(WOW_TYPE_HWND, h16))
#define ThunkHDC(h16)  ((HDC) lpWOWHandle32(WOW_TYPE_HDC , h16))
#define ThunkHPAL(h16) ((HPALETTE)lpWOWHandle32(WOW_TYPE_HPALETTE, h16))

#endif // WIN32

/*
 *  Useful structures and mapping
 */

typedef struct {
    short left, top, right, bottom;
} RECT_SHORT;


#define SHORT_RECT_TO_RECT(OutRect, InRect)  \
    OutRect.left = (LONG)InRect.left;        \
    OutRect.top = (LONG)InRect.top;          \
    OutRect.right = (LONG)InRect.right;      \
    OutRect.bottom = (LONG)InRect.bottom;

#define RECT_TO_SHORT_RECT(OutRect, InRect)  \
    OutRect.left = (short)InRect.left;       \
    OutRect.top = (short)InRect.top;         \
    OutRect.right = (short)InRect.right;     \
    OutRect.bottom = (short)InRect.bottom;


//
//  Function ids across the thunking layer (used by 32 and 16 bit)
//
enum {
   vidThunkvideoMessage32=1,
   vidThunkvideoGetNumDevs32,
   vidThunkvideoOpen32,
   vidThunkvideoClose32,

   compThunkICInfo32,
   compThunkICSendMessage32,
   compThunkICOpen32,
   compThunkICClose32
};

#ifndef WIN32
typedef struct _VIDTHUNK
{
//
//  Thunking stuff
//
    DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
                                                  DWORD, DWORD,
                                                  LPVOID, DWORD, DWORD);
    LPVOID          lpVideoThunkEntry;
    DWORD           dwVideo32Handle;
    LPVOID          lpICMThunkEntry;
    DWORD           dwICM32Handle;


} VIDTHUNK, *PVIDTHUNK, FAR *LPVIDTHUNK;
#endif // !WIN32

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);

#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo);
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICClose32(DWORD hic);

#endif // _INC_COMPMAN

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dith666.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  DITH666.H  - full color dither (to a palette with 6 red, 6 green 6 blue
//               levels)
//
//////////////////////////////////////////////////////////////////////////////

#define HSIZE 4                                 // matrix size is 4x4
#define SEG666  _based(_segname("DITH666"))     // segment containing tables
#define SEGXXX  _based(_segname("_CODE"))       // segment containing init tables

//////////////////////////////////////////////////////////////////////////////
//
//  dither table for 256 level dither (RGB 24 or 32)
//
//  total table size is 12k
//
//////////////////////////////////////////////////////////////////////////////

#define DITH256(x,y,r,g,b) aTranslate666[           \
        1  * (r/51 + (r%51 > aHalftone4x4[x][y])) + \
        6  * (g/51 + (g%51 > aHalftone4x4[x][y])) + \
        36 * (b/51 + (b%51 > aHalftone4x4[x][y]))]

#define DITH8(x,y,r,g,b) aTranslate666[   \
        aHalftone8[0][(x)&3][(y)&3][(r)] +\
        aHalftone8[1][(x)&3][(y)&3][(g)] +\
        aHalftone8[2][(x)&3][(y)&3][(b)] ]

char unsigned SEG666 aHalftone8[3][4][4][256] = {(BYTE)-1};

#if 1

static char unsigned const SEGXXX aHalftone4x4[4][4] =
{
        0,  25, 6,  31,
	38, 12, 44, 19,
        9,  35, 3,  28,
	47, 22, 41, 15
};

#else

static char unsigned const SEGXXX aHalftone4x4[4][4] =
{
        41, 3,  9,  28,
	35, 15, 22, 47,
        6,  25, 38, 0,
	19, 44, 31, 12
};

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  dither table for 32 level dither (RGB 555 or 565)
//
//  total table size is 12k
//
//////////////////////////////////////////////////////////////////////////////

#define d62(n)  (((n) * 10) / 62)                // n / 6.2
#define m62(n)  ((n) * 1000 / 62 - d62(n) * 100) // n % 6.2

#define DITH31(x,y,r,g,b) aTranslate666[                      \
        1  * (d62(r) + (m62(r) > (UINT)aHalftone2x2[x][y])) + \
        6  * (d62(g) + (m62(g) > (UINT)aHalftone2x2[x][y])) + \
        36 * (d62(b) + (m62(b) > (UINT)aHalftone2x2[x][y]))]

static char SEGXXX aHalftone2x2[2][2] =
{
        0, 99,
        66,33,
};

#ifdef USE_C

#define DITH5(x,y,rgb)  aTranslate666[            \
    aHalftone5[0][(x)&3][(y)&3][((rgb)>>8)&0xFF] +\
    aHalftone5[1][(x)&3][(y)&3][((rgb)>>5)&0xFF] +\
    aHalftone5[2][(x)&3][(y)&3][((rgb)>>0)&0xFF] ]

char unsigned SEG666 aHalftone5[3][4][4][256]  = {(BYTE)-1};


#if 0

static char unsigned const SEGXXX aHalftone4x4_5[4][4] =
{
        0,3,0,3,
        4,1,4,1,
        0,3,0,3,
        4,1,4,1
};

#else

static char SEGXXX aHalftone4x4_5[4][4] =
{
        0,3,2,3,
        2,4,0,3,
        2,0,4,1,
        4,1,2,1
};

#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  translate table from a 666 index to a foreground palette index
//
//////////////////////////////////////////////////////////////////////////////

char unsigned SEG666 aTranslate666[216] =
{
	0,
	29,
	30,
	31,
	32,
	249,
	33,
	34,
	35,
	36,
	37,
	38,
	39,
	40,
	41,
	42,
	43,
	44,
	45,
	46,
	47,
	48,
	49,
	50,
	51,
	52,
	53,
	54,
	55,
	56,
	250,
	250,
	57,
	58,
	59,
	251,
	60,
	61,
	62,
	63,
	64,
	65,
	66,
	67,
	68,
	69,
	70,
	71,
	72,
	73,
	74,
	75,
	76,
	77,
	78,
	79,
	80,
	81,
	82,
	83,
	84,
	85,
	86,
	87,
	88,
	89,
	250,
	90,
	91,
	92,
	93,
	94,
	95,
	96,
	97,
	98,
	99,
	100,
	101,
	102,
	103,
	104,
	105,
	106,
	107,
	108,
	109,
	110,
	111,
	227,
	112,
	113,
	114,
	115,
	116,
	117,
	118,
	119,
	151,
	120,
	121,
	122,
	123,
	124,
	228,
	125,
	126,
	229,
	133,
	162,
	135,
	131,
	132,
	137,
	166,
	134,
	140,
	130,
	136,
	143,
	138,
	139,
	174,
	141,
	142,
	177,
	129,
	144,
	145,
	146,
	147,
	148,
	149,
	150,
	157,
	152,
	153,
	154,
	155,
	156,
	192,
	158,
	159,
	160,
	161,
	196,
	163,
	164,
	165,
	127,
	199,
	167,
	168,
	169,
	170,
	171,
	172,
	173,
	207,
	175,
	176,
	210,
	178,
	179,
	180,
	181,
	182,
	183,
	184,
	185,
	186,
	187,
	188,
	189,
	190,
	191,
	224,
	193,
	194,
	195,
	252,
	252,
	197,
	198,
	128,
	253,
	252,
	200,
	201,
	202,
	203,
	204,
	205,
	206,
	230,
	208,
	209,
	231,
	211,
	212,
	213,
	214,
	215,
	216,
	217,
	218,
	219,
	220,
	221,
	222,
	254,
	223,
	232,
	225,
	226,
	255,
};

/*-----------------------------------------------------------------------
|	mspal.h
|	
|	Standard MS Apps Palette.  v 1.01
|
|	#include this file in the same file as HPalCreateAppPalette
|	
|	WARNING:  Generated File!  DO NOT EDIT!
|	WARNING:  Palette MUST be created with HpalCreateAppPalette
|
---------------------------------------------------------------WESC----*/
unsigned char SEGXXX pal666[256][3] =
	{
	// R     G     B
	{0x00, 0x00, 0x00}, // 0 Sys Black	gray 0
	{0x80, 0x00, 0x00}, // 1 Sys Dk Red
	{0x00, 0x80, 0x00}, // 2 Sys Dk Green
	{0x80, 0x80, 0x00}, // 3 Sys Dk Yellow
	{0x00, 0x00, 0x80}, // 4 Sys Dk Blue
	{0x80, 0x00, 0x80}, // 5 Sys Dk Violet
	{0x00, 0x80, 0x80}, // 6 Sys Dk Cyan
	{0xc0, 0xc0, 0xc0}, // 7 Sys Lt Grey	gray 192
	{0xc0, 0xdc, 0xc0}, // 8 Sys 8
	{0xa6, 0xca, 0xf0}, // 9 Sys 9 (the first 10 are fixed by Windows)

	{0x04, 0x04, 0x04}, // 10 	gray 4
	{0x08, 0x08, 0x08}, // 11 	gray 8
	{0x0c, 0x0c, 0x0c}, // 12 	gray 12
	{0x11, 0x11, 0x11}, // 13 	gray 17
	{0x16, 0x16, 0x16}, // 14 	gray 22
	{0x1c, 0x1c, 0x1c}, // 15 	gray 28
	{0x22, 0x22, 0x22}, // 16 	gray 34
	{0x29, 0x29, 0x29}, // 17 	gray 41
	{0x55, 0x55, 0x55}, // 18 swapped so inversions look good	gray 85
	{0x4d, 0x4d, 0x4d}, // 19 swapped so inversions look good	gray 77
	{0x42, 0x42, 0x42}, // 20 swapped so inversions look good	gray 66
        {0x39, 0x39, 0x39}, // 21 swapped so inversions look good       gray 57
        {0x81, 0x81, 0x81}, // 22 Sys Dk Grey repeat    gray 128
        {0x81, 0x00, 0x00}, // 23 Sys Dk Red repeat
        {0x00, 0x81, 0x00}, // 24 Sys Dk Green repeat
        {0x81, 0x81, 0x00}, // 25 Sys Dk Yellow repeat
        {0x00, 0x00, 0x81}, // 26 Sys Dk Blue repeat
        {0x81, 0x00, 0x81}, // 27 Sys Dk Violet repeat
        {0x00, 0x81, 0x81}, // 28 Sys Dk Cyan repeat
	{0x33, 0x00, 0x00}, // 29 
	{0x66, 0x00, 0x00}, // 30 
	{0x99, 0x00, 0x00}, // 31 
	{0xcc, 0x00, 0x00}, // 32 
	{0x00, 0x33, 0x00}, // 33 
	{0x33, 0x33, 0x00}, // 34 
	{0x66, 0x33, 0x00}, // 35 
	{0x99, 0x33, 0x00}, // 36 
	{0xcc, 0x33, 0x00}, // 37 
	{0xff, 0x33, 0x00}, // 38 
	{0x00, 0x66, 0x00}, // 39 
	{0x33, 0x66, 0x00}, // 40 
	{0x66, 0x66, 0x00}, // 41 
	{0x99, 0x66, 0x00}, // 42 
	{0xcc, 0x66, 0x00}, // 43 
	{0xff, 0x66, 0x00}, // 44 
	{0x00, 0x99, 0x00}, // 45 
	{0x33, 0x99, 0x00}, // 46 
	{0x66, 0x99, 0x00}, // 47 
	{0x99, 0x99, 0x00}, // 48 
	{0xcc, 0x99, 0x00}, // 49 
	{0xff, 0x99, 0x00}, // 50 
	{0x00, 0xcc, 0x00}, // 51 
	{0x33, 0xcc, 0x00}, // 52 
	{0x66, 0xcc, 0x00}, // 53 
	{0x99, 0xcc, 0x00}, // 54 
	{0xcc, 0xcc, 0x00}, // 55 
	{0xff, 0xcc, 0x00}, // 56 
	{0x66, 0xff, 0x00}, // 57 
	{0x99, 0xff, 0x00}, // 58 
	{0xcc, 0xff, 0x00}, // 59 
	{0x00, 0x00, 0x33}, // 60 
	{0x33, 0x00, 0x33}, // 61 
	{0x66, 0x00, 0x33}, // 62 
	{0x99, 0x00, 0x33}, // 63 
	{0xcc, 0x00, 0x33}, // 64 
	{0xff, 0x00, 0x33}, // 65 
	{0x00, 0x33, 0x33}, // 66 
	{0x33, 0x33, 0x33}, // 67 	gray 51
	{0x66, 0x33, 0x33}, // 68 
	{0x99, 0x33, 0x33}, // 69 
	{0xcc, 0x33, 0x33}, // 70 
	{0xff, 0x33, 0x33}, // 71 
	{0x00, 0x66, 0x33}, // 72 
	{0x33, 0x66, 0x33}, // 73 
	{0x66, 0x66, 0x33}, // 74 
	{0x99, 0x66, 0x33}, // 75 
	{0xcc, 0x66, 0x33}, // 76 
	{0xff, 0x66, 0x33}, // 77 
	{0x00, 0x99, 0x33}, // 78 
	{0x33, 0x99, 0x33}, // 79 
	{0x66, 0x99, 0x33}, // 80 
	{0x99, 0x99, 0x33}, // 81 
	{0xcc, 0x99, 0x33}, // 82 
	{0xff, 0x99, 0x33}, // 83 
	{0x00, 0xcc, 0x33}, // 84 
	{0x33, 0xcc, 0x33}, // 85 
	{0x66, 0xcc, 0x33}, // 86 
	{0x99, 0xcc, 0x33}, // 87 
	{0xcc, 0xcc, 0x33}, // 88 
	{0xff, 0xcc, 0x33}, // 89 
	{0x33, 0xff, 0x33}, // 90 
	{0x66, 0xff, 0x33}, // 91 
	{0x99, 0xff, 0x33}, // 92 
	{0xcc, 0xff, 0x33}, // 93 
	{0xff, 0xff, 0x33}, // 94 
	{0x00, 0x00, 0x66}, // 95 
	{0x33, 0x00, 0x66}, // 96 
	{0x66, 0x00, 0x66}, // 97 
	{0x99, 0x00, 0x66}, // 98 
	{0xcc, 0x00, 0x66}, // 99 
	{0xff, 0x00, 0x66}, // 100 
	{0x00, 0x33, 0x66}, // 101 
	{0x33, 0x33, 0x66}, // 102 
	{0x66, 0x33, 0x66}, // 103 
	{0x99, 0x33, 0x66}, // 104 
	{0xcc, 0x33, 0x66}, // 105 
	{0xff, 0x33, 0x66}, // 106 
	{0x00, 0x66, 0x66}, // 107 
	{0x33, 0x66, 0x66}, // 108 
	{0x66, 0x66, 0x66}, // 109 	gray 102
	{0x99, 0x66, 0x66}, // 110 
	{0xcc, 0x66, 0x66}, // 111 
	{0x00, 0x99, 0x66}, // 112 
	{0x33, 0x99, 0x66}, // 113 
	{0x66, 0x99, 0x66}, // 114 
	{0x99, 0x99, 0x66}, // 115 
	{0xcc, 0x99, 0x66}, // 116 
	{0xff, 0x99, 0x66}, // 117 
	{0x00, 0xcc, 0x66}, // 118 
	{0x33, 0xcc, 0x66}, // 119 
	{0x99, 0xcc, 0x66}, // 120 
	{0xcc, 0xcc, 0x66}, // 121 
	{0xff, 0xcc, 0x66}, // 122 
	{0x00, 0xff, 0x66}, // 123 
	{0x33, 0xff, 0x66}, // 124 
	{0x99, 0xff, 0x66}, // 125 
	{0xcc, 0xff, 0x66}, // 126 
	{0xff, 0x00, 0xcc}, // 127 
	{0xcc, 0x00, 0xff}, // 128 
	{0x00, 0x99, 0x99}, // 129 
	{0x99, 0x33, 0x99}, // 130 
	{0x99, 0x00, 0x99}, // 131 
	{0xcc, 0x00, 0x99}, // 132 
	{0x00, 0x00, 0x99}, // 133 
	{0x33, 0x33, 0x99}, // 134 
	{0x66, 0x00, 0x99}, // 135 
	{0xcc, 0x33, 0x99}, // 136 
	{0xff, 0x00, 0x99}, // 137 
	{0x00, 0x66, 0x99}, // 138 
	{0x33, 0x66, 0x99}, // 139 
	{0x66, 0x33, 0x99}, // 140 
	{0x99, 0x66, 0x99}, // 141 
	{0xcc, 0x66, 0x99}, // 142 
	{0xff, 0x33, 0x99}, // 143 
	{0x33, 0x99, 0x99}, // 144 
	{0x66, 0x99, 0x99}, // 145 
	{0x99, 0x99, 0x99}, // 146 	gray 153
	{0xcc, 0x99, 0x99}, // 147 
	{0xff, 0x99, 0x99}, // 148 
	{0x00, 0xcc, 0x99}, // 149 
	{0x33, 0xcc, 0x99}, // 150 
	{0x66, 0xcc, 0x66}, // 151 
	{0x99, 0xcc, 0x99}, // 152 
	{0xcc, 0xcc, 0x99}, // 153 
	{0xff, 0xcc, 0x99}, // 154 
	{0x00, 0xff, 0x99}, // 155 
	{0x33, 0xff, 0x99}, // 156 
	{0x66, 0xcc, 0x99}, // 157 
	{0x99, 0xff, 0x99}, // 158 
	{0xcc, 0xff, 0x99}, // 159 
	{0xff, 0xff, 0x99}, // 160 
	{0x00, 0x00, 0xcc}, // 161 
	{0x33, 0x00, 0x99}, // 162 
	{0x66, 0x00, 0xcc}, // 163 
	{0x99, 0x00, 0xcc}, // 164 
	{0xcc, 0x00, 0xcc}, // 165 
	{0x00, 0x33, 0x99}, // 166 
	{0x33, 0x33, 0xcc}, // 167 
	{0x66, 0x33, 0xcc}, // 168 
	{0x99, 0x33, 0xcc}, // 169 
	{0xcc, 0x33, 0xcc}, // 170 
	{0xff, 0x33, 0xcc}, // 171 
	{0x00, 0x66, 0xcc}, // 172 
	{0x33, 0x66, 0xcc}, // 173 
	{0x66, 0x66, 0x99}, // 174 
	{0x99, 0x66, 0xcc}, // 175 
	{0xcc, 0x66, 0xcc}, // 176 
	{0xff, 0x66, 0x99}, // 177 
	{0x00, 0x99, 0xcc}, // 178 
	{0x33, 0x99, 0xcc}, // 179 
	{0x66, 0x99, 0xcc}, // 180 
	{0x99, 0x99, 0xcc}, // 181 
	{0xcc, 0x99, 0xcc}, // 182 
	{0xff, 0x99, 0xcc}, // 183 
	{0x00, 0xcc, 0xcc}, // 184 
	{0x33, 0xcc, 0xcc}, // 185 
	{0x66, 0xcc, 0xcc}, // 186 
	{0x99, 0xcc, 0xcc}, // 187 
	{0xcc, 0xcc, 0xcc}, // 188 	gray 204
	{0xff, 0xcc, 0xcc}, // 189 
	{0x00, 0xff, 0xcc}, // 190 
	{0x33, 0xff, 0xcc}, // 191 
	{0x66, 0xff, 0x99}, // 192 
	{0x99, 0xff, 0xcc}, // 193 
	{0xcc, 0xff, 0xcc}, // 194 
	{0xff, 0xff, 0xcc}, // 195 
	{0x33, 0x00, 0xcc}, // 196 
	{0x66, 0x00, 0xff}, // 197 
	{0x99, 0x00, 0xff}, // 198 
	{0x00, 0x33, 0xcc}, // 199 
	{0x33, 0x33, 0xff}, // 200 
	{0x66, 0x33, 0xff}, // 201 
	{0x99, 0x33, 0xff}, // 202 
	{0xcc, 0x33, 0xff}, // 203 
	{0xff, 0x33, 0xff}, // 204 
	{0x00, 0x66, 0xff}, // 205 
	{0x33, 0x66, 0xff}, // 206 
	{0x66, 0x66, 0xcc}, // 207 
	{0x99, 0x66, 0xff}, // 208 
	{0xcc, 0x66, 0xff}, // 209 
	{0xff, 0x66, 0xcc}, // 210 
	{0x00, 0x99, 0xff}, // 211 
	{0x33, 0x99, 0xff}, // 212 
	{0x66, 0x99, 0xff}, // 213 
	{0x99, 0x99, 0xff}, // 214 
	{0xcc, 0x99, 0xff}, // 215 
	{0xff, 0x99, 0xff}, // 216 
	{0x00, 0xcc, 0xff}, // 217 
	{0x33, 0xcc, 0xff}, // 218 
	{0x66, 0xcc, 0xff}, // 219 
	{0x99, 0xcc, 0xff}, // 220 
	{0xcc, 0xcc, 0xff}, // 221 
	{0xff, 0xcc, 0xff}, // 222 
	{0x33, 0xff, 0xff}, // 223 
	{0x66, 0xff, 0xcc}, // 224 
	{0x99, 0xff, 0xff}, // 225 
	{0xcc, 0xff, 0xff}, // 226 
	{0xff, 0x66, 0x66}, // 227 
	{0x66, 0xff, 0x66}, // 228 
	{0xff, 0xff, 0x66}, // 229 
	{0x66, 0x66, 0xff}, // 230 
	{0xff, 0x66, 0xff}, // 231 
	{0x66, 0xff, 0xff}, // 232 
        {0xc1, 0xc1, 0xc1}, // 233 Sys Dk Grey repeat inversion gray 192
	{0x5f, 0x5f, 0x5f}, // 234 	gray 95
	{0x77, 0x77, 0x77}, // 235 	gray 119
	{0x86, 0x86, 0x86}, // 236 	gray 134
	{0x96, 0x96, 0x96}, // 237 	gray 150
	{0xcb, 0xcb, 0xcb}, // 238 	gray 203
	{0xb2, 0xb2, 0xb2}, // 239 	gray 178
	{0xd7, 0xd7, 0xd7}, // 240 	gray 215
	{0xdd, 0xdd, 0xdd}, // 241 	gray 221
	{0xe3, 0xe3, 0xe3}, // 242 	gray 227
	{0xea, 0xea, 0xea}, // 243 	gray 234
	{0xf1, 0xf1, 0xf1}, // 244 	gray 241
        {0xf8, 0xf8, 0xf8}, // 245      gray 248

	{0xff, 0xfb, 0xf0}, // 246 Sys Reserved
	{0xa0, 0xa0, 0xa4}, // 247 Sys Reserved
	{0x80, 0x80, 0x80}, // 248 Sys Lt Gray	gray 128
	{0xff, 0x00, 0x00}, // 249 Sys Red
	{0x00, 0xff, 0x00}, // 250 Sys Green
	{0xff, 0xff, 0x00}, // 251 Sys Yellow
	{0x00, 0x00, 0xff}, // 252 Sys Blue
	{0xff, 0x00, 0xff}, // 253 Sys Violet
	{0x00, 0xff, 0xff}, // 254 Sys Cyan
	{0xff, 0xff, 0xff} // 255 Sys White	gray 255
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dith775.c ===
//////////////////////////////////////////////////////////////////////////////
//
//  DITH775.C  - full color dither (to a palette with 7 red, 7 green 5 blue
//               levels)
//
//  NOTE this file contains the 'C' code and DITH775A.ASM has the ASM code.
//
//  This file does the following dithering
//
//      24bpp   -> 8bpp
//      16bpp   -> 8bpp
//
//      8bpp    -> 4bpp     N/I
//      16bpp   -> 4bpp     N/I
//      24bpp   -> 4bpp     N/I
//
//  Using four different methods
//
//      Lookup      - fastest  1 table lookup per 16bpp pel  (160K for table)
//      Scale       - fast     2 table lookups per 16bpp pel (128K for tables)
//      Table       - fast     3 table lookups plus shifting (~1K for tables)
//
//  Lookup and Scale are 386 asm code *only* (in dith775a.asm)
//  Table is in 'C' and 386 asm.
//
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"
#include "dither.h"
#include "dith775.h"

//#define OLDDITHER

#ifdef _WIN32
#define DITHER_DEFAULT      DITHER_TABLEC
#else
#define DITHER_DEFAULT      DITHER_SCALE
#endif


#define DITHER_TABLEC       0   // table based 'C' code
#define DITHER_TABLE        1   // table based assembler
#define DITHER_SCALE        2   // scale tables
#define DITHER_LOOKUP       3   // 5 lookup tables!

UINT   wDitherMethod = (UINT)-1;

LPVOID Dither16InitScale(void);
LPVOID Dither16InitLookup(void);

int         giDitherTableUsage = 0;
LPVOID      glpDitherTable;

STATICFN void Get775Colors(LPBITMAPINFOHEADER lpbi);

//////////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24C(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither24S(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

void FAR PASCAL Dither32C(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither32S(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

void FAR PASCAL Dither16C(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither16T(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither16L(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither16S(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTableInit()
//
//////////////////////////////////////////////////////////////////////////////

STATICFN LPVOID DitherTableInit()
{
    // no need to re-init table.

    if (glpDitherTable || wDitherMethod != (UINT)-1)
    {
        giDitherTableUsage++;
        return glpDitherTable;
    }

    //
    //  choose a dither method
    //
    if (wDitherMethod == -1)
    {
        wDitherMethod = DITHER_DEFAULT;
    }

#ifdef DEBUG
    wDitherMethod = (int)mmGetProfileInt(szDrawDib, TEXT("DitherMethod"), (UINT)wDitherMethod);
#endif

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLEC:
        case DITHER_TABLE:
            break;

#ifndef _WIN32
        case DITHER_SCALE:
            glpDitherTable = Dither16InitScale();

            if (glpDitherTable == NULL)
                wDitherMethod = DITHER_TABLE;

            break;

        case DITHER_LOOKUP:
            glpDitherTable = Dither16InitLookup();

            if (glpDitherTable == NULL)
                wDitherMethod = DITHER_TABLE;

            break;
#endif // _WIN32
    }

    giDitherTableUsage = 1;
    return glpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTableFree()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL DitherTableFree()
{
    if (giDitherTableUsage == 0 || --giDitherTableUsage > 0)
        return;

    if (glpDitherTable)
    {
        GlobalFreePtr(glpDitherTable);
        glpDitherTable = NULL;
	wDitherMethod = (UINT)-1;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither8Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    return DitherDeviceInit(lpbi, lpbiOut, lpDitherProc, lpDitherTable);
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither16Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get775Colors(lpbiOut);

    //
    //  choose a dither method
    //
    if (lpDitherTable == NULL)
        lpDitherTable = DitherTableInit();

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLEC:
            *lpDitherProc = Dither16C;
            break;
#ifndef _WIN32
        case DITHER_TABLE:
            *lpDitherProc = Dither16T;
            break;

        case DITHER_SCALE:
            *lpDitherProc = Dither16S;
            break;

        case DITHER_LOOKUP:
            *lpDitherProc = Dither16L;
            break;
#endif // _WIN32
    }

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16Term(LPVOID lpDitherTable)
{
    DitherTableFree();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither24Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get775Colors(lpbiOut);

    //
    //  choose a dither method
    //
    if (lpDitherTable == NULL)
        lpDitherTable = DitherTableInit();

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLE:
        case DITHER_TABLEC:
            *lpDitherProc = Dither24C;
            break;
#ifndef _WIN32
        case DITHER_SCALE:
            *lpDitherProc = Dither24S;
            break;
#endif // _WIN32
    }

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24Term(LPVOID lpDitherTable)
{
    DitherTableFree();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither32Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    // no need to re-init table.

    Get775Colors(lpbiOut);

    //
    //  choose a dither method
    //
    if (lpDitherTable == NULL)
        lpDitherTable = DitherTableInit();

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLE:
        case DITHER_TABLEC:
            *lpDitherProc = Dither32C;
            break;
#ifndef _WIN32
        case DITHER_SCALE:
            *lpDitherProc = Dither32S;
            break;
#endif // _WIN32
    }

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32Term(LPVOID lpDitherTable)
{
    DitherTableFree();
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither16InitScale()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID Dither16InitScale()
{
    LPVOID p;
    LPBYTE pbLookup;
    LPWORD pwScale;
    UINT   r,g,b;

    p = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, 32768l*2+64000);

    if (p == NULL)
        return NULL;

    pwScale  = (LPWORD)p;

    for (r=0; r<32; r++)
        for (g=0; g<32; g++)
            for (b=0; b<32; b++)
                *pwScale++ = 1600 * r + 40 * g + b;

	    /* should this be WORD or UINT ? */
    pbLookup = (LPBYTE)(((WORD _huge *)p) + 32768l);

    for (r=0; r<40; r++)
        for (g=0; g<40; g++)
            for (b=0; b<40; b++)
                *pbLookup++ = lookup775[35*rlevel[r] + 5*glevel[g] + blevel[b]];

    return p;
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither16InitLookup()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID Dither16InitLookup()
{
    LPVOID p;
    BYTE _huge *pb;
    UINT r,g,b,i,j;

    p = GlobalAllocPtr(GHND|GMEM_SHARE, 32768l*5);

    if (p == NULL)
        return NULL;

    pb  = (BYTE _huge *)p;

    for (i=0; i<5; i++) {
        j = ((i < 3) ? i*2 : i*2-1);
        for (r=0; r<32; r++) {
            for (g=0; g<32; g++) {
                for (b=0; b<32; b++) {
                    *pb++ = lookup775[rlevel[r+i]*35 + glevel[g+i]*5 + blevel[b+j]];
		}
	    }
	}
    }

    return p;
}

//////////////////////////////////////////////////////////////////////////////
//
//   GetDithColors() get the dither palette
//
//////////////////////////////////////////////////////////////////////////////

STATICFN void Get775Colors(LPBITMAPINFOHEADER lpbi)
{
    LPRGBQUAD prgb = (LPRGBQUAD)(((LPBYTE)lpbi) + (UINT)lpbi->biSize);
    int       i;

    for (i=0; i<256; i++)
    {
        prgb[i].rgbRed      = dpal775[i][0];
        prgb[i].rgbGreen    = dpal775[i][1];
        prgb[i].rgbBlue     = dpal775[i][2];
        prgb[i].rgbReserved = 0;
    }

    lpbi->biClrUsed = 256;
}

#if 0
//////////////////////////////////////////////////////////////////////////////
//
//   CreateDith775Palette() create the dither palette
//
//////////////////////////////////////////////////////////////////////////////

HPALETTE FAR CreateDith775Palette()
{
    int      i;
    HDC      hdc;
    HPALETTE hpal;

    struct {
	WORD         palVersion;
	WORD         palNumEntries;
	PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palVersion = 0x300;
    pal.palNumEntries = 256;

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = dpal775[i][0];
        pal.palPalEntry[i].peGreen = dpal775[i][1];
        pal.palPalEntry[i].peBlue  = dpal775[i][2];
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
    }

#ifndef OLDDITHER
    //
    // our palette is built assuming the "cosmic" colors at the
    // beging and the end. so put the real mcoy there!
    //
    hdc = GetDC(NULL);
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
        GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);
    }
    ReleaseDC(NULL, hdc);
#endif

    hpal = CreatePalette((LPLOGPALETTE)&pal);

    return hpal;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  Dither24TC   - dither from 24 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    int r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 24)
        return;

    DstXE &= ~3;

    wWidthSrc = ((UINT)biSrc->biWidth*3+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*3 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*3;
    wWidthDst -= DstXE;

#define GET24() \
    b = (int)*pbS++; \
    g = (int)*pbS++; \
    r = (int)*pbS++;

#define DITHER24(mr, mg, mb) \
    GET24(); *pbD++ = (BYTE)lookup775[ rdith775[r +  mr] + gdith775[g +  mg] + ((b +  mb) >> 6) ];

    for (y=0; y<DstYE; y++) {
        switch (y & 3) {
        case 0:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24(  1,   1,   2);
            DITHER24( 17,  17,  26);
            DITHER24( 25,  25,  38);
            DITHER24( 41,  41,  62);
           }
        break;

        case 1:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24( 31,  31,  46);
            DITHER24( 36,  36,  54);
            DITHER24(  7,   7,  10);
            DITHER24( 12,  12,  18);
           }
        break;

        case 2:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24( 20,  20,  30);
            DITHER24(  4,   4,   6);
            DITHER24( 39,  39,  58);
            DITHER24( 23,  23,  34);
           }
        break;

        case 3:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24( 33,  33,  50);
            DITHER24( 28,  28,  42);
            DITHER24( 15,  15,  22);
            DITHER24(  9,   9,  14);
           }
        break;
        } /*switch*/

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither32C   - dither from 32 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    int r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 32)
        return;

    DstXE &= ~3;

    wWidthSrc = ((UINT)biSrc->biWidth*4+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*4 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*4;
    wWidthDst -= DstXE;

#define GET32() \
    b = (int)*pbS++; \
    g = (int)*pbS++; \
    r = (int)*pbS++; \
    pbS++;

#define DITHER32(mr, mg, mb) \
    GET32(); *pbD++ = (BYTE)lookup775[ rdith775[r +  mr] + gdith775[g +  mg] + ((b +  mb) >> 6) ];

    for (y=0; y<DstYE; y++) {
        switch (y & 3) {
        case 0:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32(  1,   1,   2);
            DITHER32( 17,  17,  26);
            DITHER32( 25,  25,  38);
            DITHER32( 41,  41,  62);
           }
        break;

        case 1:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32( 31,  31,  46);
            DITHER32( 36,  36,  54);
            DITHER32(  7,   7,  10);
            DITHER32( 12,  12,  18);
           }
        break;

        case 2:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32( 20,  20,  30);
            DITHER32(  4,   4,   6);
            DITHER32( 39,  39,  58);
            DITHER32( 23,  23,  34);
           }
        break;

        case 3:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32( 33,  33,  50);
            DITHER32( 28,  28,  42);
            DITHER32( 15,  15,  22);
            DITHER32(  9,   9,  14);
           }
        break;
        } /*switch*/

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Dither16TC   - dither from 16 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    int r,g,b;
    WORD w;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 16)
        return;

    DstXE = DstXE & ~3; // round down!

    wWidthSrc = ((UINT)biSrc->biWidth*2+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*2 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*2;
    wWidthDst -= DstXE;

#define GET16() \
    w = *((WORD _huge *)pbS)++;  \
    r = (int)((w >> 7) & 0xF8); \
    g = (int)((w >> 2) & 0xF8); \
    b = (int)((w << 3) & 0xF8);

#define DITHER16(mr, mg, mb) \
    GET16(); *pbD++ = (BYTE)lookup775[ rdith775[r +  mr] + gdith775[g +  mg] + ((b +  mb) >> 6)];

    for (y=0; y<DstYE; y++) {
        switch (y & 3) {
        case 0:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16(  1,   1,   2);
            DITHER16( 17,  17,  26);
            DITHER16( 25,  25,  38);
            DITHER16( 41,  41,  62);
            }
        break;

        case 1:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16( 31,  31,  46);
            DITHER16( 36,  36,  54);
            DITHER16(  7,   7,  10);
            DITHER16( 12,  12,  18);
           }
        break;

        case 2:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16( 20,  20,  30);
            DITHER16(  4,   4,   6);
            DITHER16( 39,  39,  58);
            DITHER16( 23,  23,  34);
           }
        break;

        case 3:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16( 33,  33,  50);
            DITHER16( 28,  28,  42);
            DITHER16( 15,  15,  22);
            DITHER16(  9,   9,  14);
           }
        break;
        } /*switch*/

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////

#if 0
//
//  this is the original code
//
//
void Dith775ScanLine(Rbuf, Gbuf, Bbuf, n, row, paloffset)
DWORD n; // pixels per row
int   *Rbuf, *Gbuf, *Bbuf;
int   row; // distance from top of image
WORD  *paloffset;
{
    int i;

    // DITHER(x,y,rgb)

    switch (row & 3)
    {
    case 0:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   +  1] + gdith775[Gbuf[i]   +  1] + ((Bbuf[i]   +  2) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] + 17] + gdith775[Gbuf[i+1] + 17] + ((Bbuf[i+1] + 26) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] + 25] + gdith775[Gbuf[i+2] + 25] + ((Bbuf[i+2] + 38) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] + 41] + gdith775[Gbuf[i+3] + 41] + ((Bbuf[i+3] + 62) >> 6) ];
       }
    break;

    case 1:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   + 31] + gdith775[Gbuf[i]   + 31] + ((Bbuf[i]   + 46) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] + 36] + gdith775[Gbuf[i+1] + 36] + ((Bbuf[i+1] + 54) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] +  7] + gdith775[Gbuf[i+2] +  7] + ((Bbuf[i+2] + 10) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] + 12] + gdith775[Gbuf[i+3] + 12] + ((Bbuf[i+3] + 18) >> 6) ];
       }
    break;

    case 2:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   + 20] + gdith775[Gbuf[i]   + 20] + ((Bbuf[i]   + 30) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] +  4] + gdith775[Gbuf[i+1] +  4] + ((Bbuf[i+1] +  6) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] + 39] + gdith775[Gbuf[i+2] + 39] + ((Bbuf[i+2] + 58) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] + 23] + gdith775[Gbuf[i+3] + 23] + ((Bbuf[i+3] + 34) >> 6) ];
       }
    break;

    case 3:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   + 33] + gdith775[Gbuf[i]   + 33] + ((Bbuf[i]   + 50) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] + 28] + gdith775[Gbuf[i+1] + 28] + ((Bbuf[i+1] + 42) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] + 15] + gdith775[Gbuf[i+2] + 15] + ((Bbuf[i+2] + 22) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] +  9] + gdith775[Gbuf[i+3] +  9] + ((Bbuf[i+3] + 14) >> 6) ];
       }
    break;
    } /*switch*/
}
#endif

#if 0
    {
    HPALETTE hpalT;
    HWND     hwnd;
    BYTE     xlat[256];
    int      fh;
    static   BOOL fHack = TRUE;
    OFSTRUCT of;
    char     buf[80];

    //
    // convert palette to a palette that mappes 1:1 to the system
    // palette, this will allow us to draw faster
    //
    hwnd = GetActiveWindow();

    hdc = GetDC(hwnd);

    if (fHack && (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        fHack = FALSE;

        for (i=0; i<(int)pal.palNumEntries; i++)
        {
            pal.palPalEntry[i].peRed   = (BYTE)0;
            pal.palPalEntry[i].peGreen = (BYTE)0;
            pal.palPalEntry[i].peBlue  = (BYTE)0;
            pal.palPalEntry[i].peFlags = (BYTE)PC_RESERVED;
        }

        hpalT = CreatePalette((LPLOGPALETTE)&pal);
        hpalT = SelectPalette(hdc, hpalT, FALSE);
        RealizePalette(hdc);
        hpalT = SelectPalette(hdc, hpalT, FALSE);
        DeleteObject(hpalT);

        hpalT = SelectPalette(hdc, hpal, FALSE);
        RealizePalette(hdc);
        GetSystemPaletteEntries(hdc, 0, 256, pal.palPalEntry);
        SelectPalette(hdc, hpalT, FALSE);

        PostMessage(hwnd, WM_QUERYNEWPALETTE, 0, 0);

        for (i=0; i<256; i++)
        {
            // this wont work right for dup's in the palette
            j = GetNearestPaletteIndex(hpal,RGB(pal.palPalEntry[i].peRed,
                pal.palPalEntry[i].peGreen,pal.palPalEntry[i].peBlue));

            xlat[j] = (BYTE)i;
        }

        SetPaletteEntries(hpal, 0, 256, pal.palPalEntry);

        for (i=0; i < sizeof(lookup775)/sizeof(lookup775[0]); i++)
            lookup775[i] = xlat[lookup775[i]];

        //
        //  dump the new palette and lookup table out.
        //
        fh = OpenFile("c:/foo775.h", &of, OF_CREATE|OF_READWRITE);

        if (fh != -1)
        {
            wsprintf(buf, "BYTE lookup775[245] = {\r\n");
            _lwrite(fh, buf, lstrlen(buf));

            for (i=0; i < sizeof(lookup775)/sizeof(lookup775[0]); i++) {
                wsprintf(buf, "%3d,", lookup775[i]);

                if (i % 16 == 0 && i != 0)
                    _lwrite(fh, "\r\n", 2);

                _lwrite(fh, buf, lstrlen(buf));
            }

            wsprintf(buf, "}\r\n\r\nint dpal775[256][3] = {\r\n");
            _lwrite(fh, buf, lstrlen(buf));

            for (i=0; i < 256; i++) {
                wsprintf(buf, "{0x%02x, 0x%02x, 0x%02x},",
                    pal.palPalEntry[i].peRed,
                    pal.palPalEntry[i].peGreen,
                    pal.palPalEntry[i].peBlue);

                if (i % 4 == 0 && i != 0)
                    _lwrite(fh, "\r\n", 2);

                _lwrite(fh, buf, lstrlen(buf));
            }

            wsprintf(buf, "}\r\n");
            _lwrite(fh, buf, lstrlen(buf));

            _lclose(fh);
        }
    }

    ReleaseDC(hwnd, hdc);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dither.h ===
#ifndef _DITHER_H_
#define _DITHER_H_

//////////////////////////////////////////////////////////////////////////////
//
//  this code dither a 256 color DIB bitmap down to the VGA 16 colors.
//
//////////////////////////////////////////////////////////////////////////////

typedef void (FAR PASCAL *DITHERPROC)(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call DitherInit() to set up the 16k dither table.
//  you need to call DitherInit() whenever the source colors
//  change.  DitherInit() returns a pointer to the dither table
//
extern LPVOID VFWAPI DitherInit(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   VFWAPI DitherTerm(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither8Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither8Term(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL DitherDeviceInit(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither16Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither16Term(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither24Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither24Term(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither32Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither32Term(LPVOID lpDitherTable);

extern void   FAR PASCAL DitherTableFree(void);

//extern HPALETTE FAR CreateDith775Palette(void); // (in dith775.c)

//
//  call this to actualy do the dither. (in dither8.asm)
//
extern void FAR PASCAL Dither8(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call this to actualy do the dither. (in dither.c)
//
extern void FAR PASCAL Dither8C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.


//
//  call this to actualy do the dither. (in dith775.c)
//
extern void FAR PASCAL Dither16(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call this to actualy do the dither. (in dith775.c)
//
extern void FAR PASCAL Dither24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call this to map 16 bpp DIBs to 24bit (in mapa.asm)
//
extern void FAR PASCAL Map16to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.


//
//  call this to map 32 bpp DIBs to 24bit (in mapa.asm)
//
extern void FAR PASCAL Map32to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

#endif //_DITHER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\drawdib.h ===
/**************************************************************************

    DRAWDIB.H   - routines for drawing DIBs to the screen.

    Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.

    this code handles stretching and dithering with custom code.

    the following DIB formats are supported:

        8bpp
        16bpp
        24bpp

    drawing to:

        16 color DC         (will dither 8bpp down)
        256 (palletized) DC (will dither 16 and 24bpp down)
        Full-color DC       (will just draw it!)

**************************************************************************/

#ifndef _INC_DRAWDIB
#define _INC_DRAWDIB

#ifdef __cplusplus
extern "C" {
#endif

#ifndef RC_INVOKED
#ifndef VFWAPI
    #define VFWAPI  WINAPI
#ifdef WINAPIV
    #define VFWAPIV WINAPIV
#else
    #define VFWAPIV FAR CDECL
#endif
#endif
#endif

// begin_vfw32

typedef HANDLE HDRAWDIB; /* hdd */

/*********************************************************************

  DrawDib Flags

**********************************************************************/
#define DDF_0001            0x0001          /* ;Internal */
#define DDF_UPDATE          0x0002          /* re-draw the last DIB */
#define DDF_SAME_HDC        0x0004          /* HDC same as last call (all setup) */
#define DDF_SAME_DRAW       0x0008          /* draw params are the same */
#define DDF_DONTDRAW        0x0010          /* dont draw frame, just decompress */
#define DDF_ANIMATE         0x0020          /* allow palette animation */
#define DDF_BUFFER          0x0040          /* always buffer image */
#define DDF_JUSTDRAWIT      0x0080          /* just draw it with GDI */
#define DDF_FULLSCREEN      0x0100          /* use DisplayDib */
#define DDF_BACKGROUNDPAL   0x0200	    /* Realize palette in background */
#define DDF_NOTKEYFRAME     0x0400          /* this is a partial frame update, hint */
#define DDF_HURRYUP         0x0800          /* hurry up please! */
#define DDF_HALFTONE        0x1000          /* always halftone */
#define DDF_2000            0x2000          /* ;Internal */

#define DDF_PREROLL         DDF_DONTDRAW    /* Builing up a non-keyframe */
#define DDF_SAME_DIB        DDF_SAME_DRAW
#define DDF_SAME_SIZE       DDF_SAME_DRAW

/*********************************************************************

    DrawDib functions
	
*********************************************************************/
/*							// ;Internal
**  DrawDibInit()					// ;Internal
**							// ;Internal
*/							// ;Internal
extern BOOL VFWAPI DrawDibInit(void);			// ;Internal
							// ;Internal
/*
**  DrawDibOpen()
**
*/
extern HDRAWDIB VFWAPI DrawDibOpen(void);

/*
**  DrawDibClose()
**
*/
extern 
BOOL 
VFWAPI 
DrawDibClose(
    IN HDRAWDIB hdd
    );

/*
** DrawDibGetBuffer()
**
*/
extern 
LPVOID 
VFWAPI 
DrawDibGetBuffer(
    IN HDRAWDIB hdd, 
    OUT LPBITMAPINFOHEADER lpbi, 
    IN DWORD dwSize, 
    IN DWORD dwFlags
    );

/*							// ;Internal
**  DrawDibError()					// ;Internal
*/							// ;Internal
extern UINT VFWAPI DrawDibError(HDRAWDIB hdd);		// ;Internal
							// ;Internal
/*
**  DrawDibGetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern 
HPALETTE 
VFWAPI 
DrawDibGetPalette(
    IN HDRAWDIB hdd
    );


/*
**  DrawDibSetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern 
BOOL 
VFWAPI 
DrawDibSetPalette(
    IN HDRAWDIB hdd, 
    IN HPALETTE hpal
    );

/*
**  DrawDibChangePalette()
*/
extern 
BOOL 
VFWAPI 
DrawDibChangePalette(
    IN HDRAWDIB hdd, 
    IN int iStart, 
    IN int iLen, 
    IN LPPALETTEENTRY lppe
    );

/*
**  DrawDibRealize()
**
**  realize the palette in a HDD
**
*/
extern 
UINT 
VFWAPI 
DrawDibRealize(
    IN HDRAWDIB hdd, 
    IN HDC hdc, 
    IN BOOL fBackground
    );

/*
**  DrawDibStart()
**
**  start of streaming playback
**
*/
extern 
BOOL 
VFWAPI 
DrawDibStart(
    IN HDRAWDIB hdd, 
    IN DWORD rate
    );

/*
**  DrawDibStop()
**
**  start of streaming playback
**
*/
extern 
BOOL 
VFWAPI 
DrawDibStop(
    IN HDRAWDIB hdd
    );

/*
**  DrawDibBegin()
**
**  prepare to draw
**
*/
extern
BOOL 
VFWAPI 
DrawDibBegin(
    IN HDRAWDIB hdd,
    IN HDC      hdc,
    IN int      dxDst,
    IN int      dyDst,
    IN LPBITMAPINFOHEADER lpbi,
    IN int      dxSrc,
    IN int      dySrc,
    IN UINT     wFlags
    );

/*
**  DrawDibDraw()
**
**  actualy draw a DIB to the screen.
**
*/
extern 
BOOL 
VFWAPI 
DrawDibDraw(
    IN HDRAWDIB hdd,
    IN HDC      hdc,
    IN int      xDst,
    IN int      yDst,
    IN int      dxDst,
    IN int      dyDst,
    IN LPBITMAPINFOHEADER lpbi,
    IN LPVOID   lpBits,
    IN int      xSrc,
    IN int      ySrc,
    IN int      dxSrc,
    IN int      dySrc,
    IN UINT     wFlags
    );

/*
**  DrawDibUpdate()
**
**  redraw the last image (may only be valid with DDF_BUFFER)
*/
#define DrawDibUpdate(hdd, hdc, x, y) \
        DrawDibDraw(hdd, hdc, x, y, 0, 0, NULL, NULL, 0, 0, 0, 0, DDF_UPDATE)

/*
**  DrawDibEnd()
*/
extern 
BOOL 
VFWAPI 
DrawDibEnd(
    IN HDRAWDIB hdd
    );

/*
**  DrawDibTime()  [for debugging purposes only]
*/
typedef struct {
    LONG    timeCount;
    LONG    timeDraw;
    LONG    timeDecompress;
    LONG    timeDither;
    LONG    timeStretch;
    LONG    timeBlt;
    LONG    timeSetDIBits;
}   DRAWDIBTIME, FAR *LPDRAWDIBTIME;

BOOL 
VFWAPI 
DrawDibTime(
    IN HDRAWDIB hdd, 
    OUT LPDRAWDIBTIME lpddtime
    );

/* display profiling */
#define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
#define PD_CAN_STRETCHDIB       0x0002      /* basicly RC_STRETCHDIB */
#define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
#define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
#define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */

LRESULT
VFWAPI 
DrawDibProfileDisplay(
    IN LPBITMAPINFOHEADER lpbi
    );

// end_vfw32

#ifdef __cplusplus
}
#endif

#endif // _INC_DRAWDIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dither.c ===
#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"
#include "dither.h"

//#define GRAY_SCALE

extern BOOL gf286;
extern UINT gwRasterCaps;

void FAR PASCAL Map16to24(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

extern LPVOID glpDitherTable;

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID VFWAPI
DitherInit(LPBITMAPINFOHEADER lpbiIn,
           LPBITMAPINFOHEADER lpbiOut,
           DITHERPROC FAR *   lpDitherProc,
           LPVOID             lpDitherTable)
{
    switch ((int)lpbiOut->biBitCount)
    {
        case 8:
            if ((int)lpbiIn->biBitCount == 8 && (gwRasterCaps & RC_PALETTE))
                return Dither8Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 8 && !(gwRasterCaps & RC_PALETTE))
                return DitherDeviceInit(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 16)
                return Dither16Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 24)
                return Dither24Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 32)
                return Dither32Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            return (LPVOID)-1;

        case 24:
#ifndef _WIN32
            if (!gf286)
#endif
            {
		if (lpbiIn->biBitCount == 16) {
                    *lpDitherProc = Map16to24;
                    return NULL;
		} else if (lpbiIn->biBitCount == 32) {
		    *lpDitherProc = Map32to24;
		    return NULL;
		}
	    }

	    return (LPVOID)-1;

        default:
            return (LPVOID)-1;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void VFWAPI
DitherTerm(LPVOID lpDitherTable)
{
    if (lpDitherTable == glpDitherTable)
        Dither16Term(lpDitherTable);
    else
        Dither8Term(lpDitherTable);
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherDeviceInit() - dither to the colors of the display driver
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL DitherDeviceInit(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    HBRUSH   hbr;
    HDC      hdcMem;
    HDC      hdc;
    HBITMAP  hbm;
    HBITMAP  hbmT;
    int      i;
    int      nColors;
    LPRGBQUAD prgb;
    BITMAPINFOHEADER biSave = *lpbiOut;

    //
    // we dont need to re-init the dither table, unless it is not ours then
    // we should free it.
    //
    if (lpDitherTable == glpDitherTable)
    {
        DitherTerm(lpDitherTable);
        lpDitherTable = NULL;
    }

    if (lpDitherTable == NULL)
    {
        lpDitherTable = GlobalAllocPtr(GHND, 256*8*8);
    }

    if (lpDitherTable == NULL)
        return (LPVOID)-1;

    hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);

    hbm = CreateCompatibleBitmap(hdc, 256*8, 8);
    hbmT = SelectObject(hdcMem, hbm);

    if ((nColors = (int)lpbi->biClrUsed) == 0)
        nColors = 1 << (int)lpbi->biBitCount;

    prgb = (LPRGBQUAD)(lpbi+1);

    for (i=0; i<nColors; i++)
    {
        hbr = CreateSolidBrush(RGB(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue));
        hbr = SelectObject(hdcMem, hbr);
        PatBlt(hdcMem, i*8, 0, 8, 8, PATCOPY);
        hbr = SelectObject(hdcMem, hbr);
        DeleteObject(hbr);
    }

#ifdef XDEBUG
    for (i=0; i<16; i++)
        BitBlt(hdc,0,i*8,16*8,8,hdcMem,i*(16*8),0,SRCCOPY);
#endif

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    lpbiOut->biSize           = sizeof(BITMAPINFOHEADER);
    lpbiOut->biPlanes         = 1;
    lpbiOut->biBitCount       = 8;
    lpbiOut->biWidth          = 256*8;
    lpbiOut->biHeight         = 8;
    lpbiOut->biCompression    = BI_RGB;
    lpbiOut->biSizeImage      = 256*8*8;
    lpbiOut->biXPelsPerMeter  = 0;
    lpbiOut->biYPelsPerMeter  = 0;
    lpbiOut->biClrUsed        = 0;
    lpbiOut->biClrImportant   = 0;
    GetDIBits(hdc, hbm, 0, 8, lpDitherTable, (LPBITMAPINFO)lpbiOut, DIB_RGB_COLORS);

    i = (int)lpbiOut->biClrUsed;
    *lpbiOut = biSave;
    lpbiOut->biClrUsed = i;

    DeleteObject(hbm);
    ReleaseDC(NULL, hdc);

    *lpDitherProc = Dither8;

    return (LPVOID)lpDitherTable;
}


//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither8Term(LPVOID lpDitherTable)
{
    if (lpDitherTable)
        GlobalFreePtr(lpDitherTable);
}

#ifdef _WIN32

//
//  call this to actually do the dither.
//
void FAR PASCAL Dither8(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;
    DWORD dw;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 8)
        return;

    // tomor -- A little help! seems initialization is not done yet.
    if(!lpDitherTable)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX + DstY * wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX + SrcY * wWidthSrc;

    wWidthSrc -= DstXE;
    wWidthDst -= DstXE;

#define DODITH8(px, x, y)	((LPBYTE)lpDitherTable)[((y) & 7) * 256 * 8 + (px) * 8 + (x & 7)]

    for (y=0; y<DstYE; y++) {
	/* write two DWORDs (one dither cell horizontally) at once */
	for (x=0; x <= (DstXE - 8); x += 8) {

            dw = DODITH8(*pbS++, 0, y);
	    dw |= (DODITH8(*pbS++, 1, y) << 8);
	    dw |= (DODITH8(*pbS++, 2, y) << 16);
	    dw |= (DODITH8(*pbS++, 3, y) << 24);
            * ( (DWORD _huge UNALIGNED *) pbD)++ = dw;

            dw = DODITH8(*pbS++, 4, y);
	    dw |= (DODITH8(*pbS++, 5, y) << 8);
	    dw |= (DODITH8(*pbS++, 6, y) << 16);
	    dw |= (DODITH8(*pbS++, 7, y) << 24);
            * ( (DWORD _huge UNALIGNED *) pbD)++ = dw;
	}

	/* clean up remainder (less than 8 bytes per row) */
	for ( ; x < DstXE; x++) {
	    *pbD++ = DODITH8(*pbS++, x, y);
	}
	
        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
#undef DODITH8
}

/*
 * C version of 16->24 mapping (in asm for win16)
 */
extern void FAR PASCAL Map16to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{

    int x,y;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;
    WORD wRGB;

    if (biDst->biBitCount != 24 || biSrc->biBitCount != 16)
        return;

    /* width of one row is nr pixels * size of pixel rounded to 4-bytes */
    wWidthSrc = ((UINT) (biSrc->biWidth * 2) +3)&~3;
    wWidthDst = ((UINT) (biDst->biWidth * 3) +3)&~3;

    /* advance to start of source, dest rect within DIB */
    pbD = (BYTE _huge *)lpDst + (DstX * 3) + DstY * wWidthDst;
    pbS = (BYTE _huge *)lpSrc + (SrcX * 2) + SrcY * wWidthSrc;

    /* amount to advance pointer to next line from end of source, dest rect */
    wWidthSrc -= (DstXE * 2);
    wWidthDst -= (DstXE * 3);

    for (y=0; y<DstYE; y++) {
        for (x=0; x<DstXE; x++) {
	    wRGB = *((LPWORD)pbS)++;
	    *pbD++ = (wRGB << 3) & 0xf8;
	    *pbD++ = (wRGB >> 2) & 0xf8;
	    *pbD++ = (wRGB >> 7) & 0xf8;
	}

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

void FAR PASCAL Map32to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 24 || biSrc->biBitCount != 32)
        return;

    /* width of one row is nr pixels * size of pixel rounded to 4-bytes */
    //wWidthSrc = ((UINT) (biSrc->biWidth * 4) +3)&~3;
    // Multiplying by 4 ensures it is rounded to 4 bytes...
    wWidthSrc = (UINT) (biSrc->biWidth * 4);
    wWidthDst = ((UINT) (biDst->biWidth * 3) +3)&~3;

    /* advance to start of source, dest rect within DIB */
    pbD = (BYTE _huge *)lpDst + (DstX * 3) + DstY * wWidthDst;
    pbS = (BYTE _huge *)lpSrc + (SrcX * 4) + SrcY * wWidthSrc;

    /* amount to advance pointer to next line from end of source, dest rect */
    wWidthSrc -= (DstXE * 4);
    wWidthDst -= (DstXE * 3);

    for (y=0; y<DstYE; y++) {
        for (x=0; x<DstXE; x++) {
	    *pbD++ = *pbS++;
	    *pbD++ = *pbS++;
	    *pbD++ = *pbS++;
	    pbS++;
	}

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dith775.h ===
#ifdef OLDDITHER
    #include "dpal775.h"
    #include "look775.h"
    #include "dtab775.h"
#else

BYTE lookup775[245] = {
      0, 16, 10,  4,252, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 11,
     27, 12, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,250, 40,
     41, 42,254, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
     56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
     72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
     88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112, 13,113, 14,114,115,116,117,
    118,119,120,121,122,123,124,125, 15,126,248,127,128,129,130,131,
    132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,
    148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,
    164,165,166,247,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,
    196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,
    212,213,249,214,215,216,253,217,218,219,220,221,222,223,224,225,
    226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,
    251,242,243,244,255};

BYTE rdith775[297] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,35,35,35,35,35,
    35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
    35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
    35,35,35,35,35,70,70,70,70,70,70,70,70,70,70,70,
    70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,
    70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,
    105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,
    105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,
    105,105,105,105,105,105,105,105,105,105,140,140,140,140,140,140,
    140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,
    140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,
    140,140,140,140,140,175,175,175,175,175,175,175,175,175,175,175,
    175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,
    175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,210,
    210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,
    210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,
    210,210,210,210,210,210,210,210,210};

BYTE gdith775[297] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    5,5,5,5,5,10,10,10,10,10,10,10,10,10,10,10,
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
    15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
    15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
    15,15,15,15,15,15,15,15,15,15,20,20,20,20,20,20,
    20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
    20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
    20,20,20,20,20,25,25,25,25,25,25,25,25,25,25,25,
    25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
    25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,30,
    30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30,30};

BYTE dpal775[256][3] = {
    {0x00, 0x00, 0x00},{0xbf, 0x00, 0x00},{0x00, 0xbf, 0x00},{0xbf, 0xbf, 0x00},
    {0x00, 0x00, 0xbf},{0xbf, 0x00, 0xbf},{0x00, 0xbf, 0xbf},{0xc0, 0xc0, 0xc0},

    {0xc0, 0xdc, 0xc0},{0xa4, 0xc8, 0xf0},{0x00, 0x00, 0x7F},{0x00, 0x7F, 0x00},
    {0x00, 0x7F, 0x7F},{0x7F, 0x00, 0x00},{0x7F, 0x00, 0x7F},{0x7F, 0x7F, 0x00},
    {0x00, 0x00, 0x40},{0x00, 0x2b, 0x00},{0x00, 0x2b, 0x40},{0x00, 0x2b, 0x7F},
    {0x00, 0x2b, 0xbf},{0x00, 0x2b, 0xff},{0x00, 0x55, 0x00},{0x00, 0x55, 0x40},
    {0x00, 0x55, 0x7F},{0x00, 0x55, 0xbf},{0x00, 0x55, 0xff},{0x00, 0x7F, 0x40},
    {0x00, 0x7F, 0xbf},{0x00, 0x7F, 0xff},{0x00, 0xaa, 0x00},{0x00, 0xaa, 0x40},
    {0x00, 0xaa, 0x7F},{0x00, 0xaa, 0xbf},{0x00, 0xaa, 0xff},{0x00, 0xd5, 0x00},
    {0x00, 0xd5, 0x40},{0x00, 0xd5, 0x7F},{0x00, 0xd5, 0xbf},{0x00, 0xd5, 0xff},
    {0x00, 0xff, 0x40},{0x00, 0xff, 0x7F},{0x00, 0xff, 0xbf},{0x2b, 0x00, 0x00},
    {0x2b, 0x00, 0x40},{0x2b, 0x00, 0x7F},{0x2b, 0x00, 0xbf},{0x2b, 0x00, 0xff},
    {0x2b, 0x2b, 0x00},{0x2b, 0x2b, 0x40},{0x2b, 0x2b, 0x7F},{0x2b, 0x2b, 0xbf},
    {0x2b, 0x2b, 0xff},{0x2b, 0x55, 0x00},{0x2b, 0x55, 0x40},{0x2b, 0x55, 0x7F},
    {0x2b, 0x55, 0xbf},{0x2b, 0x55, 0xff},{0x2b, 0x7F, 0x00},{0x2b, 0x7F, 0x40},
    {0x2b, 0x7F, 0x7F},{0x2b, 0x7F, 0xbf},{0x2b, 0x7F, 0xff},{0x2b, 0xaa, 0x00},
    {0x2b, 0xaa, 0x40},{0x2b, 0xaa, 0x7F},{0x2b, 0xaa, 0xbf},{0x2b, 0xaa, 0xff},
    {0x2b, 0xd5, 0x00},{0x2b, 0xd5, 0x40},{0x2b, 0xd5, 0x7F},{0x2b, 0xd5, 0xbf},
    {0x2b, 0xd5, 0xff},{0x2b, 0xff, 0x00},{0x2b, 0xff, 0x40},{0x2b, 0xff, 0x7F},
    {0x2b, 0xff, 0xbf},{0x2b, 0xff, 0xff},{0x55, 0x00, 0x00},{0x55, 0x00, 0x40},
    {0x55, 0x00, 0x7F},{0x55, 0x00, 0xbf},{0x55, 0x00, 0xff},{0x55, 0x2b, 0x00},
    {0x55, 0x2b, 0x40},{0x55, 0x2b, 0x7F},{0x55, 0x2b, 0xbf},{0x55, 0x2b, 0xff},
    {0x55, 0x55, 0x00},{0x55, 0x55, 0x40},{0x55, 0x55, 0x7F},{0x55, 0x55, 0xbf},
    {0x55, 0x55, 0xff},{0x55, 0x7F, 0x00},{0x55, 0x7F, 0x40},{0x55, 0x7F, 0x7F},
    {0x55, 0x7F, 0xbf},{0x55, 0x7F, 0xff},{0x55, 0xaa, 0x00},{0x55, 0xaa, 0x40},
    {0x55, 0xaa, 0x7F},{0x55, 0xaa, 0xbf},{0x55, 0xaa, 0xff},{0x55, 0xd5, 0x00},
    {0x55, 0xd5, 0x40},{0x55, 0xd5, 0x7F},{0x55, 0xd5, 0xbf},{0x55, 0xd5, 0xff},
    {0x55, 0xff, 0x00},{0x55, 0xff, 0x40},{0x55, 0xff, 0x7F},{0x55, 0xff, 0xbf},
    {0x55, 0xff, 0xff},{0x7F, 0x00, 0x40},{0x7F, 0x00, 0xbf},{0x7F, 0x00, 0xff},
    {0x7F, 0x2b, 0x00},{0x7F, 0x2b, 0x40},{0x7F, 0x2b, 0x7F},{0x7F, 0x2b, 0xbf},
    {0x7F, 0x2b, 0xff},{0x7F, 0x55, 0x00},{0x7F, 0x55, 0x40},{0x7F, 0x55, 0x7F},
    {0x7F, 0x55, 0xbf},{0x7F, 0x55, 0xff},{0x7F, 0x7F, 0x40},{0x7F, 0x7F, 0xbf},
    {0x7F, 0x7F, 0xff},{0x7F, 0xaa, 0x00},{0x7F, 0xaa, 0x40},{0x7F, 0xaa, 0x7F},
    {0x7F, 0xaa, 0xbf},{0x7F, 0xaa, 0xff},{0x7F, 0xd5, 0x00},{0x7F, 0xd5, 0x40},
    {0x7F, 0xd5, 0x7F},{0x7F, 0xd5, 0xbf},{0x7F, 0xd5, 0xff},{0x7F, 0xff, 0x00},
    {0x7F, 0xff, 0x40},{0x7F, 0xff, 0x7F},{0x7F, 0xff, 0xbf},{0x7F, 0xff, 0xff},
    {0xaa, 0x00, 0x00},{0xaa, 0x00, 0x40},{0xaa, 0x00, 0x7F},{0xaa, 0x00, 0xbf},
    {0xaa, 0x00, 0xff},{0xaa, 0x2b, 0x00},{0xaa, 0x2b, 0x40},{0xaa, 0x2b, 0x7F},
    {0xaa, 0x2b, 0xbf},{0xaa, 0x2b, 0xff},{0xaa, 0x55, 0x00},{0xaa, 0x55, 0x40},
    {0xaa, 0x55, 0x7F},{0xaa, 0x55, 0xbf},{0xaa, 0x55, 0xff},{0xaa, 0x7F, 0x00},
    {0xaa, 0x7F, 0x40},{0xaa, 0x7F, 0x7F},{0xaa, 0x7F, 0xbf},{0xaa, 0x7F, 0xff},
    {0xaa, 0xaa, 0x00},{0xaa, 0xaa, 0x40},{0xaa, 0xaa, 0x7F},{0xaa, 0xaa, 0xbf},
    {0xaa, 0xaa, 0xff},{0xaa, 0xd5, 0x00},{0xaa, 0xd5, 0x40},{0xaa, 0xd5, 0x7F},
    {0xaa, 0xd5, 0xbf},{0xaa, 0xd5, 0xff},{0xaa, 0xff, 0x00},{0xaa, 0xff, 0x40},
    {0xaa, 0xff, 0x7F},{0xaa, 0xff, 0xbf},{0xaa, 0xff, 0xff},{0xd5, 0x00, 0x00},
    {0xd5, 0x00, 0x40},{0xd5, 0x00, 0x7F},{0xd5, 0x00, 0xbf},{0xd5, 0x00, 0xff},
    {0xd5, 0x2b, 0x00},{0xd5, 0x2b, 0x40},{0xd5, 0x2b, 0x7F},{0xd5, 0x2b, 0xbf},
    {0xd5, 0x2b, 0xff},{0xd5, 0x55, 0x00},{0xd5, 0x55, 0x40},{0xd5, 0x55, 0x7F},
    {0xd5, 0x55, 0xbf},{0xd5, 0x55, 0xff},{0xd5, 0x7F, 0x00},{0xd5, 0x7F, 0x40},
    {0xd5, 0x7F, 0x7F},{0xd5, 0x7F, 0xbf},{0xd5, 0x7F, 0xff},{0xd5, 0xaa, 0x00},
    {0xd5, 0xaa, 0x40},{0xd5, 0xaa, 0x7F},{0xd5, 0xaa, 0xbf},{0xd5, 0xaa, 0xff},
    {0xd5, 0xd5, 0x00},{0xd5, 0xd5, 0x40},{0xd5, 0xd5, 0x7F},{0xd5, 0xd5, 0xbf},
    {0xd5, 0xd5, 0xff},{0xd5, 0xff, 0x00},{0xd5, 0xff, 0x40},{0xd5, 0xff, 0x7F},
    {0xd5, 0xff, 0xbf},{0xd5, 0xff, 0xff},{0xff, 0x00, 0x40},{0xff, 0x00, 0x7F},
    {0xff, 0x00, 0xbf},{0xff, 0x2b, 0x00},{0xff, 0x2b, 0x40},{0xff, 0x2b, 0x7F},
    {0xff, 0x2b, 0xbf},{0xff, 0x2b, 0xff},{0xff, 0x55, 0x00},{0xff, 0x55, 0x40},
    {0xff, 0x55, 0x7F},{0xff, 0x55, 0xbf},{0xff, 0x55, 0xff},{0xff, 0x7F, 0x00},
    {0xff, 0x7F, 0x40},{0xff, 0x7F, 0x7F},{0xff, 0x7F, 0xbf},{0xff, 0x7F, 0xff},
    {0xff, 0xaa, 0x00},{0xff, 0xaa, 0x40},{0xff, 0xaa, 0x7F},{0xff, 0xaa, 0xbf},
    {0xff, 0xaa, 0xff},{0xff, 0xd5, 0x00},{0xff, 0xd5, 0x40},{0xff, 0xd5, 0x7F},
    {0xff, 0xd5, 0xbf},{0xff, 0xd5, 0xff},{0xff, 0xff, 0x40},{0xff, 0xff, 0x7F},
    {0xff, 0xff, 0xbf},{0x00, 0x00, 0x01},{0xff, 0xfb, 0xf0},{0xa0, 0xa0, 0xa4},

    {0x80, 0x80, 0x80},{0xff, 0x00, 0x00},{0x00, 0xff, 0x00},{0xff, 0xff, 0x00},
    {0x00, 0x00, 0xff},{0xff, 0x00, 0xff},{0x00, 0xff, 0xff},{0xff, 0xff, 0xff}};
#endif

int rlevel[40] =
    {0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,6};

int glevel[40] =
    {0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,6};

int blevel[40] =
    {0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\drawdib.c ===
/**************************************************************************

    DRAWDIB.C   - routines for drawing DIBs to the screen.

    Copyright (c) Microsoft Corporation 1992 - 1995. All rights reserved.

    this code handles stretching and dithering with custom code, none
    of this slow GDI code.

    the following DIB formats are supported:

        4bpp (will just draw it with GDI...)
        8bpp
        16bpp
        24bpp
        compressed DIBs

    drawing to:

        16 color DC         (will dither 8bpp down)
        256 (paletized) DC  (will dither 16 and 24bpp down)
        Full-color DC       (will just draw it!)

**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <profile.h>
#include "drawdibi.h"
#include "profdisp.h"

#define USE_DCI
#ifdef DAYTONA
// Daytona dynamically links to DCI - see dcilink.h for details
#include "dcilink.h"
#endif

#ifndef abs
#define abs(x)  ((x) < 0 ? -(x) : (x))
#endif

#ifndef ICMODE_FASTDECOMPRESS
    #define ICMODE_FASTDECOMPRESS 3
#endif

#define USE_SETDI 1

#define DIB_PAL_INDICES		2

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

#ifdef _WIN32
#define FlatToHuge(a, b, c)
#define HugeToFlat(a, b, c)
#ifdef DEBUG
#define FlushBuffer()	GdiFlush()
#else
#define FlushBuffer()	
#endif

#else //Win16
extern FAR PASCAL FlatToHuge(LPVOID,DWORD,DWORD);
extern FAR PASCAL HugeToFlat(LPVOID,DWORD,DWORD);
#define FlushBuffer()
#endif

#define IsScreenDC(hdc) (WindowFromDC(hdc) != NULL)

STATICFN BOOL DrawDibCheckPalette(PDD pdd);

BOOL VFWAPI DrawDibTerm(void);
BOOL VFWAPI DrawDibInit(void);

//
// Local variables
//

#ifdef DEBUG_RETAIL
static int fDebug = -1;
#endif

/**************************************************************************
**************************************************************************/

WORD                gwScreenBitDepth = (WORD)-1;
UINT                gwScreenWidth = 0;
UINT                gwScreenHeight = 0;
UINT                gwRasterCaps = 0;
#ifndef _WIN32
BOOL                gf286= FALSE;
#else
    #define gf286 FALSE
#endif
static UINT         gUsage = 0;
static BOOL         gfInit = FALSE;
static BOOL         gfHalftone = FALSE;
static BOOL         gfBitmap   = FALSE;
static BOOL         gfBitmapX  = FALSE;
#ifdef USE_DCI
#ifdef UNICODE
// we expose the DCI variables on NT to aid with stress debugging
#define STATIC
#else // for Win95
#define STATIC static
#endif
STATIC BOOL         gfScreenX  = FALSE;
#ifdef WANT_DRAW_DIRECT_TO_SCREEN
STATIC BOOL         gfDrawX    = FALSE;
#endif
#endif // USE_DCI
static HBITMAP      hbmStockMono;               // the stock mono bitmap.

#ifdef USE_DCI
STATIC  BOOL gfDisplayHasBrokenRasters;
STATIC  HDC hdcDCI;
STATIC  DCISURFACEINFO FAR *pdci;

STATIC  struct {
	    BITMAPINFOHEADER bi;
	    DWORD            dwMask[4];
	} biScreen;
STATIC  LPVOID lpScreen;

#ifndef _WIN32
static  UINT ScreenSel;
static  DCISURFACEINFO dci;
#endif

SZCODEA szDVA[] = "dva";

#define DCAlignment 3

__inline int DCNotAligned(HDC hdc, int xDst) {
    POINT pt;

    pt.x = xDst; pt.y = 0;
    LPtoDP(hdc, &pt, 1);
    xDst = pt.x;

#ifdef _WIN32
    GetDCOrgEx(hdc, &pt);
#else
    pt.x = LOWORD(GetDCOrg(hdc));
#endif
    return (pt.x + xDst) & DCAlignment;
}
#endif // USE_DCI

/**************************************************************************
**************************************************************************/

SZCODEA  szDrawDib[]            = "DrawDib";
SZCODEA  szHalftone[]           = "Halftone";
SZCODEA  szDrawToBitmap[]       = "DrawToBitmap";
SZCODEA  szDecompressToBitmap[] = "DecompressToBitmap";
#ifdef USE_DCI
SZCODEA  szDecompressToScreen[]  = "DecompressToScreen";
SZCODEA  szDrawToScreen[]        = "DrawToScreen";
#endif

/**************************************************************************
**************************************************************************/

#if 0
/**************************************************************************
**************************************************************************/

typedef struct {
    UINT    Usage;
    HBITMAP hbm;
    int     dx,dy;
}   BITBUF, *PBITBUF;

static BITBUF bb;

static HBITMAP AllocBitmap(int dx, int dy)
{
    return NULL;
}
#endif

/**************************************************************************
**************************************************************************/

STATICFN BOOL NEAR PASCAL DrawDibFree(PDD pdd, BOOL fSameDib, BOOL fSameSize);
STATICFN HPALETTE CreateBIPalette(HPALETTE hpal, LPBITMAPINFOHEADER lpbi);
STATICFN BOOL NEAR IsIdentityPalette(HPALETTE hpal);
STATICFN BOOL NEAR AreColorsAllGDIColors(LPBITMAPINFOHEADER lpbi);
STATICFN BOOL SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags);

static void DrawDibPalChange(PDD pdd, HDC hdc, HPALETTE hpal);
static void DrawDibClipChange(PDD pdd, UINT wFlags);
static BOOL FixUpCodecPalette(HIC hic, LPBITMAPINFOHEADER lpbi);
static BOOL SendSetPalette(PDD pdd);

#ifdef USE_DCI

#ifndef _WIN32

#define GetDS() SELECTOROF((LPVOID)&ScreenSel)

/****************************************************************************
 ***************************************************************************/
#pragma optimize("", off)
static void SetSelLimit(UINT sel, DWORD limit)
{
    if (limit >= 1024*1024l)
        limit = ((limit+4096) & ~4095) - 1;

    _asm
    {
        mov     ax,0008h            ; DPMI set limit
        mov     bx,sel
        mov     dx,word ptr limit[0]
        mov     cx,word ptr limit[2]
        int     31h
    }
}
#pragma optimize("", on)

#endif // _WIN32

/**************************************************************************
**************************************************************************/
static void InitDCI()
{
    UINT WidthBytes;

    //
    // initialize DCI and open a surface handle to it.
    //
    // if DVA = 0 in WIN.INI, don't use DCI or DVA.
    // PSS tells people to use this if they have video problems,
    // so we shouldn't change the string.
    // On NT the value is in the REGISTRY,
    // HKEY_CURRENT_USER\SOFTWARE\Microsoft\Multimedia\Drawdib
    //		REG_DWORD dva 1      dci enabled
    //		REG_DWORD dva 0      dci disabled
    // This value can also be set through the Video For Windows configuration
    // dialog (control panel, drivers, or via Mplay32 on an open avi file).
    if (!mmGetProfileIntA(szDrawDib, szDVA, TRUE))
	return;

#ifdef DAYTONA
    if (!InitialiseDCI()) return;
#endif

    hdcDCI = DCIOpenProvider();

    if (hdcDCI == NULL)	{
       DPF(("Failed to open DCI provider"));
       return;
    }

#ifndef _WIN32
    SetObjectOwner(hdcDCI, NULL); // on Win16, this is shared between
    // processes, so tell GDI not to clean it up or whine about it not
    // being freed.
#endif

#ifdef _WIN32
    DCICreatePrimary(hdcDCI, &pdci);
#else
    //
    // because we call 32-bit codecs we want a 32-bit DCI surface
    // (with a linear pointer, etc...)
    //
    dci.dwSize = sizeof(dci);
    if (DCICreatePrimary32(hdcDCI, &dci) == 0)
        pdci = &dci;
    else
        pdci = NULL;
#endif

    if (pdci == NULL) {
	DCICloseProvider(hdcDCI);
	hdcDCI = NULL;
        return;
    }

    WidthBytes = (UINT) abs(pdci->lStride);

    //
    // convert DCISURFACEINFO into a BITMAPINFOHEADER...
    //
    biScreen.bi.biSize          = sizeof(BITMAPINFOHEADER);
    biScreen.bi.biCompression   = pdci->dwCompression;

    biScreen.bi.biWidth         = WidthBytes*8/(UINT)pdci->dwBitCount;
    biScreen.bi.biHeight        = pdci->dwHeight;
    biScreen.bi.biPlanes        = 1;
    biScreen.bi.biBitCount      = (UINT)pdci->dwBitCount;
    biScreen.bi.biSizeImage     = pdci->dwHeight * WidthBytes;
    biScreen.bi.biXPelsPerMeter = WidthBytes;
    biScreen.bi.biYPelsPerMeter = 0;
    biScreen.bi.biClrUsed       = 0;
    biScreen.bi.biClrImportant  = 0;
    biScreen.dwMask[0]          = pdci->dwMask[0];
    biScreen.dwMask[1]          = pdci->dwMask[1];
    biScreen.dwMask[2]          = pdci->dwMask[2];

    if (pdci->dwCompression == 0) {
        if ((UINT)pdci->dwBitCount == 16)
	{
	    biScreen.dwMask[0] = 0x007C00;
	    biScreen.dwMask[1] = 0x0003E0;
	    biScreen.dwMask[2] = 0x00001F;
	}

	else if ((UINT)pdci->dwBitCount >= 24)

	{
	    biScreen.dwMask[0] = 0xFF0000;
	    biScreen.dwMask[1] = 0x00FF00;
	    biScreen.dwMask[2] = 0x0000FF;
	}
    }

    if (pdci->lStride > 0)
        biScreen.bi.biHeight = -(int)pdci->dwHeight;
#if 0   // BOGUS
    else
        pdci->dwOffSurface -= biScreen.bi.biSizeImage;
#endif

    if (pdci->dwDCICaps & DCI_1632_ACCESS)
    {
	biScreen.bi.biCompression = BI_1632;
	
	//
	// make sure the pointer is valid.
	//
	if (pdci->dwOffSurface >= 0x10000)
	{
	    DPF(("DCI Surface can't be supported: offset >64K"));

	    lpScreen = NULL;
	    biScreen.bi.biBitCount = 0;
	}
	else
	{
    #ifdef _WIN32
	    lpScreen = (LPVOID)MAKELONG((WORD)pdci->dwOffSurface, pdci->wSelSurface);
    #else
	    lpScreen = (LPVOID)MAKELP(pdci->wSelSurface,pdci->dwOffSurface);
    #endif
	}
    }
    else
    {
#ifdef _WIN32
	lpScreen = (LPVOID) pdci->dwOffSurface;
#else
	//
	// If we weren't given a selector, or the offset is >64K, we should
	// handle this case and reset the base of the selector.
	//
	// Also must do this for GDT selectors, or the Kernel thunking
	// code will kill us.
	//
	if (pdci->wSelSurface == 0 || pdci->dwOffSurface >= 0x10000)
	{
	    ScreenSel = AllocSelector(GetDS());

	    if (pdci->wSelSurface)
		SetSelectorBase(ScreenSel,
		    GetSelectorBase(pdci->wSelSurface) + pdci->dwOffSurface);
	    else
		SetSelectorBase(ScreenSel, pdci->dwOffSurface);

	    SetSelLimit(ScreenSel, biScreen.bi.biSizeImage - 1);

	    lpScreen = (LPVOID)MAKELP(ScreenSel,0);
	}
	else
	{
	    lpScreen = (LPVOID)MAKELP(pdci->wSelSurface,pdci->dwOffSurface);
	}
#endif
    }

    DPF(("DCI Surface: %ldx%ldx%ld, lpScreen = %08I", pdci->dwWidth, pdci->dwHeight, pdci->dwBitCount, (DWORD_PTR) lpScreen));
    DPF(("DCI Surface: biCompression= %ld '%4.4hs' Masks: %04lX %04lX %04lX",biScreen.bi.biCompression, (LPSTR) &biScreen.bi.biCompression,biScreen.dwMask[0],biScreen.dwMask[1],biScreen.dwMask[2]));

    //
    // check if the display has broken rasters.
    //

#if defined(DAYTONA) && !defined(_X86_)
    // On MIPS and other machines that have problems with
    // unaligned code we always set gfDisplayHasBrokenRasters to TRUE!
    gfDisplayHasBrokenRasters = TRUE;
#else
    gfDisplayHasBrokenRasters = (0x10000l % WidthBytes) != 0;
#endif

    if (gfDisplayHasBrokenRasters)
    {
        DPF(("*** Display has broken rasters"));
    }
}

void TermDCI()
{
    if (pdci)
    {
        DCIDestroy(pdci);
        pdci = NULL;
    }

    if (hdcDCI)
    {
	DCICloseProvider(hdcDCI);
        hdcDCI = NULL;
    }

#ifndef _WIN32
    if (ScreenSel)
    {
	SetSelLimit(ScreenSel, 0);
	FreeSelector(ScreenSel);
	ScreenSel = 0;
    }
#endif
#ifdef DAYTONA
    TerminateDCI();
#endif
}

#else
    #define InitDCI()
    #define TermDCI()
#endif

/**************************************************************************
* @doc INTERNAL DrawDib
*
* @api BOOL | DrawDibInit | This function initalizes the DrawDib library.
*
* @rdesc Returns TRUE if the library is initialized properly, otherwise
*        it returns FALSE.
*
* @comm Users don't need to call this, because <f DrawDibOpen> does it for them.
*
* @xref DrawDibTerm
*
**************************************************************************/
BOOL VFWAPI DrawDibInit()
{
    HDC hdc;

    WORD wScreenBitDepth;
    UINT wScreenWidth;
    UINT wScreenHeight;
    UINT wRasterCaps;

    hdc = GetDC(NULL);
    wScreenBitDepth = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    wScreenWidth    = GetSystemMetrics(SM_CXSCREEN);
    wScreenHeight   = GetSystemMetrics(SM_CYSCREEN);
    wRasterCaps     = GetDeviceCaps(hdc, RASTERCAPS);
    ReleaseDC(NULL, hdc);

    if (gfInit)
    {
        //
        // handle a screen res change.
        //
        if (gwScreenWidth    == wScreenWidth &&
            gwScreenHeight   == wScreenHeight &&
            gwScreenBitDepth == wScreenBitDepth)
        {
            return TRUE;
        }

        DPF(("Screen has changed from %dx%dx%d to %dx%dx%d", gwScreenWidth, gwScreenHeight, gwScreenBitDepth, wScreenWidth, wScreenHeight, wScreenBitDepth));

        DrawDibTerm();
    }

#ifndef _WIN32
    gf286 = (BOOL)(GetWinFlags() & WF_CPU286);
#endif

    gwScreenBitDepth = wScreenBitDepth;
    gwScreenWidth    = wScreenWidth;
    gwScreenHeight   = wScreenHeight;
    gwRasterCaps     = wRasterCaps;

    gfHalftone = mmGetProfileIntA(szDrawDib, szHalftone, FALSE);
    gfBitmap   = mmGetProfileIntA(szDrawDib, szDrawToBitmap, -1);
    gfBitmapX  = mmGetProfileIntA(szDrawDib, szDecompressToBitmap, TRUE);
#ifdef USE_DCI
    gfScreenX  = mmGetProfileIntA(szDrawDib, szDecompressToScreen, TRUE);
#ifdef WANT_DRAW_DIRECT_TO_SCREEN
    gfDrawX    = mmGetProfileIntA(szDrawDib, szDrawToScreen, TRUE);
#endif
#endif

#ifdef DEBUG
    gwRasterCaps = mmGetProfileIntA(szDrawDib, "RasterCaps", gwRasterCaps);
    gwScreenBitDepth = (WORD) mmGetProfileIntA(szDrawDib, "ScreenBitDepth", gwScreenBitDepth);
#ifndef _WIN32
    gf286 = GetProfileIntA(szDrawDib, "cpu", gf286 ? 286 : 386) == 286;
#endif
#endif

    InitDCI();

#ifdef DEBUG
    {
	UINT wType = GetBitmapType();

	switch(wType & BM_TYPE)
	{
	    case BM_VGA:
	  	DPF(("display format: VGA mode"));
		break;

	    case BM_1BIT:
		DPF(("display format: 1 bpp"));
		break;

	    case BM_4BIT:
		DPF(("display format: 4 bpp"));
		break;

	    case BM_8BIT:
		DPF(("display format: 8 bpp"));
		break;

	    case BM_16555:
		DPF(("display format: 16-bits, 555"));
		break;

	    case BM_24BGR:
		DPF(("display format: 24-bits BGR"));
		break;

	    case BM_32BGR:
		DPF(("display format: 32-bits BGR"));
		break;

	    case BM_16565:
		DPF(("display format: 16-bits, 565"));
		break;

	    case BM_24RGB:
	    case BM_32RGB:
		DPF(("display format: %d-bits RGB",
		    ((wType == BM_24RGB) ? 24 : 32)));
		break;

	    default:
		DPF(("display format: unknown (type %d)", wType));
		break;
	}
    }
#endif



    //
    // fix up the bit-depth of the display.
    //
    if (gwScreenBitDepth > 32)
        gwScreenBitDepth = 32;

    if (gwScreenBitDepth == 16 || gwScreenBitDepth == 32)
    {
        BITMAPINFOHEADER bi;
        UINT u;

        bi.biSize           = sizeof(bi);
        bi.biWidth          = 1;
        bi.biHeight         = 1;
        bi.biPlanes         = 1;
        bi.biBitCount       = gwScreenBitDepth;
        bi.biCompression    = 0;
        bi.biSizeImage      = 0;
        bi.biXPelsPerMeter  = 0;
        bi.biYPelsPerMeter  = 0;
        bi.biClrUsed        = 0;
        bi.biClrImportant   = 0;

        u = (UINT)DrawDibProfileDisplay(&bi);

        if (u == 0)
        {
            DPF(("Pretending display is 24 bit (not %d)", gwScreenBitDepth));
            gwScreenBitDepth = 24;
        }
    }

    gfInit = TRUE;
    return TRUE;
}

/**************************************************************************
* @doc INTERNAL DrawTerm
*
* @api BOOL | DrawDibTerm | This function teminates the DrawDib library.
*
* @rdesc Returns TRUE.
*
* @comm Users don't need to call this, because <f DrawDibClose> does it for them.
*
* @xref DrawDibInit
*
**************************************************************************/
BOOL VFWAPI DrawDibTerm()
{
    //
    //  free global stuff.
    //

    TermDCI();

    gfInit = FALSE;
    return TRUE;
}

/**************************************************************************
* @doc INTERNAL DrawDib
*
* @api void | DrawDibCleanup | clean up drawdib stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL DrawDibCleanup(HTASK hTask)
{
    if (gUsage > 0)
        RPF(("%d DrawDib handles left open", gUsage));

    DrawDibTerm();
}

/**************************************************************************
* @doc	INTERNAL
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER | lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
INLINE BOOL NEAR PASCAL DibEq(LPBITMAPINFOHEADER lpbi1,LPBITMAPINFOHEADER lpbi2)
{
    if (lpbi1 == NULL || lpbi2 == NULL)
	return FALSE;

    return
             lpbi1->biCompression == lpbi2->biCompression   &&
        (int)lpbi1->biSize        == (int)lpbi2->biSize     &&
        (int)lpbi1->biWidth       == (int)lpbi2->biWidth    &&
        (int)lpbi1->biHeight      == (int)lpbi2->biHeight   &&
        (int)lpbi1->biBitCount    == (int)lpbi2->biBitCount &&
        ((int)lpbi1->biBitCount > 8 ||
            (int)lpbi1->biClrUsed == (int)lpbi2->biClrUsed  &&
            _fmemcmp((LPBYTE)lpbi1 + lpbi1->biSize,
		(LPBYTE)lpbi2 + lpbi2->biSize,
                (int)lpbi1->biClrUsed*sizeof(RGBQUAD)) == 0);
}

/**************************************************************************
* @doc INTERNAL
*
* @api PDD NEAR | DrawDibLockNoTaskCheck | Lock the DrawDib handle.
*
* @comm No check is made on the validity of the calling task
*
* @parm HDRAWDIB | hdd | DrawDib handle.
*
* @rdesc Returns a pointer to a <t DRAWDIB_STRUCT> if successful, NULL otherwise.
*
**************************************************************************/

#define OffsetOf(s,m)	(DWORD_PTR)&(((s *)0)->m)

INLINE PDD NEAR PASCAL DrawDibLockNoTaskCheck(HDRAWDIB hdd)
{
#ifdef DEBUG
    if (OffsetOf(DRAWDIB_STRUCT, wSize) != 0) {
        DPF0(("INTERNAL FAILURE"));
        DebugBreak();
    }
#endif

    if (hdd == NULL ||
	IsBadWritePtr((LPVOID) (PDD) hdd, sizeof(DRAWDIB_STRUCT)) ||
#if defined(DAYTONA) && !defined(_X86_)
	(*(DWORD UNALIGNED *)hdd) != sizeof(DRAWDIB_STRUCT))
#else
 	((PDD)hdd)->wSize != sizeof(DRAWDIB_STRUCT))
#endif
    {

#ifndef _WIN32
#ifdef DEBUG_RETAIL
	LogParamError(ERR_BAD_HANDLE, DrawDibDraw, (LPVOID) (DWORD) (UINT) hdd);
#endif
#endif
	
	return NULL;
    }

    return (PDD) hdd;
}

/**************************************************************************
* @doc INTERNAL
*
* @api PDD NEAR | DrawDibLock | Lock the DrawDib handle.
*
* @parm HDRAWDIB | hdd | DrawDib handle.
*
* @rdesc Returns a pointer to a <t DRAWDIB_STRUCT> if successful, NULL otherwise.
*
**************************************************************************/
INLINE PDD NEAR PASCAL DrawDibLock(HDRAWDIB hdd)
{
    PDD pdd = DrawDibLockNoTaskCheck(hdd);

#ifndef _WIN32
    if (pdd && (pdd->htask != GetCurrentTask())) {
	DPF(("DrawDib handle used from wrong task!"));
#ifdef DEBUG_RETAIL
	LogParamError(ERR_BAD_HANDLE, DrawDibDraw, (LPVOID) (DWORD) (UINT) hdd);
#endif
	return NULL;

    }
#endif

    return pdd;
}


/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api HDRAWDIB | DrawDibOpen | This function opens a DrawDib context for drawing.
*
* @rdesc Returns a handle to a DrawDib context if successful,
*        otherwise it returns NULL.
*
* @comm Use this function to obtain a handle to a DrawDib context
*       before drawing device independent bitmaps.
*
*       If drawing multiple device independent bitmaps simultaneously,
*       obtain a handle to a DrawDib context for each bitmap.
*
* @xref <f DrawDibClose>
*
**************************************************************************/
HDRAWDIB VFWAPI DrawDibOpen(void)
{
    HDRAWDIB hdd;
    PDD      pdd;

    hdd = LocalAlloc(LPTR, sizeof(DRAWDIB_STRUCT));    /* zero init */

    if (hdd == NULL)
        return NULL;

    pdd = (PDD)hdd;
    pdd->wSize = sizeof(DRAWDIB_STRUCT);

#ifndef _WIN32
    pdd->htask = GetCurrentTask();
#endif

    if (gUsage++ == 0)
        DrawDibInit();

    return hdd;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibClose | This function closes a DrawDib context
*      and frees the resources DrawDib allocated for it.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @rdesc Returns TRUE if the context closed successfully.
*
* @comm Use this function to free the <p hdd> handle
*       after the application has finished drawing.
*
* @xref <f DrawDibOpen>
**************************************************************************/
BOOL VFWAPI DrawDibClose(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    DrawDibFree(pdd, FALSE, FALSE);

    pdd->wSize = 0;
    LocalFree(hdd);

    if (--gUsage == 0)
        DrawDibTerm();

    return TRUE;
}

/**************************************************************************
* @doc INTERNAL
*
* @api BOOL | DrawDibFree | Free up everything in a <t DRAWDIB_STRUCT>.
*
* @parm PDD | pdd | Pointer to a <t DRAWDIB_STRUCT>.
*
* @rdesc Returns TRUE if successful, FALSE otherwise.
*
**************************************************************************/
STATICFN BOOL NEAR PASCAL DrawDibFree(PDD pdd, BOOL fSameDib, BOOL fSameSize)
{
    if (pdd == NULL)
        return FALSE;

    //
    // If the draw palette has changed, the compressor may now be giving us DIBs
    // mapped to a different palette, so we need to clean up so we'll produce
    // a new mapping table so we'll actually draw with the new palette.
    // (see SendSetPalette)
    //
    if (!fSameDib) {
        //
        // if this palette is selected as the foreground palette
        // and we delete it we are going to hose GDI!
        //
	if (pdd->hpal)
	    DeleteObject(pdd->hpal);
	if (pdd->hpalCopy)
	    DeleteObject(pdd->hpalCopy);

        pdd->hpal = NULL;
        pdd->hpalCopy = NULL;
    }

    if (!fSameDib) {

	if (pdd->lpbi) {
	    GlobalFreePtr(pdd->lpbi);
	    pdd->lpbi = NULL;
	    pdd->lpargbqIn = NULL;
	}

        if (pdd->lpDitherTable)
        {
            DitherTerm(pdd->lpDitherTable);
	    pdd->lpDitherTable = NULL;
	}

        if (pdd->hic && pdd->hic != (HIC)-1)
        {
            ICDecompressEnd(pdd->hic);
            ICDecompressExEnd(pdd->hic);
            ICClose(pdd->hic);
        }

        pdd->ulFlags &= ~(DDF_IDENTITYPAL);
        pdd->hic  = NULL;

        pdd->iAnimateStart = 0;
        pdd->iAnimateLen = 0;
        pdd->iAnimateEnd = 0;
    }

    if (!fSameSize || !fSameDib)
    {
        if (pdd->hdcDraw) {
	    if (hbmStockMono)
		SelectObject(pdd->hdcDraw, hbmStockMono);

            DeleteDC(pdd->hdcDraw);
	}

        if (pdd->hbmDraw) {
            DeleteObject(pdd->hbmDraw);

            //
            // if we have a bitmap pointer lose it
            //
            if (pdd->ulFlags & (DDF_CANBITMAPX))
                pdd->pbBitmap = NULL;

        }

        if ((pdd->pbStretch) && (pdd->pbStretch != pdd->lpDIBSection))
            GlobalFreePtr(pdd->pbStretch);

        if ((pdd->pbDither) && (pdd->pbDither != pdd->lpDIBSection))
            GlobalFreePtr(pdd->pbDither);

        if ((pdd->pbBuffer) && (pdd->pbBuffer != pdd->lpDIBSection))
            GlobalFreePtr(pdd->pbBuffer);

#if USE_SETDI
	if (pdd->hbmDraw)
            SetBitmapEnd(&pdd->sd);
#endif

        pdd->hdcDraw = NULL;
        pdd->hbmDraw = NULL;
	pdd->lpDIBSection = NULL;
        pdd->pbStretch = NULL;
        pdd->pbDither = NULL;
        pdd->pbBuffer = NULL;

        pdd->biDraw.biBitCount = 0;
        pdd->biDraw.biWidth    = 0;
        pdd->biDraw.biHeight   = 0;

        pdd->biBuffer.biBitCount = 0;
        pdd->biBuffer.biWidth    = 0;
        pdd->biBuffer.biHeight   = 0;

        // clear all the internal flags (except palette stuff)
        pdd->ulFlags &= ~(DDF_OURFLAGS ^ DDF_IDENTITYPAL);
        pdd->ulFlags |= DDF_DIRTY;

	pdd->iDecompress = 0;
    }

    return TRUE;
}

/**************************************************************************
* @doc INTERNAL
*
* @api UINT | QueryDraw | see if the current display device
*             (DISPDIB or GDI) can draw the given dib
*
* @parm PDD | pdd | pointer to a <t DRAWDIB_STRUCT>.
*
* @parm LPBITMAPINFOHEADER | lpbi | pointer to a bitmap.
*
* @rdesc Returns display flags, see profdisp.h
*
**************************************************************************/

#ifndef DEBUG
#define QueryDraw(pdd, lpbi)  (UINT)DrawDibProfileDisplay((lpbi))
#endif

#ifndef QueryDraw
STATICFN UINT NEAR QueryDraw(PDD pdd, LPBITMAPINFOHEADER lpbi)
{
    UINT    u;

    u = (UINT)DrawDibProfileDisplay(lpbi);

    DPF(("QueryDraw (%dx%dx%d): %d", PUSHBI(*lpbi), u));
    return u;
}
#endif


/**************************************************************************
* @doc INTERNAL DrawDib
*
* @comm Called from DrawDibBegin to try decompression to a bitmap.
*
**************************************************************************/
BOOL DrawDibQueryBitmapX(
    PDD pdd
)
{
    BITMAPINFOHEADER *pbi;

#ifndef _WIN32
    if (!CanLockBitmaps()) {
        return FALSE;
    }
#endif

    if (gwScreenBitDepth == 8 && !(gwRasterCaps & RC_PALETTE))
        return FALSE;

    if ((gwRasterCaps & RC_PALETTE) && !(pdd->ulFlags & DDF_IDENTITYPAL))
        return FALSE;

    pbi = &pdd->biStretch;

    if (!GetDIBBitmap(pdd->hbmDraw, pbi))
        return FALSE;

#ifdef XDEBUG
    if (ICDecompressQuery(pdd->hic, pdd->lpbi, pbi) != ICERR_OK)
    {
        if (mmGetProfileIntA(szDrawDib, "ForceDecompressToBitmap", FALSE))
        {
            pbi->biHeight = -pbi->biHeight;
            pbi->biCompression = 0;
        }
    }
#endif
    if (ICDecompressQuery(pdd->hic, pdd->lpbi, pbi) != ICERR_OK)
    {
        if (pbi->biCompression == BI_BITMAP &&
            pbi->biSizeImage <= 128*1024l &&
            (pbi->biXPelsPerMeter & 0x03) == 0 &&
            pbi->biSizeImage > 64*1024l)
        {
            pdd->ulFlags |= DDF_HUGEBITMAP;
            pbi->biCompression = 0;

            pbi->biSizeImage -= pbi->biYPelsPerMeter;   //FillBytes

            if (ICDecompressQuery(pdd->hic, pdd->lpbi, pbi) != ICERR_OK)
                return FALSE;
        }
        else
            return FALSE;
    }

    pdd->ulFlags |= DDF_NEWPALETTE;     // force check in DrawDibRealize
    pdd->ulFlags |= DDF_CANBITMAPX;     // can decompress to bitmaps

    if (pdd->ulFlags & DDF_HUGEBITMAP)
        RPF(("    Can decompress '%4.4hs' to a HUGE BITMAP (%dx%dx%d)",(LPSTR)&pdd->lpbi->biCompression, PUSHBI(*pbi)));
    else
        RPF(("    Can decompress '%4.4hs' to a BITMAP (%dx%dx%d)",(LPSTR)&pdd->lpbi->biCompression, PUSHBI(*pbi)));

    //
    // reuse the stretch buffer for the bitmap.
    //
    pdd->biStretch = *pbi;
#ifndef _WIN32
    pdd->pbStretch = LockBitmap(pdd->hbmDraw);

    if (pdd->pbStretch == NULL)
    {
        DPF(("    Unable to lock bitmap!"));
        pdd->ulFlags &= ~DDF_CANBITMAPX; // can't decompress to bitmaps
        return FALSE;
    }
#endif

    return TRUE;
}



#define Is565(bi)   (((bi)->biCompression == BI_BITFIELDS) &&   \
		    ((bi)->biBitCount == 16) &&			\
		    (((LPDWORD)((bi)+1))[0] == 0x00F800) &&	\
		    (((LPDWORD)((bi)+1))[1] == 0x0007E0) &&	\
		    (((LPDWORD)((bi)+1))[2] == 0x00001F) )



/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibBegin | This function changes parameters
*      of a DrawDib context or it initializes a new DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to a display context for drawing (optional).
*
* @parm int | dxDest | Specifies the width of the destination rectangle.
*       Width is specified in MM_TEXT client units.
*
* @parm int | dyDest | Specifies the height of the destination rectangle.
*       Height is specified in MM_TEXT client units.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a pointer to a
*       <t BITMAPINFOHEADER> structure containing the
*       image format. The color table for the DIB follows the
*       image format.
*
* @parm int | dxSrc | Specifies the width of the source rectangle.
*       Width is specified in pixels.
*
* @parm int | dySrc | Specifies the height of the source rectangle.
*       Height is specified in pixels.
*
* @parm UNIT | wFlags | Specifies the applicable flags for
*       the function. The following flags are defined:
*
* @flag DDF_UPDATE | Indicates the last buffered bitmap is to be redrawn.
*       If drawing fails with this flag, a buffered image is not available
*       and a new image needs to be specified before the display is updated.
*
* @flag DDF_SAME_HDC | Assumes the handle to the display context
*       is already specified. When this flag is used,
*       DrawDib also assumes the correct palette has already been
*       realized into the device context (possibly by
*       <f DrawDibRealize>).
*
* @flag DDF_SAME_DRAW | Uses the drawing parameters previously
*       specified for this function.  Use this flag only
*       if <p lpbi>, <p dxDst>, <p dyDst>, <p dxSrc>, and <p dySrc>
*       have not changed since using <f DrawDibDraw> or <f DrawDibBegin>.
*
* @flag DDF_DONTDRAW | Indicates the frame is to be decompressed
*       and not drawn. The DDF_UPDATE flag can be used later
*       to actually draw the image.
*
* @flag DDF_ANIMATE | Allows palette animation. If this flag is present,
*       the palette <f DrawDib> creates will have the PC_RESERVED flag set for
*       as many entries as possible, and the palette can be animated by
*       <f DrawDibChangePalette>. If using <f DrawDibBegin> with
*       <f DrawDibDraw>, set this flag with <f DrawDibBegin>
*       rather than <f DrawDibDraw>.
*
* @flag DDF_JUSTDRAWIT | Uses GDI to draw the image. This prevents
*       the DrawDib functions from calling ICM to decompress
*       the image or prevents them from
*       using their own routines to stretch or dither the image.
*       This essentially reduces <f DrawDibDraw> to <f StretchDIBits>.
*
* @flag DDF_BACKGROUNDPAL | Realizes the palette used for drawing
*       in the background leaving the actual palette used for display
*       unchanged.  (This flag is valid only if DDF_SAME_HDC is not set.)
*
* @flag DDF_HALFTONE | Always dithers the DIB to a standard palette
*       regardless of the palette of the DIB. If using <f DrawDibBegin> with
*       <f DrawDibDraw>, set this flag with <f DrawDibBegin>
*       rather than <f DrawDibDraw>.
*
* @flag DDF_BUFFER | Indicates DrawDib should try to use a
*       offscreen buffer so DDF_UPDATE can be used. This
*       disables decompression and drawing directly to the screen.
*       If DrawDib is unable to create an offscreen buffer,
*       it will decompress or draw directly to the screen.
*
*       For more information, see the DDF_UPDATE and DDF_DONTDRAW
*       flags described for <f DrawDibDraw>.
*
*
* @rdesc Returns TRUE if successful.
*
* @comm This function prepares to draw a bitmap specified by <p lpbi>
*       to the display context <p hdc>. The image is stretched to
*       the size specified by <p dxDest> and <p dyDest>. If <p dxDest> and
*       <p dyDest> are (-1, -1), the bitmap is drawn to a
*       1:1 scale without stretching.
*
*       Use this function only if you want to prepare DrawDib
*       before using <f DrawDibDraw> to draw the image.
*       If you do not use this function, <f DrawDibDraw> implicitly
*       uses it when it draws the image.
*
*       To update the flags set with <f DrawDibBegin>, use
*       <f DrawDibEnd> to free the DrawDib context and reset
*       the flags with <f DrawDibBegin>, or specify the new flags
*       with changed values for <p dxDest>, <p dyDest>, <p lpbi>, <p dxSrc>,
*       or <p dySrc>.
*
*       When <f DrawDibBegin> is used, the <f DDF_SAME_DRAW>
*       flag is normally set for <f DrawDibDraw>.
*
*       If the parameters of <f DrawDibBegin> have not changed, subsequent
*       uses of it have not effect.
*
*       Use <f DrawDibEnd> to free memory used by the DrawDib context.
*
* @xref <f DrawDibEnd> <f DrawDibDraw>
**************************************************************************/
#ifndef _WIN32
#pragma message("Make DrawDibBegin faster for changing the size only!")
#endif

BOOL VFWAPI DrawDibBegin(HDRAWDIB hdd,
                             HDC      hdc,
                             int      dxDst,
                             int      dyDst,
                             LPBITMAPINFOHEADER lpbi,
                             int      dxSrc,
                             int      dySrc,
                             UINT     wFlags)
{
    PDD pdd;
    WORD ScreenBitDepth;
    int dxSave,dySave;
    BOOL     fNewPal;
    BOOL     fSameDib;
    BOOL     fSameSize;
    BOOL     fSameFlags;
    BOOL     fSameHdc;
    UINT    wFlagsChanged;
    DWORD   ulFlagsSave;
    LRESULT  dw;
    UINT     w;
    HPALETTE hPal;
    LONG    lSize;

    //
    // Quick sanity checks....
    //
    if (lpbi == NULL)
	return FALSE;

    if ((pdd = DrawDibLock(hdd)) == NULL)
	return FALSE;

    DrawDibInit();

    //
    // fill in defaults.
    //
    if (dxSrc < 0)
        dxSrc = (int)lpbi->biWidth;

    if (dySrc < 0)
        dySrc = (int)lpbi->biHeight;

    if (dxDst < 0)
        dxDst = dxSrc;

    if (dyDst < 0)
        dyDst = dySrc;

    if (dxSrc == 0 || dySrc == 0)	// !!! || dxDst == 0 || dyDst == 0)
	return FALSE;

    ulFlagsSave = pdd->ulFlags;
    wFlagsChanged = ((UINT)pdd->ulFlags ^ wFlags);

    fSameHdc = hdc == pdd->hdcLast;
    fSameDib  = DibEq(pdd->lpbi, lpbi) && !(wFlagsChanged & DDF_HALFTONE) &&
		    (pdd->hpalDraw == pdd->hpalDrawLast);

    fSameFlags = (pdd->ulFlags & DDF_BEGINFLAGS) == (wFlags & DDF_BEGINFLAGS);
    fSameSize = pdd->dxDst == dxDst && pdd->dyDst == dyDst &&
                pdd->dxSrc == dxSrc && pdd->dySrc == dySrc;
    pdd->hdcLast = hdc;

    // When the hpalDraw field changes, we need to tell the compressor about it
    // by calling SendSetPalette.
    // !!! NO we don't

    //
    // Do a quick check to see if the params have changed.
    // If the DIB, and size of the DIB, and flags used are the same as the last
    // time we called DrawDibBegin, then there's nothing to do and we'll only
    // waste time plodding through this code.
    // There is one case when all these could be the same, but the situation
    // has still changed enough so that we need to recompute things... if the
    // hdc is different than last time, and we're dealing with RLE.  You see,
    // we make some decisions about RLE (like we can go direct to a screen DC
    // but not a memory DC) that are affected by what hdc we're using.  So
    // we will not bail out early if we are using RLE and the hdc's are
    // different.
    //
    if (fSameDib && fSameSize && fSameFlags)
    {
	if ((lpbi->biCompression != BI_RLE8 && lpbi->biCompression != BI_RLE4)
								|| fSameHdc)
	    return TRUE;
    }

    pdd->hpalDrawLast = pdd->hpalDraw;

    RPF(("DrawDibBegin %dx%dx%d '%4.4hs' [%d %d] [%d %d]",
	    (int)lpbi->biWidth,
	    (int)lpbi->biHeight,
	    (int)lpbi->biBitCount,
                (lpbi->biCompression == BI_RGB  ? (LPSTR)"None" :
                 lpbi->biCompression == BI_RLE8 ? (LPSTR)"Rle8" :
                 lpbi->biCompression == BI_RLE4 ? (LPSTR)"Rle4" :
                 (LPSTR)&lpbi->biCompression),
	    dxSrc, dySrc, dxDst, dyDst));

    fNewPal = pdd->hpal == NULL || !fSameDib;

    //
    // make sure this palette is not the in the DC, because we
    // are going to delete it, and GDI get real upset if we do this.
    //

    if (fNewPal && pdd->hpal && hdc)
    {
        hPal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);

        if (hPal == pdd->hpal)
            RPF(("    Warning unselecting palette..."));
    }

    DrawDibFree(pdd, fSameDib, fSameSize);

    pdd->dxSrc = dxSrc;
    pdd->dySrc = dySrc;
    pdd->dxDst = dxDst;
    pdd->dyDst = dyDst;

    //
    // copy the source DIB header and the colors.
    //
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

////if (lpbi->biClrUsed != 0 && lpbi->biBitCount > 8)
////    lpbi->biClrUsed = 0;

    // Make a copy of the source format.  Remember, some codec could have
    // defined a custom format larger than a BITMAPINFOHEADER so make a copy
    // of EVERYTHING.
    if (!fSameDib) {
	lSize = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);
	pdd->lpbi = (LPBITMAPINFOHEADER)GlobalAllocPtr(GPTR, lSize);
	if (pdd->lpbi == NULL)
	    return FALSE;
	_fmemcpy(pdd->lpbi, lpbi, (int)lSize);
	// This is where the colour info is
	pdd->lpargbqIn = (LPVOID)((LPBYTE)lpbi + lpbi->biSize);
    }

    pdd->biBuffer = *lpbi;

    pdd->lpbi->biSizeImage = 0;
    pdd->biBuffer.biSizeImage = 0;

    //
    // init all other color tables to be the initial colors
    //
    if (lpbi->biBitCount <= 8)
    {
        _fmemcpy(pdd->argbq,   (LPBYTE)lpbi+(int)lpbi->biSize,
		(int)lpbi->biClrUsed * sizeof(RGBQUAD));
	_fmemcpy(pdd->aw,      (LPBYTE)lpbi+(int)lpbi->biSize,
		(int)lpbi->biClrUsed * sizeof(RGBQUAD));
    }

    // set PalUse to default: DIB_PAL_COLORS. This will be set
    // to DIB_PAL_INDICES if DrawdibCheckPalette is called and detects
    // that it is safe to use indices. DIB_PAL_COLORS is a safe
    // default.

    pdd->uiPalUse = DIB_RGB_COLORS;     // assume RGB colors for now.

    //
    // make sure the device is a palette device before dinking with
    // palette animation.
    //
    if (wFlags & DDF_ANIMATE)
    {
	if (!(gwRasterCaps & RC_PALETTE) ||
            (int)lpbi->biBitCount > 8 || pdd->hpalDraw)
	    wFlags &= ~DDF_ANIMATE;
    }

    //
    // copy the flags
    //
try_again:
    pdd->ulFlags &= ~DDF_USERFLAGS;
    pdd->ulFlags |= (wFlags & DDF_USERFLAGS);

    pdd->ulFlags &= ~DDF_UPDATE;

    //
    // deal with a decompressor if needed.
    //
    switch (lpbi->biCompression)
    {
        case BI_RGB:
            break;

        default:
            //
            //  see if the DISPLAY/DISPDIB can draw the format directly!
            //
	    //  if the buffer flag is set we MUST use a decompress buffer.
	    //  regardless of what the display can do
	    //
	    if (wFlags & DDF_BUFFER)
		w = 0;
	    else
                w = QueryDraw(pdd, lpbi);

            if (w & PD_CAN_DRAW_DIB)
            {
                if (((dxSrc == dxDst && dySrc == dyDst) && (w & PD_STRETCHDIB_1_1_OK)) ||
                    ((dxSrc != dxDst || dySrc != dyDst) && (w & PD_STRETCHDIB_1_N_OK)) ||
                    ((dxDst % dxSrc) == 0 && (dyDst % dySrc) == 0 && (w & PD_STRETCHDIB_1_2_OK)))
                {
		    // GDI can't handle drawing RLEs to a memory DC so we will
		    // have to pretend that RLE can't be drawn to the screen
		    // and decompress it first.
		    // We also can't DITHER RLE, so if we're running on a
		    // 16 colour display, make sure we're using a decompressor.
		    if (((lpbi->biCompression != BI_RLE8) &&
				(lpbi->biCompression != BI_RLE4)) ||
			(hdc && IsScreenDC(hdc) && gwScreenBitDepth >=8))
		    {
                	wFlags |= DDF_JUSTDRAWIT;

                	if (pdd->hic)
                	    ICClose(pdd->hic);

                	pdd->hic = NULL;
                	goto no_decomp;
		    }
                }
            }

            if (pdd->hic == NULL)
            {
		DWORD fccHandler;

		fccHandler = 0;

		if (lpbi->biCompression == BI_RLE8)
		    fccHandler = mmioFOURCC('R','L','E',' ');
		
                pdd->hic = ICLocate(ICTYPE_VIDEO,
				    fccHandler,
				    lpbi, NULL,
				    ICMODE_FASTDECOMPRESS);

                if (pdd->hic == NULL)
		    pdd->hic = ICDecompressOpen(ICTYPE_VIDEO,
						fccHandler,lpbi,NULL);
		
		if (pdd->hic)
		{
		    //
		    //  make sure the codec uses its default palette out of the gate
		    //
		    if (ICDecompressSetPalette(pdd->hic, NULL) == ICERR_OK)
		    {
			pdd->ulFlags |= DDF_CANSETPAL;
			RPF(("    codec supports ICM_SET_PALETTE"));
		    }
		    else
		    {
			pdd->ulFlags &= ~DDF_CANSETPAL;
		    }
		}
	    }

            if (pdd->hic == NULL || pdd->hic == (HIC)-1)
            {
                RPF(("    Unable to open compressor '%4.4ls'",(LPSTR)&lpbi->biCompression));
		pdd->hic = (HIC)-1;

		if (wFlags & DDF_BUFFER)
		{
		    RPF(("   Turning DDF_BUFFER off"));
		    wFlags &= ~DDF_BUFFER;
		    goto try_again;
		}

                return FALSE;
            }

            //
	    //  now find the best DIB format to decompress to.
	    //
            if (!ICGetDisplayFormat(pdd->hic, lpbi, &pdd->biBuffer,
                   (gfHalftone || (wFlags & DDF_HALFTONE)) ? 16 : 0,
                   MulDiv(dxDst,abs((int)lpbi->biWidth),dxSrc),
                   MulDiv(dyDst,abs((int)lpbi->biHeight),dySrc)))
            {
                RPF(("    Compressor error!"));
codec_error:
		// ICClose(pdd->hic);
                // pdd->hic = (HIC)-1;
                return FALSE;
            }

            // Indeo5 codec has a bug where asking it to stretch by 2 and
            // produce 32 bit RGB will only produce black frames, so ask it to
            // do 24 bit instead. (bug 402298)
            if ( pdd->biBuffer.biBitCount == 32 &&
                       pdd->biBuffer.biCompression == 0 &&
                       lpbi->biCompression ==  mmioFOURCC('I','V','5','0') &&
                       pdd->biBuffer.biWidth == 2 * lpbi->biWidth &&
                       pdd->biBuffer.biHeight == 2 * lpbi->biHeight) {
                pdd->biBuffer.biBitCount = 24;
                // biSizeImage will get fixed up below
            }

            //
            // we have new source params
            //
            dxSrc = MulDiv(dxSrc, abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
            dySrc = MulDiv(dySrc, abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
//          xSrc  = MulDiv(xSrc,  abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
//          ySrc  = MulDiv(ySrc,  abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);

            //
            // now allocate the decompress buffer!
            //
            pdd->biBuffer.biSizeImage = DIBSIZEIMAGE(pdd->biBuffer);

//Question: do we need to zeroinit the allocated buffer??
//SD
            pdd->pbBuffer = GlobalAllocPtr(GMEM_MOVEABLE,pdd->biBuffer.biSizeImage);
//          pdd->pbBuffer = GlobalAllocPtr(GHND,pdd->biBuffer.biSizeImage);

            if (pdd->pbBuffer == NULL)
            {
                RPF(("    No Memory for decompress buffer"));
                ICClose(pdd->hic);
		pdd->hic = (HIC)-1;
                return FALSE;
            }
            pdd->ulFlags |= DDF_DIRTY;

            dw = ICDecompressBegin(pdd->hic, lpbi, &pdd->biBuffer);

            if (dw != ICERR_OK)
            {
                RPF(("    Compressor failed ICM_DECOMPRESS_BEGIN"));
		goto codec_error;
            }

            RPF(("    Decompressing '%4.4hs' to %dx%dx%d%s",(LPSTR)&lpbi->biCompression, PUSHBI(pdd->biBuffer),
			     	Is565(&pdd->biBuffer) ? (LPSTR) "(565)" : (LPSTR) ""
	       ));
	    pdd->iDecompress = DECOMPRESS_BUFFER;
	    _fmemcpy(pdd->aw,pdd->argbq, 256*sizeof(RGBQUAD));
            lpbi = &pdd->biBuffer;
            break;
    }
no_decomp:
    pdd->biDraw = pdd->biBuffer;
    pdd->biDraw.biSizeImage = 0;

    pdd->biDraw.biHeight = abs((int)pdd->biDraw.biHeight);

    if ((!(wFlags & DDF_JUSTDRAWIT)) && (lpbi->biCompression == BI_RGB))
    {
        //
        //  test the display device for this DIB format
        //
        w = QueryDraw(pdd, lpbi);

        //
        // get the bit depth of the screen device.
        //
        ScreenBitDepth = gwScreenBitDepth;

        if (ScreenBitDepth > 24)
	    ScreenBitDepth = 32;        //???!!!

        // does the display support drawing 16bpp DIBs?
        // if it does not, treat it like a 24bpp device.

        if (ScreenBitDepth >= 24 && lpbi->biBitCount == 32 && !(w & PD_CAN_DRAW_DIB))
            ScreenBitDepth = 24;

        if (ScreenBitDepth >= 16 && lpbi->biBitCount == 16 && !(w & PD_CAN_DRAW_DIB))
            ScreenBitDepth = 24;

        //
        // check if the display driver isn't very good for this format
        //
        if (!(w & PD_STRETCHDIB_1_1_OK))
        {
	    pdd->ulFlags |= DDF_BITMAP;
        }

        //
        //  if the display driver isn't very good make a bitmap to copy into
        //  to draw.
        //
        switch (gfBitmap)
        {
            case 0:
                pdd->ulFlags &= ~DDF_BITMAP;
                break;

            case 1:
                pdd->ulFlags |= DDF_BITMAP;
                break;
        }

#ifndef _WIN32	// !!! why only !WIN32?
	//
	// for 16/32 bit DIBs, the display may not support DIBS at all and
	// we should use bitmaps anyway just in case, even if the user
	// tried to override
	//
	if ((pdd->biDraw.biBitCount == 16 || pdd->biDraw.biBitCount == 32) &&
	    w == PD_CAN_DRAW_DIB)
	{
	    pdd->ulFlags |= DDF_BITMAP;
	}
#endif

        if ((dxSrc != dxDst || dySrc != dyDst) && !(w & PD_STRETCHDIB_1_N_OK))
	    pdd->ulFlags |= DDF_STRETCH;

        if (dxSrc*2 == dxDst && dySrc*2 == dyDst && (w & PD_STRETCHDIB_1_2_OK))
	    pdd->ulFlags &= ~DDF_STRETCH;

        if ((dxDst % dxSrc) == 0 && (dyDst % dySrc) == 0 && (w & PD_STRETCHDIB_1_2_OK))
	    pdd->ulFlags &= ~DDF_STRETCH;

        if ((int)lpbi->biBitCount > ScreenBitDepth) {
            DPF(("Turning on DITHER as bitcount is greater than screen bit depth"));
            pdd->ulFlags |= DDF_DITHER;
        }

        //
        //  force halftone palette
        //
        if ((gfHalftone || (wFlags & DDF_HALFTONE)) && ScreenBitDepth <= 8) {
            DPF(("Turning on DITHER because of halftoning\n"));
            pdd->ulFlags |= DDF_DITHER;
        }

        // NOTE we treat a convert up (ie 16->24) as a dither too.
        if ((int)lpbi->biBitCount > 8 && (int)lpbi->biBitCount < ScreenBitDepth) {
            DPF(("Turning on DITHER as bitcount does not match screen bit depth"));
            pdd->ulFlags |= DDF_DITHER;
        }

	if (pdd->ulFlags & DDF_DITHER) {
	    if (lpbi->biBitCount == 16 && (w & PD_CAN_DRAW_DIB)) {
	    pdd->ulFlags &= ~DDF_DITHER;
		DPF(("Turning off DITHER for 16-bit DIBs, since we can draw them"));
	    }

	    if (lpbi->biBitCount == 32 && (w & PD_CAN_DRAW_DIB)) {
		pdd->ulFlags &= ~DDF_DITHER;
		DPF(("Turning off DITHER for 32-bit DIBs, since we can draw them"));
	    }

	    if (lpbi->biBitCount == 8 &&
				lpbi->biClrUsed <= 16 &&
				AreColorsAllGDIColors(lpbi)) {
		pdd->ulFlags &= ~DDF_DITHER;
		DPF(("Turning off DITHER for 8-bit DIBs already using the VGA colors"));
	    }
	}

	// force stretching in drawdib if we are dithering
	if ((pdd->ulFlags & DDF_DITHER) &&
	    ((dxSrc != dxDst) || (dySrc != dyDst))) {
		pdd->ulFlags |= DDF_STRETCH;
	}

        //
        // Force a buffer if we dont have one.  We only buffer if we're
	// decompressing or dithering or stretching or using bitmaps, so our
	// hacky way of forcing a buffer is to pretend we're stretching 1:1.
        //
        if ((pdd->ulFlags & DDF_BUFFER) &&
            pdd->hic == NULL &&
            !(pdd->ulFlags & DDF_DITHER) &&
            !(pdd->ulFlags & DDF_STRETCH) &&
            !(pdd->ulFlags & DDF_BITMAP))
        {
            RPF(("    Using a buffer because DDF_BUFFER is set."));
            pdd->ulFlags |= DDF_STRETCH;    // force a 1:1 stretch
        }

	if (lpbi->biBitCount != 8
		    && lpbi->biBitCount != 16
		    && lpbi->biBitCount != 24
#ifndef _WIN32
		    && lpbi->biBitCount != 32
#endif
	    ) {
            DPF(("Turning off stretch for an unsupported format...."));
            pdd->ulFlags &= ~(DDF_STRETCH);
        }

    }

    //
    // delete the palette if we are changing who dithers.
    //
    if (pdd->hpal &&
        pdd->lpbi->biBitCount > 8 &&
        ((pdd->ulFlags ^ ulFlagsSave) & (DDF_DITHER)))
    {
        DPF(("    Dither person has changed..."));

        if (pdd->lpDitherTable)
        {
            DitherTerm(pdd->lpDitherTable);
	    pdd->lpDitherTable = NULL;
	}

        if (hdc) {
            hPal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);

            if (hPal == pdd->hpal)
	        RPF(("    Warning unselecting palette..."));
        }

        DeleteObject(pdd->hpal);
	if (pdd->hpalCopy)
            DeleteObject(pdd->hpalCopy);
        pdd->hpal = NULL;
        pdd->hpalCopy = NULL;
    }

    if (pdd->ulFlags & DDF_STRETCH)
    {
        /* the code for stretching *only* works on a 386+ */
        if (gf286 || pdd->biBuffer.biBitCount < 8)
        {
            RPF(("    Using GDI to stretch"));
	    pdd->ulFlags &= ~DDF_STRETCH;
        }
        else
        {
            //
            // we have stretching to do, this requires extra
            // headers and buffers.
            //
            pdd->biStretch = pdd->biBuffer;
            pdd->biStretch.biWidth = dxDst;
            pdd->biStretch.biHeight = dyDst;
            pdd->biStretch.biSizeImage = DIBSIZEIMAGE(pdd->biStretch);

            pdd->pbStretch = GlobalAllocPtr(GHND,pdd->biStretch.biSizeImage);

            if (pdd->pbStretch == NULL)
            {
                RPF(("    No memory for stretch buffer, using GDI"));
		pdd->ulFlags &= ~DDF_STRETCH;
            }
            else
            {
                RPF(("    Stretching %dx%dx%d%s --> %dx%dx%d",
			    dxSrc, dySrc, (int)lpbi->biBitCount,
			    (LPSTR) (Is565(lpbi) ? "(565)":""),
			    dxDst, dyDst, (int)pdd->biStretch.biBitCount,
			    (LPSTR) (Is565(&pdd->biStretch) ? "(565)":"")
		   ));
                pdd->biDraw.biWidth = dxDst;
                pdd->biDraw.biHeight = dyDst;
                dxSrc = dxDst;
                dySrc = dyDst;
                lpbi = &pdd->biStretch;
            }
        }
    }

    if (pdd->ulFlags & DDF_DITHER)
    {
	pdd->ulFlags &= ~DDF_ANIMATE;        // cant  animate and dither!

        if (ScreenBitDepth <= 8)
            pdd->biDraw.biBitCount = 8;
        else if (lpbi->biBitCount <= 8)
            pdd->biDraw.biBitCount = lpbi->biBitCount;
        else
////////////pdd->biDraw.biBitCount = 24; //!!! what about 16bit DIB support
            pdd->biDraw.biBitCount = ScreenBitDepth;

        w = QueryDraw(pdd, &pdd->biDraw);

        if (w & PD_STRETCHDIB_1_1_OK)
	    pdd->ulFlags &= ~DDF_BITMAP;
        else
	    pdd->ulFlags |= DDF_BITMAP;

	// this is wrong isn't it ? biDraw will be set to
	// dxDst if we are stretching, or dxSrc if not. If we are asked to
	// dither and stretch together, and we choose to leave the stretching
	// to GDI, we will here set biDraw so that we ask the dither code
	// to dither from dx/dySrc to dx/dyDst - ie stretch and dither in
	// one go. Our current dither code will crash if you ask it to do this.
        dxSave = (int)pdd->biDraw.biWidth;
        dySave = (int)pdd->biDraw.biHeight;
#if 0
        pdd->biDraw.biWidth  = lpbi->biWidth;
        pdd->biDraw.biHeight = lpbi->biHeight;
#endif

	// !!! So DrawDibDraw will not DebugBreak
	pdd->biDraw.biWidth = dxSrc;
	pdd->biDraw.biHeight = dySrc;
        pdd->biDraw.biSizeImage = DIBSIZEIMAGE(pdd->biDraw);

        RPF(("    Dithering %dx%dx%d --> %dx%dx%d", PUSHBI(*lpbi), PUSHBI(pdd->biDraw)));

        //
        //  NOTE we need to use &pdd->biBuffer *not* lpbi because in the
        //  stretched case lpbi will point to pdd->biStretch and biStretch
        //  has NO COLOR TABLE
        //
        pdd->lpDitherTable = DitherInit(&pdd->biBuffer, &pdd->biDraw,
            &pdd->DitherProc, pdd->lpDitherTable);

        if (pdd->lpDitherTable == (LPVOID)-1 ||
            pdd->DitherProc == NULL ||
            !(pdd->pbDither = GlobalAllocPtr(GHND,pdd->biDraw.biSizeImage)))
        {
            if (pdd->lpDitherTable == (LPVOID)-1)
                pdd->lpDitherTable = NULL;

            if (pdd->lpDitherTable)
                DitherTerm(pdd->lpDitherTable);

	    if ((pdd->pbDither) && (pdd->pbDither != pdd->lpDIBSection))
                GlobalFreePtr(pdd->pbDither);

            pdd->lpDitherTable = NULL;
            pdd->pbDither = NULL;
            pdd->biDraw.biBitCount = pdd->biBuffer.biBitCount;
            pdd->biDraw.biWidth  = dxSave;
            pdd->biDraw.biHeight = dySave;
            pdd->biDraw.biSizeImage = 0;
	    pdd->ulFlags &= ~DDF_DITHER;

#ifdef DEBUG_RETAIL
            if (pdd->DitherProc)
                RPF(("    No Memory for dither tables!"));
            else
                RPF(("    No DitherProc!"));
#endif
        }
    }

    //
    // create a palette (if needed)
    //
    if ((gwRasterCaps & RC_PALETTE) &&
	pdd->biDraw.biBitCount <= 8 &&
        pdd->hpal == NULL)
    {
	pdd->hpal = CreateBIPalette(pdd->hpal, &pdd->biDraw);
        pdd->ulFlags |= DDF_NEWPALETTE;
    }

    //
    // make sure we treat the palette as new when starting/stopping animate
    //
    if (wFlagsChanged & DDF_ANIMATE)
    {
        pdd->ulFlags |= DDF_NEWPALETTE;
    }

    //
    // check for a identity palette
    //
    if (pdd->hpal == NULL)
    {
        pdd->ClrUsed = 0;
    }
    else if (pdd->ulFlags & DDF_NEWPALETTE)
    {
#ifdef _WIN32
        if (HIWORD(pdd->ClrUsed!=0)) {
            DPF(("Hiword of variable non zero before calling GetObject\n"));
        }
#endif
        GetObject(pdd->hpal,sizeof(int),(LPVOID)&pdd->ClrUsed);

        if (wFlagsChanged & DDF_ANIMATE)
            SetPalFlags(pdd->hpal,0,pdd->ClrUsed,0);

	if (IsIdentityPalette(pdd->hpal))
	{
	    pdd->ulFlags |= DDF_IDENTITYPAL;
	    pdd->iAnimateStart = 10;
	}
	else
	{
	    pdd->ulFlags &= ~DDF_IDENTITYPAL;
	    pdd->iAnimateStart = 0;
	}

	pdd->iAnimateLen = min(236,pdd->ClrUsed);
	pdd->iAnimateEnd = pdd->iAnimateStart + pdd->iAnimateLen;

	if (pdd->ulFlags & DDF_ANIMATE)
        {
            RPF(("    Palette animation"));
            SetPalFlags(pdd->hpal,pdd->iAnimateStart,pdd->iAnimateLen,PC_RESERVED);
        }
    }

    //
    // because of bugs in GDIs StretchDIBits (doing a stretch) we
    // always set the number of colors to be the maximum.
    //
    // this is not a big deal because we are mostly drawing full-color-table
    // DIBs any way.
    //
    if (pdd->biDraw.biBitCount <= 8)
        pdd->biDraw.biClrUsed = (1 << (int)pdd->biDraw.biBitCount);
    else
        pdd->biDraw.biClrUsed = 0;

    DrawDibSetPalette(hdd, pdd->hpalDraw);

    if (pdd->hpal)
    {
        if (pdd->ulFlags & DDF_IDENTITYPAL)
            RPF(("    Drawing with an identity palette"));
        else
            RPF(("    Drawing with a non-identity palette"));
    }

    if (pdd->uiPalUse == DIB_RGB_COLORS)
	RPF(("    Using DIB_RGB_COLORS"));
    else
	RPF(("    Using DIB_PAL_COLORS"));

    if (pdd->hpalDraw)
        RPF(("    Mapping to another palette"));

    if (pdd->ulFlags & DDF_BITMAP)
    {
        BOOL fGetDC;
        BOOL f;
        HWND hwndActive;

        RPF(("    Display driver slow for DIBs, using bitmaps"));

        if (fGetDC = (hdc == NULL))
        {
            hwndActive = GetActiveWindow();
            hdc = GetDC(hwndActive);
        }

        if (pdd->hdcDraw) {
	    if (hbmStockMono) {
		SelectObject(pdd->hdcDraw, hbmStockMono);
	    }
	} else /* if (!pdd->hdcDraw) */ {
	    pdd->hdcDraw = CreateCompatibleDC(hdc);
	}

        if (pdd->hbmDraw) {
	    // This fixes a memory leak.  Perhaps we can just use the old one?
	    DPF(("Freeing hbmDraw!\n"));
            DeleteObject(pdd->hbmDraw);
	}

        //
        // NOTE the bitmap must be as wide as the source DIB when we are
        // using SetDIBits() because SetDIBits() only takes a start scan not a (x,y)
        //
//      pdd->hbmDraw = CreateCompatibleBitmap(hdc, (int)pdd->biDraw.biWidth, (int)pdd->biDraw.biHeight);
        pdd->hbmDraw = CreateCompatibleBitmap(hdc, (int)pdd->biDraw.biWidth, dySrc);

        if (pdd->hbmDraw == NULL || pdd->hdcDraw == NULL)
            goto bitmap_fail;

        hbmStockMono = SelectObject(pdd->hdcDraw,pdd->hbmDraw);

        pdd->ulFlags |= DDF_NEWPALETTE;

#if USE_SETDI
        f = SetBitmapBegin(
		    &pdd->sd,       //  structure
		    hdc,            //  device
		    pdd->hbmDraw,   //  bitmap to set into
		    &pdd->biDraw,   //  --> BITMAPINFO of source
                    pdd->uiPalUse);
#else
        f = TRUE;
#endif
        if (!f)
        {
bitmap_fail:
            if (pdd->hdcDraw) {
                DeleteDC(pdd->hdcDraw);
		pdd->hdcDraw = NULL;
	    }

            if (pdd->hbmDraw) {
                DeleteObject(pdd->hbmDraw);
		pdd->hbmDraw = NULL;
	    }

            pdd->ulFlags &= ~DDF_BITMAP;
        }

        if (fGetDC)
        {
            ReleaseDC(hwndActive, hdc);
            hdc = NULL;
        }
    }

    //
    // Use CreateDibSection unless we're in VGA mode, or we're not
    // decompressing, stretching, or dithering.
    //
    if (ScreenBitDepth > 4 &&
		(pdd->hic || (pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)))) {
	BOOL fGetDC;
	HWND hwndActive;
	HPALETTE hpalOld = NULL;

	if (pdd->hbmDraw) {
	    // !!! Shouldn't we really not delete these until after we know
	    // we can use CreateDIBSection?
	    SelectObject(pdd->hdcDraw, hbmStockMono);
	    DeleteObject(pdd->hbmDraw);
	    DeleteDC(pdd->hdcDraw);
	    pdd->hdcDraw = NULL;
	    pdd->hbmDraw = NULL;
	}

	if (fGetDC = (hdc == NULL))
	{
	    hwndActive = GetActiveWindow();
	    hdc = GetDC(hwndActive);
	}

	if (pdd->hpalDraw || pdd->hpal) {
	    hpalOld = SelectPalette(hdc,
				    pdd->hpalDraw ? pdd->hpalDraw :
						    pdd->hpal,
				    TRUE);
	}
						
	pdd->hbmDraw = CreateDIBSection(
				hdc,
				(LPBITMAPINFO)&pdd->biDraw,
                                // we don't want to use DIB_PAL_INDICES for create dib section
                                (pdd->uiPalUse == DIB_RGB_COLORS) ? DIB_RGB_COLORS : DIB_PAL_COLORS,
				&pdd->lpDIBSection,
				0,	// handle to section
				0);	// offset within section

	pdd->hdcDraw = CreateCompatibleDC(hdc);

	if ((pdd->hdcDraw == NULL) ||
			(pdd->hbmDraw == NULL) ||
	    (pdd->lpDIBSection == NULL)) {

		if (pdd->hdcDraw)
		    DeleteDC(pdd->hdcDraw);

		if (pdd->hbmDraw)
		    DeleteObject(pdd->hbmDraw);

		pdd->lpDIBSection = NULL;
		pdd->hdcDraw = NULL;
		pdd->hbmDraw = NULL;

		RPF(("CreateDIBSection FAILED"));

	} else {
	    hbmStockMono = SelectObject(pdd->hdcDraw,pdd->hbmDraw);

	    // make sure we decomp, stretch or dither into the right place

	    if (pdd->pbDither) {
		GlobalFreePtr(pdd->pbDither);
		pdd->pbDither = pdd->lpDIBSection;
	    } else if (pdd->pbStretch) {
		GlobalFreePtr(pdd->pbStretch);
		pdd->pbStretch = pdd->lpDIBSection;
	    } else if (pdd->pbBuffer) {
		GlobalFreePtr(pdd->pbBuffer);
		pdd->pbBuffer = pdd->lpDIBSection;
	    }
	}

	if (fGetDC)
	{
	    if (hpalOld)
		SelectPalette(hdc, hpalOld, FALSE);
	    ReleaseDC(hwndActive, hdc);
	    hdc = NULL;
	}

    } else {

    // We are NOT using DIBSection.  We might have an old one sitting around,
    // so clear it out.  The reason we might have an old one sitting around is
    // that deciding whether or not to try to draw RLE directly or to decompress
    // it first to RGB (based on if our DC is a screen DC or not - because of a
    // GDI bug that can't draw RLE deltas to memory DCs) can affect whether or
    // not we use DIBSections, and our code at the beginning of DrawDibBegin is
    // not smart enough to call DrawDibFree in this case to clear this stuff
    // out.  I hate this code. - DannyMi

    // NOTE:  This code appears at least 3 times in this file.

        if (pdd->hdcDraw) {
	    if (hbmStockMono)
		SelectObject(pdd->hdcDraw, hbmStockMono);

            DeleteDC(pdd->hdcDraw);
	    pdd->hdcDraw = NULL;
	}

        if (pdd->hbmDraw) {
            DeleteObject(pdd->hbmDraw);
	    pdd->hbmDraw = NULL;
        }

	// I have to throw away these if I'm throwing away the DIB section, so
	// we don't end up trying to free it twice.
	if (pdd->pbDither == pdd->lpDIBSection)
	    pdd->pbDither = NULL;
	if (pdd->pbStretch == pdd->lpDIBSection)
	    pdd->pbStretch = NULL;
	if (pdd->pbBuffer == pdd->lpDIBSection)
	    pdd->pbBuffer = NULL;

	pdd->lpDIBSection = NULL;
    }

    //
    //  now try to decompress to a bitmap, we only decompress to
    //  bitmaps if the following is true.
    //
    //      the decompressor must decompress direct, we will not
    //      stretch/dither afterward
    //
    //      if on a palette device, the color table must be 1:1
    //
    //  we should check a decompressor flag
    //
    if (pdd->hic &&
	!(pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)) &&
        gfBitmapX &&
	(pdd->lpDIBSection == NULL) &&
        (dxDst == pdd->lpbi->biWidth) &&
        (dyDst == pdd->lpbi->biHeight)
        )
    {

        if (pdd->ulFlags & DDF_BITMAP) {
            if (pdd->hbmDraw) {
                DrawDibQueryBitmapX(pdd);
            }
        } else {

            //even though we decided not to use bitmaps, it might still
            //be worth trying decompression to bitmaps. the DDF_BITMAP
            //flag is based on a comparison of StretchDIBits vs
            //SetDIBits+BitBlt. Decompressing to a bitmap could be
            //faster even when SetDIBits+Bitblt is slower
            // but in this case, if we fail, we have to make sure we don't
            // end up doing DDF_BITMAP as we know that's slower.

            if (QueryDraw(pdd, &pdd->biBuffer) & PD_BITBLT_FAST) {

                BOOL fGetDC;
                HWND hwndActive;

                RPF(("    Not using BITMAPS, but trying Decomp to Bitmap"));

                if (fGetDC = (hdc == NULL))
                {
                    hwndActive = GetActiveWindow();
                    hdc = GetDC(hwndActive);
                }

                pdd->hdcDraw = CreateCompatibleDC(hdc);
                pdd->hbmDraw = CreateCompatibleBitmap(hdc, (int)pdd->biDraw.biWidth, (int)pdd->biDraw.biHeight);

                if ((pdd->hbmDraw != NULL) && (pdd->hdcDraw != NULL)) {

                    hbmStockMono = SelectObject(pdd->hdcDraw,pdd->hbmDraw);

                    if (fGetDC)
                    {
                        ReleaseDC(hwndActive, hdc);
                        hdc = NULL;
                    }

                    DrawDibQueryBitmapX(pdd);
                }

                if (!(pdd->ulFlags & DDF_CANBITMAPX)) {
                        if (pdd->hdcDraw) {
                            DeleteDC(pdd->hdcDraw);
			    pdd->hdcDraw = NULL;
			}

                        if (pdd->hbmDraw) {
                            DeleteObject(pdd->hbmDraw);
			    pdd->hbmDraw = NULL;
			}
                }
            }
        }
    }

#ifdef USE_DCI
    //
    //  see if the decompressor can decompress directly to the screen
    //  doing everything, stretching and all.
    //
    if (pdd->hic && pdci && gfScreenX)
    {
        if (wFlags & DDF_BUFFER)
        {
            DPF(("    DDF_BUFFER specified, unable to decompres to screen"));
            goto cant_do_screen;
        }

        // Indeo5 codec has a bug where asking it to stretch by 2 and
        // produce 32 bit RGB will only produce black frames, so disable DCI
        // if it would do this
        if ( biScreen.bi.biBitCount == 32 &&
                   pdd->lpbi->biCompression ==  mmioFOURCC('I','V','5','0') &&
                   pdd->dxDst == 2 * pdd->lpbi->biWidth &&
                   pdd->dyDst == 2 * pdd->lpbi->biHeight) {
            DPF(("    Indeo 5 bug - unable to decompres to screen"));
            goto cant_do_screen;
        }

	//
	// try to decompress to screen.
	//
        if (((gwRasterCaps & RC_PALETTE) && !(pdd->ulFlags & DDF_IDENTITYPAL)) ||
            (gwScreenBitDepth == 8 && !(gwRasterCaps & RC_PALETTE)) ||
            (pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)) ||
            (ICDecompressExQuery(pdd->hic, 0,
				pdd->lpbi, NULL, 0, 0, pdd->dxSrc, pdd->dySrc,
				(LPBITMAPINFOHEADER) &biScreen, lpScreen,
				0, 0, pdd->dxDst, pdd->dyDst) != ICERR_OK))
	{
cant_do_screen:
	    ; // we can't decompress to the screen
	}
	else
	{   // we can decompress to the screen
	    pdd->ulFlags |= DDF_CLIPCHECK;  // we need clipping checking
	    pdd->ulFlags |= DDF_NEWPALETTE; // force check in DrawDibRealize
	    pdd->ulFlags |= DDF_CANSCREENX; // we can decompress to screen
	    pdd->ulFlags |= DDF_CLIPPED;    // we are initialized for clipped now

	    RPF(("    Can decompress '%4.4hs' to the SCREEN",(LPSTR)&pdd->lpbi->biCompression));
	}
    }

#ifdef WANT_DRAW_DIRECT_TO_SCREEN
    //
    //  see if we can draw direct to the screen
    //
    if (pdd->hic && pdci && gfDrawX)
    {
        if (TRUE)
            goto cant_draw_screen;

        pdd->ulFlags |= DDF_CLIPCHECK;  // we need clipping checking
        pdd->ulFlags |= DDF_NEWPALETTE; // force check in DrawDibRealize
        pdd->ulFlags |= DDF_CANDRAWX;   // we can decompress to screen
        pdd->ulFlags |= DDF_CLIPPED;    // we are initialized for clipped now

        RPF(("    Can draw to the SCREEN"));

cant_draw_screen:
        ;
    }
#endif

#endif

    //
    // see if the source cordinates need translated
    //
    if (abs((int)pdd->biBuffer.biWidth)  != (int)pdd->lpbi->biWidth ||
        abs((int)pdd->biBuffer.biHeight) != (int)pdd->lpbi->biHeight)
    {
        pdd->ulFlags |= DDF_XLATSOURCE;
    }

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibEnd | This function frees a DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies the handle to the DrawDib context to free.
*
* @rdesc Returns TRUE if successful.
*
* @comm Any flags set or palette changes made by <f DrawDibBegin> or
*       <f DrawDibDraw> is discarded by <f DrawDibEnd>.
*
**************************************************************************/
BOOL VFWAPI DrawDibEnd(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    DrawDibFree(pdd, FALSE, FALSE);

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibTime | Returns timing information about
*       the drawing during debug operation.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm LPDRAWDIBTIME | lpddtime | Specifies a pointer to
*       a <t DRAWDIBTIME> structure.
*
* @rdesc Returns TRUE if successful.
*
**************************************************************************/
BOOL VFWAPI DrawDibTime(HDRAWDIB hdd, LPDRAWDIBTIME lpddtime)
{
#ifdef DEBUG_RETAIL
    PDD pdd;

    if ((pdd = DrawDibLockNoTaskCheck(hdd)) == NULL)
        return FALSE;

    if (lpddtime)
        *lpddtime = pdd->ddtime;

    if (pdd->ddtime.timeCount > 0)
    {
        RPF(("timeCount:       %u",        (UINT)pdd->ddtime.timeCount));
        RPF(("timeDraw:        %ums (%u)", (UINT)pdd->ddtime.timeDraw, (UINT)pdd->ddtime.timeDraw/(UINT)pdd->ddtime.timeCount));
        RPF(("timeDecompress:  %ums (%u)", (UINT)pdd->ddtime.timeDecompress, (UINT)pdd->ddtime.timeDecompress/(UINT)pdd->ddtime.timeCount));
        RPF(("timeDither:      %ums (%u)", (UINT)pdd->ddtime.timeDither, (UINT)pdd->ddtime.timeDither/(UINT)pdd->ddtime.timeCount));
        RPF(("timeStretch:     %ums (%u)", (UINT)pdd->ddtime.timeStretch, (UINT)pdd->ddtime.timeStretch/(UINT)pdd->ddtime.timeCount));
        RPF(("timeSetDIBits:   %ums (%u)", (UINT)pdd->ddtime.timeSetDIBits, (UINT)pdd->ddtime.timeSetDIBits/(UINT)pdd->ddtime.timeCount));
        RPF(("timeBlt:         %ums (%u)", (UINT)pdd->ddtime.timeBlt, (UINT)pdd->ddtime.timeBlt/(UINT)pdd->ddtime.timeCount));
    }

    pdd->ddtime.timeCount      = 0;
    pdd->ddtime.timeDraw       = 0;
    pdd->ddtime.timeDecompress = 0;
    pdd->ddtime.timeDither     = 0;
    pdd->ddtime.timeStretch    = 0;
    pdd->ddtime.timeSetDIBits  = 0;
    pdd->ddtime.timeBlt        = 0;

    return TRUE;
#else
    return FALSE;
#endif
}


/*
 * CopyPal -- copy a palette
 */
HPALETTE CopyPal(HPALETTE hpal)
{
    NPLOGPALETTE    pLogPal = NULL;
    HPALETTE        hpalNew = NULL;
    int             iSizePalette = 0;       // size of entire palette

    if (hpal == NULL)
	return NULL;

    DPF(("CopyPal routine\n"));
    GetObject(hpal,sizeof(iSizePalette),(LPSTR)&iSizePalette);

    pLogPal = (NPLOGPALETTE)LocalAlloc(LPTR, sizeof(LOGPALETTE)
            + iSizePalette * sizeof(PALETTEENTRY));

    if (!pLogPal)
	return NULL;

    pLogPal->palVersion = 0x300;
    pLogPal->palNumEntries = (WORD) iSizePalette;

    GetPaletteEntries(hpal, 0, iSizePalette, pLogPal->palPalEntry);

    hpal = CreatePalette(pLogPal);

    LocalFree((HLOCAL) pLogPal);

    return hpal;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api HPALETTE | DrawDibGetPalette | This function obtains the palette
*      used by a DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @rdesc Returns a handle for the palette if successful, otherwise
*        it returns NULL.
*
* @comm Use <f DrawDibRealize> instead of this function
*       to realize the correct palette in response to a window
*       message. You should rarely need to call this function.
*
*       Applications do not have exclusive use of the palette
*       obtained with this function. Applications should not
*       free the palette or assign it to a display context
*       with functions such as <f SelectPalette>. Applications
*       should also anticipate that some other
*       application can invalidate the handle. The palette
*       handle might also become invalid after the next use of a DrawDib function.
*
*       This function returns a valid handle only after
*       <f DrawDibBegin> has been used without pairing it with
*       <f DrawDibEnd>, or if <f DrawDibDraw> has been used.
*
* @xref <f DrawDibSetPalette> <f DrawDibRealize>
*
**************************************************************************/
HPALETTE VFWAPI DrawDibGetPalette(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLockNoTaskCheck(hdd)) == NULL)
        return NULL;

    if (pdd->hpalDraw)
        return pdd->hpalDraw;
    else {
	// For palette animation we can't return a different palette than the
	// real palette, so return hpal, not hpalCopy.
        // Just trust me.  - Toddla

        if (pdd->ulFlags & DDF_ANIMATE)
            return pdd->hpal;

	// In order for us to play direct to screen, etc, all palette
	// realization has to come through DrawDibRealize.  But that won't
	// always happen.  Some apps will always ask us for our palette and
	// realize it themselves.  So if we give them a copy of our palette,
	// and never our true palette, when our play code realizes the true
	// palette it's guarenteed to cause an actual palette change and we'll
        // correctly detect playing to screen. (BUG 1761)

	if (pdd->hpalCopy == NULL)
            pdd->hpalCopy = CopyPal(pdd->hpal);

	return pdd->hpalCopy;
    }
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibSetPalette | This function sets the palette
*      used for drawing device independent bitmaps.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HPALETTE | hpal | Specifies a handle to the palette.
*       Specify NULL to use the default palette.
*
* @rdesc Returns TRUE if successful.
*
* @comm Use this function when the application needs to realize an
*   alternate palette. The function forces the DrawDib context to use the
*   specified palette, possibly at the expense of image quality.
*
*   Do not free a palette assigned to a DrawDib context until
*   either a new palette replaces it (for example, if hpal1 is the
*   current palette, replacing it with DrawDibSetPalette(hdd, hpal2)),
*   or until the palette handle for the DrawDib context is set to
*   to the default palette (for example, DrawDibSetPalette(hdd, NULL)).
*
* @xref <f DrawDibGetPalette>
*
**************************************************************************/
BOOL VFWAPI DrawDibSetPalette(HDRAWDIB hdd, HPALETTE hpal)
{
    PDD pdd;
    int i;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (hpal == pdd->hpalCopy)
        hpal = NULL;

    if (pdd->hpalDraw != hpal)
        pdd->ulFlags |= DDF_NEWPALETTE;

    pdd->hpalDraw = hpal;       // always set this variable

    if (pdd->hpal == NULL)      // no palette to dink with
	return TRUE;

    if (pdd->biDraw.biBitCount > 8) // make sure we are drawing palettized
        return TRUE;

    if (pdd->ulFlags & DDF_ANIMATE)
    {
        DPF(("DrawDibSetPalette called while in DDF_ANIMATE mode!"));
    }

    //
    //  we are now using PAL colors...
    //
    pdd->uiPalUse = DIB_PAL_COLORS;

    if (pdd->hpalDraw != NULL)
    {
        /* Set up table for BI_PAL_COLORS non 1:1 drawing */

        //
        //  map all of our colors onto the given palette
        //  NOTE we can't use the select background trick
        //  because the given palette <hpalDraw> may have
        //  PC_RESERVED entries in it.
        //
	// SendSetPalette(pdd);
	
        for (i=0; i < 256; i++)
        {
	    if (pdd->biBuffer.biBitCount == 8)
	    {
		pdd->aw[i] = (WORD) GetNearestPaletteIndex(pdd->hpalDraw,
						    RGB(pdd->argbq[i].rgbRed,
							pdd->argbq[i].rgbGreen,
							pdd->argbq[i].rgbBlue));
	    }
	    else
	    {
		PALETTEENTRY pe;
		GetPaletteEntries(pdd->hpal, i, 1, &pe);
		pdd->aw[i] = (WORD) GetNearestPaletteIndex(pdd->hpalDraw,
						    RGB(pe.peRed,
							pe.peGreen,
							pe.peBlue));
	    }
        }

        for (; i<256; i++)
            pdd->aw[i] = 0;
    }
    else
    {
        /* Set up table for BI_PAL_COLORS 1:1 drawing */

	// SendSetPalette(pdd);
        for (i=0; i<(int)pdd->ClrUsed; i++)
            pdd->aw[i] = (WORD) i;

        for (; i<256; i++)
            pdd->aw[i] = 0;
    }

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibChangePalette | This function sets the palette entries
*      used for drawing device independent bitmaps.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm int | iStart | Specifies the starting palette entry number.
*
* @parm int | iLen | Specifies the number of palette entries.
*
* @parm LPPALETTEENTRY | lppe | Specifies a pointer to an
*       array of palette entries.
*
* @rdesc Returns TRUE if successful.
*
* @comm
*   Use this function when the DIB color table changes and
*   other parameters stay constant. This function changes
*   the physical palette only if the current
*   DrawDib palette is curently realized by calling <f DrawDibRealize>.
*
*   The DIB color table must be changed by the user or
*   the next use of <f DrawDibDraw> without the DDF_SAME_DRAW flag
*   implicity calls <f DrawDibBegin>.
*
*   If the DDF_ANIMATE flag is not set in the previous call to
*   <f DrawDibBegin> or <f DrawDibDraw>, this function will
*   animate the palette. In this case, update the DIB color
*   table from the palette specified by <p lppe> and use
*   <f DrawDibRealize> to realize the updated palette. Redraw
*   the image to see the updated colors.
*

* @xref <f DrawDibSetPalette> <f DrawDibRealize>
*
**************************************************************************/
BOOL VFWAPI DrawDibChangePalette(HDRAWDIB hdd, int iStart, int iLen, LPPALETTEENTRY lppe)
{
    PDD pdd;
    int i;

    int iStartSave;
    int iLenSave;
    LPPALETTEENTRY lppeSave;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (pdd->biBuffer.biBitCount != 8)
        return FALSE;

    if (lppe == NULL || iStart < 0 || iLen + iStart > 256)
        return FALSE;

    for (i=0; i<iLen; i++)
    {
	(*(pdd->lpargbqIn))[iStart+i].rgbRed   = lppe[i].peRed;
	(*(pdd->lpargbqIn))[iStart+i].rgbGreen = lppe[i].peGreen;
	(*(pdd->lpargbqIn))[iStart+i].rgbBlue  = lppe[i].peBlue;
    }

    //
    // handle a palette change for 8bit dither
    //
    if (pdd->lpDitherTable)
    {
        for (i=0; i<iLen; i++)
        {
            pdd->argbq[iStart+i].rgbRed   = lppe[i].peRed;
            pdd->argbq[iStart+i].rgbGreen = lppe[i].peGreen;
            pdd->argbq[iStart+i].rgbBlue  = lppe[i].peBlue;
        }

        pdd->lpDitherTable = DitherInit(pdd->lpbi, &pdd->biDraw, &pdd->DitherProc, pdd->lpDitherTable);
    }
    else if (pdd->hpalDraw)
    {
        SetPaletteEntries(pdd->hpal, iStart, iLen, lppe);
        pdd->ulFlags |= DDF_NEWPALETTE;

        for (i=iStart; i<iLen; i++)
        {
            pdd->aw[i] = (WORD) GetNearestPaletteIndex(pdd->hpalDraw,
                RGB(lppe[i].peRed,lppe[i].peGreen,lppe[i].peBlue));
        }
    }
    else if (pdd->ulFlags & DDF_ANIMATE)
    {
        for (i=iStart; i<iStart+iLen; i++)
        {
            if (i >= pdd->iAnimateStart && i < pdd->iAnimateEnd)
                lppe[i-iStart].peFlags = PC_RESERVED;
            else
                lppe[i-iStart].peFlags = 0;
        }

        /* Change iLen, iStart so that they only include the colors
        ** we can actually animate.  If we don't do this, the
        ** AnimatePalette() call just returns without doing anything.
        */

        iStartSave = iStart;
        iLenSave   = iLen;
        lppeSave   = lppe;

        if (iStart < pdd->iAnimateStart)
        {
            iLen -= (pdd->iAnimateStart - iStart);
            lppe += (pdd->iAnimateStart - iStart);
            iStart = pdd->iAnimateStart;
        }

        if (iStart + iLen > pdd->iAnimateEnd)
            iLen = pdd->iAnimateEnd - iStart;

        AnimatePalette(pdd->hpal, iStart, iLen, lppe);

        //
        //  any colors we could not animate, map to nearest
        //
        for (i=iStartSave; i<iStartSave+iLenSave; i++)
        {
            if (i >= pdd->iAnimateStart && i < pdd->iAnimateEnd)
                pdd->aw[i] = (WORD) i;
            else
                pdd->aw[i] = (WORD) GetNearestPaletteIndex(pdd->hpal,
                    RGB(lppeSave[i-iStartSave].peRed,
                        lppeSave[i-iStartSave].peGreen,
                        lppeSave[i-iStartSave].peBlue));
        }
    }
    else if (pdd->hpal)
    {
        SetPaletteEntries(pdd->hpal, iStart, iLen, lppe);
        pdd->ulFlags |= DDF_NEWPALETTE;
    }
    else
    {
        DPF(("Copying palette entries \n"));
        for (i=0; i<iLen; i++)
        {
            ((RGBQUAD *)pdd->aw)[iStart+i].rgbRed   = lppe[i].peRed;
            ((RGBQUAD *)pdd->aw)[iStart+i].rgbGreen = lppe[i].peGreen;
            ((RGBQUAD *)pdd->aw)[iStart+i].rgbBlue  = lppe[i].peBlue;
        }

        if (pdd->hbmDraw)
            pdd->ulFlags |= DDF_NEWPALETTE;
    }

    if (pdd->lpDIBSection) {

	// the colour table of a DIB Section is not changed when the palette
	// used to create it changes. We need to explicitly change it.
	SetDIBColorTable(pdd->hdcDraw, iStart, iLen,
		&(*(pdd->lpargbqIn))[iStart]);

    }

//    We'll break buggy apps if we delete a palette we've given them
//    even though we told them not to use it.
//
//    if (pdd->hpalCopy)
//	DeleteObject(pdd->hpalCopy);
//    pdd->hpalCopy = NULL;

    return TRUE;
}

/**************************************************************************
*
* @doc EXTERNAL DrawDib
*
* @api UINT | DrawDibRealize | This function realizes palette
*      of the display context specified into the DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to the display context containing
*       the palette.
*
* @parm BOOL | fBackground | If set to a nonzero value,
*       the selected palette is selected as a background palette.
*       If this is set to zero and the device context is attached
*       to a window, the logical palette is a foreground palette when
*       the window has the input focus. (The device context is attached
*       to a window if it was obtained by using the <f GetDC> function
*       or if the window-class style is CS_OWNDC.)
*
* @rdesc Returns number of entries in the logical palette
*        mapped to different values in the system palette. If
*        an error occurs or no colors were updated, it returns zero.
*
* @comm  This function should only be used to
*        handle a <m WM_PALETTECHANGE> or <m WM_QUERYNEWPALETTE>
*        message, or used in conjunction with the DDF_SAME_HDC flag
*        to prepare a display context prior to calling <f DrawDibDraw>
*        multiple times.
*
* @ex    The following example shows how the function is used to
*        handle a <m WM_PALETTECHANGE> or <m WM_QUERYNEWPALETTE>
*        message: |
*
*               case WM_PALETTECHANGE:
*                   if ((HWND)wParam == hwnd)
*                       break;
*
*               case WM_QUERYNEWPALETTE:
*                   hdc = GetDC(hwnd);
*
*                   f = DrawDibRealize(hdd, hdc, FALSE) > 0;
*
*                   ReleaseDC(hwnd, hdc);
*
*                   if (f)
*                       InvalidateRect(hwnd, NULL, TRUE);
*                   break;
*
* @ex   The following example shows using <f DrawDibRealize> use prior to
*       calling <f DrawDibDraw> multiple times: |
*
*               hdc = GetDC(hwnd);
*               DrawDibRealize(hdd, hdc, fBackground);
*               DrawDibDraw(hdd, hdc, ..........., DDF_SAME_DRAW|DDF_SAME_HDC);
*               DrawDibDraw(hdd, hdc, ..........., DDF_SAME_DRAW|DDF_SAME_HDC);
*               DrawDibDraw(hdd, hdc, ..........., DDF_SAME_DRAW|DDF_SAME_HDC);
*               ReleaseDC(hwnd, hdc);
*
* @ex   The following example shows using <f DrawDibRealize> with <f DDF_ANIMATE>
*       and (f DrawDibChangePalette> to do palette animation |
*
*               hdc = GetDC(hwnd);
*               DrawDibBegin(hdd, ....., DDF_ANIMATE);
*               DrawDibRealize(hdd, hdc, fBackground);
*               DrawDibDraw(hdd, hdc, ...., DDF_SAME_DRAW|DDF_SAME_HDC);
*               DrawDibChangePalette(hdd, ....);
*               ReleaseDC(hwnd, hdc);
*
* @comm To draw an image mapped to another palette use <f DrawDibSetPalette>.
*
*        To make <f DrawDibDraw> select its palette as a background palette
*        use the DDF_BACKGROUNDPAL flag and not this function.
*
*        While the DrawDib palette is selected into the display context,
*        do not call <f DrawDibEnd>, <f DrawDibClose>, <f DrawDibBegin>, or
*        <f DrawDibDraw> (with a different draw/format) on the same DrawDib
*        context <p hdd>. These can free the selected palette
*        while it is being used by your display context and cause
*        a GDI error.
*
* @xref <f SelectPalette>
*
**************************************************************************/
UINT VFWAPI DrawDibRealize(HDRAWDIB hdd, HDC hdc, BOOL fBackground)
{
    PDD pdd;
    HPALETTE hpal;
    UINT u;

    if (hdc == NULL)
	return 0;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return 0;

    if (IsScreenDC(hdc))
        pdd->ulFlags &= ~DDF_MEMORYDC;
    else {
        pdd->ulFlags |= DDF_MEMORYDC;

        DPF(("Drawing to a memory DC"));
    }

    SetStretchBltMode(hdc, COLORONCOLOR);

    //
    // what palette should we realize
    //
    hpal = pdd->hpalDraw ? pdd->hpalDraw : pdd->hpal;

    //
    // if we dont have a palette, we have nothing to realize
    // still call DrawDibPalChange though
    //
    if (hpal == NULL)
    {
        if (pdd->ulFlags & DDF_NEWPALETTE)
        {
            DrawDibPalChange(pdd, hdc, hpal);
            pdd->ulFlags &= ~DDF_NEWPALETTE;
        }

        return 0;
    }

// !!! There is a bug in GDI that will not map an identity palette 1-1 into
// !!! the system palette every time, which hoses us and makes it look like
// !!! dog spew.  This ICKITY-ACKITY-OOP code will flush the palette and
// !!! prevent the bug... BUT it introduces another bug where if we are a
// !!! background app, we hose everybody else's palette but ours.  So let's
// !!! live with the GDI bug.  One other thing... attempting this fix will
// !!! cause the bug to repro more often than it would have if you had left
// !!! it alone, unless you do the fix JUST RIGHT!  I don't trust myself
// !!! that much.
#if 0
    if ((pdd->ulFlags & DDF_NEWPALETTE) && (pdd->ulFlags & DDF_IDENTITYPAL) &&
		!fBackground)
    {
	//
	// this will flush the palette clean to avoid a GDI BUG!!!
	//
	SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
	SetSystemPaletteUse(hdc, SYSPAL_STATIC);
    }
#endif

    //
    // select and realize it
    //
    SelectPalette(hdc, hpal, fBackground);
    u = RealizePalette(hdc);

    // !!! If two DrawDib instances share the same palette handle, the second
    // one will not change any colours and u will be 0, and it will not stop
    // decompressing to screen or recompute stuff for bitmaps when it goes
    // into the background and it will get a messed up palette.
    // !!! This is a known bug we don't care about
    //
    // this should be fixed by the hpalCopy stuff.

    if (u > 0 || (pdd->ulFlags & DDF_NEWPALETTE))
    {
	pdd->ulFlags |= DDF_NEWPALETTE;
        DrawDibPalChange(pdd, hdc, hpal);
        pdd->ulFlags &= ~DDF_NEWPALETTE;
    }

    return u;
}

/**************************************************************************
* @doc EXTERNAL DrawDib VFW11
*
* @api LPVOID | DrawDibGetBuffer | This function returns the pointer
*      to the DrawDib decompress buffer.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a pointer to a
*        <t BITMAPINFOHEADER> structure.
*
* @parm DWORD | dwSize | Specifies the size of the buffer pointed to by <p lpbi>
*
* @parm DWORD | dwFlags | Set to zero.
*
* @rdesc Returns a pointer to the buffer used by DrawDib for decompression,
*        or NULL if no buffer is used. If <p lpbi> is not NULL,
*        it is filled in with a copy of the <t BITMAPINFOHEADER>
*        describing the buffer.
*
*        The structure for <p lpbi> must have room for a
*        <t BITMAPINFOHEADER> and 256 colors.
*
**************************************************************************/

LPVOID VFWAPI DrawDibGetBuffer(HDRAWDIB hdd, LPBITMAPINFOHEADER lpbi, DWORD dwSize, DWORD dwFlags)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return NULL;

    if (lpbi)
    {
        hmemcpy(lpbi, &pdd->biBuffer,
            min(dwSize, pdd->biBuffer.biSize + 256*sizeof(RGBQUAD)));
    }

    return pdd->pbBuffer;
}

LPVOID VFWAPI DrawDibGetBufferOld(HDRAWDIB hdd, LPBITMAPINFOHEADER lpbi)
{
    return DrawDibGetBuffer(hdd, lpbi, sizeof(BITMAPINFOHEADER), 0);
}

/**************************************************************************
* @doc EXTERNAL DrawDibStart
*
* @api BOOL | DrawDibStart | This function prepares a DrawDib
*      context for streaming playback.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm LONG | rate | Specifies the playback rate (in microseconds per frame).
*
* @rdesc Returns TRUE if successful.
*
* @xref <f DrawDibStop>
*
**************************************************************************/
BOOL VFWAPI DrawDibStart(HDRAWDIB hdd, DWORD rate)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (pdd->hic == (HIC)-1)
        return FALSE;

    // if the codec does not care about this message dont fail.

    if (pdd->hic != NULL)
        ICSendMessage(pdd->hic, ICM_DRAW_START, rate, 0);

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDibStop
*
* @api BOOL | DrawDibStop | This function frees the resources
*      used by a DrawDib context for streaming playback.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @rdesc Returns TRUE if successful.
*
* @xref <f DrawDibStart>
*
**************************************************************************/
BOOL VFWAPI DrawDibStop(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (pdd->hic == (HIC)-1)
        return FALSE;

    if (pdd->hic != NULL)
        ICSendMessage(pdd->hic, ICM_DRAW_STOP, 0, 0);

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibUpdate | This macro updates the last
*      buffered frame drawn.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to the display context.
*
* @parm int | xDst | Specifies the x-coordinate of the upper left-corner
*       of the destination rectangle. Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @parm int | yDst | Specifies the y-coordinate of the upper-left corner
*       of the destination rectangle.  Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @rdesc Returns TRUE if successful.
*
* @comm This macro uses <f DrawDibDraw> to send the DDF_UPDATE flag
*       to the DrawDib context.
*
**************************************************************************/

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibDraw | This function draws a device independent
*      bitmap to the screen.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to the display context.
*
* @parm int | xDst | Specifies the x-coordinate of the upper left-corner
*       of the destination rectangle. Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @parm int | yDst | Specifies the y-coordinate of the upper-left corner
*       of the destination rectangle. Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @parm int | dxDst | Specifies the width of the destination rectangle.
*       The width is specified in MM_TEXT client coordinates. If
*       <p dxDst> is -1, the width of the bitmap is used.
*
* @parm int | dyDst | Specifies the height of the destination rectangle.
*       The height is specified in MM_TEXT client coordinates. If
*       <p dyDst> is -1, the height of the bitmap is used.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a pointer to the
*       <t BITMAPINFOHEADER> structure for the bitmap. The color
*       table for the DIB follows the format information. The
*       height specified for the DIB in the structure must be
*       positive (that is, this function will not draw inverted DIBs).
*
* @parm LPVOID | lpBits | Specifies a pointer to the buffer
*       containing the bitmap bits.
*
* @parm int | xSrc | Specifies the x-coordinate of the upper-left corner
*       source rectangle. Coordinates are specified in pixels.
*       The coordinates (0,0) represent the upper left corner
*       of the bitmap.
*
* @parm int | ySrc | Specifies the y-coordinate of the upper left corner
*       source rectangle. Coordinates are specified in pixels.
*       The coordinates (0,0) represent the upper left corner
*       of the bitmap.
*
* @parm int | dxSrc | Specifies the width of the source rectangle.
*       The width is specified in pixels.
*
* @parm int | dySrc | Specifies the height of the source rectangle.
*       The height is specified in pixels.
*
* @parm UINT | wFlags | Specifies any applicable flags for drawing.
*       The following flags are defined:
*
* @flag DDF_UPDATE | Indicates the last buffered bitmap is to be redrawn.
*       If drawing fails with this flag, a buffered image is not available
*       and a new image needs to be specified before the display is updated.
*
* @flag DDF_SAME_HDC | Assumes the handle to the display context
*       is already specified. When this flag is used,
*       DrawDib also assumes the correct palette has already been
*       realized into the device context (possibly by
*       <f DrawDibRealize>).
*
* @flag DDF_SAME_DRAW | Uses the drawing parameters previously
*       specified for this function.  Use this flag only
*       if <p lpbi>, <p dxDst>, <p dyDst>, <p dxSrc>, and <p dySrc>
*       have not changed since using <f DrawDibDraw> or <f DrawDibBegin>.
*       Normally <f DrawDibDraw> checks the parameters, and if they
*       have changed, <f DrawDibBegin> prepares the DrawDib context
*       for drawing.
*
* @flag DDF_DONTDRAW | Indicates the frame is not to be drawn and will
*       later be recalled with the <f DDF_UPDATE> flag. DrawDib does
*       not buffer an image if an offscreen buffer does not exist.
*       In this case, DDF_DONTDRAW draws the frame to the screen and
*       the subsequent use of DDF_UPDATE fails. DrawDib does
*       guarantee that the following will
*       always draw "image" B to the screen.
*
*           DrawDibDraw(hdd, ..., lpbiA, ..., DDF_DONTDRAW);
*           DrawDibDraw(hdd, ..., lpbiB, ..., DDF_DONTDRAW);
*           DrawDibDraw(hdd, ..., NULL,  ..., DDF_UPDATE);
*
*       The DDF_UPDATE and DDF_DONTDRAW flags are used
*       together to create composite images
*       offscreen, and then do a final update when finished.
*
* @flag DDF_HURRYUP | Indicates the data does not have to
*       drawn (that is, it can be dropped) and the DDF_UPDATE flags will
*       not be used to recall this information. DrawDib looks at
*       this data only if it is required to build the next frame, otherwise
*       the data is ignored.
*
*       This flag is usually used to resynchronize video and audio. When
*       resynchronizing data, applications should send the image
*       with this flag in case the driver needs to
*       to buffer the frame to decompress subsequent frames.
*
* @flag DDF_UPDATE | Indicates the last buffered bitmap is to be redrawn.
*       If drawing fails with this flag, a buffered image is not available
*       and a new image needs to be specified before the display is updated.
*       For more information, see the <f DDF_DONTDRAW> flag.
*
* @flag DDF_BACKGROUNDPAL | Realizes the palette used for drawing
*       in the background leaving the actual palette used for display
*       unchanged.  (This flag is valid only if DDF_SAME_HDC is not set.)
*
* @flag DDF_HALFTONE | Always dithers the DIB to a standard palette
*       regardless of the palette of the DIB. If using <f DrawDibBegin>,
*       set this flag for it rather than <f DrawDibDraw>.
*
* @flag DDF_NOTKEYFRAME | Indicates the DIB data is not a key frame.
*
* @flag DDF_HURRYUP | Indicates the DIB data does not have to
*       drawn (that is, it can be dropped). This flag is usually
*       used to resynchronize the video to the audio. When
*       resynchronizing data, applications should send the image
*       with this flag in case the driver needs to
*       to buffer the frame to decompress subsequent frames.
*
* @rdesc Returns TRUE if successful.
*
* @comm This function replaces <f StretchDIBits> and supports
*       decompression of bitmaps by installable compressors.
*       This function dithers true color bitmaps properly on
*       8-bit display devices.
*
**************************************************************************/

BOOL VFWAPI DrawDibDraw(HDRAWDIB hdd,
                            HDC      hdc,
                            int      xDst,
                            int      yDst,
                            int      dxDst,
                            int      dyDst,
                            LPBITMAPINFOHEADER lpbi,
                            LPVOID   lpBits,
                            int      xSrc,
                            int      ySrc,
                            int      dxSrc,
                            int      dySrc,
                            UINT     wFlags)
{
    PDD	    pdd;
    BOOL    f;
    RECT    rc;
    DWORD   icFlags;
    LRESULT   dw;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (hdc == NULL)
        return FALSE;

    if (wFlags & DDF_UPDATE)
    {
        lpbi = pdd->lpbi;

        dxDst = pdd->dxDst;
        dyDst = pdd->dyDst;
        dxSrc = pdd->dxSrc;
        dySrc = pdd->dySrc;
    }
    else
    {
        if (lpbi == NULL)
	    return FALSE;

        //
        // fill in defaults.
        //
        if (dxSrc < 0)
	    dxSrc = (int)lpbi->biWidth - xSrc;

	if (dySrc < 0)
	    dySrc = (int)lpbi->biHeight - ySrc;
	
        if (dxDst < 0)
	    dxDst = dxSrc;

        if (dyDst < 0)
	    dyDst = dySrc;
    }

#ifdef DEBUG_RETAIL
    if (xSrc  <  0 ||
        ySrc  <  0 ||
        dxSrc <= 0 ||
        dySrc <= 0 ||
        xSrc + dxSrc > (int)lpbi->biWidth ||
        ySrc + dySrc > (int)lpbi->biHeight)
    {
        RPF(("DrawDibBegin(): bad source parameters [%d %d %d %d]", xSrc, ySrc, dxSrc, dySrc));
//      return 0;   // see what happens.
    }
#endif

    if (dxSrc == 0 || dySrc == 0)	// !!! || dxDst == 0 || dyDst == 0)
        return FALSE;

    //
    // check and make sure the params of the draw has not changed
    //
    if (!(wFlags & (DDF_SAME_DRAW|DDF_UPDATE)) &&
        !(DibEq(pdd->lpbi, lpbi) &&
          !(((UINT)pdd->ulFlags ^ wFlags) & DDF_HALFTONE) &&
        pdd->dxDst == dxDst &&
        pdd->dyDst == dyDst &&
        pdd->dxSrc == dxSrc &&
        pdd->dySrc == dySrc))
    {
        wFlags &= ~(DDF_UPDATE | DDF_FULLSCREEN);
        if (!DrawDibBegin(hdd, hdc, dxDst, dyDst, lpbi, dxSrc, dySrc, wFlags))
	    return FALSE;
    }

    TIMEINC();      // should we include DibEq?
    TIMESTART(timeDraw);

    // convert to DIB cordinates
    ySrc = (int)pdd->lpbi->biHeight - (ySrc + dySrc);

    //
    // Initialize the DC:  We need to realize the palette if we are not
    // guarenteed to be using the same DC as before, if we've been told we
    // have a new palette, or if we are mapping to somebody else's palette.
    // The owner of the palette could be changing it on us all the time or
    // doing who knows what, so to be safe we will realize it every frame.
    // If nothing's changed, this should be a really cheap operation, and
    // it doesn't appear to be causing any palette fights that end in somebody
    // getting hurt.  This is required for Magic School Bus, and PageMaster,
    // at the very least. (WIN95B 12204 and 9637)
    //
    if (!(wFlags & DDF_SAME_HDC) || (pdd->ulFlags & DDF_NEWPALETTE) ||
							pdd->hpalDraw)
    {
        //
        // image will be totally clipped anyway
        //
        if (GetClipBox(hdc, &rc) == NULLREGION)
        {
	    wFlags |= DDF_DONTDRAW;
        }

        //
        // select and realize the palette.
        //
        // NOTE you must unselect this thing, dont return early
        //
        DrawDibRealize(hdd, hdc, (wFlags & DDF_BACKGROUNDPAL) != 0);
    }

#ifdef USE_DCI
    //
    //  do a clipping check
    //
    if (pdd->ulFlags & DDF_CLIPCHECK)
    {
        RECT  rc;

        if (!(pdd->ulFlags & DDF_CLIPPED) &&
            (pdd->iDecompress == DECOMPRESS_SCREEN) && // (pdd->ulFlags & DDF_SCREENX) &&
            (wFlags & (DDF_PREROLL|DDF_DONTDRAW)))
        {
	    DPF(("DDF_DONTDRAW while decompressing to screen, staying clipped"));
        }

        if ((pdd->ulFlags & DDF_MEMORYDC) ||
	    GetClipBox(hdc, &rc) != SIMPLEREGION ||
	    xDst < rc.left ||
	    yDst < rc.top ||
	    xDst + dxDst > rc.right ||
	    yDst + dyDst > rc.bottom ||
	    (wFlags & (DDF_PREROLL|DDF_DONTDRAW)) ||
	    (gfDisplayHasBrokenRasters &&
		     (DCNotAligned(hdc, xDst) || gwScreenBitDepth == 24)))
	    // Note: if we're on a 24-bit display with broken rasters, we don't
	    // decompress to the screen even if the rectangle is aligned,
	    // because it's just too easy for somebody to try to write out
	    // a whole pixel in one gulp and hit the 64K boundary.
	{
	    //
	    //  we are clipped, check for a change.
	    //
	    if (!(pdd->ulFlags & DDF_CLIPPED))
	    {
	        pdd->ulFlags |= DDF_CLIPPED;
	        DrawDibClipChange(pdd, wFlags);
	    }
	}
	else
	{
	    //  !!!
	    //  check for the screen width changing, Chicago
	    //  currently can't change the bitdepth so don't
	    //  worry about that right now.
	    //
	    if (GetSystemMetrics(SM_CXSCREEN) != (int)gwScreenWidth)
	    {
		pdd->ulFlags |= DDF_CLIPPED;
		DrawDibClipChange(pdd, wFlags);
		DrawDibInit();
	    }

	    //
	    // we are now unclipped, check for a change
	    //
	    if ((pdd->ulFlags & DDF_CLIPPED) && !(pdd->ulFlags & DDF_UPDATE))
	    {
#ifdef DEBUG
		if (DCNotAligned(hdc, xDst))
		    DPF(("Warning draw is not aligned on 4 pixel boundary"));
#endif
		pdd->ulFlags &= ~DDF_CLIPPED;
		DrawDibClipChange(pdd, wFlags);
	    }
        }

    DPF(("Clip Box: %d %d %d %d    Dest: %d %d %d %d", rc.left, rc.top, rc.right, rc.bottom, xDst, yDst, xDst + dxDst, yDst + dyDst));

    }

#endif  //_WIN32
    if (pdd->ulFlags & DDF_WANTKEY)
    {
        //
        // Adobe hack: If the DDF_UPDATE flag is on in our internal
        // flags, that means we've just been getting a bunch of frames
        // with the DONTDRAW flag set.  In that case, if this frame
        // immediately after those frames is marked as a key frame
        // we assume that it might not be a key frame and refrain from
        // switching immediately to decompressing to screen.
        //
        if (!(wFlags & DDF_NOTKEYFRAME) && !(pdd->ulFlags & DDF_UPDATE))
        {
    	pdd->ulFlags &= ~DDF_WANTKEY;
    	DrawDibClipChange(pdd, wFlags);
        }
    }

    //
    // if update is set re-draw what ever we drew last time
    //
    if (wFlags & DDF_UPDATE)
    {
        if (pdd->hic == (HIC)-1 || (pdd->ulFlags & DDF_DIRTY))
        {
	    f = FALSE;
	    DPF(("Can't update: no decompress buffer!"));
	    goto exit;
        }

        if (pdd->hic)
        {
	    if (pdd->ulFlags & DDF_UPDATE)
	    {
		goto redraw;
	    }

	    lpbi = &pdd->biBuffer;
	    lpBits = pdd->pbBuffer;

	    //!!! set the source right.

	    if ((pdd->ulFlags & DDF_XLATSOURCE))
	    {
		dxSrc = MulDiv(dxSrc, abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
		dySrc = MulDiv(dySrc, abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
		xSrc  = MulDiv(xSrc,  abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
		ySrc  = MulDiv(ySrc,  abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
	    }
        }

        if (pdd->ulFlags & DDF_STRETCH)
        {
	    lpbi  = &pdd->biStretch;
	    lpBits = pdd->pbStretch;
	    dxSrc  = dxDst;
	    dySrc  = dyDst;
	    xSrc   = 0;
	    ySrc   = 0;
        }

        if (pdd->ulFlags & DDF_DITHER)
        {
	    lpBits = pdd->pbDither;
	    xSrc = 0;
	    ySrc = 0;
        }

        if (pdd->lpDIBSection != NULL)
	    goto bltDIB;

        if (pdd->hbmDraw && (pdd->ulFlags & DDF_BITMAP))
            goto bltit;


        if (lpBits == NULL)
        {
	    f = FALSE;       // no buffer, can't update....
	    goto exit;
        }

        goto drawit;
    }

    //
    // default for bits pointerdefault
    //
    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi+(int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD);

    //
    // call any decompressor if needed
    //
    if (pdd->hic)
    {
        if (pdd->hic == (HIC)-1)
        {
	    f = FALSE;
	    goto exit;
        }

#ifdef USE_DCI // exclude all code that references biscreen

        if (pdd->iDecompress == DECOMPRESS_SCREEN) // pdd->ulFlags & DDF_SCREENX
        {
	
	    DCIRVAL    DCIResult;
	    int		xDstC = xDst, yDstC = yDst;
	    POINT   pt;
	    pt.x = xDst; pt.y = yDst;
	    LPtoDP(hdc, &pt, 1);
	    xDst = pt.x;
	    yDst = pt.y;
	
#ifdef _WIN32
	    GetDCOrgEx(hdc, &pt);
	    xDst += pt.x;
	    yDst += pt.y;
#else
	    DWORD dwOrg;
	    dwOrg = GetDCOrg(hdc);
	    xDst += LOWORD(dwOrg);
	    yDst += HIWORD(dwOrg);
#endif
	    //
	    // we are decompressing to the screen not the buffer, so
	    // the buffer is dirty now
	    //
	    pdd->ulFlags |= DDF_DIRTY;

#define USEGETCLIPBOXEARLY
    // IF we call GetClipBox AFTER doing DCIBeginAccess we end up with
    // EXTREMELY slow drawing.
#ifdef USEGETCLIPBOXEARLY
	    // To see whether or not decompressing to the screen was OK, we
	    // called GetClipBox.  But that was a long time ago, and as of
	    // Chicago, things could have changed since then.  We call 32 bit
	    // code in the meantime, which lets other 16 bit code run, like USER
	    // which might clip the window with another window or worse yet,
	    // move this window off the screen so decompressing to the screen
	    // will crash!  Calling GetClipBox way back then was just not valid.
	    // We have to call it again now.  I'm not removing the call way back
	    // then because touching this code is known to ruin the stability
	    // of the universe. (WIN95 BUG#20754 and WIN95B BUG#8374)
	    // WARNING: xDst, yDst are in SCREEN co-ords now.  Use the client
	    // ones.
	    if (GetClipBox(hdc, &rc) != SIMPLEREGION ||
	    		xDstC < rc.left ||
	    		yDstC < rc.top ||
	    		xDstC + dxDst > rc.right ||
	    		yDstC + dyDst > rc.bottom) {
		dw = ICERR_OK;
		f = TRUE;
		goto exit;
	    }
#endif
	    DCIResult = DCIBeginAccess(pdci, xDst, yDst, dxDst, dyDst);

	    //
	    // if DCIBeginAccess fails we are in the background, and should
	    // not draw.
	    //
	    if (DCIResult < 0)
	    {
		DPF(("DCIBeginAccess returns %d\n", DCIResult));
		f = TRUE;       //!!! handle more error values!
		goto exit;
	    }
            else if (DCIResult > 0)
            {
                if (DCIResult & DCI_STATUS_POINTERCHANGED)
                {
#ifdef _WIN32
                    if (pdci->dwDCICaps & DCI_1632_ACCESS)
                    {
                        //
                        // make sure the pointer is valid.
                        //
                        if (pdci->dwOffSurface >= 0x10000)
                        {
                            DPF(("DCI Surface can't be supported: offset >64K"));

                            lpScreen = NULL;
                        }
                        else
                            lpScreen = (LPVOID)MAKELONG((WORD)pdci->dwOffSurface, pdci->wSelSurface);
                    }
                    else
                    {
                        lpScreen = (LPVOID) pdci->dwOffSurface;
                    }
#else
                    //
                    // make sure the pointer is valid.
                    //
                    if (pdci->dwOffSurface >= 0x10000)
                    {
                        DPF(("DCI Surface can't be supported: offset >64K"));

                        lpScreen = NULL;
                    }
                    else
                        lpScreen = (LPVOID)MAKELP(pdci->wSelSurface,pdci->dwOffSurface);
#endif
                }

                if (DCIResult & (DCI_STATUS_STRIDECHANGED |
                                 DCI_STATUS_FORMATCHANGED |
                                 DCI_STATUS_SURFACEINFOCHANGED |
                                 DCI_STATUS_CHROMAKEYCHANGED))
                {
                    DPF(("Unhandled DCI Flags!  (%04X)", DCIResult));
                }

                if (DCIResult & DCI_STATUS_WASSTILLDRAWING)
                {
                    DPF(("DCI still drawing!?!", DCIResult));
                    f = TRUE;       //!!!
                    goto EndAccess;
                }
            }

	    if (lpScreen == NULL)
	    {
		DPF(("DCI pointer is NULL when about to draw!"));
		f = FALSE;
		goto EndAccess;
	    }
	
	    //convert to DIB corrds.
	    yDst = (int)pdci->dwHeight - (yDst + dyDst);

	    TIMESTART(timeDecompress);

	    icFlags = 0;

	    if (wFlags & DDF_HURRYUP)
		icFlags |= ICDECOMPRESS_HURRYUP;

	    if (wFlags & DDF_NOTKEYFRAME)
		icFlags |= ICDECOMPRESS_NOTKEYFRAME;

	    DPF2(("Drawing To Screen: %d %d %d %d", xDst, yDst, xDst + dxDst, yDst + dyDst));
#ifdef USEGETCLIPBOXLATE
	    // To see whether or not decompressing to the screen was OK, we
	    // called GetClipBox.  But that was a long time ago, and as of
	    // Chicago, things could have changed since then.  We call 32 bit
	    // code in the meantime, which lets other 16 bit code run, like USER
	    // which might clip the window with another window or worse yet,
	    // move this window off the screen so decompressing to the screen
	    // will crash!  Calling GetClipBox way back then was just not valid.
	    // We have to call it again now.  I'm not removing the call way back
	    // then because touching this code is known to ruin the stability
	    // of the universe. (WIN95 BUG#20754 and WIN95B BUG#8374)
	    // WARNING: xDst, yDst are in SCREEN co-ords now.  Use the client
	    // ones.
	    if (GetClipBox(hdc, &rc) != SIMPLEREGION ||
	    		xDstC < rc.left ||
	    		yDstC < rc.top ||
	    		xDstC + dxDst > rc.right ||
	    		yDstC + dyDst > rc.bottom) {
		dw = ICERR_OK;
	    }
	    else
#endif
	    {
	        dw = ICDecompressEx(pdd->hic, icFlags,
				lpbi, lpBits, xSrc, ySrc, dxSrc, dySrc,
				(LPBITMAPINFOHEADER) &biScreen, lpScreen,
				xDst, yDst, dxDst, dyDst);
	    }

	    if (dw == ICERR_DONTDRAW)
		dw = ICERR_OK;

	    f = (dw == ICERR_OK);

	    TIMEEND(timeDecompress);
EndAccess:
	    DCIEndAccess(pdci);
	    goto exit;
        }
        else
#endif // biscreen references
	{
	    //
	    //  if the offscreen buffer is dirty, only a key frame will
	    //  clean our soul.
	    //
	    if (pdd->ulFlags & DDF_DIRTY)
	    {
	        if (wFlags & DDF_NOTKEYFRAME)
	        {
		    //!!! playing files with no key frames we will get into
		    //a state where we will never draw a frame ever again.
		    //we need a punt count?

		    DPF(("punt frame"));

		    f = TRUE;
		    goto exit;
	        }
	        else // if (!(wFlags & DDF_HURRYUP))
		{
		    pdd->ulFlags &= ~DDF_DIRTY;
	        }
	    }

	    TIMESTART(timeDecompress);

	    icFlags = 0;

	    if (wFlags & DDF_HURRYUP)
	        icFlags |= ICDECOMPRESS_HURRYUP;

	    if (wFlags & DDF_NOTKEYFRAME)
	        icFlags |= ICDECOMPRESS_NOTKEYFRAME;

	    if (pdd->lpDIBSection != 0)
	    {

	        dw = ICDecompress(pdd->hic, icFlags, lpbi, lpBits, &pdd->biBuffer, pdd->pbBuffer);
	    }
	    else if (pdd->iDecompress == DECOMPRESS_BITMAP) //pdd->ulFlags & DDF_BITMAPX
	    {
                //!!! should we check FASTTEMPORALD?
                if (pdd->ulFlags & DDF_HUGEBITMAP)
                    HugeToFlat(pdd->pbBitmap,pdd->biBitmap.biSizeImage,pdd->biBitmap.biYPelsPerMeter);

#ifdef _WIN32
                // Win32: still use the decomp buffer, then SetBitmapBits
                dw = ICDecompress(pdd->hic, icFlags, lpbi, lpBits, &pdd->biBitmap, pdd->pbBuffer);
                SetBitmapBits(pdd->hbmDraw, pdd->biBitmap.biSizeImage, pdd->pbBuffer);
#else
                dw = ICDecompress(pdd->hic, icFlags, lpbi, lpBits, &pdd->biBitmap, pdd->pbBitmap);
#endif

                if (pdd->ulFlags & DDF_HUGEBITMAP)
                    FlatToHuge(pdd->pbBitmap,pdd->biBitmap.biSizeImage,pdd->biBitmap.biYPelsPerMeter);
            }
            else
            {
                dw = ICDecompress(pdd->hic, icFlags, lpbi, lpBits, &pdd->biBuffer, pdd->pbBuffer);
            }

            TIMEEND(timeDecompress);

            FlushBuffer();

	    if (dw == ICERR_DONTDRAW) {
		// Decompressor doesn't want us to draw, for some reason....
		wFlags |= DDF_DONTDRAW;
	    } else if (dw != 0) {
		f = FALSE;
		DPF(("Error %ld from decompressor!\n", dw));
		goto exit;
	    }
        }

        //
        // if don't draw is set we just need to decompress
        //
        if (wFlags & (DDF_DONTDRAW|DDF_HURRYUP))
        {
	    f = TRUE;
            pdd->ulFlags |= DDF_UPDATE|DDF_DONTDRAW;    // make sure update knows what to do
	    goto exit;
        }

#ifndef DAYTONA
// this does not work on Daytona (because the biSizeImage is confused?)
// but in any case it's not clear that a  delta draw from client side is a
// win over a DIBSection blt from server side.
        //
        //  draw RLE delta's to the screen even when we are buffering,
	//  as long as we're not stretching, dithering or using a memory DC.
	//  Drawing RLE's to a memory DC won't work in GDI.
	//  I will also refuse to draw RLE directly if we are using a
	//  decompressor (pdd->hic).  I do this for no good reason other than
	//  it fixes Win95 bug 24412
        //
        if (!(pdd->ulFlags & (DDF_MEMORYDC|DDF_DONTDRAW|DDF_STRETCH|DDF_DITHER))
	    && lpbi->biCompression == BI_RLE8 &&
	    (dxDst == dxSrc) && (dyDst == dySrc) &&
            lpbi->biSizeImage != pdd->biBuffer.biSizeImage &&
	    !(pdd->hic))
        {
            pdd->ulFlags |= DDF_UPDATE;    // make sure update knows what to do
            pdd->biDraw.biCompression = BI_RLE8;
            goto drawit;
        }
#endif
redraw:
        pdd->ulFlags &= ~(DDF_UPDATE|DDF_DONTDRAW);

        if ((pdd->ulFlags & DDF_XLATSOURCE))
        {
            dxSrc = MulDiv(dxSrc, abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
            dySrc = MulDiv(dySrc, abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
            xSrc  = MulDiv(xSrc,  abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
            ySrc  = MulDiv(ySrc,  abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
        }

        lpbi = &pdd->biBuffer;
	lpBits = pdd->pbBuffer;

        pdd->biDraw.biCompression = pdd->biBuffer.biCompression;
    }
    else
    {

	// if we are using DIB Sections, and there is no decompression,
	// dither or stretch step, then we need to explicitly copy the data
	// into the dib section.
	// maybe with the revised CreateDIBSection we could map the existing
	// read buffer and avoid this step
	if (pdd->lpDIBSection && ((pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)) == 0)) {
	    // Include time taken here as 'stretching'.
	    // Really, though, we shouldn't be using DIB Sections in this case.
            TIMESTART(timeStretch);
	    if (lpbi->biCompression == BI_RGB) {
		lpbi->biSizeImage = DIBSIZEIMAGE(*lpbi);
	    }

	    hmemcpy(pdd->lpDIBSection, lpBits, lpbi->biSizeImage);
            TIMEEND(timeStretch);
	}

        //
        // when directly drawing RLE data we cant hurry
        //
        if (pdd->lpbi->biCompression == BI_RLE8)
            wFlags &= ~DDF_HURRYUP;

        //
        // if don't draw is set we just need to stretch/dither
        //
        if (wFlags & DDF_HURRYUP)
        {
            f = TRUE;
            pdd->ulFlags |= DDF_DIRTY;
            goto exit;
        }

        pdd->ulFlags &= ~DDF_DIRTY;
        pdd->biDraw.biCompression = lpbi->biCompression;
    }

    if (pdd->biDraw.biCompression == BI_RGB &&
        (pdd->ulFlags & (DDF_DITHER|DDF_STRETCH)))
    {
        if (pdd->ulFlags & DDF_STRETCH)
        {
            TIMESTART(timeStretch);

            StretchDIB(&pdd->biStretch, pdd->pbStretch,
                0, 0, dxDst, dyDst,
		lpbi,lpBits,
                xSrc,ySrc,dxSrc,dySrc);

            TIMEEND(timeStretch);

            lpbi  = &pdd->biStretch;
            lpBits = pdd->pbStretch;
            dxSrc  = dxDst;
            dySrc  = dyDst;
            xSrc   = 0;
            ySrc   = 0;
        }

	if (pdd->ulFlags & DDF_DITHER)
        {
            TIMESTART(timeDither);

#if 0 // this check isn't right.
	    // current dither code can only handle 1:1 sizing
	    if ((pdd->biDraw.biWidth != dxSrc) ||
	        (pdd->biDraw.biHeight != dySrc)) {
#ifdef DEBUG
		    DPF(("dither expected to stretch?"));
		    DebugBreak();
#endif
		    // fix it up somehow to avoid crash
		    dxSrc = (int) pdd->biDraw.biWidth;
		    dySrc = (int) pdd->biDraw.biHeight;
	    }
#endif
            pdd->DitherProc(&pdd->biDraw, pdd->pbDither,0,0,dxSrc,dySrc,
                lpbi,lpBits,xSrc, ySrc, pdd->lpDitherTable);

            TIMEEND(timeDither);

            lpBits = pdd->pbDither;
            xSrc = 0;
            ySrc = 0;
        }

        if ((wFlags & DDF_DONTDRAW) && !pdd->hbmDraw)
        {
            f = TRUE;
            goto exit;
        }
    }
#ifdef _WIN32
    else if (pdd->biDraw.biCompression == BI_RLE8)
    {
	/*
	 * if drawing RLE deltas on NT, the biSizeImage field needs to
	 * accurately reflect the amount of RLE data present in lpBits.
	 */
	pdd->biDraw.biSizeImage = lpbi->biSizeImage;
    }
#endif

    if (pdd->lpDIBSection != NULL) {

	//ASSERT(pdd->hbmDraw != NULL);

        if (wFlags & DDF_DONTDRAW)
        {
            f = TRUE;
            goto exit;
        }

bltDIB:
        TIMESTART(timeBlt);

	// Put things back in right-side-up coordinates
	ySrc = (int)pdd->biDraw.biHeight - (ySrc + dySrc);
//      ySrc = 0; // Was like this for Chicago M6!

        f = StretchBlt(hdc,xDst,yDst,dxDst,dyDst,pdd->hdcDraw,
            xSrc,ySrc,dxSrc,dySrc,SRCCOPY) != 0;
#ifdef DEBUG
        // Whistler: failure expected when desktops change
        if(!f && GetLastError() != ERROR_ACCESS_DENIED) {
            DPF(("StretchBlt failed %d", GetLastError()));
        }
#endif
        f = TRUE;

	FlushBuffer();

        TIMEEND(timeBlt);


    } else if (pdd->hbmDraw)
    {
#ifndef _WIN32
        //
        //  when MCIAVI is playing we need realize our palette for each
        //  draw operation because another app may have drawn a translated
        //  bitmap thus screwing up the GDI *global* device translate table.
        //  RonG I hate you some times
        //
        if (pdd->hpal && (wFlags & DDF_SAME_HDC))
            RealizePalette(hdc);
#endif

	if (pdd->iDecompress != DECOMPRESS_BITMAP) // !(pdd->ulFlags & DDF_BITMAPX)
	{
            TIMESTART(timeSetDIBits);
#if USE_SETDI
            pdd->sd.hdc = hdc;      //!!!ack!
            SetBitmap(&pdd->sd,xSrc,0,dxSrc,dySrc,lpBits,xSrc,ySrc,dxSrc,dySrc);
            pdd->sd.hdc = NULL;     //!!!ack!
            ySrc = 0;
#else
            SetDIBits(hdc, pdd->hbmDraw, 0, dySrc,
                lpBits, (LPBITMAPINFO)&pdd->biDraw, pdd->uiPalUse);
#endif
            FlushBuffer();

            TIMEEND(timeSetDIBits);
        }

        if (wFlags & DDF_DONTDRAW)
        {
            f = TRUE;
            goto exit;
        }
bltit:
        TIMESTART(timeBlt);

	// Put things back in right-side-up coordinates
	ySrc = (int)pdd->biDraw.biHeight - (ySrc + dySrc);
//      ySrc = 0; // Was like this for Chicago M6!

        f = StretchBlt(hdc,xDst,yDst,dxDst,dyDst,pdd->hdcDraw,
            xSrc,ySrc,dxSrc,dySrc,SRCCOPY) != 0;
#ifdef DEBUG
        // Whistler: failure expected when desktops change
        if(!f && GetLastError() != ERROR_ACCESS_DENIED) {
            DPF(("StretchBlt failed %d", GetLastError()));
        }
#endif
        f = TRUE;

	FlushBuffer();

        TIMEEND(timeBlt);
    }
    else
drawit:
    {

	// Sometimes when you read an RLE file, you get RGB data back (ie. the
	// first frame).  Passing RGB data to a display driver who thinks it
	// is getting RLE data will blow it up.  If the RLE data is the exact
	// size of RGB data, we decide that's just too much of a coincidence.
	BOOL fNotReallyRLE = (pdd->biDraw.biCompression == BI_RLE8 &&
	    lpbi->biSizeImage == DIBWIDTHBYTES(*lpbi) * (DWORD)lpbi->biHeight);

        if (wFlags & DDF_DONTDRAW)
        {
            f = TRUE;
            goto exit;
        }

	if (fNotReallyRLE)
	    pdd->biDraw.biCompression = BI_RGB;

        TIMESTART(timeBlt);

// NT StretchDIBits does not work with RLE deltas, even 1:1
#ifndef CHICAGO
	/*
	 * also note use of pdd->uiPalUse: this is DIB_PAL_COLORS by
	 * default, but may be set to DIB_PAL_INDICES if we detect that
	 * the system palette is identical to ours, and thus
	 * we can safely take this huge performance benefit (on NT,
	 * DIB_PAL_INDICES nearly halves the cost of this call)
	 */
        if ((dxDst == dxSrc) && (dyDst == dySrc))
        {
            f = SetDIBitsToDevice(hdc, xDst, yDst, dxDst, dyDst,
                    xSrc, ySrc, 0, (UINT)pdd->biDraw.biHeight, lpBits,
                    (LPBITMAPINFO)&pdd->biDraw, pdd->uiPalUse) != 0;
        }
        else
#endif
        {
            f = StretchDIBits(hdc,xDst,yDst,dxDst,dyDst,
                xSrc,ySrc,dxSrc,dySrc,
                lpBits, (LPBITMAPINFO)&pdd->biDraw,
                pdd->uiPalUse, SRCCOPY) != 0;
	}

        FlushBuffer();

        TIMEEND(timeBlt);

	if (fNotReallyRLE)
	    pdd->biDraw.biCompression = BI_RLE8;
    }

exit:

#ifdef _WIN32
    // from build 549 (or thereabouts) we need at least one of these per
    // frame!
    // But not if we are using DCI??  Although the cost is small so leave it in
    GdiFlush();
#endif

    if (!(wFlags & DDF_SAME_HDC) && pdd->hpal)
	SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);

    TIMEEND(timeDraw);
    return f;
}

#if 0
/**************************************************************************
* @doc INTERNAL
*
* @api BOOL| InitDrawToScreen | init drawing to the screen via DCI
*
**************************************************************************/
static BOOL InitDrawToScreen(PDD pdd)
{
    BOOL f;

    if (!(pdd->ulFlags & DDF_CANDRAWX))
        return FALSE;

    f = !(pdd->ulFlags & DDF_CLIPPED);

    if (f && !(pdd->ulFlags & DDF_DRAWX))
    {
        DPF(("drawing to SCREEN now"));

        pdd->ulFlags |= DDF_DRAWX;
    }
    else if (!f && (pdd->ulFlags & DDF_DRAWX))
    {
        DPF(("not drawing to SCREEN anymore"));

        pdd->ulFlags &= ~DDF_DRAWX;
    }
}
#endif

/**************************************************************************
* @doc INTERNAL
*
* @api BOOL| InitDecompress | init every thing for decompressing
*   to the screen or a bitmap or a memory buffer.
*
* we can decompress to the screen if the following is true:
*
*   palette must be 1:1
*   must be unclipped
*
**************************************************************************/
static BOOL InitDecompress(PDD pdd)
{
    BOOL f;
    BOOL fBitmap;
    BOOL fScreen;

    //
    // nothing to init
    //
    if (!(pdd->ulFlags & (DDF_CANSCREENX|DDF_CANBITMAPX)))
        return TRUE;

    //
    // make sure we rebegin when the palette changes
    //
    if (pdd->ulFlags & (DDF_NEWPALETTE|DDF_WANTKEY))
        pdd->iDecompress = 0;

    //
    // we need to decompress to either a memory bitmap or buffer.
    //
    fBitmap = (pdd->ulFlags & DDF_CANBITMAPX) &&
              (pdd->ulFlags & DDF_IDENTITYPAL|DDF_CANSETPAL);

    fScreen = (pdd->ulFlags & DDF_CANSCREENX) &&
             !(pdd->ulFlags & DDF_CLIPPED)    &&
              (pdd->ulFlags & DDF_IDENTITYPAL|DDF_CANSETPAL);

    //
    // should we be decompressing to the screen?
    //
#ifdef USE_DCI
    if (fScreen && pdd->iDecompress != DECOMPRESS_SCREEN)
    {
        if (pdd->ulFlags & DDF_IDENTITYPAL)
        {
            if (pdd->hpalDraw)
                ICDecompressSetPalette(pdd->hic, &pdd->biBuffer);
            else
                ICDecompressSetPalette(pdd->hic, NULL);
        }
        else
        {
            if (FixUpCodecPalette(pdd->hic, pdd->lpbi))
            {
                DPF(("Codec notified of palette change...."));
            }
            else
            {
                DPF(("Codec failed palette change...."));
		pdd->iDecompress = 0;
                goto ack;
            }
        }

	//
        // now init the compressor for screen decompress.
        //
        f = ICDecompressExBegin(pdd->hic, 0,
				pdd->lpbi, NULL, 0, 0, pdd->dxSrc, pdd->dySrc,
				(LPBITMAPINFOHEADER) &biScreen, lpScreen,
				0, 0, pdd->dxDst, pdd->dyDst) == ICERR_OK;

        if (f)
        {
	    pdd->ulFlags |= DDF_DIRTY;          // buffer is dirty now?
            RPF(("Decompressing to screen now"));
	    pdd->iDecompress = DECOMPRESS_SCREEN;
            return TRUE;
        }
        else
        {
ack:        DPF(("Compressor failed decompress to SCREEN, so not decompressing to screen!!!!"));
	    pdd->iDecompress = 0;
            pdd->ulFlags &= ~DDF_CANSCREENX;
        }
    }
    else if (fScreen)
    {
        //
        //  already decompressing to screen.
        //
        return TRUE;
    }
#endif

    if (fBitmap && pdd->iDecompress != DECOMPRESS_BITMAP)
    {
        if (pdd->ulFlags & DDF_IDENTITYPAL)
        {
            if (pdd->hpalDraw)
                ICDecompressSetPalette(pdd->hic, &pdd->biBuffer);
            else
                ICDecompressSetPalette(pdd->hic, NULL);
        }
        else
        {
            if (FixUpCodecPalette(pdd->hic, pdd->lpbi))
            {
                DPF(("Codec notified of palette change...."));
            }
            else
            {
                DPF(("Codec failed palette change...."));
		pdd->iDecompress = 0;
                goto ackack;
            }
        }

        f = ICDecompressBegin(pdd->hic, pdd->lpbi, &pdd->biBitmap) == ICERR_OK;

	if (f)
	{
	    DPF(("decompressing to BITMAP now"));

	    pdd->ulFlags |= DDF_DIRTY;          // buffer is dirty now?
	    pdd->iDecompress = DECOMPRESS_BITMAP;

	    // naked bitmap translate stuff?

	    return TRUE;
	}
	else
	{
ackack:     DPF(("Unable to init decompress to bitmap"));
	    pdd->iDecompress = 0;
        }
    }
    else if (fBitmap)
    {
        //
        //  already decompressing to bitmap.
        //
        return TRUE;
    }
	
    //
    // should we decompress to a buffer?
    //
    if (pdd->iDecompress != DECOMPRESS_BUFFER)
    {
	DPF(("decompressing to DIB now"));

        pdd->ulFlags |= DDF_DIRTY;          // buffer is dirty now?
        pdd->iDecompress = DECOMPRESS_BUFFER;

        if (pdd->hpalDraw)
            ICDecompressSetPalette(pdd->hic, &pdd->biBuffer);
        else
            ICDecompressSetPalette(pdd->hic, NULL);

        f = ICDecompressBegin(pdd->hic, pdd->lpbi, &pdd->biBuffer) == ICERR_OK;

        if (!f)
        {
            DPF(("Unable to re-begin compressor"));
        }
    }

    return TRUE;    // nothing to change
}

/**************************************************************************
* @doc INTERNAL
*
* @api void | DrawDibClipChange | called when the clipping has changed
*   from clipped to totaly un-clipped or whatever.
*
**************************************************************************/
static void DrawDibClipChange(PDD pdd, UINT wFlags)
{
    if (!(pdd->ulFlags & DDF_NEWPALETTE))
    {
	if (pdd->ulFlags & DDF_CLIPPED)
	    DPF(("now clipped"));
	else
	    DPF(("now un-clipped"));
    }

////InitDrawToScreen(pdd);

    //
    // dont change Decompressors on a non key frame, unless we have
    // to (ie getting clipped while decompressing to screen)
    //
    if (pdd->ulFlags & DDF_NEWPALETTE)
    {
	if (wFlags & DDF_NOTKEYFRAME)
	{
	    if (pdd->iDecompress == DECOMPRESS_BUFFER)
	    {
		DPF(("waiting for a key frame to change decompressor (palette change)"));
		pdd->ulFlags |= DDF_WANTKEY;
		return;
	    }
	}
    }
    else
    {
        if (wFlags & DDF_NOTKEYFRAME)
        {
            if (pdd->iDecompress != DECOMPRESS_SCREEN) // !(pdd->ulFlags & DDF_SCREENX))
            {
                DPF(("waiting for a key frame to change (clipped) decompressor"));
                pdd->ulFlags |= DDF_WANTKEY;
                return;
            }
        }
    }

    InitDecompress(pdd);
    pdd->ulFlags &= ~DDF_WANTKEY;
}

/**************************************************************************
* @doc INTERNAL
*
* @api void | DrawDibPalChange | called when the physical palette mapping
*   has changed.
*
**************************************************************************/
static void DrawDibPalChange(PDD pdd, HDC hdc, HPALETTE hpal)
{
#ifndef _WIN32
#ifdef DEBUG
	extern BOOL FAR PASCAL IsDCCurrentPalette(HDC hdc);

	BOOL fForeground = IsDCCurrentPalette(hdc);

        if (fForeground)
	    DPF(("Palette mapping has changed (foreground)..."));
	else
            DPF(("Palette mapping has changed (background)..."));
#endif
#endif

    //
    // if we are on a palette device we need to do some special stuff.
    //
    if (gwScreenBitDepth == 8 && (gwRasterCaps & RC_PALETTE))
    {
        //
        // get the logical->physical mapping
        //
        if (GetPhysDibPaletteMap(hdc, &pdd->biDraw, pdd->uiPalUse, pdd->ab))
            pdd->ulFlags |= DDF_IDENTITYPAL;
        else
	    pdd->ulFlags &= ~DDF_IDENTITYPAL;

        if (pdd->ulFlags & DDF_IDENTITYPAL)
            DPF(("Palette mapping is 1:1"));
	else
	    DPF(("Palette mapping is not 1:1"));

#ifdef DAYTONA // !!! Not on Chicago!
	if (pdd->ulFlags & DDF_IDENTITYPAL) {
            DPF(("using DIB_PAL_INDICES"));
	    pdd->uiPalUse = DIB_PAL_INDICES;
	} else {
	    pdd->uiPalUse = DIB_PAL_COLORS;
        }
#endif
    }
    else
    {
        //
        // we are not on a palette device, some code checks DDF_IDENTITYPAL
        // anyway so set it.
        //
        pdd->ulFlags |= DDF_IDENTITYPAL;
    }

    if (pdd->hbmDraw && (pdd->ulFlags & DDF_BITMAP))
    {
        //!!! we should pass pdd->ab to this function!
        //!!! and use a naked translate.
        SetBitmapColorChange(&pdd->sd, hdc, hpal);
    }

    DrawDibClipChange(pdd, DDF_NOTKEYFRAME);
}

/**************************************************************************
* @doc INTERNAL
*
* @api HPALETTE | CreateBIPalette | Create palette from bitmap.
*
* @parm LPBITMAPINFOHEADER | lpbi | Pointer to bitmap.
*
* @rdesc Returns handle to the palette, NULL if error.
*
**************************************************************************/
STATICFN HPALETTE CreateBIPalette(HPALETTE hpal, LPBITMAPINFOHEADER lpbi)
{
    LPRGBQUAD prgb;
    int i;

    // This structure is the same as LOGPALETTE EXCEPT for the array of
    // palette entries which here is 256 long.  The "template" in the
    // SDK header files only has an array of size one, hence the "duplication".
    struct {
	WORD         palVersion;                /* tomor - don't mess with word */
	WORD         palNumEntries;
	PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palVersion = 0x300;
    pal.palNumEntries = (int)lpbi->biClrUsed;

    if (pal.palNumEntries == 0 && lpbi->biBitCount <= 8)
        pal.palNumEntries = (1 << (int)lpbi->biBitCount);

    if (pal.palNumEntries == 0)
        return NULL;

    prgb = (LPRGBQUAD)(lpbi+1);

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = prgb[i].rgbRed;
        pal.palPalEntry[i].peGreen = prgb[i].rgbGreen;
        pal.palPalEntry[i].peBlue  = prgb[i].rgbBlue;
        pal.palPalEntry[i].peFlags = 0;
    }

    if (hpal)
    {
	ResizePalette(hpal, pal.palNumEntries);
	SetPaletteEntries(hpal, 0, pal.palNumEntries, pal.palPalEntry);
    }
    else
    {
	hpal = CreatePalette((LPLOGPALETTE)&pal);
    }

    return hpal;
}

/**************************************************************************
* @doc INTERNAL
*
* @api BOOL | SetPalFlags | Modifies the palette flags.
*
* @parm HPALETTE | hpal | Handle to the palette.
*
* @parm int | iIndex | Starting palette index.
*
* @parm int | cntEntries | Number of entries to set flags on.
*
* @parm UINT | wFlags | Palette flags.
*
* @rdesc Returns TRUE if successful, FALSE otherwise.
*
**************************************************************************/
STATICFN BOOL SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags)
{
    int     i;
    PALETTEENTRY ape[256];

    if (hpal == NULL)
        return FALSE;

    if (cntEntries < 0) {
	cntEntries = 0; // GetObject returns 2 bytes
        GetObject(hpal,sizeof(int),(LPSTR)&cntEntries);
    }

    GetPaletteEntries(hpal, iIndex, cntEntries, ape);

    for (i=0; i<cntEntries; i++)
        ape[i].peFlags = (BYTE)wFlags;

    return SetPaletteEntries(hpal, iIndex, cntEntries, ape);
}


/**************************************************************************
* @doc INTERNAL
*
* @api BOOL | IsIdentityPalette | Check if palette is an identity palette.
*
* @parm HPALETTE | hpal | Handle to the palette.
*
* @rdesc Returns TRUE if the palette is an identity palette, FALSE otherwise.
*
**************************************************************************/

#define CODE _based(_segname("_CODE"))

//
// These are the standard VGA colors, we will be stuck with until the
// end of time!
//
static PALETTEENTRY CODE apeCosmic[16] = {
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x80, 0x00, 0x00, 0x00,     // 0001  dark red
    0x00, 0x80, 0x00, 0x00,     // 0010  dark green
    0x80, 0x80, 0x00, 0x00,     // 0011  mustard
    0x00, 0x00, 0x80, 0x00,     // 0100  dark blue
    0x80, 0x00, 0x80, 0x00,     // 0101  purple
    0x00, 0x80, 0x80, 0x00,     // 0110  dark turquoise
    0xC0, 0xC0, 0xC0, 0x00,     // 1000  gray
    0x80, 0x80, 0x80, 0x00,     // 0111  dark gray
    0xFF, 0x00, 0x00, 0x00,     // 1001  red
    0x00, 0xFF, 0x00, 0x00,     // 1010  green
    0xFF, 0xFF, 0x00, 0x00,     // 1011  yellow
    0x00, 0x00, 0xFF, 0x00,     // 1100  blue
    0xFF, 0x00, 0xFF, 0x00,     // 1101  pink (magenta)
    0x00, 0xFF, 0xFF, 0x00,     // 1110  cyan
    0xFF, 0xFF, 0xFF, 0x00      // 1111  white
    };

static PALETTEENTRY CODE apeFake[16] = {
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0xBF, 0x00, 0x00, 0x00,     // 0001  dark red
    0x00, 0xBF, 0x00, 0x00,     // 0010  dark green
    0xBF, 0xBF, 0x00, 0x00,     // 0011  mustard
    0x00, 0x00, 0xBF, 0x00,     // 0100  dark blue
    0xBF, 0x00, 0xBF, 0x00,     // 0101  purple
    0x00, 0xBF, 0xBF, 0x00,     // 0110  dark turquoise
    0xC0, 0xC0, 0xC0, 0x00,     // 1000  gray
    0x80, 0x80, 0x80, 0x00,     // 0111  dark gray
    0xFF, 0x00, 0x00, 0x00,     // 1001  red
    0x00, 0xFF, 0x00, 0x00,     // 1010  green
    0xFF, 0xFF, 0x00, 0x00,     // 1011  yellow
    0x00, 0x00, 0xFF, 0x00,     // 1100  blue
    0xFF, 0x00, 0xFF, 0x00,     // 1101  pink (magenta)
    0x00, 0xFF, 0xFF, 0x00,     // 1110  cyan
    0xFF, 0xFF, 0xFF, 0x00,     // 1111  white
    };

static PALETTEENTRY CODE apeBlackWhite[16] = {
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0xFF, 0xFF, 0xFF, 0x00      // 1111  white
    };

STATICFN BOOL NEAR IsIdentityPalette(HPALETTE hpal)
{
    int i,n=0;    // n is initialised as GetObject returns a 2 byte value
    HDC hdc;

    PALETTEENTRY ape[256];
    PALETTEENTRY apeSystem[16];

    if (hpal == NULL || !(gwRasterCaps & RC_PALETTE) || gwScreenBitDepth != 8)
        return FALSE;

    // Some wierd display cards actually have different numbers of system
    // colours! We definitely don't want to think we can do identity palettes.
    hdc = GetDC(NULL);
    n = GetDeviceCaps(hdc, NUMRESERVED);
    ReleaseDC(NULL, hdc);

    if (n != 20)
	return FALSE;

    GetObject(hpal, sizeof(n), (LPVOID)&n);

    if (n != 256)
	return FALSE;

    GetPaletteEntries(hpal, 0,	 8, &ape[0]);
    GetPaletteEntries(hpal, 248, 8, &ape[8]);

    for (i=0; i<16; i++)
	ape[i].peFlags = 0;

    if (!_fmemcmp(ape, apeCosmic, sizeof(apeCosmic)))
        goto DoneChecking;

    if (!_fmemcmp(ape, apeFake, sizeof(apeFake)))
	goto DoneChecking;

    if (!_fmemcmp(ape, apeBlackWhite, sizeof(apeBlackWhite)))
        goto DoneChecking;

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0,   8, &apeSystem[0]);
    GetSystemPaletteEntries(hdc, 248, 8, &apeSystem[8]);
    ReleaseDC(NULL, hdc);

    for (i=0; i<16; i++)
	apeSystem[i].peFlags = 0;

    if (!_fmemcmp(ape, apeSystem, sizeof(apeSystem)))
        goto DoneChecking;

    return FALSE;

DoneChecking:
    //
    // if we have an identity palette then, patch the colors to match
    // the driver ones exactly.
    //
    GetPaletteEntries(hpal, 0, 256, ape);

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0,   10, &ape[0]);
    GetSystemPaletteEntries(hdc, 246, 10, &ape[246]);
    ReleaseDC(NULL, hdc);

    for (i=0; i<10; i++)
        ape[i].peFlags = 0;

    for (i=10; i<246; i++)
        ape[i].peFlags = PC_NOCOLLAPSE;

    for (i=246; i<256; i++)
        ape[i].peFlags = 0;

    SetPaletteEntries(hpal, 0, 256, ape);
    DPF(("Calling UnrealizeObject on hpal==%8x\n", hpal));
    UnrealizeObject(hpal);      //??? needed

    return TRUE;
}

#define COLORMASK 0xF8
STATICFN BOOL NEAR AreColorsAllGDIColors(LPBITMAPINFOHEADER lpbi)
{
    int	    cColors;
    LPRGBQUAD lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi->biSize);
    int	    i;

    for (cColors = (int) lpbi->biClrUsed; cColors > 0; cColors--, lprgb++) {
	for (i = 0; i < 16; i++) {
	    if (((lprgb->rgbRed & COLORMASK) == (apeCosmic[i].peRed & COLORMASK)) &&
		((lprgb->rgbGreen & COLORMASK) == (apeCosmic[i].peGreen & COLORMASK)) &&
		((lprgb->rgbBlue & COLORMASK) == (apeCosmic[i].peBlue & COLORMASK)))
		goto Onward;
	
	    if (((lprgb->rgbRed & COLORMASK) == (apeFake[i].peRed & COLORMASK)) &&
		((lprgb->rgbGreen & COLORMASK) == (apeFake[i].peGreen & COLORMASK)) &&
		((lprgb->rgbBlue & COLORMASK) == (apeFake[i].peBlue & COLORMASK)))
		goto Onward;
	}

	return FALSE;
Onward:
	;	// There's got to be a nicer way to arrange this code!
    }

    return TRUE; // !!!!!
}

#if 0
#ifdef _WIN32
/*
 * check if the system palette is identical to the palette we want
 * to draw with. This should be the same as checking both IsIdentityPalette
 * and also that we have the foreground window. If the palettes are the same,
 * then set a flag showing that we can safely use DIB_PAL_INDICES instead of
 * DIB_PAL_COLORS.
 *
 * On NT at least, DIB_PAL_INDICES saves a large amount of time from the
 * critical GDI drawing call (SetDIBitsToDevice). But we can only use it
 * if our palette is really the same as the system palette. This function
 * should be called from the WM_NEWPALETTE message so that every time
 * a new palette is realised (by us or anyone else) we will accurately set
 * this flag.
 */
static void DrawDibCheckPalette(PDD pdd)
{
    PALETTEENTRY apeSystem[256];
    PALETTEENTRY apeLocal[256];
    UINT palcount = 0;  // GetObject stores two bytes.  Rest of code prefers 32 bits
    HDC hdc;
    HPALETTE hpal;

    hpal = (pdd->hpalDraw ? pdd->hpalDraw : pdd->hpal);

    if (hpal == NULL)
        return;

    /*
     * check that it is 8-bit colour in use
     */

    if (gwScreenBitDepth != 8 || !(gwRasterCaps & RC_PALETTE))
	return ;

    GetObject(hpal, sizeof(palcount), (LPVOID)&palcount);

    if (palcount != 256)
	return ;

    /*
     * read all the system palette
     */
    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0, 256, apeSystem);
    ReleaseDC(NULL, hdc);

    /* read local palette entries */
    GetPaletteEntries(hpal, 0, 256, apeLocal);

    /* compare colours */
#define BETTER_PAL_INDICES   // Faster when the result is DIB_PAL_INDICES
#ifdef BETTER_PAL_INDICES    // but slower when DIB_PAL_COLORS is the outcome
			     // unless the quick check is OK
    StartCounting();
    if (apeLocal[17].peRed == apeSystem[17].peRed) { // Quick check
	for (palcount=256; palcount--; ) {
	    apeLocal[palcount].peFlags = apeSystem[palcount].peFlags = 0;
	}  // its a shame we have to clear the flags out

	if (!memcmp(apeLocal, apeSystem, sizeof(apeSystem))) {
	    /* all ok - we can use INDICES */
	    RPF(("\tUsing PAL_INDICES"));
	    pdd->uiPalUse = DIB_PAL_INDICES;
	    EndCounting("(memcmp) DIB_PAL_INDICES");
	    return;
        }
    }
    /* comparison failed - forget it */
    RPF(("\tUsing DIB_PAL_COLORS"));
    pdd->uiPalUse = DIB_PAL_COLORS;
    EndCounting("(memcmp) DIB_PAL_COLORS");

#else

    StartCounting();
    for (palcount = 0; palcount < 256; palcount++) {
	if ((apeLocal[palcount].peRed != apeSystem[palcount].peRed) ||
	    (apeLocal[palcount].peGreen != apeSystem[palcount].peGreen) ||
	    (apeLocal[palcount].peBlue != apeSystem[palcount].peBlue))  {

		/* comparison failed - forget it */
		DPF(("\tUsing DIB_PAL_COLORS  Failed with palcount=%d",palcount));

		pdd->uiPalUse = DIB_PAL_COLORS;
		EndCounting("         DIB_PAL_COLORS");
		return;
	}
    }

    /* all ok - we can use INDICES */
    RPF(("\tUsing PAL_INDICES"));
    pdd->uiPalUse = DIB_PAL_INDICES;
    EndCounting("         DIB_PAL_INDICES");
#endif
}

#endif
#endif



/**************************************************************************

let codec adapt to the system palette.

**************************************************************************/

static BOOL FixUpCodecPalette(HIC hic, LPBITMAPINFOHEADER lpbi)
{
    struct {
	BITMAPINFOHEADER bi;
        RGBQUAD          argbq[256];
    } s;
    int                 i;
    HDC                 hdc;

    s.bi.biSize           = sizeof(s.bi);
    s.bi.biWidth          = lpbi->biWidth;
    s.bi.biHeight         = lpbi->biHeight;
    s.bi.biPlanes         = 1;
    s.bi.biBitCount       = 8;
    s.bi.biCompression    = 0;
    s.bi.biSizeImage      = 0;
    s.bi.biXPelsPerMeter  = 0;
    s.bi.biYPelsPerMeter  = 0;
    s.bi.biClrUsed        = 256;
    s.bi.biClrImportant   = 0;

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0, 256, (LPPALETTEENTRY) &s.argbq);
    ReleaseDC(NULL, hdc);

    for (i = 0; i < 256; i++)
	((DWORD FAR*)s.argbq)[i] = i < 8 || i >= 248 ? 0 :
	    RGB(s.argbq[i].rgbRed,s.argbq[i].rgbGreen,s.argbq[i].rgbBlue);

    return ICDecompressSetPalette(hic, &s.bi) == ICERR_OK;
}

/**************************************************************************

let codec adapt to a palette passed by the app.

**************************************************************************/

static BOOL NEAR SendSetPalette(PDD pdd)
{
    int  i;
    int  iPalColors = 0;
    BOOL f;

    if (pdd->hic == NULL)               // nobody to send too
        return FALSE;

    if (pdd->biBuffer.biBitCount != 8)  // not decompressing to 8bit
        return FALSE;

    if (!(gwRasterCaps & RC_PALETTE))   // not a palette device who cares.
        return FALSE;

    if (pdd->hpalDraw)
    {
        GetObject(pdd->hpalDraw, sizeof(iPalColors), (void FAR *)&iPalColors);

        if (iPalColors == 0)
            return FALSE;

        if (iPalColors > 256)
            iPalColors = 256;

        pdd->biBuffer.biClrUsed = iPalColors;
        GetPaletteEntries(pdd->hpalDraw, 0, iPalColors, (PALETTEENTRY FAR *)pdd->argbq);

        for (i = 0; i < iPalColors; i++)
            ((DWORD*)pdd->argbq)[i] = RGB(pdd->argbq[i].rgbRed,pdd->argbq[i].rgbGreen,pdd->argbq[i].rgbBlue);

        f = ICDecompressSetPalette(pdd->hic, &pdd->biBuffer) == ICERR_OK;
        ICDecompressGetPalette(pdd->hic, pdd->lpbi, &pdd->biBuffer);
    }
    else
    {
        pdd->biBuffer.biClrUsed = pdd->ClrUsed;
        f = ICDecompressSetPalette(pdd->hic, NULL) == ICERR_OK;
        ICDecompressGetPalette(pdd->hic, pdd->lpbi, &pdd->biBuffer);
    }

    return f;
}

#ifdef DEBUG_RETAIL

#define _WINDLL
#include <stdarg.h>
#include <stdio.h>

void FAR CDECL ddprintf(LPSTR szFormat, ...)
{
    char ach[128];
    va_list va;
    UINT n;

    if (fDebug == -1)
        fDebug = mmGetProfileIntA("Debug", MODNAME, FALSE);

    if (!fDebug)
        return;

    va_start(va, szFormat);
#ifdef _WIN32
    if ('+' == *szFormat) {
	n = 0;
	++szFormat;
    } else {
	n = sprintf(ach, MODNAME ": (tid %x) ", GetCurrentThreadId());
    }

    n += vsprintf(ach+n, szFormat, va);
#else
    lstrcpy(ach, MODNAME ": ");
    n = lstrlen(ach);
    n += wvsprintf(ach+n, szFormat, va);
#endif
    va_end(va);
    if ('+' == ach[n-1]) {
	--n;
    } else {
	ach[n++] = '\r';
	ach[n++] = '\n';
    }
    ach[n] = 0;
    OutputDebugStringA(ach);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\drawdibi.h ===
/**************************************************************************

    DRAWDIBI.H   - internal DrawDib include file

**************************************************************************/

// This stuff is not going to work for win64
#pragma warning(disable:4312)

#ifndef _WIN32
    #define VFWAPI  FAR PASCAL _loadds
    #define VFWAPIV FAR CDECL _loadds
#endif

//#define MEASURE_PERFORMANCE

#if defined(MEASURE_PERFORMANCE) && defined(_WIN32) && defined(DEBUG)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

/**************************************************************************
includes
**************************************************************************/

#include <win32.h>      // for Win32 and Win16
#include <memory.h>     // for _fmemcmp
#include <vfw.h>

#include "dither.h"
#include "stretch.h"
#include "lockbm.h"
#include "setdi.h"
#include "dciman.h"

/**************************************************************************
**************************************************************************/

#define DDF_OURFLAGS        0xFFFFC000l  /* internal flags */
#define DDF_MEMORYDC        0x00008000l  /* drawing to a memory DC */
#define DDF_WANTKEY         0x00004000l  /* wait for a key frame */
#define DDF_STRETCH         0x00010000l  /* we need to stretch */
#define DDF_DITHER          0x00020000l  /* we need to dither */
#define DDF_BITMAP          0x00040000l  /* Display driver isn't very good */
#define DDF_X               0x00080000l  /*  */
#define DDF_IDENTITYPAL     0x00100000l  /* 1:1 palette mapping */
#define DDF_CANBITMAPX      0x00200000l  /* can decompress to bitmap */
#define DDF_CANSCREENX      0x00400000l  /* we can decompress/draw to screen */
#define DDF_Y               0x00800000l  /*  */
#define DDF_DIRTY           0x01000000l  /* decompress buffer is dirty (not valid) */
#define DDF_HUGEBITMAP      0x02000000l  /* decompressing to a HUGE bitmap */
#define DDF_XLATSOURCE      0x04000000l  /* need to xlat source cord. */
#define DDF_CLIPPED         0x08000000l  /* currently clipped */
#define DDF_NEWPALETTE      0x10000000l  /* palette needs mapped */
#define DDF_CLIPCHECK       0x20000000l  /* we care about clipping */
#define DDF_CANDRAWX        0x40000000l  /* we can draw direct to screen */
#define DDF_CANSETPAL       0x80000000l  /* codec supports ICM_SETPALETTE */

#define DDF_USERFLAGS       0x00003FFFl  /* the user/called gives these, see .h */

/* these flags change what DrawDibBegin does */
#define DDF_BEGINFLAGS      (DDF_JUSTDRAWIT | DDF_BUFFER | DDF_ANIMATE | DDF_FULLSCREEN | DDF_HALFTONE)

/**************************************************************************

flags, a little more info for people who are not me

    DDF_OURFLAGS        these are internal state flags, not passed in by
                        the user.

    DDF_STRETCH         the current draw requires us to stretch, if GDI
                        is stretching this bit is clear.

    DDF_DITHER          the current draw requires a format conversion
                        note a 16->24 32->24 conversion is also called
                        a dither, again if GDI is taking care of it this
                        bit is clear.

    DDF_BITMAP          the display driver isn't very good and we are converting
                        DIB to BMPs before drawing

    DDF_CANBITMAPX      we can decompress to bitmaps.

    DDF_BITMAPX         we are decompressing directly into a bitmap

    DDF_IDENTITYPAL     the palette is a identity palette.

    DDF_CANSCREENX      we can decompress to screen with the current draw
                        params.

    DDF_SCREENX         we are currently decompressing to the screen.

    DDF_DIRTY           the decompress buffer is dirty, ie does not
                        match what *should* be on the screen.

    DDF_HUGEBITMAP      we are decompressing into a huge bitmap, and
                        then calling FlatToHuge...

    DDF_XLATSOURCE      the source cordinates need remapping after
                        decompression, (basicly the decompressor is
                        doing a stretch...)

    DDF_UPDATE          the buffer is valid but needs drawn to the screen.
                        this will get set when DDF_DONTDRAW is passed, and
                        we are decompressing to memory

                        another way to put it is, if DDF_UPDATE is set
                        the screen is out of sync with our internal
                        buffer (the internal buffer is more correct)

    DDF_CLIPPED         we are clipped

    DDF_NEWPALETTE      we need to build new palette map

    DDF_CLIPCHECK       please check for clipping changes.
    DDF_W
    DDF_Q

    DDF_USERFLAGS       these flags are defined in the API, the user will pass
                        these to us.

    DDF_BEGINFLAGS      these flags will effect what DrawDibBegin() does

**************************************************************************/

/**************************************************************************
**************************************************************************/

#ifdef DEBUG
    #define DPF0( x ) {	\
	       		int fSave = fDebug; \
			fDebug = 1;	    \
			ddprintf x ;        \
			fDebug = fSave;     \
		      }
    #define DPF2( x ) if (fDebug >= 2 ){    \
			ddprintf x ;        \
		      }
    #define DPF( x ) ddprintf x
    #define DEBUG_RETAIL
#else
    #define DPF2(x)
    #define DPF0(x)
    #define DPF(x)
#endif

#ifdef DEBUG_RETAIL
    #define MODNAME "DRAWDIB"

    extern void FAR cdecl ddprintf(LPSTR szFormat, ...);

    #define RPF( x ) ddprintf x
#else
    #define RPF(X)
#endif

/**************************************************************************
*  The biXXXXX elements are grouped at the end to minimise the chance of
*  overwriting non bitmap data (i.e. pointers).  IF the code was totally
*  clean this would be irrelevant, however it does increase robustness.
**************************************************************************/

typedef struct {
    UINT                wSize;		/* MANDATORY: this MUST be the first field */
    ULONG               ulFlags;
    UINT                wError;

    #define DECOMPRESS_NONE   0
    #define DECOMPRESS_BITMAP 1
    #define DECOMPRESS_SCREEN 2
    #define DECOMPRESS_BUFFER 3
    int                 iDecompress;

    int                 dxSrc;
    int                 dySrc;
    int                 dxDst;
    int                 dyDst;

    HPALETTE            hpal;
    HPALETTE            hpalCopy;
    HPALETTE            hpalDraw;
    HPALETTE            hpalDrawLast;	/* hpalDraw for last DrawDibBegin */
    int                 ClrUsed;        /* number of colors used! */
    int                 iAnimateStart;  /* colors we can change */
    int                 iAnimateLen;
    int                 iAnimateEnd;

    int                 iPuntFrame;     /* how many frames we blew off */

    /*
     * set to DIB_RGB_COLORS, DIB_PAL_COLORS, or if on Win32 and 1:1 palette
     * DIB_PAL_INDICES (see DrawdibCheckPalette())
     *
     */
    UINT                uiPalUse;

    DITHERPROC          DitherProc;

    LPBYTE              pbBuffer;       /* decompress buffer */
    LPBYTE              pbStretch;      /* stretched bits. */

    //
    //  note we alias the stretch buffer for bitmaps too.
    //
    #define             biBitmap    biStretch
    #define             pbBitmap    pbStretch

    SETDI               sd;             /* for SetBitmap */
    HBITMAP             hbmDraw;        /* for drawing DIBs on the VGA!!! */
    HDC                 hdcDraw;
    HDC                 hdcLast;	/* hdc last call to DrawDibBegin */
    LPVOID		lpDIBSection;	/* pointer to dib section bits */

    LPBYTE              pbDither;       /* bits we will dither to */
    LPVOID              lpDitherTable;  /* for dithering */

    HIC                 hic;            /* decompressor */

#ifdef DEBUG_RETAIL
    DRAWDIBTIME         ddtime;
#endif


    LPBITMAPINFOHEADER  lpbi;           /* source dib format */
    RGBQUAD (FAR       *lpargbqIn)[256];/* source dib colors */
    BITMAPINFOHEADER    biBuffer;       /* decompress format */
    RGBQUAD             argbq[256];     /* drawdib colors */
    BITMAPINFOHEADER    biStretch;      /* stretched DIB */
    DWORD               smag[3];        /* room for masks */
    BITMAPINFOHEADER    biDraw;         /* DIB we will draw */
    WORD                aw[512];        /* either index's or RGBQs */
    BYTE                ab[256];        /* pallete mapping (!!!needed?) */

#ifndef _WIN32
    HTASK		htask;
#endif

}   DRAWDIB_STRUCT, *PDD;

/**************************************************************************
**************************************************************************/

extern DRAWDIB_STRUCT   gdd;
extern WORD             gwScreenBitDepth;
#ifndef _WIN32
extern BOOL             gf286;
#endif


/**************************************************************************
**************************************************************************/

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE_DEFAULT     0x0000

UINT (FAR PASCAL *DisplayDib)(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, UINT wFlags);
UINT (FAR PASCAL *DisplayDibEx)(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, UINT wFlags);

/**************************************************************************
**************************************************************************/

#ifdef DEBUG_RETAIL
    #define TIMEINC()        pdd->ddtime.timeCount++
    #define TIMESTART(time)  pdd->ddtime.time -= timeGetTime()
    #define TIMEEND(time)    pdd->ddtime.time += timeGetTime()
#else
    #define TIMEINC()
    #define TIMESTART(time)
    #define TIMEEND(time)
#endif

/**************************************************************************
**************************************************************************/

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (UINT)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
#define DIBSIZEIMAGE(bi)  ((DWORD)(UINT)(bi).biHeight * (DWORD)(UINT)DIBWIDTHBYTES(bi))

#define PUSHBI(bi) (int)(bi).biWidth, (int)(bi).biHeight, (int)(bi).biBitCount

/**************************************************************************
**************************************************************************/


#if defined(MEASURE_PERFORMANCE) && defined(_WIN32) && defined(DEBUG)

static LARGE_INTEGER PC1;    /* current counter value    */
static LARGE_INTEGER PC2;    /* current counter value    */
static LARGE_INTEGER PC3;    /* current counter value    */

#define abs(x)  ((x) < 0 ? -(x) : (x))

static VOID StartCounting(VOID)
{
    QueryPerformanceCounter(&PC1);
    return;
}

static VOID EndCounting(LPSTR szId)
{
    QueryPerformanceCounter(&PC2);
    PC3.QuadPart = PC2.QuadPart - PC1.QuadPart;
    DPF(("%s: %d ticks", szId, PC3.LowPart));
    return;
}

#else

#define StartCounting()
#define EndCounting(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dpal775.h ===
int dpal775[256][3] = {
         {0x00, 0x00, 0x00},    /* cosmic colors */
         {0x00, 0x00, 0x80},
	 {0x00, 0x80, 0x00},
         {0x00, 0x80, 0x80},
	 {0x80, 0x00, 0x00},
         {0x80, 0x00, 0x80},
         {0x80, 0x80, 0x00},
         {0x00, 0x00, 0x00},    // {0xc0, 0xc0, 0xc0},   //not used
         {0x00, 0x00, 0x00},    // {0xc0, 0xdc, 0xc0},   //not used
         {0x00, 0x00, 0x00},    // {0xf0, 0xca, 0xa6},   //not used
{0x00, 0x00, 0x40},
{0x00, 0x00, 0xc0},
{0x00, 0x2b, 0x00},
{0x00, 0x2b, 0x40},
{0x00, 0x2b, 0x80},
{0x00, 0x2b, 0xbf},
{0x00, 0x2b, 0xff},
{0x00, 0x55, 0x00},
{0x00, 0x55, 0x40},
{0x00, 0x55, 0x80},
{0x00, 0x55, 0xbf},
{0x00, 0x55, 0xff},
{0x00, 0x80, 0x40},
{0x00, 0x80, 0xbf},
{0x00, 0x80, 0xff},
{0x00, 0xaa, 0x00},
{0x00, 0xaa, 0x40},
{0x00, 0xaa, 0x80},
{0x00, 0xaa, 0xbf},
{0x00, 0xaa, 0xff},
{0x00, 0xd5, 0x00},
{0x00, 0xd5, 0x40},
{0x00, 0xd5, 0x80},
{0x00, 0xd5, 0xbf},
{0x00, 0xd5, 0xff},
{0x00, 0xff, 0x40},
{0x00, 0xff, 0x80},
{0x00, 0xff, 0xbf},
{0x2b, 0x00, 0x00},
{0x2b, 0x00, 0x40},
{0x2b, 0x00, 0x80},
{0x2b, 0x00, 0xbf},
{0x2b, 0x00, 0xff},
{0x2b, 0x2b, 0x00},
{0x2b, 0x2b, 0x40},
{0x2b, 0x2b, 0x80},
{0x2b, 0x2b, 0xbf},
{0x2b, 0x2b, 0xff},
{0x2b, 0x55, 0x00},
{0x2b, 0x55, 0x40},
{0x2b, 0x55, 0x80},
{0x2b, 0x55, 0xbf},
{0x2b, 0x55, 0xff},
{0x2b, 0x80, 0x00},
{0x2b, 0x80, 0x40},
{0x2b, 0x80, 0x80},
{0x2b, 0x80, 0xbf},
{0x2b, 0x80, 0xff},
{0x2b, 0xaa, 0x00},
{0x2b, 0xaa, 0x40},
{0x2b, 0xaa, 0x80},
{0x2b, 0xaa, 0xbf},
{0x2b, 0xaa, 0xff},
{0x2b, 0xd5, 0x00},
{0x2b, 0xd5, 0x40},
{0x2b, 0xd5, 0x80},
{0x2b, 0xd5, 0xbf},
{0x2b, 0xd5, 0xff},
{0x2b, 0xff, 0x00},
{0x2b, 0xff, 0x40},
{0x2b, 0xff, 0x80},
{0x2b, 0xff, 0xbf},
{0x2b, 0xff, 0xff},
{0x55, 0x00, 0x00},
{0x55, 0x00, 0x40},
{0x55, 0x00, 0x80},
{0x55, 0x00, 0xbf},
{0x55, 0x00, 0xff},
{0x55, 0x2b, 0x00},
{0x55, 0x2b, 0x40},
{0x55, 0x2b, 0x80},
{0x55, 0x2b, 0xbf},
{0x55, 0x2b, 0xff},
{0x55, 0x55, 0x00},
{0x55, 0x55, 0x40},
{0x55, 0x55, 0x80},
{0x55, 0x55, 0xbf},
{0x55, 0x55, 0xff},
{0x55, 0x80, 0x00},
{0x55, 0x80, 0x40},
{0x55, 0x80, 0x80},
{0x55, 0x80, 0xbf},
{0x55, 0x80, 0xff},
{0x55, 0xaa, 0x00},
{0x55, 0xaa, 0x40},
{0x55, 0xaa, 0x80},
{0x55, 0xaa, 0xbf},
{0x55, 0xaa, 0xff},
{0x55, 0xd5, 0x00},
{0x55, 0xd5, 0x40},
{0x55, 0xd5, 0x80},
{0x55, 0xd5, 0xbf},
{0x55, 0xd5, 0xff},
{0x55, 0xff, 0x00},
{0x55, 0xff, 0x40},
{0x55, 0xff, 0x80},
{0x55, 0xff, 0xbf},
{0x55, 0xff, 0xff},
{0x80, 0x00, 0x40},
{0x80, 0x00, 0xbf},
{0x80, 0x00, 0xff},
{0x80, 0x2b, 0x00},
{0x80, 0x2b, 0x40},
{0x80, 0x2b, 0x80},
{0x80, 0x2b, 0xbf},
{0x80, 0x2b, 0xff},
{0x80, 0x55, 0x00},
{0x80, 0x55, 0x40},
{0x80, 0x55, 0x80},
{0x80, 0x55, 0xbf},
{0x80, 0x55, 0xff},
{0x80, 0x80, 0x40},
{0x80, 0x80, 0xbf},
{0x80, 0x80, 0xff},
{0x80, 0xaa, 0x00},
{0x80, 0xaa, 0x40},
{0x80, 0xaa, 0x80},
{0x80, 0xaa, 0xbf},
{0x80, 0xaa, 0xff},
{0x80, 0xd5, 0x00},
{0x80, 0xd5, 0x40},
{0x80, 0xd5, 0x80},
{0x80, 0xd5, 0xbf},
{0x80, 0xd5, 0xff},
{0x80, 0xff, 0x00},
{0x80, 0xff, 0x40},
{0x80, 0xff, 0x80},
{0x80, 0xff, 0xbf},
{0x80, 0xff, 0xff},
{0xaa, 0x00, 0x00},
{0xaa, 0x00, 0x40},
{0xaa, 0x00, 0x80},
{0xaa, 0x00, 0xbf},
{0xaa, 0x00, 0xff},
{0xaa, 0x2b, 0x00},
{0xaa, 0x2b, 0x40},
{0xaa, 0x2b, 0x80},
{0xaa, 0x2b, 0xbf},
{0xaa, 0x2b, 0xff},
{0xaa, 0x55, 0x00},
{0xaa, 0x55, 0x40},
{0xaa, 0x55, 0x80},
{0xaa, 0x55, 0xbf},
{0xaa, 0x55, 0xff},
{0xaa, 0x80, 0x00},
{0xaa, 0x80, 0x40},
{0xaa, 0x80, 0x80},
{0xaa, 0x80, 0xbf},
{0xaa, 0x80, 0xff},
{0xaa, 0xaa, 0x00},
{0xaa, 0xaa, 0x40},
{0xaa, 0xaa, 0x80},
{0xaa, 0xaa, 0xbf},
{0xaa, 0xaa, 0xff},
{0xaa, 0xd5, 0x00},
{0xaa, 0xd5, 0x40},
{0xaa, 0xd5, 0x80},
{0xaa, 0xd5, 0xbf},
{0xaa, 0xd5, 0xff},
{0xaa, 0xff, 0x00},
{0xaa, 0xff, 0x40},
{0xaa, 0xff, 0x80},
{0xaa, 0xff, 0xbf},
{0xaa, 0xff, 0xff},
{0xd5, 0x00, 0x00},
{0xd5, 0x00, 0x40},
{0xd5, 0x00, 0x80},
{0xd5, 0x00, 0xbf},
{0xd5, 0x00, 0xff},
{0xd5, 0x2b, 0x00},
{0xd5, 0x2b, 0x40},
{0xd5, 0x2b, 0x80},
{0xd5, 0x2b, 0xbf},
{0xd5, 0x2b, 0xff},
{0xd5, 0x55, 0x00},
{0xd5, 0x55, 0x40},
{0xd5, 0x55, 0x80},
{0xd5, 0x55, 0xbf},
{0xd5, 0x55, 0xff},
{0xd5, 0x80, 0x00},
{0xd5, 0x80, 0x40},
{0xd5, 0x80, 0x80},
{0xd5, 0x80, 0xbf},
{0xd5, 0x80, 0xff},
{0xd5, 0xaa, 0x00},
{0xd5, 0xaa, 0x40},
{0xd5, 0xaa, 0x80},
{0xd5, 0xaa, 0xbf},
{0xd5, 0xaa, 0xff},
{0xd5, 0xd5, 0x00},
{0xd5, 0xd5, 0x40},
{0xd5, 0xd5, 0x80},
{0xd5, 0xd5, 0xbf},
{0xd5, 0xd5, 0xff},
{0xd5, 0xff, 0x00},
{0xd5, 0xff, 0x40},
{0xd5, 0xff, 0x80},
{0xd5, 0xff, 0xbf},
{0xd5, 0xff, 0xff},
{0xff, 0x00, 0x40},
{0xff, 0x00, 0x80},
{0xff, 0x00, 0xbf},
{0xff, 0x2b, 0x00},
{0xff, 0x2b, 0x40},
{0xff, 0x2b, 0x80},
{0xff, 0x2b, 0xbf},
{0xff, 0x2b, 0xff},
{0xff, 0x55, 0x00},
{0xff, 0x55, 0x40},
{0xff, 0x55, 0x80},
{0xff, 0x55, 0xbf},
{0xff, 0x55, 0xff},
{0xff, 0x80, 0x00},
{0xff, 0x80, 0x40},
{0xff, 0x80, 0x80},
{0xff, 0x80, 0xbf},
{0xff, 0x80, 0xff},
{0xff, 0xaa, 0x00},
{0xff, 0xaa, 0x40},
{0xff, 0xaa, 0x80},
{0xff, 0xaa, 0xbf},
{0xff, 0xaa, 0xff},
{0xff, 0xd5, 0x00},
{0xff, 0xd5, 0x40},
{0xff, 0xd5, 0x80},
{0xff, 0xd5, 0xbf},
{0xff, 0xd5, 0xff},
{0xff, 0xff, 0x40},
{0xff, 0xff, 0x80},
{0xff, 0xff, 0xbf},
{0x00, 0x00, 0x01}, /* six extra colors */
{0x00, 0x00, 0x02},
{0x00, 0x00, 0x03},
{0x00, 0x00, 0x04},
{0x00, 0x00, 0x05},
{0x00, 0x00, 0x06},
         {0x00, 0x00, 0x00},    //  {0xf0, 0xfb, 0xff}, //not used
         {0x00, 0x00, 0x00},    //  {0xa4, 0xa0, 0xa0}, //not used
         {0x80, 0x80, 0x80},
	 {0x00, 0x00, 0xff},
	 {0x00, 0xff, 0x00},
	 {0x00, 0xff, 0xff},
	 {0xff, 0x00, 0x00},
	 {0xff, 0x00, 0xff},
	 {0xff, 0xff, 0x00},
	 {0xff, 0xff, 0xff}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dtab775.h ===
BYTE rdith775[297] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210
};

BYTE gdith775[297] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\lockbm.h ===
// This stuff is not going to work for win64
#pragma warning(disable:4312)

#define BM_NULL         0
#define BM_TYPE         0x0F        // type mask
#define BM_8BIT         0x01        // all SVGA, and other 256 color
#define BM_16555        0x02        // some HiDAC cards
#define BM_24BGR        0x03        // just like a DIB
#define BM_32BGR        0x04        // 32 bit BGR
#define BM_VGA          0x05        // VGA style bitmap.
#define BM_16565        0x06        // most HiDAC cards
#define BM_24RGB        0x07        // 24 bit RGB
#define BM_32RGB        0x08        // 32 bit RGB
#define BM_1BIT         0x09        // mono bitmap
#define BM_4BIT         0x0A        // 4 bit packed pixel.

#define BM_CANLOCK      0x10        // can lock these bitmaps
#define BM_MAPFLAT      0x20        // can make bitmaps flat
#define BM_HUGE         0x40        // with FillBytes != 0 (for > 64k)
#define BM_BOTTOMTOTOP  0x80        // like a DIB

//
//  this is a physical BITMAP in memory, this is just like a  BITMAP
//  structure, but with extra fields staring at bmWidthPlanes
//
typedef struct {
    short  bmType;
    short  bmWidth;
    short  bmHeight;
    short  bmWidthBytes;
    BYTE   bmPlanes;
    BYTE   bmBitsPixel;
    LPVOID bmBits;
    long   bmWidthPlanes;
    long   bmlpPDevice;
    short  bmSegmentIndex;
    short  bmScanSegment;
    short  bmFillBytes;
    short  reserved1;
    short  reserved2;
} IBITMAP;

#define bmBitmapInfo bmWidthPlanes
#define bmOffset     bmlpPDevice
#define bmNextScan   reserved1

BOOL   FAR CanLockBitmaps(void);
UINT   FAR GetBitmapType(void);
LPVOID FAR LockBitmap(HBITMAP hbm);
LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb);
LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb);
LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi);
LPVOID FAR GetPDevice(HDC hdc);
void   FAR TestSurfaceType(HDC hdc, int x, int y);
UINT   FAR GetSurfaceType(LPVOID lpBits);

BOOL   FAR MakeBitmapFlat(HBITMAP hbm);

//void   FAR BitmapXY(IBITMAP FAR *pbm, int x, int y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\profdisp.h ===
#ifndef PD_CAN_DRAW_DIB
    #define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
    #define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
    #define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
    #define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */
#endif

    #define PD_BITBLT_FAST          0x0020      /* try decomp to bitmap? */

LRESULT VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);

LPVOID FAR TestDibFormats(int dx, int dy, BOOL fForceMe);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\lockbm.c ===
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include "lockbm.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifndef BI_BITFIELDS
    #define BI_BITFIELDS 3
#endif

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
//  GDI!GDIInit2()      GDI.403
//
//  this GDI function does the following:
//
//      GetSetBitmapHandle(hbm, 0)  - will return global handle of bitmap
//
//      GetSetBitmapHandle(hbm, h)  - will set global handle to <h>
//
//      GetSetBitmapHandle(hbm, -1) - will set global handle to NULL
//
static HANDLE (FAR PASCAL *GetSetBitmapHandle)(HBITMAP hbm, HANDLE h);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#define muldiv(a,b,c) (UINT)(((DWORD)(UINT)(a) * (DWORD)(UINT)(b)) / (UINT)(c))

//////////////////////////////////////////////////////////////////////////////
//
// CanLockBitmaps()
//
// determime if we can lock bitmaps on the current display device
//
//////////////////////////////////////////////////////////////////////////////
BOOL FAR CanLockBitmaps(void)
{
#ifndef _WIN32
    //its not safe to do this on NT. god only knows what gdi.403 is on future
    //nt platforms - the only thing we can be sure of is that it is NOT
    // GetSetBitmapHandle()

    UINT w;
    UINT rc;
    HDC  hdc;
    BOOL f;

    static BOOL fCanLockBitmaps = -1;

    if (fCanLockBitmaps == -1)
    {
        w = (UINT)GetVersion();

        w = ((UINT)LOBYTE(w) << 8) | HIBYTE(w);

        hdc = GetDC(NULL);
        rc = GetDeviceCaps(hdc, RASTERCAPS);
        ReleaseDC(NULL, hdc);

        (FARPROC)GetSetBitmapHandle =
            GetProcAddress(GetModuleHandle(TEXT("GDI")),(LPCSTR)MAKEINTATOM(403));
#ifdef _WIN32
            // MAKEINTATOM returns a LPTSTR.
            // GetProcAddress wants LPCSTR - NOT Unicode.  Hence we cast
#endif

        //
        // assume we dont need this on windows 4.0?
        //
        // what about the DIBENG? it does DEVBITS and in win 4.0?
        //
        // if the display handles device bitmaps, dont do this either
        //

        f = GetProfileIntA("DrawDib", "Bitmaps", TRUE);

#ifdef DEBUG
        fCanLockBitmaps = f && GetSetBitmapHandle != NULL;
#else
        fCanLockBitmaps = f && /* (w < 0x0400) && */
                          !(rc & RC_DEVBITS) &&
                          GetSetBitmapHandle != NULL;
#endif
    }

    return fCanLockBitmaps;
#else
    return FALSE;
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// LockBitmap
//
// return a pointer to the bitmap bits
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR LockBitmap(HBITMAP hbm)
{
    return GetBitmap(hbm, NULL, 0);
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmapDIB
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb)
{
    IBITMAP FAR *pbm;

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

    if (p == NULL || cb < sizeof(BITMAP))
        return lpBits;

    pbm = p;

    if (lpbi->biCompression == 0)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            case 0x0101: pbm->bmType = BM_1BIT;  break;
            case 0x0104: pbm->bmType = BM_4BIT;  break;
            case 0x0108: pbm->bmType = BM_8BIT;  break;
            case 0x0110: pbm->bmType = BM_16555; break;
            case 0x0118: pbm->bmType = BM_24BGR; break;
            case 0x0120: pbm->bmType = BM_32BGR; break;
            case 0x0401: pbm->bmType = BM_VGA;   break;
            default: return NULL;
        }
    }
    else if (lpbi->biCompression == BI_BITFIELDS)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            //!!! hack: realy should check the bit fields!
            case 0x0110: pbm->bmType = BM_16565; break;
            case 0x0118: pbm->bmType = BM_24RGB; break;
            case 0x0120: pbm->bmType = BM_32RGB; break;
            default: return NULL;
        }
    }
    else
        return NULL;

    pbm->bmWidth        = (int)lpbi->biWidth;
    pbm->bmHeight       = ((int)lpbi->biHeight > 0) ? (int)lpbi->biHeight : -(int)lpbi->biHeight;
    pbm->bmWidthBytes   = (((int)lpbi->biBitCount * (int)lpbi->biWidth + 31)&~31)/8;
    pbm->bmPlanes       = (BYTE)lpbi->biPlanes;
    pbm->bmBitsPixel    = (BYTE)lpbi->biBitCount;
    pbm->bmBits         = lpBits;

    if (cb > sizeof(BITMAP))
    {
        pbm->bmSegmentIndex = 0;
        pbm->bmScanSegment  = pbm->bmHeight;
        pbm->bmFillBytes    = 0;
        pbm->bmBitmapInfo   = (LONG)(LONG_PTR)lpbi;

        if ((long)lpbi->biHeight < 0)
        {
            pbm->bmNextScan = -pbm->bmWidthBytes;
            pbm->bmOffset   = (long)pbm->bmWidthBytes * (pbm->bmHeight-1);
        }
        else
        {
            pbm->bmNextScan = pbm->bmWidthBytes;
            pbm->bmOffset   = 0;
        }
    }

    return lpBits;
}

#if 0
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void FAR BitmapXY(IBITMAP FAR *pbm, int x, int y)
{
    UINT t;

    if (pbm->bmFillBytes)
    {
        while (y-- > 0)
        {
            t = (UINT)(pbm->bmOffset & 0xFFFF0000);
            pbm->bmOffset += pbm->bmNextScan;
            if ((UINT)(pbm->bmOffset & 0xFFFF0000) != t)
                pbm->bmOffset += pbm->bmFillBytes;
        }
    }
    else
    {
        pbm->bmOffset += y * (long)pbm->bmNextScan;
    }

    pbm->bmOffset += x * pbm->bmBitsPixel / 8;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// GetDIBBitmap
//
//////////////////////////////////////////////////////////////////////////////

/*
 * creates a DIB header for a bitmap, and returns a pointer to the bitmap
 * bits. This pointer is not used - it's checked against NULL, as if this
 * routine returned BOOL.
 *
 * On NT, you can't get the bitmap bits (wrong process) so we return 1 meaning
 * TRUE. You need to call SetBitmapBits to access the bits themselves.
 */
LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi)
{
    UINT wType;
    BITMAP bm;
    UINT ScansPerSeg;
    UINT FillBytes;

    if (hbm)
        GetObject(hbm, sizeof(bm), &bm);

    wType = GetBitmapType();

    if (wType == 0)
        return NULL;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = bm.bmWidth;
    lpbi->biHeight         = bm.bmHeight;
    lpbi->biPlanes         = bm.bmPlanes;
    lpbi->biBitCount       = bm.bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)(bm.bmWidthBytes * bm.bmPlanes) * (DWORD)bm.bmHeight;
    lpbi->biXPelsPerMeter  = 0;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    switch(wType & BM_TYPE)
    {
        case BM_VGA:
            break;

        case BM_1BIT:
        case BM_4BIT:
        case BM_8BIT:
            break;

        case BM_16555:
            break;

        case BM_24BGR:
        case BM_32BGR:
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            lpbi->biSize += 3 * sizeof(DWORD);
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            lpbi->biSize += 3 * sizeof(DWORD);
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;

        default:
            return NULL;
    }

    //
    //  make sure WidthBytes is right, dont forget bitmaps are WORD aligned
    //  and DIBs are DWORD aligned.
    //
    if (bm.bmWidthBytes != ((bm.bmWidth * bm.bmBitsPixel + 31) & ~31)/8)
    {
        if (lpbi->biCompression != 0)
            return NULL;

        lpbi->biCompression = BI_BITMAP;
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
    }

    if ((wType & BM_HUGE) && (lpbi->biSizeImage > 64*1024l))
    {
        if (lpbi->biCompression == BI_BITFIELDS)
            return NULL;

        lpbi->biCompression = BI_BITMAP;

        ScansPerSeg = muldiv(64,1024,bm.bmWidthBytes * bm.bmPlanes);
        FillBytes   = (UINT)(64ul*1024 - bm.bmWidthBytes * bm.bmPlanes * ScansPerSeg);

        lpbi->biSizeImage     += FillBytes * (bm.bmHeight / ScansPerSeg);
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
        lpbi->biYPelsPerMeter  = FillBytes;
    }

    if (!(wType & BM_BOTTOMTOTOP))
        lpbi->biHeight = -bm.bmHeight;

#ifdef _WIN32
    return (LPVOID) TRUE;
#else
    return LockBitmap(hbm);
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmap
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb)
{
    HANDLE h;
    DWORD  dwSize;
    IBITMAP FAR *pbm;
    HDC hdc = NULL;
    HBITMAP hbmT;

    if (!CanLockBitmaps())
        return NULL;

    if (hbm == NULL)
        return NULL;

    h = GetSetBitmapHandle(hbm, 0);

    if (h == NULL)
        return NULL;

    pbm = (LPVOID)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        return NULL;

    //
    // see if it is realy a bitmap.
    //
    if (pbm->bmType != 0)
        return NULL;

    //
    // make sure the bmBits pointer is valid.
    //
    if (pbm->bmBits == NULL)
    {
        hdc = CreateCompatibleDC(NULL);
        hbmT = SelectObject(hdc, hbm);
    }

    dwSize = (DWORD)pbm->bmHeight * (DWORD)pbm->bmWidthBytes;

    if (IsBadHugeWritePtr((LPVOID)pbm->bmBits, dwSize))
    {
        if (hdc)
        {
            SelectObject(hdc, hbmT);
            DeleteDC(hdc);
        }

        return NULL;
    }

    if (p)
    {
        UINT u;

        hmemcpy(p, pbm, min(cb, sizeof(IBITMAP)));
        pbm = p;

        u = GetBitmapType();

        pbm->bmType = u & BM_TYPE;

        if (cb > sizeof(BITMAP))
        {
            pbm->bmBitmapInfo = 0;
            pbm->bmNextScan = pbm->bmWidthBytes * pbm->bmPlanes;

            if (u & BM_BOTTOMTOTOP)
            {
                pbm->bmOffset = 0;
            }
            else
            {
                pbm->bmOffset   = (long)pbm->bmNextScan * (pbm->bmHeight-1);
                pbm->bmNextScan = -pbm->bmNextScan;
                pbm->bmFillBytes = -pbm->bmFillBytes;
            }

            //
            // see if this particular bitmap is HUGE
            //
            if (!(u & BM_HUGE) || (DWORD)pbm->bmHeight * pbm->bmWidthBytes < 64l*1024)
            {
                pbm->bmFillBytes = 0;
                pbm->bmScanSegment = pbm->bmHeight;
            }
            else
            {
                if (pbm->bmOffset)
                    pbm->bmOffset -= (long)((pbm->bmHeight-1) / pbm->bmScanSegment) * pbm->bmFillBytes;
            }
        }
    }

    if (hdc)
    {
        SelectObject(hdc, hbmT);
        DeleteDC(hdc);
    }

    return (LPVOID)pbm->bmBits;
}

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

///////////////////////////////////////////////////////////////////////////////
//
//  GetSurfaceType
//
///////////////////////////////////////////////////////////////////////////////
#define BCODE _based(_segname("_CODE"))

static BYTE  BCODE bits8[]   = {0x00,0xF9,0xFA,0xFC,0xFF};
static WORD  BCODE bits555[] = {0x0000,0x7C00,0x03E0,0x001F,0x7FFF};
static WORD  BCODE bits5551[]= {0x8000,0xFC00,0x83E0,0x801F,0xFFFF};
static WORD  BCODE bits565[] = {0x0000,0xF800,0x07E0,0x001F,0xFFFF};
static BYTE  BCODE bitsBGR[] = {0x00,0x00,0x00, 0x00,0x00,0xFF, 0x00,0xFF,0x00, 0xFF,0x00,0x00, 0xFF,0xFF,0xFF};
static BYTE  BCODE bitsRGB[] = {0x00,0x00,0x00, 0xFF,0x00,0x00, 0x00,0xFF,0x00, 0x00,0x00,0xFF, 0xFF,0xFF,0xFF};
static DWORD BCODE bitsRGBX[]= {0x000000, 0x0000FF, 0x00FF00, 0xFF0000, 0xFFFFFF};
static DWORD BCODE bitsBGRX[]= {0x000000, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFFFF};

void FAR TestSurfaceType(HDC hdc, int x, int y)
{
    PatBlt(hdc, x, y, 5, 1, BLACKNESS);

    SetPixel(hdc, x+0, y, RGB(000,000,000));
    SetPixel(hdc, x+1, y, RGB(255,000,000));
    SetPixel(hdc, x+2, y, RGB(000,255,000));
    SetPixel(hdc, x+3, y, RGB(000,000,255));
    SetPixel(hdc, x+4, y, RGB(255,255,255));

    GetPixel(hdc, x, y);
}

UINT FAR GetSurfaceType(LPVOID lpBits)
{
    #define TESTFMT(a,n) \
        if (_fmemcmp(lpBits, (LPVOID)a, sizeof(a)) == 0) return n;

    TESTFMT(bits8,    BM_8BIT);
    TESTFMT(bits555,  BM_16555);
    TESTFMT(bits5551, BM_16555);
    TESTFMT(bits565,  BM_16565);
    TESTFMT(bitsRGB,  BM_24RGB);
    TESTFMT(bitsBGR,  BM_24BGR);
    TESTFMT(bitsRGBX, BM_32RGB);
    TESTFMT(bitsBGRX, BM_32BGR);

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetBitmapType
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

UINT FAR GetBitmapType()
{
    BITMAP bm;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdc;
    UINT u;
    BYTE bits[20*4*2];

    static UINT wBitmapType = 0xFFFF;

    if (wBitmapType != 0xFFFF)
        return wBitmapType;

    //
    // create a test bitmap (<64k)
    //
    hdc = GetDC(NULL);
    if (hdc == NULL) {
	return 0;
    }

    hbm = CreateCompatibleBitmap(hdc,20,2);
    ReleaseDC(NULL, hdc);

    if (hbm == NULL) {
	return 0;
    }


    hdc = CreateCompatibleDC(NULL);
    if (hdc == NULL) {
	DeleteObject(hbm);
	return 0;
    }

    hbmT = SelectObject(hdc, hbm);

    if (GetObject(hbm, sizeof(bm), &bm) == 0) {
	SelectObject(hdc, hbmT);
	DeleteObject(hbm);
	DeleteDC(hdc);
	return 0;
    }

    PatBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, BLACKNESS);

    TestSurfaceType(hdc, 0, 0);
    GetBitmapBits(hbm, sizeof(bits), bits);
    u = GetSurfaceType(bits);

    if (u == 0) {
        u = GetSurfaceType(bits + bm.bmWidthBytes);

        if (u)
            u |= BM_BOTTOMTOTOP;
    }

#ifndef _WIN32
    if (u) {
        BYTE _huge *pb;
        UINT dy,w;

        //
        // see if bitmap(s) are huge format
        //
        dy = (UINT)(0x10000l/bm.bmWidthBytes) + 1;
        hbm = CreateCompatibleBitmap(hdc,bm.bmWidth,dy);
        DeleteObject(SelectObject(hdc, hbm));
        PatBlt(hdc, 0, 0, bm.bmWidth, dy, BLACKNESS);

        pb = (BYTE _huge *)LockBitmap(hbm);

        if (pb == NULL || OFFSETOF(pb) != 0)
            ; // cant lock bitmaps
        else {
            u |= BM_CANLOCK;

            w = (dy-1) * bm.bmWidthBytes;

            pb[64l*1024] = 0;
            pb[w] = 0;

            if (u & BM_BOTTOMTOTOP)
                SetPixel(hdc, 0, 0, RGB(255,255,255));
            else
                SetPixel(hdc, 0, dy-1, RGB(255,255,255));

            if (pb[64l*1024] != 0 && pb[w] == 0)
                u |= BM_HUGE;
            else if (pb[64l*1024] == 0 && pb[w] != 0)
                ;
            else
                u = 0;
        }
    }
#endif

    SelectObject(hdc, hbmT);
    DeleteObject(hbm);
    DeleteDC(hdc);

    wBitmapType = u;
    return u;
}

//////////////////////////////////////////////////////////////////////////////
//
//  returns the PDevice of the given physical or memory DC
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetPDevice(HDC hdc)
{
    HANDLE h;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdcT=NULL;
    IBITMAP FAR *pbm;
    LPVOID lpPDevice = NULL;

    // GDI.403
    static HANDLE (FAR PASCAL *GdiGetBitmapHandle)(HBITMAP hbm, HANDLE h);

    if (GdiGetBitmapHandle == NULL)
        (FARPROC)GdiGetBitmapHandle = GetProcAddress(GetModuleHandle(TEXT("GDI")),(LPCSTR)MAKEINTATOM(403));

    if (GdiGetBitmapHandle == NULL)
        return NULL;

    hbm = CreateBitmap(1,1,1,1,NULL);

    //
    //  first try the passed DC if it is a bitmap/DC
    //
    hbmT = SelectBitmap(hdc, hbm);

    if (hbmT != NULL)
    {
        //
        // it is a memory DC.
        //
        h = GdiGetBitmapHandle(hbmT, 0);
    }
    else
    {
        //
        // it is a physical DC.
        //

        hdcT = CreateCompatibleDC(hdc);
        hbmT = SelectBitmap(hdcT, hbm);

        h = GdiGetBitmapHandle(hbm, 0);
    }

    if (h == NULL)
        goto exit;

    pbm = (IBITMAP FAR *)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        goto exit;

    if (pbm)
        pbm = (IBITMAP FAR *)pbm->bmlpPDevice;
    else
        pbm = NULL;

    if (IsBadReadPtr(pbm, 2))
        goto exit;

    lpPDevice = (LPVOID)pbm;

exit:
    if (hdcT)
    {
        SelectObject(hdcT, hbmT);
        DeleteObject(hdcT);
    }
    else
    {
        SelectObject(hdc, hbmT);
    }

    DeleteObject(hbm);

    return lpPDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\profdisp.c ===
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>           // for timeGetTime()
#include <profile.h>
#include "drawdibi.h"
#include "profdisp.h"

#ifdef UNICODE
#include <wchar.h>
#endif
#include <vfw.h>
//#include "lockbm.h"
//#include "setdi.h"


// daytona will check the device capabilities but will do no timing.
// we are hardwired to use CreateDIBSection on Daytona, and to use GDI for
// all stretching

// Remove inline assembly warning
#pragma warning(disable:4704)

//
//  Set+Blt must be N% faster in order to say a driver isn't good
//
#define PROFDISP_FUDGE      110

#ifndef _WIN32
    #define GdiFlush()
#endif

LRESULT VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);
STATICFN UINT NEAR PASCAL ProfDispCanDrawDib(LPBITMAPINFOHEADER lpbi);

STATICFN HPALETTE CreateTestPalette(BOOL);

#ifndef _WIN32

//C6 will die if we dont redefine this.
#undef  GlobalFreePtr
#define GlobalFreePtr(p)    GlobalFree(GlobalPtrHandle(p))

#pragma alloc_text(DRAWDIB, DrawDibProfileDisplay)
#pragma alloc_text(DRAWDIB, ProfDispCanDrawDib)
#endif

#ifndef QUERYDIBSUPPORT
    #define QUERYDIBSUPPORT     3073
#endif

#ifndef QDI_SETDIBITS
    #define QDI_SETDIBITS       0x0001
    #define QDI_GETDIBITS       0x0002
    #define QDI_DIBTOSCREEN     0x0004
    #define QDI_STRETCHDIB      0x0008
#endif

/*
** ProfDisp - profile the display driver
*/

#define BITMAP_X    320
#define BITMAP_Y    240
#define N_FRAMES    10
#define STRETCH_N   125

#ifdef DEBUG
    #define FIRST_N 0           // do four bit
#else
    #define FIRST_N 1
#endif

#define BITBLTINDEX 5
#define BACKINDEX 6

// Internal return codes from DrawDibTest

#define CANT_DO_THESE_BITS      1
#define CANT_DO_STRETCHDIBITS   2
#define STRETCHDI_FASTER        3
#define OTHER_FASTER            4
#define STRETCHDI_BUT_TRY_BLT   5

static HWND     ghwnd ;
extern BOOL    gfIsRTL;    // in MSVIDEO\init.c

#ifndef _WIN32
#define CODE  _based(_segname("_CODE"))
#define STACK _based(_segname("_STACK"))
#else
#define CODE
#define STACK
#endif

STATICFN UINT ProfileDisplay(HDC hdc, UINT wBitsToTest, int dx, int dy) ;
STATICFN BOOL IsDisplay16Bit(HDC hdc ) ;
STATICFN BOOL IsDisplay32Bit(HDC hdc ) ;
STATICFN UINT DrawDibTest(HDC hdc, UINT wBits, LPBITMAPINFOHEADER FAR *alpbi, UINT wFrames,UINT wStretch ) ;
#ifndef DAYTONA
STATICFN void FreeFrames( LPBITMAPINFOHEADER FAR *alpbi) ;
STATICFN void MakeFrames(LPBITMAPINFOHEADER FAR *alpbi, UINT bits, UINT wXSize,UINT wYSize ) ;
#endif
STATICFN HANDLE MakeDib( HBITMAP hbitmap, UINT bits ) ;

static TCHAR CODE szBoot[]        = TEXT("boot" );
static TCHAR CODE szDisplay[]     = TEXT("display.drv" );
static TCHAR CODE szNull[]        = TEXT("") ;
static TCHAR CODE szDrawdib[]     = TEXT("DrawDib");
static TCHAR CODE szSystemIni[]   = TEXT("system.ini") ;
static TCHAR CODE szNxNxNxType[]  = TEXT(" %dx%dx%d(%s%u)");
static TCHAR CODE szEntryFormat[] = TEXT("%d,%d,%d,%d");
static TCHAR CODE szU[]           = TEXT("%u");
static TCHAR CODE sz02U[]         = TEXT("%02u");
static TCHAR CODE sz565[]         = TEXT("565 ");
static TCHAR CODE sz555[]         = TEXT("555 ");
static TCHAR CODE szRGB[]         = TEXT("RGB ");
static TCHAR CODE szBGR[]         = TEXT("BGR ");

// The following two strings are loaded from MSVIDEO.DLL - defined in
// video\video.rc.  If they cannot be found there, use these definitions
static TCHAR CODE szProfilingDefault[]  = TEXT("Profiling Display");
static TCHAR CODE szListbox[]           = TEXT("ListBox");

#if 0   // dont warn any-more
#ifndef _WIN32
static TCHAR CODE szWarning[]     = TEXT("Warning!");

static TCHAR CODE szDisplaySucks[]=
            TEXT("You may encounter display performance problems; ")
            TEXT("please contact the manufacturer of your video ")
            TEXT("board to see if an updated driver is available.");
#endif
#endif

#define ARRAYLEN(array)	    (sizeof(array)/sizeof(array[0]))

static int result[5] = {
     -1,
     -1,
     -1,
     -1,
     -1};

//
// UINT displayFPS[7][3][2]     [test dib][stretch][method]
//
// this array contains fps numbers times 10, ie 10 == 1fps
// zero means the test was not run.
//
// testdib:
//      0       = 4bpp  DIB (debug only)
//      1       = 8bpp  DIB
//      2       = 16bpp DIB
//      3       = 24bpp DIB
//      4       = 32bpp DIB
//      5       = BitBlt
//      6       = 8bpp  DIB (with non identity palette)
//
//  stretch:
//      0       = 1:1
//      1       = 1:2
//      2       = 1:N  (realy 2:3)
//
//  method (for stretch == 1:1)
//      0       = StretchDIBits()
//      1       = SetDIBits() + BitBlt  *
//
//  method (for stretch != 1:1)
//      0       = StretchDIBits()
//      1       = StretchDIB() + StretchDIBits() **
//
//  method (for testdib == 5, bitblt)
//      0       = BitBlt foreground palette
//      1       = BitBlt background palette
//
//  NOTE high color dibs (> 8) are not tested on devices with bitdepths <= 8
//
//  NOTE stretching tests are not run unless the device does stretching.
//  (RasterCaps has RC_STRETCHBLT or RC_STRETCHDIBITS set)
//
//  * NOTE if we can access bitmaps, we dont use SetDIBits() we use direct
//    code.
//
//  ** NOTE (StretchDIB is not a GDI api...)
//
//  EXAMPLE:
//      displayFPS[1][0][0] is the FPS of 1:1 StretchDIBits() on a 8bpp DIB
//      displayFPS[1][0][1] is the FPS of Set+BitBlt() on a 8bpp DIB
//      displayFPS[1][1][0] is the FPS of 1:2 StretchDIBits() on a 8bpp DIB
//
//  how the ResultN flags get set:
//
//      PD_CAN_DRAW_DIB (can draw this dib 1:1 using some method...)
//          displayFPS[N][0][0] != 0 or displayFPS[N][0][1] != 0
//
//      PD_CAN_STRETCHDIB (can stretch this dib using StretchDIBits)
//          displayFPS[N][1][0] > displayFPS[N][1][1] or
//          displayFPS[N][2][0] > displayFPS[N][2][1]
//
//      PD_STRETCHDIB_1_1_OK (StretchDIBits faster than Set+BitBlt)
//          displayFPS[N][0][0] > displayFPS[N][0][1]
//
//      PD_STRETCHDIB_1_2_OK (StretchDIBits 1:2 is faster the doing it our self)
//          displayFPS[N][1][0] > displayFPS[N][1][1]
//
//      PD_STRETCHDIB_1_N_OK (StretchDIBits 1:N is faster the doing it our self)
//          displayFPS[N][2][0] > displayFPS[N][2][1]
//

static UINT displayFPS[7]   // 0=4bbp, 1=8bpp, 2=16bpp, 3=24bpp, 4=32bit, 5=BitBlt, 6=Dib ~1:1
                      [3]   // 0=1:1,  1=1:2,  2=1:N
                      [2];  // 0=DrawDib, 1=Set+Blt (or ~1:1 for BitBlt)

#ifndef _WIN32
/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api LONG | atoi | local version of atoi
 *
 ***************************************************************************/

INLINE STATICFN int NEAR PASCAL atoi(TCHAR FAR *sz)
{
    int i = 0;

    while (*sz && *sz >= TEXT('0') && *sz <= TEXT('9'))
    	i = i*10 + *sz++ - TEXT('0');
    	
    return i;    	
}
#endif

STATICFN void FAR InitProfDisp(BOOL fForceMe)
{
    TCHAR   ach[80];
    TCHAR   achDisplay[80];
    HDC     hdc;
    int     i;
    int     n;
    int     BitDepth;

    GetPrivateProfileString(szBoot, szDisplay, szNull,
			    achDisplay, ARRAYLEN(achDisplay), szSystemIni);

    hdc = GetDC(NULL);

    BitDepth = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    n = GetBitmapType();

    switch(n & BM_TYPE)
    {
        default:
        case BM_8BIT:    ach[0] = 0;             break;
        case BM_16555:   lstrcpy(ach, sz555);    break;
        case BM_16565:   lstrcpy(ach, sz565);    break;
        case BM_24BGR:
        case BM_32BGR:   lstrcpy(ach, szBGR);    break;
        case BM_24RGB:
        case BM_32RGB:   lstrcpy(ach, szRGB);    break;
    }

    wsprintf(achDisplay + lstrlen(achDisplay), szNxNxNxType,
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        BitDepth,(LPTSTR)ach, n >> 4);
    ReleaseDC(NULL, hdc);

    mmGetProfileString(szDrawdib, achDisplay, szNull, ach, ARRAYLEN(ach));

    for (i=0,n=1; n<5; n++)
    {
        if (ach[i] == TEXT('\0'))
        {
            result[n] = -1;
        }
        else
        {
#ifdef UNICODE
            result[n] = wcstol(ach+i, NULL, 10);
#else
            result[n] = atoi(ach+i);
#endif
            while (ach[i] != 0 && ach[i] != TEXT(','))
                i++;
            if (ach[i] != 0)
                i++;
	}
    }

    if (fForceMe ||
        result[1] == -1 ||
        result[2] == -1 ||
        result[3] == -1 ||
        result[4] == -1)
    {
        TestDibFormats(BITMAP_X,BITMAP_Y,fForceMe);

	wsprintf(ach, szEntryFormat,
		 result[1], result[2], result[3], result[4]);
        mmWriteProfileString(szDrawdib, achDisplay, ach);

#if 0
        //
        // if the DISPLAY driver isn't very good drawing DIBs then warn the user.
        //
        // we will only warn if the device is at least 8bpp
        //
        if (BitDepth >= 8 && !(result[1] & PD_STRETCHDIB_1_1_OK))
        {
#ifndef _WIN32
            MessageBox(NULL, szDisplaySucks, szWarning, MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION);
#else
            RPF(("Display driver probably too slow for AVI"));
#endif
        }
#endif
    }
}

/****************************************************************
*
*****************************************************************/

STATICFN UINT NEAR PASCAL ProfDispCanDrawDib(LPBITMAPINFOHEADER lpbi)
{
    int     n;
    LONG    l;
    HDC     hdc;
    UINT    w;

    if (result[1] == -1 || lpbi==NULL)
        InitProfDisp(FALSE);

    if (lpbi == NULL)
        return 0;

    switch (lpbi->biCompression)
    {
        //
        //  standard format use our pre-computed performance numbers.
        //
        case BI_RGB:
            n = (int)lpbi->biBitCount / 8;
            return result[n];

        case BI_RLE4:
        case BI_RLE8:
            //
            // return the un-rle results *but* RLE can't stretch
            //
            return result[1] & PD_CAN_DRAW_DIB|PD_STRETCHDIB_1_1_OK;

        //
        //  custom format, ask the DISPLAY driver
        //
        default:
            l = 0;
            w = 0;

            hdc = GetDC(NULL);

            if (Escape(hdc, QUERYDIBSUPPORT, (int)lpbi->biSize, (LPVOID)lpbi, (LPVOID)&l) > 0)
            {
                // make sure the driver realy realy gave us back flags.
                if (l & ~(0x00FF))
                    l = 0;

                if (l & QDI_DIBTOSCREEN)
                    w |= PD_STRETCHDIB_1_1_OK | PD_CAN_DRAW_DIB;

                if (l & QDI_STRETCHDIB)
                    w |= PD_CAN_STRETCHDIB;

                /* what about stretching? fast? */
            }

            ReleaseDC(NULL, hdc);
            return w;
    }
}

/****************************************************************
* @doc EXTERNAL DrawDib
*
* @api void | DrawDibProfileDisplay | Profiles the display for DrawDib.
*
* @parm LPBITMAPINFOHEADER | parms | Specifies bitmap information.
*       Set to null if no information is available.
*
*****************************************************************/

LRESULT VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi)
{
    if (lpbi == NULL)
    {
        InitProfDisp(TRUE) ;
        return (DWORD_PTR)(LPVOID)displayFPS;
    }
    else
        return ProfDispCanDrawDib(lpbi);
}

LPVOID FAR TestDibFormats(int dx, int dy, BOOL fForceMe)
{
    int         dxScreen,dyScreen;
    HDC         hdc;
    int         n;
    int         i;
#ifndef DAYTONA
    HCURSOR     hcur;
    HPALETTE    hpal;
    RECT        rc;
    HWND        hwnd;
    HWND        hwndActive;
    DWORD       fdwExStyle;
#endif
    BOOL	fMiniDriver = FALSE;
    TCHAR       szProfiling[80];

    // dont change this without changing MSVIDEO.RC
    #define IDS_PROFILING       4000

    extern HMODULE ghInst;      // in MSVIDEO\init.c

    // fill in displayFPS[7][3][2];

    for (n=0; n<7; n++)
        for (i=0; i<3; i++)
            displayFPS[n][i][0] =
            displayFPS[n][i][1] = 0;

#ifndef CAPS1
#define CAPS1	94
#endif
#ifndef C1_DIBENGINE
#define C1_DIBENGINE 0x0010
#endif

    hdc = GetDC(NULL);
    i = GetDeviceCaps(hdc, CAPS1);
    n = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);
    if (i & C1_DIBENGINE) {
	DPF(("Display is DIB Engine-based; not profiling...."));
	fMiniDriver = TRUE;
	result[0] = 1;
	if (n < 8) {
	    result[1] = 33;  // 8bpp
	    result[2] = 0;  // 16bpp
	    result[3] = 0;  // 24bpp
	    result[4] = 0;  // 32bpp
	} else if (n == 8) {
	    result[1] = 55; // 8bpp
	    result[2] = 0;  // 16bpp
	    result[3] = 0;  // 24bpp
	    result[4] = 0;  // 32bpp
	} else {
	    result[1] = 37;  // 8bpp
	    result[2] = 5;  // 16bpp
	    result[3] = 5;  // 24bpp
	    result[4] = 5;  // 32bpp
	}

	// Normally, if we are a mini-driver, we don't need to profile the
	// display.  But because of a Kings Quest VII bug, we have to at least
	// create a window, or they'll hang.  They call us with the fForceMe
	// flag on, so we can't return now, we have to go ahead and pretend
	// we're profiling.  But we don't want to actually profile the display,
	// so we'll just do everything BUT the calls to ProfileDisplay() if
	// we're a mini driver.
	if (!fForceMe)
	    return (LPVOID) displayFPS;
    }

    if (!LoadString(ghInst, IDS_PROFILING, szProfiling, sizeof(szProfiling)/sizeof(TCHAR)))
        lstrcpy(szProfiling, szProfilingDefault);

#ifdef _WIN32
    #define GetCurrentInstance() GetModuleHandle(NULL)
#else
    #define GetCurrentInstance() GetWindowWord(IsWindow(GetActiveWindow()) ? GetActiveWindow() : GetDesktopWindow(), GWW_HINSTANCE)
#endif

    dxScreen = GetSystemMetrics(SM_CXSCREEN);
    dyScreen = GetSystemMetrics(SM_CYSCREEN);
#ifdef DAYTONA

    // we don't do any drawing - just get caps
    hdc = GetDC(NULL);

#else
    SetRect(&rc, 0, 0, dx, dy);
    AdjustWindowRect(&rc, (WS_OVERLAPPED | WS_CAPTION | WS_BORDER), FALSE);
    OffsetRect(&rc, -rc.left, -rc.top);

    fdwExStyle = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
    hwnd = CreateWindowEx(fdwExStyle,
			szListbox,     // Class name
                         szProfiling,   // Caption
                          LBS_NOINTEGRALHEIGHT|
                          (WS_OVERLAPPED | WS_CAPTION | WS_BORDER),
                        (dxScreen - rc.right) / 2,
                        (dyScreen - rc.bottom) / 2,
                          rc.right,
                          rc.bottom,
                          (HWND)NULL,             // Parent window (no parent)
                          (HMENU)NULL,            // use class menu
                          GetCurrentInstance(),   // handle to window instance
                        (LPTSTR)NULL            // no params to pass on
                         );

    // make the window top most
    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

    // and show it.
    SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_SHOWWINDOW);

    // and activate it.
    hwndActive = GetActiveWindow();
    SetActiveWindow(hwnd);

    hdc = GetDC(hwnd);
    hcur = SetCursor(NULL);
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        hpal = CreateTestPalette(TRUE);
        SelectPalette(hdc, hpal, FALSE);
        RealizePalette(hdc);
    }

    Yield();
    Yield();
    Yield();
#endif

#ifndef _WIN32
    //
    //      make sure no junk is around in the SmartDrv cache, this will
    //      mess with the timings
    //
    _asm {
        mov     ax,4A10h        ; tell Bambi to flush the cache
        mov     bx,0001h
        int     2fh

        mov     ah,0Dh          ; tell other people to commit...
        int     21h
    }
#else
    GdiFlush();
#endif

    // King's Quest bug - don't actually profile
    if (!fMiniDriver)
    {
        for (n=FIRST_N; n<5; n++)
            result[n] = ProfileDisplay(hdc, n==0 ? 4 : n*8, dx, dy);
    }

#ifndef DAYTONA
#ifdef DEBUG
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        HPALETTE    hpalT;
        //
        // re-run the 8bit tests with a background palette
        //
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
        RealizePalette(hdc);

	hpalT = CreateTestPalette(FALSE);
	SelectPalette(hdc, hpalT, TRUE);
        RealizePalette(hdc);

        Yield();
        Yield();
        Yield();

	if (!fMiniDriver)
            ProfileDisplay(hdc, 8, dx, dy);

        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
        RealizePalette(hdc);
	DeleteObject(hpalT);
        DeleteObject(hpal);
    }
#endif

    SetCursor(hcur);
    ReleaseDC(hwnd, hdc);

    if (hwndActive)
        SetActiveWindow(hwndActive);

    DestroyWindow(hwnd) ;
#else
    ReleaseDC(NULL, hdc);
#endif

    return (LPVOID)displayFPS;
}

STATICFN UINT ProfileDisplay(HDC hdc, UINT wBitsToTest, int dx, int dy)
{
    LPBITMAPINFOHEADER alpbi[N_FRAMES];
    UINT                wRetval;

    if (GetDeviceCaps(hdc, BITSPIXEL) *
        GetDeviceCaps(hdc, PLANES) <= 8 && wBitsToTest > 8)
        return 0;

    alpbi[0] = NULL;

#ifndef DAYTONA
    MakeFrames(alpbi,wBitsToTest,dx,dy);
    if (!alpbi[0])
        return (UINT)-1 ;
#endif

    wRetval = 0 ;


    switch(DrawDibTest(hdc, wBitsToTest, alpbi,N_FRAMES,100))
    {
        case CANT_DO_THESE_BITS:
            goto done ;

        case CANT_DO_STRETCHDIBITS:
            wRetval = PD_CAN_DRAW_DIB ;
            goto done ;

        case STRETCHDI_BUT_TRY_BLT:
            // stretchdi_faster, but bitblt is >20% faster than
            // StretchDIBits, so worth trying decomp to bitmap.
            wRetval = PD_BITBLT_FAST;
            /* falling through .... */
        case STRETCHDI_FASTER:
            wRetval |= PD_STRETCHDIB_1_1_OK ;
            /* Falling through */

        case OTHER_FASTER:
            wRetval |= PD_CAN_DRAW_DIB;

    }

    if (DrawDibTest(hdc, wBitsToTest, alpbi,N_FRAMES,STRETCH_N) == STRETCHDI_FASTER)
        wRetval |= PD_STRETCHDIB_1_N_OK|PD_CAN_STRETCHDIB;

    if (DrawDibTest(hdc, wBitsToTest, alpbi,N_FRAMES,200) == STRETCHDI_FASTER)
        wRetval |= PD_STRETCHDIB_1_2_OK|PD_CAN_STRETCHDIB;

done:

#ifndef DAYTONA
    FreeFrames(alpbi);
#endif

    return wRetval;
}

STATICFN UINT DrawDibTest(HDC hdc, UINT wBits, LPBITMAPINFOHEADER FAR *alpbi,UINT wFrames,UINT wStretch)
{
    int                 n ;
    BOOL                fBack;
#ifndef DAYTONA
    HDC                 hdcMem ;
    HBITMAP             hbitmap ;
    HBITMAP             hbitmapOld ;

    DWORD               wSizeColors ;

    volatile LPBITMAPINFOHEADER  lpbi ;
    LPBYTE              bits ;
    LPBITMAPINFOHEADER  lpbiStretch ;
    LPBYTE              bitsStretch ;
    DWORD               time0 = 0;
    DWORD               time1 = 0;
    DWORD               time2 = 0;
    RECT                rc ;
    int                 XDest,YDest,cXDest,cYDest ;
    int                 cXSrc,cYSrc ;
    int                 i ;
    UINT                DibUsage;
    BOOL                f;

    DWORD               dwSize;
    DWORD               dwSizeImage;
    HPALETTE            hpal;
    int                 q ;


    lpbi = alpbi[0];

    /*
    ** Get stuff common to all frames
    */
    //cXSrc = (int)lpbi->biWidth ;
    //cYSrc = (int)lpbi->biHeight ;
    //cXDest = wStretch*(int)lpbi->biWidth/100 ;
    //cYDest = wStretch*(int)lpbi->biHeight/100 ;

    cXSrc = 100*(int)lpbi->biWidth/wStretch ;
    cYSrc = 100*(int)lpbi->biHeight/wStretch ;
    cXDest = (int)lpbi->biWidth ;
    cYDest = (int)lpbi->biHeight ;
#endif

    // are we background'ed
    n = wStretch == 100 ? 0 : wStretch == 200 ? 1 : 2;
    fBack = wBits==8 && displayFPS[1][n][0] != 0;

#ifndef DAYTONA
    if (lpbi->biBitCount <= 8)
        wSizeColors = sizeof(RGBQUAD) * (int)(lpbi->biClrUsed ? lpbi->biClrUsed : (1 << (int)lpbi->biBitCount));
    else
        wSizeColors = 0 ;

    bits = (LPBYTE)lpbi + (int)lpbi->biSize + wSizeColors ;
#endif

    if (GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) <= 8 && wBits > 8)
        return CANT_DO_STRETCHDIBITS;

////if (wStretch != 100 && !(GetDeviceCaps(hdc,RASTERCAPS)&(RC_STRETCHDIB|RC_STRETCHBLT)))

    if (wStretch != 100 && !(GetDeviceCaps(hdc,RASTERCAPS)&(RC_STRETCHDIB)))
        return CANT_DO_STRETCHDIBITS ;

    if (wStretch != 100 && wBits == 4)
        return CANT_DO_STRETCHDIBITS ;

#ifndef _WIN32
    if (wStretch != 100 && (GetWinFlags() & WF_CPU286))
        return STRETCHDI_FASTER;
#endif

//  if (wStretch != 100 && wBits > 8) //!!!
//      wFrames = 4;

#ifdef DAYTONA
    return STRETCHDI_FASTER;
#else
    lpbi->biWidth  = cXSrc;
    lpbi->biHeight = cYSrc;


    // get current palette
    hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
    SelectPalette(hdc, hpal, fBack);
    RealizePalette(hdc);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        DibUsage = DIB_PAL_COLORS;
    }
    else
    {
        DibUsage = DIB_RGB_COLORS;
    }

////GetClientRect(hwnd,&rc) ;
    GetClipBox(hdc,&rc) ;
    XDest = (rc.right - cXDest)/2 ;
    YDest = (rc.bottom - cYDest)/2 ;

    time0 = 0;

    if (wBits == 16 && !IsDisplay16Bit(hdc))
        goto test_bitmap;

    if (wBits == 32 && !IsDisplay32Bit(hdc))
        goto test_bitmap;

    time0 = timeGetTime() ;

    for (i=0; i<(int)wFrames; i++)
    {
        lpbi = alpbi[i%N_FRAMES];
        bits = ((LPBYTE)lpbi) + (int)lpbi->biSize + wSizeColors ;

#ifdef _WIN32
	/*
	 * to correctly model the behaviour of DrawDibDraw, we
	 * use SetDIBitsToDevice if 1:1 (source rect == dest rect).
	 */
	if ( (cXSrc == cXDest) && (cYSrc == cYDest)) {
            f = SetDIBitsToDevice(hdc, XDest, YDest, cXDest, cYDest,
				0, 0, 0, cYSrc,
                                bits, (LPBITMAPINFO)lpbi, DibUsage);
	} else
#endif
        {
            f = StretchDIBits(
                    hdc,
                    XDest,YDest,cXDest,cYDest,
                    0,0,cXSrc, cYSrc,
                    bits,(LPBITMAPINFO)lpbi,DibUsage,SRCCOPY) ;
        }
    }

    GdiFlush();

    time0 = timeGetTime() - time0 ;

    if (f == 0)
        time0 = 0;

test_bitmap:
    time1 = 0;

    if (wStretch == 100)
    {
        PSETDI psd;

        psd = (PSETDI)LocalAlloc(LPTR, sizeof(SETDI));

        if (psd == NULL)
            goto done;

        hbitmap = CreateCompatibleBitmap(hdc,cXDest,cYDest) ;
        hdcMem = CreateCompatibleDC(NULL) ;
        hbitmapOld = SelectObject(hdcMem,hbitmap) ;

        f = SetBitmapBegin(
                    psd,            //  structure
                    hdc,            //  device
                    hbitmap,        //  bitmap to set into
                    lpbi,           //  --> BITMAPINFO of source
                    DibUsage);

        psd->hdc = hdc;

        if (f)
            f = SetBitmap(psd, 0, 0, cXDest, cYDest, bits, 0, 0, cXDest, cYDest);

        if (f)
        {
//          SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
//          RealizePalette(hdc);

            time1 = timeGetTime();

            for (i=0; i<(int)wFrames; i++)
            {
                SetBitmap(psd, 0, 0, cXDest, cYDest, bits, 0, 0, cXDest, cYDest);
                BitBlt(hdc,XDest,YDest,cXDest,cYDest,hdcMem,0,0,SRCCOPY);
            }

            GdiFlush();

            time1 = timeGetTime() - time1 ;

            SetBitmapEnd(psd);

//          SelectPalette(hdc, hpal, fBack);
//          RealizePalette(hdc);
        }

#ifdef DEBUG
        if ((int)lpbi->biBitCount == GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES))
        {
            time2 = timeGetTime() ;

            for (i=0; i<(int)wFrames; i++)
                BitBlt(hdc,XDest,YDest,cXDest,cYDest,hdcMem,0,0,SRCCOPY) ;

            GdiFlush();

            time2 = timeGetTime() - time2 ;
        }
#endif

            LocalFree((HLOCAL)psd);
            SelectObject(hdcMem,hbitmapOld) ;
            DeleteObject(hbitmap) ;
            DeleteDC(hdcMem) ;
    } else {
        if (wBits == 16 && !IsDisplay16Bit(hdc))
            goto done;

        if (wBits == 32 && !IsDisplay32Bit(hdc))
            goto done;

        // Calc size we need to allocate for stretched bits

        dwSizeImage = (DWORD)(UINT)cYDest*(DWORD)(((UINT)cXDest*(UINT)lpbi->biBitCount+31)/32*4);
        dwSize = (int)lpbi->biSize + (int)lpbi->biClrUsed*sizeof(RGBQUAD);

        if ((lpbiStretch = (LPVOID)GlobalAllocPtr(GHND,dwSize + dwSizeImage)) != NULL)
        {
            hmemcpy(lpbiStretch, lpbi, dwSize);
            lpbiStretch->biWidth  = cXDest;
            lpbiStretch->biHeight = cYDest;
            lpbiStretch->biSizeImage = dwSizeImage;
            bitsStretch = (LPBYTE)lpbiStretch + (UINT)dwSize;

            time1 = timeGetTime() ;

            for (i=0; i<(int)wFrames; i++)
            {
                lpbi = alpbi[i%N_FRAMES];
                bits = ((LPBYTE)lpbi) + (int)lpbi->biSize + wSizeColors;

                StretchDIB(
                    lpbiStretch,bitsStretch,
                    0,0,cXDest,cYDest,
                    lpbi,bits,
                    0,0,cXSrc,cYSrc);
#ifdef _WIN32
		/*
		 * to correctly model the behaviour of DrawDibDraw, we
		 * use SetDIBitsToDevice if 1:1 (source rect == dest rect).
		 */
                f = SetDIBitsToDevice(hdc, XDest, YDest, cXDest, cYDest,
                                    0, 0, 0, cYSrc,
                                    bits, (LPBITMAPINFO)lpbi, DibUsage);
#else
                f = StretchDIBits(
                    hdc,
                    XDest,YDest,cXDest,cYDest,
                    0,0,cXDest,cYDest,
                    bitsStretch,(LPBITMAPINFO)lpbiStretch,DibUsage,SRCCOPY);
#endif
            }

            GdiFlush();

            time1 = timeGetTime() - time1 ;

            GlobalFreePtr(lpbiStretch);

            if (f == 0)
                time1 = 0;
        }

#ifdef DEBUG
        if ((int)lpbi->biBitCount == GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES))
        {
            hbitmap = CreateCompatibleBitmap(hdc,cXSrc,cYSrc) ;
            hdcMem = CreateCompatibleDC(NULL) ;
            hbitmapOld = SelectObject(hdcMem,hbitmap) ;
	    lpbi = alpbi[0];
	    bits = ((LPBYTE)lpbi) + (int)lpbi->biSize + wSizeColors;
            SetDIBits(hdc,hbitmap,0,cYSrc,bits,(LPBITMAPINFO)lpbi,DibUsage);

            SelectPalette(hdcMem, hpal, FALSE);
//          RealizePalette(hdcMem);

            time2 = timeGetTime() ;

            for (i=0; i<(int)wFrames; i++)
                StretchBlt(hdc,XDest,YDest,cXDest,cYDest,hdcMem,0,0,cXSrc,cYSrc,SRCCOPY) ;

            GdiFlush();

            time2 = timeGetTime() - time2 ;

            SelectObject(hdcMem,hbitmapOld) ;
            DeleteObject(hbitmap) ;
            DeleteDC(hdcMem) ;
        }
#endif
    }

done:
    /* time0 is the time required to do StretchDIBits */
    /* time1 is the time required to do Set + BitBlt */
    /* time2 is the time required to do a BitBlt */

    //
    // compute the FPS * 10 and store for later use.
    //
    n = wStretch == 100 ? 0 : wStretch == 200 ? 1 : 2;
    q = fBack ? BACKINDEX : wBits/8;

    time1 = (DWORD)MulDiv((int)time1,PROFDISP_FUDGE,100);

    displayFPS[q][n][0] = time0 ? (UINT)MulDiv(wFrames,10000,(int)time0) : 0;
    displayFPS[q][n][1] = time1 ? (UINT)MulDiv(wFrames,10000,(int)time1) : 0;

    if (time2)
        displayFPS[BITBLTINDEX][n][fBack] = (UINT)MulDiv(wFrames,10000,(int)time2);

    RPF(("DrawDibTest %dx%dx%d %d StretchDIBits=%04lu SetDI+BitBlt=%04lu BitBlt=%04lu %ls",cXDest,cYDest,wBits,wStretch,time0,time1,time2,(LPSTR)(time0 < time1 ? TEXT("") : TEXT("SLOW"))));

    lpbi->biWidth  = cXDest;
    lpbi->biHeight = cYDest;

    if (time0 == 0)
    {
        return time1 ? OTHER_FASTER : CANT_DO_THESE_BITS;
    }
    else
    {
        if (time1) {
            if (time0 < time1) {

                // in the 1:1 case, see if it's worth trying decomp to bitmap
                // - this maybe worthwhile even if StretchDIBits is faster
                // than SetDIBits+BitBlt, so long as BitBlt is > 20% or so
                // faster than StretchDIBits.
                if ((wStretch == 100) && (time2) &&
                    ( (time0 * 80 / 100)  > time2)) {
                    return STRETCHDI_BUT_TRY_BLT;
                } else {
                    return STRETCHDI_FASTER;
                }

            } else {
                return OTHER_FASTER;
            }
        } else {
            return STRETCHDI_FASTER;
        }
    }
#endif
}

#ifndef DAYTONA
STATICFN void MakeFrames(LPBITMAPINFOHEADER FAR *alpbi, UINT bits, UINT wXSize,UINT wYSize )
{
    int         i ;
    int         x ;
    int         y ;
    LPBITMAPINFOHEADER lpbi ;
    DWORD       dwSizeImage;
    BYTE _huge *pb;
    WORD FAR   *pw;
    DWORD FAR  *pdw;
    UINT        rc;
    HDC         hdc;

    hdc = GetDC(NULL);
    rc = GetDeviceCaps(hdc, RASTERCAPS);
    ReleaseDC(NULL,hdc);

    FreeFrames(alpbi);

    dwSizeImage = wYSize*(DWORD)((wXSize*bits/8+3)&~3);

    lpbi = (LPVOID)GlobalAllocPtr(GHND,sizeof(BITMAPINFOHEADER)+dwSizeImage + 1024);
    lpbi->biSize            = sizeof(BITMAPINFOHEADER) ;
    lpbi->biWidth           = wXSize ;
    lpbi->biHeight          = wYSize ;
    lpbi->biPlanes          = 1 ;
    lpbi->biBitCount        = bits ;
    lpbi->biCompression     = BI_RGB ;
    lpbi->biSizeImage       = dwSizeImage;
    lpbi->biXPelsPerMeter   = 0 ;
    lpbi->biYPelsPerMeter   = 0 ;
    lpbi->biClrUsed         = 0 ;
    lpbi->biClrImportant    = 0 ;

    // !!! These should be RGB DIBs if the device isn't a palette device!

    if (bits == 4)
    {
        lpbi->biClrUsed = 16;
    }
    else if (bits == 8)
    {
	lpbi->biClrUsed = 256;
    }

    pb = (BYTE _huge *)lpbi+lpbi->biSize+lpbi->biClrUsed * sizeof(RGBQUAD);

    if (bits == 4)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x += 2)
	    {
                i = ((x / (wXSize / 4)) + 4 * (y / (wYSize / 4)));
		i += i * 16;
		*pb++ = i;
            }

        if (rc & RC_PALETTE)
        {
            pw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            for (i=0; i<8; i++)
                *pw++ = i;

            for (i=0; i<8; i++)
                *pw++ = 248+i;
        }
        else
        {
            pdw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            *pdw++ = 0x00000000;    // 0000  black
            *pdw++ = 0x00800000;    // 0001  dark red
            *pdw++ = 0x00008000;    // 0010  dark green
            *pdw++ = 0x00808000;    // 0011  mustard
            *pdw++ = 0x00000080;    // 0100  dark blue
            *pdw++ = 0x00800080;    // 0101  purple
            *pdw++ = 0x00008080;    // 0110  dark turquoise
            *pdw++ = 0x00C0C0C0;    // 1000  gray
            *pdw++ = 0x00808080;    // 0111  dark gray
            *pdw++ = 0x00FF0000;    // 1001  red
            *pdw++ = 0x0000FF00;    // 1010  green
            *pdw++ = 0x00FFFF00;    // 1011  yellow
            *pdw++ = 0x000000FF;    // 1100  blue
            *pdw++ = 0x00FF00FF;    // 1101  pink (magenta)
            *pdw++ = 0x0000FFFF;    // 1110  cyan
            *pdw++ = 0x00FFFFFF;    // 1111  white
        }
    }
    else if (bits == 8)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
            {
                *pb++ = 10 + y * 236 / (int)wYSize;
            }

        if (rc & RC_PALETTE)
        {
            pw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            for (i=0; i<256; i++)
                *pw++ = i;
        }
        else
        {
            pdw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            for (i=0; i<256; i++)
                *pdw++ = RGB(i,0,0);
        }
    }
    else if (bits == 16)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
            {
                *pb++ = (BYTE) ((UINT)y * 32u / wYSize);
                *pb++ = (BYTE)(((UINT)x * 32u / wXSize) << 2);
	    }
    }
    else if (bits == 24)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
	    {
                *pb++ = (BYTE) (y * 256l / wYSize);
                *pb++ = (BYTE)~(x * 256l / wXSize);
                *pb++ = (BYTE) (x * 256l / wXSize);
	    }
    }
    else if (bits == 32)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
	    {
                *pb++ = (BYTE)~(x * 256l / wXSize);
                *pb++ = (BYTE) (y * 256l / wYSize);
                *pb++ = (BYTE) (x * 256l / wXSize);
                *pb++ = 0;
	    }
    }

    for ( i=0; i<N_FRAMES; i++ )
        alpbi[i] = lpbi;
}

STATICFN void FreeFrames(LPBITMAPINFOHEADER FAR *alpbi)
{
    UINT        w ;

    if (!alpbi[0])
        return ;

    for (w=0; w<N_FRAMES; w++)
	if (alpbi[w] && (w == 0 || alpbi[w] != alpbi[w-1]))
            GlobalFreePtr(alpbi[w]);

    for (w=0; w<N_FRAMES; w++)
        alpbi[w] = NULL;
}
#endif

#if 0
/*
 *  CreateTestPalette()
 *
 */
STATICFN HPALETTE CreateTestPalette(BOOL f)
{
    HDC hdc;
    int i;

    struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palNumEntries = 256;
    pal.palVersion    = 0x0300;

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0, 256, &pal.palPalEntry[0]);
    ReleaseDC(NULL,hdc);

    for (i = 10; i < 246; i++)
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;

    if (!f)
        pal.palPalEntry[0].peRed = 255;

    return CreatePalette((LPLOGPALETTE)&pal);
}

#else

/*
 *  CreateTestPalette()
 *
 */
STATICFN HPALETTE CreateTestPalette(BOOL fUp)
{
    int i;
    HDC hdc;

    struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palNumEntries = 256;
    pal.palVersion    = 0x0300;

    for (i = 0; i < 256; i++)
    {
        pal.palPalEntry[i].peRed   = 0;
        pal.palPalEntry[i].peGreen = 0;
        pal.palPalEntry[i].peBlue  = (BYTE)(fUp ? i : 255 - i);
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
    }

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
    GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);
    ReleaseDC(NULL,hdc);

    return CreatePalette((LPLOGPALETTE)&pal);
}
#endif

#define RGB555_RED      0x7C00
#define RGB555_GREEN    0x03E0
#define RGB555_BLUE     0x001F

STATICFN BOOL IsDisplay16Bit( HDC hdc )
{
    struct {
        BITMAPINFOHEADER    bi;
        RGBQUAD             rgbq[256];
    }   dib;
    int                     w ;
    LONG                    l=0;
    WORD                    bits[2];
    COLORREF                cref ;

    w = GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES) ;

    if ( w < 15 )
        return FALSE;

    /*
    ** OK, the hardware is at least 16 bits - now test to see
    ** if they impelement 5-5-5 RGB
    */

    dib.bi.biSize = sizeof(BITMAPINFOHEADER);
    dib.bi.biWidth = 1;
    dib.bi.biHeight = 1;
    dib.bi.biPlanes = 1;
    dib.bi.biBitCount = 16;
    dib.bi.biCompression = BI_RGB;
    dib.bi.biSizeImage = 4;
    dib.bi.biXPelsPerMeter = 0;
    dib.bi.biYPelsPerMeter = 0;
    dib.bi.biClrUsed = 1;
    dib.bi.biClrImportant = 0;

    //
    // just in case they try to decode it as rle
    //
    bits[0] = 0x0000;           // this is RLE EOL
    bits[1] = 0x0100;           // this is RLE EOF

    //
    // send the Escape to see if they support 16bpp DIBs
    //
    if (Escape(hdc, QUERYDIBSUPPORT, (int)dib.bi.biSize, (LPVOID)&dib, (LPVOID)&l) > 0)
    {
        // make sure the driver realy realy gave us back flags.
	if (l & ~(0x00FF))
		l = 0;

        if (l & (QDI_DIBTOSCREEN|QDI_STRETCHDIB))
            return TRUE;
    }

    //
    // they dont support the QUERYDIBSUPPORT Escape, try to draw DIBs and see
    // what they do!
    //

    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) ;

    if (cref != RGB(0,0,0))
        return FALSE;

    /*
    ** Display a red pixel of the max value and get it back with
    ** GetPixel(). Verify that red has the max value in the RGB
    ** triplet and green and blue are nothing.
    */
    bits[0] = RGB555_RED ;
    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) & 0x00F8F8F8;

    if (cref != RGB(0xF8,0,0))
        return FALSE;

    /*
    ** Ditto green. Note that if the driver is implementing 5-6-5, then
    ** green will read back as less than full scale and we will catch
    ** it here.
    */
    bits[0] = RGB555_GREEN ;
    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) & 0x00F8F8F8;

    if (cref != RGB(0,0xF8,0))
        return FALSE;

    /*
    ** Ditto blue.
    */
    bits[0] = RGB555_BLUE ;
    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) & 0x00F8F8F8;

    if (cref != RGB(0,0,0xF8))
        return FALSE;

    return TRUE;
}

STATICFN BOOL IsDisplay32Bit( HDC hdc )
{
    struct {
        BITMAPINFOHEADER    bi;
        RGBQUAD             rgbq[256];
    }   dib;
    int                     w ;
    LONG                    l=0;
    DWORD                   bits[2];

    w = GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES) ;

    if ( w < 15 )
        return FALSE;

    /*
    ** OK, the hardware is at least 16 bits - now test to see
    ** if they impelement a 32 bit DIB
    */

    dib.bi.biSize = sizeof(BITMAPINFOHEADER);
    dib.bi.biWidth = 2;
    dib.bi.biHeight = 1;
    dib.bi.biPlanes = 1;
    dib.bi.biBitCount = 32;
    dib.bi.biCompression = BI_RGB;
    dib.bi.biSizeImage = 4;
    dib.bi.biXPelsPerMeter = 0;
    dib.bi.biYPelsPerMeter = 0;
    dib.bi.biClrUsed = 1;
    dib.bi.biClrImportant = 0;

    //
    // send the Escape to see if they support 32bpp DIBs
    //
    if (Escape(hdc, QUERYDIBSUPPORT, (int)dib.bi.biSize, (LPVOID)&dib, (LPVOID)&l) > 0)
    {
        // make sure the driver realy realy gave us back flags.
	if (l & ~(0x00FF))
		l = 0;

        if (l & (QDI_DIBTOSCREEN|QDI_STRETCHDIB))
            return TRUE;
    }

    bits[0] = 0x00000000;
    bits[1] = 0x00FFFFFF;

    //
    // they dont support the QUERYDIBSUPPORT Escape, try to draw DIBs and see
    // what they do!
    //
    if (!StretchDIBits(hdc,0,0,2,1,0,0,2,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    if (GetPixel(hdc,0,0) != 0)
        return FALSE;

    if ((GetPixel(hdc,1,0) & 0x00F8F8F8) != 0x00F8F8F8)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\look775.h ===
BYTE lookup775[245] = {
0,
10,
1,
11,
249,
12,
13,
14,
15,
16,
17,
18,
19,
20,
21,
2,
22,
3,
23,
24,
25,
26,
27,
28,
29,
30,
31,
32,
33,
34,
250,
35,
36,
37,
251,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
55,
56,
57,
58,
59,
60,
61,
62,
63,
64,
65,
66,
67,
68,
69,
70,
71,
72,
73,
74,
75,
76,
77,
78,
79,
80,
81,
82,
83,
84,
85,
86,
87,
88,
89,
90,
91,
92,
93,
94,
95,
96,
97,
98,
99,
100,
101,
102,
103,
104,
105,
106,
107,
4,
108,
5,
109,
110,
111,
112,
113,
114,
115,
116,
117,
118,
119,
120,
6,
121,
248,
122,
123,
124,
125,
126,
127,
128,
129,
130,
131,
132,
133,
134,
135,
136,
137,
138,
139,
140,
141,
142,
143,
144,
145,
146,
147,
148,
149,
150,
151,
152,
153,
154,
155,
156,
157,
158,
159,
160,
161,
162,
163,
164,
165,
166,
167,
168,
169,
170,
171,
172,
173,
174,
175,
176,
177,
178,
179,
180,
181,
182,
183,
184,
185,
186,
187,
188,
189,
190,
191,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
252,
209,
210,
211,
253,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
228,
229,
230,
231,
232,
233,
234,
235,
236,
254,
237,
238,
239,
255
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\stretch.h ===
// in stretch.asm

void FAR PASCAL StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	--> BITMAPINFO of destination
	LPVOID	lpDst,		    //	--> to destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	--> BITMAPINFO of source
	LPVOID	lpSrc,		    //	--> to source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE); 	    //	y extent of the BLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\setdi.c ===
/**************************************************************************
*
*   SETDI.C - contains routines for doing a SetDIBits() into a bitmap.
*
**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include "lockbm.h"
#include "setdi.h"

/**************************************************************************
*
*  format conversion functions.
*
*  special functions....
*      copy_8_8    (no translate)
*      dither_8_8  (dither from 8bpp to fixed color device (like VGA, SVGA...)
*
**************************************************************************/

extern CONVERTPROC copy_8_8,      dither_8_8;
extern CONVERTPROC convert_8_8,   convert_8_16,    convert_8_24,    convert_8_32,    convert_8_VGA,  convert_8_565,   convert_8_RGB,   convert_8_RGBX;
extern CONVERTPROC convert_16_8,  convert_16_16,   convert_16_24,   convert_16_32,   convert_16_VGA, convert_16_565,  convert_16_RGB,  convert_16_RGBX;
extern CONVERTPROC convert_24_8,  convert_24_16,   convert_24_24,   convert_24_32,   convert_24_VGA, convert_24_565,  convert_24_RGB,  convert_24_RGBX;
extern CONVERTPROC convert_32_8,  convert_32_16,   convert_32_24,   convert_32_32,   convert_32_VGA, convert_32_565,  convert_32_RGB,  convert_32_RGBX;

static INITPROC init_8_8,   init_8_16,    init_8_24,    init_8_32,    init_8_VGA,  init_8_565,   init_8_RGB,   init_8_RGBX;
static INITPROC init_16_8,  init_16_16,   init_16_24,   init_16_32,   init_16_VGA, init_16_565,  init_16_RGB,  init_16_RGBX;
static INITPROC init_24_8,  init_24_16,   init_24_24,   init_24_32,   init_24_VGA, init_24_565,  init_24_RGB,  init_24_RGBX;
static INITPROC init_32_8,  init_32_16,   init_32_24,   init_32_32,   init_32_VGA, init_32_565,  init_32_RGB,  init_32_RGBX;

static INITPROC    init_setdi;
static CONVERTPROC convert_setdi;

static FREEPROC free_common;

static LPVOID init_dither_8_8(HDC hdc, LPBITMAPINFOHEADER lpbi);

/**************************************************************************
*
*  some conversions we dont do
*
**************************************************************************/

#define convert_8_VGA   NULL
#define convert_16_VGA  NULL
#define convert_24_VGA  NULL
#define convert_32_VGA  NULL

#define convert_8_32   NULL
#define convert_16_32  NULL
#define convert_24_32  NULL
#define convert_32_32  NULL

#define convert_8_RGBX   NULL
#define convert_16_RGBX  NULL
#define convert_24_RGBX  NULL
#define convert_32_RGBX  NULL

#define convert_8_RGB    NULL
#define convert_16_RGB   NULL
#define convert_24_RGB   NULL
#define convert_32_RGB   NULL

#define convert_16_8  NULL      // not now later!
#define convert_24_8  NULL
#define convert_32_8  NULL

/**************************************************************************
*
*  format conversion tables...
*
*  BITMAP types
*
*  8       0
*  16      1
*  24      2
*  32      3
*  VGA     4
*  16 565  5
*  24 RGB  6
*  32 RGB  7
*
**************************************************************************/

static PCONVERTPROC  ConvertProcTable[4][8] = {
    {convert_8_8,   convert_8_16,    convert_8_24,    convert_8_32,    convert_8_VGA,  convert_8_565,   convert_8_RGB,   convert_8_RGBX},
    {convert_16_8,  convert_16_16,   convert_16_24,   convert_16_32,   convert_16_VGA, convert_16_565,  convert_16_RGB,  convert_16_RGBX},
    {convert_24_8,  convert_24_16,   convert_24_24,   convert_24_32,   convert_24_VGA, convert_24_565,  convert_24_RGB,  convert_24_RGBX},
    {convert_32_8,  convert_32_16,   convert_32_24,   convert_32_32,   convert_32_VGA, convert_32_565,  convert_32_RGB,  convert_32_RGBX},
};

static PINITPROC  InitProcTable[4][8] = {
    {init_8_8,   init_8_16,    init_8_24,    init_8_32,    init_8_VGA,  init_8_565,   init_8_RGB,   init_8_RGBX},
    {init_16_8,  init_16_16,   init_16_24,   init_16_32,   init_16_VGA, init_16_565,  init_16_RGB,  init_16_RGBX},
    {init_24_8,  init_24_16,   init_24_24,   init_24_32,   init_24_VGA, init_24_565,  init_24_RGB,  init_24_RGBX},
    {init_32_8,  init_32_16,   init_32_24,   init_32_32,   init_32_VGA, init_32_565,  init_32_RGB,  init_32_RGBX},
};

/**************************************************************************
**************************************************************************/

#define RGB555(r,g,b) (\
            (((WORD)(r) >> 3) << 10) |  \
            (((WORD)(g) >> 3) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

#define RGB565(r,g,b) (\
            (((WORD)(r) >> 3) << 11) |  \
            (((WORD)(g) >> 2) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

/**************************************************************************
**************************************************************************/

#ifdef DEBUG
static
#else
__inline
#endif

LONG BitmapXY(IBITMAP *pbm, int x, int y)
{
    LONG offset = pbm->bmOffset;

//!!! wrong!!! but y for bitmaps is always zero....
//  if (pbm->bmFillBytes)
//      offset += (y / pbm->bmScanSegment) * pbm->bmFillBytes;

    offset += y * (long)pbm->bmNextScan;
    offset += x * pbm->bmBitsPixel / 8;

    return offset;
}

/**************************************************************************
* @doc INTERNAL SetBitmapBegin
*
* @api BOOL | SetBitmapBegin | prepare to do a SetDIBits() into a bitmap
*
* @rdesc Returns TRUE if success.
*
**************************************************************************/

BOOL FAR SetBitmapBegin(
    PSETDI   psd,
    HDC      hdc,               //
    HBITMAP  hbm,               //  bitmap to set into
    LPBITMAPINFOHEADER lpbi,    //  --> BITMAPINFO of source
    UINT     DibUsage)
{
    BITMAP bm;

    SetBitmapEnd(psd);  // free and old stuff

    GetObject(hbm, sizeof(bm), &bm);

    psd->hbm     = hbm;
//  psd->hdc     = hdc;
//  psd->hpal    = hpal;
    psd->DibUsage= DibUsage;

    psd->color_convert = NULL;
    psd->convert = NULL;
    psd->size = sizeof(SETDI);

    if (!GetBitmapDIB(lpbi, NULL, &psd->bmSrc, sizeof(psd->bmSrc)))
        return FALSE;

    //
    // make sure we can lock the bitmap
    //
    if (GetBitmap(hbm, &psd->bmDst, sizeof(psd->bmDst)) &&
        psd->bmDst.bmFillBytes <= 0 &&
        psd->bmSrc.bmType > 0 && psd->bmSrc.bmType <= 4 &&
        psd->bmDst.bmType > 0 && psd->bmDst.bmType <= 8)
    {
        psd->init    = InitProcTable[psd->bmSrc.bmType-1][psd->bmDst.bmType-1];
        psd->convert = ConvertProcTable[psd->bmSrc.bmType-1][psd->bmDst.bmType-1];
        psd->free    = free_common;
    }

    //
    // if we cant convert ourself try SetDIBits()
    //
    if (psd->convert == NULL)
    {
        psd->convert = convert_setdi;
        psd->init    = init_setdi;
        psd->free    = NULL;
    }

    if (psd->init)
    {
        psd->hdc = hdc;
        if (!psd->init(psd))
        {
            psd->hdc = 0;
            psd->size = 0;
            psd->convert = NULL;
            return FALSE;
        }
        psd->hdc  = NULL;
        psd->hpal = NULL;
    }

    return TRUE;
}

/**************************************************************************
* @doc INTERNAL SetBitmapColorChange
*
* @api BOOL | SetBitmapColorChange | re-init the color conversion
*
* @rdesc Returns TRUE if success.
*
**************************************************************************/

void FAR SetBitmapColorChange(PSETDI psd, HDC hdc, HPALETTE hpal)
{
    if (psd->size != sizeof(SETDI))
        return;

    if (hdc == NULL)
        return;

    if (psd->free)              //!!! ack?
        psd->free(psd);

    psd->hdc  = hdc;
    psd->hpal = hpal;

    if (psd->init)
        psd->init(psd);

    psd->hdc  = NULL;
    psd->hpal = NULL;
}

/**************************************************************************
* @doc INTERNAL SetBitmapEnd
*
* @api void | SetBitmapEnd | clean out a SETDI structure
*
**************************************************************************/

void FAR SetBitmapEnd(PSETDI psd)
{
    if (psd->size != sizeof(SETDI))
        return;

    if (psd->free)
        psd->free(psd);

    psd->size = 0;
    psd->convert = NULL;
    psd->init = NULL;
    psd->free = NULL;
}

/**************************************************************************
* @doc INTERNAL SetBitmap
*
* @api BOOL | SetBitmap | convert DIB bits to bitmaps bits.
*
**************************************************************************/

BOOL FAR SetBitmap(PSETDI psd, int DstX, int DstY, int DstDX, int DstDY, LPVOID lpBits, int SrcX, int SrcY, int SrcDX, int SrcDY)
{
    if (psd->size != sizeof(SETDI))
        return FALSE;

    psd->convert(
        psd->bmDst.bmBits,                  // --> dst.
        BitmapXY(&psd->bmDst, DstX, DstY),  // offset to start at
        psd->bmDst.bmNextScan,              // dst_next_scan.
        psd->bmDst.bmFillBytes,             // fill bytes
        lpBits,                             // --> Src.
        BitmapXY(&psd->bmSrc, SrcX, SrcY),  // offset to start at
        psd->bmSrc.bmNextScan,              // Src_next_scan.
        DstDX,
        DstDY,
        psd->color_convert);

    return TRUE;
}

/**************************************************************************
*
*   cleanup stuff
*
**************************************************************************/

static BOOL free_common(PSETDI psd)
{
    //
    // clean up what we did
    //
    if (psd->color_convert != NULL)
        GlobalFreePtr(psd->color_convert);

    psd->color_convert = NULL;

    return TRUE;
}

/**************************************************************************
*
* GetBackgroundTranslate
*
*   get the foreground to background translate table.
*
*   does this by calling GDI, this should always work.
*   this only works on a palette device.
*
**************************************************************************/

BOOL GetBackgroundTranslate(HDC hdc, LPBYTE pb)
{
    int  i;
    int  n;
    DWORD rgb;
    DWORD *prgb;

#ifndef _WIN32  // until we can find this on NT... make it 16bit only
    extern BOOL FAR PASCAL IsDCCurrentPalette(HDC hdc);

    if (IsDCCurrentPalette(hdc))
    {
        for (i=0; i<256; i++)
            pb[i] = i;

        return TRUE;
    }
#endif

    prgb = (DWORD *)LocalAlloc(LPTR, 256 * sizeof(DWORD));

    if (prgb == NULL)
	return TRUE;

    GetSystemPaletteEntries(hdc, 0, 256,(PALETTEENTRY FAR *)prgb);

    for (n=0; n<256; n++)           //!!! is this needed.
	prgb[n] &= 0x00FFFFFF;

    for (i=0; i<256; i++)
    {
        //
        // GDI will figure out what physical color this palette
        // index is mapped to.
        //
        rgb = GetNearestColor(hdc, PALETTEINDEX(i)) & 0x00FFFFFF;

        //
        // quick check for identity map.
        //
	if (prgb[i] == rgb)
        {
            pb[i] = (BYTE)i;
            continue;
        }

        //
        // now we have to find the rgb in the physical palette
        //
        for (n=0; n<256; n++)
	    if (prgb[n] == rgb)
                break;

        //
        // our search should never fail, because GDI gave us a RGB
        // in the palette.
        //
        if (n == 256)   //!!! should never happen
            n = 0;

        pb[i] = (BYTE)n;
    }

    LocalFree((HLOCAL)prgb);

    return TRUE;
}

/**************************************************************************
*
* @doc INTERNAL GetPaletteMap
*
* @api BOOL | GetPhysPaletteMap | gets the physical mapping for a DIB
*
* returns TRUE if the mapping is a 1:1 mapping, FALSE otherwise
*
**************************************************************************/

BOOL GetPhysDibPaletteMap(HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb)
{
    int i;
    int n;
    BYTE ab[256];

    GetDibPaletteMap(hdc, lpbi, Usage, pb);
    GetBackgroundTranslate(hdc, ab);

    //
    // translate forground palette to physical
    //
    for (i=0; i<256; i++)
        pb[i] = ab[pb[i]];

    //
    // test for 1:1
    //
    n = (int)lpbi->biClrUsed ? (int)lpbi->biClrUsed : 256;

    for (i=0; i<n; i++)
        if (pb[i] != i)
            break;

    return i == n;
}

/**************************************************************************
*
* @doc INTERNAL
*
* @api void | GetDibPaletteMap | gets the mapping of a DIB color table
* in  foreground palette index's
*
**************************************************************************/

BOOL GetDibPaletteMap(HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb)
{
    HBITMAP hbm;
    int i;
    int n;

    LONG biWidth = lpbi->biWidth;
    LONG biHeight = lpbi->biHeight;
    LONG biSizeImage = lpbi->biSizeImage;

    n = (int)lpbi->biClrUsed ? (int)lpbi->biClrUsed : 256;

    for (i=0; i<n; i++)
        pb[i] = (BYTE) i;

    for (; i<256; i++)
        pb[i] = 0;

    if (lpbi->biBitCount != 8)
        return FALSE;

    hbm = CreateCompatibleBitmap(hdc,256,1);

    lpbi->biSizeImage = 256;
    lpbi->biWidth  = 256;
    lpbi->biHeight = 1;

    SetDIBits(hdc, hbm, 0, 1, pb, (LPBITMAPINFO)lpbi, Usage);
    GetBitmapBits(hbm, 256, pb);
    DeleteObject(hbm);

    lpbi->biWidth  = biWidth;
    lpbi->biHeight = biHeight;
    lpbi->biSizeImage = biSizeImage;

    //
    // test for 1:1 translate
    //
    for (i=0; i<n; i++)
    {
        if (pb[i] != i)
        {
            //
            // some ET4000 drivers have the same color (128,128,128)
            // at index 7 and at index 248.
            //
            // we should detect a identity palette in this case.
            //
            if (i == 248 && pb[i] == 7)
            {
                pb[i] = 248;
                continue;
            }
            break;
        }
    }

    return i == n;
}

/**************************************************************************
*
*   convert for SetDIBits
*
**************************************************************************/

void FAR PASCAL convert_setdi(
    LPVOID pd,      // --> dst.
    LONG   dd,      // offset to start at
    LONG   nd,      // dst_next_scan.
    LONG   fd,      // dst fill bytes
    LPVOID ps,      // --> source.
    LONG   ds,      // offset to start at
    LONG   ns,      // src_next_scan.
    LONG   dx,      // pixel count.
    LONG   dy,      // scan count.
    LPVOID pc)      // pixel convert table.
{
    PSETDI psd = (PSETDI)(LONG_PTR)pd;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    lpbi->biHeight = dy;

    SetDIBits(
        psd->hdc,
        psd->hbm,
        0,(int)dy,
        ((BYTE _huge *)ps) + ds - dd,
        (LPBITMAPINFO)lpbi,
        psd->DibUsage);

    lpbi->biHeight = psd->bmSrc.bmHeight;
}

/**************************************************************************
*
*   init stuff for SetDIBits
*
**************************************************************************/

static BOOL init_setdi(PSETDI psd)
{
    UINT u;
    HDC  hdc;
    LPBYTE p;
    LPBITMAPINFOHEADER lpbi;

    // test to see if SetDIBits() works.
    // !!! we should check for 16 or a 32bit DIB and do the escape.
    // !!! on a palette device we need to build a palette map!!!

    if (psd->bmSrc.bmBitsPixel == 16 ||
        psd->bmSrc.bmBitsPixel == 32)
        return FALSE;

    // convert_setdi will need this.
    psd->bmDst.bmBits = (LPVOID)(UINT_PTR)psd;
    psd->bmDst.bmOffset = 0;
    psd->bmDst.bmBitsPixel = psd->bmSrc.bmBitsPixel;

    if (psd->hdc && psd->hpal)
    {
        // map colors to current palette!!!!!!!!!!!!!!!!!!!!!!!!!!

        //set this to be the BITMAPINFO + color map.
        psd->color_convert = 0;
    }

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;
    lpbi->biHeight = 1;

    p = (LPBYTE)GlobalAllocPtr(GHND,psd->bmSrc.bmWidthBytes);

    hdc = GetDC(NULL);

    u = SetDIBits(
        hdc,
        psd->hbm,0,1,p,
        (LPBITMAPINFO)psd->bmSrc.bmBitmapInfo,
        psd->DibUsage);

    ReleaseDC(NULL, hdc);

    lpbi->biHeight = psd->bmSrc.bmHeight;
    GlobalFreePtr(p);

    return u == 1;
}

/**************************************************************************
*
*   init stuff for 8bpp bitmaps
*
**************************************************************************/

static BOOL init_8_8(PSETDI psd)
{
    LPBITMAPINFOHEADER lpbi;

    //
    //  if we are mapping from one DIB to another figure this out
    //
    if (psd->hdc == NULL || psd->bmDst.bmBitmapInfo != 0)
    {
        // we assume this routine will not be used for  color matching
        // from DIB to DIB, so give up.

        psd->convert = copy_8_8;
        return TRUE;
    }

    //
    // we are mapping to a device (HDC)
    //
    // we need to compute a 8-->8 conversion table, from the source colors
    // (in psd->lpbiSrc) to the colors on the device.
    //
    // how we do this depends on weather the device is a palette device or not.
    //

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (GetDeviceCaps(psd->hdc, RASTERCAPS) & RC_PALETTE)
    {
        if (psd->hpal == NULL)
        {
            // no palette to match to yet
            psd->convert = copy_8_8;
            return TRUE;
        }

        if (psd->color_convert == NULL)
            psd->color_convert = GlobalAllocPtr(GHND, 256);

        //
        //  we can do this one of two ways,
        //
        //  we can always convert to the palette foreground mapping, or
        //
        //  we can convert to the current colors always (using this method
        //  we will need to recompute the xlat table on every palette
        //  change)
        //
        //  lets convert to the current device colors. (this may cause
        //  problems we will check on later...)
        //

//      if (GetPhysDibPaletteMap(psd->hdc, lpbi, psd->DibUsage, psd->color_convert))
        if (GetDibPaletteMap(psd->hdc, lpbi, psd->DibUsage, psd->color_convert))
            psd->convert = copy_8_8;
        else
            psd->convert = convert_8_8;
    }
    else
    {
        // !!!we should check for solid colors (ie no dither needed) and also
        // check for 1:1 (no translate)

        if (psd->color_convert == NULL)     //!!!
            psd->color_convert = init_dither_8_8(psd->hdc, lpbi);

        psd->convert = dither_8_8;

        //!!! we need to give the device colors to the caller
    }

    return TRUE;
}

static BOOL init_16_8(PSETDI psd)
{
    return FALSE;       // we dont handle dither yet!
}

static BOOL init_24_8(PSETDI psd)
{
    return FALSE;       // we dont handle dither yet!
}

static BOOL init_32_8(PSETDI psd)
{
    return FALSE;       // we dont handle dither yet!
}

/**************************************************************************
*
*   init stuff for 16bpp bitmaps
*
**************************************************************************/

static BOOL init_8_16(PSETDI psd)
{
    WORD FAR*pw;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*2);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pw = psd->color_convert;

    for (i=0; i<n; i++)
        pw[i] = RGB555(prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);

    for (; i<256; i++)
        pw[i] = 0;

    return TRUE;
}

static BOOL init_16_16(PSETDI psd)
{
    return TRUE;
}

static BOOL init_24_16(PSETDI psd)
{
    return TRUE;
}

static BOOL init_32_16(PSETDI psd)
{
    return TRUE;
}

/**************************************************************************
*
*   init stuff for 24bpp bitmaps
*
**************************************************************************/

static BOOL init_8_24(PSETDI psd)
{
    DWORD FAR*pd;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*4);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pd = psd->color_convert;

    for (i=0; i<n; i++)
        pd[i] = RGB(prgb[i].rgbBlue, prgb[i].rgbGreen, prgb[i].rgbRed);

    for (; i<256; i++)
        pd[i] = 0;

    return TRUE;
}

static BOOL init_16_24(PSETDI psd)
{
    return TRUE;
}

static BOOL init_24_24(PSETDI psd)
{
    return TRUE;
}

static BOOL init_32_24(PSETDI psd)
{
    return TRUE;
}

/**************************************************************************
*
*   init stuff for 32bpp bitmaps
*
**************************************************************************/

static BOOL init_8_32(PSETDI psd)
{
    return FALSE;
////return init_8_24(psd);
}

static BOOL init_16_32(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_32(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_32(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*   init stuff for VGA bitmaps
*
**************************************************************************/

static BOOL init_8_VGA(PSETDI psd)
{
    return FALSE;
}

static BOOL init_16_VGA(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_VGA(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_VGA(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*   init stuff for RGB 565 bitmaps
*
**************************************************************************/

static BOOL init_8_565(PSETDI psd)
{
    WORD FAR*pw;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*2);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pw = psd->color_convert;

    for (i=0; i<n; i++)
        pw[i] = RGB565(prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);

    for (; i<256; i++)
        pw[i] = 0;

    return TRUE;
}

static BOOL init_16_565(PSETDI psd)
{
    return TRUE;
}

static BOOL init_24_565(PSETDI psd)
{
    return TRUE;
}

static BOOL init_32_565(PSETDI psd)
{
    return TRUE;
}

/**************************************************************************
*
*   init stuff for RGB 24bpp bitmaps
*
**************************************************************************/

static BOOL init_8_RGB(PSETDI psd)
{
    DWORD FAR *pd;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*4);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pd = psd->color_convert;

    for (i=0; i<n; i++)
        pd[i] = RGB(prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);

    for (; i<256; i++)
        pd[i] = 0;

    return TRUE;
}

static BOOL init_16_RGB(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_RGB(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_RGB(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*   init stuff for RGB 32bpp bitmaps
*
**************************************************************************/

static BOOL init_8_RGBX(PSETDI psd)
{
    return init_8_RGB(psd);
}

static BOOL init_16_RGBX(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_RGBX(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_RGBX(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*  init_dither_8_8
*
*  initialize a dither table that maps a 8 bit color to the device's dither
*
*  pel = dither_table[y&7][pel][x&7]
*
**************************************************************************/

static LPVOID init_dither_8_8(HDC hdc, LPBITMAPINFOHEADER lpbi)
{
    HBRUSH   hbr;
    HDC      hdcMem;
//  HDC      hdc;
    HBITMAP  hbm;
    HBITMAP  hbmT;
    int      i;
    int      nColors;
    LPRGBQUAD prgb;
    LPVOID   lpDitherTable;

    struct {
        BITMAPINFOHEADER bi;
        RGBQUAD rgb[256];
    }   dib;

    lpDitherTable = GlobalAllocPtr(GHND, 256*8*8);

    if (lpDitherTable == NULL)
        return (LPVOID)-1;

    hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);

    hbm = CreateCompatibleBitmap(hdc, 256*8, 8);
    hbmT = SelectObject(hdcMem, hbm);

    if ((nColors = (int)lpbi->biClrUsed) == 0)
        nColors = 1 << (int)lpbi->biBitCount;

    prgb = (LPRGBQUAD)(lpbi+1);

    for (i=0; i<nColors; i++)
    {
        hbr = CreateSolidBrush(RGB(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue));
        hbr = SelectObject(hdcMem, hbr);
        PatBlt(hdcMem, i*8, 0, 8, 8, PATCOPY);
        hbr = SelectObject(hdcMem, hbr);
        DeleteObject(hbr);
    }

#ifdef XDEBUG
    for (i=0; i<16; i++)
        BitBlt(hdc,0,i*8,16*8,8,hdcMem,i*(16*8),0,SRCCOPY);
#endif

    dib.bi.biSize           = sizeof(BITMAPINFOHEADER);
    dib.bi.biPlanes         = 1;
    dib.bi.biBitCount       = 8;
    dib.bi.biWidth          = 256*8;
    dib.bi.biHeight         = 8;
    dib.bi.biCompression    = BI_RGB;
    dib.bi.biSizeImage      = 256*8*8;
    dib.bi.biXPelsPerMeter  = 0;
    dib.bi.biYPelsPerMeter  = 0;
    dib.bi.biClrUsed        = 0;
    dib.bi.biClrImportant   = 0;
    GetDIBits(hdc, hbm, 0, 8, lpDitherTable, (LPBITMAPINFO)&dib, DIB_RGB_COLORS);

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);
    DeleteObject(hbm);
    ReleaseDC(NULL, hdc);

    return (LPVOID)lpDitherTable;
}

#ifdef _WIN32 // Provide some dummy entry points as a temporary measure for NT
void FAR PASCAL convert_16_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_16_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_16_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_24_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_24_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_24_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_32_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_32_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_32_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_8
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL copy_8_8
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL dither_8_8
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\setdi.h ===
#ifndef _SETDI_H_
#define _SETDI_H_

typedef void (FAR PASCAL CONVERTPROC)(
        LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc);             // pixel convert table.

struct SETDI;

typedef CONVERTPROC *PCONVERTPROC;
typedef BOOL (INITPROC)(struct SETDI *psd);
typedef BOOL (FREEPROC)(struct SETDI *psd);

typedef INITPROC *PINITPROC;
typedef FREEPROC *PFREEPROC;

typedef struct SETDI
{
        LONG         size;           // for sanity checks.

        HDC          hdc;
        HPALETTE     hpal;
        HBITMAP      hbm;
        UINT         DibUsage;

        IBITMAP      bmDst;
        IBITMAP      bmSrc;

        LPVOID       color_convert;  // dither/color convert table.
        PCONVERTPROC convert;        // convert function
        PINITPROC    init;
        PFREEPROC    free;
} SETDI, *PSETDI;

BOOL FAR SetBitmapBegin(
        PSETDI   psd,
        HDC      hdc,
        HBITMAP  hbm,               //  bitmap to set into
        LPBITMAPINFOHEADER lpbi,    //  --> BITMAPINFO of source
        UINT     DibUsage);

void FAR SetBitmapColorChange(PSETDI psd, HDC hdc, HPALETTE hpal);
void FAR SetBitmapEnd(PSETDI psd);
BOOL FAR SetBitmap(PSETDI psd, int DstX, int DstY, int DstDX, int DstDY, LPVOID lpBits, int SrcX, int SrcY, int SrcDX, int SrcDY);

BOOL GetPhysDibPaletteMap(HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb);
BOOL GetDibPaletteMap    (HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb);
#endif //_SETDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType	    dw	?		; contains 'DI', 0 or ScreenSelector  ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deCursorExclude   dd	?		; Cursor Exclude call back	      ;*/ void         (FAR *deCursorExclude)();  /*
  deCursorUnexclude dd	?		; Cursor Unexclude call back	      ;*/ void         (FAR *deCursorUnexclude)();/*
  deReserved2	    dd  ?		; Reserved.                           ;*/ DWORD        deReserved2;               /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER   	equ     0000000000000001b
PALETTIZED   	equ     0000000000000010b				      
SELECTEDDIB  	equ     0000000000000100b				      
CURSOREXCLUDE	equ     0000000000001000b                                      
DISABLED        equ     0000000000010000b
VRAM		equ     1000000000000000b                                      
BANKEDVRAM	equ     0100000000000000b                                      
BANKEDSCAN	equ     0010000000000000b                                      
comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define CURSOREXCLUDE   0x0008	  
#define DISABLED        0x0010	  
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
/*
end comment ~
;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
MONO_BIT	equ	00000001b	;0=Black, 1=White                     
PHYS_BIT	equ	10000000b	;1=physical color, 0=logical color    
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define MONO_BIT        0x01	  
#define PHYS_BIT        0x80	  
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
/*
end comment ~
;----------------------------------------------------------------------------
; M A C R O S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Cycle24 i
;
; This macro cycle a replicated 24 bit color in register eax, 'i' times.
; If 'i' is blank, the cycle is done one time, else it is done twice
;----------------------------------------------------------------------------
Cycle24 macro i

ifb <i>                                 ;assume eax = 'brgb'
        mov     al,ah                   ;eax = 'brgg'
        ror     eax,8                   ;eax = 'gbrg'
else
        rol     eax,16                  ;eax = 'gbbr'
        mov     ah,al                   ;eax = 'gbrr'
        ror     eax,8                   ;eax = 'rgbr'
endif
        endm
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dva.h ===
/****************************************************************************

 DVA.H

 Copyright (c) 1993-1994 Microsoft Corporation

 DVA 1.0 Interface Definitions

 ***************************************************************************/

#ifndef _INC_DVA
#define _INC_DVA
#ifdef WIN32
#define DVABeginAccess(hdva, x, y, dx, dy) 0
#define DVAEndAccess(hdva) 0
#define DVAGetSurfaceFmt(hdva) 0
#define DVAGetSurfacePtr(hdva) 0
#else

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dvaddi.h"     // interface to the display driver

/****************************************************************************
 ***************************************************************************/

typedef DVASURFACEINFO FAR *PDVA;
typedef PDVA HDVA;

/****************************************************************************
 ***************************************************************************/

//
// this code in biCompression means the frame buffer must be accesed via
// 48 bit pointers! using *ONLY* the given selector
//
// BI_1632 has bitmasks (just like BI_BITFIELDS) for biBitCount == 16,24,32
//
#ifndef BI_1632
#define BI_1632  0x32333631     // '1632'
#endif

#ifndef BI_BITFIELDS
#define BI_BITFIELDS 3
#endif

/****************************************************************************
 ***************************************************************************/

#if defined(_INC_VFW) || defined(_INC_DRAWDIB)
//
//  this API is in MSVIDEO.DLL
//
BOOL VFWAPI DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *lpSurfaceInfo);

#else

//
//  this API uses the Escape to the display driver only
//
__inline BOOL DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    int i;

    i = Escape(hdc, DVAGETSURFACE,sizeof(int),(LPCSTR)&nSurface,(LPVOID)pdva);

    return i > 0;
}

#endif

/****************************************************************************
 ***************************************************************************/

__inline PDVA DVAOpenSurface(HDC hdc, int nSurface)
{
    PDVA pdva;

    pdva = (PDVA)GlobalLock(GlobalAlloc(GHND|GMEM_SHARE, sizeof(DVASURFACEINFO)));

    if (pdva == NULL)
        return NULL;

    if (!DVAGetSurface(hdc, nSurface, pdva) ||
        !pdva->OpenSurface(pdva->lpSurface))
    {
        GlobalFree((HGLOBAL)SELECTOROF(pdva));
        return NULL;
    }

    return pdva;
}

/****************************************************************************
 ***************************************************************************/

__inline void DVACloseSurface(PDVA pdva)
{
    if (pdva == NULL)
        return;

    pdva->CloseSurface(pdva->lpSurface);

    GlobalFree((HGLOBAL)SELECTOROF(pdva));
}

/****************************************************************************
 ***************************************************************************/

__inline BOOL DVABeginAccess(PDVA pdva, int x, int y, int dx, int dy)
{
    return pdva->BeginAccess(pdva->lpSurface, x, y, dx, dy);
}

/****************************************************************************
 ***************************************************************************/

__inline void DVAEndAccess(PDVA pdva)
{
    pdva->EndAccess(pdva->lpSurface);
}

/****************************************************************************
 ***************************************************************************/

__inline LPBITMAPINFOHEADER DVAGetSurfaceFmt(PDVA pdva)
{
    if (pdva == NULL)
        return NULL;

    return &pdva->BitmapInfo;
}

/****************************************************************************
 ***************************************************************************/

__inline LPVOID DVAGetSurfacePtr(PDVA pdva)
{
    if (pdva == NULL)
        return NULL;

    return (LPVOID)MAKELONG(pdva->offSurface, pdva->selSurface);
}

#ifdef __cplusplus
    }
#endif

#endif // else WIN32
#endif // _INC_DVA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dvaati.c ===
/****************************************************************************

    DVA surface provider for a ATI Mach32 card.

    assumes a linear frame buffer

    assumes a hardware cursor

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern NEAR PASCAL DetectATI(void);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK ati_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK ati_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK ati_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    //
    // ATI Mach32 has a HW cursor so we dont do anything
    // !!!we may need to check for the sysVM in background
    //
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK ati_end_access(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL ati_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (pbm->bmType != 0x2000)
        return FALSE;

    if (!DetectATI())
        return FALSE;

    sel = ((WORD FAR  *)&pbm->bmBits)[2];
    off = ((DWORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0xFFFFFFFF || off < 4*1024*1024l)
        return FALSE;

    sel = 0;    // off is the linear offset.

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = (LPVOID)42;

#ifdef DEBUG
{
//
// in DEBUG use the VGA's begin/end access routines so the mouse will flicker!
//
extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);
extern BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy);
extern BOOL FAR PASCAL _loadds vga_end_access(LPVOID pv);
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
}
#else
    (FARPROC)pdva->OpenSurface  = (FARPROC)ati_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)ati_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)ati_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)ati_end_access;
#endif
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dva.c ===
#include <windows.h>

#define _INC_VFW
#define VFWAPI FAR PASCAL _loadds

#include "dva.h"
#include "lockbm.h"

/****************************************************************************
 ***************************************************************************/

extern BOOL vga_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL ati_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL dib_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL thun_get_surface(HDC,int, DVASURFACEINFO FAR *);
extern BOOL vlb_get_surface(HDC, int, DVASURFACEINFO FAR *);

#define GetDS() SELECTOROF((LPVOID)&ScreenSel)
static short ScreenSel;

static BOOL InitSurface(DVASURFACEINFO FAR *pdva);
static BOOL TestSurface(DVASURFACEINFO FAR *pdva);
static void SetSelLimit(UINT sel, DWORD limit);

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL DVAInit()
{
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL DVATerm()
{
    //
    // free screen alias
    //
    if (ScreenSel)
    {
        SetSelLimit(ScreenSel, 0);
        FreeSelector(ScreenSel);
        ScreenSel = 0;
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    int i;

    i = Escape(hdc, DVAGETSURFACE,sizeof(int),(LPCSTR)&nSurface,(LPVOID)pdva);

    //
    // should this be a function table? list?
    //
    if (i <= 0 &&
        !dib_get_surface(hdc, nSurface, pdva) &&
        !ati_get_surface(hdc, nSurface, pdva) &&
#ifdef DEBUG
        !vlb_get_surface(hdc, nSurface, pdva) &&
        !thun_get_surface(hdc, nSurface, pdva) &&
#endif
        !vga_get_surface(hdc, nSurface, pdva))

        return FALSE;

    return InitSurface(pdva);
}

#if 0

/****************************************************************************
 ***************************************************************************/

HDVA FAR PASCAL DVAOpenSurface(HDC hdc, int nSurface)
{
    PDVA pdva;

    pdva = (PDVA)GlobalAllocPtr(GHND|GMEM_SHARE, sizeof(DVASURFACEINFO));

    if (pdva == NULL)
        return NULL;

    if (!DVAGetSurface(hdc, nSurface, pdva) ||
        !pdva->OpenSurface(pdva->lpSurface))
    {
        GlobalFreePtr(pdva);
        return NULL;
    }

    return pdva;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL DVACloseSurface(HDVA pdva)
{
    if (pdva == NULL)
        return;

    pdva->CloseSurface(pdva->lpSurface);

    GlobalFreePtr(pdva);
}

#endif

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK default_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK default_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK default_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK default_end_access(LPVOID pv)
{
}


/****************************************************************************
 ***************************************************************************/

UINT CALLBACK default_show_surface(LPVOID pv, HWND hwnd, LPRECT src, LPRECT dst)
{
    return 1;
}

/****************************************************************************
 ***************************************************************************/

static BOOL InitSurface(DVASURFACEINFO FAR *pdva)
{
    LPBITMAPINFOHEADER lpbi;

    if (pdva->Version != 0x0100)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return FALSE;

    if (lpbi->biPlanes != 1)
        return FALSE;

    //
    // make the pointer a 16:16 pointer
    //
    if (pdva->offSurface >= 0x10000 &&
        !(pdva->Flags & DVAF_1632_ACCESS))
    {
        if (ScreenSel == NULL)
            ScreenSel = AllocSelector(GetDS());

        if (pdva->selSurface != 0)
            pdva->offSurface += GetSelectorBase(pdva->selSurface);

        SetSelectorBase(ScreenSel,pdva->offSurface);
        SetSelLimit(ScreenSel,lpbi->biSizeImage-1);

        pdva->offSurface = 0;
        pdva->selSurface = ScreenSel;
    }

    //
    // fill in defaults.
    //
    if (pdva->OpenSurface == NULL)
        pdva->OpenSurface = default_open_surface;

    if (pdva->CloseSurface == NULL)
        pdva->CloseSurface = default_close_surface;

    if (pdva->ShowSurface == NULL)
        pdva->ShowSurface = default_show_surface;

    if (pdva->BeginAccess == NULL)
    {
        pdva->BeginAccess = default_begin_access;
        pdva->EndAccess   = default_end_access;
    }

    //
    // only test RGB surfaces.
    //
    if (lpbi->biCompression == 0 ||
        lpbi->biCompression == BI_BITFIELDS ||
        lpbi->biCompression == BI_1632)
    {
        if (!TestSurface(pdva))
            return FALSE;
    }

    //
    // set BI_1632 if needed
    //
    if (pdva->Flags & DVAF_1632_ACCESS)
    {
        lpbi->biCompression = BI_1632;
    }

    return TRUE;
}

/****************************************************************************
 ***************************************************************************/
#pragma optimize("", off)
static void SetSelLimit(UINT sel, DWORD limit)
{
    if (limit >= 1024*1024l)
        limit = ((limit+4096) & ~4095) - 1;

    _asm
    {
        mov     ax,0008h            ; DPMI set limit
        mov     bx,sel
        mov     dx,word ptr limit[0]
        mov     cx,word ptr limit[2]
        int     31h
    }
}
#pragma optimize("", on)

/****************************************************************************
 ***************************************************************************/

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#pragma optimize("", off)
static BYTE ReadByte(PDVA pdva, LPVOID lpBits, DWORD dw)
{
    BYTE b=42;

    DVABeginAccess(pdva, 0, 0, 1024, 1024);

    _asm {
        ASM66   xor     bx,bx
                les     bx,lpBits
        ASM66   add     bx,word ptr dw
                mov     ax,es
        ASM66   lsl     ax,ax
        ASM66   cmp     bx,ax
                ja      exit
        DB 26h ;mov     al,es:[ebx]
        DB 67h
        DB 8Ah
        DB 03h
                mov b,al
exit:
    }

    DVAEndAccess(pdva);

    return b;
}
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

/****************************************************************************
 ***************************************************************************/

static BOOL TestSurface(DVASURFACEINFO FAR *pdva)
{
    HDC hdc;
    int x,y,h,w,wb;
    COLORREF rgb,rgb0,rgb1,rgb2,rgb3,rgb4;
    DWORD dw;
    BYTE  b0,b1;
    UINT  uType=0;
    LPBITMAPINFOHEADER lpbi;
    LPVOID lpBits;
    HCURSOR hcur;

    if (!pdva->OpenSurface(pdva->lpSurface))
        return FALSE;

    lpbi = DVAGetSurfaceFmt(pdva);
    lpBits = DVAGetSurfacePtr(pdva);

    h = abs((int)lpbi->biHeight);
    w = (int)lpbi->biWidth;
    wb = (w * ((UINT)lpbi->biBitCount/8) + 3) & ~3;
    dw = (DWORD)(UINT)(h-1) * (DWORD)(UINT)wb;

    if ((int)lpbi->biHeight < 0)
        y = 0;
    else
        y = h-1;

#ifdef XDEBUG
    x = (int)lpbi->biWidth - 5;
    ((LPBYTE)lpBits) += x * (UINT)lpbi->biBitCount/8;
#else
    x = 0;
#endif

    hcur = SetCursor(NULL);
    hdc = GetDC(NULL);

    rgb = GetPixel(hdc, x, h-1-y);
    SetPixel(hdc, x, h-1-y, RGB(0,0,0));       GetPixel(hdc, x, h-1-y); b0 = ReadByte(pdva, lpBits, dw);
    SetPixel(hdc, x, h-1-y, RGB(255,255,255)); GetPixel(hdc, x, h-1-y); b1 = ReadByte(pdva, lpBits, dw);
    SetPixel(hdc, x, h-1-y,rgb);

    if (b0 != 0x00 || b1 == 0x00)
        goto done;

    rgb0 = GetPixel(hdc, x+0, y);
    rgb1 = GetPixel(hdc, x+1, y);
    rgb2 = GetPixel(hdc, x+2, y);
    rgb3 = GetPixel(hdc, x+3, y);
    rgb4 = GetPixel(hdc, x+4, y);

    TestSurfaceType(hdc, x, y);

    DVABeginAccess(pdva, x, y, 5, 1);
    uType = GetSurfaceType(lpBits);
    DVAEndAccess(pdva);

    SetPixel(hdc, x+0, y,rgb0);
    SetPixel(hdc, x+1, y,rgb1);
    SetPixel(hdc, x+2, y,rgb2);
    SetPixel(hdc, x+3, y,rgb3);
    SetPixel(hdc, x+4, y,rgb4);

done:
    ReleaseDC(NULL, hdc);
    SetCursor(hcur);

    pdva->CloseSurface(pdva->lpSurface);

    switch (uType)
    {
        case BM_8BIT:
            break;

        case BM_16555:
            ((LPDWORD)(lpbi+1))[0] = 0x007C00;
            ((LPDWORD)(lpbi+1))[1] = 0x0003E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24BGR:
        case BM_32BGR:
            ((LPDWORD)(lpbi+1))[0] = 0xFF0000;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0x0000FF;
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;
    }

    return uType != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\stretchc.c ===
/*
 * StretchC.C
 *
 * StretchBlt for DIBs
 *
 * C version of stretch.asm: StretchDIB optimised for AVI.
 *
 * NOTES
 *	- does not handle mirroring in x or y
 *	- does not handle pixel translation
 *	- will not work in place.
 *
 * AUTHOR
 *      C version by Geraint Davies
 */

#include <windows.h>
#include "drawdibi.h"
#include "stretch.h"

/* Outline:
 *
 * we select a y-stretching function depending on the ratio (eg 1:N or N:1).
 * it copies scanlines from source to destination, duplicating or omitting
 * scanlines as necessary to fit the destination. It copies each scanline
 * via the X_FUNC function we passed as an argument: this copies one scanline
 * duplicating or omitting pixels to fit the destination: we select an X_FUNC
 * depending on the bit-depth as well as the x-stretching ratio.
 *
 * both x and y stretching functions use the following basic model for deciding
 * when to insert/omit elements:
 *
 * 	delta = <larger extent> -1;
 *
 *      for (number of destination elements) {
 *
 *		copy one element
 *		advance pointer to larger region
 *		delta -= <smaller extent>
 *		if (delta < 0) {
 *			delta += <larger extent>;
 *			advance pointer to smaller region
 *		}
 *	}
 */


/* stretch proportions */
#define STRETCH_1_1	1
#define STRETCH_1_2	2
#define STRETCH_1_4	3
#define STRETCH_1_N	4
#define STRETCH_N_1	5
#define STRETCH_4_1	6
#define STRETCH_2_1	7



/*
 * an X_FUNC is a function that copies one scanline, stretching or shrinking it
 * to fit a destination scanline. Pick an X_FUNC depending on
 * bitdepth and stretch ratio (1:1, 1:2, 1:4, 1:N, N:1, 4:1, 2:1)
 *
 * the x_fract argument is the delta fraction: it is a representation
 * of the smaller extent (whichever that is) as a fraction of the larger,
 * and is used when stretching or shrinking to advance the pointer to the
 * smaller scanline every (fract) pixels of the larger.
 * Thus if we are expanding 1:8, x_fract will be 1/8, we will advance the
 * source pointer once every 8 pixels, and thus copy each source pixel to
 * 8 dest pixels. Note that if shrinking 8:1, x_fract will still be 1/8
 * and we will use it to control advancement of the dest pointer.
 * the fraction is multiplied by 65536.
 */
typedef void (*X_FUNC) (LPBYTE lpSrc,
			LPBYTE lpDst,
			int SrcXE,
			int DstXE,
			int x_fract);


void X_Stretch_1_1_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_4_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);


/*
 * Y_Stretch_* functions copy DstYE scanlines (using
 * an X_FUNC to copy each scanline) omitting or duplicating scanlines to
 * fit the destination extent. Pick a Y_ depending on the ratio
 * (1:N, N:1...)
 */

void Y_Stretch_1_N(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract,
		   X_FUNC x_func);

void Y_Stretch_N_1(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract,
		   X_FUNC x_func);

/*
 * special case y-stretch functions for 1:2 in both dimensions for 8 and 16 bits
 * takes no X_FUNC arg. Will do entire stretch.
 */
void Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract);


void Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract);

/* straight copy of one scanline of count bytes */
void X_CopyScanline(LPBYTE lpSrc, LPBYTE lpDst, int count);


/* -------------------------------------------------------------------- */

/*
 * StretchFactor
 *
 * calculate the stretch factor (proportion of source extent to destination
 * extent: 1:1, 1:2, 1:4, 1:N, N:1, 4:1,or 2:1) and also the
 * delta fraction (see above comment on X_FUNC). This is the ratio of
 * the smaller extent to the larger extent, represented as a fraction
 * multiplied by 65536.
 *
 * returns: the stretch factor  (stores the delta fraction in *pfract)
 */

int
StretchFactor(int SrcE, int DstE, int *pfract)
{


	if (SrcE == DstE) {
		if (pfract != NULL) {
			pfract = 0;	     	
		}

		return(STRETCH_1_1);

	}


	if (SrcE > DstE) {
		if (pfract != NULL) {
			*pfract = ( (DstE << 16) / SrcE) & 0xffff;
		}

		if (SrcE == (DstE * 2)) {
			return(STRETCH_2_1);
		} else if (SrcE == (DstE * 4)) {
			return(STRETCH_4_1);
		} else {
			return(STRETCH_N_1);
		}

	} else {

		/* calculate delta fraction based on smallest / largest */
		if (pfract != NULL) {
			*pfract = ( (SrcE << 16) / DstE) & 0xffff;
		}
	
		if (DstE == (SrcE * 2)) {
			return(STRETCH_1_2);
		} else if (DstE == (SrcE * 4)) {
			return(STRETCH_1_4);
		} else {
			return(STRETCH_1_N);
		}
	}
}


/* -------------------------------------------------------------------- */

/*
 * StretchDIB
 *
 */

void FAR PASCAL
StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	--> BITMAPINFO of destination
	LPVOID	lpvDst,		    //	--> to destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	--> BITMAPINFO of source
	LPVOID	lpvSrc,		    //	--> to source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE	 	    //	y extent of the BLT
	)
{

	int nBits;
	int SrcWidth, DstWidth;
	LPBYTE lpDst = lpvDst, lpSrc = lpvSrc;
	int x_fract;
	int x_factor;
	int y_factor;
	X_FUNC xfunc;
	

	/*
	 * check that bit depths are same and 8, 16 or 24
	 */

	if ((nBits = biDst->biBitCount) != biSrc->biBitCount) {
		return;
	}

	if ( (nBits != 8 ) && (nBits != 16) && (nBits != 24)) {
		return;
	}

	/*
	 * check that extents are not bad
	 */
	if ( (SrcXE <= 0) || (SrcYE <= 0) || (DstXE <= 0) || (DstYE <= 0)) {
		return;
	}

	/*
	 * calculate width of one scan line in bytes, rounded up to
	 * DWORD boundary.
	 */
	SrcWidth = (((biSrc->biWidth * nBits) + 31) & ~31) / 8;
	DstWidth = (((biDst->biWidth * nBits) + 31) & ~31) / 8;

	/*
	 * set initial source and dest pointers
	 */
	lpSrc += (SrcY * SrcWidth) + ((SrcX * nBits) / 8);
	lpDst += (DstY * DstWidth) + ((DstX * nBits) / 8);


	/*
	 * calculate stretch proportions (1:1, 1:2, 1:N, N:1 etc) and
	 * also the fractional stretch factor. (we are not interested in
	 * the y stretch fraction - this is only used in x stretching.
	 */

	y_factor = StretchFactor(SrcYE, DstYE, NULL);
	x_factor = StretchFactor(SrcXE, DstXE, &x_fract);

	/*
	 * we have special case routines for 1:2 in both dimensions
	 * for 8 and 16 bits
	 */
	if ((y_factor == x_factor) && (y_factor == STRETCH_1_2)) {

		if (nBits == 8) {
			//StartCounting();
			Stretch_1_2_8Bits(lpSrc, lpDst, SrcXE, SrcYE,
					  DstXE, DstYE, SrcWidth, DstWidth,
					  x_fract);
			//EndCounting("8 bit");
			return;

		} else if (nBits == 16) {
			//StartCounting();
			Stretch_1_2_16Bits(lpSrc, lpDst, SrcXE, SrcYE,
					  DstXE, DstYE, SrcWidth, DstWidth,
					  x_fract);
			//EndCounting("16 bit");
			return;
		}
	}


	/* pick an X stretch function */
	switch(nBits) {

	case 8:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_8Bits;
			break;

		case STRETCH_1_2:
			xfunc = X_Stretch_1_2_8Bits;
			break;

		case STRETCH_1_4:
			xfunc = X_Stretch_1_4_8Bits;
			break;

		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_8Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_8Bits;
			break;

		}
		break;

	case 16:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_16Bits;
			break;

		case STRETCH_1_2:
			xfunc = X_Stretch_1_2_16Bits;
			break;

		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_16Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_16Bits;
			break;

		}
		break;

	case 24:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_24Bits;
			break;

		case STRETCH_1_2:
		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_24Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_24Bits;
			break;

		}
		break;

	}


	/*
	 * now call appropriate stretching function depending
	 * on the y stretch factor
	 */
	switch (y_factor) {
	case STRETCH_1_1:
	case STRETCH_1_2:
	case STRETCH_1_4:
	case STRETCH_1_N:
		Y_Stretch_1_N(lpSrc, lpDst, SrcXE, SrcYE,
			      DstXE, DstYE, SrcWidth, DstWidth, x_fract, xfunc);
		break;

	case STRETCH_N_1:
	case STRETCH_4_1:
	case STRETCH_2_1:
		Y_Stretch_N_1(lpSrc, lpDst, SrcXE, SrcYE,
			      DstXE, DstYE, SrcWidth, DstWidth, x_fract, xfunc);
		break;

	}
	return;
}


/* ---- y stretching -------------------------------------------- */

/*
 * call an X_FUNC to copy scanlines from lpSrc to lpDst. Duplicate or
 * omit scanlines to stretch SrcYE to DstYE.
 */


/*
 * Y_Stretch_1_N
 *
 * write DstYE scanlines based on SrcYE scanlines, DstYE > SrcYE
 *
 */

void
Y_Stretch_1_N(LPBYTE lpSrc,
              LPBYTE lpDst,
              int SrcXE,
              int SrcYE,
              int DstXE,
              int DstYE,
	      int SrcWidth,
	      int DstWidth,
              int x_fract,
              X_FUNC x_func)
{

	int ydelta;
	int i;
	LPBYTE lpPrev = NULL;

	ydelta = DstYE -1;

	for (i = 0; i < DstYE; i++) {

		/* have we already stretched this scanline ? */
		if (lpPrev == NULL) {
			/* no - copy one scanline */
			(*x_func)(lpSrc, lpDst, SrcXE, DstXE, x_fract);
			lpPrev = lpDst;
		} else {	
			/* yes - this is a duplicate scanline. do
			 * a straight copy of one that has already
			 * been stretched/shrunk
			 */
			X_CopyScanline(lpPrev, lpDst, DstWidth);
		}

		/* advance dest pointer */
		lpDst += DstWidth;

		/* should we advance source pointer this time ? */
		if ( (ydelta -= SrcYE) < 0) {
			ydelta += DstYE;
			lpSrc += SrcWidth;
			lpPrev = NULL;
		}
	}
}


/*
 * Y_Stretch_N_1
 *
 * write DstYE scanlines based on SrcYE scanlines, DstYE < SrcYE
 *
 */
void
Y_Stretch_N_1(LPBYTE lpSrc,
              LPBYTE lpDst,
              int SrcXE,
              int SrcYE,
              int DstXE,
              int DstYE,
	      int SrcWidth,
	      int DstWidth,
              int x_fract,
              X_FUNC x_func)
{

	int ydelta;
	int i;

	ydelta = SrcYE -1;

	for (i = 0; i < DstYE; i++) {

		/* copy one scanline */
		(*x_func)(lpSrc, lpDst, SrcXE, DstXE, x_fract);

		/* advance dest pointer */
		lpDst += DstWidth;

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += SrcWidth;
			ydelta -= DstYE;
		} while (ydelta >= 0);

		ydelta += SrcYE;
	}
}

/* ---8-bit X stretching -------------------------------------------------- */

/*
 * X_Stretch_1_N_8Bits
 *
 * copy one scan line, stretching 1:N (DstXE > SrcXE). For 8-bit depth.
 */
void
X_Stretch_1_N_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one byte and advance dest */
		*lpDst++ = *lpSrc;

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc++;
		}
	}
}


/*
 * X_Stretch_N_1_8Bits
 *
 * copy one scan line, shrinking N:1 (DstXE < SrcXE). For 8-bit depth.
 */
void
X_Stretch_N_1_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one byte and advance dest */
		*lpDst++ = *lpSrc;

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc++;
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}
}

/*
 * copy one scanline of count bytes from lpSrc to lpDst. used by 1:1
 * scanline functions for all bit depths
 */
void
X_CopyScanline(LPBYTE lpSrc, LPBYTE lpDst, int count)
{
	int i;

	/*
	 * if the alignment of lpSrc and lpDst is the same, then
	 * we can get them aligned and do a faster copy
	 */
        if (((DWORD)(DWORD_PTR) lpSrc & 0x3) == ( (DWORD)(DWORD_PTR) lpDst & 0x3)) {
		
		/* align on WORD boundary */
		if ( (DWORD)(DWORD_PTR) lpSrc & 0x1) {
			*lpDst++ = *lpSrc++;
			count--;
		}

		/* align on DWORD boundary */
		if ((DWORD)(DWORD_PTR) lpSrc & 0x2) {
			* ((LPWORD) lpDst) = *((LPWORD) lpSrc);
			lpDst += sizeof(WORD);
			lpSrc += sizeof(WORD);
			count -= sizeof(WORD);
		}

		/* copy whole DWORDS */
		for ( i = (count / 4); i > 0; i--) {
			*((LPDWORD) lpDst) =  *((LPDWORD) lpSrc);
			lpSrc += sizeof(DWORD);
			lpDst += sizeof(DWORD);
		}
	} else {
		/* the lpSrc and lpDst pointers are different
		 * alignment, so leave them unaligned and
		 * copy all the whole DWORDs
		 */
                for (i = (count / 4); i> 0; i--) {
			*( (DWORD UNALIGNED FAR *) lpDst) =
				*((DWORD UNALIGNED FAR *) lpSrc);
			lpSrc += sizeof(DWORD);
			lpDst += sizeof(DWORD);
		}
	}

	/* in either case, copy last (up to 3) bytes. */
	for ( i = count % 4; i > 0; i--) {
		*lpDst++ = *lpSrc++;
	}
}
		
/*
 * X_Stretch_1_1_8Bits
 *
 * copy a scanline with no change (1:1)
 */
void
X_Stretch_1_1_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	X_CopyScanline(lpSrc, lpDst, DstXE);
}


/*
 * X_Stretch_1_2_8Bits
 *
 * copy a scanline, doubling all the pixels (1:2)
 */
void
X_Stretch_1_2_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
   	WORD wPix;
	int i;

	for (i = 0; i < SrcXE; i++) {
		
		/* get a pixel and double it */
		wPix = *lpSrc++;
		wPix |= (wPix << 8);
		* ((WORD UNALIGNED *) lpDst) = wPix;
		lpDst += sizeof(WORD);
	}
}


/*
 * X_Stretch_1_4_8Bits
 *
 * copy a scanline, quadrupling all the pixels (1:4)
 */
void
X_Stretch_1_4_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	DWORD dwPix;
	int i;

	for (i = 0; i < SrcXE; i++) {

		/* get a pixel and make four copies of it */
		dwPix = *lpSrc++;
		dwPix |= (dwPix <<8);
		dwPix |= (dwPix << 16);
		* ((DWORD UNALIGNED *) lpDst) = dwPix;
		lpDst += sizeof(DWORD);
	}
}


/*  -- 16-bit X functions -----------------------------------------------*/

/*
 * copy one scan-line of 16 bits with no change (1:1)
 */
void
X_Stretch_1_1_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	X_CopyScanline(lpSrc, lpDst, DstXE * sizeof(WORD));

}


/*
 * copy one scanline of 16 bpp duplicating each pixel
 */
void
X_Stretch_1_2_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

   	DWORD dwPix;
	int i;

	for (i = 0; i < SrcXE; i++) {
		
		/* get a pixel and double it */
		dwPix = * ((WORD *)lpSrc);
		dwPix |= (dwPix << 16);
		* ((DWORD UNALIGNED *) lpDst) = dwPix;

		lpDst += sizeof(DWORD);
		lpSrc += sizeof(WORD);
	}

}

/*
 * copy one scanline of 16 bits, stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one pixel and advance dest */
		*((WORD *) lpDst) = *((WORD *) lpSrc);

		lpDst += sizeof(WORD);

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc += sizeof(WORD);
		}
	}
}

/*
 * copy one scanline of 16bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one pixel and advance dest */
		*((WORD *) lpDst) = *((WORD *)lpSrc);

		lpDst += sizeof(WORD);

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += sizeof(WORD);
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}

}


/* 24-bits ---------------------------------------------------------*/

/*
 * copy one 24-bpp scanline as is (1:1)
 */
void
X_Stretch_1_1_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	X_CopyScanline(lpSrc, lpDst, DstXE * 3);
}

/*
 * copy one 24-bpp scanline stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {
		/* copy first word of pixel and advance dest */
		*((WORD UNALIGNED *) lpDst) = *((WORD UNALIGNED *) lpSrc);

		lpDst += sizeof(WORD);

		/* copy third byte and advance dest */
		*lpDst++ = lpSrc[sizeof(WORD)];

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc += 3;
		}
	}
}

/*
 * copy one scanline of 24 bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy first word of pixel and advance dest */
		*((WORD UNALIGNED *) lpDst) = *((WORD UNALIGNED *) lpSrc);

		lpDst += sizeof(WORD);

		/* copy third byte and advance dest */
		*lpDst++ = lpSrc[sizeof(WORD)];


		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += 3;
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}
}		

/* -- special-case 1:2 -------------------------------------------*/

/*
 * stretch 1:2 in both directions, for 8 bits.
 *
 * An experiment was done on x86 to only write every other line during
 * the stretch and when the whole frame was done to use memcpy to fill
 * in the gaps.  This is slower than doing the stretch in a single pass.
 */
void
Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract)
{

	int SrcInc, DstInc;
	int i, j;
	WORD wPix;
	DWORD dwPix4;

	/* amount to advance source by at the end of each scan */
	SrcInc = SrcWidth - SrcXE;


	/* amount to advance dest by at the end of each scan - note
	 * that we write two scans at once, so advance past the next
	 * scan line
	 */
	DstInc = (DstWidth * 2) - DstXE;

	/*
	 * we would like to copy the pixels DWORD at a time. this means
	 * being aligned. if we are currently aligned on a WORD boundary,
	 * then copy one pixel to get aligned. If we are on a byte
	 * boundary, we can never get aligned, so use the slower loop.
	 */
	if ( ((DWORD)(DWORD_PTR)lpDst) & 1) {

		/*
		 * dest is byte aligned - so we can never align it
		 * by writing WORDs - use slow loop.
		 */
		for (i = 0; i < SrcYE; i++) {
	
			for (j = 0; j < SrcXE; j++) {
	
				/* get a pixel and double it */
	
				wPix = *lpSrc++;
				wPix |= (wPix<<8);
	
	
				/* write doubled pixel to this scanline */
	
				*( (WORD UNALIGNED *) lpDst) = wPix;
	
				/* write double pixel to next scanline */
				*( (WORD UNALIGNED *) (lpDst + DstWidth)) = wPix;
	
				lpDst += sizeof(WORD);
			}
			lpSrc += SrcInc;
			lpDst += DstInc;
		}
		return;
	}

	/*
	 * this will be the aligned version. align each scan line
	 */
	for ( i = 0; i < SrcYE; i++) {

		/* count of pixels remaining */
		j = SrcXE;

		/* align this scan line */
		if (((DWORD)(DWORD_PTR)lpDst) & 2) {

			/* word aligned - copy one doubled pixel and we are ok */
			wPix = *lpSrc++;
			wPix |= (wPix << 8);
	
			*( (WORD *) lpDst) = wPix;
  			*( (WORD *) (lpDst + DstWidth)) = wPix;
			lpDst += sizeof(WORD);

			j -= 1;
		}


		/* now dest is aligned - so loop eating two pixels at a time
		 * until there is at most one left
		 */
               	for ( ; j > 1; j -= 2) {

			/* read two pixels and double them */
			wPix = * ((WORD UNALIGNED *) lpSrc);
			lpSrc += sizeof(WORD);

			dwPix4 = (wPix & 0xff) | ((wPix & 0xff) << 8);
			dwPix4 |= ((wPix & 0xff00) << 8) | ((wPix & 0xff00) << 16);
			*((DWORD *) lpDst) = dwPix4;
  			*((DWORD *) (lpDst + DstWidth)) = dwPix4;

			lpDst += sizeof(DWORD);
		}

		/* odd byte remaining ? */
		if (j > 0) {
			/* word aligned - copy one doubled pixel and we are ok */
			wPix = *lpSrc++;
			wPix |= (wPix << 8);
	
			*( (WORD *) lpDst) = wPix;
			*( (WORD *) (lpDst + DstWidth)) = wPix;
			lpDst += sizeof(WORD);

			j -= 1;
		}
		lpSrc += SrcInc;
		lpDst += DstInc;
	}
}



/* ----------------------------------------------------------------*/

/*
 * stretch 1:2 in both directions, for 16-bits
 */

void
Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract)

{
	int SrcInc, DstInc;
	int i, j;
	DWORD dwPix;

	/* amount to advance source by at the end of each scan */
	SrcInc = SrcWidth - (SrcXE * sizeof(WORD));


	/* amount to advance dest by at the end of each scan - note
	 * that we write two scans at once, so advance past the next
	 * scan line
	 */
	DstInc = (DstWidth * 2) - (DstXE * sizeof(WORD));

	for (i = 0; i < SrcYE; i++) {

		for (j = 0; j < SrcXE; j++) {

			/* get a pixel and double it */

			dwPix = *((WORD *)lpSrc);
			dwPix |= (dwPix<<16);

			lpSrc += sizeof(WORD);

			/* write doubled pixel to this scanline */

			*( (DWORD UNALIGNED *) lpDst) = dwPix;

			/* write double pixel to next scanline */
			*( (DWORD UNALIGNED *) (lpDst + DstWidth)) = dwPix;

			lpDst += sizeof(DWORD);
		}
	        lpSrc += SrcInc;
		lpDst += DstInc;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dvaclip.c ===
#define TestWF(hwnf, f) (GetWindowLong(hwnd, GWL_STYLE) & (f))

BOOL DVAIsClipped(HDC hdc, RECT& rc)
{
    RECT rcClip;

    if (GetClipBox(hdc, &rcClip) != SIMPLEREGION)
        return TRUE;

    if (rc.left   < rcClip.left  ||
        rc.top    < rcClip.top   ||
        rc.right  > rcClip.right ||
        rc.bottom > rcClip.bottom)

        return TRUE;

    return FALSE;
}

int DVAGetClipList(HWND hwnd, LPRECT prc, LPRECT RectList, int RectCount)
{
    RECT rc;
    HWND hwndP;
    HWND hwndT;

    if (RectCount == 0 || !IsVisible(hwnd))
        return 0;

    //
    // get the client area of the window
    //
    GetClientRect(hwnd, RectList);

    if (prcTest)
        IntersectRect(RectList, RectList, prc);

    ClientToScreen(hwnd, (LPPOINT)RectList);
    ClientToScreen(hwnd, (LPPOINT)RectList + 1);

    RectCount = 1;
    RectList[1] = RectList[0];

    //
    // walk all children of hwnd and remove them if needed
    //
    if (TestWF(hwnd WS_CLIPCHILDREN))
    {
        RectCount = ExcludeWindowRects(RectList, RectCount,
            GetWindow(hwnd, GW_CHILD), NULL);

        if (RectCount == 0)
            return 0;
    }

    //
    // walk all the siblings of hwnd and exclude them from the list.
    //
    for (; (hwndP = GetWindow(hwnd, GW_PARENT)) != NULL; hwnd = hwndP)
    {
        GetWindowRect(hwndP, &rc);
        RectCount = IntersectRectList(RectList, RectCount, &rc;

        if (RectCount == 0)
            return 0;

        if (TestWF(hwnd, WS_CLIPSIBLINGS))
        {
            RectCount = ExcludeWindowRects(RectList, RectCount,
                GetWindow(hwndP, GW_CHILD), hwnd);

            if (RectCount == 0)
                return 0;
        }
    }

    return RectCount;
}

int ExcludeWindowRects(LPRECT RectList, int RectCount, HWND hwndA, HWND hwndB)
{
    RECT rc;

    for (hwnd = hwndA; hwnd != NULL && hwnd != hwndB; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        if (!IsWindowVisible(hwnd))
	    continue;

	// Don't subtract off transparent windows...
	//
	if (TestWF(hwnd, WEFTRANSPARENT))
            continue;

        GetWindowRect(hwnd, &rc);

        RectCount = ExcludeRectList(RectList, RectCount, &rc);

        if (RectCount == 0)
            return 0;
    }

    return RectCount;
}


int ExcludeRectList(LPRECT RectList, int RectCount, LPRECT prc)
{
    int i;
    int n;
    RECT rc;

    if (RectCount == 0)
        return 0;

    SubtractRect(RectList, prc);

    for (i=1; i <= RectCount; i++)
    {
        if (!IntersectRect(&rc, &RectList[i], prc))
            continue;

        //
        //
        //

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dvaddi.h ===
//
// DVADDDI.H
//
// Copyright (c) 1993-1994 Microsoft Corporation
//
// DVA 1.0 Interface Definitions
//

#define DVAGETSURFACE       3074    // GDI Escape for DVA
#define DVA_VERSION         0x0100  // version number of DVA 1.0

//
// DVASURFACEINFO structure
//
typedef struct {                                               //
    BITMAPINFOHEADER BitmapInfo;                               // BITMAPINFO of surface
    DWORD            dwMask[3];                                // masks for BI_BITFIELDS
    DWORD            offSurface;                               // surface offset
    WORD             selSurface;                               // surface selector
    WORD             Version;                                  // DVA Version
    DWORD            Flags;                                    // Flags
    LPVOID           lpSurface;                                // driver use.
    BOOL (CALLBACK *OpenSurface) (LPVOID);                     // OpenSurface callback
    void (CALLBACK *CloseSurface)(LPVOID);                     // CloseSurface callback
    BOOL (CALLBACK *BeginAccess) (LPVOID,int,int,int,int);     // BeginAccess callback
    void (CALLBACK *EndAccess)   (LPVOID);                     // EndAccess callback
    UINT (CALLBACK *ShowSurface) (LPVOID,HWND,LPRECT,LPRECT);  // ShowSurface callback
} DVASURFACEINFO, FAR *LPDVASURFACEINFO;                       //

//
// Definitions for DVASURFACEINFO.dvaFlags
//
#define DVAF_1632_ACCESS    0x0001  // must access using 16:32 pointers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dvaddi.inc ===
;----------------------------------------------------------------------------
; DVADDDI.INC
;
; Copyright (c) 1993 Microsoft Corporation
;
; DVA 1.0 Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------

DVAGETSURFACE       equ     3074d   ; GDI Escape for DVA
DVA_VERSION         equ     0100h   ; version number of DVA 1.0

;----------------------------------------------------------------------------
; DVASURFACEINFO structure
;----------------------------------------------------------------------------
DVASURFACEINFO  struc
  dvaBitmapInfo     db  40 dup(?)       ; BITMAPINFO of surface
  dvaMasks          dd  3 dup(?)        ; masks for BI_BITFIELDS
  dvaOffSurface     dd  ?               ; surface offset
  dvaSelSurface     dw  ?               ; surface selector
  dvaVersion        dw  ?               ; DVA Version
  dvaFlags          dd  ?               ; Flags
  dvaSurface        dd  ?               ; driver use.
  dvaOpenSurface    dd  ?               ; OpenSurface callback
  dvaCloseSurface   dd  ?               ; CloseSurface callback
  dvaBeginAccess    dd  ?               ; BeginAccess callback
  dvaEndAccess      dd  ?               ; EndAccess callback
  dvaShowSurface    dd  ?               ; ShowSurface callback
DVASURFACEINFO  ends

;----------------------------------------------------------------------------
; Definitions for DVASURFACEINFO.dvaFlags
;----------------------------------------------------------------------------

DVAF_1632_ACCESS    equ     0001h   ; must access using 16:32 pointers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\lockbm.h ===
#define BM_NULL         0
#define BM_TYPE         0x0F        // type mask
#define BM_8BIT         0x01        // all SVGA, and other 256 color
#define BM_16555        0x02        // some HiDAC cards
#define BM_24BGR        0x03        // just like a DIB
#define BM_32BGR        0x04        // 32 bit BGR
#define BM_VGA          0x05        // VGA style bitmap.
#define BM_16565        0x06        // most HiDAC cards
#define BM_24RGB        0x07        // 24 bit RGB
#define BM_32RGB        0x08        // 32 bit RGB
#define BM_1BIT         0x09        // mono bitmap
#define BM_4BIT         0x0A        // 4 bit packed pixel.

#define BM_CANLOCK      0x10        // can lock these bitmaps
#define BM_MAPFLAT      0x20        // can make bitmaps flat
#define BM_HUGE         0x40        // with FillBytes != 0 (for > 64k)
#define BM_BOTTOMTOTOP  0x80        // like a DIB

//
//  this is a physical BITMAP in memory, this is just like a  BITMAP
//  structure, but with extra fields staring at bmWidthPlanes
//
typedef struct {
    short  bmType;
    short  bmWidth;
    short  bmHeight;
    short  bmWidthBytes;
    BYTE   bmPlanes;
    BYTE   bmBitsPixel;
    LPVOID bmBits;
    long   bmWidthPlanes;
    long   bmlpPDevice;
    short  bmSegmentIndex;
    short  bmScanSegment;
    short  bmFillBytes;
    short  reserved1;
    short  reserved2;
} IBITMAP;

#define bmBitmapInfo bmWidthPlanes
#define bmOffset     bmlpPDevice
#define bmNextScan   reserved1

BOOL   FAR CanLockBitmaps(void);
UINT   FAR GetBitmapType(void);
LPVOID FAR LockBitmap(HBITMAP hbm);
LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb);
LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb);
LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi);
LPVOID FAR GetPDevice(HDC hdc);
void   FAR TestSurfaceType(HDC hdc, int x, int y);
UINT   FAR GetSurfaceType(LPVOID lpBits);

BOOL   FAR MakeBitmapFlat(HBITMAP hbm);

//void   FAR BitmapXY(IBITMAP FAR *pbm, int x, int y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dvadib.c ===
/****************************************************************************

    DVA surface provider for Chicago DIBENG

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "dibeng.inc"
#include "lockbm.h"

#define RP_TYPE     0x5250  // 'RP'

// stuff in DVAVGA.C
extern HDC  hdcScreen;
extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK dib_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK dib_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK dib_begin_access(LPVOID pv, int x, int y, int AccessDX, int AccessDY)
{
    //
    //  on some SVGAs with 8514 like accelerators, a command Que may need to
    //  be flushed before touching video memory.
    //
    //  mini drivers should not need this "handholding" but the S3 driver
    //  does
    //
    if (hdcScreen)
        GetPixel(hdcScreen, x, y);

    _asm {
        push    ds
;       push    si
;       push    di

	lds	bx,pv

	xor	ax,ax
        test    [bx].deFlags,DISABLED
	jnz	exit

        mov     cx,x
        mov     dx,y
        mov     si,cx
        add     si,AccessDX
        mov     di,y
        add     di,AccessDY
	call	dword ptr [bx].deCursorExclude
	mov	ax,1
exit:
;       pop     di
;       pop     si
        pop     ds
    }
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL dib_end_access(LPVOID pv)
{
    _asm {
	push	ds
	lds	bx,pv
	call	dword ptr [bx].deCursorUnexclude
	pop	ds
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL dib_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DIBENGINE FAR *pde;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pde = (DIBENGINE FAR *)GetPDevice(hdc);

    if (pde == NULL ||
        pde->deType != RP_TYPE ||
        pde->dePlanes != 1 ||
        pde->deVersion != 0x0400)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    hmemcpy(lpbi, pde->deBitmapInfo, sizeof(BITMAPINFOHEADER));

    if (lpbi->biCompression != 0 &&
        lpbi->biCompression != BI_BITFIELDS)
	return FALSE;

    pdva->selSurface   = pde->deBitsSelector;
    pdva->offSurface   = pde->deBitsOffset;
    pdva->Flags        = 0;
    pdva->Version      = 0x0100;
    pdva->lpSurface    = (LPVOID)pde;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)dib_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)dib_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    if (!(pde->deFlags & CURSOREXCLUDE))
    {
        pdva->BeginAccess = NULL;
        pdva->EndAccess   = NULL;
    }

    if (pde->deDeltaScan > 0)
    {
        lpbi->biWidth  = (int)pde->deDeltaScan * 8 / (int)pde->deBitsPixel;
        lpbi->biHeight =-(int)pde->deHeight;
        lpbi->biSizeImage = pde->deDeltaScan * pde->deHeight;
    }
    else
    {
        lpbi->biWidth  = -(int)pde->deDeltaScan * 8 / (int)pde->deBitsPixel;
        lpbi->biHeight =  (int)pde->deHeight;
        lpbi->biSizeImage = -(int)pde->deDeltaScan * pde->deHeight;

	pdva->offSurface += (long)pde->deDeltaScan * (long)pde->deHeight-1;
    }

    //
    // mark the surface as 16:32 pointer access ONLY!
    //
    if (pde->deFlags & BANKEDVRAM)
	pdva->Flags |= DVAF_1632_ACCESS;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\vflat.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  VFLAT.ASM
;
;   module for doing direct video access under windows.
;
;   we will talk to VflatD to get the linear address of the video buffer.
;
;   we MUST not use these API in the background, how do we do this?
;
;   we support the following modes: (same as SVGA256...)
;
;        VRAM II 640x480x8bpp
;        VRAM II 720x512x8bpp
;        VRAM II 800x600x8bpp
;        VRAM II 1024x768x8bpp
;
;        V7 VGA 640x480x8bpp
;        V7 VGA 720x512x8bpp
;        V7 VGA 800x600x8bpp
;        V7 VGA 1024x768x8bpp
;
;        WD VGA 640x480x8bpp
;        WD VGA 800x600x8bpp
;        WD VGA 1024x768x8bpp
;        WD VGA 640x480x16bpp
;        WD VGA 800x600x16bpp
;
;        Trident 640x480x8bpp
;        Trident 800x600x8bpp
;        Trident 1024x768x8bpp
;
;        Oak 640x480x8bpp
;        Oak 800x600x8bpp
;        Oak 1024x768x8bpp
;
;        ATI 640x480x8bpp
;        ATI 800x600x8bpp
;        ATI 1024x768x8bpp
;        ATI 640x480x24bpp
;
;        Compaq AVGA 640x480x8bpp
;
;        Compaq QVision 640x480x8bpp
;        Compaq QVision 800x600x8bpp
;        Compaq QVision 1024x768x8bpp
;
;        Compaq QVision 640x480x16bpp
;        Compaq QVision 800x600x16bpp
;        Compaq QVision 1024x768x16bpp
;
;        Tseng ET4000 640x480x8bpp
;        Tseng ET4000 800x600x8bpp
;        Tseng ET4000 1024x768x8bpp
;        Tseng ET4000 640x480x16bpp
;        Tseng ET4000 800x600x16bpp
;
;        Everex 640x480x8bpp
;        Everex 800x600x8bpp
;        Everex 1024x768x8bpp
;
;        Cirrus 542x 640x480x8bpp
;        Cirrus 542x 800x600x8bpp
;        Cirrus 542x 1024x768x8bpp
;
;        Cirrus 6420 640x480x8bpp
;        Cirrus 6420 800x600x8bpp
;        Cirrus 6420 1024x768x8bpp
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1994 Microsoft Corporation
;
; Public Functions:
;
;       VFlatInit()
;
; Public Data:
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
.386
	.xlist
	include cmacros.inc
        include windows.inc
        WIN31=1
        include VflatD.inc
        .list

        externFP        GetDC
        externFP        ReleaseDC
        externFP        GetDeviceCaps
        externFP        OutputDebugString
        externFP        WriteProfileString

        externA         __C000h
        externA         __A000h

sBegin  Data

        ScreenMode  dw      0                   ; current mode (index)
        VflatD_Proc dd      0                   ; VflatD entry point

        bank_save           dw      0           ; saved bank...

sEnd    Data

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifdef DEBUG
DPF     macro   text
        local   string, string_end
        jmp short string_end
string label byte
        db      "&text&",13,10,0
string_end label byte
        pusha
        push    es
        push    cs
        push    offset string
        call    OutputDebugString
        pop     es
        popa
        endm
else
DPF     macro text
        endm
endif

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        .386p
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifdef DEBUG
szDebug     db "Debug", 0
szDrawDib   db "DrawDib", 0
szDetect    db "detect", 0
szDetectDVA db "DetectDVA: ", 0
szNone      db "None", 0
endif

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ModeInfo STRUC

    ModeNext            dw      ?
    ModeDetect          dw      ?
    ModeNum             dw      ?
    ModeWidth           dw      ?
    ModeHeight          dw      ?
    ModeDepth           dw      ?
    ModeSetBank         dw      ?
    ModeGetBank         dw      ?
    ModeSetBank32       dw      ?
    ModeSetBank32Size   dw      ?
    ModeName            db      ?

ModeInfo ENDS

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

Mode macro y, n, w, h, b, x, name
        local   l1,l2
l1:
        dw      l2 - l1
        dw      Detect&y, n, w, h, b, SetBank&x, GetBank&x, SetBank32&x, SetBank32&x&Size

ifdef DEBUG
        db      name
        db      0
endif

l2:
        endm

ModeInfoTable label byte

        Mode VRAM, 67h, 640, 480, 8, VRAM, "VRAM II 640x480x8bpp"
        Mode VRAM, 68h, 720, 512, 8, VRAM, "VRAM II 720x512x8bpp"
        Mode VRAM, 69h, 800, 600, 8, VRAM, "VRAM II 800x600x8bpp"
        Mode VRAM, 6Ah, 1024,768, 8, VRAM, "VRAM II 1024x768x8bpp"

        Mode V7,   67h, 640, 480, 8, V7, "V7 VGA 640x480x8bpp"
        Mode V7,   68h, 720, 512, 8, V7, "V7 VGA 720x512x8bpp"
        Mode V7,   69h, 800, 600, 8, V7, "V7 VGA 800x600x8bpp"
        Mode V7,   6Ah, 1024,768, 8, V7, "V7 VGA 1024x768x8bpp"

        Mode WD,   5Fh, 640, 480, 8, WD, "WD VGA 640x480x8bpp"
        Mode WD,   5Ch, 800, 600, 8, WD, "WD VGA 800x600x8bpp"
        Mode WD,   60h, 1024,768, 8, WD, "WD VGA 1024x768x8bpp"
        Mode WD,   64h, 640, 480,16, WD, "WD VGA 640x480x16bpp"
        Mode WD,   65h, 800, 600,16, WD, "WD VGA 800x600x16bpp"

        Mode Trident, 5Dh, 640, 480, 8, Trident, "Trident 640x480x8bpp"
        Mode Trident, 5Eh, 800, 600, 8, Trident, "Trident 800x600x8bpp"
        Mode Trident, 62h, 1024,768, 8, Trident, "Trident 1024x768x8bpp"

        Mode Oak,  53h, 640, 480, 8, Oak, "Oak 640x480x8bpp"
        Mode Oak,  54h, 800, 600, 8, Oak, "Oak 800x600x8bpp"
        Mode Oak,  59h, 1024,768, 8, Oak, "Oak 1024x768x8bpp"

        Mode ATI,  12h, 640, 480, 8, ATI, "ATI 640x480x8bpp"
        Mode ATI,  12h, 800, 600, 8, ATI, "ATI 800x600x8bpp"
        Mode ATI,  12h, 1024,768, 8, ATI, "ATI 1024x768x8bpp"
        Mode ATI,  12h, 2048,1024,8, ATI, "ATI 2048x1024x8bpp"

        Mode ATI,  12h, 640, 480,16, ATI, "ATI 640x480x16bpp"
        Mode ATI,  12h, 800, 600,16, ATI, "ATI 800x600x16bpp"
        Mode ATI,  12h, 1024,768,16, ATI, "ATI 1024x768x16bpp"
        Mode ATI,  12h, 2048,1024,16,ATI, "ATI 2048x1024x16bpp"

        Mode ATI,  12h, 640, 480,24, ATI, "ATI 640x480x24bpp"
        Mode ATI,  12h, 800, 600,24, ATI, "ATI 800x600x24bpp"
        Mode ATI,  12h, 1024,768,24, ATI, "ATI 1024x768x24bpp"
        Mode ATI,  12h, 2048,1024,24,ATI, "ATI 2048x1024x24bpp"

        Mode ATI,  62h, 640, 480, 8, ATI, "ATI 640x480x8bpp"
        Mode ATI,  63h, 800, 600, 8, ATI, "ATI 800x600x8bpp"
        Mode ATI,  64h, 1024,768, 8, ATI, "ATI 1024x768x8bpp"
        Mode ATI,  75h, 640, 480,24, ATI, "ATI 640x480x24bpp"

        Mode Compaq,2Eh, 640, 480, 8, Compaq, "Compaq AVGA 640x480x8bpp"
        Mode Compaq,12h, 640, 480, 8, Compaq, "Compaq AVGA 640x480x8bpp"

        Mode Compaq,06h, 640, 480, 8, Compaq, "Compaq QVision 640x480x8bpp"
        Mode Compaq,06h, 800, 600, 8, Compaq, "Compaq QVision 800x600x8bpp"
        Mode Compaq,06h, 1024,768, 8, Compaq, "Compaq QVision 1024x768x8bpp"

        Mode Compaq,06h, 640, 480, 16, Compaq, "Compaq QVision 640x480x16bpp"
        Mode Compaq,06h, 800, 600, 16, Compaq, "Compaq QVision 800x600x16bpp"
        Mode Compaq,06h, 1024,768, 16, Compaq, "Compaq QVision 1024x768x16bpp"

        Mode Tseng, 2Eh, 640, 480, 8, Tseng, "Tseng ET4000 640x480x8bpp"
        Mode Tseng, 30h, 800, 600, 8, Tseng, "Tseng ET4000 800x600x8bpp"
        Mode Tseng, 38h, 1024,768, 8, Tseng, "Tseng ET4000 1024x768x8bpp"
        Mode Tseng, 2Eh, 640, 480,16, Tseng, "Tseng ET4000 640x480x16bpp"
        Mode Tseng, 30h, 800, 600,16, Tseng, "Tseng ET4000 800x600x16bpp"

        Mode Everex, 2Eh, 640, 480, 8, Tseng, "Everex 640x480x8bpp"
        Mode Everex, 30h, 800, 600, 8, Tseng, "Everex 800x600x8bpp"
        Mode Everex, 38h, 1024,768, 8, Tseng, "Everex 1024x768x8bpp"

; Until we get a detect routine for Cirrus, we won't include these.

        ;Mode C542x, 5Fh, 640, 480, 8, C542x, "C542x 640x480x8bpp"
        ;Mode C542x, 5Ch, 800, 600, 8, C542x, "C542x 800x600x8bpp"
        ;Mode C542x, 60h, 1024,768, 8, C542x, "C542x 1024x768x8bpp"

        ;Mode C6420, 2Eh, 640, 480, 8, C6420, "C6420 640x480x8bpp"
        ;Mode C6420, 30h, 800, 600, 8, C6420, "C6420 800x600x8bpp"
        ;Mode C6420, 38h, 1024,768, 8, C6420, "C6420 1024x768x8bpp"

ModeInfoTableEnd label byte

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;

szTseng:    db  "Tseng", 0
szOAK:      db  " OAK", 0
szTrident:  db  "TRIDENT", 0
szEverex:   db  "Everex", 0
szParadise: db  "PARADISE", 0
szWD:       db  "WESTERN DIGITAL", 0
szWeitek:   db  "WEITEK",0
szViper:    db  "VIPER VLB",0

;---------------------------Public-Routine------------------------------;
; VFlatInit
;
;       initialize for a banked display
;
; Returns:
;       C       if error
;       NC      if success
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatInit, <NEAR, PASCAL, PUBLIC>, <si,di,ds>
        localW  hdc
        localW  ScreenWidth
        localW  ScreenHeight
        localW  ScreenDepth
        localW  BiosMode
cBegin

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   get a display DC and get resolution info
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
        cCall   GetDC, <0>
        mov     hdc,ax

        cCall   GetDeviceCaps, <hdc,HORZRES>
        mov     ScreenWidth,ax

        cCall   GetDeviceCaps, <hdc,VERTRES>
        mov     ScreenHeight,ax

        cCall   GetDeviceCaps, <hdc,BITSPIXEL>
        push    ax
        cCall   GetDeviceCaps, <hdc,PLANES>
        pop     dx
        mul     dx
        mov     ScreenDepth,ax

        cCall   ReleaseDC, <0, hdc>

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   scan our mode table
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        mov     ax, 6F04h               ;Get V7 mode
        int     10h
        cmp     al,04h
        jne     short @f
	mov	ax,0F00h		;Call BIOS to get mode back.
	int	10h			;al = mode we are in.
@@:     xor     ah,ah
        mov     BiosMode,ax

        lea     bx,ModeInfoTable

mode_search:
        mov     ax,BiosMode
        cmp     cs:[bx].ModeNum,ax
        jne     short mode_search_next

        mov     ax,ScreenWidth
        cmp     cs:[bx].ModeWidth,ax
        jne     short mode_search_next

        mov     ax,ScreenHeight
        cmp     cs:[bx].ModeHeight,ax
        jne     short mode_search_next

        mov     ax,ScreenDepth
        cmp     cs:[bx].ModeDepth,ax
        jne     short mode_search_next

        push    bx
        call    cs:[bx].ModeDetect
        pop     bx
        or      ax,ax
        jnz     short mode_search_found
        errn$   mode_search_next

mode_search_next:
        add     bx,cs:[bx].ModeNext
        cmp     bx,offset ModeInfoTableEnd
        jl      mode_search
        jge     mode_search_fail

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_found:
        mov     ScreenMode,bx               ; save this for later.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   this is a banked display, we need to talk to VflatD in order for
;   anything to work.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
	xor	di,di
	mov	es,di
	mov	ax,1684h
        mov     bx,VflatD_Windows_ID
	int	2fh			    ;returns with es:di-->VFlatD Entry point
        mov     word ptr [VflatD_Proc][0],di
        mov     word ptr [VflatD_Proc][2],es
	mov	ax,es
        or      ax,di
        jne     short mode_search_vflat

	xor	di,di
	mov	es,di
	mov	ax,1684h
        mov     bx,VflatD_Chicago_ID
	int	2fh			    ;returns with es:di-->VFlatD Entry point
        mov     word ptr [VflatD_Proc][0],di
        mov     word ptr [VflatD_Proc][2],es
	mov	ax,es
        or      ax,di
        jz      short mode_search_fail

mode_search_vflat:
	xor	ax,ax
	mov	dx,VflatD_Get_Version
	call	[VflatD_Proc]
	cmp	ax,VflatD_Version
        jb      short mode_search_fail

        ;
        ;   estimate the required framebuffer memory
        ;
        mov     ax,ScreenDepth              ; bitdepth
        mul     ScreenWidth                 ; * width = bit width
        shr     ax,3                        ; / 8 = width bytes
        add     ax,1024-1                   ; round up to nearest K
        and     ax,not (1024-1)             ; now we have scan width
        mul     ScreenHeight                ; * number of scans = total bytes
        add     ax,0FFFFh                   ; round up to nearest MB
        adc     dx,0000Fh
        and     dx,0FFF0h
        shl     dx,4                        ; convert to 4K pages.
        mov     ax,dx

        mov     dx,VflatD_Get_Sel           ; get selector
;;;;;;;;mov     ax,512                      ; size in pages of video memory?
	mov	bx,ScreenMode
        mov     cx,cs:[bx].ModeSetBank32Size; size of bank code.
        mov     di,cs:[bx].ModeSetBank32    ; point es:di to bank code.
	push	cs
	pop	es
        call    [VflatD_Proc]               ; let VflatD init things.
        jc      short mode_search_fail
        or      ax,ax
        jz      short mode_search_fail

        errn$   mode_search_ok

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_ok:

ifdef DEBUG
        pusha
        mov     bx,ScreenMode
        lea     ax,[bx].ModeName
        lea     bx,szDrawDib
        lea     cx,szDetect

        cCall   WriteProfileString, <cs,bx, cs,cx, cs,ax>
        popa
endif
        mov     dx, ax
        xor     ax, ax
        jmp     short mode_search_exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_fail:
ifdef DEBUG
        pusha
        lea     ax,szDrawDib
        lea     bx,szDetect
        lea     cx,szNone
        cCall   WriteProfileString, <cs,ax, cs,bx, cs,cx>
        popa
endif
        xor     ax,ax
        mov     dx,ax
        mov     ScreenMode,ax
        mov     word ptr [VflatD_Proc][0],ax
        mov     word ptr [VflatD_Proc][2],ax
        errn$   mode_search_exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_exit:

cEnd

;---------------------------Public-Routine------------------------------;
; VFlatBegin - start direct frame buffer access
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatBegin, <NEAR, PUBLIC>, <>
cBegin
        mov     bx, ScreenMode
        or      bx, bx
        jz      short BeginExit

%out is CLI/STI needed?
;;;;;;;;cli
        call    cs:[bx].ModeGetBank
        xchg    bank_save,ax
        mov     dx,ax
        call    cs:[bx].ModeSetBank
;;;;;;;;sti
BeginExit:
cEnd

;---------------------------Public-Routine------------------------------;
; VFlatEnd - end direct frame buffer access
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatEnd, <NEAR, PUBLIC>, <>
cBegin
        mov     bx, ScreenMode
        or      bx, bx
        jz      short EndExit

%out is CLI/STI needed?
;;;;;;;;cli
        call    cs:[bx].ModeGetBank
        xchg    bank_save,ax
        mov     dx,ax
        call    cs:[bx].ModeSetBank
;;;;;;;;sti
EndExit:
cEnd

;---------------------------Public-Routine------------------------------;
; ScanROM   - scan the video bios ROM looking for a string
;
; Entry:
;       cs:ax   - string to look for.
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

ScanROM proc near
        push    si
        mov     si,ax

        mov     ax,__C000h
        mov     es,ax

        xor     bx,bx               ; start at zero
        mov     cx,512              ; search first 512 bytes.

        mov     dx,si
scan_start:
        mov     si,dx
        mov     al,cs:[si]
scan_cmp:
        cmp     byte ptr es:[bx], al
        je      short scan_found
        inc     bx
        loop    scan_start
        xor     ax,ax
        pop     si
        ret

scan_next:
        inc     bx
        loop    scan_cmp
        xor     ax,ax
        pop     si
        ret

scan_found:
        inc     si
        mov     al,cs:[si]
        or      al,al
        jnz     scan_next
        inc     ax
        pop     si
        ret

ScanROM  endp

;----------------------------------------------------------------------------
; BANK SWITCH TEMPLATES
;  Each template is given to vflatd.386 which copies it inline in to the 
;  page fault handling code.
; NOTE: This code runs at ring 0 in a USE32 code segment, so be carefull!!!
; ALL REGISTERS MUST BE PRESERVED (except for dx)
;----------------------------------------------------------------------------

;****************************************************************************
; V7
;****************************************************************************

DetectV7 proc near

        mov     ax,6f00h                ;Test for Video 7
	xor	bx,bx
	cld
        int     10h
        xor     ax,ax
        cmp     bx,'V7'
        jne     short @f
        inc     ax
@@:     ret

DetectV7 endp

SetBank32V7 label byte
	push	ax
	push	bx

        mov     bl,al
        and     bl,1                    ; BL = extended page select

        mov     ah,al
        and     ah,2
        shl     ah,4                    ; AH = page select bit

        and     al,00ch
        mov     bh,al
        shr     al,2
        or      bh,al                   ; BH = 256K bank select

        db      66h,0bah,0cch,03h       ;mov dx, 3CCh
        in      al,dx                   ; Get Miscellaneous Output Register
        and     al,not 20h              ; Clear page select bit
        or      al,ah                   ; Set page select bit (maybe)
        mov     dl,0c2h                 ; Write Miscellaneous Output Register
        out     dx,al

        mov     dl,0c4h                 ; Sequencer
        mov     al,0f9h                 ; Extended page select register
        mov     ah,bl                   ; Extended page select value
        out     dx,eax			; out dx,ax

        mov     al,0f6h                 ; 256K bank select
        out     dx,al
        inc     dx                      ; Point to data
        in      al,dx
        and     al,0f0h                 ; Clear out bank select banks
        or      al,bh                   ; Set bank select banks (maybe)
        out     dx,al
	pop	bx
        pop     ax
SetBank32V7Size = $ - SetBank32V7

SetBankV7 proc near
        mov     bl,dl
        and     bl,1                    ; BL = extended page select

        mov     ah,dl
        and     ah,2
        shl     ah,4                    ; AH = page select bit

        and     dl,00ch
        mov     bh,dl
        shr     dl,2
        or      bh,dl                   ; BH = 256K bank select

        mov     dx,03cch
        in      al,dx                   ; Get Miscellaneous Output Register
        and     al,not 20h              ; Clear page select bit
        or      al,ah                   ; Set page select bit (maybe)
        mov     dl,0c2h                 ; Write Miscellaneous Output Register
        out     dx,al

        mov     dl,0c4h                 ; Sequencer
        mov     al,0f9h                 ; Extended page select register
        mov     ah,bl                   ; Extended page select value
        out     dx,ax

        mov     al,0f6h                 ; 256K bank select
        out     dx,al
        inc     dx                      ; Point to data
        in      al,dx
        and     al,0f0h                 ; Clear out bank select banks
        or      al,bh                   ; Set bank select banks (maybe)
        out     dx,al
	ret
SetBankV7 endp

GetBankV7      proc    near
	mov	dx,3cch
        in      al,dx
        and     al,20h                  ; page select bit
        shr     al,4
        mov     ah,al

	mov	dx,3C4h
	mov	al,0f9h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,1
        or      ah,al

	dec	dx
	mov	al,0F6h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,0ch
        or      al,ah
        xor     ah,ah
	ret
GetBankV7      endp

;****************************************************************************
; V7 II
;****************************************************************************

DetectVRAM proc near
if 0    ; ack!
        call    DetectV7
        or      ax,ax
        jz      short novram

	mov	dx,03C4H
	mov	al,08FH
	out	dx,al
	inc	dx
	in	al,dx
	mov	ah,al

	dec	dx
	mov	al,08EH
	out	dx,al
	inc	dx
	in	al,dx

        cmp     ax,07151H               ;VRAMII rev B id
        je      short isvram
        cmp     ax,07152H               ;VRAMII rev C and D id
        je      short isvram
;       cmp     ax,07760H               ;HT216 rev B and C
;       je      short isvram
;       cmp     ax,07763H               ;HT216 rev B, C, and D
;       je      short isvram
;       cmp     ax,07764H               ;HT216 rev E
;       je      short isvram
endif
novram:
        xor     ax,ax
        ret
isvram:
        mov     ax,1
        ret

DetectVRAM endp

SetBank32VRAM label byte
        push    ax                      ;push eax
        shl     dl,4
        mov     ah,dl
        db      66h,0bah,0c4h,03h       ; mov dx, 3C4h
	mov	al,0e8h
        out     dx,eax			; out dx,ax
        pop     ax                      ; pop eax
SetBank32VRAMSize = $ - SetBank32VRAM

SetBankVRAM proc near
        shl     dl,4
        mov     ah,dl
	mov	dx,03c4h
	mov	al,0e8h
        out     dx,ax
        ret
SetBankVRAM endp

GetBankVRAM proc near
        mov     dx,3c4h
        mov     al,0e8h
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,4
        ret
GetBankVRAM endp

;****************************************************************************
; ATI
;****************************************************************************

public DetectATI
DetectATI proc near
        mov     ax,__C000h              ;ATI VGA detect (largely from ATI example code)
        mov     es,ax
        xor     ax,ax
	cmp	word ptr es:[40h],'13'	;ATI Signiture on the Video BIOS
        jne     short @f
        inc     ax
@@:     ret
DetectATI endp

SetBank32ATI label byte
	push	ax
	mov	ah,al
	shl	ah,1
	mov	al,0B2h
        db      66h,0bah,0ceh,01h       ;mov dx, 1CEh
	out	dx,eax
	pop	ax
SetBank32ATISize = $ - SetBank32ATI

SetBankATI proc near
	mov	ah,dl
	shl	ah,1
	mov	al,0b2h		;Page select register index
	mov	dx,1ceh		;
	out	dx,ax		;
	ret
SetBankATI endp

GetBankATI     proc    near
	mov	dx,1ceh
	mov	al,0b2h
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,1
	ret
GetBankATI     endp

;****************************************************************************
; OAK
;****************************************************************************

DetectOAK   proc    near

        lea     ax,szOAK
        jmp     ScanROM

DetectOAK   endp

SetBank32Oak label byte
	push	ax
	mov	ah,al
	shl	al,4
	or	ah,al
        db      66h,0bah,0deh,03h       ;mov dx, 3DEh
	mov	al,11h
	out	dx,eax
	pop	ax
SetBank32OakSize = $ - SetBank32Oak

SetBankOAK proc near
	mov	al,dl
	mov	ah,al
	shl	al,4
	or	ah,al
	mov	dx,3deh
	mov	al,11h
	out	dx,ax
	ret
SetBankOAK endp

GetBankOAK     proc    near
	mov	dx,3deh
	mov	al,11h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,0Fh
	ret
GetBankOAK        endp

;****************************************************************************
; Everex
;****************************************************************************

DetectEverex  proc    near

        lea     ax,szEverex
        jmp     ScanROM

DetectEverex    endp

;****************************************************************************
; Tseng
;****************************************************************************

DetectTseng  proc    near

        lea     ax,szTseng
        jmp     ScanROM

DetectTseng   endp

SetBank32Tseng label byte
	mov	dx, ax                  ;mov edx,eax
	shl	al, 4
	or	al, dl
        db      66h,0bah,0cdh,03h       ;mov dx, 3CDh
	out	dx, al                              
	shr	al, 4                   ;shr al,4
SetBank32TsengSize = $ - SetBank32Tseng

SetBankTseng proc near
        and     al,0fh
	mov	al,dl
	mov	ah,al
	shl	al,4
	or	al,ah
	mov	dx,3cdh
	out	dx,al
	ret
SetBankTseng endp

GetBankTseng proc near
	mov	dx,3cdh
        in      al,dx
	shr	al, 4                   ;shr al,4
	ret
GetBankTseng endp

;****************************************************************************
; WD
;****************************************************************************

DetectWD  proc    near

        lea     ax,szWD
        call    ScanROM
        or      ax,ax
        jz      short @f
        ret

@@:     lea     ax,szParadise
        jmp     ScanROM

DetectWD endp

SetBank32WD label byte
        push    ax
	mov	ah,al			;ah = bank number
        mov     al,9                    ;select the primary "bank adder" reg
        shl     ah,4
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax                  ;out dx,ax (write 3cf:09, desired bank)
        pop     ax
SetBank32WDSize = $ - SetBank32WD

SetBankWD proc near
        mov     al,9                    ;select the primary "bank adder" reg
        mov     ah,dl
        shl     ah,4
        mov     dx,3ceh
        out     dx,ax                   ;write 3cf:09, desired bank
        ret
SetBankWD endp

GetBankWD      proc near
	mov	dx,3ceh
        mov     al,9
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,4
	ret
GetBankWD      endp

;****************************************************************************
; Weitek
;****************************************************************************

DetectWeitek  proc    near

        lea     ax,szWeitek
        jmp     ScanROM

DetectWeitek   endp

;****************************************************************************
; Trident
;****************************************************************************

DetectTrident proc    near

        lea     ax,szTrident
        jmp     ScanROM

DetectTrident endp

SetBank32Trident label byte
	push	ax
	mov	ah,al
	xor	ah,2
	mov	al,0EH
        db      66h,0bah,0c4h,03h       ;mov dx, 3C4h
	out	dx,eax			
;;      db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
;;	out	dx,eax			;for 8900c or better only.
	pop	ax
SetBank32TridentSize = $ - SetBank32Trident

SetBankTrident proc near
	mov	ah,dl
	xor	ah,2
	mov	al,0EH
	mov	dx,3c4h
	out	dx,ax
;;	mov	dx,3ceh
;;	out	dx,ax			;for 8900c or better only.
	ret
SetBankTrident endp

GetBankTrident proc near
	mov	dx,3c4h
	mov	al,0eh
	out	dx,al
	inc	dx
	in	al,dx
        xor     al,2
	ret
GetBankTrident endp

;****************************************************************************
; Compaq
;****************************************************************************

DetectCompaq proc near
        mov     ax,__C000h
        mov     es,ax
        xor     ax,ax
        cmp     word ptr es:[2],0E930h
        jne     short @f
        inc     ax
@@:     ret
DetectCompaq endp

SetBank32Compaq label byte
        push    ax
        mov     ah,al
        shl     ah,4
        mov     al,45h
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax
        inc     al
        add     ah,08h
        out     dx,eax
	pop	ax
SetBank32CompaqSize = $ - SetBank32Compaq

SetBankCompaq proc near
        mov     ah,dl
        shl     ah,4
        mov     dx,03CEh
        mov     al,45h
        out     dx,ax
        inc     al
        add     ah,08h
        out     dx,ax
	ret
SetBankCompaq endp

GetBankCompaq proc near
        mov     dx,03CEh
        mov     al,45h
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret
GetBankCompaq endp

;****************************************************************************
; Cirrus 6420
;****************************************************************************

DetectC6420 proc near
        %out *** need a Detect function for Cirrus 6420
        mov     ax,1        ;!!!
        ret
DetectC6420 endp

SetBank32C6420 label byte
        push    ax
        mov     ah,al
	shl	ah,4
        mov     al,0eh
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax                  ;
        pop     ax

SetBank32C6420Size = $ - SetBank32C6420

SetBankC6420    proc near
        mov     ah,dl
	shl	ah,4
        mov     al,0eh
        mov     dx, 3CEh
        out     dx,ax
        ret

SetBankC6420    endp

GetBankC6420    proc near
        mov     dx,03CEh
        mov     al,0Eh
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret

GetBankC6420    endp

;****************************************************************************
; Cirrus 542x
;****************************************************************************

DetectC542x proc near
        %out *** need a Detect function for Cirrus 542x
        mov     ax,1        ;!!!
        ret
DetectC542x endp

SetBank32C542x label byte
        push    ax
        mov     ah,al
	shl	ah,4
        mov     al,09h
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax
        pop     ax

SetBank32C542xSize = $ - SetBank32C542x

SetBankC542x    proc near
        mov     ah,dl
	shl	ah,4
        mov     al,09h
        mov     dx,3CEh
        out     dx,ax
        ret

SetBankC542x    endp

GetBankC542x    proc near
        mov     dx,03CEh
        mov     al,09h
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret

GetBankC542x    endp

;****************************************************************************
; Viper Vesa Local bus
;****************************************************************************

public DetectViper
DetectViper proc near
        lea     ax,szViper
        jmp     ScanROM
DetectViper endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\test\fill.asm ===
.xlist
        include cmacros.inc
        .list

sBegin  Code
        .386
        assumes cs,Code
        assumes ds,nothing
        assumes es,nothing

;--------------------------Private-Routine-------------------------------;
; rect
;
; draws a solid rect
;
; Entry:
;       lpBits          bits pointer
;       width_bytes     width in bytes to next scan
;       lpPoints        points to draw.
; Return:
;       none
; Error Returns:
;       none
; Registers Preserved:
;       none
; Registers Destroyed:
;       AX,BX,CX,DX,DS,ES,SI,DI,FLAGS
; Calls:
;       non
; History:
;       Mon 26-Mar-1990 -by-  Todd Laney [ToddLa]
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DIBRect,<FAR,PUBLIC>,<ds>
        parmD   lpBits
        parmD   WidthBytes
        parmW   RectX
        parmW   RectY
        parmW   RectDX
        parmW   RectDY
        parmW   color
cBegin
        push    edi

        xor     edi,edi
        les     di,lpBits               ; es:edi --> bits
        add     di,RectX
        movzx   eax,RectY               ; get Y value of first scan
        imul    WidthBytes              ; eax - offset to scan
        add     edi,eax                 ; es:edi --> scan

        xor     ecx,ecx
        mov     dx,RectDY
        or      dx,dx
        jz      DIBRectExit

        mov     cx,RectDX
        and     cx,not 3
        or      cx,cx
        jz      DIBRectExit
        sub     WidthBytes,ecx

        mov     al,byte ptr color

;       test    di,011b
;       jnz     short DIBRectLoopOdd

        mov     bx,RectDX
;       test    bx,011b
;       jnz     short DIBRectLoopOdd

        shr     bx,2
        mov     ah,al
        mov     cx,ax
        shl     eax,16
        mov     ax,cx
DIBRectLoop:
        mov     cx,bx
        rep     stos dword ptr es:[edi]
        add     edi,WidthBytes
        dec     dx
        jnz     short DIBRectLoop
        jz      short DIBRectExit

DIBRectLoopOdd:
        mov     cx,RectDX
        rep stos byte ptr es:[edi]
        add     edi,WidthBytes
        dec     dx
        jnz     short DIBRectLoopOdd

DIBRectExit:
        pop    edi
cEnd

sEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\lockbm.c ===
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include "lockbm.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifndef BI_BITFIELDS
    #define BI_BITFIELDS 3
#endif

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
//  GDI!GDIInit2()      GDI.403
//
//  this GDI function does the following:
//
//      GetSetBitmapHandle(hbm, 0)  - will return global handle of bitmap
//
//      GetSetBitmapHandle(hbm, h)  - will set global handle to <h>
//
//      GetSetBitmapHandle(hbm, -1) - will set global handle to NULL
//
static HANDLE (FAR PASCAL *GetSetBitmapHandle)(HBITMAP hbm, HANDLE h);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#define muldiv(a,b,c) (UINT)(((DWORD)(UINT)(a) * (DWORD)(UINT)(b)) / (UINT)(c))

//////////////////////////////////////////////////////////////////////////////
//
// CanLockBitmaps()
//
// determime if we can lock bitmaps on the current display device
//
//////////////////////////////////////////////////////////////////////////////
BOOL FAR CanLockBitmaps(void)
{
#ifndef WIN32
    //its not safe to do this on NT. god only knows what gdi.403 is on future
    //nt platforms - the only thing we can be sure of is that it is NOT
    // GetSetBitmapHandle()

    UINT w;
    UINT rc;
    HDC  hdc;
    BOOL f;

    static BOOL fCanLockBitmaps = -1;

    if (fCanLockBitmaps == -1)
    {
        w = (UINT)GetVersion();

        w = ((UINT)LOBYTE(w) << 8) | HIBYTE(w);

        hdc = GetDC(NULL);
        rc = GetDeviceCaps(hdc, RASTERCAPS);
        ReleaseDC(NULL, hdc);

        (FARPROC)GetSetBitmapHandle =
            GetProcAddress(GetModuleHandle(TEXT("GDI")),(LPCSTR)MAKEINTATOM(403));
#ifdef WIN32
            // MAKEINTATOM returns a LPTSTR.
            // GetProcAddress wants LPCSTR - NOT Unicode.  Hence we cast
#endif

        //
        // assume we dont need this on windows 4.0?
        //
        // what about the DIBENG? it does DEVBITS and in win 4.0?
        //
        // if the display handles device bitmaps, dont do this either
        //

        f = GetProfileIntA("DrawDib", "Bitmaps", TRUE);

#ifdef DEBUG
        fCanLockBitmaps = f && GetSetBitmapHandle != NULL;
#else
        fCanLockBitmaps = f && /* (w < 0x0400) && */
                          !(rc & RC_DEVBITS) &&
                          GetSetBitmapHandle != NULL;
#endif
    }

    return fCanLockBitmaps;
#else
    return FALSE;
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// LockBitmap
//
// return a pointer to the bitmap bits
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR LockBitmap(HBITMAP hbm)
{
    return GetBitmap(hbm, NULL, 0);
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmapDIB
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb)
{
    IBITMAP FAR *pbm;

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

    if (p == NULL || cb < sizeof(BITMAP))
        return lpBits;

    pbm = p;

    if (lpbi->biCompression == 0)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            case 0x0101: pbm->bmType = BM_1BIT;  break;
            case 0x0104: pbm->bmType = BM_4BIT;  break;
            case 0x0108: pbm->bmType = BM_8BIT;  break;
            case 0x0110: pbm->bmType = BM_16555; break;
            case 0x0118: pbm->bmType = BM_24BGR; break;
            case 0x0120: pbm->bmType = BM_32BGR; break;
            case 0x0401: pbm->bmType = BM_VGA;   break;
            default: return NULL;
        }
    }
    else if (lpbi->biCompression == BI_BITFIELDS)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            //!!! hack: realy should check the bit fields!
            case 0x0110: pbm->bmType = BM_16565; break;
            case 0x0118: pbm->bmType = BM_24RGB; break;
            case 0x0120: pbm->bmType = BM_32RGB; break;
            default: return NULL;
        }
    }
    else
        return NULL;

    pbm->bmWidth        = (int)lpbi->biWidth;
    pbm->bmHeight       = ((int)lpbi->biHeight > 0) ? (int)lpbi->biHeight : -(int)lpbi->biHeight;
    pbm->bmWidthBytes   = (((int)lpbi->biBitCount * (int)lpbi->biWidth + 31)&~31)/8;
    pbm->bmPlanes       = (BYTE)lpbi->biPlanes;
    pbm->bmBitsPixel    = (BYTE)lpbi->biBitCount;
    pbm->bmBits         = lpBits;

    if (cb > sizeof(BITMAP))
    {
        pbm->bmSegmentIndex = 0;
        pbm->bmScanSegment  = pbm->bmHeight;
        pbm->bmFillBytes    = 0;
        pbm->bmBitmapInfo   = (long)lpbi;

        if ((long)lpbi->biHeight < 0)
        {
            pbm->bmNextScan = -pbm->bmWidthBytes;
            pbm->bmOffset   = (long)pbm->bmWidthBytes * (pbm->bmHeight-1);
        }
        else
        {
            pbm->bmNextScan = pbm->bmWidthBytes;
            pbm->bmOffset   = 0;
        }
    }

    return lpBits;
}

#if 0
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void FAR BitmapXY(IBITMAP FAR *pbm, int x, int y)
{
    UINT t;

    if (pbm->bmFillBytes)
    {
        while (y-- > 0)
        {
            t = (UINT)(pbm->bmOffset & 0xFFFF0000);
            pbm->bmOffset += pbm->bmNextScan;
            if ((UINT)(pbm->bmOffset & 0xFFFF0000) != t)
                pbm->bmOffset += pbm->bmFillBytes;
        }
    }
    else
    {
        pbm->bmOffset += y * (long)pbm->bmNextScan;
    }

    pbm->bmOffset += x * pbm->bmBitsPixel / 8;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// GetDIBBitmap
//
//////////////////////////////////////////////////////////////////////////////

/*
 * creates a DIB header for a bitmap, and returns a pointer to the bitmap
 * bits. This pointer is not used - it's checked against NULL, as if this
 * routine returned BOOL.
 *
 * On NT, you can't get the bitmap bits (wrong process) so we return 1 meaning
 * TRUE. You need to call SetBitmapBits to access the bits themselves.
 */
LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi)
{
    UINT wType;
    BITMAP bm;
    UINT ScansPerSeg;
    UINT FillBytes;

    if (hbm)
        GetObject(hbm, sizeof(bm), &bm);

    wType = GetBitmapType();

    if (wType == 0)
        return NULL;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = bm.bmWidth;
    lpbi->biHeight         = bm.bmHeight;
    lpbi->biPlanes         = bm.bmPlanes;
    lpbi->biBitCount       = bm.bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)(bm.bmWidthBytes * bm.bmPlanes) * (DWORD)bm.bmHeight;
    lpbi->biXPelsPerMeter  = 0;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    switch(wType & BM_TYPE)
    {
        case BM_VGA:
            break;

        case BM_1BIT:
        case BM_4BIT:
        case BM_8BIT:
            break;

        case BM_16555:
            break;

        case BM_24BGR:
        case BM_32BGR:
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;

        default:
            return NULL;
    }

    //
    //  make sure WidthBytes is right, dont forget bitmaps are WORD aligned
    //  and DIBs are DWORD aligned.
    //
    if (bm.bmWidthBytes != ((bm.bmWidth * bm.bmBitsPixel + 31) & ~31)/8)
    {
        if (lpbi->biCompression != 0)
            return NULL;

        lpbi->biCompression = BI_BITMAP;
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
    }

    if ((wType & BM_HUGE) && (lpbi->biSizeImage > 64*1024l))
    {
        if (lpbi->biCompression == BI_BITFIELDS)
            return NULL;

        lpbi->biCompression = BI_BITMAP;

        ScansPerSeg = muldiv(64,1024,bm.bmWidthBytes * bm.bmPlanes);
        FillBytes   = (UINT)(64ul*1024 - bm.bmWidthBytes * bm.bmPlanes * ScansPerSeg);

        lpbi->biSizeImage     += FillBytes * (bm.bmHeight / ScansPerSeg);
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
        lpbi->biYPelsPerMeter  = FillBytes;
    }

    if (!(wType & BM_BOTTOMTOTOP))
        lpbi->biHeight = -bm.bmHeight;

#ifdef WIN32
    return (LPVOID) TRUE;
#else
    return LockBitmap(hbm);
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmap
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb)
{
    HANDLE h;
    DWORD  dwSize;
    IBITMAP FAR *pbm;
    HDC hdc = NULL;
    HBITMAP hbmT;

    if (!CanLockBitmaps())
        return NULL;

    if (hbm == NULL)
        return NULL;

    h = GetSetBitmapHandle(hbm, 0);

    if (h == NULL)
        return NULL;

    pbm = (LPVOID)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        return NULL;

    //
    // see if it is realy a bitmap.
    //
    if (pbm->bmType != 0)
        return NULL;

    //
    // make sure the bmBits pointer is valid.
    //
    if (pbm->bmBits == NULL)
    {
        hdc = CreateCompatibleDC(NULL);
        hbmT = SelectObject(hdc, hbm);
    }

    dwSize = (DWORD)pbm->bmHeight * (DWORD)pbm->bmWidthBytes;

    if (IsBadHugeWritePtr((LPVOID)pbm->bmBits, dwSize))
    {
        if (hdc)
        {
            SelectObject(hdc, hbmT);
            DeleteDC(hdc);
        }

        return NULL;
    }

    if (p)
    {
        UINT u;

        hmemcpy(p, pbm, min(cb, sizeof(IBITMAP)));
        pbm = p;

        u = GetBitmapType();

        pbm->bmType = u & BM_TYPE;

        if (cb > sizeof(BITMAP))
        {
            pbm->bmBitmapInfo = 0;
            pbm->bmNextScan = pbm->bmWidthBytes * pbm->bmPlanes;

            if (u & BM_BOTTOMTOTOP)
            {
                pbm->bmOffset = 0;
            }
            else
            {
                pbm->bmOffset   = (long)pbm->bmNextScan * (pbm->bmHeight-1);
                pbm->bmNextScan = -pbm->bmNextScan;
                pbm->bmFillBytes = -pbm->bmFillBytes;
            }

            //
            // see if this particular bitmap is HUGE
            //
            if (!(u & BM_HUGE) || (DWORD)pbm->bmHeight * pbm->bmWidthBytes < 64l*1024)
            {
                pbm->bmFillBytes = 0;
                pbm->bmScanSegment = pbm->bmHeight;
            }
            else
            {
                if (pbm->bmOffset)
                    pbm->bmOffset -= (long)((pbm->bmHeight-1) / pbm->bmScanSegment) * pbm->bmFillBytes;
            }
        }
    }

    if (hdc)
    {
        SelectObject(hdc, hbmT);
        DeleteDC(hdc);
    }

    return (LPVOID)pbm->bmBits;
}

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

///////////////////////////////////////////////////////////////////////////////
//
//  GetSurfaceType
//
///////////////////////////////////////////////////////////////////////////////
#define BCODE _based(_segname("_CODE"))

static BYTE  BCODE bits8[]   = {0x00,0xF9,0xFA,0xFC,0xFF};
static WORD  BCODE bits555[] = {0x0000,0x7C00,0x03E0,0x001F,0x7FFF};
static WORD  BCODE bits5551[]= {0x8000,0xFC00,0x83E0,0x801F,0xFFFF};
static WORD  BCODE bits565[] = {0x0000,0xF800,0x07E0,0x001F,0xFFFF};
static BYTE  BCODE bitsBGR[] = {0x00,0x00,0x00, 0x00,0x00,0xFF, 0x00,0xFF,0x00, 0xFF,0x00,0x00, 0xFF,0xFF,0xFF};
static BYTE  BCODE bitsRGB[] = {0x00,0x00,0x00, 0xFF,0x00,0x00, 0x00,0xFF,0x00, 0x00,0x00,0xFF, 0xFF,0xFF,0xFF};
static DWORD BCODE bitsRGBX[]= {0x000000, 0x0000FF, 0x00FF00, 0xFF0000, 0xFFFFFF};
static DWORD BCODE bitsBGRX[]= {0x000000, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFFFF};

void FAR TestSurfaceType(HDC hdc, int x, int y)
{
    PatBlt(hdc, x, y, 5, 1, BLACKNESS);

    SetPixel(hdc, x+0, y, RGB(000,000,000));
    SetPixel(hdc, x+1, y, RGB(255,000,000));
    SetPixel(hdc, x+2, y, RGB(000,255,000));
    SetPixel(hdc, x+3, y, RGB(000,000,255));
    SetPixel(hdc, x+4, y, RGB(255,255,255));

    GetPixel(hdc, x, y);
}

UINT FAR GetSurfaceType(LPVOID lpBits)
{
    #define TESTFMT(a,n) \
        if (_fmemcmp(lpBits, (LPVOID)a, sizeof(a)) == 0) return n;

    TESTFMT(bits8,    BM_8BIT);
    TESTFMT(bits555,  BM_16555);
    TESTFMT(bits5551, BM_16555);
    TESTFMT(bits565,  BM_16565);
    TESTFMT(bitsRGB,  BM_24RGB);
    TESTFMT(bitsBGR,  BM_24BGR);
    TESTFMT(bitsRGBX, BM_32RGB);
    TESTFMT(bitsBGRX, BM_32BGR);

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetBitmapType
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

UINT FAR GetBitmapType()
{
    BITMAP bm;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdc;
    UINT u;
    BYTE bits[20*4*2];

    static UINT wBitmapType = 0xFFFF;

    if (wBitmapType != 0xFFFF)
        return wBitmapType;

    //
    // create a test bitmap (<64k)
    //
    hdc = GetDC(NULL);
    if (hdc == NULL) {
	return 0;
    }

    hbm = CreateCompatibleBitmap(hdc,20,2);
    ReleaseDC(NULL, hdc);

    if (hbm == NULL) {
	return 0;
    }


    hdc = CreateCompatibleDC(NULL);
    if (hdc == NULL) {
	DeleteObject(hbm);
	return 0;
    }

    hbmT = SelectObject(hdc, hbm);

    if (GetObject(hbm, sizeof(bm), &bm) == 0) {
	SelectObject(hdc, hbmT);
	DeleteObject(hbm);
	DeleteDC(hdc);
	return 0;
    }

    PatBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, BLACKNESS);

    TestSurfaceType(hdc, 0, 0);
    GetBitmapBits(hbm, sizeof(bits), bits);
    u = GetSurfaceType(bits);

    if (u == 0) {
        u = GetSurfaceType(bits + bm.bmWidthBytes);

        if (u)
            u |= BM_BOTTOMTOTOP;
    }

#ifndef WIN32
    if (u) {
        BYTE _huge *pb;
        UINT dy,w;

        //
        // see if bitmap(s) are huge format
        //
        dy = (UINT)(0x10000l/bm.bmWidthBytes) + 1;
        hbm = CreateCompatibleBitmap(hdc,bm.bmWidth,dy);
        DeleteObject(SelectObject(hdc, hbm));
        PatBlt(hdc, 0, 0, bm.bmWidth, dy, BLACKNESS);

        pb = (BYTE _huge *)LockBitmap(hbm);

        if (pb == NULL || OFFSETOF(pb) != 0)
            ; // cant lock bitmaps
        else {
            u |= BM_CANLOCK;

            w = (dy-1) * bm.bmWidthBytes;

            pb[64l*1024] = 0;
            pb[w] = 0;

            if (u & BM_BOTTOMTOTOP)
                SetPixel(hdc, 0, 0, RGB(255,255,255));
            else
                SetPixel(hdc, 0, dy-1, RGB(255,255,255));

            if (pb[64l*1024] != 0 && pb[w] == 0)
                u |= BM_HUGE;
            else if (pb[64l*1024] == 0 && pb[w] != 0)
                ;
            else
                u = 0;
        }
    }
#endif

    SelectObject(hdc, hbmT);
    DeleteObject(hbm);
    DeleteDC(hdc);

    wBitmapType = u;
    return u;
}

//////////////////////////////////////////////////////////////////////////////
//
//  returns the PDevice of the given physical or memory DC
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetPDevice(HDC hdc)
{
    HANDLE h;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdcT=NULL;
    IBITMAP FAR *pbm;
    LPVOID lpPDevice = NULL;

    // GDI.403
    static HANDLE (FAR PASCAL *GdiGetBitmapHandle)(HBITMAP hbm, HANDLE h);

    if (GdiGetBitmapHandle == NULL)
        (FARPROC)GdiGetBitmapHandle = GetProcAddress(GetModuleHandle(TEXT("GDI")),(LPCSTR)MAKEINTATOM(403));

    if (GdiGetBitmapHandle == NULL)
        return NULL;

    hbm = CreateBitmap(1,1,1,1,NULL);

    //
    //  first try the passed DC if it is a bitmap/DC
    //
    hbmT = SelectBitmap(hdc, hbm);

    if (hbmT != NULL)
    {
        //
        // it is a memory DC.
        //
        h = GdiGetBitmapHandle(hbmT, 0);
    }
    else
    {
        //
        // it is a physical DC.
        //

        hdcT = CreateCompatibleDC(hdc);
        hbmT = SelectBitmap(hdcT, hbm);

        h = GdiGetBitmapHandle(hbm, 0);
    }

    if (h == NULL)
        goto exit;

    pbm = (IBITMAP FAR *)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        goto exit;

    if (pbm)
        pbm = (IBITMAP FAR *)pbm->bmlpPDevice;
    else
        pbm = NULL;

    if (IsBadReadPtr(pbm, 2))
        goto exit;

    lpPDevice = (LPVOID)pbm;

exit:
    if (hdcT)
    {
        SelectObject(hdcT, hbmT);
        DeleteObject(hdcT);
    }
    else
    {
        SelectObject(hdc, hbmT);
    }

    DeleteObject(hbm);

    return lpPDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\test\qa.h ===
/* 'About' dialog box resource id */
#define ABOUTBOX    1

/* Menu Items */
#define MENU_ABOUT       2
#define MENU_EXIT        4
#define MENU_OPEN        5
#define MENU_TEST        6
#define MENU_TEST1       7

#define MENU_ALIGN       10
#define MENU_XALIGN      11
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\dvavga.c ===
/****************************************************************************

    DVA surface provider for SVGA card, using dva.386

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern UINT PASCAL __A000h;
#define A000h   (WORD)(&__A000h)

// stuff in VFlat.asm
//
extern LPVOID NEAR PASCAL VFlatInit(void);
extern void   NEAR PASCAL VFlatBegin(void);
extern void   NEAR PASCAL VFlatEnd(void);

#define GETAPI(mod, api) GetProcAddress(GetModuleHandle(mod),MAKEINTATOM(api))

static HCURSOR hcur;
static FARPROC CheckCursor;
       HDC     hdcScreen;
static int     open_count;

static BOOL (FAR PASCAL *XIsWinoldAppTask)(HTASK hTask);

#define IsWinoldAppTask XIsWinoldAppTask

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv)
{
    if (open_count++ == 0)
    {
        (FARPROC)CheckCursor = GETAPI("DISPLAY", MAKEINTATOM(104));
        (FARPROC)XIsWinoldAppTask = GETAPI("KERNEL", MAKEINTATOM(158));

        hdcScreen = CreateDC("DISPLAY", NULL, NULL, NULL);
    }

    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL _loadds vga_close_surface(LPVOID pv)
{
    if (open_count && --open_count == 0)
    {
        DeleteDC(hdcScreen);
        hdcScreen = NULL;
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    RECT rc;
    POINT pt;
    HWND  hwndA;

    //
    //  if windows is in the background dont draw to the screen.
    //
    hwndA = GetActiveWindow();
    if (IsWinoldAppTask(GetWindowTask(hwndA)) && IsIconic(hwndA))
        return FALSE;

    //
    //  on some SVGAs with 8514 like accelerators, a command Que may need to
    //  be flushed before touching video memory.
    //
    if (hdcScreen)
        GetPixel(hdcScreen, x, y);

//!!! we realy should hook the mouse callback.

    GetCursorPos(&pt);

    #define CUR 40

    if ((pt.x >= x-CUR && pt.x <= x+dx+CUR) &&
        (pt.y >= y-CUR && pt.y <= y+dy+CUR))
    {
        hcur = SetCursor(NULL);
    }
    else
    {
        hcur = NULL;

        rc.left = pt.x;
        rc.top = pt.y;
        rc.right = pt.x+1;
        rc.bottom = pt.y+1;

        ClipCursor(&rc);
    }

    if (CheckCursor)
        CheckCursor();

    VFlatBegin();
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL _loadds vga_end_access(LPVOID pv)
{
    VFlatEnd();

    if (hcur)
        SetCursor(hcur);
    else
        ClipCursor(NULL);
}

/****************************************************************************
 ***************************************************************************/

BOOL vga_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    LPBITMAPINFOHEADER lpbi;
    int BitDepth;
    LPVOID lpScreen=NULL;
    IBITMAP FAR *pbm;

    if (nSurface != 0)
        return FALSE;

    BitDepth = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    if (BitDepth < 8)       // forget VGA or mono.
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (HIWORD(pbm->bmBits) != A000h)
        return FALSE;

    lpScreen = VFlatInit();

    if (lpScreen == NULL)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight         = -(int)pbm->bmHeight;
    lpbi->biPlanes         = pbm->bmPlanes;
    lpbi->biBitCount       = pbm->bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)pbm->bmWidthBytes * (DWORD)pbm->bmHeight;
    lpbi->biXPelsPerMeter  = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    pdva->selSurface   = SELECTOROF(lpScreen);
    pdva->offSurface   = OFFSETOF(lpScreen);
    pdva->Version      = 0x0100;
    pdva->Flags        = DVAF_1632_ACCESS;
    pdva->lpSurface    = (LPVOID)(DWORD)pbm->bmHeight;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\dva\test\qa.c ===
/*----------------------------------------------------------------------------*\
|   qa.c - A template for a Windows application                                |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include "qa.h"
#include "dva.h"
#include "lockbm.h"
#include "dibeng.inc"


#define DI_TYPE     0x4944  // 'DI'
#define DE_TYPE     0x4544  // 'DE'
#define RP_TYPE     0x5250  // 'RP'
#define M4_TYPE     0x344D  // 'M4'

/*----------------------------------------------------------------------------*\
|                                                                              |
|   g e n e r a l   c o n s t a n t s                                          |
|                                                                              |
\*----------------------------------------------------------------------------*/

#define MAXSTR   80

#define EXPORT  FAR  PASCAL _export     // exported function
#define PRIVATE NEAR PASCAL             // function local to this segment
#define PUBLIC  FAR  PASCAL             // function external to this segment

/*----------------------------------------------------------------------------*\
|                                                                              |
|   g l o b a l   v a r i a b l e s                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
static  char    szAppName[]="Quick App";

static  HANDLE  hInstApp;
static  HWND    hwndApp;

LPVOID lpScreen;
BITMAPINFOHEADER biScreen;

/*----------------------------------------------------------------------------*\
|                                                                              |
|   f u n c t i o n   d e f i n i t i o n s                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

LONG EXPORT AppWndProc (HWND hwnd, unsigned uiMessage, WORD wParam, LONG lParam);
int  ErrMsg (LPSTR sz,...);
BOOL fDialog(int id,HWND hwnd,FARPROC fpfn);

LONG NEAR PASCAL AppCommand(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);

/*----------------------------------------------------------------------------*\
|   AppAbout( hDlg, uiMessage, wParam, lParam )                                |
|                                                                              |
|   Description:                                                               |
|       This function handles messages belonging to the "About" dialog box.    |
|       The only message that it looks for is WM_COMMAND, indicating the use   |
|       has pressed the "OK" button.  When this happens, it takes down         |
|       the dialog box.                                                        |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL EXPORT AppAbout( hDlg, uiMessage, wParam, lParam )
    HWND     hDlg;
    unsigned uiMessage;
    WORD     wParam;
    long     lParam;
{
    switch (uiMessage) {
        case WM_COMMAND:
            if (wParam == IDOK)
            {
                EndDialog(hDlg,TRUE);
            }
            break;

        case WM_INITDIALOG:
            return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   AppInit( hInst, hPrev)                                                     |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into               |
|       memory.  It performs all initialization that doesn't need to be done   |
|       once per instance.                                                     |
|                                                                              |
|   Arguments:                                                                 |
|       hInstance       instance handle of current instance                    |
|       hPrev           instance handle of previous instance                   |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL AppInit(HANDLE hInst,HANDLE hPrev,WORD sw,LPSTR szCmdLine)
{
    WNDCLASS cls;
    int      dx,dy;

    /* Save instance handle for DialogBoxs */
    hInstApp = hInst;

    if (!hPrev) {
        /*
         *  Register a class for the main application window
         */
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = LoadIcon(hInst,"AppIcon");
        cls.lpszMenuName   = "AppMenu";
        cls.lpszClassName  = szAppName;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        cls.lpfnWndProc    = (WNDPROC)AppWndProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        if (!RegisterClass(&cls))
            return FALSE;
    }

    dx = GetSystemMetrics (SM_CXSCREEN);
    dy = GetSystemMetrics (SM_CYSCREEN);

    hwndApp = CreateWindow (szAppName,    // Class name
                            szAppName,              // Caption
                            WS_OVERLAPPEDWINDOW,    // Style bits
                            CW_USEDEFAULT, 0,       // Position
                            dx/2,dy/2,              // Size
                            (HWND)NULL,             // Parent window (no parent)
                            (HMENU)NULL,            // use class menu
                            (HANDLE)hInst,          // handle to window instance
                            (LPSTR)NULL             // no params to pass on
                           );
    ShowWindow(hwndApp,sw);

    return TRUE;
}

void AppExit()
{
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the App.  After initializing, it just goes      |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|       hInst           instance handle of this instance of the app            |
|       hPrev           instance handle of previous instance, NULL if first    |
|       szCmdLine       ->null-terminated command line                         |
|       cmdShow         specifies how the window is initially displayed        |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
int PASCAL WinMain(HANDLE hInst, HANDLE hPrev, LPSTR szCmdLine, WORD sw)
{
    MSG     msg;

    /* Call initialization procedure */
    if (!AppInit(hInst,hPrev,sw,szCmdLine))
        return FALSE;

    /*
     * Polling messages from event queue
     */

    while (GetMessage(&msg,NULL,0,0))  {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    AppExit();
    return msg.wParam;
}

UINT BiosMode()
{
    UINT Mode;

    _asm
    {
        mov     ax, 6F04h               ;Get V7 mode
        int     10h
        cmp     al,04h
        jne     short v7
	mov	ax,0F00h		;Call BIOS to get mode back.
        int     10h                     ;al = mode we are in.
v7:     xor     ah,ah
        mov     Mode,ax
    }

    return Mode;
}

#if 0
LONG GetSelBase(short sel)
{
    _asm
    {
    }
}
#endif

/*----------------------------------------------------------------------------*\
|   AppPaint(hwnd, hdc)                                                        |
|                                                                              |
|   Description:                                                               |
|       The paint function.  Right now this does nothing.                      |
|                                                                              |
|   Arguments:                                                                 |
|       hwnd             window painting into                                  |
|       hdc              display context to paint to                           |
|                                                                              |
|   Returns:                                                                   |
|       nothing                                                                |
|                                                                              |
\*----------------------------------------------------------------------------*/

AppPaint (HWND hwnd, HDC hdc)
{
    RECT    rc;
    int     x,y;
    char    ach[128];
    char    achDisplay[80];
    UINT    wType;
    TEXTMETRIC tm;
    IBITMAP FAR *pbm;
    DWORD off;
    WORD sel;

    SetPixel(hdc, 0, 0, RGB(0,0,0));

#define TEXT(sz) \
    (TextOut(hdc, x, y, sz, lstrlen(sz)), y += tm.tmHeight+1)

#define PF1(sz, a)          PF3(sz, a, 0, 0)
#define PF2(sz, a, b)       PF3(sz, a, b, 0)
#define PF3(sz, a, b, c)    (wsprintf(ach, sz, a, b, c), TEXT(ach))
#define FLAG(w, f, s)       if ((w) & (f)) TEXT(s)

    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));

    GetTextMetrics(hdc, &tm);

    GetClientRect(hwnd,&rc);

    x = 4; y = 4;

    SetTextColor(hdc,GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc,GetSysColor(COLOR_WINDOW));

    GetPrivateProfileString("boot", "display.drv","",achDisplay,sizeof(achDisplay),"system.ini");

    wsprintf(ach, "Device: %dx%dx%d (%s)",
        GetDeviceCaps(hdc, HORZRES),
        GetDeviceCaps(hdc, VERTRES),
        GetDeviceCaps(hdc, BITSPIXEL) *
        GetDeviceCaps(hdc, PLANES),
        (LPSTR)achDisplay);

    TEXT(ach);
    PF1("Bios Mode = %04X",BiosMode());

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_DEVBITS)
        TEXT("  Device bitmap support");

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        TEXT("  Palette device");
    else
        TEXT("  RGB device (non-palette)");

    if (lpScreen != NULL)
    {
        TEXT("Direct Screen access");
    }

    if (pbm = (IBITMAP FAR *)GetPDevice(hdc))
    {
        PF1("lpPDevice = %08lX",pbm);

        if (pbm->bmType == DI_TYPE ||
            pbm->bmType == DE_TYPE ||
            pbm->bmType == RP_TYPE ||
            pbm->bmType == M4_TYPE)
        {
            DIBENGINE FAR *pde = (DIBENGINE FAR *)pbm;

            PF2("   deType       = %c%c",  LOBYTE(pde->deType), HIBYTE(pde->deType));
            PF1("   deWidth      = %d",    pde->deWidth);
            PF1("   deHeight     = %d",    pde->deHeight);
            PF1("   deWidthBytes = %d",    pde->deWidthBytes);
            PF1("   dePlanes     = %d",    pde->dePlanes);
            PF1("   deBitsPixel  = %d",    pde->deBitsPixel);
            PF1("   deReserved1  = %08lX", pde->deReserved1);
            PF1("   deDeltaScan  = %ld",   pde->deDeltaScan);
            PF1("   delpPDevice  = %08lX", pde->delpPDevice);
            PF2("   deBits       = %04X:%08lX",pde->deBitsSelector,pde->deBitsOffset);
            PF1("         base   = %08lX",GetSelectorBase(pde->deBitsSelector));
            PF1("         limit  = %08lX",GetSelectorLimit(pde->deBitsSelector));
            PF1("   deFlags      = %04X",  pde->deFlags);
            FLAG(pde->deFlags, MINIDRIVER      , "    MINIDRIVER   ");
            FLAG(pde->deFlags, PALETTIZED      , "    PALETTIZED   ");
            FLAG(pde->deFlags, SELECTEDDIB     , "    SELECTEDDIB  ");
            FLAG(pde->deFlags, CURSOREXCLUDE   , "    CURSOREXCLUDE");
            FLAG(pde->deFlags, DISABLED        , "    DISABLED     ");
            FLAG(pde->deFlags, VRAM            , "    VRAM         ");
            FLAG(pde->deFlags, BANKEDVRAM      , "    BANKEDVRAM   ");
            FLAG(pde->deFlags, BANKEDSCAN      , "    BANKEDSCAN   ");
            PF1("   deVersion    = %04X",  pde->deVersion);
            PF1("   deBitmapInfo = %08lX", pde->deBitmapInfo);
        }
        else
        {
            PF1("   bmType         = %04X",pbm->bmType);
            PF1("   bmWidth        = %d",pbm->bmWidth);
            PF1("   bmHeight       = %d",pbm->bmHeight);
            PF1("   bmWidthBytes   = %d",pbm->bmWidthBytes);
            PF1("   bmPlanes       = %d",pbm->bmPlanes);
            PF1("   bmBitsPixel    = %d",pbm->bmBitsPixel);

            sel = ((WORD FAR *)&pbm->bmBits)[1];
            off = ((WORD FAR *)&pbm->bmBits)[0];

            PF2("   bmBits         = %04X:%04X",sel,(WORD)off);
            PF1("           base   = %08lX",GetSelectorBase(sel));
            PF1("           limit  = %08lX",GetSelectorLimit(sel));

            sel = ((WORD FAR  *)&pbm->bmBits)[2];
            off = ((DWORD FAR *)&pbm->bmBits)[0];
            PF2("   bmBits48       = %04X:%08lX",sel,off);
            PF1("           base   = %08lX",GetSelectorBase(sel));
            PF1("           limit  = %08lX",GetSelectorLimit(sel));

            PF1("   bmWidthPlanes  = %d",pbm->bmWidthPlanes);
            PF1("   bmlpPDevice    = %08lX",pbm->bmlpPDevice);
            PF1("   bmSegmentIndex = %04X",pbm->bmSegmentIndex);
            PF1("   bmScanSegment  = %d",pbm->bmScanSegment);
            PF1("   bmFillBytes    = %d",pbm->bmFillBytes);
            PF1("   reserved1      = %d",pbm->reserved1);
            PF1("   reserved2      = %d",pbm->reserved2);
        }
    }

    if (CanLockBitmaps() && GetBitmapType())
    {
        wType = GetBitmapType();

        TEXT("Can Lock Bitmaps");

	if (wType & BM_HUGE)
	    TEXT("  Huge Bitmaps");
	else
	    TEXT("  Flat Bitmaps");

	if (wType & BM_BOTTOMTOTOP)
	    TEXT("  Bottom to top Bitmaps");
	else
	    TEXT("  Top to bottom Bitmaps");

        switch (wType & BM_TYPE)
        {
            case BM_VGA:    TEXT("  Bitmap type: VGA"); break;
            case BM_1BIT:   TEXT("  Bitmap type: 1 BIT"); break;
            case BM_4BIT:   TEXT("  Bitmap type: 4 BIT"); break;
            case BM_8BIT:   TEXT("  Bitmap type: 8 BIT"); break;
            case BM_16555:  TEXT("  Bitmap type: 16 BIT RGB 555"); break;
            case BM_16565:  TEXT("  Bitmap type: 16 BIT RGB 565"); break;
            case BM_24BGR:  TEXT("  Bitmap type: 24 BIT BGR"); break;
            case BM_24RGB:  TEXT("  Bitmap type: 24 BIT RGB"); break;
            case BM_32BGR:  TEXT("  Bitmap type: 32 BIT BGR"); break;
            case BM_32RGB:  TEXT("  Bitmap type: 32 BIT RGB"); break;
	    default:	    TEXT("  Bitmap type: Unknown"); break;
        }
    }

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|                                                                              |
|   w i n d o w   p r o c s                                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|   AppWndProc( hwnd, uiMessage, wParam, lParam )                              |
|                                                                              |
|   Description:                                                               |
|       The window proc for the app's main (tiled) window.  This processes all |
|       of the parent window's messages.                                       |
|                                                                              |
|   Arguments:                                                                 |
|       hwnd            window handle for the window                           |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       0 if processed, nonzero if ignored                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
LONG EXPORT AppWndProc(hwnd, msg, wParam, lParam)
    HWND     hwnd;
    unsigned msg;
    WORD     wParam;
    long     lParam;
{
    PAINTSTRUCT ps;
    HDC hdc;

    switch (msg) {
        case WM_CREATE:
            hdc = GetDC(hwnd);
            lpScreen = DVAGetSurface(hdc, &biScreen);
            ReleaseDC(hwnd, hdc);
            break;

        case WM_SYSCOLORCHANGE:
            break;

        case WM_TIMER:
            break;

        case WM_ERASEBKGND:
            break;

        case WM_INITMENU:
            EnableMenuItem((HMENU)wParam, MENU_TEST,  lpScreen == NULL ? MF_GRAYED : MF_ENABLED);
            EnableMenuItem((HMENU)wParam, MENU_TEST1, lpScreen == NULL ? MF_GRAYED : MF_ENABLED);
            break;

        case WM_COMMAND:
            return AppCommand(hwnd,msg,wParam,lParam);

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CLOSE:
            break;

        case WM_PAINT:
            BeginPaint(hwnd,&ps);
            AppPaint (hwnd,ps.hdc);
            EndPaint(hwnd,&ps);
            return 0L;
    }
    return DefWindowProc(hwnd,msg,wParam,lParam);
}

void NEAR PASCAL AlignPlaybackWindow(HWND hwnd, BOOL fAlign)
{
    DWORD dw;
    int x,y;
    RECT rc;
    HDC hdc;

    #define X_ALIGN 4
    #define Y_ALIGN 4

    hdc = GetDC(hwnd);
    dw = GetDCOrg(hdc);
    x = LOWORD(dw);
    y = HIWORD(dw);
    ReleaseDC(hwnd, hdc);

    if (!fAlign)
    {
        x++;
        y++;
    }

    if ((x & (X_ALIGN-1)) || (y & (Y_ALIGN-1)))
    {
        //
        // dont move the window if it does not want to be moved.
        //
        if (IsWindowVisible(hwnd) &&
           !IsZoomed(hwnd) &&
           !IsIconic(hwnd) &&
            IsWindowEnabled(hwnd))
        {
            GetWindowRect(hwnd, &rc);
            OffsetRect(&rc, -(x & (X_ALIGN-1)), -(y & (Y_ALIGN-1)));

            if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
                ScreenToClient(GetParent(hwnd), (LPPOINT)&rc);

            SetWindowPos(hwnd,NULL,rc.left,rc.top,0,0,
                SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
        }
    }
}

LONG NEAR PASCAL AppCommand (hwnd, msg, wParam, lParam)
    HWND     hwnd;
    unsigned msg;
    WORD     wParam;
    long     lParam;
{
    HDC hdc;
    LPVOID lpScreen;
    BITMAPINFOHEADER bi;

    switch(wParam)
    {
        case MENU_ABOUT:
            fDialog(ABOUTBOX,hwnd,(FARPROC)AppAbout);
            break;

        case MENU_OPEN:
            break;

        case MENU_EXIT:
            PostMessage(hwnd,WM_CLOSE,0,0L);
            break;

        case MENU_XALIGN:
            AlignPlaybackWindow(hwnd, FALSE);
            break;

        case MENU_ALIGN:
            AlignPlaybackWindow(hwnd, TRUE);
            break;

        case MENU_TEST1:
            hdc = GetDC(hwnd);

            lpScreen = DVAGetSurface(hdc, &bi);

            if (lpScreen)
            {
                UINT u;
                RECT rc;
                DWORD dw;
                int x,y,dx,dy,w;
                DWORD time;

                extern void FAR PASCAL DIBRect(LPVOID, LONG, int, int, int, int, UINT);

                GetClientRect(hwnd, &rc);
                dw = GetDCOrg(hdc);

                x = LOWORD(dw) * (int)bi.biBitCount / 8;
                y = HIWORD(dw);
                dx = rc.right * (int)bi.biBitCount / 8;
                dy = rc.bottom;
                w  = bi.biWidth * (int)bi.biBitCount / 8;

                time = timeGetTime();

                for (u=0; u<256; u++)
                {
                    DVABeginAccess(hdc,x,y,dx,dy);
                    DIBRect(lpScreen,w,x,y,dx,dy,u);
                    DVAEndAccess(hdc);
                }

                time = timeGetTime() - time;

                ErrMsg("DVA %d.%03d fps",
                    (UINT)(1000l * 256 / time),
                    (UINT)((1000000l * 256 / time) % 1000));
            }

            ReleaseDC(hwnd, hdc);
            break;

        case MENU_TEST:
            hdc = GetDC(hwnd);

            lpScreen = DVAGetSurface(hdc, &bi);

            if (lpScreen)
            {
                UINT u;
                RECT rc;
                DWORD dw;
                int x,y,dx,dy,w;
                DWORD time;

                extern void FAR PASCAL DIBRect(LPVOID, LONG, int, int, int, int, UINT);

                GetClientRect(hwnd, &rc);
                dw = GetDCOrg(hdc);

                x = LOWORD(dw) * (int)bi.biBitCount / 8;
                y = HIWORD(dw);
                dx = rc.right * (int)bi.biBitCount / 8;
                dy = rc.bottom;
                w  = bi.biWidth * (int)bi.biBitCount / 8;

                DVABeginAccess(hdc, x, y, dx, dy);

                time = timeGetTime();

                for (u=0; u<256; u++)
                {
                    DIBRect(lpScreen,w,x,y,dx,dy,u);
                }

                time = timeGetTime() - time;

                DVAEndAccess(hdc);

                ErrMsg("DVA %d.%03d fps",
                    (UINT)(1000l * 256 / time),
                    (UINT)((1000000l * 256 / time) % 1000));
            }

            ReleaseDC(hwnd, hdc);
            break;
    }
    return 0L;
}

/*----------------------------------------------------------------------------*\
|   ErrMsg - Opens a Message box with a error message in it.  The user can     |
|            select the OK button to continue                                  |
\*----------------------------------------------------------------------------*/
int ErrMsg (LPSTR sz,...)
{
    char ach[128];

    wvsprintf (ach,sz,(LPSTR)(&sz+1));   /* Format the string */
    MessageBox(NULL,ach,NULL,MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);
    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function displays a dialog box and returns the exit code.         |
|       the function passed will have a proc instance made for it.             |
|                                                                              |
|   Arguments:                                                                 |
|       id              resource id of dialog to display                       |
|       hwnd            parent window of dialog                                |
|       fpfn            dialog message function                                |
|                                                                              |
|   Returns:                                                                   |
|       exit code of dialog (what was passed to EndDialog)                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL fDialog(int id,HWND hwnd,FARPROC fpfn)
{
    BOOL        f;
    HANDLE      hInst;

    hInst = GetWindowWord(hwnd,GWW_HINSTANCE);
    fpfn  = MakeProcInstance(fpfn,hInst);
    f = DialogBox(hInst,MAKEINTRESOURCE(id),hwnd,fpfn);
    FreeProcInstance (fpfn);
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib\profdisp\profdisp.c ===
#include <windows.h>
#include "ntavi.h"
#include <vfw.h>

#ifdef WIN32
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw)
#else
int PASCAL WinMain(HANDLE hInst, HANDLE hPrev, LPSTR szCmdLine, WORD sw)
#endif
{
    DrawDibProfileDisplay(NULL);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\cmacro32.inc ===
?386regs=1
PMODE=1
?WIN=0
?SMALL=1

ifndef ?auto32
    ?auto32 = 1
endif

comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros ToddLa 32-bit Version - Copyright (c) Microsoft Corp. 1992>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
outif ?auto32,0,<Discardable 32bit code segment hack enabled>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 386 protect mode use32>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
;.286p
.386p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [ebp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [ebp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [ebp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [ebp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [ebp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [ebp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif

ife c
n proc near
else
if ?auto32
&n&_fix_cs:
    db 057h                     ; push    di
    db 083h,0ECh,008h           ; sub     sp,8
    db 08Ch,0CBh                ; mov     bx,cs
    db 08Ch,0D0h                ; mov     ax,ss
    db 08Eh,0C0h                ; mov     es,ax
    db 08Bh,0FCh                ; mov     di,sp
    db 0B8h,00Bh,000h           ; mov     ax,000Bh
    db 0CDh,031h                ; int     31h
    db 026h,080h,04Dh,006h,040h ; or      byte ptr es:[di+6],40h
    db 0B8h,00Ch,000h           ; mov     ax,000Ch
    db 0CDh,031h                ; int     31h
    add     sp,8                ; db 083h,0C4h,008h
    pop     di                  ; db 05Fh
align 4
n proc far
    xor eax,eax
    mov ah,80h
    add eax,eax
    jc  short &n&_fix_cs
else
n proc far
endif
endif

ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
    push bp
    movzx ebp,sp
else
if ???
    push    bp
    movzx   ebp, sp
    sub     sp, ???

;;;;;enter ???,0
;;;;;movzx bp,bp

else
push bp
movzx ebp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
        push    bp
        movzx   ebp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
        inc     bp
endif
        push    bp
        movzx   ebp,sp
	push	ds
else
if ?ff+???+?po+?rp
        push    bp
        movzx   ebp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
movzx ebp,sp
else
if ???

    push    bp
    movzx   ebp, sp
    sub     sp, ???

;;;;enter ???,0
;;;;movzx ebp,bp
else
push  bp
movzx ebp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
        push    bp
        movzx   ebp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
;;;;lea     sp,-4[bp]
if ???
    add     sp, ???
endif
    pop     bp
;;;;leave
endif
else
if ?ff+???+?po+?rp

;;;;lea     sp,-4[bp]
if ???
    add     sp, ???
endif
    pop     bp
    

;;;;;;;;;;;;;;;;;;;leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
        lea     sp,-2[bp]
endif
	pop	ds
        pop     bp
ife ?DOS5
        dec     bp
endif
else
if (?TF eq 0) or (???+?rp)
        mov     sp,bp
endif
if ???+?po+?rp
        pop     bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
;;;;lea     sp,-4[bp]
if  ???
    add     sp, ???
endif
    pop     bp
;;;;;;;;;;;;;;;;;;;;;;;;leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
        mov     sp,bp
endif
        pop     bp
endif
endif
endif
ife cc
        db      66h
        retf
else
        db      66h
        retf    o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
;.286p
;createSeg _TEXT,Code,word,public,CODE
;.386p
;;;;;;;;;createSeg _TEXT32,Code32,word,use32,CODE
ife ?nodata1
.286p
createSeg _DATA,Data,word,public,DATA,DGROUP
.386p
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dith666.c ===
//////////////////////////////////////////////////////////////////////////////
//
//  DITH666.C  - full color dither (to a palette with 6 red, 6 green 6 blue
//               levels)
//
//  NOTE this file contains the 'C' code and DITH666A.ASM has the ASM code.
//
//  This file does the following dithering
//
//      32bpp   -> 8bpp
//      24bpp   -> 8bpp
//      16bpp   -> 8bpp
//
//      8bpp    -> 4bpp     N/I
//      16bpp   -> 4bpp     N/I
//      24bpp   -> 4bpp     N/I
//      32bpp   -> 4bpp     N/I
//
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"
#include "dither.h"

#if defined(WIN32) || defined(WANT_286) // 'C' code for Win32
#define USE_C
#endif

#include "dith666.h"

int         giDitherTableUsage = 0;
LPVOID      glpDitherTable;

static void Get666Colors(LPBITMAPINFOHEADER lpbi);

//////////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither24(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither32(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTableInit()
//
//////////////////////////////////////////////////////////////////////////////

static LPVOID DitherTableInit()
{
#ifdef DEBUG
    DWORD time = timeGetTime();
#endif

#ifdef XDEBUG
    int X,Y;
    char aBuffer[100];
    char far *pBuffer = aBuffer;

    GetProfileString("DrawDib", "Matrix5", "", aBuffer, sizeof(aBuffer));

    if (aBuffer[0])
    {
        for(Y = 0;Y < 4;Y++)
        {
            for(X = 0;X < 4;X++)
            {
                while(!isdigit(*pBuffer))
                {
                        pBuffer++;
                }

                aHalftone4x4_5[X][Y] = *pBuffer - '0';
                pBuffer++;
            }
        }
    }
#endif

    if (aHalftone8[0][0][0][0] == (BYTE)-1)
    {
        int i,x,y;

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (i=0; i<256; i++)
                    aHalftone8[0][x][y][i] = (i/51 + (i%51 > aHalftone4x4[x][y]));

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (i=0; i<256; i++)
                    aHalftone8[1][x][y][i] = 6 * (i/51 + (i%51 > aHalftone4x4[x][y]));

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (i=0; i<256; i++)
                    aHalftone8[2][x][y][i] = 36 * (i/51 + (i%51 > aHalftone4x4[x][y]));
    }

#ifdef USE_C
    if (aHalftone5[0][0][0][0] == (BYTE)-1)
    {
        int i,x,y,z,n;

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (z=0; z<256; z++) {
                    n = (z >> 2) & 0x1F;
                    i = n > 0 ? n-1 : 0;
                    aHalftone5[0][x][y][z] = (i/6 + (i%6 > aHalftone4x4_5[x][y]));
                }

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (z=0; z<256; z++) {
                    n = (z & 0x1F);
                    i = n > 0 ? n-1 : 0;
                    aHalftone5[1][x][y][z] = 6 * (i/6 + (i%6 > aHalftone4x4_5[x][y]));
                }

        for (x=0; x<4; x++)
            for (y=0; y<4; y++)
                for (z=0; z<256; z++) {
                    n = z & 0x1F;
                    i = n > 0 ? n-1 : 0;
                    aHalftone5[2][x][y][z] = 36 * (i/6 + (i%6 > aHalftone4x4_5[x][y]));
                }
    }
#endif

    DPF(("DitherTableInit() took %ldms", timeGetTime() - time));

    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither8Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    UINT x,y,i,r,g,b;
    BYTE FAR *pb;

    Get666Colors(lpbiOut);

    DitherTableInit();

    if (lpDitherTable == NULL)
        lpDitherTable = GlobalAllocPtr(GHND, 256*8*8);

    if (lpDitherTable == NULL)
        return (LPVOID)-1;

    pb = (LPBYTE)lpDitherTable;

    for (y=0; y<8; y++)
    {
        for (i=0; i<256; i++)
        {
            r = ((LPRGBQUAD)(lpbi+1))[i].rgbRed;
            g = ((LPRGBQUAD)(lpbi+1))[i].rgbGreen;
            b = ((LPRGBQUAD)(lpbi+1))[i].rgbBlue;

            for (x=0; x<8; x++)
            {
                *pb++ = DITH8(x,y,r,g,b);
            }
        }
    }

    *lpDitherProc = Dither8;

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither16Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get666Colors(lpbiOut);

    *lpDitherProc = Dither16;

    DitherTableInit();

#ifndef USE_C
    //
    // we dont need to re-init the dither table, unless it is not ours then
    // we should free it.
    //
    if (lpDitherTable && lpDitherTable != glpDitherTable)
    {
        DitherTerm(lpDitherTable);
        lpDitherTable = NULL;
    }

    //
    // we dont need to re-init table
    //
    if (lpDitherTable != NULL)
        return lpDitherTable;

    if (glpDitherTable)
    {
        giDitherTableUsage++;
        return glpDitherTable;
    }
    else
    {
        //
        //  build a table that maps a RGB555 directly to a palette index
        //  we actualy build 4 tables, we assume a 2x2 dither and build
        //  a table for each position in the matrix.
        //

        UINT x,y,r,g,b;
        BYTE FAR *pb;

#ifdef DEBUG
        DWORD time = timeGetTime();
#endif
        lpDitherTable = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, 32768l*4);

        if (lpDitherTable == NULL)
            return (LPVOID)-1;

        glpDitherTable = lpDitherTable;
        giDitherTableUsage = 1;

        for (y=0; y<2; y++)
        {
            if (y == 0)
                pb = (BYTE FAR *)lpDitherTable;
            else
                pb = (BYTE FAR *)((BYTE _huge *)lpDitherTable + 65536);

            for (r=0; r<32; r++)
                for (g=0; g<32; g++)
                    for (b=0; b<32; b++)
                        for (x=0; x<2; x++)
                            *pb++ = DITH31(x,y,r,g,b);
        }

        DPF(("Dither16Init() took %ldms", timeGetTime() - time));
    }
#endif
    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16Term(LPVOID lpDitherTable)
{
    if (giDitherTableUsage == 0 || --giDitherTableUsage > 0)
        return;

    if (glpDitherTable)
    {
        GlobalFreePtr(glpDitherTable);
        glpDitherTable = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither24Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get666Colors(lpbiOut);

    *lpDitherProc = Dither24;

    return DitherTableInit();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24Term(LPVOID lpDitherTable)
{
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither32Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get666Colors(lpbiOut);

    *lpDitherProc = Dither32;

    return DitherTableInit();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32Term(LPVOID lpDitherTable)
{
}

//////////////////////////////////////////////////////////////////////////////
//
//   GetDithColors() get the dither palette
//
//////////////////////////////////////////////////////////////////////////////

static void Get666Colors(LPBITMAPINFOHEADER lpbi)
{
    RGBQUAD FAR *prgb = (RGBQUAD FAR *)(((LPBYTE)lpbi) + (UINT)lpbi->biSize);
    int i;

    for (i=0; i<256; i++)
    {
        prgb[i].rgbRed   = pal666[i][0];
        prgb[i].rgbGreen = pal666[i][1];
        prgb[i].rgbBlue  = pal666[i][2];
        prgb[i].rgbReserved = 0;
    }

    lpbi->biClrUsed = 256;
}

#ifdef USE_C

//////////////////////////////////////////////////////////////////////////////
//
//  Dither24   - dither from 24 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    BYTE r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 24)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth*3+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*3 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*3;
    wWidthDst -= DstXE;

#define GET24() \
    b = *pbS++; \
    g = *pbS++; \
    r = *pbS++;

    for (y=0; y<DstYE; y++) {

        for (x=0; x<DstXE; x++) {
            GET24(); *pbD++ = DITH8(x,y,r,g,b);
        }

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither32  - dither from 32 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    BYTE r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 32)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth*4+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*4 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*4;
    wWidthDst -= DstXE;

#define GET32() \
    b = *pbS++; \
    g = *pbS++; \
    r = *pbS++; \
    pbS++;

    for (y=0; y<DstYE; y++) {

        for (x=0; x<DstXE; x++)
        {
            GET32();
            *pbD++ = DITH8(x,y,r,g,b);
        }

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Dither16  - dither from 16 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    WORD w;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 16)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth*2+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*2 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*2;
    wWidthDst -= DstXE;

#define GET16() \
    w = *((WORD _huge *)pbS)++;

    for (y=0; y<DstYE; y++) {

        for (x=0; x<DstXE; x++)
        {
            GET16();
            *pbD++ = DITH5(x,y,w);
        }

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dith666.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  DITH666.H  - full color dither (to a palette with 6 red, 6 green 6 blue
//               levels)
//
//////////////////////////////////////////////////////////////////////////////

#define HSIZE 4                                 // matrix size is 4x4
#define SEG666  _based(_segname("DITH666"))     // segment containing tables
#define SEGXXX  _based(_segname("_CODE"))       // segment containing init tables

//////////////////////////////////////////////////////////////////////////////
//
//  dither table for 256 level dither (RGB 24 or 32)
//
//  total table size is 12k
//
//////////////////////////////////////////////////////////////////////////////

#define DITH256(x,y,r,g,b) aTranslate666[           \
        1  * (r/51 + (r%51 > aHalftone4x4[x][y])) + \
        6  * (g/51 + (g%51 > aHalftone4x4[x][y])) + \
        36 * (b/51 + (b%51 > aHalftone4x4[x][y]))]

#define DITH8(x,y,r,g,b) aTranslate666[   \
        aHalftone8[0][(x)&3][(y)&3][(r)] +\
        aHalftone8[1][(x)&3][(y)&3][(g)] +\
        aHalftone8[2][(x)&3][(y)&3][(b)] ]

char unsigned SEG666 aHalftone8[3][4][4][256] = {(BYTE)-1};

#if 1

static char unsigned const SEGXXX aHalftone4x4[4][4] =
{
        0,  25, 6,  31,
	38, 12, 44, 19,
        9,  35, 3,  28,
	47, 22, 41, 15
};

#else

static char unsigned const SEGXXX aHalftone4x4[4][4] =
{
        41, 3,  9,  28,
	35, 15, 22, 47,
        6,  25, 38, 0,
	19, 44, 31, 12
};

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  dither table for 32 level dither (RGB 555 or 565)
//
//  total table size is 12k
//
//////////////////////////////////////////////////////////////////////////////

#define d62(n)  (((n) * 10) / 62)                // n / 6.2
#define m62(n)  ((n) * 1000 / 62 - d62(n) * 100) // n % 6.2

#define DITH31(x,y,r,g,b) aTranslate666[                      \
        1  * (d62(r) + (m62(r) > (UINT)aHalftone2x2[x][y])) + \
        6  * (d62(g) + (m62(g) > (UINT)aHalftone2x2[x][y])) + \
        36 * (d62(b) + (m62(b) > (UINT)aHalftone2x2[x][y]))]

static char SEGXXX aHalftone2x2[2][2] =
{
        0, 99,
        66,33,
};

#ifdef USE_C

#define DITH5(x,y,rgb)  aTranslate666[            \
    aHalftone5[0][(x)&3][(y)&3][((rgb)>>8)&0xFF] +\
    aHalftone5[1][(x)&3][(y)&3][((rgb)>>5)&0xFF] +\
    aHalftone5[2][(x)&3][(y)&3][((rgb)>>0)&0xFF] ]

char unsigned SEG666 aHalftone5[3][4][4][256]  = {(BYTE)-1};


#if 0

static char unsigned const SEGXXX aHalftone4x4_5[4][4] =
{
        0,3,0,3,
        4,1,4,1,
        0,3,0,3,
        4,1,4,1
};

#else

static char SEGXXX aHalftone4x4_5[4][4] =
{
        0,3,2,3,
        2,4,0,3,
        2,0,4,1,
        4,1,2,1
};

#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  translate table from a 666 index to a foreground palette index
//
//////////////////////////////////////////////////////////////////////////////

char unsigned SEG666 aTranslate666[216] =
{
	0,
	29,
	30,
	31,
	32,
	249,
	33,
	34,
	35,
	36,
	37,
	38,
	39,
	40,
	41,
	42,
	43,
	44,
	45,
	46,
	47,
	48,
	49,
	50,
	51,
	52,
	53,
	54,
	55,
	56,
	250,
	250,
	57,
	58,
	59,
	251,
	60,
	61,
	62,
	63,
	64,
	65,
	66,
	67,
	68,
	69,
	70,
	71,
	72,
	73,
	74,
	75,
	76,
	77,
	78,
	79,
	80,
	81,
	82,
	83,
	84,
	85,
	86,
	87,
	88,
	89,
	250,
	90,
	91,
	92,
	93,
	94,
	95,
	96,
	97,
	98,
	99,
	100,
	101,
	102,
	103,
	104,
	105,
	106,
	107,
	108,
	109,
	110,
	111,
	227,
	112,
	113,
	114,
	115,
	116,
	117,
	118,
	119,
	151,
	120,
	121,
	122,
	123,
	124,
	228,
	125,
	126,
	229,
	133,
	162,
	135,
	131,
	132,
	137,
	166,
	134,
	140,
	130,
	136,
	143,
	138,
	139,
	174,
	141,
	142,
	177,
	129,
	144,
	145,
	146,
	147,
	148,
	149,
	150,
	157,
	152,
	153,
	154,
	155,
	156,
	192,
	158,
	159,
	160,
	161,
	196,
	163,
	164,
	165,
	127,
	199,
	167,
	168,
	169,
	170,
	171,
	172,
	173,
	207,
	175,
	176,
	210,
	178,
	179,
	180,
	181,
	182,
	183,
	184,
	185,
	186,
	187,
	188,
	189,
	190,
	191,
	224,
	193,
	194,
	195,
	252,
	252,
	197,
	198,
	128,
	253,
	252,
	200,
	201,
	202,
	203,
	204,
	205,
	206,
	230,
	208,
	209,
	231,
	211,
	212,
	213,
	214,
	215,
	216,
	217,
	218,
	219,
	220,
	221,
	222,
	254,
	223,
	232,
	225,
	226,
	255,
};

/*-----------------------------------------------------------------------
|	mspal.h
|	
|	Standard MS Apps Palette.  v 1.01
|
|	#include this file in the same file as HPalCreateAppPalette
|	
|	WARNING:  Generated File!  DO NOT EDIT!
|	WARNING:  Palette MUST be created with HpalCreateAppPalette
|
---------------------------------------------------------------WESC----*/
unsigned char SEGXXX pal666[256][3] =
	{
	// R     G     B
	{0x00, 0x00, 0x00}, // 0 Sys Black	gray 0
	{0x80, 0x00, 0x00}, // 1 Sys Dk Red
	{0x00, 0x80, 0x00}, // 2 Sys Dk Green
	{0x80, 0x80, 0x00}, // 3 Sys Dk Yellow
	{0x00, 0x00, 0x80}, // 4 Sys Dk Blue
	{0x80, 0x00, 0x80}, // 5 Sys Dk Violet
	{0x00, 0x80, 0x80}, // 6 Sys Dk Cyan
	{0xc0, 0xc0, 0xc0}, // 7 Sys Lt Grey	gray 192
	{0xc0, 0xdc, 0xc0}, // 8 Sys 8
	{0xa6, 0xca, 0xf0}, // 9 Sys 9 (the first 10 are fixed by Windows)

	{0x04, 0x04, 0x04}, // 10 	gray 4
	{0x08, 0x08, 0x08}, // 11 	gray 8
	{0x0c, 0x0c, 0x0c}, // 12 	gray 12
	{0x11, 0x11, 0x11}, // 13 	gray 17
	{0x16, 0x16, 0x16}, // 14 	gray 22
	{0x1c, 0x1c, 0x1c}, // 15 	gray 28
	{0x22, 0x22, 0x22}, // 16 	gray 34
	{0x29, 0x29, 0x29}, // 17 	gray 41
	{0x55, 0x55, 0x55}, // 18 swapped so inversions look good	gray 85
	{0x4d, 0x4d, 0x4d}, // 19 swapped so inversions look good	gray 77
	{0x42, 0x42, 0x42}, // 20 swapped so inversions look good	gray 66
        {0x39, 0x39, 0x39}, // 21 swapped so inversions look good       gray 57
        {0x81, 0x81, 0x81}, // 22 Sys Dk Grey repeat    gray 128
        {0x81, 0x00, 0x00}, // 23 Sys Dk Red repeat
        {0x00, 0x81, 0x00}, // 24 Sys Dk Green repeat
        {0x81, 0x81, 0x00}, // 25 Sys Dk Yellow repeat
        {0x00, 0x00, 0x81}, // 26 Sys Dk Blue repeat
        {0x81, 0x00, 0x81}, // 27 Sys Dk Violet repeat
        {0x00, 0x81, 0x81}, // 28 Sys Dk Cyan repeat
	{0x33, 0x00, 0x00}, // 29 
	{0x66, 0x00, 0x00}, // 30 
	{0x99, 0x00, 0x00}, // 31 
	{0xcc, 0x00, 0x00}, // 32 
	{0x00, 0x33, 0x00}, // 33 
	{0x33, 0x33, 0x00}, // 34 
	{0x66, 0x33, 0x00}, // 35 
	{0x99, 0x33, 0x00}, // 36 
	{0xcc, 0x33, 0x00}, // 37 
	{0xff, 0x33, 0x00}, // 38 
	{0x00, 0x66, 0x00}, // 39 
	{0x33, 0x66, 0x00}, // 40 
	{0x66, 0x66, 0x00}, // 41 
	{0x99, 0x66, 0x00}, // 42 
	{0xcc, 0x66, 0x00}, // 43 
	{0xff, 0x66, 0x00}, // 44 
	{0x00, 0x99, 0x00}, // 45 
	{0x33, 0x99, 0x00}, // 46 
	{0x66, 0x99, 0x00}, // 47 
	{0x99, 0x99, 0x00}, // 48 
	{0xcc, 0x99, 0x00}, // 49 
	{0xff, 0x99, 0x00}, // 50 
	{0x00, 0xcc, 0x00}, // 51 
	{0x33, 0xcc, 0x00}, // 52 
	{0x66, 0xcc, 0x00}, // 53 
	{0x99, 0xcc, 0x00}, // 54 
	{0xcc, 0xcc, 0x00}, // 55 
	{0xff, 0xcc, 0x00}, // 56 
	{0x66, 0xff, 0x00}, // 57 
	{0x99, 0xff, 0x00}, // 58 
	{0xcc, 0xff, 0x00}, // 59 
	{0x00, 0x00, 0x33}, // 60 
	{0x33, 0x00, 0x33}, // 61 
	{0x66, 0x00, 0x33}, // 62 
	{0x99, 0x00, 0x33}, // 63 
	{0xcc, 0x00, 0x33}, // 64 
	{0xff, 0x00, 0x33}, // 65 
	{0x00, 0x33, 0x33}, // 66 
	{0x33, 0x33, 0x33}, // 67 	gray 51
	{0x66, 0x33, 0x33}, // 68 
	{0x99, 0x33, 0x33}, // 69 
	{0xcc, 0x33, 0x33}, // 70 
	{0xff, 0x33, 0x33}, // 71 
	{0x00, 0x66, 0x33}, // 72 
	{0x33, 0x66, 0x33}, // 73 
	{0x66, 0x66, 0x33}, // 74 
	{0x99, 0x66, 0x33}, // 75 
	{0xcc, 0x66, 0x33}, // 76 
	{0xff, 0x66, 0x33}, // 77 
	{0x00, 0x99, 0x33}, // 78 
	{0x33, 0x99, 0x33}, // 79 
	{0x66, 0x99, 0x33}, // 80 
	{0x99, 0x99, 0x33}, // 81 
	{0xcc, 0x99, 0x33}, // 82 
	{0xff, 0x99, 0x33}, // 83 
	{0x00, 0xcc, 0x33}, // 84 
	{0x33, 0xcc, 0x33}, // 85 
	{0x66, 0xcc, 0x33}, // 86 
	{0x99, 0xcc, 0x33}, // 87 
	{0xcc, 0xcc, 0x33}, // 88 
	{0xff, 0xcc, 0x33}, // 89 
	{0x33, 0xff, 0x33}, // 90 
	{0x66, 0xff, 0x33}, // 91 
	{0x99, 0xff, 0x33}, // 92 
	{0xcc, 0xff, 0x33}, // 93 
	{0xff, 0xff, 0x33}, // 94 
	{0x00, 0x00, 0x66}, // 95 
	{0x33, 0x00, 0x66}, // 96 
	{0x66, 0x00, 0x66}, // 97 
	{0x99, 0x00, 0x66}, // 98 
	{0xcc, 0x00, 0x66}, // 99 
	{0xff, 0x00, 0x66}, // 100 
	{0x00, 0x33, 0x66}, // 101 
	{0x33, 0x33, 0x66}, // 102 
	{0x66, 0x33, 0x66}, // 103 
	{0x99, 0x33, 0x66}, // 104 
	{0xcc, 0x33, 0x66}, // 105 
	{0xff, 0x33, 0x66}, // 106 
	{0x00, 0x66, 0x66}, // 107 
	{0x33, 0x66, 0x66}, // 108 
	{0x66, 0x66, 0x66}, // 109 	gray 102
	{0x99, 0x66, 0x66}, // 110 
	{0xcc, 0x66, 0x66}, // 111 
	{0x00, 0x99, 0x66}, // 112 
	{0x33, 0x99, 0x66}, // 113 
	{0x66, 0x99, 0x66}, // 114 
	{0x99, 0x99, 0x66}, // 115 
	{0xcc, 0x99, 0x66}, // 116 
	{0xff, 0x99, 0x66}, // 117 
	{0x00, 0xcc, 0x66}, // 118 
	{0x33, 0xcc, 0x66}, // 119 
	{0x99, 0xcc, 0x66}, // 120 
	{0xcc, 0xcc, 0x66}, // 121 
	{0xff, 0xcc, 0x66}, // 122 
	{0x00, 0xff, 0x66}, // 123 
	{0x33, 0xff, 0x66}, // 124 
	{0x99, 0xff, 0x66}, // 125 
	{0xcc, 0xff, 0x66}, // 126 
	{0xff, 0x00, 0xcc}, // 127 
	{0xcc, 0x00, 0xff}, // 128 
	{0x00, 0x99, 0x99}, // 129 
	{0x99, 0x33, 0x99}, // 130 
	{0x99, 0x00, 0x99}, // 131 
	{0xcc, 0x00, 0x99}, // 132 
	{0x00, 0x00, 0x99}, // 133 
	{0x33, 0x33, 0x99}, // 134 
	{0x66, 0x00, 0x99}, // 135 
	{0xcc, 0x33, 0x99}, // 136 
	{0xff, 0x00, 0x99}, // 137 
	{0x00, 0x66, 0x99}, // 138 
	{0x33, 0x66, 0x99}, // 139 
	{0x66, 0x33, 0x99}, // 140 
	{0x99, 0x66, 0x99}, // 141 
	{0xcc, 0x66, 0x99}, // 142 
	{0xff, 0x33, 0x99}, // 143 
	{0x33, 0x99, 0x99}, // 144 
	{0x66, 0x99, 0x99}, // 145 
	{0x99, 0x99, 0x99}, // 146 	gray 153
	{0xcc, 0x99, 0x99}, // 147 
	{0xff, 0x99, 0x99}, // 148 
	{0x00, 0xcc, 0x99}, // 149 
	{0x33, 0xcc, 0x99}, // 150 
	{0x66, 0xcc, 0x66}, // 151 
	{0x99, 0xcc, 0x99}, // 152 
	{0xcc, 0xcc, 0x99}, // 153 
	{0xff, 0xcc, 0x99}, // 154 
	{0x00, 0xff, 0x99}, // 155 
	{0x33, 0xff, 0x99}, // 156 
	{0x66, 0xcc, 0x99}, // 157 
	{0x99, 0xff, 0x99}, // 158 
	{0xcc, 0xff, 0x99}, // 159 
	{0xff, 0xff, 0x99}, // 160 
	{0x00, 0x00, 0xcc}, // 161 
	{0x33, 0x00, 0x99}, // 162 
	{0x66, 0x00, 0xcc}, // 163 
	{0x99, 0x00, 0xcc}, // 164 
	{0xcc, 0x00, 0xcc}, // 165 
	{0x00, 0x33, 0x99}, // 166 
	{0x33, 0x33, 0xcc}, // 167 
	{0x66, 0x33, 0xcc}, // 168 
	{0x99, 0x33, 0xcc}, // 169 
	{0xcc, 0x33, 0xcc}, // 170 
	{0xff, 0x33, 0xcc}, // 171 
	{0x00, 0x66, 0xcc}, // 172 
	{0x33, 0x66, 0xcc}, // 173 
	{0x66, 0x66, 0x99}, // 174 
	{0x99, 0x66, 0xcc}, // 175 
	{0xcc, 0x66, 0xcc}, // 176 
	{0xff, 0x66, 0x99}, // 177 
	{0x00, 0x99, 0xcc}, // 178 
	{0x33, 0x99, 0xcc}, // 179 
	{0x66, 0x99, 0xcc}, // 180 
	{0x99, 0x99, 0xcc}, // 181 
	{0xcc, 0x99, 0xcc}, // 182 
	{0xff, 0x99, 0xcc}, // 183 
	{0x00, 0xcc, 0xcc}, // 184 
	{0x33, 0xcc, 0xcc}, // 185 
	{0x66, 0xcc, 0xcc}, // 186 
	{0x99, 0xcc, 0xcc}, // 187 
	{0xcc, 0xcc, 0xcc}, // 188 	gray 204
	{0xff, 0xcc, 0xcc}, // 189 
	{0x00, 0xff, 0xcc}, // 190 
	{0x33, 0xff, 0xcc}, // 191 
	{0x66, 0xff, 0x99}, // 192 
	{0x99, 0xff, 0xcc}, // 193 
	{0xcc, 0xff, 0xcc}, // 194 
	{0xff, 0xff, 0xcc}, // 195 
	{0x33, 0x00, 0xcc}, // 196 
	{0x66, 0x00, 0xff}, // 197 
	{0x99, 0x00, 0xff}, // 198 
	{0x00, 0x33, 0xcc}, // 199 
	{0x33, 0x33, 0xff}, // 200 
	{0x66, 0x33, 0xff}, // 201 
	{0x99, 0x33, 0xff}, // 202 
	{0xcc, 0x33, 0xff}, // 203 
	{0xff, 0x33, 0xff}, // 204 
	{0x00, 0x66, 0xff}, // 205 
	{0x33, 0x66, 0xff}, // 206 
	{0x66, 0x66, 0xcc}, // 207 
	{0x99, 0x66, 0xff}, // 208 
	{0xcc, 0x66, 0xff}, // 209 
	{0xff, 0x66, 0xcc}, // 210 
	{0x00, 0x99, 0xff}, // 211 
	{0x33, 0x99, 0xff}, // 212 
	{0x66, 0x99, 0xff}, // 213 
	{0x99, 0x99, 0xff}, // 214 
	{0xcc, 0x99, 0xff}, // 215 
	{0xff, 0x99, 0xff}, // 216 
	{0x00, 0xcc, 0xff}, // 217 
	{0x33, 0xcc, 0xff}, // 218 
	{0x66, 0xcc, 0xff}, // 219 
	{0x99, 0xcc, 0xff}, // 220 
	{0xcc, 0xcc, 0xff}, // 221 
	{0xff, 0xcc, 0xff}, // 222 
	{0x33, 0xff, 0xff}, // 223 
	{0x66, 0xff, 0xcc}, // 224 
	{0x99, 0xff, 0xff}, // 225 
	{0xcc, 0xff, 0xff}, // 226 
	{0xff, 0x66, 0x66}, // 227 
	{0x66, 0xff, 0x66}, // 228 
	{0xff, 0xff, 0x66}, // 229 
	{0x66, 0x66, 0xff}, // 230 
	{0xff, 0x66, 0xff}, // 231 
	{0x66, 0xff, 0xff}, // 232 
        {0xc1, 0xc1, 0xc1}, // 233 Sys Dk Grey repeat inversion gray 192
	{0x5f, 0x5f, 0x5f}, // 234 	gray 95
	{0x77, 0x77, 0x77}, // 235 	gray 119
	{0x86, 0x86, 0x86}, // 236 	gray 134
	{0x96, 0x96, 0x96}, // 237 	gray 150
	{0xcb, 0xcb, 0xcb}, // 238 	gray 203
	{0xb2, 0xb2, 0xb2}, // 239 	gray 178
	{0xd7, 0xd7, 0xd7}, // 240 	gray 215
	{0xdd, 0xdd, 0xdd}, // 241 	gray 221
	{0xe3, 0xe3, 0xe3}, // 242 	gray 227
	{0xea, 0xea, 0xea}, // 243 	gray 234
	{0xf1, 0xf1, 0xf1}, // 244 	gray 241
        {0xf8, 0xf8, 0xf8}, // 245      gray 248

	{0xff, 0xfb, 0xf0}, // 246 Sys Reserved
	{0xa0, 0xa0, 0xa4}, // 247 Sys Reserved
	{0x80, 0x80, 0x80}, // 248 Sys Lt Gray	gray 128
	{0xff, 0x00, 0x00}, // 249 Sys Red
	{0x00, 0xff, 0x00}, // 250 Sys Green
	{0xff, 0xff, 0x00}, // 251 Sys Yellow
	{0x00, 0x00, 0xff}, // 252 Sys Blue
	{0xff, 0x00, 0xff}, // 253 Sys Violet
	{0x00, 0xff, 0xff}, // 254 Sys Cyan
	{0xff, 0xff, 0xff} // 255 Sys White	gray 255
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dith775.c ===
//////////////////////////////////////////////////////////////////////////////
//
//  DITH775.C  - full color dither (to a palette with 7 red, 7 green 5 blue
//               levels)
//
//  NOTE this file contains the 'C' code and DITH775A.ASM has the ASM code.
//
//  This file does the following dithering
//
//      24bpp   -> 8bpp
//      16bpp   -> 8bpp
//
//      8bpp    -> 4bpp     N/I
//      16bpp   -> 4bpp     N/I
//      24bpp   -> 4bpp     N/I
//
//  Using four different methods
//
//      Lookup      - fastest  1 table lookup per 16bpp pel  (160K for table)
//      Scale       - fast     2 table lookups per 16bpp pel (128K for tables)
//      Table       - fast     3 table lookups plus shifting (~1K for tables)
//
//  Lookup and Scale are 386 asm code *only* (in dith775a.asm)
//  Table is in 'C' and 386 asm.
//
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"
#include "dither.h"
#include "dith775.h"

//#define OLDDITHER

#ifdef WIN32
#define DITHER_DEFAULT      DITHER_TABLEC
#else
#define DITHER_DEFAULT      DITHER_SCALE
#endif


#define DITHER_TABLEC       0   // table based 'C' code
#define DITHER_TABLE        1   // table based assembler
#define DITHER_SCALE        2   // scale tables
#define DITHER_LOOKUP       3   // 5 lookup tables!

UINT   wDitherMethod = (UINT)-1;

LPVOID Dither16InitScale(void);
LPVOID Dither16InitLookup(void);

int         giDitherTableUsage = 0;
LPVOID      glpDitherTable;

static void Get775Colors(LPBITMAPINFOHEADER lpbi);

//////////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24C(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither24S(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

void FAR PASCAL Dither32C(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither32S(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

void FAR PASCAL Dither16C(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither16T(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither16L(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);
void FAR PASCAL Dither16S(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTableInit()
//
//////////////////////////////////////////////////////////////////////////////

static LPVOID DitherTableInit()
{
    // no need to re-init table.

    if (glpDitherTable || wDitherMethod != (UINT)-1)
    {
        giDitherTableUsage++;
        return glpDitherTable;
    }

    //
    //  choose a dither method
    //
    if (wDitherMethod == -1)
    {
        wDitherMethod = DITHER_DEFAULT;
    }

#ifdef DEBUG
    wDitherMethod = (int)GetProfileInt(TEXT("DrawDib"), TEXT("DitherMethod"), (UINT)wDitherMethod);
#endif

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLEC:
        case DITHER_TABLE:
            break;

#ifndef WIN32
        case DITHER_SCALE:
            glpDitherTable = Dither16InitScale();

            if (glpDitherTable == NULL)
                wDitherMethod = DITHER_TABLE;

            break;

        case DITHER_LOOKUP:
            glpDitherTable = Dither16InitLookup();

            if (glpDitherTable == NULL)
                wDitherMethod = DITHER_TABLE;

            break;
#endif // WIN32
    }

    giDitherTableUsage = 1;
    return glpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTableFree()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL DitherTableFree()
{
    if (giDitherTableUsage == 0 || --giDitherTableUsage > 0)
        return;

    if (glpDitherTable)
    {
        GlobalFreePtr(glpDitherTable);
        glpDitherTable = NULL;
	wDitherMethod = (UINT)-1;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither8Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    return DitherDeviceInit(lpbi, lpbiOut, lpDitherProc, lpDitherTable);
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither16Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get775Colors(lpbiOut);

    //
    //  choose a dither method
    //
    if (lpDitherTable == NULL)
        lpDitherTable = DitherTableInit();

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLEC:
            *lpDitherProc = Dither16C;
            break;
#ifndef WIN32
        case DITHER_TABLE:
            *lpDitherProc = Dither16T;
            break;

        case DITHER_SCALE:
            *lpDitherProc = Dither16S;
            break;

        case DITHER_LOOKUP:
            *lpDitherProc = Dither16L;
            break;
#endif // WIN32
    }

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16Term(LPVOID lpDitherTable)
{
    DitherTableFree();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither24Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    Get775Colors(lpbiOut);

    //
    //  choose a dither method
    //
    if (lpDitherTable == NULL)
        lpDitherTable = DitherTableInit();

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLE:
        case DITHER_TABLEC:
            *lpDitherProc = Dither24C;
            break;
#ifndef WIN32
        case DITHER_SCALE:
            *lpDitherProc = Dither24S;
            break;
#endif // WIN32
    }

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither24Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24Term(LPVOID lpDitherTable)
{
    DitherTableFree();
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Init()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL Dither32Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    // no need to re-init table.

    Get775Colors(lpbiOut);

    //
    //  choose a dither method
    //
    if (lpDitherTable == NULL)
        lpDitherTable = DitherTableInit();

    switch (wDitherMethod)
    {
        default:
        case DITHER_TABLE:
        case DITHER_TABLEC:
            *lpDitherProc = Dither32C;
            break;
#ifndef WIN32
        case DITHER_SCALE:
            *lpDitherProc = Dither32S;
            break;
#endif // WIN32
    }

    return lpDitherTable;
}

//////////////////////////////////////////////////////////////////////////////
//
//   Dither32Term()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32Term(LPVOID lpDitherTable)
{
    DitherTableFree();
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither16InitScale()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID Dither16InitScale()
{
    LPVOID p;
    LPBYTE pbLookup;
    LPWORD pwScale;
    UINT   r,g,b;

    p = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, 32768l*2+64000);

    if (p == NULL)
        return NULL;

    pwScale  = (LPWORD)p;

    for (r=0; r<32; r++)
        for (g=0; g<32; g++)
            for (b=0; b<32; b++)
                *pwScale++ = 1600 * r + 40 * g + b;

	    /* should this be WORD or UINT ? */
    pbLookup = (LPBYTE)(((WORD _huge *)p) + 32768l);

    for (r=0; r<40; r++)
        for (g=0; g<40; g++)
            for (b=0; b<40; b++)
                *pbLookup++ = lookup775[35*rlevel[r] + 5*glevel[g] + blevel[b]];

    return p;
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither16InitLookup()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID Dither16InitLookup()
{
    LPVOID p;
    BYTE _huge *pb;
    UINT r,g,b,i,j;

    p = GlobalAllocPtr(GHND|GMEM_SHARE, 32768l*5);

    if (p == NULL)
        return NULL;

    pb  = (BYTE _huge *)p;

    for (i=0; i<5; i++) {
        j = ((i < 3) ? i*2 : i*2-1);
        for (r=0; r<32; r++) {
            for (g=0; g<32; g++) {
                for (b=0; b<32; b++) {
                    *pb++ = lookup775[rlevel[r+i]*35 + glevel[g+i]*5 + blevel[b+j]];
		}
	    }
	}
    }

    return p;
}

//////////////////////////////////////////////////////////////////////////////
//
//   GetDithColors() get the dither palette
//
//////////////////////////////////////////////////////////////////////////////

static void Get775Colors(LPBITMAPINFOHEADER lpbi)
{
    LPRGBQUAD prgb = (LPRGBQUAD)(((LPBYTE)lpbi) + (UINT)lpbi->biSize);
    int       i;

    for (i=0; i<256; i++)
    {
        prgb[i].rgbRed      = dpal775[i][0];
        prgb[i].rgbGreen    = dpal775[i][1];
        prgb[i].rgbBlue     = dpal775[i][2];
        prgb[i].rgbReserved = 0;
    }

    lpbi->biClrUsed = 256;
}

#if 0
//////////////////////////////////////////////////////////////////////////////
//
//   CreateDith775Palette() create the dither palette
//
//////////////////////////////////////////////////////////////////////////////

HPALETTE FAR CreateDith775Palette()
{
    int      i;
    HDC      hdc;
    HPALETTE hpal;

    struct {
	WORD         palVersion;
	WORD         palNumEntries;
	PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palVersion = 0x300;
    pal.palNumEntries = 256;

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = dpal775[i][0];
        pal.palPalEntry[i].peGreen = dpal775[i][1];
        pal.palPalEntry[i].peBlue  = dpal775[i][2];
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
    }

#ifndef OLDDITHER
    //
    // our palette is built assuming the "cosmic" colors at the
    // beging and the end. so put the real mcoy there!
    //
    hdc = GetDC(NULL);
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
        GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);
    }
    ReleaseDC(NULL, hdc);
#endif

    hpal = CreatePalette((LPLOGPALETTE)&pal);

    return hpal;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  Dither24TC   - dither from 24 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither24C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    int r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 24)
        return;

    DstXE &= ~3;

    wWidthSrc = ((UINT)biSrc->biWidth*3+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*3 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*3;
    wWidthDst -= DstXE;

#define GET24() \
    b = (int)*pbS++; \
    g = (int)*pbS++; \
    r = (int)*pbS++;

#define DITHER24(mr, mg, mb) \
    GET24(); *pbD++ = (BYTE)lookup775[ rdith775[r +  mr] + gdith775[g +  mg] + ((b +  mb) >> 6) ];

    for (y=0; y<DstYE; y++) {
        switch (y & 3) {
        case 0:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24(  1,   1,   2);
            DITHER24( 17,  17,  26);
            DITHER24( 25,  25,  38);
            DITHER24( 41,  41,  62);
           }
        break;

        case 1:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24( 31,  31,  46);
            DITHER24( 36,  36,  54);
            DITHER24(  7,   7,  10);
            DITHER24( 12,  12,  18);
           }
        break;

        case 2:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24( 20,  20,  30);
            DITHER24(  4,   4,   6);
            DITHER24( 39,  39,  58);
            DITHER24( 23,  23,  34);
           }
        break;

        case 3:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER24( 33,  33,  50);
            DITHER24( 28,  28,  42);
            DITHER24( 15,  15,  22);
            DITHER24(  9,   9,  14);
           }
        break;
        } /*switch*/

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Dither32C   - dither from 32 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither32C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    int r,g,b;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 32)
        return;

    DstXE &= ~3;

    wWidthSrc = ((UINT)biSrc->biWidth*4+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*4 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*4;
    wWidthDst -= DstXE;

#define GET32() \
    b = (int)*pbS++; \
    g = (int)*pbS++; \
    r = (int)*pbS++; \
    pbS++;

#define DITHER32(mr, mg, mb) \
    GET32(); *pbD++ = (BYTE)lookup775[ rdith775[r +  mr] + gdith775[g +  mg] + ((b +  mb) >> 6) ];

    for (y=0; y<DstYE; y++) {
        switch (y & 3) {
        case 0:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32(  1,   1,   2);
            DITHER32( 17,  17,  26);
            DITHER32( 25,  25,  38);
            DITHER32( 41,  41,  62);
           }
        break;

        case 1:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32( 31,  31,  46);
            DITHER32( 36,  36,  54);
            DITHER32(  7,   7,  10);
            DITHER32( 12,  12,  18);
           }
        break;

        case 2:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32( 20,  20,  30);
            DITHER32(  4,   4,   6);
            DITHER32( 39,  39,  58);
            DITHER32( 23,  23,  34);
           }
        break;

        case 3:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER32( 33,  33,  50);
            DITHER32( 28,  28,  42);
            DITHER32( 15,  15,  22);
            DITHER32(  9,   9,  14);
           }
        break;
        } /*switch*/

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Dither16TC   - dither from 16 to 8 using the Table method in 'C' Code
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither16C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    int r,g,b;
    WORD w;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 16)
        return;

    DstXE = DstXE & ~3; // round down!

    wWidthSrc = ((UINT)biSrc->biWidth*2+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX   + (DWORD)(UINT)DstY * (DWORD)wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX*2 + (DWORD)(UINT)SrcY * (DWORD)wWidthSrc;

    wWidthSrc -= DstXE*2;
    wWidthDst -= DstXE;

#define GET16() \
    w = *((WORD _huge *)pbS)++;  \
    r = (int)((w >> 7) & 0xF8); \
    g = (int)((w >> 2) & 0xF8); \
    b = (int)((w << 3) & 0xF8);

#define DITHER16(mr, mg, mb) \
    GET16(); *pbD++ = (BYTE)lookup775[ rdith775[r +  mr] + gdith775[g +  mg] + ((b +  mb) >> 6)];

    for (y=0; y<DstYE; y++) {
        switch (y & 3) {
        case 0:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16(  1,   1,   2);
            DITHER16( 17,  17,  26);
            DITHER16( 25,  25,  38);
            DITHER16( 41,  41,  62);
            }
        break;

        case 1:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16( 31,  31,  46);
            DITHER16( 36,  36,  54);
            DITHER16(  7,   7,  10);
            DITHER16( 12,  12,  18);
           }
        break;

        case 2:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16( 20,  20,  30);
            DITHER16(  4,   4,   6);
            DITHER16( 39,  39,  58);
            DITHER16( 23,  23,  34);
           }
        break;

        case 3:
         for (x=0; x<DstXE; x+=4)
           {
            DITHER16( 33,  33,  50);
            DITHER16( 28,  28,  42);
            DITHER16( 15,  15,  22);
            DITHER16(  9,   9,  14);
           }
        break;
        } /*switch*/

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////

#if 0
//
//  this is the original code
//
//
void Dith775ScanLine(Rbuf, Gbuf, Bbuf, n, row, paloffset)
DWORD n; // pixels per row
int   *Rbuf, *Gbuf, *Bbuf;
int   row; // distance from top of image
WORD  *paloffset;
{
    int i;

    // DITHER(x,y,rgb)

    switch (row & 3)
    {
    case 0:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   +  1] + gdith775[Gbuf[i]   +  1] + ((Bbuf[i]   +  2) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] + 17] + gdith775[Gbuf[i+1] + 17] + ((Bbuf[i+1] + 26) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] + 25] + gdith775[Gbuf[i+2] + 25] + ((Bbuf[i+2] + 38) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] + 41] + gdith775[Gbuf[i+3] + 41] + ((Bbuf[i+3] + 62) >> 6) ];
       }
    break;

    case 1:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   + 31] + gdith775[Gbuf[i]   + 31] + ((Bbuf[i]   + 46) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] + 36] + gdith775[Gbuf[i+1] + 36] + ((Bbuf[i+1] + 54) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] +  7] + gdith775[Gbuf[i+2] +  7] + ((Bbuf[i+2] + 10) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] + 12] + gdith775[Gbuf[i+3] + 12] + ((Bbuf[i+3] + 18) >> 6) ];
       }
    break;

    case 2:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   + 20] + gdith775[Gbuf[i]   + 20] + ((Bbuf[i]   + 30) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] +  4] + gdith775[Gbuf[i+1] +  4] + ((Bbuf[i+1] +  6) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] + 39] + gdith775[Gbuf[i+2] + 39] + ((Bbuf[i+2] + 58) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] + 23] + gdith775[Gbuf[i+3] + 23] + ((Bbuf[i+3] + 34) >> 6) ];
       }
    break;

    case 3:
     for (i=0; i<n; i+=4)
       {
        paloffset[i]   = lookup775[ rdith775[Rbuf[i]   + 33] + gdith775[Gbuf[i]   + 33] + ((Bbuf[i]   + 50) >> 6) ];
        paloffset[i+1] = lookup775[ rdith775[Rbuf[i+1] + 28] + gdith775[Gbuf[i+1] + 28] + ((Bbuf[i+1] + 42) >> 6) ];
        paloffset[i+2] = lookup775[ rdith775[Rbuf[i+2] + 15] + gdith775[Gbuf[i+2] + 15] + ((Bbuf[i+2] + 22) >> 6) ];
        paloffset[i+3] = lookup775[ rdith775[Rbuf[i+3] +  9] + gdith775[Gbuf[i+3] +  9] + ((Bbuf[i+3] + 14) >> 6) ];
       }
    break;
    } /*switch*/
}
#endif

#if 0
    {
    HPALETTE hpalT;
    HWND     hwnd;
    BYTE     xlat[256];
    int      fh;
    static   BOOL fHack = TRUE;
    OFSTRUCT of;
    char     buf[80];

    //
    // convert palette to a palette that mappes 1:1 to the system
    // palette, this will allow us to draw faster
    //
    hwnd = GetActiveWindow();

    hdc = GetDC(hwnd);

    if (fHack && (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        fHack = FALSE;

        for (i=0; i<(int)pal.palNumEntries; i++)
        {
            pal.palPalEntry[i].peRed   = (BYTE)0;
            pal.palPalEntry[i].peGreen = (BYTE)0;
            pal.palPalEntry[i].peBlue  = (BYTE)0;
            pal.palPalEntry[i].peFlags = (BYTE)PC_RESERVED;
        }

        hpalT = CreatePalette((LPLOGPALETTE)&pal);
        hpalT = SelectPalette(hdc, hpalT, FALSE);
        RealizePalette(hdc);
        hpalT = SelectPalette(hdc, hpalT, FALSE);
        DeleteObject(hpalT);

        hpalT = SelectPalette(hdc, hpal, FALSE);
        RealizePalette(hdc);
        GetSystemPaletteEntries(hdc, 0, 256, pal.palPalEntry);
        SelectPalette(hdc, hpalT, FALSE);

        PostMessage(hwnd, WM_QUERYNEWPALETTE, 0, 0);

        for (i=0; i<256; i++)
        {
            // this wont work right for dup's in the palette
            j = GetNearestPaletteIndex(hpal,RGB(pal.palPalEntry[i].peRed,
                pal.palPalEntry[i].peGreen,pal.palPalEntry[i].peBlue));

            xlat[j] = (BYTE)i;
        }

        SetPaletteEntries(hpal, 0, 256, pal.palPalEntry);

        for (i=0; i < sizeof(lookup775)/sizeof(lookup775[0]); i++)
            lookup775[i] = xlat[lookup775[i]];

        //
        //  dump the new palette and lookup table out.
        //
        fh = OpenFile("c:/foo775.h", &of, OF_CREATE|OF_READWRITE);

        if (fh != -1)
        {
            wsprintf(buf, "BYTE lookup775[245] = {\r\n");
            _lwrite(fh, buf, lstrlen(buf));

            for (i=0; i < sizeof(lookup775)/sizeof(lookup775[0]); i++) {
                wsprintf(buf, "%3d,", lookup775[i]);

                if (i % 16 == 0 && i != 0)
                    _lwrite(fh, "\r\n", 2);

                _lwrite(fh, buf, lstrlen(buf));
            }

            wsprintf(buf, "}\r\n\r\nint dpal775[256][3] = {\r\n");
            _lwrite(fh, buf, lstrlen(buf));

            for (i=0; i < 256; i++) {
                wsprintf(buf, "{0x%02x, 0x%02x, 0x%02x},",
                    pal.palPalEntry[i].peRed,
                    pal.palPalEntry[i].peGreen,
                    pal.palPalEntry[i].peBlue);

                if (i % 4 == 0 && i != 0)
                    _lwrite(fh, "\r\n", 2);

                _lwrite(fh, buf, lstrlen(buf));
            }

            wsprintf(buf, "}\r\n");
            _lwrite(fh, buf, lstrlen(buf));

            _lclose(fh);
        }
    }

    ReleaseDC(hwnd, hdc);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dith666a.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: DITH666.ASM
;
; code to dither 16,24,32 bit DIBs to a 8bit DIB with a fixed palette
;
; NOTES:
;       this is a ASM version of the code found in dith666.c
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
	.xlist
        include cmacro32.inc
        include windows.inc
        .list

;-----------------------------------------------------------------------;
;
;   Halftone tables...
;
;	extern BYTE aHalftone8[3][4][4][256];
;       extern BYTE aHalftone5[3][4][4][256];
;       extern BYTE aHalftoneTranslate[256];
;
;   for 24 bit or 32 bit (256 levels):
;
;	pal8 = aHalftone8[0][x%4][y%4][r] +
;	       aHalftone8[1][x%4][y%4][g] +
;              aHalftone8[2][x%4][y%4][b];
;
;       pal8 = aHalftoneTranslate[pal8]
;
;   for 16 bit (32 levels):
;
;       pal8 = aHalftone5[0][x%4][y%4][rgb & 0xFF] +
;              aHalftone5[1][x%4][y%4][rgb&0xFF |] +
;              aHalftone5[2][x%4][y%4][rgb>>8];
;
;       pal8 = aHalftoneTranslate[pal8]
;
;   for fast 16 bit: (2x2 dither...)
;       pal8 = aHalftone16[y%1][x%1][rgb16]
;
;-----------------------------------------------------------------------;

sBegin  Data
sEnd    Data

        externB _aHalftone8                  ; in dith666.h
        externB _aTranslate666               ; in dith666.h

        aHalftone8R  equ <_aHalftone8>
        aHalftone8G  equ <_aHalftone8 + 4096>
        aHalftone8B  equ <_aHalftone8 + 8192>
        aTranslate   equ <_aTranslate666>

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        .386
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;
;   DITH16 row
;
;       dither 4 16 bit pels
;
;   Entry:
;       fs:esi  - 16bit pel to dither
;       es:edi  - 8bit dest
;       ds      - dither tables
;
;   Uses:
;       eax, ebx, edx, ebp, esi, edi, flags
;
;   Saves:
;       ecx, edi, es,ds,fs,gs,ss
;
;   access the dither tables like so:
;
;       0 1 0 1         0 = (0,0) (what dither matrix to look at)
;       2 3 2 3         1 = (0,1)
;       0 1 0 1         2 = (1,0)
;       2 3 2 3         3 = (1,1)
;
;   the table is layed out like so
;
;           yrrrrrgggggbbbbbx
;
;--------------------------------------------------------------------------;

DITH16  macro row

        mov     edx,fs:[esi+4]      ; edx = ?rrrrrgggggbbbbb?rrrrrgggggbbbbb
        or      dh,80h              ; edx = ?rrrrrgggggbbbbb1rrrrrgggggbbbbb
        add     edx,edx             ; edx = rrrrrgggggbbbbb1rrrrrgggggbbbbb0
        mov     bx,dx               ; ebx = 0000000000000000rrrrrgggggbbbbb0
        shr     edx,16              ; edx = 0000000000000000rrrrrgggggbbbbb1
        mov     al,[ebx + ((row and 1) * 65536)]
        mov     ah,[edx + ((row and 1) * 65536)]

        shl     eax,16

        mov     edx,fs:[esi]        ; edx = ?rrrrrgggggbbbbb?rrrrrgggggbbbbb
        or      dh,80h              ; edx = ?rrrrrgggggbbbbb1rrrrrgggggbbbbb
        shl     edx,1               ; edx = rrrrrgggggbbbbb1rrrrrgggggbbbbb0
        mov     bx,dx               ; ebx = 0000000000000000rrrrrgggggbbbbb0
        shr     edx,16              ; edx = 0000000000000000rrrrrgggggbbbbb1
        mov     al,[ebx + ((row and 1) * 65536)]
        mov     ah,[edx + ((row and 1) * 65536)]

        mov     es:[edi],eax

        add     esi,8
        add     edi,4
endm

;--------------------------------------------------------------------------;
;
;   Dither16()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

Dither16JumpTable label dword
        dd      Dither16Scan0
        dd      Dither16Scan3
        dd      Dither16Scan2
        dd      Dither16Scan1

cProc	Dither16,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;not used (for 8->4 bit dither)

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   We only handle (DstXE % 4) == 0 or 3.  If it's == 1 or 2, then we
;   round down, because otherwise we'd have to deal with half of a
;   dither cell on the end. 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
	inc	DstXE			; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,16
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither16Exit

        mov     ds,word ptr lpDitherTable[2]     ; DS --> dither table
        assumes ds,nothing

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither16Exit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither16Exit
        mov     DstXE,cx

        movzx   ecx, DstXE

        and     ebx, 011b               ; Get height mod 4
        xor     edx,edx                 ; set up for dither macros
        jmp     Dither16JumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither16OuterLoop:

        movzx   ecx, DstXE
        align   4
Dither16Scan0:
        DITH16  0
        dec     ecx
        jnz     Dither16Scan0

        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan1:
        DITH16  1
        dec     ecx
        jnz     Dither16Scan1

        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan2:
        DITH16  2
        dec     ecx
        jnz     Dither16Scan2

	add	esi, SrcInc
	add	edi, DstInc

        movzx   ecx, DstXE
	align	4
Dither16Scan3:
        DITH16  3
        dec     ecx
        jnz     Dither16Scan3

	add	esi, SrcInc
	add	edi, DstInc

	dec	DstYE
        jnz     Dither16OuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither16Exit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   GET24 - get a byte, every four times doing a LODSD
;
;--------------------------------------------------------------------------;

GET24_N = 0

GET24 macro dst
	if (GET24_N mod 4) eq 0
	    mov     edx,dword ptr fs:[esi]
	    mov     dst,dl
	    add     esi,4
        elseif (GET24_N mod 4) eq 1
	    mov     dst,dh
        elseif (GET24_N mod 4) eq 2
            shr     edx,16
	    mov     dst,dl
        elseif (GET24_N mod 4) eq 3
	    mov     dst,dh
        endif

	GET24_N = GET24_N + 1

        endm

;--------------------------------------------------------------------------;
;
;   Dither24() - dither 24 to 8
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

DITH24	macro row, col, dst

	GET24	bl	    ; get BLUE
        mov     dst,ds:[aHalftone8B + ebx + row*256 + col*256*4]

	GET24	bl	    ; get GREEN
        add     dst,ds:[aHalftone8G + ebx + row*256 + col*256*4]

	GET24	bl	    ; get RED
        add     dst,ds:[aHalftone8R + ebx + row*256 + col*256*4]

        mov     bl,dst
        mov     dst,ds:[aTranslate + ebx]
	endm

Dither24JumpTable label dword
	dd	Dither24Scan0
	dd	Dither24Scan3
	dd	Dither24Scan2
	dd	Dither24Scan1

cProc	Dither24,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;196k dither table

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;       inc     DstXE                   ; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,24
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither24Exit

        mov     ax, seg aHalftone8R
        mov     ds, ax
        assumes ds,nothing

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
	jz	Dither24Exit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
	jz	Dither24Exit
        mov     DstXE,cx

        and     ebx, 011b                ; Get height mod 4
	jmp	Dither24JumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither24OuterLoop:

        movzx   ecx, DstXE
        align   4
Dither24Scan0:
	DITH24	0,0,al
	DITH24	0,1,ah
	shl	eax,16
	DITH24	0,2,al
	DITH24	0,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither24Scan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither24Scan1:
	DITH24	1,0,al
	DITH24	1,1,ah
	shl	eax,16
	DITH24	1,2,al
	DITH24	1,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither24Scan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither24Scan2:
	DITH24	2,0,al
	DITH24	2,1,ah
	shl	eax,16
	DITH24	2,2,al
	DITH24	2,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither24Scan2
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither24Scan3:
	DITH24	3,0,al
	DITH24	3,1,ah
	shl	eax,16
	DITH24	3,2,al
	DITH24	3,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither24Scan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
	jnz	Dither24OuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither24Exit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   GET32 - get a byte from a 32 bit DIB
;
;--------------------------------------------------------------------------;

GET32_N = 0

GET32 macro dst
	if (GET32_N mod 3) eq 0
	    mov     edx,dword ptr fs:[esi]
	    mov     dst,dl
	    add     esi,4
        elseif (GET32_N mod 3) eq 1
	    mov     dst,dh
        elseif (GET32_N mod 3) eq 2
            shr     edx,16
	    mov     dst,dl
        endif

	GET32_N = GET32_N + 1

        endm

;--------------------------------------------------------------------------;
;
;   Dither32() - dither 32 to 8
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
	assumes es,nothing

DITH32	macro row, col, dst

	GET32	bl	    ; get BLUE
        mov     dst,ds:[aHalftone8B + ebx + row*256 + col*256*4]

	GET32	bl	    ; get GREEN
        add     dst,ds:[aHalftone8G + ebx + row*256 + col*256*4]

	GET32	bl	    ; get RED
        add     dst,ds:[aHalftone8R + ebx + row*256 + col*256*4]

        mov     bl,dst
        mov     dst,aTranslate[ebx]
	endm

Dither32JumpTable label dword
	dd	Dither32Scan0
	dd	Dither32Scan3
	dd	Dither32Scan2
	dd	Dither32Scan1

cProc	Dither32,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;196k dither table

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;       inc     DstXE                   ; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,32
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither32Exit

        mov     ax, seg aHalftone8R
        mov     ds, ax
        assumes ds,nothing

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
	jz	Dither32Exit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
	jz	Dither32Exit
        mov     DstXE,cx

        and     ebx, 011b                ; Get height mod 4
	jmp	Dither32JumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither32OuterLoop:

        movzx   ecx, DstXE
        align   4
Dither32Scan0:
	DITH32	0,0,al
	DITH32	0,1,ah
	shl	eax,16
	DITH32	0,2,al
        DITH32  0,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither32Scan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither32Scan1:
	DITH32	1,0,al
	DITH32	1,1,ah
	shl	eax,16
	DITH32	1,2,al
	DITH32	1,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither32Scan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither32Scan2:
	DITH32	2,0,al
	DITH32	2,1,ah
	shl	eax,16
	DITH32	2,2,al
	DITH32	2,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither32Scan2
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither32Scan3:
	DITH32	3,0,al
	DITH32	3,1,ah
	shl	eax,16
	DITH32	3,2,al
	DITH32	3,3,ah
        rol     eax,16
	mov	es:[edi], eax
	add	edi,4
        dec     ecx
	jnz	Dither32Scan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
	jnz	Dither32OuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither32Exit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   dither_init
;
;   init local frame vars for DitherDIB
;
;   ENTRY:
;       AX      -   source bpp
;       BX      -   dest bpp
;	ss:ebp	--> ditherdib frame
;
;   EXIT:
;       FS:ESI  --> source DIB start x,y
;       ES:EDI  --> dest DIB start x,y
;       DS:     --> dither tables (in DGROUP)
;
;--------------------------------------------------------------------------;

dither_init_error:
        stc
        ret

dither_init proc near

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   validate the DIBs
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   eax,ax
        movzx   ebx,bx
        movzx   ecx,cx
        movzx   edx,dx
        movzx   edi,di
        movzx   esi,si

        lfs     si, biSrc
        les     di, biDst

	mov	cx, es:[di].biBitCount	  ; dest must be right
        cmp     cx, bx
	jne	short dither_init_error

	mov	cx, fs:[si].biBitCount	 ; source must be right
        cmp     cx, ax
	jne	short dither_init_error

dither_init_bit_depth_ok:

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial source pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     eax,fs:[si].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
	mov	SrcWidth,eax
        mov     SrcInc,eax

        lfs     si,lpSrc

	movzx	edx,SrcY
        mul     edx
        add     esi,eax

        movzx   eax,SrcX
        mul     ecx
        shr     eax,3
        add     esi,eax

        movzx   eax, DstXE           ; SrcInc = SrcWidth - DstXE*bits/8
        mul     ecx
        shr     eax, 3
        sub     SrcInc, eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial dest pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     cx, es:[di].biBitCount
        mov     eax,es:[di].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
	mov	DstWidth,eax
        mov     DstInc,eax

        cmp     es:[edi].biHeight,0            ; init a upside down DIB
        jge     short @f
        movsx   ebx,DstY
        add     ebx,es:[edi].biHeight
        not     ebx
        mov     DstY,bx
        neg     DstWidth
        neg     DstInc
@@:
        les     di,lpDst

        movsx   edx,DstY
        mul     edx
	add	edi,eax

        movsx   eax,DstX
        mul     ecx
        shr     eax,3
        add     edi,eax

        movzx   eax, DstXE           ; DstInc = DstWidth - DstXE*bits/8
        mul     ecx
        shr     eax, 3
        sub     DstInc, eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

dither_init_exit:
        clc
        ret

dither_init endp

sEnd    CodeSeg

end

;--------------------------------------------------------------------------;
;
;   GET16  - read a RGB555 from the input
;
;   INPUT:
;       fs:[esi]        rgb555 DIB
;
;   OUTPUT:
;       edx             rgb555
;       esi+=2
;--------------------------------------------------------------------------;

GET16   macro col
if col and 1
        shr     edx,6                       ; get pel from last time
else
        mov     edx, dword ptr fs:[esi]     ; grab two pels
        add     esi,4
endif
        endm

;--------------------------------------------------------------------------;
;
;   DITH16 row, col
;
;       grab a 16 bit pel and dither it.
;
;   Entry:
;       fs:esi  - 16bit pel to dither
;       ds      - data segment
;
;   Returns:
;       al      - dithered pel (rotated into eax)
;
;   Uses:
;       eax, ebx, edx, ebp, esi, edi, flags
;
;   Saves:
;       ecx, edi, es,ds,fs,gs,ss
;
;--------------------------------------------------------------------------;

DITH16  macro row, col, dst

        GET16 col

        mov     bl,dl
        mov     dst,aHalftone5B[ebx + row*256 + col*256*4]

        mov     bl,dh
        add     dst,aHalftone5R[ebx + row*256 + col*256*4]

        and     bl,11b
        or      bl,dl

        add     dst,aHalftone5G[ebx + row*256 + col*256*4]

        endm

;--------------------------------------------------------------------------;
;
;   Dither16()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing        

Dither16JumpTable label dword
        dd      Dither16Scan0
        dd      Dither16Scan3
        dd      Dither16Scan2
        dd      Dither16Scan1

cProc	Dither16,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;not used (for 8->4 bit dither)

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   We only handle (DstXE % 4) == 0 or 3.  If it's == 1 or 2, then we
;   round down, because otherwise we'd have to deal with half of a
;   dither cell on the end. 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
	inc	DstXE			; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,16
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither16Exit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither16Exit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither16Exit
        mov     DstXE,cx

        and     ebx, 011b                ; Get height mod 4
        jmp     Dither16JumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither16OuterLoop:

        movzx   ecx, DstXE
        align   4
Dither16Scan0:
        DITH16  0,0,al
        DITH16  0,1,ah
        shl     eax,16
        DITH16  0,2,al
        DITH16  0,3,ah
        rol     eax,16
	mov	dword ptr es:[edi], eax
	add	edi,4
        dec     ecx
        jnz     Dither16Scan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan1:
        DITH16  1,0,al
        DITH16  1,1,ah
        shl     eax,16
        DITH16  1,2,al
        DITH16  1,3,ah
        rol     eax,16
	mov	dword ptr es:[edi], eax
	add	edi,4
        dec     ecx
        jnz     Dither16Scan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan2:
        DITH16  2,0,al
        DITH16  2,1,ah
        shl     eax,16
        DITH16  2,2,al
        DITH16  2,3,ah
        rol     eax,16
	mov	dword ptr es:[edi], eax
	add	edi,4
	dec	ecx
	jnz	Dither16Scan2
	add	esi, SrcInc
	add	edi, DstInc

	movzx	ecx, DstXE
	align	4
Dither16Scan3:
        DITH16  3,0,al
        DITH16  3,1,ah
        shl     eax,16
        DITH16  3,2,al
        DITH16  3,3,ah
        rol     eax,16
	mov	dword ptr es:[edi], eax
	add	edi,4
	dec	ecx
	jnz	Dither16Scan3
	add	esi, SrcInc
	add	edi, DstInc

	dec	DstYE
        jnz     Dither16OuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither16Exit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        pop     edi
        pop     esi
cEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dpal775.h ===
int dpal775[256][3] = {
         {0x00, 0x00, 0x00},    /* cosmic colors */
         {0x00, 0x00, 0x80},
	 {0x00, 0x80, 0x00},
         {0x00, 0x80, 0x80},
	 {0x80, 0x00, 0x00},
         {0x80, 0x00, 0x80},
         {0x80, 0x80, 0x00},
         {0x00, 0x00, 0x00},    // {0xc0, 0xc0, 0xc0},   //not used
         {0x00, 0x00, 0x00},    // {0xc0, 0xdc, 0xc0},   //not used
         {0x00, 0x00, 0x00},    // {0xf0, 0xca, 0xa6},   //not used
{0x00, 0x00, 0x40},
{0x00, 0x00, 0xc0},
{0x00, 0x2b, 0x00},
{0x00, 0x2b, 0x40},
{0x00, 0x2b, 0x80},
{0x00, 0x2b, 0xbf},
{0x00, 0x2b, 0xff},
{0x00, 0x55, 0x00},
{0x00, 0x55, 0x40},
{0x00, 0x55, 0x80},
{0x00, 0x55, 0xbf},
{0x00, 0x55, 0xff},
{0x00, 0x80, 0x40},
{0x00, 0x80, 0xbf},
{0x00, 0x80, 0xff},
{0x00, 0xaa, 0x00},
{0x00, 0xaa, 0x40},
{0x00, 0xaa, 0x80},
{0x00, 0xaa, 0xbf},
{0x00, 0xaa, 0xff},
{0x00, 0xd5, 0x00},
{0x00, 0xd5, 0x40},
{0x00, 0xd5, 0x80},
{0x00, 0xd5, 0xbf},
{0x00, 0xd5, 0xff},
{0x00, 0xff, 0x40},
{0x00, 0xff, 0x80},
{0x00, 0xff, 0xbf},
{0x2b, 0x00, 0x00},
{0x2b, 0x00, 0x40},
{0x2b, 0x00, 0x80},
{0x2b, 0x00, 0xbf},
{0x2b, 0x00, 0xff},
{0x2b, 0x2b, 0x00},
{0x2b, 0x2b, 0x40},
{0x2b, 0x2b, 0x80},
{0x2b, 0x2b, 0xbf},
{0x2b, 0x2b, 0xff},
{0x2b, 0x55, 0x00},
{0x2b, 0x55, 0x40},
{0x2b, 0x55, 0x80},
{0x2b, 0x55, 0xbf},
{0x2b, 0x55, 0xff},
{0x2b, 0x80, 0x00},
{0x2b, 0x80, 0x40},
{0x2b, 0x80, 0x80},
{0x2b, 0x80, 0xbf},
{0x2b, 0x80, 0xff},
{0x2b, 0xaa, 0x00},
{0x2b, 0xaa, 0x40},
{0x2b, 0xaa, 0x80},
{0x2b, 0xaa, 0xbf},
{0x2b, 0xaa, 0xff},
{0x2b, 0xd5, 0x00},
{0x2b, 0xd5, 0x40},
{0x2b, 0xd5, 0x80},
{0x2b, 0xd5, 0xbf},
{0x2b, 0xd5, 0xff},
{0x2b, 0xff, 0x00},
{0x2b, 0xff, 0x40},
{0x2b, 0xff, 0x80},
{0x2b, 0xff, 0xbf},
{0x2b, 0xff, 0xff},
{0x55, 0x00, 0x00},
{0x55, 0x00, 0x40},
{0x55, 0x00, 0x80},
{0x55, 0x00, 0xbf},
{0x55, 0x00, 0xff},
{0x55, 0x2b, 0x00},
{0x55, 0x2b, 0x40},
{0x55, 0x2b, 0x80},
{0x55, 0x2b, 0xbf},
{0x55, 0x2b, 0xff},
{0x55, 0x55, 0x00},
{0x55, 0x55, 0x40},
{0x55, 0x55, 0x80},
{0x55, 0x55, 0xbf},
{0x55, 0x55, 0xff},
{0x55, 0x80, 0x00},
{0x55, 0x80, 0x40},
{0x55, 0x80, 0x80},
{0x55, 0x80, 0xbf},
{0x55, 0x80, 0xff},
{0x55, 0xaa, 0x00},
{0x55, 0xaa, 0x40},
{0x55, 0xaa, 0x80},
{0x55, 0xaa, 0xbf},
{0x55, 0xaa, 0xff},
{0x55, 0xd5, 0x00},
{0x55, 0xd5, 0x40},
{0x55, 0xd5, 0x80},
{0x55, 0xd5, 0xbf},
{0x55, 0xd5, 0xff},
{0x55, 0xff, 0x00},
{0x55, 0xff, 0x40},
{0x55, 0xff, 0x80},
{0x55, 0xff, 0xbf},
{0x55, 0xff, 0xff},
{0x80, 0x00, 0x40},
{0x80, 0x00, 0xbf},
{0x80, 0x00, 0xff},
{0x80, 0x2b, 0x00},
{0x80, 0x2b, 0x40},
{0x80, 0x2b, 0x80},
{0x80, 0x2b, 0xbf},
{0x80, 0x2b, 0xff},
{0x80, 0x55, 0x00},
{0x80, 0x55, 0x40},
{0x80, 0x55, 0x80},
{0x80, 0x55, 0xbf},
{0x80, 0x55, 0xff},
{0x80, 0x80, 0x40},
{0x80, 0x80, 0xbf},
{0x80, 0x80, 0xff},
{0x80, 0xaa, 0x00},
{0x80, 0xaa, 0x40},
{0x80, 0xaa, 0x80},
{0x80, 0xaa, 0xbf},
{0x80, 0xaa, 0xff},
{0x80, 0xd5, 0x00},
{0x80, 0xd5, 0x40},
{0x80, 0xd5, 0x80},
{0x80, 0xd5, 0xbf},
{0x80, 0xd5, 0xff},
{0x80, 0xff, 0x00},
{0x80, 0xff, 0x40},
{0x80, 0xff, 0x80},
{0x80, 0xff, 0xbf},
{0x80, 0xff, 0xff},
{0xaa, 0x00, 0x00},
{0xaa, 0x00, 0x40},
{0xaa, 0x00, 0x80},
{0xaa, 0x00, 0xbf},
{0xaa, 0x00, 0xff},
{0xaa, 0x2b, 0x00},
{0xaa, 0x2b, 0x40},
{0xaa, 0x2b, 0x80},
{0xaa, 0x2b, 0xbf},
{0xaa, 0x2b, 0xff},
{0xaa, 0x55, 0x00},
{0xaa, 0x55, 0x40},
{0xaa, 0x55, 0x80},
{0xaa, 0x55, 0xbf},
{0xaa, 0x55, 0xff},
{0xaa, 0x80, 0x00},
{0xaa, 0x80, 0x40},
{0xaa, 0x80, 0x80},
{0xaa, 0x80, 0xbf},
{0xaa, 0x80, 0xff},
{0xaa, 0xaa, 0x00},
{0xaa, 0xaa, 0x40},
{0xaa, 0xaa, 0x80},
{0xaa, 0xaa, 0xbf},
{0xaa, 0xaa, 0xff},
{0xaa, 0xd5, 0x00},
{0xaa, 0xd5, 0x40},
{0xaa, 0xd5, 0x80},
{0xaa, 0xd5, 0xbf},
{0xaa, 0xd5, 0xff},
{0xaa, 0xff, 0x00},
{0xaa, 0xff, 0x40},
{0xaa, 0xff, 0x80},
{0xaa, 0xff, 0xbf},
{0xaa, 0xff, 0xff},
{0xd5, 0x00, 0x00},
{0xd5, 0x00, 0x40},
{0xd5, 0x00, 0x80},
{0xd5, 0x00, 0xbf},
{0xd5, 0x00, 0xff},
{0xd5, 0x2b, 0x00},
{0xd5, 0x2b, 0x40},
{0xd5, 0x2b, 0x80},
{0xd5, 0x2b, 0xbf},
{0xd5, 0x2b, 0xff},
{0xd5, 0x55, 0x00},
{0xd5, 0x55, 0x40},
{0xd5, 0x55, 0x80},
{0xd5, 0x55, 0xbf},
{0xd5, 0x55, 0xff},
{0xd5, 0x80, 0x00},
{0xd5, 0x80, 0x40},
{0xd5, 0x80, 0x80},
{0xd5, 0x80, 0xbf},
{0xd5, 0x80, 0xff},
{0xd5, 0xaa, 0x00},
{0xd5, 0xaa, 0x40},
{0xd5, 0xaa, 0x80},
{0xd5, 0xaa, 0xbf},
{0xd5, 0xaa, 0xff},
{0xd5, 0xd5, 0x00},
{0xd5, 0xd5, 0x40},
{0xd5, 0xd5, 0x80},
{0xd5, 0xd5, 0xbf},
{0xd5, 0xd5, 0xff},
{0xd5, 0xff, 0x00},
{0xd5, 0xff, 0x40},
{0xd5, 0xff, 0x80},
{0xd5, 0xff, 0xbf},
{0xd5, 0xff, 0xff},
{0xff, 0x00, 0x40},
{0xff, 0x00, 0x80},
{0xff, 0x00, 0xbf},
{0xff, 0x2b, 0x00},
{0xff, 0x2b, 0x40},
{0xff, 0x2b, 0x80},
{0xff, 0x2b, 0xbf},
{0xff, 0x2b, 0xff},
{0xff, 0x55, 0x00},
{0xff, 0x55, 0x40},
{0xff, 0x55, 0x80},
{0xff, 0x55, 0xbf},
{0xff, 0x55, 0xff},
{0xff, 0x80, 0x00},
{0xff, 0x80, 0x40},
{0xff, 0x80, 0x80},
{0xff, 0x80, 0xbf},
{0xff, 0x80, 0xff},
{0xff, 0xaa, 0x00},
{0xff, 0xaa, 0x40},
{0xff, 0xaa, 0x80},
{0xff, 0xaa, 0xbf},
{0xff, 0xaa, 0xff},
{0xff, 0xd5, 0x00},
{0xff, 0xd5, 0x40},
{0xff, 0xd5, 0x80},
{0xff, 0xd5, 0xbf},
{0xff, 0xd5, 0xff},
{0xff, 0xff, 0x40},
{0xff, 0xff, 0x80},
{0xff, 0xff, 0xbf},
{0x00, 0x00, 0x01}, /* six extra colors */
{0x00, 0x00, 0x02},
{0x00, 0x00, 0x03},
{0x00, 0x00, 0x04},
{0x00, 0x00, 0x05},
{0x00, 0x00, 0x06},
         {0x00, 0x00, 0x00},    //  {0xf0, 0xfb, 0xff}, //not used
         {0x00, 0x00, 0x00},    //  {0xa4, 0xa0, 0xa0}, //not used
         {0x80, 0x80, 0x80},
	 {0x00, 0x00, 0xff},
	 {0x00, 0xff, 0x00},
	 {0x00, 0xff, 0xff},
	 {0xff, 0x00, 0x00},
	 {0xff, 0x00, 0xff},
	 {0xff, 0xff, 0x00},
	 {0xff, 0xff, 0xff}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dith775.h ===
#ifdef OLDDITHER
    #include "dpal775.h"
    #include "look775.h"
    #include "dtab775.h"
#else

BYTE lookup775[245] = {
      0, 16, 10,  4,252, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 11,
     27, 12, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,250, 40,
     41, 42,254, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
     56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
     72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
     88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112, 13,113, 14,114,115,116,117,
    118,119,120,121,122,123,124,125, 15,126,248,127,128,129,130,131,
    132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,
    148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,
    164,165,166,247,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,
    196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,
    212,213,249,214,215,216,253,217,218,219,220,221,222,223,224,225,
    226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,
    251,242,243,244,255};

BYTE rdith775[297] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,35,35,35,35,35,
    35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
    35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
    35,35,35,35,35,70,70,70,70,70,70,70,70,70,70,70,
    70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,
    70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,
    105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,
    105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,
    105,105,105,105,105,105,105,105,105,105,140,140,140,140,140,140,
    140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,
    140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,
    140,140,140,140,140,175,175,175,175,175,175,175,175,175,175,175,
    175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,
    175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,210,
    210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,
    210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,210,
    210,210,210,210,210,210,210,210,210};

BYTE gdith775[297] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    5,5,5,5,5,10,10,10,10,10,10,10,10,10,10,10,
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
    15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
    15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
    15,15,15,15,15,15,15,15,15,15,20,20,20,20,20,20,
    20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
    20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
    20,20,20,20,20,25,25,25,25,25,25,25,25,25,25,25,
    25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
    25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,30,
    30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30,30};

BYTE dpal775[256][3] = {
    {0x00, 0x00, 0x00},{0xbf, 0x00, 0x00},{0x00, 0xbf, 0x00},{0xbf, 0xbf, 0x00},
    {0x00, 0x00, 0xbf},{0xbf, 0x00, 0xbf},{0x00, 0xbf, 0xbf},{0xc0, 0xc0, 0xc0},

    {0xc0, 0xdc, 0xc0},{0xa4, 0xc8, 0xf0},{0x00, 0x00, 0x7F},{0x00, 0x7F, 0x00},
    {0x00, 0x7F, 0x7F},{0x7F, 0x00, 0x00},{0x7F, 0x00, 0x7F},{0x7F, 0x7F, 0x00},
    {0x00, 0x00, 0x40},{0x00, 0x2b, 0x00},{0x00, 0x2b, 0x40},{0x00, 0x2b, 0x7F},
    {0x00, 0x2b, 0xbf},{0x00, 0x2b, 0xff},{0x00, 0x55, 0x00},{0x00, 0x55, 0x40},
    {0x00, 0x55, 0x7F},{0x00, 0x55, 0xbf},{0x00, 0x55, 0xff},{0x00, 0x7F, 0x40},
    {0x00, 0x7F, 0xbf},{0x00, 0x7F, 0xff},{0x00, 0xaa, 0x00},{0x00, 0xaa, 0x40},
    {0x00, 0xaa, 0x7F},{0x00, 0xaa, 0xbf},{0x00, 0xaa, 0xff},{0x00, 0xd5, 0x00},
    {0x00, 0xd5, 0x40},{0x00, 0xd5, 0x7F},{0x00, 0xd5, 0xbf},{0x00, 0xd5, 0xff},
    {0x00, 0xff, 0x40},{0x00, 0xff, 0x7F},{0x00, 0xff, 0xbf},{0x2b, 0x00, 0x00},
    {0x2b, 0x00, 0x40},{0x2b, 0x00, 0x7F},{0x2b, 0x00, 0xbf},{0x2b, 0x00, 0xff},
    {0x2b, 0x2b, 0x00},{0x2b, 0x2b, 0x40},{0x2b, 0x2b, 0x7F},{0x2b, 0x2b, 0xbf},
    {0x2b, 0x2b, 0xff},{0x2b, 0x55, 0x00},{0x2b, 0x55, 0x40},{0x2b, 0x55, 0x7F},
    {0x2b, 0x55, 0xbf},{0x2b, 0x55, 0xff},{0x2b, 0x7F, 0x00},{0x2b, 0x7F, 0x40},
    {0x2b, 0x7F, 0x7F},{0x2b, 0x7F, 0xbf},{0x2b, 0x7F, 0xff},{0x2b, 0xaa, 0x00},
    {0x2b, 0xaa, 0x40},{0x2b, 0xaa, 0x7F},{0x2b, 0xaa, 0xbf},{0x2b, 0xaa, 0xff},
    {0x2b, 0xd5, 0x00},{0x2b, 0xd5, 0x40},{0x2b, 0xd5, 0x7F},{0x2b, 0xd5, 0xbf},
    {0x2b, 0xd5, 0xff},{0x2b, 0xff, 0x00},{0x2b, 0xff, 0x40},{0x2b, 0xff, 0x7F},
    {0x2b, 0xff, 0xbf},{0x2b, 0xff, 0xff},{0x55, 0x00, 0x00},{0x55, 0x00, 0x40},
    {0x55, 0x00, 0x7F},{0x55, 0x00, 0xbf},{0x55, 0x00, 0xff},{0x55, 0x2b, 0x00},
    {0x55, 0x2b, 0x40},{0x55, 0x2b, 0x7F},{0x55, 0x2b, 0xbf},{0x55, 0x2b, 0xff},
    {0x55, 0x55, 0x00},{0x55, 0x55, 0x40},{0x55, 0x55, 0x7F},{0x55, 0x55, 0xbf},
    {0x55, 0x55, 0xff},{0x55, 0x7F, 0x00},{0x55, 0x7F, 0x40},{0x55, 0x7F, 0x7F},
    {0x55, 0x7F, 0xbf},{0x55, 0x7F, 0xff},{0x55, 0xaa, 0x00},{0x55, 0xaa, 0x40},
    {0x55, 0xaa, 0x7F},{0x55, 0xaa, 0xbf},{0x55, 0xaa, 0xff},{0x55, 0xd5, 0x00},
    {0x55, 0xd5, 0x40},{0x55, 0xd5, 0x7F},{0x55, 0xd5, 0xbf},{0x55, 0xd5, 0xff},
    {0x55, 0xff, 0x00},{0x55, 0xff, 0x40},{0x55, 0xff, 0x7F},{0x55, 0xff, 0xbf},
    {0x55, 0xff, 0xff},{0x7F, 0x00, 0x40},{0x7F, 0x00, 0xbf},{0x7F, 0x00, 0xff},
    {0x7F, 0x2b, 0x00},{0x7F, 0x2b, 0x40},{0x7F, 0x2b, 0x7F},{0x7F, 0x2b, 0xbf},
    {0x7F, 0x2b, 0xff},{0x7F, 0x55, 0x00},{0x7F, 0x55, 0x40},{0x7F, 0x55, 0x7F},
    {0x7F, 0x55, 0xbf},{0x7F, 0x55, 0xff},{0x7F, 0x7F, 0x40},{0x7F, 0x7F, 0xbf},
    {0x7F, 0x7F, 0xff},{0x7F, 0xaa, 0x00},{0x7F, 0xaa, 0x40},{0x7F, 0xaa, 0x7F},
    {0x7F, 0xaa, 0xbf},{0x7F, 0xaa, 0xff},{0x7F, 0xd5, 0x00},{0x7F, 0xd5, 0x40},
    {0x7F, 0xd5, 0x7F},{0x7F, 0xd5, 0xbf},{0x7F, 0xd5, 0xff},{0x7F, 0xff, 0x00},
    {0x7F, 0xff, 0x40},{0x7F, 0xff, 0x7F},{0x7F, 0xff, 0xbf},{0x7F, 0xff, 0xff},
    {0xaa, 0x00, 0x00},{0xaa, 0x00, 0x40},{0xaa, 0x00, 0x7F},{0xaa, 0x00, 0xbf},
    {0xaa, 0x00, 0xff},{0xaa, 0x2b, 0x00},{0xaa, 0x2b, 0x40},{0xaa, 0x2b, 0x7F},
    {0xaa, 0x2b, 0xbf},{0xaa, 0x2b, 0xff},{0xaa, 0x55, 0x00},{0xaa, 0x55, 0x40},
    {0xaa, 0x55, 0x7F},{0xaa, 0x55, 0xbf},{0xaa, 0x55, 0xff},{0xaa, 0x7F, 0x00},
    {0xaa, 0x7F, 0x40},{0xaa, 0x7F, 0x7F},{0xaa, 0x7F, 0xbf},{0xaa, 0x7F, 0xff},
    {0xaa, 0xaa, 0x00},{0xaa, 0xaa, 0x40},{0xaa, 0xaa, 0x7F},{0xaa, 0xaa, 0xbf},
    {0xaa, 0xaa, 0xff},{0xaa, 0xd5, 0x00},{0xaa, 0xd5, 0x40},{0xaa, 0xd5, 0x7F},
    {0xaa, 0xd5, 0xbf},{0xaa, 0xd5, 0xff},{0xaa, 0xff, 0x00},{0xaa, 0xff, 0x40},
    {0xaa, 0xff, 0x7F},{0xaa, 0xff, 0xbf},{0xaa, 0xff, 0xff},{0xd5, 0x00, 0x00},
    {0xd5, 0x00, 0x40},{0xd5, 0x00, 0x7F},{0xd5, 0x00, 0xbf},{0xd5, 0x00, 0xff},
    {0xd5, 0x2b, 0x00},{0xd5, 0x2b, 0x40},{0xd5, 0x2b, 0x7F},{0xd5, 0x2b, 0xbf},
    {0xd5, 0x2b, 0xff},{0xd5, 0x55, 0x00},{0xd5, 0x55, 0x40},{0xd5, 0x55, 0x7F},
    {0xd5, 0x55, 0xbf},{0xd5, 0x55, 0xff},{0xd5, 0x7F, 0x00},{0xd5, 0x7F, 0x40},
    {0xd5, 0x7F, 0x7F},{0xd5, 0x7F, 0xbf},{0xd5, 0x7F, 0xff},{0xd5, 0xaa, 0x00},
    {0xd5, 0xaa, 0x40},{0xd5, 0xaa, 0x7F},{0xd5, 0xaa, 0xbf},{0xd5, 0xaa, 0xff},
    {0xd5, 0xd5, 0x00},{0xd5, 0xd5, 0x40},{0xd5, 0xd5, 0x7F},{0xd5, 0xd5, 0xbf},
    {0xd5, 0xd5, 0xff},{0xd5, 0xff, 0x00},{0xd5, 0xff, 0x40},{0xd5, 0xff, 0x7F},
    {0xd5, 0xff, 0xbf},{0xd5, 0xff, 0xff},{0xff, 0x00, 0x40},{0xff, 0x00, 0x7F},
    {0xff, 0x00, 0xbf},{0xff, 0x2b, 0x00},{0xff, 0x2b, 0x40},{0xff, 0x2b, 0x7F},
    {0xff, 0x2b, 0xbf},{0xff, 0x2b, 0xff},{0xff, 0x55, 0x00},{0xff, 0x55, 0x40},
    {0xff, 0x55, 0x7F},{0xff, 0x55, 0xbf},{0xff, 0x55, 0xff},{0xff, 0x7F, 0x00},
    {0xff, 0x7F, 0x40},{0xff, 0x7F, 0x7F},{0xff, 0x7F, 0xbf},{0xff, 0x7F, 0xff},
    {0xff, 0xaa, 0x00},{0xff, 0xaa, 0x40},{0xff, 0xaa, 0x7F},{0xff, 0xaa, 0xbf},
    {0xff, 0xaa, 0xff},{0xff, 0xd5, 0x00},{0xff, 0xd5, 0x40},{0xff, 0xd5, 0x7F},
    {0xff, 0xd5, 0xbf},{0xff, 0xd5, 0xff},{0xff, 0xff, 0x40},{0xff, 0xff, 0x7F},
    {0xff, 0xff, 0xbf},{0x00, 0x00, 0x01},{0xff, 0xfb, 0xf0},{0xa0, 0xa0, 0xa4},

    {0x80, 0x80, 0x80},{0xff, 0x00, 0x00},{0x00, 0xff, 0x00},{0xff, 0xff, 0x00},
    {0x00, 0x00, 0xff},{0xff, 0x00, 0xff},{0x00, 0xff, 0xff},{0xff, 0xff, 0xff}};
#endif

int rlevel[40] =
    {0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,6};

int glevel[40] =
    {0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,6};

int blevel[40] =
    {0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dith775a.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: DITH775.ASM
;
; code to dither 16 or 24 bit DIBs to a 8bit DIB with a fixed palette
;
; NOTES:
;       this is a ASM version of the code found in dith775.c
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
	.xlist
        include cmacro32.inc
        include windows.inc
        .list

        externA __AHINCR
        externA __AHSHIFT

sBegin  Data
        externB _lookup775      ; in look775.h
        externB _rdith775       ; in dtab775.h
        externB _gdith775       ; in dtab775.h
sEnd    Data

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        .386
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;
;   GET16  - read a RGB555 from the input
;
;   INPUT:
;       fs:[esi]        rgb555 DIB
;
;   OUTPUT:
;       bx              rgb555
;
;--------------------------------------------------------------------------;

GET16   macro col
if col and 1
        shr     ebx,16                      ; get pel from last time
else
        mov     ebx, dword ptr fs:[esi]     ; grab two pels
        add     esi,4
endif
        endm

;--------------------------------------------------------------------------;
;
;   DITH m1, m2, row, col
;
;       grab a 16 bit pel and dither it.
;
;       m1 and m2 are the magic dither table offsets.
;
;       here is the 'C' code we are emulating
;
;           w = *((WORD huge *)pbS)++;
;           r = (int)((w >> 7) & 0xF8);
;           g = (int)((w >> 2) & 0xF8);
;           b = (int)((w << 3) & 0xF8);
;
;           *pbD++ = (BYTE)lookup775[ rdith775[r + m1] + gdith775[g + m1] + ((b +  m2) >> 6) ];
;
;       the 'magic' values vary over a 4x4 block
;
;       m1:  1  17  25  41      m2:  2  26  38  62
;           31  36   7  12          46  54  19  18
;           20   4  39  23          30   6  58  34
;           33  28  15   9          50  42  22  14
;
;
;       for a 2x2 dither use the following numbers:
;
;       m1:  5  27  m2:  8  40
;           38  16      56  24
;
;       m1:  1  41  m2:  2  62
;           33   9      50  14
;
;   NOTE:
;       !!! the lookup tables should be BYTEs not INTs !!!
;
;   Entry:
;       m1, m2  - magic values
;       fs:esi  - 16bit pel to dither
;       ds      - data segment
;
;   Returns:
;       al      - dithered pel (rotated into eax)
;
;   Uses:
;       eax, ebx, edx, ebp, esi, edi, flags
;
;   Saves:
;       ecx, edi, es,ds,fs,gs,ss
;
;--------------------------------------------------------------------------;

DITH16  macro m1, m2, row, col

        GET16 col

        mov     al, bl                      ; get blue
        and     al, 1Fh
        add     al, (m2 shr 3)
        shr     al, 3

        shr     bx, 2                       ; get green
        mov     dl, bl
        and     dx, 0F8h

        shr     bx, 5                       ; get red
        and     bx, 0F8h

        add     al, _rdith775[bx + m1]
        mov     bl, dl
        add     al, _gdith775[bx + m1]
        mov     bl, al

if col and 1
        mov     al, byte ptr _lookup775[bx]
        xchg    al, ah
        ror     eax,16                      ; rotate pixel into eax
else
        mov     ah, byte ptr _lookup775[bx]
endif
        endm

;--------------------------------------------------------------------------;
;
;   Dither16()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing        

Dither16TJumpTable label dword
        dd      Dither16Scan0
        dd      Dither16Scan3
        dd      Dither16Scan2
        dd      Dither16Scan1

cProc   Dither16T,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;not used (for 8->4 bit dither)

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
;       push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   We only handle (DstXE % 4) == 0 or 3.  If it's == 1 or 2, then we
;   round down, because otherwise we'd have to deal with half of a
;   dither cell on the end. 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
	inc	DstXE			; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,16
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither16Exit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither16Exit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither16Exit
        mov     DstXE,cx

        and     ebx, 011b                ; Get height mod 4
        jmp     Dither16TJumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither16OuterLoop:

        movzx   ecx, DstXE
        align   4
Dither16Scan0:
        DITH16   1  2 0 0                  ;        DITH16   1  2 0 0
        DITH16  17 26 0 1                  ;        DITH16  41 62 0 1
        DITH16  25 38 0 2                  ;        DITH16   1  2 0 2
        DITH16  41 62 0 3                  ;        DITH16  41 62 0 3
        stos    dword ptr es:[edi]
        dec     ecx
        jnz     Dither16Scan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan1:
        DITH16  31 46 1 0                  ;        DITH16  33 50 1 0
        DITH16  36 54 1 1                  ;        DITH16   9 14 1 1
        DITH16   7 19 1 2                  ;        DITH16  33 50 1 2
        DITH16  12 18 1 3                  ;        DITH16   9 14 1 3
        stos    dword ptr es:[edi]
        dec     ecx
        jnz     Dither16Scan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan2:
        DITH16  20 30 2 0                  ;        DITH16   1  2 2 0
        DITH16   4  6 2 1                  ;        DITH16  41 62 2 1
        DITH16  39 58 2 2                  ;        DITH16   1  2 2 2
        DITH16  23 34 2 3                  ;        DITH16  41 62 2 3
        stos    dword ptr es:[edi]
        dec     ecx
        jnz     Dither16Scan2
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16Scan3:
        DITH16  33 50 3 0                  ;        DITH16  33 50 3 0
        DITH16  28 42 3 1                  ;        DITH16   9 14 3 1
        DITH16  15 22 3 2                  ;        DITH16  33 50 3 2
        DITH16   9 14 3 3                  ;        DITH16   9 14 3 3
        stos    dword ptr es:[edi]
        dec     ecx
        jnz     Dither16Scan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
        jnz     Dither16OuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither16Exit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
;       pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   Dither16L() - dither using lookup table(s)
;
;       using dither matrix:
;
;           0 2 2 4
;           3 4 0 1 [or possibly 3 3 1 1 -- see which looks better]
;           2 0 4 2
;           3 3 1 1
;
;       the dither matrix determines which lookup table to use.
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

FOO     macro   reg, err
if err eq 0
        mov     reg, ds:[ebx]
elseif err eq 1
        mov     reg, ds:[ebx + edx]
elseif err eq 2
        mov     reg, ds:[ebx + 2*edx]
elseif err eq 3
        or      bh,80h
        mov     reg, ds:[ebx + 2*edx]
elseif err eq 4
        mov     reg, ds:[ebx + 4*edx]
else
        bark
endif
        endm


DITH16L macro m1, m2, m3, m4
        mov     bx, fs:[esi + 4]
        and     bh, ch
        FOO     al, m3

        mov     bx, fs:[esi + 6]
        and     bh, ch
        FOO     ah, m4

        shl     eax,16

        mov     bx, fs:[esi + 0]
        and     bh, ch
        FOO     al, m1

        mov     bx, fs:[esi + 2]
        and     bh, ch
        FOO     ah, m2

        mov     dword ptr es:[edi], eax

        add     edi, 4
        add     esi, 8
        endm

Dither16LJumpTable label dword
        dd      Dither16lScan0
        dd      Dither16lScan3
        dd      Dither16lScan2
        dd      Dither16lScan1

cProc   Dither16L,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;196k dither table

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   We only handle (DstXE % 4) == 0 or 3.  If it's == 1 or 2, then we
;   round down, because otherwise we'd have to deal with half of a
;   dither cell on the end. 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
	inc	DstXE			; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,16
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither16lExit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither16lExit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither16lExit
        mov     DstXE,cx

        mov     ds, lpDitherTable.sel   ; DS --> dither table
        mov     ax, ds
        add     ax, __AHINCR
        mov     gs, ax

        xor     ebx, ebx
        mov     edx, 32768
        mov     ch,7Fh

        and     ebx, 011b                ; Get height mod 4
        jmp     Dither16LJumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither16lOuterLoop:

        mov     cl, byte ptr DstXE
        align   4
Dither16lScan0:
        DITH16L 0 2 2 4
        dec     cl
        jnz     short Dither16lScan0
        add     esi, SrcInc
        add     edi, DstInc

        mov     cl, byte ptr DstXE
        align   4
Dither16lScan1:
        DITH16L 3 4 0 1
        dec     cl
        jnz     short Dither16lScan1
        add     esi, SrcInc
        add     edi, DstInc

        mov     cl, byte ptr DstXE
        align   4
Dither16lScan2:
        DITH16L 2 0 4 2
        dec     cl
        jnz     short Dither16lScan2
        add     esi, SrcInc
        add     edi, DstInc

        mov     cl, byte ptr DstXE
        align   4
Dither16lScan3:
        DITH16L 3 3 1 1
        dec     cl
        jnz     short Dither16lScan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
        jnz     Dither16lOuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither16lExit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        mov     gs,ax
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   Dither16S() - dither using scale table(s)
;
;       pel8 = lookup[scale[rgb555] + error]
;
;   using error matrix:
;
;       0       3283    4924    8207
;       6565    6566    1641    1642
;       3283    0       8207    4924
;       6566    4925    3282    1641
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

DITH16S macro m1, m2, m3, m4
        mov     ebx, fs:[esi + 4]           ; grab rgb555
        add     bx, bx
        mov     bx, ds:[bx]                 ; scale it
        mov     al, gs:[bx + m3]            ; dither it with error

        shr     ebx,16
;       mov     bx, fs:[esi + 6]            ; grab rgb555
        add     bx, bx
        mov     bx, ds:[bx]                 ; scale it
        mov     ah, gs:[bx + m4]            ; dither it with error

        shl     eax,16

        mov     ebx, fs:[esi + 0]           ; grab rgb555
        add     bx, bx
        mov     bx, ds:[bx]                 ; scale it
        mov     al, gs:[bx + m1]            ; dither it with error

        shr     ebx,16
;       mov     bx, fs:[esi + 2]            ; grab rgb555
        add     bx, bx
        mov     bx, ds:[bx]                 ; scale it
        mov     ah, gs:[bx + m2]            ; dither it with error

        mov     dword ptr es:[edi], eax

        add     edi, 4
        add     esi, 8
        endm

Dither16SJumpTable label dword
        dd      Dither16sScan0
        dd      Dither16sScan3
        dd      Dither16sScan2
        dd      Dither16sScan1

cProc   Dither16S,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;196k dither table

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
	inc	DstXE			; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,16
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither16sExit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither16sExit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither16sExit
        mov     DstXE,cx

        mov     ds, lpDitherTable.sel   ; DS --> dither table
        mov     ax, ds
        add     ax, __AHINCR
        mov     gs, ax

        and     ebx, 011b                ; Get height mod 4
        jmp     Dither16SJumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither16sOuterLoop:

        movzx   ecx, DstXE
        align   4
Dither16sScan0:
        DITH16S 0       3283    4924    8207
        dec     ecx
        jnz     short Dither16sScan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16sScan1:
        DITH16S 6565    6566    1641    1642
        dec     ecx
        jnz     short Dither16sScan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16sScan2:
        DITH16S 3283    0       8207    4924
        dec     ecx
        jnz     short Dither16sScan2
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither16sScan3:
        DITH16S 6566    4925    3282    1641
        dec     ecx
        jnz     short Dither16sScan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
        jnz     Dither16sOuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither16sExit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        mov     gs,ax
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   LODSB32 - get a byte, every four times doing a LODSD
;
;--------------------------------------------------------------------------;

LODSB32_N = 0

LODSB32 macro
        if (LODSB32_N mod 4) eq 0
;;          lods dword ptr ds:[esi]
            mov     eax,dword ptr fs:[esi]
            add     esi,4
        else
            ror     eax,8
        endif

        LODSB32_N = LODSB32_N + 1

        endm

;--------------------------------------------------------------------------;
;
;   Dither24S() - dither using scale table(s)
;
;       pel8 = lookup[scale[rgb555] + error]
;
;   using error matrix:
;
;       0       3283    4924    8207
;       6565    6566    1641    1642
;       3283    0       8207    4924
;       6566    4925    3282    1641
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

GET24   macro
        LODSB32             ; get BLUE
        and     al,0F8h
        mov     bl,al
        LODSB32             ; get GREEN
        mov     bh,al
        shr     bh,3
        shr     ebx,2
        LODSB32             ; get RED
        and     al,0F8h
        or      bh,al
        endm

DITH24S macro m1, m2, m3, m4

        GET24                               ; grab rgb555*2
        movzx   ebx, word ptr ds:[ebx]      ; scale it
        mov     dl, ds:[ebx + m1 + 65536]   ; dither it with error

        GET24                               ; grab rgb555*2
        movzx   ebx, word ptr ds:[ebx]      ; scale it
        mov     dh, ds:[ebx + m2 + 65536]   ; dither it with error

        ror     edx,16                      ; save ax

        GET24                               ; grab rgb555
        movzx   ebx, word ptr ds:[ebx]      ; scale it
        mov     dl, ds:[ebx + m3 + 65536]   ; dither it with error

        GET24                               ; grab rgb555
        movzx   ebx, word ptr ds:[ebx]      ; scale it
        mov     dh, ds:[ebx + m4 + 65536]   ; dither it with error

        ror     edx,16                      ; get eax right
        mov     dword ptr es:[edi], edx     ; store four pixels
        add     edi, 4
        endm

Dither24SJumpTable label dword
        dd      Dither24sScan0
        dd      Dither24sScan3
        dd      Dither24sScan2
        dd      Dither24sScan1

cProc   Dither24S,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;196k dither table

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;       inc     DstXE                   ; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,24
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither24sExit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither24sExit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither24sExit
        mov     DstXE,cx

        mov     ds, lpDitherTable.sel   ; DS --> dither table
        mov     ax, ds
        add     ax, __AHINCR
        mov     gs, ax

        and     ebx, 011b                ; Get height mod 4
        jmp     Dither24SJumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither24sOuterLoop:

        movzx   ecx, DstXE
        align   4
Dither24sScan0:
        DITH24S 0       3283    4924    8207
        dec     ecx
        jnz     Dither24sScan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither24sScan1:
        DITH24S 6565    6566    1641    1642
        dec     ecx
        jnz     Dither24sScan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither24sScan2:
        DITH24S 3283    0       8207    4924
        dec     ecx
        jnz     Dither24sScan2
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither24sScan3:
        DITH24S 6566    4925    3282    1641
        dec     ecx
        jnz     Dither24sScan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
        jnz     Dither24sOuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither24sExit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        mov     gs,ax
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   Dither32S() - dither using scale table(s)
;
;       pel8 = lookup[scale[rgb555] + error]
;
;   using error matrix:
;
;       0       3283    4924    8207
;       6565    6566    1641    1642
;       3283    0       8207    4924
;       6566    4925    3282    1641
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

GET32   macro
if 1
        mov     bx,fs:[esi+0]   ; ebx = ????????????????GGGGGgggBBBBBbbb
        shr     bh,3            ; ebx = 000?????????????000GGGGGBBBBBbbb
        shr     bx,3            ; ebx = 000?????????????000000GGGGGBBBBB
        mov     al,fs:[esi+2]   ; eax = ????????????????????????RRRRRrrr
        and     al,0F8h         ; eax = ????????????????????????RRRRR000
        shr     al,1            ; eax = ????????????????????????0RRRRR00
        or      bh,al           ; ebx = 000?????????????0RRRRRGGGGGBBBBB
        add     ebx,ebx         ; ebx = 00?????????????0RRRRRGGGGGBBBBB0
        add     esi,4
else
        mov     eax,fs:[esi]        ; eax = RRRRRrrrGGGGGgggBBBBBbbb
        add     esi,2
        mov     bl,al               ; ebx = 00000000????????BBBBBbbb
        shr     eax,8               ; eax = 00000000RRRRRrrrGGGGGggg
        shr     ah,3                ; eax = 00000000000RRRRRGGGGGggg
        shl     ax,5                ; eax = 000000RRRRRGGGGGggg00000
endif
        endm

DITH32S macro m1, m2, m3, m4

        GET32                               ; grab rgb555*2
        mov     bx, word ptr ds:[ebx]       ; scale it
        mov     dl, ds:[ebx + m1 + 65536]   ; dither it with error

        GET32                               ; grab rgb555*2
        mov     bx, word ptr ds:[ebx]       ; scale it
        mov     dh, ds:[ebx + m2 + 65536]   ; dither it with error

        ror     edx,16                      ; save ax

        GET32                               ; grab rgb555
        mov     bx, word ptr ds:[ebx]       ; scale it
        mov     dl, ds:[ebx + m3 + 65536]   ; dither it with error

        GET32                               ; grab rgb555
        movzx   bx, word ptr ds:[ebx]       ; scale it
        mov     dh, ds:[ebx + m4 + 65536]   ; dither it with error

        ror     edx,16                      ; get eax right
        mov     dword ptr es:[edi], edx     ; store four pixels
        add     edi, 4
        endm

Dither32SJumpTable label dword
        dd      Dither32sScan0
        dd      Dither32sScan3
        dd      Dither32sScan2
        dd      Dither32sScan1

cProc   Dither32S,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;196k dither table

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;       inc     DstXE                   ; Make the == 3 mod 4 case work
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,32
        mov     ebx,8
        call    dither_init             ; init all the frame variables
        jc      Dither32sExit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, DstYE               ; divide by 4
        mov     ebx, ecx

        add     ecx, 3                   ; be sure to round up
        shr     ecx, 2
        jz      Dither32sExit
        mov     DstYE, cx

        movzx   ecx, DstXE               ; divide by 4
        shr     ecx,2
        jz      Dither32sExit
        mov     DstXE,cx

        mov     ds, lpDitherTable.sel   ; DS --> dither table
        mov     ax, ds
        add     ax, __AHINCR
        mov     gs, ax

        and     ebx, 011b                ; Get height mod 4
        jmp     Dither32SJumpTable[ebx*4]

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        align   4
Dither32sOuterLoop:

        movzx   ecx, DstXE
        align   4
Dither32sScan0:
        DITH32S 0       3283    4924    8207
        dec     ecx
        jnz     Dither32sScan0
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither32sScan1:
        DITH32S 6565    6566    1641    1642
        dec     ecx
        jnz     Dither32sScan1
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither32sScan2:
        DITH32S 3283    0       8207    4924
        dec     ecx
        jnz     Dither32sScan2
        add     esi, SrcInc
        add     edi, DstInc

        movzx   ecx, DstXE
        align   4
Dither32sScan3:
        DITH32S 6566    4925    3282    1641
        dec     ecx
        jnz     Dither32sScan3
        add     esi, SrcInc
        add     edi, DstInc

        dec     DstYE
        jnz     Dither32sOuterLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Dither32sExit:
        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy
        mov     gs,ax
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   dither_init
;
;   init local frame vars for DitherDIB
;
;   ENTRY:
;       AX      -   source bpp
;       BX      -   dest bpp
;       ss:bp   --> ditherdib frame
;
;   EXIT:
;       FS:ESI  --> source DIB start x,y
;       ES:EDI  --> dest DIB start x,y
;       DS:     --> dither tables (in DGROUP)
;
;--------------------------------------------------------------------------;

dither_init_error:
        stc
        ret

dither_init proc near

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   validate the DIBs
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   eax,ax
        movzx   ebx,bx
        movzx   ecx,cx
        movzx   edx,dx
        movzx   edi,di
        movzx   esi,si

        lfs     si, biSrc
        les     di, biDst

        mov     cx, es:[di].biBitCount    ; dest must be right
        cmp     cx, bx
        jne     dither_init_error

        mov     cx, fs:[si].biBitCount   ; source must be right
        cmp     cx, ax
        jne     dither_init_error

dither_init_bit_depth_ok:

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial source pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     eax,fs:[si].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
	mov	SrcWidth,eax
        mov     SrcInc,eax

        lfs     si,lpSrc

	movzx	edx,SrcY
        mul     edx
        add     esi,eax

        movzx   eax,SrcX
        mul     ecx
        shr     eax,3
        add     esi,eax

        movzx   eax, DstXE           ; SrcInc = SrcWidth - DstXE*bits/8
        mul     ecx
        shr     eax, 3
        sub     SrcInc, eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial dest pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     cx, es:[di].biBitCount
        mov     eax,es:[di].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
	mov	DstWidth,eax
        mov     DstInc,eax

        cmp     es:[edi].biHeight,0            ; init a upside down DIB
        jge     short @f
        movsx   ebx,DstY
        add     ebx,es:[edi].biHeight
        not     ebx
        mov     DstY,bx
        neg     DstWidth
        neg     DstInc
@@:
        les     di,lpDst

        movsx   edx,DstY
        mul     edx
	add	edi,eax

        movsx   eax,DstX
        mul     ecx
        shr     eax,3
        add     edi,eax

        movzx   eax, DstXE           ; DstInc = DstWidth - DstXE*bits/8
        mul     ecx
        shr     eax, 3
        sub     DstInc, eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

dither_init_exit:
        clc
        ret

dither_init endp

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dtab775.h ===
BYTE rdith775[297] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
35,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
105,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
140,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
175,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210,
210
};

BYTE gdith775[297] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
5,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30,
30
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dither8.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: DITHER.ASM
;
; dither a 256 color DIB down to a 16 color dib.
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
	.xlist
        include cmacro32.inc
        include windows.inc
	.list

sBegin  Data

sEnd    Data

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        .386
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;
;   DITHER
;
;   Entry:
;       dl  pixel to dither (0-256)
;       bl  pattern x
;       ah  pattern y
;       fs  --> 8x256x8 dither table.
;
;       HIWORD(eax) = 0
;       HIWORD(ebx) = 0
;
;   Returns:
;       dl  dithered pixel (0-15) (rotated into edx)
;       bl  pattern x (advanced mod 8)
;
;--------------------------------------------------------------------------;
DITH8   macro

        mov     al,dl       ; get pel
        mov     dl,fs:[eax*8+ebx]  ; get dithered version of the pixel.
        ror     edx,8

        inc     bl          ; increment x
        and     bl,07h      ; mod 8

        endm

;--------------------------------------------------------------------------;
;
;   DitherDIB()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   Dither8,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of the dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of the source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;dither table.

        LocalD  DstWidth
        LocalD  SrcWidth
cBegin
        cld

        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        and     SrcX,  not 011b         ; align by four
        add     DstXE, 3
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        call    dither_init             ; init all the frame variables

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   time to do the dither.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     ax,DstY
        and     ax,07h
        mov     ah,al           ; ah has the scanline mod 8

        movzx   eax,ax
        movzx   ebx,bx
        movzx   ecx,cx

align 4
DitherOuterLoop:
        movzx   ebx,DstX
        and     ebx,07h
        movzx   ecx,DstXE
        shr     ecx,2

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   we have a input pixel now look up the dithered version.
;
;   the dither table is a byte array like so.
;
;       lpDitherTable[y % 8][pixel][x % 8]
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
align 4
DitherInnerLoop:
        mov     edx, dword ptr ds:[esi] ; get four input pixel(s)

        DITH8
        DITH8
        DITH8
        DITH8

        mov     dword ptr es:[edi],edx  ; write four output pixel(s)

        add     esi,4
        add     edi,4

        dec     ecx
        jnz     short DitherInnerLoop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        inc     ah
        and     ah, 07h
        add     esi, SrcWidth
        add     edi, DstWidth

        dec     DstYE
        jnz     short DitherOuterLoop

        xor     ax,ax
        mov     fs,ax       ; to make KRNL286.EXE and DOSX happy

        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   dither_init
;
;   init local frame vars for DitherDIB
;
;   ENTRY:
;       ss:bp   --> ditherdib frame
;
;   EXIT:
;       DS:ESI  --> source DIB start x,y
;       ES:EDI  --> dest DIB start x,y
;       FS:EBX  --> dither table
;
;--------------------------------------------------------------------------;

dither_init proc near

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial dest pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        lds     si,biDst

        mov     eax,[si].biWidth
        add     eax,3
        and     eax,not 3
        mov     DstWidth,eax

        xor     edi,edi
        les     di,lpDst

        movzx   ebx,DstX
        movzx   edx,DstY
        mul     edx
        add     eax,ebx
        add     edi,eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial source pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        lds     si,biSrc

        mov     eax,[si].biWidth
        add     eax,3
        and     eax,not 3
        mov     SrcWidth,eax

        xor     esi,esi
        lds     si,lpSrc

        movzx   ebx,SrcX
        movzx   edx,SrcY
        mul     edx
        add     eax,ebx
        add     esi,eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        xor     ebx,ebx
        lfs     bx,lpDitherTable

        movzx   eax,DstXE
        sub     SrcWidth, eax

        movzx   eax,DstXE
        sub     DstWidth, eax

        ret

dither_init endp

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dither.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  this code dither a 256 color DIB bitmap down to the VGA 16 colors.
//
//////////////////////////////////////////////////////////////////////////////

typedef void (FAR PASCAL *DITHERPROC)(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call DitherInit() to set up the 16k dither table.
//  you need to call DitherInit() whenever the source colors
//  change.  DitherInit() returns a pointer to the dither table
//
extern LPVOID VFWAPI DitherInit(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   VFWAPI DitherTerm(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither8Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither8Term(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL DitherDeviceInit(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither16Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither16Term(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither24Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither24Term(LPVOID lpDitherTable);

extern LPVOID FAR PASCAL Dither32Init(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable);
extern void   FAR PASCAL Dither32Term(LPVOID lpDitherTable);

extern void   FAR PASCAL DitherTableFree(void);

//extern HPALETTE FAR CreateDith775Palette(void); // (in dith775.c)

//
//  call this to actualy do the dither. (in dither8.asm)
//
extern void FAR PASCAL Dither8(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call this to actualy do the dither. (in dither.c)
//
extern void FAR PASCAL Dither8C(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.


//
//  call this to actualy do the dither. (in dith775.c)
//
extern void FAR PASCAL Dither16(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call this to actualy do the dither. (in dith775.c)
//
extern void FAR PASCAL Dither24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.

//
//  call this to map 16 bpp DIBs to 24bit (in mapa.asm)
//
extern void FAR PASCAL Map16to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.


//
//  call this to map 32 bpp DIBs to 24bit (in mapa.asm)
//
extern void FAR PASCAL Map32to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable);  // dither table.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dither.c ===
#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"
#include "dither.h"

//#define GRAY_SCALE

extern BOOL gf286;
extern UINT gwRasterCaps;

void FAR PASCAL Map16to24(LPBITMAPINFOHEADER,LPVOID,int,int,int,int,LPBITMAPINFOHEADER,LPVOID,int,int,LPVOID);

extern LPVOID glpDitherTable;

//////////////////////////////////////////////////////////////////////////////
//
//   DitherInit()
//
//////////////////////////////////////////////////////////////////////////////

LPVOID VFWAPI
DitherInit(LPBITMAPINFOHEADER lpbiIn,
           LPBITMAPINFOHEADER lpbiOut,
           DITHERPROC FAR *   lpDitherProc,
           LPVOID             lpDitherTable)
{
    switch ((int)lpbiOut->biBitCount)
    {
        case 8:
            if ((int)lpbiIn->biBitCount == 8 && (gwRasterCaps & RC_PALETTE))
                return Dither8Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 8 && !(gwRasterCaps & RC_PALETTE))
                return DitherDeviceInit(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 16)
                return Dither16Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 24)
                return Dither24Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            if ((int)lpbiIn->biBitCount == 32)
                return Dither32Init(lpbiIn, lpbiOut, lpDitherProc, lpDitherTable);

            return (LPVOID)-1;

        case 24:
            if (!gf286) {
		if (lpbiIn->biBitCount == 16) {
                    *lpDitherProc = Map16to24;
                    return NULL;
		} else if (lpbiIn->biBitCount == 32) {
		    *lpDitherProc = Map32to24;
		    return NULL;
		}
	    }

	    return (LPVOID)-1;

        default:
            return (LPVOID)-1;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void VFWAPI
DitherTerm(LPVOID lpDitherTable)
{
    if (lpDitherTable == glpDitherTable)
        Dither16Term(lpDitherTable);
    else
        Dither8Term(lpDitherTable);
}

//////////////////////////////////////////////////////////////////////////////
//
//   DitherDeviceInit() - dither to the colors of the display driver
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR PASCAL DitherDeviceInit(LPBITMAPINFOHEADER lpbi, LPBITMAPINFOHEADER lpbiOut, DITHERPROC FAR *lpDitherProc, LPVOID lpDitherTable)
{
    HBRUSH   hbr;
    HDC      hdcMem;
    HDC      hdc;
    HBITMAP  hbm;
    HBITMAP  hbmT;
    int      i;
    int      nColors;
    LPRGBQUAD prgb;
    BITMAPINFOHEADER biSave = *lpbiOut;

    //
    // we dont need to re-init the dither table, unless it is not ours then
    // we should free it.
    //
    if (lpDitherTable == glpDitherTable)
    {
        DitherTerm(lpDitherTable);
        lpDitherTable = NULL;
    }

    if (lpDitherTable == NULL)
    {
        lpDitherTable = GlobalAllocPtr(GHND, 256*8*8);
    }

    if (lpDitherTable == NULL)
        return (LPVOID)-1;

    hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);

    hbm = CreateCompatibleBitmap(hdc, 256*8, 8);
    hbmT = SelectObject(hdcMem, hbm);

    if ((nColors = (int)lpbi->biClrUsed) == 0)
        nColors = 1 << (int)lpbi->biBitCount;

    prgb = (LPRGBQUAD)(lpbi+1);

    for (i=0; i<nColors; i++)
    {
        hbr = CreateSolidBrush(RGB(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue));
        hbr = SelectObject(hdcMem, hbr);
        PatBlt(hdcMem, i*8, 0, 8, 8, PATCOPY);
        hbr = SelectObject(hdcMem, hbr);
        DeleteObject(hbr);
    }

#ifdef XDEBUG
    for (i=0; i<16; i++)
        BitBlt(hdc,0,i*8,16*8,8,hdcMem,i*(16*8),0,SRCCOPY);
#endif

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    lpbiOut->biSize           = sizeof(BITMAPINFOHEADER);
    lpbiOut->biPlanes         = 1;
    lpbiOut->biBitCount       = 8;
    lpbiOut->biWidth          = 256*8;
    lpbiOut->biHeight         = 8;
    lpbiOut->biCompression    = BI_RGB;
    lpbiOut->biSizeImage      = 256*8*8;
    lpbiOut->biXPelsPerMeter  = 0;
    lpbiOut->biYPelsPerMeter  = 0;
    lpbiOut->biClrUsed        = 0;
    lpbiOut->biClrImportant   = 0;
    GetDIBits(hdc, hbm, 0, 8, lpDitherTable, (LPBITMAPINFO)lpbiOut, DIB_RGB_COLORS);

    i = (int)lpbiOut->biClrUsed;
    *lpbiOut = biSave;
    lpbiOut->biClrUsed = i;

    DeleteObject(hbm);
    ReleaseDC(NULL, hdc);

    *lpDitherProc = Dither8;

    return (LPVOID)lpDitherTable;
}


//////////////////////////////////////////////////////////////////////////////
//
//   DitherTerm()
//
//////////////////////////////////////////////////////////////////////////////

void FAR PASCAL Dither8Term(LPVOID lpDitherTable)
{
    if (lpDitherTable)
        GlobalFreePtr(lpDitherTable);
}

#ifdef WIN32

//
//  call this to actually do the dither.
//
void FAR PASCAL Dither8(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    int x,y;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;
    DWORD dw;

    if (biDst->biBitCount != 8 || biSrc->biBitCount != 8)
        return;

    // tomor -- A little help! seems initialization is not done yet.
    if(!lpDitherTable)
        return;

    wWidthSrc = ((UINT)biSrc->biWidth+3)&~3;
    wWidthDst = ((UINT)biDst->biWidth+3)&~3;

    pbD = (BYTE _huge *)lpDst + DstX + DstY * wWidthDst;
    pbS = (BYTE _huge *)lpSrc + SrcX + SrcY * wWidthSrc;

    wWidthSrc -= DstXE;
    wWidthDst -= DstXE;

#define DODITH8(px, x, y)	((LPBYTE)lpDitherTable)[((y) & 7) * 256 * 8 + (px) * 8 + (x & 7)]

    for (y=0; y<DstYE; y++) {
	/* write two DWORDs (one dither cell horizontally) at once */
	for (x=0; x <= (DstXE - 8); x += 8) {

            dw = DODITH8(*pbS++, 0, y);
	    dw |= (DODITH8(*pbS++, 1, y) << 8);
	    dw |= (DODITH8(*pbS++, 2, y) << 16);
	    dw |= (DODITH8(*pbS++, 3, y) << 24);
            * ( (DWORD _huge UNALIGNED *) pbD)++ = dw;

            dw = DODITH8(*pbS++, 4, y);
	    dw |= (DODITH8(*pbS++, 5, y) << 8);
	    dw |= (DODITH8(*pbS++, 6, y) << 16);
	    dw |= (DODITH8(*pbS++, 7, y) << 24);
            * ( (DWORD _huge UNALIGNED *) pbD)++ = dw;
	}

	/* clean up remainder (less than 8 bytes per row) */
	for ( ; x < DstXE; x++) {
	    *pbD++ = DODITH8(*pbS++, x, y);
	}
	
        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
#undef DODITH8
}

/*
 * C version of 16->24 mapping (in asm for win16)
 */
extern void FAR PASCAL Map16to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{

    int x,y;
    UINT wWidthSrc;
    UINT wWidthDst;
    BYTE _huge *pbS;
    BYTE _huge *pbD;
    WORD wRGB;

    if (biDst->biBitCount != 24 || biSrc->biBitCount != 16)
        return;

    /* width of one row is nr pixels * size of pixel rounded to 4-bytes */
    wWidthSrc = ((UINT) (biSrc->biWidth * 2) +3)&~3;
    wWidthDst = ((UINT) (biDst->biWidth * 3) +3)&~3;

    /* advance to start of source, dest rect within DIB */
    pbD = (BYTE _huge *)lpDst + (DstX * 3) + DstY * wWidthDst;
    pbS = (BYTE _huge *)lpSrc + (SrcX * 2) + SrcY * wWidthSrc;

    /* amount to advance pointer to next line from end of source, dest rect */
    wWidthSrc -= (DstXE * 2);
    wWidthDst -= (DstXE * 3);

    for (y=0; y<DstYE; y++) {
        for (x=0; x<DstXE; x++) {
	    wRGB = *((LPWORD)pbS)++;
	    *pbD++ = (wRGB << 3) & 0xf8;
	    *pbD++ = (wRGB >> 2) & 0xf8;
	    *pbD++ = (wRGB >> 7) & 0xf8;
	}

        pbS += wWidthSrc;
        pbD += wWidthDst;
    }
}

void FAR PASCAL Map32to24(
    LPBITMAPINFOHEADER biDst,           // --> BITMAPINFO of the dest
    LPVOID             lpDst,           // --> to destination bits
    int                DstX,            // Destination origin - x coordinate
    int                DstY,            // Destination origin - y coordinate
    int                DstXE,           // x extent of the BLT
    int                DstYE,           // y extent of the BLT
    LPBITMAPINFOHEADER biSrc,           // --> BITMAPINFO of the source
    LPVOID             lpSrc,           // --> to source bits
    int                SrcX,            // Source origin - x coordinate
    int                SrcY,            // Source origin - y coordinate
    LPVOID             lpDitherTable)   // dither table.
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\drawdib.c ===
/**************************************************************************

    DRAWDIB.C   - routines for drawing DIBs to the screen.

    this code handles stretching and dithering with custom code, none
    of this slow GDI code.

    the following DIB formats are supported:

        4bpp (will just draw it with GDI...)
        8bpp
        16bpp
        24bpp
        compressed DIBs

    drawing to:

        16 color DC         (will dither 8bpp down)
        256 (paletized) DC  (will dither 16 and 24bpp down)
        Full-color DC       (will just draw it!)

**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include "drawdibi.h"

#ifndef ICMODE_FASTDECOMPRESS
    #define ICMODE_FASTDECOMPRESS 3
#endif

#define USE_SETDI 1

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

#ifdef WIN32
#define FlatToHuge(a, b, c)
#define HugeToFlat(a, b, c)
#else
extern FAR PASCAL FlatToHuge(LPVOID,DWORD,DWORD);
extern FAR PASCAL HugeToFlat(LPVOID,DWORD,DWORD);
#endif

//!!! not quite right.
#ifndef WIN32
#define IsScreenDC(hdc)     (GetDCOrg(hdc) != 0L)
#else
#define IsScreenDC(hdc)     (WindowFromDC(hdc) != NULL)
#endif

#define DCAlignment 3

__inline int DCNotAligned(HDC hdc, int xDst) {
    POINT pt;

    pt.x = xDst; pt.y = 0;
    LPtoDP(hdc, &pt, 1);
    xDst = pt.x;

#ifdef _WIN32
    GetDCOrgEx(hdc, &pt);
#else
    pt.x = LOWORD(GetDCOrg(hdc));
#endif
    return (pt.x + xDst) & DCAlignment;
}

/**************************************************************************
**************************************************************************/

UINT                gwScreenBitDepth = (UINT)-1;
UINT                gwRasterCaps = 0;
BOOL                gf286= FALSE;
static UINT         gUsage = 0;
static BOOL         gfInit = FALSE;
static BOOL         gfHalftone = FALSE;
static BOOL         gfBitmap   = FALSE;
static BOOL         gfBitmapX  = FALSE;
static BOOL         gfScreenX  = FALSE;
static BOOL         gfDrawX    = FALSE;
static HBITMAP      hbmStockMono;               // the stock mono bitmap.

#ifndef WIN32
static  BOOL gfDisplayHasBrokenRasters;
static  HDC hdcDCI;
static  DCISURFACEINFO FAR *pdci;

static  struct {
        BITMAPINFOHEADER bi;
        DWORD            dwMask[3];
}       biScreen;
static  LPVOID lpScreen;

SZCODE  szDVA[] = TEXT("dva");
#endif

/**************************************************************************
**************************************************************************/

SZCODE  szDrawDib[]             = TEXT("DrawDib");
SZCODE  szHalftone[]            = TEXT("Halftone");
SZCODE  szDrawToBitmap[]        = TEXT("DrawToBitmap");
SZCODE  szDecompressToBitmap[]  = TEXT("DecompressToBitmap");
SZCODE  szDecompressToScreen[]  = TEXT("DecompressToScreen");
SZCODE  szDrawToScreen[]        = TEXT("DrawToScreen");

/**************************************************************************
**************************************************************************/

static BOOL NEAR PASCAL DrawDibFree(PDD pdd, BOOL fSameDib, BOOL fSameSize);
static HPALETTE CreateBIPalette(HPALETTE hpal, LPBITMAPINFOHEADER lpbi);
static BOOL NEAR IsIdentityPalette(HPALETTE hpal);
static BOOL NEAR AreColorsAllGDIColors(LPBITMAPINFOHEADER lpbi);
static BOOL SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags);
static HPALETTE CreateExplicitPalette(void);

void DrawDibPalChange(PDD pdd, HDC hdc, HPALETTE hpal);
void DrawDibClipChange(PDD pdd, UINT wFlags);

static BOOL FixUpCodecPalette(HIC hic, LPBITMAPINFOHEADER lpbi);
static BOOL NEAR SendSetPalette(PDD pdd);

#ifndef WIN32
extern BOOL gf286;

/**************************************************************************
**************************************************************************/
static void InitDCI()
{
    UINT WidthBytes;

    //
    // initialize DCI and open a surface handle to it.
    //

    // if DVA = 0 in WIN.INI, don't use DCI or DVA.
    // PSS tells people to use this if they have video problems,
    // so we shouldn't change the string.

    if (gf286 || !GetProfileInt(szDrawDib, szDVA, TRUE))
        return;

    hdcDCI = DCIOpenProvider();

    if (hdcDCI == NULL)
        return;

    DCICreatePrimary(hdcDCI, &pdci);

    if (pdci == NULL)
        return;

    WidthBytes = abs((UINT)pdci->lStride);

    //
    // convert DCISURFACEINFO into a BITMAPINFOHEADER...
    //
    biScreen.bi.biSize          = sizeof(BITMAPINFOHEADER);
    biScreen.bi.biWidth         = WidthBytes*8/(UINT)pdci->dwBitCount;
    biScreen.bi.biHeight        = pdci->dwHeight;
    biScreen.bi.biPlanes        = 1;
    biScreen.bi.biBitCount      = (UINT)pdci->dwBitCount;
    biScreen.bi.biCompression   = BI_1632;  //!!!???
    biScreen.bi.biSizeImage     = pdci->dwHeight * WidthBytes;
    biScreen.bi.biXPelsPerMeter = WidthBytes;
    biScreen.bi.biYPelsPerMeter = 0;
    biScreen.bi.biClrUsed       = 0;
    biScreen.bi.biClrImportant  = 0;
    biScreen.dwMask[0]          = pdci->dwMask[0];
    biScreen.dwMask[1]          = pdci->dwMask[1];
    biScreen.dwMask[2]          = pdci->dwMask[2];

    if (pdci->dwCompression == 0 && (UINT)pdci->dwBitCount == 16)
    {
        biScreen.dwMask[0] = 0x007C00;
        biScreen.dwMask[1] = 0x0003E0;
        biScreen.dwMask[2] = 0x00001F;
    }

    if (pdci->dwCompression == 0 && (UINT)pdci->dwBitCount >= 24)
    {
        biScreen.dwMask[0] = 0xFF0000;
        biScreen.dwMask[1] = 0x00FF00;
        biScreen.dwMask[2] = 0x0000FF;
    }

    DPF(("DCI Surface: %dx%dx%d", (int)pdci->dwWidth, (int)pdci->dwHeight, (int)LOWORD(pdci->dwBitCount)));
    DPF(("DCI Surface: biCompression=%ld Masks: %04lX %04lX %04lX",biScreen.bi.biCompression,biScreen.dwMask[0],biScreen.dwMask[1],biScreen.dwMask[2]));

    if (pdci->lStride > 0)
        biScreen.bi.biHeight = -(int)pdci->dwHeight;
    else
        pdci->dwOffSurface -= biScreen.bi.biSizeImage;

    //
    // make sure the pointer is valid.
    //
    if (pdci->dwOffSurface >= 0x10000)
    {
        DPF(("DCI Surface cant be supported"));

        lpScreen = NULL;
        biScreen.bi.biSize = 0;
    }
    else
    {
        lpScreen = (LPVOID)MAKELP(pdci->wSelSurface,pdci->dwOffSurface);
    }

    //
    // check if the display has broken rasters.
    //
    if (pdci->dwDCICaps & DCI_1632_ACCESS)
        gfDisplayHasBrokenRasters = (0x10000l % WidthBytes) != 0;

    if (gfDisplayHasBrokenRasters)
    {
        DPF(("*** Display has broken rasters"));
    }
}

void TermDCI()
{
    if (pdci)
    {
        DCIDestroy(pdci);
        pdci = NULL;
    }

    if (hdcDCI)
    {
        DeleteDC(hdcDCI);
        hdcDCI = NULL;
    }
}

#else
    #define InitDCI()
    #define TermDCI()
#endif

/**************************************************************************
* @doc INTERNAL DrawDib
*
* @api BOOL | DrawDibInit | This function initalizes the DrawDib library.
*
* @rdesc Returns TRUE if the library is initialized properly, otherwise
*        it returns FALSE.
*
* @comm Users don't need to call this, because <f DrawDibOpen> does it for them.
*
* @xref DrawDibTerm
*
**************************************************************************/
BOOL VFWAPI DrawDibInit()
{
    HDC hdc;

    if (gfInit)
        return TRUE;

    gf286 = (BOOL)(GetWinFlags() & WF_CPU286);

    hdc = GetDC(NULL);

    gwScreenBitDepth = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    gwRasterCaps = GetDeviceCaps(hdc, RASTERCAPS);

    InitDCI();

    ReleaseDC(NULL, hdc);

    gfHalftone = GetProfileInt(szDrawDib, szHalftone, FALSE);
    gfBitmap   = GetProfileInt(szDrawDib, szDrawToBitmap, -1);
    gfBitmapX  = GetProfileInt(szDrawDib, szDecompressToBitmap, TRUE);
    gfScreenX  = GetProfileInt(szDrawDib, szDecompressToScreen, TRUE);
    gfDrawX    = GetProfileInt(szDrawDib, szDrawToScreen, TRUE);

#ifdef DEBUG
    gwRasterCaps = GetProfileIntA("drawdib", "RasterCaps", gwRasterCaps);
    gwScreenBitDepth = GetProfileIntA("drawdib", "ScreenBitDepth", gwScreenBitDepth);
    gf286 = GetProfileIntA("drawdib", "cpu", gf286 ? 286 : 386) == 286;
#endif

    //
    // fix up the bit-depth of the display.
    //
    if (gwScreenBitDepth > 32)
        gwScreenBitDepth = 32;

    if (gwScreenBitDepth == 16 || gwScreenBitDepth == 32)
    {
        BITMAPINFOHEADER bi;
        UINT u;

        bi.biSize           = sizeof(bi);
        bi.biWidth          = 1;
        bi.biHeight         = 1;
        bi.biPlanes         = 1;
        bi.biBitCount       = gwScreenBitDepth;
        bi.biCompression    = 0;
        bi.biSizeImage      = 0;
        bi.biXPelsPerMeter  = 0;
        bi.biYPelsPerMeter  = 0;
        bi.biClrUsed        = 0;
        bi.biClrImportant   = 0;

        u = (UINT)DrawDibProfileDisplay(&bi);

        if (u == 0)
        {
            DPF(("Pretending display is 24 bit (not %d)", gwScreenBitDepth));
            gwScreenBitDepth = 24;
        }
    }

    gfInit = TRUE;
    return TRUE;
}

/**************************************************************************
* @doc INTERNAL DrawTerm
*
* @api BOOL | DrawDibTerm | This function teminates the DrawDib library.
*
* @rdesc Returns TRUE.
*
* @comm Users don't need to call this, because <f DrawDibClose> does it for them.
*
* @xref DrawDibInit
*
**************************************************************************/
BOOL VFWAPI DrawDibTerm()
{
    //
    //  free global stuff.
    //
    TermDCI();
    gfInit = FALSE;
    return TRUE;
}

/**************************************************************************
* @doc INTERNAL DrawDib
*
* @api void | DrawDibCleanup | clean up drawdib stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL DrawDibCleanup(HTASK hTask)
{
    if (gUsage > 0)
        RPF(("%d DrawDib handles left open", gUsage));

    DrawDibTerm();
}

/**************************************************************************
* @doc  INTERNAL
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER | lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
INLINE BOOL NEAR PASCAL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    if (lpbi1 == NULL || lpbi2 == NULL)
	return FALSE;

    return
             lpbi1->biCompression == lpbi2->biCompression   &&
        (int)lpbi1->biSize        == (int)lpbi2->biSize     &&
        (int)lpbi1->biWidth       == (int)lpbi2->biWidth    &&
        (int)lpbi1->biHeight      == (int)lpbi2->biHeight   &&
        (int)lpbi1->biBitCount    == (int)lpbi2->biBitCount &&
        ((int)lpbi1->biBitCount > 8 ||
            (int)lpbi1->biClrUsed == (int)lpbi2->biClrUsed  &&
            _fmemcmp((LPBYTE)lpbi1 + lpbi1->biSize,
		(LPBYTE)lpbi2 + lpbi2->biSize,
                (int)lpbi1->biClrUsed*sizeof(RGBQUAD)) == 0);
}

/**************************************************************************
* @doc INTERNAL
*
* @api PDD NEAR | DrawDibLock | Lock the DrawDib handle.
*
* @parm HDRAWDIB | hdd | DrawDib handle.
*
* @rdesc Returns a pointer to a <t DRAWDIB_STRUCT> if successful, NULL otherwise.
*
**************************************************************************/

#define DrawDibLock(hdd) (\
    hdd == NULL || ((PDD)hdd)->wSize != sizeof(DRAWDIB_STRUCT) ? NULL : \
    (PDD)hdd)

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api HDRAWDIB | DrawDibOpen | This function opens a DrawDib context for drawing.
*
* @rdesc Returns a handle to a DrawDib context if successful,
*        otherwise it returns NULL.
*
* @comm Use this function to obtain a handle to a DrawDib context
*       before drawing device independent bitmaps.
*
*       If drawing multiple device independent bitmaps simultaneously,
*       obtain a handle to a DrawDib context for each bitmap.
*
* @xref <f DrawDibClose>
*
**************************************************************************/
HDRAWDIB VFWAPI DrawDibOpen(void)
{
    HDRAWDIB hdd;
    PDD      pdd;

    hdd = LocalAlloc(LPTR, sizeof(DRAWDIB_STRUCT));    /* zero init */

    if (hdd == NULL)
        return NULL;

    pdd = (PDD)hdd;
    pdd->wSize = sizeof(DRAWDIB_STRUCT);

    if (gUsage++ == 0)
        DrawDibInit();

    return hdd;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibClose | This function closes a DrawDib context
*      and frees the resources DrawDib allocated for it.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @rdesc Returns TRUE if the context closed successfully.
*
* @comm Use this function to free the <p hdd> handle
*       after the application has finished drawing.
*
* @xref <f DrawDibOpen>
**************************************************************************/
BOOL VFWAPI DrawDibClose(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    DrawDibFree(pdd, FALSE, FALSE);

    pdd->wSize = 0;
    LocalFree(hdd);

    if (--gUsage == 0)
        DrawDibTerm();

    return TRUE;
}

/**************************************************************************
* @doc INTERNAL
*
* @api BOOL | DrawDibFree | Free up everything in a <t DRAWDIB_STRUCT>.
*
* @parm PDD | pdd | Pointer to a <t DRAWDIB_STRUCT>.
*
* @rdesc Returns TRUE if successful, FALSE otherwise.
*
**************************************************************************/
static BOOL NEAR PASCAL DrawDibFree(PDD pdd, BOOL fSameDib, BOOL fSameSize)
{
    if (pdd == NULL)
        return FALSE;

    //
    // If the draw palette has changed, the compressor may now be giving us DIBs
    // mapped to a different palette, so we need to clean up so we'll produce
    // a new mapping table so we'll actually draw with the new palette.
    // (see SendSetPalette)
    //
    if (!fSameDib)
    {
        //
        // if this palette is selected as the foreground palette
        // and we delete it we are going to hose GDI!
        //
        if (pdd->hpal)
            DeleteObject(pdd->hpal);
        if (pdd->hpalCopy)
            DeleteObject(pdd->hpalCopy);

        pdd->hpal = NULL;
        pdd->hpalCopy = NULL;
    }

    if (!fSameDib)
    {

	if (pdd->lpbi) {
	    GlobalFreePtr(pdd->lpbi);
	    pdd->lpbi = NULL;
	    pdd->lpargbqIn = NULL;
	}

        if (pdd->lpDitherTable)
        {
            DitherTerm(pdd->lpDitherTable);
            pdd->lpDitherTable = NULL;
        }

        if (pdd->hic && pdd->hic != (HIC)-1)
        {
            ICDecompressEnd(pdd->hic);
            ICDecompressExEnd(pdd->hic);
            ICClose(pdd->hic);
        }

        pdd->ulFlags &= ~(DDF_IDENTITYPAL);
        pdd->hic  = NULL;

        pdd->iAnimateStart = 0;
        pdd->iAnimateLen = 0;
        pdd->iAnimateEnd = 0;
    }

    if (!fSameSize || !fSameDib)
    {
        if (pdd->hdcDraw && hbmStockMono)
            SelectObject(pdd->hdcDraw, hbmStockMono);

        if (pdd->hdcDraw)
            DeleteDC(pdd->hdcDraw);

        if (pdd->hbmDraw) {
            DeleteObject(pdd->hbmDraw);

            //
            // if we have a bitmap pointer lose it
            //
            if (pdd->ulFlags & (DDF_CANBITMAPX))
                pdd->pbBitmap = NULL;
        }

        if ((pdd->pbStretch) && (pdd->pbStretch != pdd->lpDIBSection))
            GlobalFreePtr(pdd->pbStretch);

        if ((pdd->pbDither) && (pdd->pbDither != pdd->lpDIBSection))
            GlobalFreePtr(pdd->pbDither);

        if ((pdd->pbBuffer) && (pdd->pbBuffer != pdd->lpDIBSection))
            GlobalFreePtr(pdd->pbBuffer);

#if USE_SETDI
        if (pdd->hbmDraw)
            SetBitmapEnd(&pdd->sd);
#endif

        pdd->hdcDraw = NULL;
        pdd->hbmDraw = NULL;
	pdd->lpDIBSection = NULL;
        pdd->pbStretch = NULL;
        pdd->pbDither = NULL;
        pdd->pbBuffer = NULL;

        pdd->biDraw.biBitCount = 0;
        pdd->biDraw.biWidth    = 0;
        pdd->biDraw.biHeight   = 0;

        pdd->biBuffer.biBitCount = 0;
        pdd->biBuffer.biWidth    = 0;
        pdd->biBuffer.biHeight   = 0;

        // clear all the internal flags (except palette stuff)
        pdd->ulFlags &= ~(DDF_OURFLAGS ^ DDF_IDENTITYPAL);
        pdd->ulFlags |= DDF_DIRTY;

        pdd->iDecompress = 0;
    }

    return TRUE;
}

/**************************************************************************
* @doc INTERNAL
*
* @api UINT | QueryDraw | see if the current display device
*             (DISPDIB or GDI) can draw the given dib
*
* @parm PDD | pdd | pointer to a <t DRAWDIB_STRUCT>.
*
* @parm LPBITMAPINFOHEADER | lpbi | pointer to a bitmap.
*
* @rdesc Returns display flags, see profdisp.h
*
**************************************************************************/

static UINT NEAR QueryDraw(PDD pdd, LPBITMAPINFOHEADER lpbi)
{
    return (UINT)DrawDibProfileDisplay(lpbi);
}

/**************************************************************************
* @doc INTERNAL DrawDib
*
* @comm Called from DrawDibBegin to try decompression to a bitmap.
*
**************************************************************************/
BOOL DrawDibQueryBitmapX(
    PDD pdd
)
{
    BITMAPINFOHEADER *pbi;

#ifndef _WIN32
    if (!CanLockBitmaps()) {
        return FALSE;
    }
#endif

    if (gwScreenBitDepth == 8 && !(gwRasterCaps & RC_PALETTE))
        return FALSE;

    if ((gwRasterCaps & RC_PALETTE) && !(pdd->ulFlags & DDF_IDENTITYPAL))
        return FALSE;

    pbi = &pdd->biStretch;

    if (!GetDIBBitmap(pdd->hbmDraw, pbi))
        return FALSE;

#ifdef XDEBUG
    if (ICDecompressQuery(pdd->hic, pdd->lpbi, pbi) != ICERR_OK)
    {
        if (mmGetProfileIntA(szDrawDib, "ForceDecompressToBitmap", FALSE))
        {
            pbi->biHeight = -pbi->biHeight;
            pbi->biCompression = 0;
        }
    }
#endif
    if (ICDecompressQuery(pdd->hic, pdd->lpbi, pbi) != ICERR_OK)
    {
        if (pbi->biCompression == BI_BITMAP &&
            pbi->biSizeImage <= 128*1024l &&
            (pbi->biXPelsPerMeter & 0x03) == 0 &&
            pbi->biSizeImage > 64*1024l)
        {
            pdd->ulFlags |= DDF_HUGEBITMAP;
            pbi->biCompression = 0;

            pbi->biSizeImage -= pbi->biYPelsPerMeter;   //FillBytes

            if (ICDecompressQuery(pdd->hic, pdd->lpbi, pbi) != ICERR_OK)
                return FALSE;
        }
        else
            return FALSE;
    }

    pdd->ulFlags |= DDF_NEWPALETTE;     // force check in DrawDibRealize
    pdd->ulFlags |= DDF_CANBITMAPX;     // can decompress to bitmaps

    if (pdd->ulFlags & DDF_HUGEBITMAP)
        RPF(("    Can decompress '%4.4hs' to a HUGE BITMAP (%dx%dx%d)",(LPSTR)&pdd->lpbi->biCompression, PUSHBI(*pbi)));
    else
        RPF(("    Can decompress '%4.4hs' to a BITMAP (%dx%dx%d)",(LPSTR)&pdd->lpbi->biCompression, PUSHBI(*pbi)));

    //
    // reuse the stretch buffer for the bitmap.
    //
    pdd->biStretch = *pbi;
#ifndef _WIN32
    pdd->pbStretch = LockBitmap(pdd->hbmDraw);

    if (pdd->pbStretch == NULL)
    {
        DPF(("    Unable to lock bitmap!"));
        pdd->ulFlags &= ~DDF_CANBITMAPX; // can't decompress to bitmaps
        return FALSE;
    }
#endif

    return TRUE;
}



#define Is565(bi)   (((bi)->biCompression == BI_BITFIELDS) &&   \
		    ((bi)->biBitCount == 16) &&			\
		    (((LPDWORD)((bi)+1))[0] == 0x00F800) &&	\
		    (((LPDWORD)((bi)+1))[1] == 0x0007E0) &&	\
		    (((LPDWORD)((bi)+1))[2] == 0x00001F) )



/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibBegin | This function changes parameters
*      of a DrawDib context or it initializes a new DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to a display context for drawing (optional).
*
* @parm int | dxDest | Specifies the width of the destination rectangle.
*       Width is specified in MM_TEXT client units.
*
* @parm int | dyDest | Specifies the height of the destination rectangle.
*       Height is specified in MM_TEXT client units.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a pointer to a
*       <t BITMAPINFOHEADER> structure containing the
*       image format. The color table for the DIB follows the
*       image format.
*
* @parm int | dxSrc | Specifies the width of the source rectangle.
*       Width is specified in pixels.
*
* @parm int | dySrc | Specifies the height of the source rectangle.
*       Height is specified in pixels.
*
* @parm UNIT | wFlags | Specifies the applicable flags for
*       the function. The following flags are defined:
*
* @flag DDF_SAME_HDC | Assumes the handle to the display context
*       is already specified. When this flag is used,
*       DrawDib also assumes the correct palette has already been
*       realized into the device context (possibly by
*       <f DrawDibRealize>).
*
* @flag DDF_SAME_DRAW | Uses the drawing parameters previously
*       specified for this function.  Use this flag only
*       if <p lpbi>, <p dxDst>, <p dyDst>, <p dxSrc>, and <p dySrc>
*       have not changed since using <f DrawDibDraw> or <f DrawDibBegin>.
*
* @flag DDF_DONTDRAW | Indicates the frame is to be decompressed
*       and not drawn. The DDF_UPDATE flag can be used later
*       to actually draw the image.
*
* @flag DDF_ANIMATE | Allows palette animation. If this flag is present,
*       the palette <f DrawDib> creates will have the PC_RESERVED flag set for
*       as many entries as possible, and the palette can be animated by
*       <f DrawDibChangePalette>. If using <f DrawDibBegin> with
*       <f DrawDibDraw>, set this flag with <f DrawDibBegin>
*       rather than <f DrawDibDraw>.
*
* @flag DDF_JUSTDRAWIT | Uses GDI to draw the image. This prevents
*       the DrawDib functions from calling ICM to decompress
*       the image or prevents them from
*       using their own routines to stretch or dither the image.
*       This essentially reduces <f DrawDibDraw> to <f StretchDIBits>.
*
* @flag DDF_BACKGROUNDPAL | Realizes the palette used for drawing
*       in the background leaving the actual palette used for display
*       unchanged.  (This flag is valid only if DDF_SAME_HDC is not set.)
*
* @flag DDF_HALFTONE | Always dithers the DIB to a standard palette
*       regardless of the palette of the DIB. If using <f DrawDibBegin> with
*       <f DrawDibDraw>, set this flag with <f DrawDibBegin>
*       rather than <f DrawDibDraw>.
*
* @flag DDF_BUFFER | Indicates DrawDib should try to use a
*       offscreen buffer so DDF_UPDATE can be used. This
*       disables decompression and drawing directly to the screen.
*       If DrawDib is unable to create an offscreen buffer,
*       it will decompress or draw directly to the screen.
*
*       For more information, see the DDF_UPDATE and DDF_DONTDRAW
*       flags described for <f DrawDibDraw>.
*
*
* @rdesc Returns TRUE if successful.
*
* @comm This function prepares to draw a bitmap specified by <p lpbi>
*       to the display context <p hdc>. The image is stretched to
*       the size specified by <p dxDest> and <p dyDest>. If <p dxDest> and
*       <p dyDest> are (-1, -1), the bitmap is drawn to a
*       1:1 scale without stretching.
*
*       Use this function only if you want to prepare DrawDib
*       before using <f DrawDibDraw> to draw the image.
*       If you do not use this function, <f DrawDibDraw> implicitly
*       uses it when it draws the image.
*
*       To update the flags set with <f DrawDibBegin>, call <f DrawDibBegin>
*       with new parameters.
*
*       When <f DrawDibBegin> is used, the <f DDF_SAME_DRAW>
*       flag is normally set for <f DrawDibDraw>.
*
*       If the parameters of <f DrawDibBegin> have not changed, subsequent
*       uses of it have not effect.
*
*       Use <f DrawDibEnd> to free memory used by the DrawDib context.
*
* @xref <f DrawDibEnd> <f DrawDibDraw>
**************************************************************************/
//#ifndef WIN32
//#pragma message("Make DrawDibBegin faster for changing the size only!")
//#endif
BOOL VFWAPI DrawDibBegin(HDRAWDIB hdd,
                             HDC      hdc,
                             int      dxDst,
                             int      dyDst,
                             LPBITMAPINFOHEADER lpbi,
                             int      dxSrc,
                             int      dySrc,
                             UINT     wFlags)
{
    PDD pdd;
    int ScreenBitDepth;
    int dxSave,dySave;
    BOOL     fNewPal;
    BOOL     fSameDib;
    BOOL     fSameSize;
    BOOL     fSameFlags;
    BOOL     fSameHdc;
    UINT    wFlagsChanged;
    DWORD   ulFlagsSave;
    DWORD    dw;
    UINT     w;
    HPALETTE hPal;
    LONG    lSize;

    //
    // Quick sanity checks....
    //
    if (lpbi == NULL)
        return FALSE;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (!gfInit)
        DrawDibInit();

    //
    // fill in defaults.
    //
    if (dxSrc < 0)
        dxSrc = (int)lpbi->biWidth;

    if (dySrc < 0)
        dySrc = (int)lpbi->biHeight;

    if (dxDst < 0)
        dxDst = dxSrc;

    if (dyDst < 0)
        dyDst = dySrc;

    if (dxSrc == 0 || dySrc == 0)       // !!! || dxDst == 0 || dyDst == 0)
        return FALSE;

    ulFlagsSave = pdd->ulFlags;
    wFlagsChanged = ((UINT)pdd->ulFlags ^ wFlags);

    fSameHdc = hdc == pdd->hdcLast;
    fSameDib  = DibEq(pdd->lpbi, lpbi) &&
                        !(wFlagsChanged & DDF_HALFTONE) &&
                        (pdd->hpalDraw == pdd->hpalDrawLast);

    fSameFlags = (pdd->ulFlags & DDF_BEGINFLAGS) == (wFlags & DDF_BEGINFLAGS);
    fSameSize = pdd->dxDst == dxDst && pdd->dyDst == dyDst &&
                pdd->dxSrc == dxSrc && pdd->dySrc == dySrc;
    pdd->hdcLast = hdc;

    //
    // do a quick check to see if the params have changed.
    // If the DIB, and size of the DIB, and flags used are the same as the last
    // time we called DrawDibBegin, then there's nothing to do and we'll only
    // waste time plodding through this code.
    // There is one case when all these could be the same, but the situation
    // has still changed enough so that we need to recompute things... if the
    // hdc is different than last time, and we're dealing with RLE.  You see,
    // we make some decisions about RLE (like we can go direct to a screen DC
    // but not a memory DC) that are affected by what hdc we're using.  So
    // we will not bail out early if we are using RLE and the hdc's are
    // different.
    //
    if (fSameDib && fSameSize && fSameFlags)
    {
	if ((lpbi->biCompression != BI_RLE8 && lpbi->biCompression != BI_RLE4)
								|| fSameHdc)
	    return TRUE;
    }

    pdd->hpalDrawLast = pdd->hpalDraw;

    RPF(("DrawDibBegin %dx%dx%d '%4.4hs' [%d %d] [%d %d]",
            (int)lpbi->biWidth,
            (int)lpbi->biHeight,
            (int)lpbi->biBitCount,
                (lpbi->biCompression == BI_RGB  ? (LPSTR)"None" :
                 lpbi->biCompression == BI_RLE8 ? (LPSTR)"Rle8" :
                 lpbi->biCompression == BI_RLE4 ? (LPSTR)"Rle4" :
                 (LPSTR)&lpbi->biCompression),
            dxSrc, dySrc, dxDst, dyDst));

    fNewPal = pdd->hpal == NULL || !fSameDib;

    //
    // make sure this palette is not the in the DC, because we
    // are going to delete it, and GDI get real upset if we do this.
    //

    if (fNewPal && pdd->hpal && hdc)
    {
        hPal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);

        if (hPal == pdd->hpal)
            RPF(("    Warning unselecting palette..."));
    }

    DrawDibFree(pdd, fSameDib, fSameSize);

    pdd->dxSrc = dxSrc;
    pdd->dySrc = dySrc;
    pdd->dxDst = dxDst;
    pdd->dyDst = dyDst;

    //
    // copy the source DIB header and the colors.
    //
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

////if (lpbi->biClrUsed != 0 && lpbi->biBitCount > 8)
////    lpbi->biClrUsed = 0;

    // Make a copy of the source format.  Remember, some codec could have
    // defined a custom format larger than a BITMAPINFOHEADER so make a copy
    // of EVERYTHING.
    if (!fSameDib) {
	lSize = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);
	pdd->lpbi = (LPBITMAPINFOHEADER)GlobalAllocPtr(GPTR, lSize);
	if (pdd->lpbi == NULL)
	    return FALSE;
	_fmemcpy(pdd->lpbi, lpbi, (int)lSize);
	// This is where the colour info is
	pdd->lpargbqIn = (LPVOID)((LPBYTE)lpbi + lpbi->biSize);
    }

    pdd->biBuffer = *lpbi;

    pdd->lpbi->biSizeImage = 0;
    pdd->biBuffer.biSizeImage = 0;

    //
    // init all other color tables to be the initial colors
    //
    if (lpbi->biBitCount <= 8)
    {
        _fmemcpy(pdd->argbq,   (LPBYTE)lpbi+(int)lpbi->biSize,
                (int)lpbi->biClrUsed * sizeof(RGBQUAD));
        _fmemcpy(pdd->aw,      (LPBYTE)lpbi+(int)lpbi->biSize,
                (int)lpbi->biClrUsed * sizeof(RGBQUAD));
    }

    // set PalUse to default: DIB_PAL_COLORS. This will be set
    // to DIB_PAL_INDICES if DrawdibCheckPalette is called and detects
    // that it is safe to use indices. DIB_PAL_COLORS is a safe
    // default.

    pdd->uiPalUse = DIB_RGB_COLORS;     // assume RGB colors for now.

    //
    // make sure the device is a palette device before dinking with
    // palette animation.
    //
    if (wFlags & DDF_ANIMATE)
    {
        if (!(gwRasterCaps & RC_PALETTE) ||
            (int)lpbi->biBitCount > 8 || pdd->hpalDraw)
            wFlags &= ~DDF_ANIMATE;
    }

    //
    // copy the flags
    //
try_again:
    pdd->ulFlags &= ~DDF_USERFLAGS;
    pdd->ulFlags |= (wFlags & DDF_USERFLAGS);

    pdd->ulFlags &= ~DDF_UPDATE;

    //
    // deal with a decompressor if needed.
    //
    switch (lpbi->biCompression)
    {
        case BI_RGB:
            break;

        default:
            //
            //  see if the DISPLAY/DISPDIB can draw the format directly!
            //
            //  if the buffer flag is set we MUST use a decompress buffer.
            //  regardless of what the display can do
            //
            if (wFlags & DDF_BUFFER)
                w = 0;
            else
                w = QueryDraw(pdd, lpbi);

            if (w & PD_CAN_DRAW_DIB)
            {
                if (((dxSrc == dxDst && dySrc == dyDst) && (w & PD_STRETCHDIB_1_1_OK)) ||
                    ((dxSrc != dxDst || dySrc != dyDst) && (w & PD_STRETCHDIB_1_N_OK)) ||
                    ((dxDst % dxSrc) == 0 && (dyDst % dySrc) == 0 && (w & PD_STRETCHDIB_1_2_OK)))
                {
		    // GDI can't handle drawing RLEs to a memory DC so we will
		    // have to pretend that RLE can't be drawn to the screen
		    // and decompress it first.
		    // We also can't DITHER RLE, so if we're running on a
		    // 16 colour display, make sure we're using a decompressor.
		    if (((lpbi->biCompression != BI_RLE8) &&
				(lpbi->biCompression != BI_RLE4)) ||
			(hdc && IsScreenDC(hdc) && gwScreenBitDepth >=8))
		    {
                	wFlags |= DDF_JUSTDRAWIT;

                	if (pdd->hic)
                	    ICClose(pdd->hic);

                	pdd->hic = NULL;
                	goto no_decomp;
		    }
                }
            }

            if (pdd->hic == NULL)
            {
                DWORD fccHandler;

                fccHandler = 0;

                if (lpbi->biCompression == BI_RLE8)
                    fccHandler = mmioFOURCC('R','L','E',' ');

                pdd->hic = ICLocate(ICTYPE_VIDEO,
                                    fccHandler,
                                    lpbi, NULL,
                                    ICMODE_FASTDECOMPRESS);

                if (pdd->hic == NULL)
                    pdd->hic = ICDecompressOpen(ICTYPE_VIDEO,
                                                fccHandler,lpbi,NULL);

                if (pdd->hic)
                {
                    //
                    //  make sure the codec uses its default palette out of the gate
                    //
                    if (ICDecompressSetPalette(pdd->hic, NULL) == ICERR_OK)
                    {
                        pdd->ulFlags |= DDF_CANSETPAL;
                        RPF(("    codec supports ICM_SET_PALETTE"));
                    }
                    else
                    {
                        pdd->ulFlags &= ~DDF_CANSETPAL;
                    }
                }
            }

            if (pdd->hic == NULL || pdd->hic == (HIC)-1)
            {
                RPF(("    Unable to open compressor '%4.4ls'",(LPSTR)&lpbi->biCompression));
                pdd->hic = (HIC)-1;

                if (wFlags & DDF_BUFFER)
                {
                    RPF(("   Turning DDF_BUFFER off"));
                    wFlags &= ~DDF_BUFFER;
                    goto try_again;
                }

                return FALSE;
            }

            //
            //  now find the best DIB format to decompress to.
            //
            if (!ICGetDisplayFormat(pdd->hic, lpbi, &pdd->biBuffer,
                (gfHalftone || (wFlags & DDF_HALFTONE)) ? 16 : 0,
                MulDiv(dxDst,abs((int)lpbi->biWidth),dxSrc),
                MulDiv(dyDst,abs((int)lpbi->biHeight),dySrc)))
            {
                RPF(("    Compressor error!"));
codec_error:
                //ICClose(pdd->hic);
                //pdd->hic = (HIC)-1;
                return FALSE;
            }

            //
            // we have new source params
            //
            dxSrc = MulDiv(dxSrc, abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
            dySrc = MulDiv(dySrc, abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
//          xSrc  = MulDiv(xSrc,  abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
//          ySrc  = MulDiv(ySrc,  abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);

            //
            // now allocate the decompress buffer!
            //
            pdd->biBuffer.biSizeImage = DIBSIZEIMAGE(pdd->biBuffer);
            pdd->pbBuffer = GlobalAllocPtr(GHND,pdd->biBuffer.biSizeImage);

            if (pdd->pbBuffer == NULL)
            {
                RPF(("    No Memory for decompress buffer"));
                ICClose(pdd->hic);
                pdd->hic = (HIC)-1;
                return FALSE;
            }
            pdd->ulFlags |= DDF_DIRTY;

            dw = ICDecompressBegin(pdd->hic, lpbi, &pdd->biBuffer);

            if (dw != ICERR_OK)
            {
                RPF(("    Compressor failed ICM_DECOMPRESS_BEGIN"));
		goto codec_error;
                return FALSE;
            }

            RPF(("    Decompressing '%4.4hs' to %dx%dx%d%s",(LPSTR)&lpbi->biCompression, PUSHBI(pdd->biBuffer),
			     	Is565(&pdd->biBuffer) ? (LPSTR) "(565)" : (LPSTR) ""
	       ));
            pdd->iDecompress = DECOMPRESS_BUFFER;

            _fmemcpy(pdd->aw,pdd->argbq, 256*sizeof(RGBQUAD));
            lpbi = &pdd->biBuffer;
            break;
    }
no_decomp:
    pdd->biDraw = pdd->biBuffer;
    pdd->biDraw.biSizeImage = 0;

    pdd->biDraw.biHeight = abs((int)pdd->biDraw.biHeight);

    if ((!(wFlags & DDF_JUSTDRAWIT)) && (lpbi->biCompression == BI_RGB))
    {
        //
        //  test the display device for this DIB format
        //
        w = QueryDraw(pdd, lpbi);

        //
        // get the bit depth of the screen device.
        //
        ScreenBitDepth = gwScreenBitDepth;

        if (ScreenBitDepth > 24)
            ScreenBitDepth = 32;        //???!!!

        // does the display support drawing 16bpp DIBs?
        // if it does not, treat it like a 24bpp device.

        if (ScreenBitDepth >= 24 && lpbi->biBitCount == 32 && !(w & PD_CAN_DRAW_DIB))
            ScreenBitDepth = 24;

        if (ScreenBitDepth >= 16 && lpbi->biBitCount == 16 && !(w & PD_CAN_DRAW_DIB))
            ScreenBitDepth = 24;

        //
        // check if the display driver isn't very good, for this format
        //
        if (!(w & PD_STRETCHDIB_1_1_OK))
        {
            pdd->ulFlags |= DDF_BITMAP;
        }

        //
        //  if the display driver isn't very good make a bitmap to copy into
        //  to draw.
        //
        switch (gfBitmap)
        {
            case 0:
                pdd->ulFlags &= ~DDF_BITMAP;
                break;

            case 1:
                pdd->ulFlags |= DDF_BITMAP;
                break;
        }

#ifndef WIN32	
	//
	// for 16/32 bit DIBs, the display may not support DIBS at all and
	// we should use bitmaps anyway just in case, even if the user
	// tried to override
	//
	if ((pdd->biDraw.biBitCount == 16 || pdd->biDraw.biBitCount == 32) &&
	    w == PD_CAN_DRAW_DIB)
	{
	    pdd->ulFlags |= DDF_BITMAP;
	}
#endif

        if ((dxSrc != dxDst || dySrc != dyDst) && !(w & PD_STRETCHDIB_1_N_OK))
            pdd->ulFlags |= DDF_STRETCH;

        if (dxSrc*2 == dxDst && dySrc*2 == dyDst && (w & PD_STRETCHDIB_1_2_OK))
            pdd->ulFlags &= ~DDF_STRETCH;

        if ((dxDst % dxSrc) == 0 && (dyDst % dySrc) == 0 && (w & PD_STRETCHDIB_1_2_OK))
            pdd->ulFlags &= ~DDF_STRETCH;

        if ((int)lpbi->biBitCount > ScreenBitDepth)
            pdd->ulFlags |= DDF_DITHER;

        //
        //  force halftone palette
        //
        if ((gfHalftone || (wFlags & DDF_HALFTONE)) && ScreenBitDepth <= 8)
            pdd->ulFlags |= DDF_DITHER;

        // NOTE we treat a convert up (ie 16->24) as a dither too.
        if ((int)lpbi->biBitCount > 8 && (int)lpbi->biBitCount < ScreenBitDepth)
            pdd->ulFlags |= DDF_DITHER;

	if (pdd->ulFlags & DDF_DITHER) {
	    if (lpbi->biBitCount == 16 && (w & PD_CAN_DRAW_DIB)) {
	    pdd->ulFlags &= ~DDF_DITHER;
		DPF(("Turning off DITHER for 16-bit DIBs, since we can draw them"));
	    }

	    if (lpbi->biBitCount == 32 && (w & PD_CAN_DRAW_DIB)) {
		pdd->ulFlags &= ~DDF_DITHER;
		DPF(("Turning off DITHER for 32-bit DIBs, since we can draw them"));
	    }

	    if (lpbi->biBitCount == 8 &&
				lpbi->biClrUsed <= 16 &&
				AreColorsAllGDIColors(lpbi)) {
		pdd->ulFlags &= ~DDF_DITHER;
		DPF(("Turning off DITHER for 8-bit DIBs already using the VGA colors"));
	    }
	}

	// force stretching in drawdib if we are dithering
	if ((pdd->ulFlags & DDF_DITHER) &&
	    ((dxSrc != dxDst) || (dySrc != dyDst))) {
		pdd->ulFlags |= DDF_STRETCH;
	}

        //
        // force a buffer if we dont have one.
        //
        if ((pdd->ulFlags & DDF_BUFFER) &&
            pdd->hic == NULL &&
            !(pdd->ulFlags & DDF_DITHER) &&
            !(pdd->ulFlags & DDF_STRETCH) &&
            !(pdd->ulFlags & DDF_BITMAP))
        {
            RPF(("    Using a buffer because DDF_BUFFER is set."));
            pdd->ulFlags |= DDF_STRETCH;    // force a 1:1 stretch
        }

	if (lpbi->biBitCount != 8
		    && lpbi->biBitCount != 16
		    && lpbi->biBitCount != 24
#ifndef _WIN32
		    && lpbi->biBitCount != 32
#endif
	    ) {
            DPF(("Turning off stretch for an unsupported format...."));
            pdd->ulFlags &= ~(DDF_STRETCH);
        }

    }

    //
    // delete the palette if we are changing who dithers.
    //
    if (pdd->hpal &&
        pdd->lpbi->biBitCount > 8 &&
        ((pdd->ulFlags ^ ulFlagsSave) & (DDF_DITHER)))
    {
        DPF(("    Dither person has changed..."));

        if (pdd->lpDitherTable)
        {
            DitherTerm(pdd->lpDitherTable);
            pdd->lpDitherTable = NULL;
        }

        if (hdc) {
            hPal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);

            if (hPal == pdd->hpal)
	        RPF(("    Warning unselecting palette..."));
        }

        DeleteObject(pdd->hpal);
        if (pdd->hpalCopy)
            DeleteObject(pdd->hpalCopy);
        pdd->hpal = NULL;
        pdd->hpalCopy = NULL;
    }

    if (pdd->ulFlags & DDF_STRETCH)
    {
        /* the code for stretching *only* works on a 386+ */
        if (gf286 || pdd->biBuffer.biBitCount < 8)
        {
            RPF(("    Using GDI to stretch"));
            pdd->ulFlags &= ~DDF_STRETCH;
        }
        else
        {
            //
            // we have stretching to do, this requires extra
            // headers and buffers.
            //
            pdd->biStretch = pdd->biBuffer;
            pdd->biStretch.biWidth = dxDst;
            pdd->biStretch.biHeight = dyDst;
            pdd->biStretch.biSizeImage = DIBSIZEIMAGE(pdd->biStretch);

            pdd->pbStretch = GlobalAllocPtr(GHND,pdd->biStretch.biSizeImage);

            if (pdd->pbStretch == NULL)
            {
                RPF(("    No memory for stretch buffer, using GDI"));
                pdd->ulFlags &= ~DDF_STRETCH;
            }
            else
            {
                RPF(("    Stretching %dx%dx%d%s --> %dx%dx%d",
			    dxSrc, dySrc, (int)lpbi->biBitCount,
			    (LPSTR) (Is565(lpbi) ? "(565)":""),
			    dxDst, dyDst, (int)pdd->biStretch.biBitCount,
			    (LPSTR) (Is565(&pdd->biStretch) ? "(565)":"")
		   ));
                pdd->biDraw.biWidth = dxDst;
                pdd->biDraw.biHeight = dyDst;
                dxSrc = dxDst;
                dySrc = dyDst;
                lpbi = &pdd->biStretch;
            }
        }
    }

    if (pdd->ulFlags & DDF_DITHER)
    {
        pdd->ulFlags &= ~DDF_ANIMATE;        // cant  animate and dither!

        if (ScreenBitDepth <= 8)
            pdd->biDraw.biBitCount = 8;
        else if (lpbi->biBitCount <= 8)
            pdd->biDraw.biBitCount = lpbi->biBitCount;
        else
////////////pdd->biDraw.biBitCount = 24; //!!! what about 16bit DIB support
            pdd->biDraw.biBitCount = ScreenBitDepth;

        w = QueryDraw(pdd, &pdd->biDraw);

        if (w & PD_STRETCHDIB_1_1_OK)
            pdd->ulFlags &= ~DDF_BITMAP;
        else
            pdd->ulFlags |= DDF_BITMAP;

	// this is wrong isn't it ? biDraw will be set to
	// dxDst if we are stretching, or dxSrc if not. If we are asked to
	// dither and stretch together, and we choose to leave the stretching
	// to GDI, we will here set biDraw so that we ask the dither code
	// to dither from dx/dySrc to dx/dyDst - ie stretch and dither in
	// one go. Our current dither code will crash if you ask it to do this.
        dxSave = (int)pdd->biDraw.biWidth;
        dySave = (int)pdd->biDraw.biHeight;
#if 0
        pdd->biDraw.biWidth  = dxDst; // lpbi->biWidth;
        pdd->biDraw.biHeight = dyDst; // lpbi->biHeight;
#endif
	// !!! So DrawDibDraw will not DebugBreak
	pdd->biDraw.biWidth = dxSrc;
	pdd->biDraw.biHeight = dySrc;
        pdd->biDraw.biSizeImage = DIBSIZEIMAGE(pdd->biDraw);


        RPF(("    Dithering %dx%dx%d --> %dx%dx%d", PUSHBI(*lpbi), PUSHBI(pdd->biDraw)));

        //
        //  NOTE we need to use &pdd->biBuffer *not* lpbi because in the
        //  stretched case lpbi will point to pdd->biStretch and biStretch
        //  has NO COLOR TABLE
        //
        pdd->lpDitherTable = DitherInit(&pdd->biBuffer, &pdd->biDraw,
            &pdd->DitherProc, pdd->lpDitherTable);

        if (pdd->lpDitherTable == (LPVOID)-1 ||
            pdd->DitherProc == NULL ||
            !(pdd->pbDither = GlobalAllocPtr(GHND,pdd->biDraw.biSizeImage)))
        {
            if (pdd->lpDitherTable == (LPVOID)-1)
                pdd->lpDitherTable = NULL;

            if (pdd->lpDitherTable)
                DitherTerm(pdd->lpDitherTable);

            if (pdd->pbDither)
                GlobalFreePtr(pdd->pbDither);

            pdd->lpDitherTable = NULL;
            pdd->pbDither = NULL;
            pdd->biDraw.biBitCount = pdd->biBuffer.biBitCount;
            pdd->biDraw.biWidth  = dxSave;
            pdd->biDraw.biHeight = dySave;
            pdd->biDraw.biSizeImage = 0;
            pdd->ulFlags &= ~DDF_DITHER;

#ifdef DEBUG_RETAIL
            if (pdd->DitherProc)
                RPF(("    No Memory for dither tables!"));
            else
                RPF(("    No DitherProc!"));
#endif
        }
    }

    //
    // create a palette (if needed)
    //
    if ((gwRasterCaps & RC_PALETTE) &&
        pdd->biDraw.biBitCount <= 8 &&
        pdd->hpal == NULL)
    {
        pdd->hpal = CreateBIPalette(pdd->hpal, &pdd->biDraw);
        pdd->ulFlags |= DDF_NEWPALETTE;
    }

    //
    // make sure we treat the palette as new when starting/stopping animate
    //
    if (wFlagsChanged & DDF_ANIMATE)
    {
        pdd->ulFlags |= DDF_NEWPALETTE;
    }

    //
    // check for a identity palette
    //
    if (pdd->hpal == NULL)
    {
        pdd->ClrUsed = 0;
    }
    else if (pdd->ulFlags & DDF_NEWPALETTE)
    {
        GetObject(pdd->hpal,sizeof(int),(LPVOID)&pdd->ClrUsed);

        if (wFlagsChanged & DDF_ANIMATE)
            SetPalFlags(pdd->hpal,0,pdd->ClrUsed,0);

        if (IsIdentityPalette(pdd->hpal))
        {
            pdd->ulFlags |= DDF_IDENTITYPAL;
            pdd->iAnimateStart = 10;
        }
        else
        {
            pdd->ulFlags &= ~DDF_IDENTITYPAL;
            pdd->iAnimateStart = 0;
        }

        pdd->iAnimateLen = min(236,pdd->ClrUsed);
        pdd->iAnimateEnd = pdd->iAnimateStart + pdd->iAnimateLen;

        if (pdd->ulFlags & DDF_ANIMATE)
        {
            RPF(("    Palette animation"));
            SetPalFlags(pdd->hpal,pdd->iAnimateStart,pdd->iAnimateLen,PC_RESERVED);
        }
    }

    //
    // because of bugs in GDIs StretchDIBits (doing a stretch) we
    // always set the number of colors to be the maximum.
    //
    // this is not a big deal because we are mostly drawing full-color-table
    // DIBs any way.
    //
    if (pdd->biDraw.biBitCount <= 8)
        pdd->biDraw.biClrUsed = (1 << (int)pdd->biDraw.biBitCount);
    else
        pdd->biDraw.biClrUsed = 0;

    DrawDibSetPalette(hdd, pdd->hpalDraw);

    if (pdd->hpal)
    {
        if (pdd->ulFlags & DDF_IDENTITYPAL)
            RPF(("    Drawing with an identity palette"));
        else
            RPF(("    Drawing with a non-identity palette"));
    }

    if (pdd->uiPalUse == DIB_RGB_COLORS)
        RPF(("    Using DIB_RGB_COLORS"));
    else
        RPF(("    Using DIB_PAL_COLORS"));

    if (pdd->hpalDraw)
        RPF(("    Mapping to another palette"));

    if (pdd->ulFlags & DDF_BITMAP)
    {
        BOOL fGetDC;
        BOOL f;
        HWND hwndActive;

        RPF(("    Display driver slow for DIBs, using bitmaps"));

        if (fGetDC = (hdc == NULL))
        {
            hwndActive = GetActiveWindow();
            hdc = GetDC(hwndActive);
        }

        if (pdd->hdcDraw) {
	    if (hbmStockMono) {
		SelectObject(pdd->hdcDraw, hbmStockMono);
	    }
	} else /* if (!pdd->hdcDraw) */ {
	    pdd->hdcDraw = CreateCompatibleDC(hdc);
	}

        if (pdd->hbmDraw) {
	    // This fixes a memory leak.  Perhaps we can just use the old one?
	    DPF(("Freeing hbmDraw!\n"));
            DeleteObject(pdd->hbmDraw);
	}

        //
        // NOTE the bitmap must be as wide as the source DIB when we are
        // using SetDIBits() because SetDIBits() only takes a start scan not a (x,y)
        //
//      pdd->hbmDraw = CreateCompatibleBitmap(hdc, (int)pdd->biDraw.biWidth, (int)pdd->biDraw.biHeight);
        pdd->hbmDraw = CreateCompatibleBitmap(hdc, (int)pdd->biDraw.biWidth, dySrc);

        if (pdd->hbmDraw == NULL || pdd->hdcDraw == NULL)
            goto bitmap_fail;

        hbmStockMono = SelectObject(pdd->hdcDraw,pdd->hbmDraw);

        pdd->ulFlags |= DDF_NEWPALETTE;

#if USE_SETDI
        f = SetBitmapBegin(
                    &pdd->sd,       //  structure
                    hdc,            //  device
                    pdd->hbmDraw,   //  bitmap to set into
                    &pdd->biDraw,   //  --> BITMAPINFO of source
                    pdd->uiPalUse);
#else
        f = TRUE;
#endif
        if (!f)
        {
bitmap_fail:
            if (pdd->hdcDraw)
                DeleteDC(pdd->hdcDraw);

            if (pdd->hbmDraw)
                DeleteObject(pdd->hbmDraw);

            pdd->hdcDraw = NULL;
            pdd->hbmDraw = NULL;
            pdd->ulFlags &= ~DDF_BITMAP;
        }

        if (fGetDC)
        {
            ReleaseDC(hwndActive, hdc);
            hdc = NULL;
        }
    }

    //
    //  now try to decompress to a bitmap, we only decompress to
    //  bitmaps if the following is true.
    //
    //      the decompressor must decompress direct, we will not
    //      stretch/dither afterward
    //
    //      if on a palette device, the color table must be 1:1
    //
    //  we should check a decompressor flag
    //
    if (pdd->hic &&
        !(pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)) &&
        gfBitmapX &&
	(pdd->lpDIBSection == NULL) &&
        (dxDst == pdd->lpbi->biWidth) &&
        (dyDst == pdd->lpbi->biHeight)
        )
    {

        if (pdd->ulFlags & DDF_BITMAP) {
            if (pdd->hbmDraw) {
                DrawDibQueryBitmapX(pdd);
            }
        } else {

            //even though we decided not to use bitmaps, it might still
            //be worth trying decompression to bitmaps. the DDF_BITMAP
            //flag is based on a comparison of StretchDIBits vs
            //SetDIBits+BitBlt. Decompressing to a bitmap could be
            //faster even when SetDIBits+Bitblt is slower
            // but in this case, if we fail, we have to make sure we don't
            // end up doing DDF_BITMAP as we know that's slower.

#if 0
            if (QueryDraw(pdd, &pdd->biBuffer) & PD_BITBLT_FAST) {

                BOOL fGetDC;
                HWND hwndActive;

                RPF(("    Not using BITMAPS, but trying Decomp to Bitmap"));

                if (fGetDC = (hdc == NULL))
                {
                    hwndActive = GetActiveWindow();
                    hdc = GetDC(hwndActive);
                }

                pdd->hdcDraw = CreateCompatibleDC(hdc);
                pdd->hbmDraw = CreateCompatibleBitmap(hdc, (int)pdd->biDraw.biWidth, (int)pdd->biDraw.biHeight);

                if ((pdd->hbmDraw != NULL) && (pdd->hdcDraw != NULL)) {

                    hbmStockMono = SelectObject(pdd->hdcDraw,pdd->hbmDraw);

                    if (fGetDC)
                    {
                        ReleaseDC(hwndActive, hdc);
                        hdc = NULL;
                    }

                    DrawDibQueryBitmapX(pdd);
                }

                if (!(pdd->ulFlags & DDF_CANBITMAPX)) {
                        if (pdd->hdcDraw) {
                            DeleteDC(pdd->hdcDraw);
			    pdd->hdcDraw = NULL;
			}

                        if (pdd->hbmDraw) {
                            DeleteObject(pdd->hbmDraw);
			    pdd->hbmDraw = NULL;
			}
                }
            }
#endif
        }
    }

#ifndef WIN32    // Note: pdci will be 0 for Win32
    //
    //  see if the decompressor can decompress directly to the screen
    //  doing everything, stretching and all.
    //
    if (pdd->hic && pdci && gfScreenX)
    {
        if (wFlags & DDF_BUFFER)
        {
            DPF(("    DDF_BUFFER specified, unable to decompress to screen"));
            goto cant_do_screen;
        }

	//
	// try to decompress to screen.
	//
        if (((gwRasterCaps & RC_PALETTE) && !(pdd->ulFlags & DDF_IDENTITYPAL)) ||
            (gwScreenBitDepth == 8 && !(gwRasterCaps & RC_PALETTE)) ||
            (pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)) ||
            (ICDecompressExQuery(pdd->hic, 0,
				pdd->lpbi, NULL, 0, 0, pdd->dxSrc, pdd->dySrc,
				(LPBITMAPINFOHEADER) &biScreen, lpScreen,
				0, 0, pdd->dxDst, pdd->dyDst) != ICERR_OK))
	{
cant_do_screen:
	    ; // we can't decompress to the screen
	}
	else
	{   // we can decompress to the screen
	    pdd->ulFlags |= DDF_CLIPCHECK;  // we need clipping checking
	    pdd->ulFlags |= DDF_NEWPALETTE; // force check in DrawDibRealize
	    pdd->ulFlags |= DDF_CANSCREENX; // we can decompress to screen
	    pdd->ulFlags |= DDF_CLIPPED;    // we are initialized for clipped now

	    RPF(("    Can decompress '%4.4hs' to the SCREEN",(LPSTR)&pdd->lpbi->biCompression));
	}
    }

#if 0
    //
    //  see if we can draw direct to the screen
    //
    if (pdd->hic && pdci && gfDrawX)
    {
        if (TRUE)
            goto cant_draw_screen;

        pdd->ulFlags |= DDF_CLIPCHECK;  // we need clipping checking
        pdd->ulFlags |= DDF_NEWPALETTE; // force check in DrawDibRealize
        pdd->ulFlags |= DDF_CANDRAWX;   // we can decompress to screen
        pdd->ulFlags |= DDF_CLIPPED;    // we are initialized for clipped now

        RPF(("    Can draw to the SCREEN"));

cant_draw_screen:
        ;
    }
#endif

#endif

    //
    // see if the source cordinates need translated
    //
    if (abs((int)pdd->biBuffer.biWidth)  != (int)pdd->lpbi->biWidth ||
        abs((int)pdd->biBuffer.biHeight) != (int)pdd->lpbi->biHeight)
    {
        pdd->ulFlags |= DDF_XLATSOURCE;
    }

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibEnd | This function frees a DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies the handle to the DrawDib context to free.
*
* @rdesc Returns TRUE if successful.
*
* @comm Any flags set or palette changes made by <f DrawDibBegin> or
*       <f DrawDibDraw> is discarded by <f DrawDibEnd>.
*
**************************************************************************/
BOOL VFWAPI DrawDibEnd(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    DrawDibFree(pdd, FALSE, FALSE);

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibTime | Returns timing information about
*       the drawing during debug operation.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm LPDRAWDIBTIME | lpddtime | Specifies a pointer to
*       a <t DRAWDIBTIME> structure.
*
* @rdesc Returns TRUE if successful.
*
**************************************************************************/
BOOL VFWAPI DrawDibTime(HDRAWDIB hdd, LPDRAWDIBTIME lpddtime)
{
#ifdef DEBUG_RETAIL
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (lpddtime)
        *lpddtime = pdd->ddtime;

    if (pdd->ddtime.timeCount > 0)
    {
        RPF(("timeCount:       %u",        (UINT)pdd->ddtime.timeCount));
        RPF(("timeDraw:        %ums (%u)", (UINT)pdd->ddtime.timeDraw, (UINT)pdd->ddtime.timeDraw/(UINT)pdd->ddtime.timeCount));
        RPF(("timeDecompress:  %ums (%u)", (UINT)pdd->ddtime.timeDecompress, (UINT)pdd->ddtime.timeDecompress/(UINT)pdd->ddtime.timeCount));
        RPF(("timeDither:      %ums (%u)", (UINT)pdd->ddtime.timeDither, (UINT)pdd->ddtime.timeDither/(UINT)pdd->ddtime.timeCount));
        RPF(("timeStretch:     %ums (%u)", (UINT)pdd->ddtime.timeStretch, (UINT)pdd->ddtime.timeStretch/(UINT)pdd->ddtime.timeCount));
        RPF(("timeSetDIBits:   %ums (%u)", (UINT)pdd->ddtime.timeSetDIBits, (UINT)pdd->ddtime.timeSetDIBits/(UINT)pdd->ddtime.timeCount));
        RPF(("timeBlt:         %ums (%u)", (UINT)pdd->ddtime.timeBlt, (UINT)pdd->ddtime.timeBlt/(UINT)pdd->ddtime.timeCount));
    }

    pdd->ddtime.timeCount      = 0;
    pdd->ddtime.timeDraw       = 0;
    pdd->ddtime.timeDecompress = 0;
    pdd->ddtime.timeDither     = 0;
    pdd->ddtime.timeStretch    = 0;
    pdd->ddtime.timeSetDIBits  = 0;
    pdd->ddtime.timeBlt        = 0;

    return TRUE;
#else
    return FALSE;
#endif
}


/*
 * CopyPal -- copy a palette
 */
HPALETTE CopyPal(HPALETTE hpal)
{
    NPLOGPALETTE    pLogPal = NULL;
    HPALETTE        hpalNew = NULL;
    int             iSizePalette = 0;           // size of entire palette

    if (hpal == NULL)
        return NULL;

    GetObject(hpal,sizeof(iSizePalette),(LPSTR)&iSizePalette);

    pLogPal = (NPLOGPALETTE)LocalAlloc(LPTR, sizeof(LOGPALETTE)
            + iSizePalette * sizeof(PALETTEENTRY));

    if (!pLogPal)
        return NULL;

    pLogPal->palVersion = 0x300;
    pLogPal->palNumEntries = iSizePalette;

    GetPaletteEntries(hpal, 0, iSizePalette, pLogPal->palPalEntry);

    hpal = CreatePalette(pLogPal);

    LocalFree((HLOCAL) pLogPal);

    return hpal;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api HPALETTE | DrawDibGetPalette | This function obtains the palette
*      used by a DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @rdesc Returns a handle for the palette if successful, otherwise
*        it returns NULL.
*
* @comm Use <f DrawDibRealize> instead of this function
*       to realize the correct palette in response to a window
*       message. You should rarely need to call this function.
*
*       Applications do not have exclusive use of the palette
*       obtained with this function. Applications should not
*       free the palette or assign it to a display context
*       with functions such as <f SelectPalette>. Applications
*       should also anticipate that some other
*       application can invalidate the handle. The palette
*       handle might also become invalid after the next use of a DrawDib function.
*
*       This function returns a valid handle only after
*       <f DrawDibBegin> has been used without pairing it with
*       <f DrawDibEnd>, or if <f DrawDibDraw> has been used.
*
* @xref <f DrawDibSetPalette> <f DrawDibRealize>
*
**************************************************************************/
HPALETTE VFWAPI DrawDibGetPalette(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return NULL;

    if (pdd->hpalDraw)
        return pdd->hpalDraw;
    else {
        // For palette animation we can't return a different palette than the
        // real palette, so return hpal, not hpalCopy.
        // Just trust me.  - Toddla

        if (pdd->ulFlags & DDF_ANIMATE)
            return pdd->hpal;

        // In order for us to play direct to screen, etc, all palette
        // realization has to come through DrawDibRealize.  But that won't
        // always happen.  Some apps will always ask us for our palette and
        // realize it themselves.  So if we give them a copy of our palette,
        // and never our true palette, when our play code realizes the true
        // palette it's guarenteed to cause an actual palette change and we'll
        // correctly detect playing to screen. (BUG 1761)

        if (pdd->hpalCopy == NULL)
            pdd->hpalCopy = CopyPal(pdd->hpal);

        return pdd->hpalCopy;
    }
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibSetPalette | This function sets the palette
*      used for drawing device independent bitmaps.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HPALETTE | hpal | Specifies a handle to the palette.
*       Specify NULL to use the default palette.
*
* @rdesc Returns TRUE if successful.
*
* @comm Use this function when the application needs to realize an
*   alternate palette. The function forces the DrawDib context to use the
*   specified palette, possibly at the expense of image quality.
*
*   Do not free a palette assigned to a DrawDib context until
*   either a new palette replaces it (for example, if hpal1 is the
*   current palette, replacing it with DrawDibSetPalette(hdd, hpal2)),
*   or until the palette handle for the DrawDib context is set to
*   to the default palette (for example, DrawDibSetPalette(hdd, NULL)).
*
* @xref <f DrawDibGetPalette>
*
**************************************************************************/
BOOL VFWAPI DrawDibSetPalette(HDRAWDIB hdd, HPALETTE hpal)
{
    PDD pdd;
    int i;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (hpal == pdd->hpalCopy)
        hpal = NULL;

    if (pdd->hpalDraw != hpal)
        pdd->ulFlags |= DDF_NEWPALETTE;

    pdd->hpalDraw = hpal;       // always set this variable

    if (pdd->hpal == NULL)      // no palette to dink with
        return TRUE;

    if (pdd->biDraw.biBitCount > 8) // make sure we are drawing palettized
        return TRUE;

    if (pdd->ulFlags & DDF_ANIMATE)
    {
        DPF(("DrawDibSetPalette called while in DDF_ANIMATE mode!"));
    }

    //
    //  we are now using PAL colors...
    //
    pdd->uiPalUse = DIB_PAL_COLORS;

    if (pdd->hpalDraw != NULL)
    {
        /* Set up table for BI_PAL_COLORS non 1:1 drawing */

        //
        //  map all of our colors onto the given palette
        //  NOTE we can't use the select background trick
        //  because the given palette <hpalDraw> may have
        //  PC_RESERVED entries in it.
        //
        // SendSetPalette(pdd);

        for (i=0; i < 256; i++)
        {
            if (pdd->biBuffer.biBitCount == 8)
            {
                pdd->aw[i] = GetNearestPaletteIndex(pdd->hpalDraw,
                                                    RGB(pdd->argbq[i].rgbRed,
                                                        pdd->argbq[i].rgbGreen,
                                                        pdd->argbq[i].rgbBlue));
            }
            else
            {
                PALETTEENTRY pe;
                GetPaletteEntries(pdd->hpal, i, 1, &pe);
                pdd->aw[i] = GetNearestPaletteIndex(pdd->hpalDraw,
                                                    RGB(pe.peRed,
                                                        pe.peGreen,
                                                        pe.peBlue));
            }
        }

        for (; i<256; i++)
            pdd->aw[i] = 0;
    }
    else
    {
        /* Set up table for BI_PAL_COLORS 1:1 drawing */

        // SendSetPalette(pdd);
        for (i=0; i<(int)pdd->ClrUsed; i++)
            pdd->aw[i] = i;

        for (; i<256; i++)
            pdd->aw[i] = 0;
    }

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibChangePalette | This function sets the palette entries
*      used for drawing device independent bitmaps.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm int | iStart | Specifies the starting palette entry number.
*
* @parm int | iLen | Specifies the number of palette entries.
*
* @parm LPPALETTEENTRY | lppe | Specifies a pointer to an
*       array of palette entries.
*
* @rdesc Returns TRUE if successful.
*
* @comm
*   Use this function when the DIB color table changes and
*   other parameters stay constant. This function changes
*   the physical palette only if the current
*   DrawDib palette is curently realized by calling <f DrawDibRealize>.
*
*   The DIB color table must be changed by the user or
*   the next use of <f DrawDibDraw> without the DDF_SAME_DRAW flag
*   implicity calls <f DrawDibBegin>.
*
*   If the DDF_ANIMATE flag is not set in the previous call to
*   <f DrawDibBegin> or <f DrawDibDraw>, this function will
*   animate the palette. In this case, update the DIB color
*   table from the palette specified by <p lppe> and use
*   <f DrawDibRealize> to realize the updated palette. Redraw
*   the image to see the updated colors.
*

* @xref <f DrawDibSetPalette> <f DrawDibRealize>
*
**************************************************************************/
BOOL VFWAPI DrawDibChangePalette(HDRAWDIB hdd, int iStart, int iLen, LPPALETTEENTRY lppe)
{
    PDD pdd;
    int i;

    int iStartSave;
    int iLenSave;
    LPPALETTEENTRY lppeSave;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (pdd->biBuffer.biBitCount != 8)
        return FALSE;

    if (lppe == NULL || iStart < 0 || iLen + iStart > 256)
        return FALSE;

    for (i=0; i<iLen; i++)
    {
	(*(pdd->lpargbqIn))[iStart+i].rgbRed   = lppe[i].peRed;
	(*(pdd->lpargbqIn))[iStart+i].rgbGreen = lppe[i].peGreen;
	(*(pdd->lpargbqIn))[iStart+i].rgbBlue  = lppe[i].peBlue;
    }

    //
    // handle a palette change for 8bit dither
    //
    if (pdd->lpDitherTable)
    {
        for (i=0; i<iLen; i++)
        {
            pdd->argbq[iStart+i].rgbRed   = lppe[i].peRed;
            pdd->argbq[iStart+i].rgbGreen = lppe[i].peGreen;
            pdd->argbq[iStart+i].rgbBlue  = lppe[i].peBlue;
        }

        pdd->lpDitherTable = DitherInit(pdd->lpbi, &pdd->biDraw, &pdd->DitherProc, pdd->lpDitherTable);
    }
    else if (pdd->hpalDraw)
    {
        SetPaletteEntries(pdd->hpal, iStart, iLen, lppe);
        pdd->ulFlags |= DDF_NEWPALETTE;

        for (i=iStart; i<iLen; i++)
        {
            pdd->aw[i] = GetNearestPaletteIndex(pdd->hpalDraw,
                RGB(lppe[i].peRed,lppe[i].peGreen,lppe[i].peBlue));
        }
    }
    else if (pdd->ulFlags & DDF_ANIMATE)
    {
        for (i=iStart; i<iStart+iLen; i++)
        {
            if (i >= pdd->iAnimateStart && i < pdd->iAnimateEnd)
                lppe[i-iStart].peFlags = PC_RESERVED;
            else
                lppe[i-iStart].peFlags = 0;
        }

        /* Change iLen, iStart so that they only include the colors
        ** we can actually animate.  If we don't do this, the
        ** AnimatePalette() call just returns without doing anything.
        */

        iStartSave = iStart;
        iLenSave   = iLen;
        lppeSave   = lppe;

        if (iStart < pdd->iAnimateStart)
        {
            iLen -= (pdd->iAnimateStart - iStart);
            lppe += (pdd->iAnimateStart - iStart);
            iStart = pdd->iAnimateStart;
        }

        if (iStart + iLen > pdd->iAnimateEnd)
            iLen = pdd->iAnimateEnd - iStart;

        AnimatePalette(pdd->hpal, iStart, iLen, lppe);

        //
        //  any colors we could not animate, map to nearest
        //
        for (i=iStartSave; i<iStartSave+iLenSave; i++)
        {
            if (i >= pdd->iAnimateStart && i < pdd->iAnimateEnd)
                pdd->aw[i] = i;
            else
                pdd->aw[i] = GetNearestPaletteIndex(pdd->hpal,
                    RGB(lppeSave[i-iStartSave].peRed,
                        lppeSave[i-iStartSave].peGreen,
                        lppeSave[i-iStartSave].peBlue));
        }
    }
    else if (pdd->hpal)
    {
        SetPaletteEntries(pdd->hpal, iStart, iLen, lppe);
        pdd->ulFlags |= DDF_NEWPALETTE;
    }
    else
    {
        for (i=0; i<iLen; i++)
        {
            ((RGBQUAD *)pdd->aw)[iStart+i].rgbRed   = lppe[i].peRed;
            ((RGBQUAD *)pdd->aw)[iStart+i].rgbGreen = lppe[i].peGreen;
            ((RGBQUAD *)pdd->aw)[iStart+i].rgbBlue  = lppe[i].peBlue;
        }

        if (pdd->hbmDraw)
            pdd->ulFlags |= DDF_NEWPALETTE;
    }

#ifdef DIBSECTION
    if (pdd->lpDIBSection) {

	// the colour table of a DIB Section is not changed when the palette
	// used to create it changes. We need to explicitly change it.
	SetDIBColorTable(pdd->hdcDraw, iStart, iLen,
		&(*(pdd->lpargbqIn))[iStart]);
    }
#endif

//    We'll break buggy apps if we delete a palette we've given them
//    even though we told them not to use it.
//
//    if (pdd->hpalCopy)
//      DeleteObject(pdd->hpalCopy);
//    pdd->hpalCopy = NULL;

    return TRUE;
}

/**************************************************************************
*
* @doc EXTERNAL DrawDib
*
* @api UINT | DrawDibRealize | This function realizes palette
*      of the display context specified into the DrawDib context.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to the display context containing
*       the palette.
*
* @parm BOOL | fBackground | If set to a nonzero value,
*       the selected palette is selected as a background palette.
*       If this is set to zero and the device context is attached
*       to a window, the logical palette is a foreground palette when
*       the window has the input focus. (The device context is attached
*       to a window if it was obtained by using the <f GetDC> function
*       or if the window-class style is CS_OWNDC.)
*
* @rdesc Returns number of entries in the logical palette
*        mapped to different values in the system palette. If
*        an error occurs or no colors were updated, it returns zero.
*
* @comm  This function should only be used to
*        handle a <m WM_PALETTECHANGE> or <m WM_QUERYNEWPALETTE>
*        message, or used in conjunction with the DDF_SAME_HDC flag
*        to prepare a display context prior to calling <f DrawDibDraw>
*        multiple times.
*
* @ex    The following example shows how the function is used to
*        handle a <m WM_PALETTECHANGE> or <m WM_QUERYNEWPALETTE>
*        message: |
*
*               case WM_PALETTECHANGE:
*                   if ((HWND)wParam == hwnd)
*                       break;
*
*               case WM_QUERYNEWPALETTE:
*                   hdc = GetDC(hwnd);
*
*                   f = DrawDibRealize(hdd, hdc, FALSE) > 0;
*
*                   ReleaseDC(hwnd, hdc);
*
*                   if (f)
*                       InvalidateRect(hwnd, NULL, TRUE);
*                   break;
*
* @ex   The following example shows using <f DrawDibRealize> prior to
*       calling <f DrawDibDraw> multiple times: |
*
*               hdc = GetDC(hwnd);
*               DrawDibRealize(hdd, hdc, fBackground);
*               DrawDibDraw(hdd, hdc, ..........., DDF_SAME_DRAW|DDF_SAME_HDC);
*               DrawDibDraw(hdd, hdc, ..........., DDF_SAME_DRAW|DDF_SAME_HDC);
*               DrawDibDraw(hdd, hdc, ..........., DDF_SAME_DRAW|DDF_SAME_HDC);
*               ReleaseDC(hwnd, hdc);
*
* @ex   The following example shows using <f DrawDibRealize> with <f DDF_ANIMATE>
*       and (f DrawDibChangePalette> to do palette animation |
*
*               hdc = GetDC(hwnd);
*               DrawDibBegin(hdd, ....., DDF_ANIMATE);
*               DrawDibRealize(hdd, hdc, fBackground);
*               DrawDibDraw(hdd, hdc, ...., DDF_SAME_DRAW|DDF_SAME_HDC);
*               DrawDibChangePalette(hdd, ....);
*               ReleaseDC(hwnd, hdc);
*
* @comm To draw an image mapped to another palette use <f DrawDibSetPalette>.
*
*        To make <f DrawDibDraw> select its palette as a background palette
*        use the DDF_BACKGROUNDPAL flag and not this function.
*
*        While the DrawDib palette is selected into the display context,
*        do not call <f DrawDibEnd>, <f DrawDibClose>, <f DrawDibBegin>, or
*        <f DrawDibDraw> (with a different draw/format) on the same DrawDib
*        context <p hdd>. These can free the selected palette
*        while it is being used by your display context and cause
*        a GDI error.
*
*        <f DrawDibRealize> will return 0 if called before a
*        <f DrawDibBegin> or <f DrawDibDraw>
*
* @xref <f SelectPalette>
*
**************************************************************************/
UINT VFWAPI DrawDibRealize(HDRAWDIB hdd, HDC hdc, BOOL fBackground)
{
    PDD pdd;
    HPALETTE hpal;
    UINT u;

    if (hdc == NULL)
	return 0;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return 0;

    if (IsScreenDC(hdc))
        pdd->ulFlags &= ~DDF_MEMORYDC;
    else
        pdd->ulFlags |= DDF_MEMORYDC;

    if (pdd->ulFlags & DDF_MEMORYDC)
        DPF(("Drawing to a memory DC"));

    SetStretchBltMode(hdc, COLORONCOLOR);

    //
    // what palette should we realize
    //
    hpal = pdd->hpalDraw ? pdd->hpalDraw : pdd->hpal;

    //
    // if we dont have a palette, we have nothing to realize
    // still call DrawDibPalChange though
    //
    if (hpal == NULL)
    {
        if (pdd->ulFlags & DDF_NEWPALETTE)
        {
            DrawDibPalChange(pdd, hdc, hpal);
            pdd->ulFlags &= ~DDF_NEWPALETTE;
        }

        return 0;
    }

// !!! There is a bug in GDI that will not map an identity palette 1-1 into
// !!! the system palette every time, which hoses us and makes it look like
// !!! dog spew.  This ICKITY-ACKITY-OOP code will flush the palette and
// !!! prevent the bug... BUT it introduces another bug where if we are a
// !!! background app, we hose everybody else's palette but ours.  So let's
// !!! live with the GDI bug.  One other thing... attempting this fix will
// !!! cause the bug to repro more often than it would have if you had left
// !!! it alone, unless you do the fix JUST RIGHT!  I don't trust myself
// !!! that much.
#if 0
    if ((pdd->ulFlags & DDF_NEWPALETTE) && (pdd->ulFlags & DDF_IDENTITYPAL) &&
                !fBackground)
    {
        //
        // this will flush the palette clean to avoid a GDI BUG!!!
        //
        SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
        SetSystemPaletteUse(hdc, SYSPAL_STATIC);
    }
#endif

    //
    // select and realize it
    //
    SelectPalette(hdc, hpal, fBackground);
    u = RealizePalette(hdc);

    // !!! If two DrawDib instances share the same palette handle, the second
    // one will not change any colours and u will be 0, and it will not stop
    // decompressing to screen or recompute stuff for bitmaps when it goes
    // into the background and it will get a messed up palette.
    // !!! This is a known bug we don't care about
    //
    // this should be fixed by the hpalCopy stuff.

    if (u > 0 || (pdd->ulFlags & DDF_NEWPALETTE))
    {
        pdd->ulFlags |= DDF_NEWPALETTE;
        DrawDibPalChange(pdd, hdc, hpal);
        pdd->ulFlags &= ~DDF_NEWPALETTE;
    }

    return u;
}

/**************************************************************************
* @doc EXTERNAL DrawDib VFW11
*
* @api LPVOID | DrawDibGetBuffer | This function returns the pointer
*      to the DrawDib decompress buffer.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a pointer to a
*        <t BITMAPINFOHEADER> structure.
*
* @parm DWORD | dwSize | Specifies the size of the buffer pointed to by <p lpbi>
*
* @parm DWORD | dwFlags | Set to zero.
*
* @rdesc Returns a pointer to the buffer used by DrawDib for decompression,
*        or NULL if no buffer is used. If <p lpbi> is not NULL,
*        it is filled in with a copy of the <t BITMAPINFOHEADER>
*        describing the buffer.
*
*        The structure for <p lpbi> must have room for a
*        <t BITMAPINFOHEADER> and 256 colors.
*
**************************************************************************/

LPVOID VFWAPI DrawDibGetBuffer(HDRAWDIB hdd, LPBITMAPINFOHEADER lpbi, DWORD dwSize, DWORD dwFlags)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return NULL;

    if (lpbi)
    {
        hmemcpy(lpbi, &pdd->biBuffer,
            min(dwSize, pdd->biBuffer.biSize + 256*sizeof(RGBQUAD)));
    }

    return pdd->pbBuffer;
}

LPVOID VFWAPI DrawDibGetBufferOld(HDRAWDIB hdd, LPBITMAPINFOHEADER lpbi)
{
    return DrawDibGetBuffer(hdd, lpbi, sizeof(BITMAPINFOHEADER), 0);
}

/**************************************************************************
* @doc EXTERNAL DrawDibStart
*
* @api BOOL | DrawDibStart | This function prepares a DrawDib
*      context for streaming playback.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm LONG | rate | Specifies the playback rate (in microseconds per frame).
*
* @rdesc Returns TRUE if successful.
*
* @xref <f DrawDibStop>
*
**************************************************************************/
BOOL VFWAPI DrawDibStart(HDRAWDIB hdd, DWORD rate)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (pdd->hic == (HIC)-1)
        return FALSE;

    // if the codec does not care about this message dont fail.

    if (pdd->hic != NULL)
        ICSendMessage(pdd->hic, ICM_DRAW_START, rate, 0);

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDibStop
*
* @api BOOL | DrawDibStop | This function frees the resources
*      used by a DrawDib context for streaming playback.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @rdesc Returns TRUE if successful.
*
* @xref <f DrawDibStart>
*
**************************************************************************/
BOOL VFWAPI DrawDibStop(HDRAWDIB hdd)
{
    PDD pdd;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (pdd->hic == (HIC)-1)
        return FALSE;

    if (pdd->hic != NULL)
        ICSendMessage(pdd->hic, ICM_DRAW_STOP, 0, 0);

    return TRUE;
}

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibUpdate | This macro updates the last
*      buffered frame drawn.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to the display context.
*
* @parm int | xDst | Specifies the x-coordinate of the upper left-corner
*       of the destination rectangle. Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @parm int | yDst | Specifies the y-coordinate of the upper-left corner
*       of the destination rectangle.  Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @rdesc Returns TRUE if successful.
*
* @comm This macro uses <f DrawDibDraw> to send the DDF_UPDATE flag
*       to the DrawDib context.
*
**************************************************************************/

/**************************************************************************
* @doc EXTERNAL DrawDib
*
* @api BOOL | DrawDibDraw | This function draws a device independent
*      bitmap to the screen.
*
* @parm HDRAWDIB | hdd | Specifies a handle to a DrawDib context.
*
* @parm HDC | hdc | Specifies a handle to the display context.
*
* @parm int | xDst | Specifies the x-coordinate of the upper left-corner
*       of the destination rectangle. Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @parm int | yDst | Specifies the y-coordinate of the upper-left corner
*       of the destination rectangle. Coordinates are specified
*       in MM_TEXT client coordinates.
*
* @parm int | dxDst | Specifies the width of the destination rectangle.
*       The width is specified in MM_TEXT client coordinates. If
*       <p dxDst> is -1, the width of the bitmap is used.
*
* @parm int | dyDst | Specifies the height of the destination rectangle.
*       The height is specified in MM_TEXT client coordinates. If
*       <p dyDst> is -1, the height of the bitmap is used.
*
* @parm LPBITMAPINFOHEADER | lpbi | Specifies a pointer to the
*       <t BITMAPINFOHEADER> structure for the bitmap. The color
*       table for the DIB follows the format information. The
*       height specified for the DIB in the structure must be
*       positive (that is, this function will not draw inverted DIBs).
*
* @parm LPVOID | lpBits | Specifies a pointer to the buffer
*       containing the bitmap bits.
*
* @parm int | xSrc | Specifies the x-coordinate of the upper-left corner
*       source rectangle. Coordinates are specified in pixels.
*       The coordinates (0,0) represent the upper left corner
*       of the bitmap.
*
* @parm int | ySrc | Specifies the y-coordinate of the upper left corner
*       source rectangle. Coordinates are specified in pixels.
*       The coordinates (0,0) represent the upper left corner
*       of the bitmap.
*
* @parm int | dxSrc | Specifies the width of the source rectangle.
*       The width is specified in pixels.
*
* @parm int | dySrc | Specifies the height of the source rectangle.
*       The height is specified in pixels.
*
* @parm UINT | wFlags | Specifies any applicable flags for drawing.
*       The following flags are defined:
*
* @flag DDF_UPDATE | Indicates the last buffered bitmap is to be redrawn.
*       If drawing fails with this flag, a buffered image is not available
*       and a new image needs to be specified before the display is updated.
*
* @flag DDF_SAME_HDC | Assumes the display context has been prepared with
*       <f DrawDibRealize> prior to this call and <f DrawDibDraw> should not
*       initialize it.
*
* @flag DDF_SAME_DRAW | Uses the drawing parameters previously
*       specified for this function.  Use this flag only
*       if <p lpbi>, <p dxDst>, <p dyDst>, <p dxSrc>, and <p dySrc>
*       have not changed since using <f DrawDibDraw> or <f DrawDibBegin>.
*       Normally <f DrawDibDraw> checks the parameters, and if they
*       have changed, <f DrawDibBegin> prepares the DrawDib context
*       for drawing.
*
* @flag DDF_DONTDRAW | Indicates the frame is not to be drawn and will
*       later be recalled with the <f DDF_UPDATE> flag. DrawDib does
*       not buffer an image if an offscreen buffer does not exist.
*       In this case, DDF_DONTDRAW draws the frame to the screen and
*       the subsequent use of DDF_UPDATE fails. DrawDib does
*       guarantee that the following will
*       always draw "image" B to the screen.
*
*           DrawDibDraw(hdd, ..., lpbiA, ..., DDF_DONTDRAW);
*
*           DrawDibDraw(hdd, ..., lpbiB, ..., DDF_DONTDRAW);
*
*           DrawDibDraw(hdd, ..., NULL,  ..., DDF_UPDATE);
*
*       The DDF_UPDATE and DDF_DONTDRAW flags are used
*       together to create composite images
*       offscreen, and then do a final update when finished.
*
* @flag DDF_HURRYUP | Indicates the data does not have to
*       drawn (that is, it can be dropped) and the DDF_UPDATE flags will
*       not be used to recall this information. DrawDib looks at
*       this data only if it is required to build the next frame, otherwise
*       the data is ignored.
*
*       This flag is usually used to resynchronize video and audio. When
*       resynchronizing data, applications should send the image
*       with this flag in case the driver needs to
*       to buffer the frame to decompress subsequent frames.
*
* @flag DDF_UPDATE | Indicates the last buffered bitmap is to be redrawn.
*       If drawing fails with this flag, a buffered image is not available
*       and a new image needs to be specified before the display is updated.
*       For more information, see the <f DDF_DONTDRAW> flag.
*
* @flag DDF_BACKGROUNDPAL | Realizes the palette used for drawing
*       in the background leaving the actual palette used for display
*       unchanged.  (This flag is valid only if DDF_SAME_HDC is not set.)
*
* @flag DDF_HALFTONE | Always dithers the DIB to a standard palette
*       regardless of the palette of the DIB. If using <f DrawDibBegin>,
*       set this flag for it rather than <f DrawDibDraw>.
*
* @flag DDF_NOTKEYFRAME | Indicates the DIB data is not a key frame.
*
* @flag DDF_HURRYUP | Indicates the DIB data does not have to
*       drawn (that is, it can be dropped). This flag is usually
*       used to resynchronize the video to the audio. When
*       resynchronizing data, applications should send the image
*       with this flag in case the driver needs to
*       to buffer the frame to decompress subsequent frames.
*
* @rdesc Returns TRUE if successful.
*
* @comm This function replaces <f StretchDIBits> and supports
*       decompression of bitmaps by installable compressors.
*       This function dithers true color bitmaps properly on
*       8-bit display devices.
*
**************************************************************************/

BOOL VFWAPI DrawDibDraw(HDRAWDIB hdd,
                            HDC      hdc,
                            int      xDst,
                            int      yDst,
                            int      dxDst,
                            int      dyDst,
                            LPBITMAPINFOHEADER lpbi,
                            LPVOID   lpBits,
                            int      xSrc,
                            int      ySrc,
                            int      dxSrc,
                            int      dySrc,
                            UINT     wFlags)
{
    PDD     pdd;
    BOOL    f;
    RECT    rc;
    DWORD   icFlags;
    DWORD   dw;

    if ((pdd = DrawDibLock(hdd)) == NULL)
        return FALSE;

    if (hdc == NULL)
        return FALSE;

    if (wFlags & DDF_UPDATE)
    {
        lpbi = pdd->lpbi;

        dxDst = pdd->dxDst;
        dyDst = pdd->dyDst;
        dxSrc = pdd->dxSrc;
        dySrc = pdd->dySrc;
    }
    else
    {
        if (lpbi == NULL)
            return FALSE;

        //
        // fill in defaults.
        //
        if (dxSrc < 0)
            dxSrc = (int)lpbi->biWidth - xSrc;

        if (dySrc < 0)
            dySrc = (int)lpbi->biHeight - ySrc;

        if (dxDst < 0)
            dxDst = dxSrc;

        if (dyDst < 0)
            dyDst = dySrc;
    }
#ifdef DEBUG_RETAIL
    if (xSrc  <  0 ||
        ySrc  <  0 ||
        dxSrc <= 0 ||
        dySrc <= 0 ||
        xSrc + dxSrc > (int)lpbi->biWidth ||
        ySrc + dySrc > (int)lpbi->biHeight)
    {
        RPF(("DrawDibBegin(): bad source parameters [%d %d %d %d]", xSrc, ySrc, dxSrc, dySrc));
//      return 0;   // see what happens.
    }
#endif

    if (dxSrc == 0 || dySrc == 0)       // !!! || dxDst == 0 || dyDst == 0)
        return FALSE;

    //
    // check and make sure the params of the draw has not changed
    //
    if (!(wFlags & (DDF_SAME_DRAW|DDF_UPDATE)) &&
        !(DibEq(pdd->lpbi, lpbi) &&
          !(((UINT)pdd->ulFlags ^ wFlags) & DDF_HALFTONE) &&
        pdd->dxDst == dxDst &&
        pdd->dyDst == dyDst &&
        pdd->dxSrc == dxSrc &&
        pdd->dySrc == dySrc))
    {
        wFlags &= ~(DDF_UPDATE | DDF_FULLSCREEN);
        if (!DrawDibBegin(hdd, hdc, dxDst, dyDst, lpbi, dxSrc, dySrc, wFlags))
            return FALSE;
    }

    TIMEINC();      // should we include DibEq?
    TIMESTART(timeDraw);

    // convert to DIB cordinates
    ySrc = (int)pdd->lpbi->biHeight - (ySrc + dySrc);

    //
    // Initialize the DC:  We need to realize the palette if we are not
    // guarenteed to be using the same DC as before, if we've been told we
    // have a new palette, or if we are mapping to somebody else's palette.
    // The owner of the palette could be changing it on us all the time or
    // doing who knows what, so to be safe we will realize it every frame.
    // If nothing's changed, this should be a really cheap operation, and
    // it doesn't appear to be causing any palette fights that end in somebody
    // getting hurt.  This is required for Magic School Bus, and PageMaster,
    // at the very least. (WIN95B 12204 and 9637)
    //
    if (!(wFlags & DDF_SAME_HDC) || (pdd->ulFlags & DDF_NEWPALETTE) ||
							pdd->hpalDraw)
    {
        //
        // image will be totally clipped anyway
        //
        if (GetClipBox(hdc, &rc) == NULLREGION)
        {
            wFlags |= DDF_DONTDRAW;
        }

        //
        // select and realize the palette.
        //
        // NOTE you must unselect this thing, dont return early
        //

        DrawDibRealize(hdd, hdc, (wFlags & DDF_BACKGROUNDPAL) != 0);
    }

#ifndef WIN32
    //
    //  do a clipping check
    //
    if (pdd->ulFlags & DDF_CLIPCHECK)
    {
        RECT  rc;

        if (!(pdd->ulFlags & DDF_CLIPPED) &&
            (pdd->iDecompress == DECOMPRESS_SCREEN) && // (pdd->ulFlags & DDF_SCREENX) &&
            (wFlags & (DDF_PREROLL|DDF_DONTDRAW)))
        {
            DPF(("DDF_DONTDRAW while decompressing to screen, staying clipped"));
        }

        if ((pdd->ulFlags & DDF_MEMORYDC) ||
            GetClipBox(hdc, &rc) != SIMPLEREGION ||
            xDst < rc.left ||
            yDst < rc.top ||
            xDst + dxDst > rc.right ||
            yDst + dyDst > rc.bottom ||
            (wFlags & (DDF_PREROLL|DDF_DONTDRAW)) ||
            (gfDisplayHasBrokenRasters &&
		     (DCNotAligned(hdc, xDst) || gwScreenBitDepth == 24)))
	    // Note: if we're on a 24-bit display with broken rasters, we don't
	    // decompress to the screen even if the rectangle is aligned,
	    // because it's just too easy for somebody to try to write out
	    // a whole pixel in one gulp and hit the 64K boundary.
        {
            //
            //  we are clipped, check for a change.
            //
            if (!(pdd->ulFlags & DDF_CLIPPED))
            {
                pdd->ulFlags |= DDF_CLIPPED;
                DrawDibClipChange(pdd, wFlags);
            }
        }
        else
        {
            //
            // we are now unclipped, check for a change
            //
            if (pdd->ulFlags & DDF_CLIPPED)
            {
#ifdef DEBUG
		if (DCNotAligned(hdc, xDst))
                    DPF(("Warning draw is not aligned on 4 pixel boundry"));
#endif
                pdd->ulFlags &= ~DDF_CLIPPED;
                DrawDibClipChange(pdd, wFlags);
            }
        }
    }

#endif  //WIN32
    if (pdd->ulFlags & DDF_WANTKEY)
    {
        //
        // Adobe hack: If the DDF_UPDATE flag is on in our internal
        // flags, that means we've just been getting a bunch of frames
        // with the DONTDRAW flag set.  In that case, if this frame
        // immediately after those frames is marked as a key frame
        // we assume that it might not be a key frame and refrain from
        // switching immediately to decompressing to screen.
        //
        if (!(wFlags & DDF_NOTKEYFRAME) && !(pdd->ulFlags & DDF_UPDATE))
        {
            pdd->ulFlags &= ~DDF_WANTKEY;
            DrawDibClipChange(pdd, wFlags);
        }
    }

    //
    // if update is set re-draw what ever we drew last time
    //
    if (wFlags & DDF_UPDATE)
    {
        if (pdd->hic == (HIC)-1 || (pdd->ulFlags & DDF_DIRTY))
        {
            f = FALSE;
            goto exit;
        }

        if (pdd->hic)
        {
            if (pdd->ulFlags & DDF_UPDATE)
            {
                goto redraw;
            }

            lpbi = &pdd->biBuffer;
            lpBits = pdd->pbBuffer;

            //!!! set the source right.

            if ((pdd->ulFlags & DDF_XLATSOURCE))
            {
                dxSrc = MulDiv(dxSrc, abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
                dySrc = MulDiv(dySrc, abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
                xSrc  = MulDiv(xSrc,  abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
                ySrc  = MulDiv(ySrc,  abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
            }
        }

        if (pdd->ulFlags & DDF_STRETCH)
        {
            lpbi  = &pdd->biStretch;
            lpBits = pdd->pbStretch;
            dxSrc  = dxDst;
            dySrc  = dyDst;
            xSrc   = 0;
            ySrc   = 0;
        }

        if (pdd->ulFlags & DDF_DITHER)
        {
            lpBits = pdd->pbDither;
            xSrc = 0;
            ySrc = 0;
        }

        if (pdd->lpDIBSection != NULL)
	    goto bltDIB;

        if (pdd->hbmDraw && (pdd->ulFlags & DDF_BITMAP))
            goto bltit;


        if (lpBits == NULL)
        {
            f = FALSE;       // no buffer, can't update....
            goto exit;
        }

        goto drawit;
    }

    //
    // default for bits pointerdefault
    //
    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi+(int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD);

    //
    // call any decompressor if needed
    //
    if (pdd->hic)
    {
        if (pdd->hic == (HIC)-1)
        {
            f = FALSE;
            goto exit;
        }

#ifndef WIN32 // exclude all code that references biscreen

        if (pdd->iDecompress == DECOMPRESS_SCREEN) // ulFlags & DDF_SCREENX
        {
            //
            // we are decompressing to the screen not the buffer, so
            // the buffer is dirty now
            //
            pdd->ulFlags |= DDF_DIRTY;

            dw = GetDCOrg(hdc);
            xDst += LOWORD(dw);
            yDst += HIWORD(dw);


            //
            // if DCIBeginAccess fails we are in the background, and should
            // not draw.
            //
            if (DCIBeginAccess(pdci, xDst, yDst, dxDst, dyDst) != 0)
            {
                DPF(("DCIBeginAccess failed!!!"));
                f = TRUE;       //!!! is this right?
                goto exit;
            }

            //convert to DIB corrds.
            yDst = (int)pdci->dwHeight - (yDst + dyDst);

            TIMESTART(timeDecompress);

            icFlags = 0;

            if (wFlags & DDF_HURRYUP)
                icFlags |= ICDECOMPRESS_HURRYUP;

            if (wFlags & DDF_NOTKEYFRAME)
                icFlags |= ICDECOMPRESS_NOTKEYFRAME;

            dw = ICDecompressEx(pdd->hic, icFlags,
                                lpbi, lpBits, xSrc, ySrc, dxSrc, dySrc,
                                &biScreen, lpScreen,
                                xDst, yDst, dxDst, dyDst);

            if (dw == ICERR_DONTDRAW)
                dw = ICERR_OK;

            f = (dw == ICERR_OK);

            TIMEEND(timeDecompress);

            DCIEndAccess(pdci);
            goto exit;
        }
        else
#endif // biscreen references
        {
            //
            //  if the offscreen buffer is dirty, only a key frame will
            //  clean our soul.
            //
            if (pdd->ulFlags & DDF_DIRTY)
            {
                if (wFlags & DDF_NOTKEYFRAME)
                {
                    //!!! playing files with no key frames we will get into
                    //a state where we will never draw a frame ever again.
                    //we need a punt count?

                    DPF(("punt frame"));

                    f = TRUE;
                    goto exit;
                }
                else // if (!(wFlags & DDF_HURRYUP))
                {
                    pdd->ulFlags &= ~DDF_DIRTY;
                }
            }

            TIMESTART(timeDecompress);

            icFlags = 0;

            if (wFlags & DDF_HURRYUP)
                icFlags |= ICDECOMPRESS_HURRYUP;

            if (wFlags & DDF_NOTKEYFRAME)
                icFlags |= ICDECOMPRESS_NOTKEYFRAME;

            if (pdd->iDecompress == DECOMPRESS_BITMAP) // ulFlags & DDF_BITMAPX
            {
                //!!! should we check FASTTEMPORALD?
                if (pdd->ulFlags & DDF_HUGEBITMAP) {
                    HugeToFlat(pdd->pbBitmap,pdd->biBitmap.biSizeImage,pdd->biBitmap.biYPelsPerMeter);
		}

                dw = ICDecompress(pdd->hic, icFlags, lpbi, lpBits, &pdd->biBitmap, pdd->pbBitmap);

                if (pdd->ulFlags & DDF_HUGEBITMAP) {
                    FlatToHuge(pdd->pbBitmap,pdd->biBitmap.biSizeImage,pdd->biBitmap.biYPelsPerMeter);
		}
            }
            else
            {
                dw = ICDecompress(pdd->hic, icFlags, lpbi, lpBits, &pdd->biBuffer, pdd->pbBuffer);
            }

            TIMEEND(timeDecompress);

            if (dw == ICERR_DONTDRAW) {
                // Decompressor doesn't want us to draw, for some reason....
                wFlags |= DDF_DONTDRAW;
            } else if (dw != 0) {
                f = FALSE;
                DPF(("Error %ld from decompressor!\n", dw));
                goto exit;
            }
        }

        //
        // if don't draw is set we just need to decompress
        //
        if (wFlags & (DDF_DONTDRAW|DDF_HURRYUP))
        {
            f = TRUE;
            pdd->ulFlags |= DDF_UPDATE|DDF_DONTDRAW;    // make sure update knows what to do
            goto exit;
        }

        //
        //  draw RLE delta's to the screen even when we are buffering.
        //
        if (!(pdd->ulFlags & (DDF_DONTDRAW|DDF_STRETCH|DDF_DITHER|DDF_NAKED)) &&
            lpbi->biCompression == BI_RLE8 &&
            lpbi->biSizeImage != pdd->biBuffer.biSizeImage)
        {
            pdd->ulFlags |= DDF_UPDATE;    // make sure update knows what to do
            pdd->biDraw.biCompression = BI_RLE8;
            goto drawit;
        }
redraw:
        pdd->ulFlags &= ~(DDF_UPDATE|DDF_DONTDRAW);

        if ((pdd->ulFlags & DDF_XLATSOURCE))
        {
            dxSrc = MulDiv(dxSrc, abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
            dySrc = MulDiv(dySrc, abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
            xSrc  = MulDiv(xSrc,  abs((int)pdd->biBuffer.biWidth),  (int)pdd->lpbi->biWidth);
            ySrc  = MulDiv(ySrc,  abs((int)pdd->biBuffer.biHeight), (int)pdd->lpbi->biHeight);
        }

        lpbi = &pdd->biBuffer;
        lpBits = pdd->pbBuffer;

        pdd->biDraw.biCompression = pdd->biBuffer.biCompression;
    }
    else
    {
	if (pdd->lpDIBSection && ((pdd->ulFlags & (DDF_STRETCH|DDF_DITHER)) == 0)) {
	    // Include time taken here as 'stretching'.
	    // Really, though, we shouldn't be using DIB Sections in this case.
            TIMESTART(timeStretch);
	    if (lpbi->biCompression == BI_RGB) {
		lpbi->biSizeImage = DIBSIZEIMAGE(*lpbi);
	    }

	    hmemcpy(pdd->lpDIBSection, lpBits, lpbi->biSizeImage);
            TIMEEND(timeStretch);
	}

        //
        // when directly drawing RLE data we cant hurry
        //
        if (pdd->lpbi->biCompression == BI_RLE8)
            wFlags &= ~DDF_HURRYUP;

        //
        // if don't draw is set we just need to stretch/dither
        //
        if (wFlags & DDF_HURRYUP)
        {
            f = TRUE;
            pdd->ulFlags |= DDF_DIRTY;
            goto exit;
        }

        pdd->ulFlags &= ~DDF_DIRTY;
        pdd->biDraw.biCompression = lpbi->biCompression;
    }

    if (pdd->biDraw.biCompression == BI_RGB &&
        (pdd->ulFlags & (DDF_DITHER|DDF_STRETCH)))
    {
        if (pdd->ulFlags & DDF_STRETCH)
        {
            TIMESTART(timeStretch);

            StretchDIB(&pdd->biStretch, pdd->pbStretch,
                0, 0, dxDst, dyDst,
                lpbi,lpBits,
                xSrc,ySrc,dxSrc,dySrc);

            TIMEEND(timeStretch);

            lpbi  = &pdd->biStretch;
            lpBits = pdd->pbStretch;
            dxSrc  = dxDst;
            dySrc  = dyDst;
            xSrc   = 0;
            ySrc   = 0;
        }

        if (pdd->ulFlags & DDF_DITHER)
        {
            TIMESTART(timeDither);

            pdd->DitherProc(&pdd->biDraw, pdd->pbDither,0,0,dxSrc,dySrc,
                lpbi,lpBits,xSrc, ySrc, pdd->lpDitherTable);

            TIMEEND(timeDither);

            lpBits = pdd->pbDither;
            xSrc = 0;
            ySrc = 0;
        }

        if ((wFlags & DDF_DONTDRAW) && !pdd->hbmDraw)
        {
            f = TRUE;
            goto exit;
        }
    }
    else if (pdd->biDraw.biCompression == BI_RLE8)
    {
        /*
         * if drawing RLE deltas on NT, the biSizeImage field needs to
         * accurately reflect the amount of RLE data present in lpBits.
         */
        pdd->biDraw.biSizeImage = lpbi->biSizeImage;
    }

    if (pdd->lpDIBSection != NULL) {

	//ASSERT(pdd->hbmDraw != NULL);

        if (wFlags & DDF_DONTDRAW)
        {
            f = TRUE;
            goto exit;
        }

bltDIB:
        TIMESTART(timeBlt);

	// Put things back in right-side-up coordinates
	ySrc = (int)pdd->biDraw.biHeight - (ySrc + dySrc);
//      ySrc = 0; // Was like this for Chicago M6!

        f = StretchBlt(hdc,xDst,yDst,dxDst,dyDst,pdd->hdcDraw,
            xSrc,ySrc,dxSrc,dySrc,SRCCOPY) != 0;

        TIMEEND(timeBlt);


    } else if (pdd->hbmDraw)
    {
        //
        //  when MCIAVI is playing we need realize our palette for each
        //  draw operation because another app may have drawn a translated
        //  bitmap thus screwing up the GDI *global* device translate table.
        //  RonG I hate you some times
        //
        if (pdd->hpal && (wFlags & DDF_SAME_HDC)) {
            if (GetProfileInt(szDrawDib, "switchpalette", TRUE))
                RealizePalette(hdc);
        }

        if (pdd->iDecompress != DECOMPRESS_BITMAP) // !(pdd->ulFlags & DDF_BITMAPX)
        {
            TIMESTART(timeSetDIBits);
#if USE_SETDI
            pdd->sd.hdc = hdc;      //!!!ack!
            SetBitmap(&pdd->sd,xSrc,0,dxSrc,dySrc,lpBits,xSrc,ySrc,dxSrc,dySrc);
            pdd->sd.hdc = NULL;     //!!!ack!
            ySrc = 0;
#else
            SetDIBits(hdc, pdd->hbmDraw, 0, dySrc,
                lpBits, (LPBITMAPINFO)&pdd->biDraw, pdd->uiPalUse);
#endif
            TIMEEND(timeSetDIBits);
        }

        if (wFlags & DDF_DONTDRAW)
        {
            f = TRUE;
            goto exit;
        }
bltit:
        TIMESTART(timeBlt);

	// Put things back in right-side-up coordinates
	ySrc = (int)pdd->biDraw.biHeight - (ySrc + dySrc);
//      ySrc = 0;

        f = StretchBlt(hdc,xDst,yDst,dxDst,dyDst,pdd->hdcDraw,
            xSrc,ySrc,dxSrc,dySrc,SRCCOPY) != 0;

        TIMEEND(timeBlt);
    }
    else
drawit:
    {

        // Sometimes when you read an RLE file, you get RGB data back (ie. the
        // first frame).  Passing RGB data to a display driver who thinks it
        // is getting RLE data will blow it up.  If the RLE data is the exact
        // size of RGB data, we decide that's just too much of a coincidence.
        BOOL fNotReallyRLE = (pdd->biDraw.biCompression == BI_RLE8 &&
            lpbi->biSizeImage == DIBWIDTHBYTES(*lpbi) * (DWORD)lpbi->biHeight);

// !!! We've been told not to draw, but I'm going to draw anyway, to fix bug
// WIN95C 14453.  MCIAVI draws from a keyframe forward, saying DONTDRAW on
// every frame but the last.  Works fine in theory, but in theory, communism
// works! Because of other bugs declared WONTFIX, Drawdib doesn't buffer the
// images as it goes along, so when it comes time to draw the result at the
// end, it goes "ACK! I have no idea what I was told to draw!".  So the only
// safe way to fix it is to draw even though we were told not to.  I feel safe
// doing this because this is the way VFW1.1 worked, and nobody has complained
// in over a year.
#if 0
        if (wFlags & DDF_DONTDRAW)
        {
            f = TRUE;
            goto exit;
        }
#endif

        if (fNotReallyRLE)
            pdd->biDraw.biCompression = BI_RGB;

        if (pdd->biDraw.biCompression == BI_RLE8)
        {
            /*
             * if drawing RLE deltas on NT, the biSizeImage field needs to
             * accurately reflect the amount of RLE data present in lpBits.
             */
            pdd->biDraw.biSizeImage = lpbi->biSizeImage;
        }

        TIMESTART(timeBlt);

        /*
         * NT stretchdibits does not work with RLE deltas, even 1:1
         *
         * also note use of pdd->uiPalUse: this is DIB_PAL_COLORS by
         * default, but may be set to DIB_PAL_INDICES if we detect that
         * the system palette is identical to ours, and thus
         * we can safely take this huge performance benefit (on NT,
         * DIB_PAL_INDICES nearly halves the cost of this call)
         */
        if ((dxDst == dxSrc) && (dyDst == dySrc))
        {
            f = SetDIBitsToDevice(hdc, xDst, yDst, dxDst, dyDst,
                    xSrc, ySrc, 0, (UINT)pdd->biDraw.biHeight, lpBits,
                    (LPBITMAPINFO)&pdd->biDraw, pdd->uiPalUse) != 0;
        }
        else
        {
            f = StretchDIBits(hdc,xDst,yDst,dxDst,dyDst,
                xSrc,ySrc,dxSrc,dySrc,
                lpBits, (LPBITMAPINFO)&pdd->biDraw,
                pdd->uiPalUse, SRCCOPY) != 0;
        }

        TIMEEND(timeBlt);
        if (fNotReallyRLE)
            pdd->biDraw.biCompression = BI_RLE8;
    }

exit:
    if (!(wFlags & DDF_SAME_HDC) && pdd->hpal)
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);

    TIMEEND(timeDraw);
    return f;
}

#if 0
/**************************************************************************
* @doc INTERNAL
*
* @api BOOL| InitDrawToScreen | init drawing to the screen via DCI
*
**************************************************************************/
static BOOL InitDrawToScreen(PDD pdd)
{
    BOOL f;

    if (!(pdd->ulFlags & DDF_CANDRAWX))
        return FALSE;

    f = !(pdd->ulFlags & DDF_CLIPPED);

    if (f && !(pdd->ulFlags & DDF_DRAWX))
    {
        DPF(("drawing to SCREEN now"));

        pdd->ulFlags |= DDF_DRAWX;
    }
    else if (!f && (pdd->ulFlags & DDF_DRAWX))
    {
        DPF(("not drawing to SCREEN anymore"));

        pdd->ulFlags &= ~DDF_DRAWX;
    }
}
#endif

/**************************************************************************
* @doc INTERNAL
*
* @api BOOL| InitDecompress | init every thing for decompressing
*   to the screen or a bitmap or a memory buffer.
*
* we can decompress to the screen if the following is true:
*
*   palette must be 1:1
*   must be unclipped
*
**************************************************************************/
static BOOL InitDecompress(PDD pdd)
{
    BOOL f;
    BOOL fBitmap;
    BOOL fScreen;

    //
    // nothing to init
    //
    if (!(pdd->ulFlags & (DDF_CANSCREENX|DDF_CANBITMAPX)))
        return TRUE;

    //
    // make sure we rebegin when the palette changes
    //
    if (pdd->ulFlags & (DDF_NEWPALETTE|DDF_WANTKEY))
        pdd->iDecompress = 0;

    //
    // we need to decompress to either a memory bitmap or buffer.
    //
    fBitmap = (pdd->ulFlags & DDF_CANBITMAPX) &&
              (pdd->ulFlags & (DDF_IDENTITYPAL|DDF_CANSETPAL));

    fScreen = (pdd->ulFlags & DDF_CANSCREENX) &&
             !(pdd->ulFlags & DDF_CLIPPED)    &&
             !(pdd->ulFlags & DDF_MEMORYDC)   &&
              (pdd->ulFlags & (DDF_IDENTITYPAL|DDF_CANSETPAL));

    //
    // should we be decompressing to the screen?
    //
    if (fScreen && pdd->iDecompress != DECOMPRESS_SCREEN)
    {
        if (pdd->ulFlags & DDF_IDENTITYPAL)
        {
            if (pdd->hpalDraw)
                ICDecompressSetPalette(pdd->hic, &pdd->biBuffer);
            else
                ICDecompressSetPalette(pdd->hic, NULL);
        }
        else
        {
            if (FixUpCodecPalette(pdd->hic, pdd->lpbi))
            {
                DPF(("Codec notified of palette change...."));
            }
            else
            {
                DPF(("Codec failed palette change...."));
                pdd->iDecompress = 0;
                goto ack;
            }
        }

        //
        // now init the compressor for screen decompress.
        //
        f = ICDecompressExBegin(pdd->hic, 0,
            pdd->lpbi, NULL, 0, 0, pdd->dxSrc, pdd->dySrc,
            &biScreen, lpScreen, 0, 0, pdd->dxDst, pdd->dyDst) == ICERR_OK;

        if (f)
        {
            pdd->ulFlags |= DDF_DIRTY;          // buffer is dirty now?
            RPF(("Decompressing to screen now"));
            pdd->iDecompress = DECOMPRESS_SCREEN;
            return TRUE;
        }
        else
        {
ack:        DPF(("Compressor failed decompress to SCREEN, so not decompressing to screen!!!!"));
            pdd->iDecompress = 0;
            pdd->ulFlags &= ~DDF_CANSCREENX;
        }
    }
    else if (fScreen)
    {
        //
        //  already decompressing to screen.
        //
        return TRUE;
    }

    //
    // should we decompress to a bitmap?
    //
    if (fBitmap && pdd->iDecompress != DECOMPRESS_BITMAP)
    {
        if (pdd->ulFlags & DDF_IDENTITYPAL)
        {
            if (pdd->hpalDraw)
                ICDecompressSetPalette(pdd->hic, &pdd->biBuffer);
            else
                ICDecompressSetPalette(pdd->hic, NULL);
        }
        else
        {
            if (FixUpCodecPalette(pdd->hic, pdd->lpbi))
            {
                DPF(("Codec notified of palette change...."));
            }
            else
            {
                DPF(("Codec failed palette change...."));
                pdd->iDecompress = 0;
                goto ackack;
            }
        }

        f = ICDecompressBegin(pdd->hic, pdd->lpbi, &pdd->biBitmap) == ICERR_OK;

        if (f)
        {
            pdd->ulFlags |= DDF_DIRTY;          // buffer is dirty now?
            DPF(("decompressing to BITMAP now"));
            pdd->iDecompress = DECOMPRESS_BITMAP;

            return TRUE;
        }
        else
        {
ackack:     DPF(("Unable to init decompress to bitmap"));
            pdd->iDecompress = 0;
        }
    }
    else if (fBitmap)
    {
        //
        //  already decompressing to bitmap
        //
        return TRUE;
    }

    //
    // should we decompress to a buffer?
    //
    if (pdd->iDecompress != DECOMPRESS_BUFFER)
    {
        DPF(("decompressing to DIB now"));

        pdd->ulFlags |= DDF_DIRTY;          // buffer is dirty now?
        pdd->iDecompress = DECOMPRESS_BUFFER;

        if (pdd->hpalDraw)
            ICDecompressSetPalette(pdd->hic, &pdd->biBuffer);
        else
            ICDecompressSetPalette(pdd->hic, NULL);

        f = ICDecompressBegin(pdd->hic, pdd->lpbi, &pdd->biBuffer) == ICERR_OK;

        if (!f)
        {
            DPF(("Unable to re-begin compressor"));
        }
    }

    return TRUE;    // nothing to change
}

/**************************************************************************
* @doc INTERNAL
*
* @api void | DrawDibClipChange | called when the clipping has changed
*   from clipped to totaly un-clipped or whatever.
*
**************************************************************************/
void DrawDibClipChange(PDD pdd, UINT wFlags)
{
    if (!(pdd->ulFlags & DDF_NEWPALETTE))
    {
        if (pdd->ulFlags & DDF_CLIPPED)
            DPF(("now clipped"));
        else
            DPF(("now un-clipped"));
    }

////InitDrawToScreen(pdd);

    //
    // dont change Decompressors on a non key frame, unless we have
    // to (ie going clipped and decompressing to screen)
    //
    if (pdd->ulFlags & DDF_NEWPALETTE)
    {
        if (wFlags & DDF_NOTKEYFRAME)
        {
            if (pdd->iDecompress == DECOMPRESS_BUFFER) // !(pdd->ulFlags & DDF_SCREENX))
            {
                DPF(("waiting for a key frame to change (palette) decompressor"));
                pdd->ulFlags |= DDF_WANTKEY;
                return;
            }
        }
    }
    else
    {
        if (wFlags & DDF_NOTKEYFRAME)
        {
            if (pdd->iDecompress != DECOMPRESS_SCREEN) // !(pdd->ulFlags & DDF_SCREENX))
            {
                DPF(("waiting for a key frame to change (clipped) decompressor"));
                pdd->ulFlags |= DDF_WANTKEY;
                return;
            }
        }
    }

    InitDecompress(pdd);
    pdd->ulFlags &= ~DDF_WANTKEY;
}

/**************************************************************************
* @doc INTERNAL
*
* @api void | DrawDibPalChange | called when the physical palette mapping
*   has changed.
*
**************************************************************************/
void DrawDibPalChange(PDD pdd, HDC hdc, HPALETTE hpal)
{
#ifndef WIN32
#ifdef DEBUG
//      extern BOOL FAR PASCAL IsDCCurrentPalette(HDC hdc);

//      BOOL fForeground = IsDCCurrentPalette(hdc);

//      if (fForeground)
//          DPF(("Palette mapping has changed (foreground)..."));
//      else
//          DPF(("Palette mapping has changed (background)..."));
#endif
#endif

    //
    // if we are on a palette device we need to do some special stuff.
    //
    if (gwScreenBitDepth == 8 && (gwRasterCaps & RC_PALETTE))
    {
        //
        // get the logical->physical mapping
        //
        if (GetPhysDibPaletteMap(hdc, &pdd->biDraw, pdd->uiPalUse, pdd->ab))
            pdd->ulFlags |= DDF_IDENTITYPAL;
        else
            pdd->ulFlags &= ~DDF_IDENTITYPAL;

        if (pdd->ulFlags & DDF_IDENTITYPAL)
            DPF(("Palette mapping is 1:1"));
        else
            DPF(("Palette mapping is not 1:1"));

#ifdef WIN32    //!!!NT Only
        if (pdd->ulFlags & DDF_IDENTITYPAL)
            pdd->uiPalUse = DIB_PAL_INDICES;
        else
            pdd->uiPalUse = DIB_PAL_COLORS;
#endif
    }
    else
    {
        //
        // we are not on a palette device, some code checks DDF_IDENTITYPAL
        // anyway so set it.
        //
        pdd->ulFlags |= DDF_IDENTITYPAL;
    }

    if (pdd->hbmDraw && (pdd->ulFlags & DDF_BITMAP))
    {
        //!!! we should pass pdd->ab to this function!
        //!!! and use a naked translate.
        SetBitmapColorChange(&pdd->sd, hdc, hpal);
    }

    DrawDibClipChange(pdd, DDF_NOTKEYFRAME);
}

/**************************************************************************
* @doc INTERNAL
*
* @api HPALETTE | CreateBIPalette | Create palette from bitmap.
*
* @parm LPBITMAPINFOHEADER | lpbi | Pointer to bitmap.
*
* @rdesc Returns handle to the palette, NULL if error.
*
**************************************************************************/
static HPALETTE CreateBIPalette(HPALETTE hpal, LPBITMAPINFOHEADER lpbi)
{
    LPRGBQUAD prgb;
    int i;

    // This structure is the same as LOGPALETTE EXCEPT for the array of
    // palette entries which here is 256 long.  The "template" in the
    // SDK header files only has an array of size one, hence the "duplication".
    struct {
        WORD         palVersion;                /* tomor - don't mess with word */
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palVersion = 0x300;
    pal.palNumEntries = (int)lpbi->biClrUsed;

    if (pal.palNumEntries == 0 && lpbi->biBitCount <= 8)
        pal.palNumEntries = (1 << (int)lpbi->biBitCount);

    if (pal.palNumEntries == 0)
        return NULL;

    prgb = (LPRGBQUAD)(lpbi+1);

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = prgb[i].rgbRed;
        pal.palPalEntry[i].peGreen = prgb[i].rgbGreen;
        pal.palPalEntry[i].peBlue  = prgb[i].rgbBlue;
        pal.palPalEntry[i].peFlags = 0;
    }

    if (hpal)
    {
        ResizePalette(hpal, pal.palNumEntries);
        SetPaletteEntries(hpal, 0, pal.palNumEntries, pal.palPalEntry);
    }
    else
    {
        hpal = CreatePalette((LPLOGPALETTE)&pal);
    }

    return hpal;
}

/**************************************************************************
* @doc INTERNAL
*
* @api BOOL | SetPalFlags | Modifies the palette flags.
*
* @parm HPALETTE | hpal | Handle to the palette.
*
* @parm int | iIndex | Starting palette index.
*
* @parm int | cntEntries | Number of entries to set flags on.
*
* @parm UINT | wFlags | Palette flags.
*
* @rdesc Returns TRUE if successful, FALSE otherwise.
*
**************************************************************************/
static BOOL SetPalFlags(HPALETTE hpal, int iIndex, int cntEntries, UINT wFlags)
{
    int     i;
    PALETTEENTRY ape[256];

    if (hpal == NULL)
        return FALSE;

    if (cntEntries < 0)
        GetObject(hpal,sizeof(int),(LPSTR)&cntEntries);

    GetPaletteEntries(hpal, iIndex, cntEntries, ape);

    for (i=0; i<cntEntries; i++)
        ape[i].peFlags = (BYTE)wFlags;

    return SetPaletteEntries(hpal, iIndex, cntEntries, ape);
}


/**************************************************************************
* @doc INTERNAL
*
* @api BOOL | IsIdentityPalette | Check if palette is an identity palette.
*
* @parm HPALETTE | hpal | Handle to the palette.
*
* @rdesc Returns TRUE if the palette is an identity palette, FALSE otherwise.
*
**************************************************************************/

#define CODE _based(_segname("_CODE"))

//
// These are the standard VGA colors, we will be stuck with until the
// end of time!
//
static PALETTEENTRY CODE apeCosmic[16] = {
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x80, 0x00, 0x00, 0x00,     // 0001  dark red
    0x00, 0x80, 0x00, 0x00,     // 0010  dark green
    0x80, 0x80, 0x00, 0x00,     // 0011  mustard
    0x00, 0x00, 0x80, 0x00,     // 0100  dark blue
    0x80, 0x00, 0x80, 0x00,     // 0101  purple
    0x00, 0x80, 0x80, 0x00,     // 0110  dark turquoise
    0xC0, 0xC0, 0xC0, 0x00,     // 1000  gray
    0x80, 0x80, 0x80, 0x00,     // 0111  dark gray
    0xFF, 0x00, 0x00, 0x00,     // 1001  red
    0x00, 0xFF, 0x00, 0x00,     // 1010  green
    0xFF, 0xFF, 0x00, 0x00,     // 1011  yellow
    0x00, 0x00, 0xFF, 0x00,     // 1100  blue
    0xFF, 0x00, 0xFF, 0x00,     // 1101  pink (magenta)
    0x00, 0xFF, 0xFF, 0x00,     // 1110  cyan
    0xFF, 0xFF, 0xFF, 0x00      // 1111  white
    };

static PALETTEENTRY CODE apeFake[16] = {
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0xBF, 0x00, 0x00, 0x00,     // 0001  dark red
    0x00, 0xBF, 0x00, 0x00,     // 0010  dark green
    0xBF, 0xBF, 0x00, 0x00,     // 0011  mustard
    0x00, 0x00, 0xBF, 0x00,     // 0100  dark blue
    0xBF, 0x00, 0xBF, 0x00,     // 0101  purple
    0x00, 0xBF, 0xBF, 0x00,     // 0110  dark turquoise
    0xC0, 0xC0, 0xC0, 0x00,     // 1000  gray
    0x80, 0x80, 0x80, 0x00,     // 0111  dark gray
    0xFF, 0x00, 0x00, 0x00,     // 1001  red
    0x00, 0xFF, 0x00, 0x00,     // 1010  green
    0xFF, 0xFF, 0x00, 0x00,     // 1011  yellow
    0x00, 0x00, 0xFF, 0x00,     // 1100  blue
    0xFF, 0x00, 0xFF, 0x00,     // 1101  pink (magenta)
    0x00, 0xFF, 0xFF, 0x00,     // 1110  cyan
    0xFF, 0xFF, 0xFF, 0x00,     // 1111  white
    };

static PALETTEENTRY CODE apeBlackWhite[16] = {
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0x00, 0x00, 0x00, 0x00,     // 0000  black
    0xFF, 0xFF, 0xFF, 0x00      // 1111  white
    };

static BOOL NEAR IsIdentityPalette(HPALETTE hpal)
{
    int i,n=0;    // n is initialised as GetObject returns a 2 byte value
    HDC hdc;

    PALETTEENTRY ape[256];
    PALETTEENTRY apeSystem[16];

    if (hpal == NULL || !(gwRasterCaps & RC_PALETTE) || gwScreenBitDepth != 8)
        return FALSE;

    // Some wierd display cards actually have different numbers of system
    // colours! We definitely don't want to think we can do identity palettes.
    hdc = GetDC(NULL);
    n = GetDeviceCaps(hdc, NUMRESERVED);
    ReleaseDC(NULL, hdc);

    if (n != 20)
        return FALSE;

    GetObject(hpal, sizeof(n), (LPVOID)&n);

    if (n != 256)
        return FALSE;

    GetPaletteEntries(hpal, 0,   8, &ape[0]);
    GetPaletteEntries(hpal, 248, 8, &ape[8]);

    for (i=0; i<16; i++)
        ape[i].peFlags = 0;

    if (!_fmemcmp(ape, apeCosmic, sizeof(apeCosmic)))
        goto DoneChecking;

    if (!_fmemcmp(ape, apeFake, sizeof(apeFake)))
        goto DoneChecking;

    if (!_fmemcmp(ape, apeBlackWhite, sizeof(apeBlackWhite)))
        goto DoneChecking;

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0,   8, &apeSystem[0]);
    GetSystemPaletteEntries(hdc, 248, 8, &apeSystem[8]);
    ReleaseDC(NULL, hdc);

    for (i=0; i<16; i++)
        apeSystem[i].peFlags = 0;

    if (!_fmemcmp(ape, apeSystem, sizeof(apeSystem)))
        goto DoneChecking;

    return FALSE;

DoneChecking:
    //
    // if we have an identity palette then, patch the colors to match
    // the driver ones exactly.
    //
    GetPaletteEntries(hpal, 0, 256, ape);

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0,   10, &ape[0]);
    GetSystemPaletteEntries(hdc, 246, 10, &ape[246]);
    ReleaseDC(NULL, hdc);

    for (i=0; i<10; i++)
        ape[i].peFlags = 0;

    for (i=10; i<246; i++)
        ape[i].peFlags = PC_NOCOLLAPSE;

    for (i=246; i<256; i++)
        ape[i].peFlags = 0;

    SetPaletteEntries(hpal, 0, 256, ape);
    UnrealizeObject(hpal);      //??? needed

    return TRUE;
}

#define COLORMASK 0xF8
STATICFN BOOL NEAR AreColorsAllGDIColors(LPBITMAPINFOHEADER lpbi)
{
    int	    cColors;
    LPRGBQUAD lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi->biSize);
    int	    i;

    for (cColors = (int) lpbi->biClrUsed; cColors > 0; cColors--, lprgb++) {
	for (i = 0; i < 16; i++) {
	    if (((lprgb->rgbRed & COLORMASK) == (apeCosmic[i].peRed & COLORMASK)) &&
		((lprgb->rgbGreen & COLORMASK) == (apeCosmic[i].peGreen & COLORMASK)) &&
		((lprgb->rgbBlue & COLORMASK) == (apeCosmic[i].peBlue & COLORMASK)))
		goto Onward;
	
	    if (((lprgb->rgbRed & COLORMASK) == (apeFake[i].peRed & COLORMASK)) &&
		((lprgb->rgbGreen & COLORMASK) == (apeFake[i].peGreen & COLORMASK)) &&
		((lprgb->rgbBlue & COLORMASK) == (apeFake[i].peBlue & COLORMASK)))
		goto Onward;
	}

	return FALSE;
Onward:
	;	// There's got to be a nicer way to arrange this code!
    }

    return TRUE; // !!!!!
}

/**************************************************************************

let codec adapt to the system palette.

**************************************************************************/

static BOOL FixUpCodecPalette(HIC hic, LPBITMAPINFOHEADER lpbi)
{
    struct {
        BITMAPINFOHEADER bi;
        RGBQUAD          argbq[256];
    } s;
    int                 i;
    HDC                 hdc;

    s.bi.biSize           = sizeof(s.bi);
    s.bi.biWidth          = lpbi->biWidth;
    s.bi.biHeight         = lpbi->biHeight;
    s.bi.biPlanes         = 1;
    s.bi.biBitCount       = 8;
    s.bi.biCompression    = 0;
    s.bi.biSizeImage      = 0;
    s.bi.biXPelsPerMeter  = 0;
    s.bi.biYPelsPerMeter  = 0;
    s.bi.biClrUsed        = 256;
    s.bi.biClrImportant   = 0;

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0, 256, (LPPALETTEENTRY) &s.argbq);
    ReleaseDC(NULL, hdc);

    for (i = 0; i < 256; i++)
        ((DWORD FAR*)s.argbq)[i] = i < 8 || i >= 248 ? 0 :
            RGB(s.argbq[i].rgbRed,s.argbq[i].rgbGreen,s.argbq[i].rgbBlue);

    return ICDecompressSetPalette(hic, &s.bi) == ICERR_OK;
}

/**************************************************************************

let codec adapt to a palette passed by the app.

**************************************************************************/

static BOOL NEAR SendSetPalette(PDD pdd)
{
    int  i;
    int  iPalColors = 0;
    BOOL f;

    if (pdd->hic == NULL)               // nobody to send too
        return FALSE;

    if (pdd->biBuffer.biBitCount != 8)  // not decompressing to 8bit
        return FALSE;

    if (!(gwRasterCaps & RC_PALETTE))   // not a palette device who cares.
        return FALSE;

    if (pdd->hpalDraw)
    {
        GetObject(pdd->hpalDraw, sizeof(iPalColors), (void FAR *)&iPalColors);

        if (iPalColors == 0)
            return FALSE;

        if (iPalColors > 256)
            iPalColors = 256;

        pdd->biBuffer.biClrUsed = iPalColors;
        GetPaletteEntries(pdd->hpalDraw, 0, iPalColors, (PALETTEENTRY FAR *)pdd->argbq);

        for (i = 0; i < iPalColors; i++)
            ((DWORD*)pdd->argbq)[i] = RGB(pdd->argbq[i].rgbRed,pdd->argbq[i].rgbGreen,pdd->argbq[i].rgbBlue);

        f = ICDecompressSetPalette(pdd->hic, &pdd->biBuffer) == ICERR_OK;
        ICDecompressGetPalette(pdd->hic, pdd->lpbi, &pdd->biBuffer);
    }
    else
    {
        pdd->biBuffer.biClrUsed = pdd->ClrUsed;
        f = ICDecompressSetPalette(pdd->hic, NULL) == ICERR_OK;
        ICDecompressGetPalette(pdd->hic, pdd->lpbi, &pdd->biBuffer);
    }

    return f;
}

#ifdef DEBUG_RETAIL

#define _WINDLL
#include <stdarg.h>
#include <stdio.h>

void FAR CDECL ddprintf(LPSTR szFormat, ...)
{
    char ach[128];
    va_list va;
    UINT n;
    static int fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug", MODNAME, FALSE);

    if (!fDebug)
        return;

    va_start(va, szFormat);
#ifdef WIN32
    n = sprintf(ach, MODNAME ": (tid %x) ", GetCurrentThreadId());
    n += vsprintf(ach+n, szFormat, va);
#else
    lstrcpy(ach, MODNAME ": ");
    n = lstrlen(ach);
    n += wvsprintf(ach+n, szFormat, va);
#endif
    va_end(va);
    ach[n++] = '\r';
    ach[n++] = '\n';
    ach[n] = 0;
    OutputDebugStringA(ach);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\flat.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: FLAT.ASM
;
; init/term routines for using flat pointers
;
; LocalAlloc should go through here!
;
;-----------------------------------------------------------------------;
.286
?PLM=1
?WIN=0
	.xlist
        include cmacros.inc
        .list

;--------------------------------------------------------------------------;
;--------------------------------------------------------------------------;

sBegin Data
        public flatBase
        public flatSel
        flatSel             dw 0
        flatBase            dd 0
        KernelLocalAlloc    dd 0
sEnd

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

        externFP    GetSelectorBase         ; in KERNEL
        externFP    SetSelectorBase         ; in KERNEL
        externFP    GetSelectorLimit        ; in KERNEL
        externFP    SetSelectorLimit        ; in KERNEL
        externFP    GlobalWire              ; in KERNEL
        externFP    GlobalUnwire            ; in KERNEL
        externFP    GlobalFix               ; in KERNEL
        externFP    GlobalUnfix             ; in KERNEL
;       externFP    KernelLocalAlloc        ; in KERNEL

        externFP    GetProcAddress          ; in KERNEL
        externFP    GetModuleHandle         ; in KERNEL

        externFP    AllocSelector           ; in KERNEL
        externFP    FreeSelector            ; in KERNEL

;--------------------------------------------------------------------------;
;
;   FlatInit
;
;--------------------------------------------------------------------------;

cProc   FlatInit, <FAR, PUBLIC, PASCAL>
cBegin
;       cCall   GlobalWire, <ds>
        cCall   GlobalFix, <ds>

        cCall   AllocSelector,<ds>
        mov     [flatSel],ax

        mov     bx,ax
        mov     ax,0008h   ; DPMI Set Limit
        mov     cx,-1
        mov     dx,-1
        int     31h

;       cCall   SetSelectorLimit,<ax,-1,-1>

        cCall   GetSelectorBase, <ds>
        mov     word ptr flatBase[0],ax
        mov     word ptr flatBase[2],dx
cEnd

;--------------------------------------------------------------------------;
;
;   FlatTerm
;
;--------------------------------------------------------------------------;

cProc   FlatTerm, <FAR, PUBLIC, PASCAL>
cBegin
        cCall   SetSelectorLimit,<[flatSel],0,0>
        cCall   FreeSelector,<[flatSel]>

;       cCall   GlobalUnwire, <ds>
        cCall   GlobalUnfix, <ds>
	mov	word ptr [flatBase][0],0
	mov	word ptr [flatBase][2],0
        mov     [flatSel],0
cEnd

;--------------------------------------------------------------------------;
;
;   LocalAlloc
;
;--------------------------------------------------------------------------;

szKernel: db  "KERNEL",0

cProc	LocalAlloc, <FAR, PUBLIC, PASCAL>
        ParmW   flags
        ParmW   bytes
cBegin
        mov     ax,word ptr [KernelLocalAlloc][0]
        or      ax,word ptr [KernelLocalAlloc][2]
        jnz     @f

        lea     ax,szKernel
        cCall   GetModuleHandle,<cs,ax>
        cCall   GetProcAddress,<ax, 0, 5>

        mov     word ptr [KernelLocalAlloc][0],ax
        mov     word ptr [KernelLocalAlloc][2],dx

@@:     mov     ax,word ptr [flatBase][0]
	or	ax,word ptr [flatBase][2]
	pushf
	jz	@f
        cCall   FlatTerm
@@:	cCall	KernelLocalAlloc, <flags, bytes>
	popf
	jz	@f
	push	ax
        cCall   FlatInit
	pop	ax
@@:
cEnd

;--------------------------------------------------------------------------;
;
;   MapFlat - convert a 16:16 pointer into a 0:32 pointer
;
;       note this function assumes the memory will *not* move
;       while being accessed.  If this is not true call GlobalFix
;       on the memory
;
;   INPUT:
;       ptr16       16:16 pointer to map flat.
;
;   OUTPUT:
;       dx:ax       flat pointer
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc MapFlat, <NEAR>
        ParmD   ptr16
cBegin
        mov     ds,[flatSel]

        push    word ptr ptr16[2]
        cCall   GetSelectorBase

        add     ax,word ptr ptr16[0]
        adc     dx,0

        sub     ax,word ptr flatBase[0]
        sbb     dx,word ptr flatBase[2]
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\lockbm.h ===
#define BM_NULL         0
#define BM_TYPE         0x0F        // type mask
#define BM_8BIT         0x01        // all SVGA, and other 256 color
#define BM_16555        0x02        // some HiDAC cards
#define BM_24BGR        0x03        // just like a DIB
#define BM_32BGR        0x04        // 32 bit BGR
#define BM_VGA          0x05        // VGA style bitmap.
#define BM_16565        0x06        // most HiDAC cards
#define BM_24RGB        0x07        // 24 bit RGB
#define BM_32RGB        0x08        // 32 bit RGB
#define BM_1BIT         0x09        // mono bitmap
#define BM_4BIT         0x0A        // 4 bit packed pixel.

#define BM_CANLOCK      0x10        // can lock these bitmaps
#define BM_MAPFLAT      0x20        // can make bitmaps flat
#define BM_HUGE         0x40        // with FillBytes != 0 (for > 64k)
#define BM_BOTTOMTOTOP  0x80        // like a DIB

//
//  this is a physical BITMAP in memory, this is just like a  BITMAP
//  structure, but with extra fields staring at bmWidthPlanes
//
typedef struct {
    short  bmType;
    short  bmWidth;
    short  bmHeight;
    short  bmWidthBytes;
    BYTE   bmPlanes;
    BYTE   bmBitsPixel;
    LPVOID bmBits;
    long   bmWidthPlanes;
    long   bmlpPDevice;
    short  bmSegmentIndex;
    short  bmScanSegment;
    short  bmFillBytes;
    short  reserved1;
    short  reserved2;
} IBITMAP;

#define bmBitmapInfo bmWidthPlanes
#define bmOffset     bmlpPDevice
#define bmNextScan   reserved1

BOOL   FAR CanLockBitmaps(void);
UINT   FAR GetBitmapType(void);
LPVOID FAR LockBitmap(HBITMAP hbm);
LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb);
LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb);
LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi);
LPVOID FAR GetPDevice(HDC hdc);
void   FAR TestSurfaceType(HDC hdc, int x, int y);
UINT   FAR GetSurfaceType(LPVOID lpBits);

BOOL   FAR MakeBitmapFlat(HBITMAP hbm);

//void   FAR BitmapXY(IBITMAP FAR *pbm, int x, int y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\flat.h ===
#ifndef WIN32
extern void  FAR PASCAL FlatInit(void);
extern void  FAR PASCAL FlatTerm(void);
extern DWORD FAR PASCAL MapFlat(LPVOID);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\drawdibi.h ===
/**************************************************************************

    DRAWDIBI.H   - internal DrawDib include file

**************************************************************************/

#ifndef WIN32
    #define VFWAPI  FAR PASCAL _loadds
    #define VFWAPIV FAR CDECL _loadds
#endif

/**************************************************************************
includes
**************************************************************************/

#include <win32.h>      // for Win32 and Win16
#include <memory.h>     // for _fmemcmp
#include <compman.h>

#include "drawdib.h"
#include "dither.h"
#include "stretch.h"
#include "lockbm.h"
#include "setdi.h"
#include "dciman.h"

/**************************************************************************
**************************************************************************/

#define DDF_OURFLAGS        0xFFFFC001l  /* internal flags */
#define DDF_MEMORYDC        0x00008000l  /* drawing to a memory DC */
#define DDF_WANTKEY         0x00004000l  /* wait for a key frame */
#define DDF_STRETCH         0x00010000l  /* we need to stretch */
#define DDF_DITHER          0x00020000l  /* we need to dither */
#define DDF_BITMAP          0x00040000l  /* Display driver isn't very good */
#define DDF_X               0x00080000l  /* */
#define DDF_IDENTITYPAL     0x00100000l  /* 1:1 palette mapping */
#define DDF_CANBITMAPX      0x00200000l  /* can decompress to bitmap */
#define DDF_CANSCREENX      0x00400000l  /* we can decompress/draw to screen */
#define DDF_Y               0x00800000l  /* */
#define DDF_DIRTY           0x01000000l  /* decompress buffer is dirty (not valid) */
#define DDF_HUGEBITMAP      0x02000000l  /* decompressing to a HUGE bitmap */
#define DDF_XLATSOURCE      0x04000000l  /* need to xlat source cord. */
#define DDF_CLIPPED         0x08000000l  /* currently clipped */
#define DDF_NEWPALETTE      0x10000000l  /* palette needs mapped */
#define DDF_CLIPCHECK       0x20000000l  /* we care about clipping */
#define DDF_CANDRAWX        0x40000000l  /* we can draw direct to screen */
#define DDF_CANSETPAL       0x80000000l  /* codec supports ICM_SETPALETTE */
#define DDF_NAKED           0x00000001l  /* dont need GDI to translate */

#define DDF_USERFLAGS       0x00003FFEl  /* the user/called gives these, see .h */

/* these flags change what DrawDibBegin does */
#define DDF_BEGINFLAGS      (DDF_JUSTDRAWIT | DDF_BUFFER | DDF_ANIMATE | DDF_FULLSCREEN | DDF_HALFTONE)

/**************************************************************************

flags, a little more info for people who are not me

    DDF_OURFLAGS        these are internal state flags, not passed in by
                        the user.

    DDF_STRETCH         the current draw requires us to stretch, if GDI
                        is stretching this bit is clear.

    DDF_DITHER          the current draw requires a format conversion
                        note a 16->24 32->24 conversion is also called
                        a dither, again if GDI is taking care of it this
                        bit is clear.

    DDF_BITMAP          the display driver isn't very good and we are converting
                        DIB to BMPs before drawing

    DDF_CANBITMAPX      we can decompress to bitmaps.

    DDF_BITMAPX         we are decompressing directly into a bitmap

    DDF_IDENTITYPAL     the palette is a identity palette.

    DDF_CANSCREENX      we can decompress to screen with the current draw
                        params.

    DDF_SCREENX         we are currently decompressing to the screen.

    DDF_DIRTY           the decompress buffer is dirty, ie does not
                        match what *should* be on the screen.

    DDF_HUGEBITMAP      we are decompressing into a huge bitmap, and
                        then calling FlatToHuge...

    DDF_XLATSOURCE      the source cordinates need remapping after
                        decompression, (basicly the decompressor is
                        doing a stretch...)

    DDF_UPDATE          the buffer is valid but needs drawn to the screen.
                        this will get set when DDF_DONTDRAW is passed, and
                        we are decompressing to memory

                        another way to put it is, if DDF_UPDATE is set
                        the screen is out of sync with our internal
                        buffer (the internal buffer is more correct)

    DDF_CLIPPED         we are clipped

    DDF_NEWPALETTE      we need to build new palette map

    DDF_CLIPCHECK       please check for clipping changes.
    DDF_W
    DDF_Q

    DDF_USERFLAGS       these flags are defined in the API, the user will pass
                        these to us.

    DDF_BEGINFLAGS      these flags will effect what DrawDibBegin() does

**************************************************************************/

/**************************************************************************
**************************************************************************/

#ifdef DEBUG
    #define DPF( x ) ddprintf x
    #define DEBUG_RETAIL
#else
    #define DPF(x)
#endif
    
#ifdef DEBUG_RETAIL
    #define MODNAME "DRAWDIB"

    extern void FAR cdecl ddprintf(LPSTR szFormat, ...);

    #define RPF( x ) ddprintf x
#else
    #define RPF(X)
#endif

/**************************************************************************
*  The biXXXXX elements are grouped at the end to minimise the chance of
*  overwriting non bitmap data (i.e. pointers).  IF the code was totally
*  clean this would be irrelevant, however it does increase robustness.
**************************************************************************/

typedef struct {
    UINT                wSize;          /* MANDATORY: this MUST be the first field */
    ULONG               ulFlags;
    UINT                wError;

    #define DECOMPRESS_NONE   0
    #define DECOMPRESS_BITMAP 1
    #define DECOMPRESS_SCREEN 2
    #define DECOMPRESS_BUFFER 3
    int                 iDecompress;

    int                 dxSrc;
    int                 dySrc;
    int                 dxDst;
    int                 dyDst;

    HPALETTE            hpal;
    HPALETTE            hpalCopy;
    HPALETTE            hpalDraw;
    HPALETTE            hpalDrawLast;   /* hpalDraw for last DrawDibBegin */
    int                 ClrUsed;        /* number of colors used! */
    int                 iAnimateStart;  /* colors we can change */
    int                 iAnimateLen;
    int                 iAnimateEnd;

    int                 iPuntFrame;     /* how many frames we blew off */

    /*
     * set to DIB_RGB_COLORS, DIB_PAL_COLORS, or if on Win32 and 1:1 palette
     * DIB_PAL_INDICES (see DrawdibCheckPalette())
     *
     */
    UINT                uiPalUse;

    DITHERPROC          DitherProc;

    LPBYTE              pbBuffer;       /* decompress buffer */
    LPBYTE              pbStretch;      /* stretched bits. */

    //
    //  note we alias the stretch buffer for bitmaps too.
    //
    #define             biBitmap    biStretch
    #define             pbBitmap    pbStretch

    SETDI               sd;             /* for SetBitmap */
    HBITMAP             hbmDraw;        /* for drawing DIBs on the VGA!!! */
    HDC                 hdcDraw;
    HDC                 hdcLast;        /* hdc last call to DrawDibBegin */
    LPVOID              lpDIBSection;   /* pointer to dib section bits */

    LPBYTE              pbDither;       /* bits we will dither to */
    LPVOID              lpDitherTable;  /* for dithering */

    HIC                 hic;            /* decompressor */

#ifdef DEBUG_RETAIL
    DRAWDIBTIME         ddtime;
#endif


    LPBITMAPINFOHEADER  lpbi;           /* source dib format */
    RGBQUAD (FAR       *lpargbqIn)[256];/* source dib colors */
    BITMAPINFOHEADER    biBuffer;       /* decompress format */
    RGBQUAD             argbq[256];     /* drawdib colors */
    BITMAPINFOHEADER    biStretch;      /* stretched DIB */
    DWORD               smag[3];        /* room for masks */
    BITMAPINFOHEADER    biDraw;         /* DIB we will draw */
    WORD                aw[512];        /* either index's or RGBQs */
    BYTE                ab[256];        /* pallete mapping (!!!needed?) */

#ifndef _WIN32
    HTASK               htask;
#endif
}   DRAWDIB_STRUCT, *PDD;
/**************************************************************************
**************************************************************************/

extern DRAWDIB_STRUCT   gdd;
extern UINT             gwScreenBitDepth;
extern BOOL             gf286;


/**************************************************************************
**************************************************************************/

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE_DEFAULT     0x0000

UINT (FAR PASCAL *DisplayDib)(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, UINT wFlags);
UINT (FAR PASCAL *DisplayDibEx)(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, UINT wFlags);

/**************************************************************************
**************************************************************************/

#ifdef DEBUG_RETAIL
    extern DWORD FAR PASCAL timeGetTime(void);

    #define TIMEINC()        pdd->ddtime.timeCount++
    #define TIMESTART(time)  pdd->ddtime.time -= timeGetTime()
    #define TIMEEND(time)    pdd->ddtime.time += timeGetTime()
#else
    #define TIMEINC()
    #define TIMESTART(time)
    #define TIMEEND(time)
#endif

/**************************************************************************
**************************************************************************/

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (UINT)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
#define DIBSIZEIMAGE(bi)  ((DWORD)(UINT)(bi).biHeight * (DWORD)(UINT)DIBWIDTHBYTES(bi))

#define PUSHBI(bi) (int)(bi).biWidth, (int)(bi).biHeight, (int)(bi).biBitCount

/**************************************************************************
**************************************************************************/

//#define MEASURE_PERFORMANCE

#if defined(MEASURE_PERFORMANCE) && defined(WIN32) && defined(DEBUG)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

static LARGE_INTEGER PC1;    /* current counter value    */
static LARGE_INTEGER PC2;    /* current counter value    */
static LARGE_INTEGER PC3;    /* current counter value    */

#define abs(x)  ((x) < 0 ? -(x) : (x))

static VOID StartCounting(VOID)
{
    QueryPerformanceCounter(&PC1);
    return;
}

static VOID EndCounting(LPSTR szId)
{
    QueryPerformanceCounter(&PC2);
    PC3 = I64Sub(PC2,PC1);
    DPF(("%s: %d ticks", szId, PC3.LowPart));
    return;
}

#else

#define StartCounting()
#define EndCounting(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\look775.h ===
BYTE lookup775[245] = {
0,
10,
1,
11,
249,
12,
13,
14,
15,
16,
17,
18,
19,
20,
21,
2,
22,
3,
23,
24,
25,
26,
27,
28,
29,
30,
31,
32,
33,
34,
250,
35,
36,
37,
251,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
55,
56,
57,
58,
59,
60,
61,
62,
63,
64,
65,
66,
67,
68,
69,
70,
71,
72,
73,
74,
75,
76,
77,
78,
79,
80,
81,
82,
83,
84,
85,
86,
87,
88,
89,
90,
91,
92,
93,
94,
95,
96,
97,
98,
99,
100,
101,
102,
103,
104,
105,
106,
107,
4,
108,
5,
109,
110,
111,
112,
113,
114,
115,
116,
117,
118,
119,
120,
6,
121,
248,
122,
123,
124,
125,
126,
127,
128,
129,
130,
131,
132,
133,
134,
135,
136,
137,
138,
139,
140,
141,
142,
143,
144,
145,
146,
147,
148,
149,
150,
151,
152,
153,
154,
155,
156,
157,
158,
159,
160,
161,
162,
163,
164,
165,
166,
167,
168,
169,
170,
171,
172,
173,
174,
175,
176,
177,
178,
179,
180,
181,
182,
183,
184,
185,
186,
187,
188,
189,
190,
191,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
252,
209,
210,
211,
253,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
228,
229,
230,
231,
232,
233,
234,
235,
236,
254,
237,
238,
239,
255
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\drawdib.h ===
/**************************************************************************

    DRAWDIB.H   - routines for drawing DIBs to the screen.

    Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.

    this code handles stretching and dithering with custom code.

    the following DIB formats are supported:

        8bpp
        16bpp
        24bpp

    drawing to:

        16 color DC         (will dither 8bpp down)
        256 (palletized) DC (will dither 16 and 24bpp down)
        Full-color DC       (will just draw it!)

**************************************************************************/

#ifndef _INC_DRAWDIB
#define _INC_DRAWDIB

#ifdef __cplusplus
extern "C" {
#endif

#ifndef VFWAPI
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif

typedef HANDLE HDRAWDIB; /* hdd */

/*********************************************************************

  DrawDib Flags

**********************************************************************/
#define DDF_0001            0x0001          /* */ /* Internal */
#define DDF_UPDATE          0x0002          /* re-draw the last DIB */
#define DDF_SAME_HDC        0x0004          /* HDC same as last call (all setup) */
#define DDF_SAME_DRAW       0x0008          /* draw params are the same */
#define DDF_DONTDRAW        0x0010          /* dont draw frame, just decompress */
#define DDF_ANIMATE         0x0020          /* allow palette animation */
#define DDF_BUFFER          0x0040          /* always buffer image */
#define DDF_JUSTDRAWIT      0x0080          /* just draw it with GDI */
#define DDF_FULLSCREEN      0x0100          /* use DisplayDib */
#define DDF_BACKGROUNDPAL   0x0200	    /* Realize palette in background */
#define DDF_NOTKEYFRAME     0x0400          /* this is a partial frame update, hint */
#define DDF_HURRYUP         0x0800          /* hurry up please! */
#define DDF_HALFTONE        0x1000          /* always halftone */
#define DDF_2000            0x2000          /* */ /* Internal */

#define DDF_PREROLL         DDF_DONTDRAW    /* Builing up a non-keyframe */
#define DDF_SAME_DIB        DDF_SAME_DRAW
#define DDF_SAME_SIZE       DDF_SAME_DRAW

/*********************************************************************

    DrawDib functions
	
*********************************************************************/
/*
**  DrawDibInit()
**
*/
extern BOOL VFWAPI DrawDibInit(void);

/*
**  DrawDibOpen()
**
*/
extern HDRAWDIB VFWAPI DrawDibOpen(void);

/*
**  DrawDibClose()
**
*/
extern BOOL VFWAPI DrawDibClose(HDRAWDIB hdd);

/*
** DrawDibGetBuffer()
**
*/
extern LPVOID VFWAPI DrawDibGetBuffer(HDRAWDIB hdd, LPBITMAPINFOHEADER lpbi, DWORD dwSize, DWORD dwFlags);

/*
**  DrawDibError()
*/
extern UINT VFWAPI DrawDibError(HDRAWDIB hdd);

/*
**  DrawDibGetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern HPALETTE VFWAPI DrawDibGetPalette(HDRAWDIB hdd);


/*
**  DrawDibSetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern BOOL VFWAPI DrawDibSetPalette(HDRAWDIB hdd, HPALETTE hpal);

/*
**  DrawDibChangePalette()
*/
extern BOOL VFWAPI DrawDibChangePalette(HDRAWDIB hdd, int iStart, int iLen, LPPALETTEENTRY lppe);

/*
**  DrawDibRealize()
**
**  realize the palette in a HDD
**
*/
extern UINT VFWAPI DrawDibRealize(HDRAWDIB hdd, HDC hdc, BOOL fBackground);

/*
**  DrawDibStart()
**
**  start of streaming playback
**
*/
extern BOOL VFWAPI DrawDibStart(HDRAWDIB hdd, DWORD rate);

/*
**  DrawDibStop()
**
**  start of streaming playback
**
*/
extern BOOL VFWAPI DrawDibStop(HDRAWDIB hdd);

/*
**  DrawDibBegin()
**
**  prepare to draw
**
*/
extern BOOL VFWAPI DrawDibBegin(HDRAWDIB hdd,
                                    HDC      hdc,
                                    int      dxDst,
                                    int      dyDst,
                                    LPBITMAPINFOHEADER lpbi,
                                    int      dxSrc,
                                    int      dySrc,
                                    UINT     wFlags);
/*
**  DrawDibDraw()
**
**  actualy draw a DIB to the screen.
**
*/
extern BOOL VFWAPI DrawDibDraw(HDRAWDIB hdd,
                                   HDC      hdc,
                                   int      xDst,
                                   int      yDst,
                                   int      dxDst,
                                   int      dyDst,
                                   LPBITMAPINFOHEADER lpbi,
                                   LPVOID   lpBits,
                                   int      xSrc,
                                   int      ySrc,
                                   int      dxSrc,
                                   int      dySrc,
                                   UINT     wFlags);

/*
**  DrawDibUpdate()
**
**  redraw the last image (may only be valid with DDF_BUFFER)
*/
#define DrawDibUpdate(hdd, hdc, x, y) \
        DrawDibDraw(hdd, hdc, x, y, 0, 0, NULL, NULL, 0, 0, 0, 0, DDF_UPDATE)

/*
**  DrawDibEnd()
*/
extern BOOL VFWAPI DrawDibEnd(HDRAWDIB hdd);

/*
**  DrawDibTime()  [for debugging purposes only]
*/
typedef struct {
    LONG    timeCount;
    LONG    timeDraw;
    LONG    timeDecompress;
    LONG    timeDither;
    LONG    timeStretch;
    LONG    timeBlt;
    LONG    timeSetDIBits;
}   DRAWDIBTIME, FAR *LPDRAWDIBTIME;

BOOL VFWAPI DrawDibTime(HDRAWDIB hdd, LPDRAWDIBTIME lpddtime);

/* display profiling */
#define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
#define PD_CAN_STRETCHDIB       0x0002      /* basicly RC_STRETCHDIB */
#define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
#define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
#define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */

DWORD VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);

#ifdef __cplusplus
}
#endif

#endif // _INC_DRAWDIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\profdisp.h ===
#ifndef PD_CAN_DRAW_DIB
    #define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
    #define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
    #define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
    #define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */
#endif

DWORD VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);

LPVOID FAR TestDibFormats(int dx, int dy);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\profdisp.c ===
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>           // for timeGetTime()
#include "drawdibi.h"
#include "profdisp.h"

//#include "msvideo.h"
//#include "lockbm.h"
//#include "setdi.h"

// Remove inline assembly warning
#pragma warning(disable:4704)

//
//  Set+Blt must be N% faster in order to say a driver isn't good
//
#define PROFDISP_FUDGE      110

#ifndef WIN32
    #define GdiFlush()
#endif

DWORD VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);
static UINT NEAR PASCAL ProfDispCanDrawDib(LPBITMAPINFOHEADER lpbi);

static HPALETTE CreateTestPalette(BOOL);

#ifndef WIN32

//C6 will die if we dont redefine this.
#undef  GlobalFreePtr
#define GlobalFreePtr(p)    GlobalFree(GlobalPtrHandle(p))

#pragma alloc_text(DRAWDIB, DrawDibProfileDisplay)
#pragma alloc_text(DRAWDIB, ProfDispCanDrawDib)
#endif

#ifndef QUERYDIBSUPPORT
    #define QUERYDIBSUPPORT     3073
#endif

#ifndef QDI_SETDIBITS
    #define QDI_SETDIBITS       0x0001
    #define QDI_GETDIBITS       0x0002
    #define QDI_DIBTOSCREEN     0x0004
    #define QDI_STRETCHDIB      0x0008
#endif

/*
** ProfDisp - profile the display driver
*/

#define BITMAP_X    320
#define BITMAP_Y    240
#define N_FRAMES    10
#define STRETCH_N   190         // 1.90 times

#ifdef DEBUG
    #define FIRST_N 0           // do four bit
#else
    #define FIRST_N 1
#endif

#define BITBLTINDEX 5
#define BACKINDEX 6

// Internal return codes from DrawDibTest

#define CANT_DO_THESE_BITS      1
#define CANT_DO_STRETCHDIBITS   2
#define STRETCHDI_FASTER        3
#define OTHER_FASTER            4

static HWND     ghwnd ;

#ifndef WIN32
#define CODE  _based(_segname("_CODE"))
#define STACK _based(_segname("_STACK"))
#else
#define CODE
#define STACK
#endif

static UINT ProfileDisplay(HDC hdc, UINT wBitsToTest, int dx, int dy) ;
static BOOL IsDisplay16Bit(HDC hdc ) ;
static BOOL IsDisplay32Bit(HDC hdc ) ;
static UINT DrawDibTest(HDC hdc, LPBITMAPINFOHEADER FAR *alpbi, UINT wFrames,UINT wStretch ) ;
static void FreeFrames( LPBITMAPINFOHEADER FAR *alpbi) ;
static void MakeFrames(LPBITMAPINFOHEADER FAR *alpbi, UINT bits, UINT wXSize,UINT wYSize ) ;
static HANDLE MakeDib( HBITMAP hbitmap, UINT bits ) ;

static TCHAR CODE szBoot[]        = TEXT("boot" );
static TCHAR CODE szDisplay[]     = TEXT("display.drv" );
static TCHAR CODE szNull[]        = TEXT("") ;
static TCHAR CODE szDrawdib[]     = TEXT("drawdib" );
static TCHAR CODE szSystemIni[]   = TEXT("system.ini") ;
static TCHAR CODE szNxNxNxType[]  = TEXT(" %dx%dx%d(%s%u)");
static TCHAR CODE szEntryFormat[] = TEXT("%d,%d,%d,%d");
static TCHAR CODE szU[]           = TEXT("%u");
static TCHAR CODE sz02U[]         = TEXT("%02u");
static TCHAR CODE sz565[]         = TEXT("565 ");
static TCHAR CODE sz555[]         = TEXT("555 ");
static TCHAR CODE szRGB[]         = TEXT("RGB ");
static TCHAR CODE szBGR[]         = TEXT("BGR ");

// The following two strings are loaded from MSVIDEO.DLL - defined in
// video\video.rc.  If they cannot be found there, use these definitions
static TCHAR CODE szProfilingDefault[]  = TEXT("Profiling Display");
static TCHAR CODE szListbox[]           = TEXT("ListBox");

#if 0   // dont warn any-more
#ifndef WIN32
static TCHAR CODE szWarning[]     = TEXT("Warning!");

static TCHAR CODE szDisplaySucks[]=
            TEXT("You may encounter display performance problems; ")
            TEXT("please contact the manufacturer of your video ")
            TEXT("board to see if an updated driver is available.");
#endif
#endif

#define ARRAYLEN(array)	    (sizeof(array)/sizeof(array[0]))

static int result[5] = {
     -1,
     -1,
     -1,
     -1,
     -1};

//
// UINT displayFPS[7][3][2]     [test dib][stretch][method]
//
// this array contains fps numbers times 10, ie 10 == 1fps
// zero means the test was not run.
//
// testdib:
//      0       = 4bpp  DIB (debug only)
//      1       = 8bpp  DIB
//      2       = 16bpp DIB
//      3       = 24bpp DIB
//      4       = 32bpp DIB
//      5       = BitBlt
//      6       = 8bpp  DIB (with non identity palette)
//
//  stretch:
//      0       = 1:1
//      1       = 1:2
//      2       = 1:N  (realy 2:3)
//
//  method (for stretch == 1:1)
//      0       = StretchDIBits()
//      1       = SetDIBits() + BitBlt  *
//
//  method (for stretch != 1:1)
//      0       = StretchDIBits()
//      1       = StretchDIB() + StretchDIBits() **
//
//  method (for testdib == 5, bitblt)
//      0       = BitBlt foreground palette
//      1       = BitBlt background palette
//
//  NOTE high color dibs (> 8) are not tested on devices with bitdepths <= 8
//
//  NOTE stretching tests are not run unless the device does stretching.
//  (RasterCaps has RC_STRETCHBLT or RC_STRETCHDIBITS set)
//
//  * NOTE if we can access bitmaps, we dont use SetDIBits() we use direct
//    code.
//
//  ** NOTE (StretchDIB is not a GDI api...)
//
//  EXAMPLE:
//      displayFPS[1][0][0] is the FPS of 1:1 StretchDIBits() on a 8bpp DIB
//      displayFPS[1][0][1] is the FPS of Set+BitBlt() on a 8bpp DIB
//      displayFPS[1][1][0] is the FPS of 1:2 StretchDIBits() on a 8bpp DIB
//
//  how the ResultN flags get set:
//
//      PD_CAN_DRAW_DIB (can draw this dib 1:1 using some method...)
//          displayFPS[N][0][0] != 0 or displayFPS[N][0][1] != 0
//
//      PD_CAN_STRETCHDIB (can stretch this dib using StretchDIBits)
//          displayFPS[N][1][0] > displayFPS[N][1][1] or
//          displayFPS[N][2][0] > displayFPS[N][2][1]
//
//      PD_STRETCHDIB_1_1_OK (StretchDIBits faster than Set+BitBlt)
//          displayFPS[N][0][0] > displayFPS[N][0][1]
//
//      PD_STRETCHDIB_1_2_OK (StretchDIBits 1:2 is faster the doing it our self)
//          displayFPS[N][1][0] > displayFPS[N][1][1]
//
//      PD_STRETCHDIB_1_N_OK (StretchDIBits 1:N is faster the doing it our self)
//          displayFPS[N][2][0] > displayFPS[N][2][1]
//

static UINT displayFPS[7]   // 0=4bbp, 1=8bpp, 2=16bpp, 3=24bpp, 4=32bit, 5=BitBlt, 6=Dib ~1:1
                      [3]   // 0=1:1,  1=1:2,  2=1:N
                      [2];  // 0=DrawDib, 1=Set+Blt (or ~1:1 for BitBlt)

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api LONG | atoi | local version of atoi
 *
 ***************************************************************************/
 
static int NEAR PASCAL atoi(char FAR *sz)
{
    int i = 0;
    
    while (*sz && *sz >= '0' && *sz <= '9')
    	i = i*10 + *sz++ - '0';
    	
    return i;    	
}	

static void FAR InitProfDisp(BOOL fForceMe)
{
    TCHAR   ach[80];
    TCHAR   achDisplay[80];
    HDC     hdc;
    int     i;
    int     n;
    int     BitDepth;

    GetPrivateProfileString(szBoot, szDisplay, szNull,
			    achDisplay, ARRAYLEN(achDisplay), szSystemIni);

    hdc = GetDC(NULL);

    BitDepth = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    n = GetBitmapType();

    switch(n & BM_TYPE)
    {
        default:
        case BM_8BIT:    ach[0] = 0;             break;
        case BM_16555:   lstrcpy(ach, sz555);    break;
        case BM_16565:   lstrcpy(ach, sz565);    break;
        case BM_24BGR:
        case BM_32BGR:   lstrcpy(ach, szBGR);    break;
        case BM_24RGB:
        case BM_32RGB:   lstrcpy(ach, szRGB);    break;
    }

    wsprintf(achDisplay + lstrlen(achDisplay), szNxNxNxType,
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        BitDepth,(LPSTR)ach, n >> 4);
    ReleaseDC(NULL, hdc);

    GetProfileString(szDrawdib, achDisplay, szNull, ach, ARRAYLEN(ach));
    
    for (i=0,n=1; n<5; n++)
    {
        if (ach[i] == '\0')
        {
            result[n] = -1;
        }
        else
        {
            result[n] = atoi(ach+i);
            while (ach[i] != 0 && ach[i] != ',')
                i++;
            if (ach[i] != 0)
                i++;
	}
    }

    if (fForceMe ||
        result[1] == -1 ||
        result[2] == -1 ||
        result[3] == -1 ||
        result[4] == -1)
    {
        TestDibFormats(BITMAP_X,BITMAP_Y);

	wsprintf(ach, szEntryFormat,
		 result[1], result[2], result[3], result[4]);
        WriteProfileString(szDrawdib, achDisplay, ach);

#if 0
        //
        // if the DISPLAY driver isn't very good at drawing DIBs then warn the user.
        //
        // we will only warn if the device is at least 8bpp
        //
        if (BitDepth >= 8 && !(result[1] & PD_STRETCHDIB_1_1_OK))
        {
#ifndef WIN32
            MessageBox(NULL, szDisplaySucks, szWarning,
#ifdef BIDI
		MB_RTL_READING |
#endif

                MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION);
#else
            RPF(("Display driver probably too slow for AVI"));
#endif
        }
#endif
    }
}

/****************************************************************
*
*****************************************************************/

static UINT NEAR PASCAL ProfDispCanDrawDib(LPBITMAPINFOHEADER lpbi)
{
    int     n;
    LONG    l;
    HDC     hdc;
    UINT    w;

    if (result[1] == -1 || lpbi==NULL)
        InitProfDisp(FALSE);

    if (lpbi == NULL)
        return 0;

    switch (lpbi->biCompression)
    {
        //
        //  standard format use our pre-computed performance numbers.
        //
        case BI_RGB:
            n = (int)lpbi->biBitCount / 8;
            return result[n];

        case BI_RLE4:
        case BI_RLE8:
            //
            // return the un-rle results *but* RLE can't stretch
            //
            return result[1] & PD_CAN_DRAW_DIB|PD_STRETCHDIB_1_1_OK;

        //
        //  custom format, ask the DISPLAY driver
        //
        default:
            l = 0;
            w = 0;

            hdc = GetDC(NULL);

            if (Escape(hdc, QUERYDIBSUPPORT, (int)lpbi->biSize, (LPVOID)lpbi, (LPVOID)&l) > 0)
            {
                // make sure the driver realy realy gave us back flags.
                if (l & ~(0x00FF))
                    l = 0;

                if (l & QDI_DIBTOSCREEN)
                    w |= PD_STRETCHDIB_1_1_OK | PD_CAN_DRAW_DIB;

                if (l & QDI_STRETCHDIB)
                    w |= PD_CAN_STRETCHDIB;

                /* what about stretching? fast? */
            }

            ReleaseDC(NULL, hdc);
            return w;
    }
}

/****************************************************************
* @doc EXTERNAL DrawDib
*
* @api void | DrawDibProfileDisplay | Profiles the display for DrawDib.
*
* @parm LPBITMAPINFOHEADER | parms | Specifies bitmap information. 
*       Set to null if no information is available.
*
*****************************************************************/

DWORD VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi)
{
    if (lpbi == NULL)
    {
        InitProfDisp(TRUE) ;
        return (DWORD)(LPVOID)displayFPS;
    }
    else
        return ProfDispCanDrawDib(lpbi);
}

LPVOID FAR TestDibFormats(int dx, int dy)
{
    int         dxScreen,dyScreen;
    RECT        rc;
    HWND        hwnd;
    HDC         hdc;
    int         n;
    int         i;
    HCURSOR     hcur;
    HPALETTE    hpal;
#ifdef DEBUG
    HPALETTE    hpalT;
#endif
    HWND        hwndActive;
    TCHAR       szProfiling[80];

    // dont change this without changing MSVIDEO.RC
    #define IDS_PROFILING       4000

    extern HMODULE ghInst;      // in MSVIDEO\init.c

    if (!LoadString(ghInst, IDS_PROFILING, szProfiling, sizeof(szProfiling)/sizeof(TCHAR)))
        lstrcpy(szProfiling, szProfilingDefault);

#ifdef WIN32
    #define GetCurrentInstance() GetModuleHandle(NULL)
#else
    #define GetCurrentInstance() NULL
#endif

    dxScreen = GetSystemMetrics(SM_CXSCREEN);
    dyScreen = GetSystemMetrics(SM_CYSCREEN);

    // fill in displayFPS[7][3][2];

    for (n=0; n<7; n++)
        for (i=0; i<3; i++)
            displayFPS[n][i][0] =
            displayFPS[n][i][1] = 0;

    SetRect(&rc, 0, 0, dx, dy);
    AdjustWindowRect(&rc, (WS_OVERLAPPED | WS_CAPTION | WS_BORDER), FALSE);
    OffsetRect(&rc, -rc.left, -rc.top);

    hwnd =
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
			szListbox,     // Class name
                         szProfiling,   // Caption
                          LBS_NOINTEGRALHEIGHT|
                          (WS_OVERLAPPED | WS_CAPTION | WS_BORDER),
                        (dxScreen - rc.right) / 2,
                        (dyScreen - rc.bottom) / 2,
                          rc.right,
                          rc.bottom,
                          (HWND)NULL,             // Parent window (no parent)
                          (HMENU)NULL,            // use class menu
                          GetCurrentInstance(),   // handle to window instance
                        (LPTSTR)NULL            // no params to pass on
                         );

#else
	CreateWindow (
			szListbox,     // Class name
                         szProfiling,   // Caption
                          LBS_NOINTEGRALHEIGHT|
                          (WS_OVERLAPPED | WS_CAPTION | WS_BORDER),
                        (dxScreen - rc.right) / 2,
                        (dyScreen - rc.bottom) / 2,
                          rc.right,
                          rc.bottom,
                          (HWND)NULL,             // Parent window (no parent)
                          (HMENU)NULL,            // use class menu
                          GetCurrentInstance(),   // handle to window instance
                        (LPTSTR)NULL            // no params to pass on
                         );
#endif

    // make the window top most
    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

    // and show it.
    SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_SHOWWINDOW);

    // and activate it.
    hwndActive = GetActiveWindow();
    SetActiveWindow(hwnd);

    hdc = GetDC(hwnd);
    hcur = SetCursor(NULL);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        hpal = CreateTestPalette(TRUE);
        SelectPalette(hdc, hpal, FALSE);
        RealizePalette(hdc);
    }

    Yield();
    Yield();
    Yield();

#ifndef WIN32
    //
    //      make sure no junk is around in the SmartDrv cache, this will
    //      mess with the timings
    //
    _asm {
        mov     ax,4A10h        ; tell Bambi to flush the cache
        mov     bx,0001h
        int     2fh

        mov     ah,0Dh          ; tell other people to commit...
        int     21h
    }
#else
    GdiFlush();
#endif

    for (n=FIRST_N; n<5; n++)
        result[n] = ProfileDisplay(hdc, n==0 ? 4 : n*8, dx, dy);

#ifdef DEBUG
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        //
        // re-run the 8bit tests with a background palette
        //
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
        RealizePalette(hdc);

	hpalT = CreateTestPalette(FALSE);
	SelectPalette(hdc, hpalT, TRUE);
        RealizePalette(hdc);

        Yield();
        Yield();
        Yield();

        ProfileDisplay(hdc, 8, dx, dy);

        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
        RealizePalette(hdc);
	DeleteObject(hpalT);
        DeleteObject(hpal);
    }
#endif

    SetCursor(hcur);
    ReleaseDC(hwnd, hdc);

    if (hwndActive)
        SetActiveWindow(hwndActive);

    DestroyWindow(hwnd) ;

    return (LPVOID)displayFPS;
}

static UINT ProfileDisplay(HDC hdc, UINT wBitsToTest, int dx, int dy)
{
    LPBITMAPINFOHEADER alpbi[N_FRAMES];
    UINT                wRetval;

    if (GetDeviceCaps(hdc, BITSPIXEL) *
        GetDeviceCaps(hdc, PLANES) <= 8 && wBitsToTest > 8)
        return 0;

    alpbi[0] = NULL;

    MakeFrames(alpbi,wBitsToTest,dx,dy);

    wRetval = 0 ;

    if (!alpbi[0])
        return (UINT)-1 ;

    switch(DrawDibTest(hdc,alpbi,N_FRAMES,100))
    {
        case CANT_DO_THESE_BITS:
            goto done ;

        case CANT_DO_STRETCHDIBITS:
            wRetval = PD_CAN_DRAW_DIB ;
            goto done ;

        case STRETCHDI_FASTER:
            wRetval = PD_STRETCHDIB_1_1_OK ;
            /* Falling through */

        case OTHER_FASTER:
            wRetval |= PD_CAN_DRAW_DIB;
    }

    if (DrawDibTest(hdc,alpbi,N_FRAMES,STRETCH_N) == STRETCHDI_FASTER)
        wRetval |= PD_STRETCHDIB_1_N_OK|PD_CAN_STRETCHDIB;

    if (DrawDibTest(hdc,alpbi,N_FRAMES,200) == STRETCHDI_FASTER)
        wRetval |= PD_STRETCHDIB_1_2_OK|PD_CAN_STRETCHDIB;

done:
    FreeFrames(alpbi);

    return wRetval;
}

static UINT DrawDibTest(HDC hdc,LPBITMAPINFOHEADER FAR *alpbi,UINT wFrames,UINT wStretch)
{
    HDC                 hdcMem ;
    HBITMAP             hbitmap ;
    HBITMAP             hbitmapOld ;

    UINT                wBits ;
    DWORD               dwSize;
    DWORD               wSizeColors ;
    DWORD               dwSizeImage;

    volatile LPBITMAPINFOHEADER  lpbi ;
    LPBYTE              bits ;
    LPBITMAPINFOHEADER  lpbiStretch ;
    LPBYTE              bitsStretch ;
    DWORD               time0 = 0;
    DWORD               time1 = 0;
    DWORD               time2 = 0;
    RECT                rc ;
    int                 XDest,YDest,cXDest,cYDest ;
    int                 cXSrc,cYSrc ;
    int                 i ;
    int                 n ;
    int                 q ;
    UINT                DibUsage;
    HPALETTE            hpal;
    BOOL                fBack;
    BOOL                f;

    lpbi = alpbi[0];

    /*
    ** Get stuff common to all frames
    */
    wBits = lpbi->biBitCount ;
    //cXSrc = (int)lpbi->biWidth ;
    //cYSrc = (int)lpbi->biHeight ;
    //cXDest = wStretch*(int)lpbi->biWidth/100 ;
    //cYDest = wStretch*(int)lpbi->biHeight/100 ;

    cXSrc = 100*(int)lpbi->biWidth/wStretch ;
    cYSrc = 100*(int)lpbi->biHeight/wStretch ;
    cXDest = (int)lpbi->biWidth ;
    cYDest = (int)lpbi->biHeight ;

    // are we background'ed
    n = wStretch == 100 ? 0 : wStretch == 200 ? 1 : 2;
    fBack = wBits==8 && displayFPS[1][n][0] != 0;

    if (lpbi->biBitCount <= 8)
        wSizeColors = sizeof(RGBQUAD) * (int)(lpbi->biClrUsed ? lpbi->biClrUsed : (1 << (int)lpbi->biBitCount));
    else
        wSizeColors = 0 ;

    bits = (LPBYTE)lpbi + (int)lpbi->biSize + wSizeColors ;

    if (GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) <= 8 && wBits > 8)
        return CANT_DO_STRETCHDIBITS;

////if (wStretch != 100 && !(GetDeviceCaps(hdc,RASTERCAPS)&(RC_STRETCHDIB|RC_STRETCHBLT)))

    if (wStretch != 100 && !(GetDeviceCaps(hdc,RASTERCAPS)&(RC_STRETCHDIB)))
        return CANT_DO_STRETCHDIBITS ;

    if (wStretch != 100 && wBits == 4)
        return CANT_DO_STRETCHDIBITS ;

    if (wStretch != 100 && (GetWinFlags() & WF_CPU286))
        return STRETCHDI_FASTER;

//  if (wStretch != 100 && wBits > 8) //!!!
//      wFrames = 4;

    lpbi->biWidth  = cXSrc;
    lpbi->biHeight = cYSrc;

    // get current palette
    hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
    SelectPalette(hdc, hpal, fBack);
    RealizePalette(hdc);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        DibUsage = DIB_PAL_COLORS;
    }
    else
    {
        DibUsage = DIB_RGB_COLORS;
    }

////GetClientRect(hwnd,&rc) ;
    GetClipBox(hdc,&rc) ;
    XDest = (rc.right - cXDest)/2 ;
    YDest = (rc.bottom - cYDest)/2 ;

    time0 = 0;

    if (wBits == 16 && !IsDisplay16Bit(hdc))
        goto test_bitmap;

    if (wBits == 32 && !IsDisplay32Bit(hdc))
        goto test_bitmap;

    time0 = timeGetTime() ;

    for (i=0; i<(int)wFrames; i++)
    {
        lpbi = alpbi[i%N_FRAMES];
        bits = ((LPBYTE)lpbi) + (int)lpbi->biSize + wSizeColors ;

#ifdef WIN32
	/*
	 * to correctly model the behaviour of DrawDibDraw, we
	 * use SetDIBitsToDevice if 1:1 (source rect == dest rect).
	 */
	if ( (cXSrc == cXDest) && (cYSrc == cYDest)) {
            f = SetDIBitsToDevice(hdc, XDest, YDest, cXDest, cYDest,
				0, 0, 0, cYSrc,
                                bits, (LPBITMAPINFO)lpbi, DibUsage);
	} else
#endif
        {
            f = StretchDIBits(
                    hdc,
                    XDest,YDest,cXDest,cYDest,
                    0,0,cXSrc, cYSrc,
                    bits,(LPBITMAPINFO)lpbi,DibUsage,SRCCOPY) ;
        }
    }

    GdiFlush();

    time0 = timeGetTime() - time0 ;

    if (f == 0)
        time0 = 0;

test_bitmap:
    time1 = 0;

    if (wStretch == 100)
    {
        PSETDI psd;

        psd = (PSETDI)LocalAlloc(LPTR, sizeof(SETDI));

        if (psd == NULL)
            goto done;

        hbitmap = CreateCompatibleBitmap(hdc,cXDest,cYDest) ;
        hdcMem = CreateCompatibleDC(NULL) ;
        hbitmapOld = SelectObject(hdcMem,hbitmap) ;

        f = SetBitmapBegin(
                    psd,            //  structure
                    hdc,            //  device
                    hbitmap,        //  bitmap to set into
                    lpbi,           //  --> BITMAPINFO of source
                    DibUsage);

        psd->hdc = hdc;

        if (f)
            f = SetBitmap(psd, 0, 0, cXDest, cYDest, bits, 0, 0, cXDest, cYDest);

        if (f)
        {
//          SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
//          RealizePalette(hdc);

            time1 = timeGetTime();

            for (i=0; i<(int)wFrames; i++)
            {
                SetBitmap(psd, 0, 0, cXDest, cYDest, bits, 0, 0, cXDest, cYDest);
                BitBlt(hdc,XDest,YDest,cXDest,cYDest,hdcMem,0,0,SRCCOPY);
            }

            GdiFlush();

            time1 = timeGetTime() - time1 ;

            SetBitmapEnd(psd);

//          SelectPalette(hdc, hpal, fBack);
//          RealizePalette(hdc);
        }

#ifdef DEBUG
        if ((int)lpbi->biBitCount == GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES))
        {
            time2 = timeGetTime() ;

            for (i=0; i<(int)wFrames; i++)
                BitBlt(hdc,XDest,YDest,cXDest,cYDest,hdcMem,0,0,SRCCOPY) ;

            GdiFlush();

            time2 = timeGetTime() - time2 ;
        }
#endif

        LocalFree((HLOCAL)psd);
        SelectObject(hdcMem,hbitmapOld) ;
        DeleteObject(hbitmap) ;
        DeleteDC(hdcMem) ;
    }
    else
    {
        if (wBits == 16 && !IsDisplay16Bit(hdc))
            goto done;

        if (wBits == 32 && !IsDisplay32Bit(hdc))
            goto done;

#ifdef NOSTRETCH
	/*
         * StretchDIB not ported from ASM yet - so StretchDIBits must win.
         */
        time1 = time0 + 1;
#else
        // Calc size we need to allocate for stretched bits

        dwSizeImage = (DWORD)(UINT)cYDest*(DWORD)(((UINT)cXDest*(UINT)lpbi->biBitCount+31)/32*4);
        dwSize = (int)lpbi->biSize + (int)lpbi->biClrUsed*sizeof(RGBQUAD);

        if ((lpbiStretch = (LPVOID)GlobalAllocPtr(GHND,dwSize + dwSizeImage)) != NULL)
        {
            hmemcpy(lpbiStretch, lpbi, dwSize);
            lpbiStretch->biWidth  = cXDest;
            lpbiStretch->biHeight = cYDest;
            lpbiStretch->biSizeImage = dwSizeImage;
            bitsStretch = (LPBYTE)lpbiStretch + (UINT)dwSize;

            time1 = timeGetTime() ;

            for (i=0; i<(int)wFrames; i++)
            {
                lpbi = alpbi[i%N_FRAMES];
                bits = ((LPBYTE)lpbi) + (int)lpbi->biSize + wSizeColors;

                StretchDIB(
                    lpbiStretch,bitsStretch,
                    0,0,cXDest,cYDest,
                    lpbi,bits,
                    0,0,cXSrc,cYSrc);
#ifdef WIN32
		/*
		 * to correctly model the behaviour of DrawDibDraw, we
		 * use SetDIBitsToDevice if 1:1 (source rect == dest rect).
		 */
                f = SetDIBitsToDevice(hdc, XDest, YDest, cXDest, cYDest,
                                    0, 0, 0, cYSrc,
                                    bits, (LPBITMAPINFO)lpbi, DibUsage);
#else
                f = StretchDIBits(
                    hdc,
                    XDest,YDest,cXDest,cYDest,
                    0,0,cXDest,cYDest,
                    bitsStretch,(LPBITMAPINFO)lpbiStretch,DibUsage,SRCCOPY);
#endif
            }

            GdiFlush();

            time1 = timeGetTime() - time1 ;

            GlobalFreePtr(lpbiStretch);

            if (f == 0)
                time1 = 0;
#endif
        }

#ifdef DEBUG
        if ((int)lpbi->biBitCount == GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES))
        {
            hbitmap = CreateCompatibleBitmap(hdc,cXSrc,cYSrc) ;
            hdcMem = CreateCompatibleDC(NULL) ;
            hbitmapOld = SelectObject(hdcMem,hbitmap) ;
	    lpbi = alpbi[0];
	    bits = ((LPBYTE)lpbi) + (int)lpbi->biSize + wSizeColors;
            SetDIBits(hdc,hbitmap,0,cYSrc,bits,(LPBITMAPINFO)lpbi,DibUsage);

            SelectPalette(hdcMem, hpal, FALSE);
//          RealizePalette(hdcMem);

            time2 = timeGetTime() ;

            for (i=0; i<(int)wFrames; i++)
                StretchBlt(hdc,XDest,YDest,cXDest,cYDest,hdcMem,0,0,cXSrc,cYSrc,SRCCOPY) ;

            GdiFlush();

            time2 = timeGetTime() - time2 ;

            SelectObject(hdcMem,hbitmapOld) ;
            DeleteObject(hbitmap) ;
            DeleteDC(hdcMem) ;
        }
#endif
    }

done:
    /* time0 is the time required to do StretchDIBits */
    /* time1 is the time required to do Set + BitBlt */
    /* time2 is the time required to do a BitBlt */

    //
    // compute the FPS * 10 and store for later use.
    //
    n = wStretch == 100 ? 0 : wStretch == 200 ? 1 : 2;
    q = fBack ? BACKINDEX : wBits/8;

    time1 = (DWORD)MulDiv((int)time1,PROFDISP_FUDGE,100);

    displayFPS[q][n][0] = time0 ? (UINT)MulDiv(wFrames,10000,(int)time0) : 0;
    displayFPS[q][n][1] = time1 ? (UINT)MulDiv(wFrames,10000,(int)time1) : 0;

    if (time2)
        displayFPS[BITBLTINDEX][n][fBack] = (UINT)MulDiv(wFrames,10000,(int)time2);

    RPF(("DrawDibTest %dx%dx%d %d StretchDIBits=%04lu SetDI+BitBlt=%04lu BitBlt=%04lu %ls",cXDest,cYDest,wBits,wStretch,time0,time1,time2,(LPSTR)(time0 < time1 ? TEXT("") : TEXT("SUCKS!"))));

    lpbi->biWidth  = cXDest;
    lpbi->biHeight = cYDest;

    if (time0 == 0)
    {
        return time1 ? OTHER_FASTER : CANT_DO_THESE_BITS;
    }
    else
    {
        if (time1)
            return (time0 < time1) ? STRETCHDI_FASTER : OTHER_FASTER;
        else
            return STRETCHDI_FASTER;
    }
}

static void MakeFrames(LPBITMAPINFOHEADER FAR *alpbi, UINT bits, UINT wXSize,UINT wYSize )
{
    int         i ;
    int         x ;
    int         y ;
    LPBITMAPINFOHEADER lpbi ;
    DWORD       dwSizeImage;
    BYTE _huge *pb;
    WORD FAR   *pw;
    DWORD FAR  *pdw;
    UINT        rc;
    HDC         hdc;

    hdc = GetDC(NULL);
    rc = GetDeviceCaps(hdc, RASTERCAPS);
    ReleaseDC(NULL,hdc);

    FreeFrames(alpbi);

    dwSizeImage = wYSize*(DWORD)((wXSize*bits/8+3)&~3);

    lpbi = (LPVOID)GlobalAllocPtr(GHND,sizeof(BITMAPINFOHEADER)+dwSizeImage + 1024);
    lpbi->biSize            = sizeof(BITMAPINFOHEADER) ;
    lpbi->biWidth           = wXSize ;
    lpbi->biHeight          = wYSize ;
    lpbi->biPlanes          = 1 ;
    lpbi->biBitCount        = bits ;
    lpbi->biCompression     = BI_RGB ;
    lpbi->biSizeImage       = dwSizeImage;
    lpbi->biXPelsPerMeter   = 0 ;
    lpbi->biYPelsPerMeter   = 0 ;
    lpbi->biClrUsed         = 0 ;
    lpbi->biClrImportant    = 0 ;

    // !!! These should be RGB DIBs if the device isn't a palette device!

    if (bits == 4)
    {
        lpbi->biClrUsed = 16;
    }
    else if (bits == 8)
    {
	lpbi->biClrUsed = 256;
    }

    pb = (BYTE _huge *)lpbi+lpbi->biSize+lpbi->biClrUsed * sizeof(RGBQUAD);

    if (bits == 4)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x += 2)
	    {
                i = ((x / (wXSize / 4)) + 4 * (y / (wYSize / 4)));
		i += i * 16;
		*pb++ = i;
            }

        if (rc & RC_PALETTE)
        {
            pw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            for (i=0; i<8; i++)
                *pw++ = i;

            for (i=0; i<8; i++)
                *pw++ = 248+i;
        }
        else
        {
            pdw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            *pdw++ = 0x00000000;    // 0000  black
            *pdw++ = 0x00800000;    // 0001  dark red
            *pdw++ = 0x00008000;    // 0010  dark green
            *pdw++ = 0x00808000;    // 0011  mustard
            *pdw++ = 0x00000080;    // 0100  dark blue
            *pdw++ = 0x00800080;    // 0101  purple
            *pdw++ = 0x00008080;    // 0110  dark turquoise
            *pdw++ = 0x00C0C0C0;    // 1000  gray
            *pdw++ = 0x00808080;    // 0111  dark gray
            *pdw++ = 0x00FF0000;    // 1001  red
            *pdw++ = 0x0000FF00;    // 1010  green
            *pdw++ = 0x00FFFF00;    // 1011  yellow
            *pdw++ = 0x000000FF;    // 1100  blue
            *pdw++ = 0x00FF00FF;    // 1101  pink (magenta)
            *pdw++ = 0x0000FFFF;    // 1110  cyan
            *pdw++ = 0x00FFFFFF;    // 1111  white
        }
    }
    else if (bits == 8)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
            {
                *pb++ = 10 + y * 236 / (int)wYSize;
            }

        if (rc & RC_PALETTE)
        {
            pw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            for (i=0; i<256; i++)
                *pw++ = i;
        }
        else
        {
            pdw = (LPVOID)((LPBYTE)lpbi+(int)lpbi->biSize);

            for (i=0; i<256; i++)
                *pdw++ = RGB(i,0,0);
        }
    }
    else if (bits == 16)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
            {
                *pb++ = (BYTE) ((UINT)y * 32u / wYSize);
                *pb++ = (BYTE)(((UINT)x * 32u / wXSize) << 2);
	    }
    }
    else if (bits == 24)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
	    {
                *pb++ = (BYTE) (y * 256l / wYSize);
                *pb++ = (BYTE)~(x * 256l / wXSize);
                *pb++ = (BYTE) (x * 256l / wXSize);
	    }
    }
    else if (bits == 32)
    {
        for (y=0; y<(int)wYSize; y++)
            for (x=0; x<(int)wXSize; x++)
	    {
                *pb++ = (BYTE)~(x * 256l / wXSize);
                *pb++ = (BYTE) (y * 256l / wYSize);
                *pb++ = (BYTE) (x * 256l / wXSize);
                *pb++ = 0;
	    }
    }

    for ( i=0; i<N_FRAMES; i++ )
        alpbi[i] = lpbi;
}

static void FreeFrames(LPBITMAPINFOHEADER FAR *alpbi)
{
    UINT        w ;

    if (!alpbi[0])
        return ;

    for (w=0; w<N_FRAMES; w++)
	if (alpbi[w] && (w == 0 || alpbi[w] != alpbi[w-1]))
            GlobalFreePtr(alpbi[w]);

    for (w=0; w<N_FRAMES; w++)
        alpbi[w] = NULL;
}

#if 0
/*
 *  CreateTestPalette()
 *
 */
static HPALETTE CreateTestPalette(BOOL f)
{
    HDC hdc;
    int i;

    struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palNumEntries = 256;
    pal.palVersion    = 0x0300;

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0, 256, &pal.palPalEntry[0]);
    ReleaseDC(NULL,hdc);

    for (i = 10; i < 246; i++)
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;

    if (!f)
        pal.palPalEntry[0].peRed = 255;

    return CreatePalette((LPLOGPALETTE)&pal);
}

#else

/*
 *  CreateTestPalette()
 *
 */
static HPALETTE CreateTestPalette(BOOL fUp)
{
    int i;
    HDC hdc;

    struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    pal.palNumEntries = 256;
    pal.palVersion    = 0x0300;

    for (i = 0; i < 256; i++)
    {
        pal.palPalEntry[i].peRed   = 0;
        pal.palPalEntry[i].peGreen = 0;
        pal.palPalEntry[i].peBlue  = (BYTE)(fUp ? i : 255 - i);
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
    }

    hdc = GetDC(NULL);
    GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
    GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);
    ReleaseDC(NULL,hdc);

    return CreatePalette((LPLOGPALETTE)&pal);
}
#endif

#define RGB555_RED      0x7C00
#define RGB555_GREEN    0x03E0
#define RGB555_BLUE     0x001F

static BOOL IsDisplay16Bit( HDC hdc )
{
    struct {
        BITMAPINFOHEADER    bi;
        RGBQUAD             rgbq[256];
    }   dib;
    int                     w ;
    LONG                    l=0;
    WORD                    bits[2];
    COLORREF                cref ;

    w = GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES) ;

    if ( w < 15 )
        return FALSE;

    /*
    ** OK, the hardware is at least 16 bits - now test to see
    ** if they impelement 5-5-5 RGB
    */

    dib.bi.biSize = sizeof(BITMAPINFOHEADER);
    dib.bi.biWidth = 1;
    dib.bi.biHeight = 1;
    dib.bi.biPlanes = 1;
    dib.bi.biBitCount = 16;
    dib.bi.biCompression = BI_RGB;
    dib.bi.biSizeImage = 4;
    dib.bi.biXPelsPerMeter = 0;
    dib.bi.biYPelsPerMeter = 0;
    dib.bi.biClrUsed = 1;
    dib.bi.biClrImportant = 0;

    //
    // just in case they try to decode it as rle
    //
    bits[0] = 0x0000;           // this is RLE EOL
    bits[1] = 0x0100;           // this is RLE EOF

    //
    // send the Escape to see if they support 16bpp DIBs
    //
    if (Escape(hdc, QUERYDIBSUPPORT, (int)dib.bi.biSize, (LPVOID)&dib, (LPVOID)&l) > 0)
    {
        // make sure the driver realy realy gave us back flags.
	if (l & ~(0x00FF))
		l = 0;

        if (l & (QDI_DIBTOSCREEN|QDI_STRETCHDIB))
            return TRUE;
    }

    //
    // they dont support the QUERYDIBSUPPORT Escape, try to draw DIBs and see
    // what they do!
    //

    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) ;

    if (cref != RGB(0,0,0))
        return FALSE;

    /*
    ** Display a red pixel of the max value and get it back with
    ** GetPixel(). Verify that red has the max value in the RGB
    ** triplet and green and blue are nothing.
    */
    bits[0] = RGB555_RED ;
    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) & 0x00F8F8F8;

    if (cref != RGB(0xF8,0,0))
        return FALSE;

    /*
    ** Ditto green. Note that if the driver is implementing 5-6-5, then
    ** green will read back as less than full scale and we will catch
    ** it here.
    */
    bits[0] = RGB555_GREEN ;
    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) & 0x00F8F8F8;

    if (cref != RGB(0,0xF8,0))
        return FALSE;

    /*
    ** Ditto blue.
    */
    bits[0] = RGB555_BLUE ;
    if ( !StretchDIBits(hdc,0,0,1,1,0,0,1,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    cref = GetPixel(hdc,0,0) & 0x00F8F8F8;

    if (cref != RGB(0,0,0xF8))
        return FALSE;

    return TRUE;
}

static BOOL IsDisplay32Bit( HDC hdc )
{
    struct {
        BITMAPINFOHEADER    bi;
        RGBQUAD             rgbq[256];
    }   dib;
    int                     w ;
    LONG                    l=0;
    DWORD                   bits[2];

    w = GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES) ;

    if ( w < 15 )
        return FALSE;

    /*
    ** OK, the hardware is at least 16 bits - now test to see
    ** if they impelement a 32 bit DIB
    */

    dib.bi.biSize = sizeof(BITMAPINFOHEADER);
    dib.bi.biWidth = 2;
    dib.bi.biHeight = 1;
    dib.bi.biPlanes = 1;
    dib.bi.biBitCount = 32;
    dib.bi.biCompression = BI_RGB;
    dib.bi.biSizeImage = 4;
    dib.bi.biXPelsPerMeter = 0;
    dib.bi.biYPelsPerMeter = 0;
    dib.bi.biClrUsed = 1;
    dib.bi.biClrImportant = 0;

    //
    // send the Escape to see if they support 32bpp DIBs
    //
    if (Escape(hdc, QUERYDIBSUPPORT, (int)dib.bi.biSize, (LPVOID)&dib, (LPVOID)&l) > 0)
    {
        // make sure the driver realy realy gave us back flags.
	if (l & ~(0x00FF))
		l = 0;

        if (l & (QDI_DIBTOSCREEN|QDI_STRETCHDIB))
            return TRUE;
    }

    bits[0] = 0x00000000;
    bits[1] = 0x00FFFFFF;

    //
    // they dont support the QUERYDIBSUPPORT Escape, try to draw DIBs and see
    // what they do!
    //
    if (!StretchDIBits(hdc,0,0,2,1,0,0,2,1,bits,(LPBITMAPINFO)&dib,DIB_RGB_COLORS,SRCCOPY))
        return FALSE;

    if (GetPixel(hdc,0,0) != 0)
        return FALSE;

    if ((GetPixel(hdc,1,0) & 0x00F8F8F8) != 0x00F8F8F8)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\mapa.asm ===
title   mapa.asm
        page    ,132

?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention

        .xlist
        include cmacro32.inc
        include windows.inc
        .list

; -------------------------------------------------------
;               DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
.386
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;
;   STOSB32 - store a byte, every four times doing a STOSD
;
;--------------------------------------------------------------------------;

STOSB32_N = 0

STOSB32 macro
        ror     eax,8                       ; rotate pixel (al) into eax

        STOSB32_N = STOSB32_N + 1

        if (STOSB32_N mod 4) eq 0
;;          stos dword ptr es:[edi]
            mov     dword ptr es:[edi], eax
            add     edi,4
        endif

        endm

;--------------------------------------------------------------------------;
;
;   LODSB32 - get a byte, every four times doing a LODSD
;
;--------------------------------------------------------------------------;

LODSB32_N = 0

LODSB32 macro
        if (LODSB32_N mod 4) eq 0
;;          lods dword ptr ds:[esi]
            mov     eax,dword ptr ds:[esi]
            add     esi,4
        else
            ror     eax,8
        endif

        LODSB32_N = LODSB32_N + 1

        endm

;--------------------------------------------------------------------------;
;
;   MAP16
;
;--------------------------------------------------------------------------;

MAP16   macro   n

if n and 1
        shr     ebx,16                      ; get pel from last time
else
        mov     ebx, dword ptr ds:[esi]     ; grab two pels
        add     esi,4
endif
        ;
        ;       BX contains 5:5:5 RGB convert it to a 8:8:8 RGB
        ;
        mov     al,bl
        shl     al,3
        STOSB32

        shr     bx,2
        mov     al,bl
        and     al,0F8h
        STOSB32

        mov     al,bh
        shl     al,3
        STOSB32

        endm


;--------------------------------------------------------------------------;
;
;   Map16to24()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing        

cProc   Map16to24,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;not used

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        and     DstXE, not 011b
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,16                  ; source 16
        mov     ebx,24                  ; dest 24
        call    map_init                ; init all the frame variables
        jc      Map16to24Exit

        movzx   eax, DstXE               ; inner loop expanded by 4
        shr     eax, 2
        jz      Map16to24Exit
        mov     DstXE,ax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
align 4
Outer16to24Loop:
        movzx   ecx,DstXE

align 4
Inner16to24Loop:
        MAP16   0
        MAP16   1
        MAP16   2
        MAP16   3
        dec     ecx
        jnz     Inner16to24Loop

        add     edi, DstInc
        add     esi, SrcInc

        dec     DstYE
        jnz     Outer16to24Loop

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Map16to24Exit:
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   Map32to24()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing        

cProc   Map32to24,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmD   lpDitherTable           ;not used

        localD  SrcWidth                ;width of source in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcInc
        localD  DstInc
	localW	OriginalDstXE
cBegin
        push    esi
        push    edi
        push    ds

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   align everything on four pixel boundries, we realy should
;   not do this but should handle the general case instead,
;   but hey we are hackers.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
	mov	ax, DstXE
	mov	OriginalDstXE, ax
	mov	bx, ax
	add	ax, 011b
        and     ax, not 011b
	mov	DstXE, ax

	and	bx, 011b	
	jz	short @f
	dec	DstYE		; if the width isn't a multiple of 4, special-
				; case the last line.
@@:
	

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     eax,32                  ; source 32
        mov     ebx,24                  ; dest 24
        call    map_init                ; init all the frame variables
        jc      Map32to24Exit

        movzx   eax, DstXE               ; inner loop expanded by 4
        shr     eax, 2
        jz      short Map32to24Exit
        mov     DstXE,ax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
align 4
Outer32to24Loop:
        movzx   ecx,DstXE

align 4
Inner32to24Loop:
        mov     eax,[esi]           ; eax = XRGB
        mov     ebx,[esi+4]         ; ebx = xrgb
        shl     eax,8               ; eax = RGB0
        shrd    eax,ebx,8           ; eax = bRGB
        mov     es:[edi],eax        ; store pels
        shl     ebx,8               ; ebx = rgb0

        mov     eax,[esi+8]         ; eax = XRGB
        shrd    ebx,eax,16          ; ebx = GBrg
        mov     es:[edi+4],ebx      ; store pels
        shl     eax,8               ; eax = RGB0

        mov     ebx,[esi+12]        ; ebx = xrgb
        shrd    eax,ebx,24          ; eax = rgbR
        mov     es:[edi+8],eax      ; store pels

        add     esi,16
        add     edi,12
        dec     ecx
        jnz     Inner32to24Loop

        add     edi, DstInc
        add     esi, SrcInc

        dec     DstYE
        jnz     Outer32to24Loop

; done, but might have to do one more scan line
	mov	ax, OriginalDstXE
	and	ax, 011b
	jz	short Map32to24Exit

        movzx   ecx,OriginalDstXE

align 4
@@:	; one more scan line to do....
        mov     eax,[esi]           ; eax = XRGB
        shl     eax,8               ; eax = RGB0
	mov	es:[edi], ah
	shr	eax,16		    ; eax = 00RG
	mov	es:[edi+1], ax

        add     esi,4
        add     edi,3
        dec     ecx
        jnz     @b

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
Map32to24Exit:
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   map_init
;
;   init local frame vars for mapDIB
;
;   ENTRY:
;       AX      -   source bpp
;       BX      -   dest bpp
;       ss:bp   --> mapdib frame
;
;   EXIT:
;       DS:ESI  --> source DIB start x,y
;       ES:EDI  --> dest DIB start x,y
;
;--------------------------------------------------------------------------;

map_init_error:
        stc
        ret

map_init proc near

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   validate the DIBs
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        xor     edi,edi
	xor	esi,esi

        lds     si, biSrc
        les     di, biDst

        movzx   ecx, es:[di].biBitCount     ; dest must be right
        cmp     cx, bx
        jne     map_init_error

        mov     cx, [si].biBitCount         ; source must be 16
        cmp     cx, ax
        jne     map_init_error

map_init_bit_depth_ok:

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial source pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     eax,[si].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
	mov	SrcWidth,eax
        mov     SrcInc,eax

        lds     si,lpSrc

	movzx	edx,SrcY
        mul     edx
        add     esi,eax

        movzx   eax,SrcX
        mul     ecx
        shr     eax,3
        add     esi,eax

        movzx   eax, DstXE           ; SrcInc = SrcWidth - DstXE*bits/8
        mul     ecx
        shr     eax, 3
        sub     SrcInc, eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial dest pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   ecx, es:[di].biBitCount
        mov     eax,es:[di].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
	mov	DstWidth,eax
        mov     DstInc,eax

        les     di,lpDst

        movzx   edx,DstY
        mul     edx
	add	edi,eax

        movzx   eax,DstX
        mul     ecx
        shr     eax,3
        add     edi,eax

        movzx   eax, DstXE           ; DstInc = DstWidth - DstXE*bits/8
        mul     ecx
        shr     eax, 3
        sub     DstInc, eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

map_init_exit:
        clc
        ret

map_init endp

;--------------------------------------------------------------------------;
;
;   HugeToFlat
;
;   map a bunch of bitmap bits in "huge" format to "flat" format
;
;   this code only works for bitmaps <= 128k
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   HugeToFlat,<FAR,PUBLIC,PASCAL>,<>
        parmD   lpBits                  ;--> bits
        parmD   cbBits                  ;count of bits.
        parmD   FillBytes               ;the fill bytes
cBegin
        push    esi
        push    edi
        push    ds

        mov     ax,word ptr lpBits[2]
        mov     ds,ax
        mov     es,ax
        mov     eax,FillBytes
        mov     ecx,cbBits
        add     ecx,eax
        mov     esi,00010000h
        sub     ecx,esi
        mov     edi,esi
        sub     edi,eax

        shr     ecx,2
        rep     movsd

        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   FlatToHuge
;
;   map a bunch of bitmap bits in "flat" format to "huge" format
;
;   this code only works for bitmaps <= 128k
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing        

cProc   FlatToHuge,<FAR,PUBLIC,PASCAL>,<>
        parmD   lpBits                  ;--> bits
        parmD   cbBits                  ;count of bits.
        parmD   FillBytes               ;the fill bytes
cBegin
        push    esi
        push    edi
        push    ds

        mov     ax,word ptr lpBits[2]
        mov     ds,ax
        mov     es,ax
        mov     eax,FillBytes
        mov     ecx,cbBits
        add     ecx,eax
        mov     edi,ecx
        sub     edi,4
        mov     esi,edi
        sub     esi,FillBytes
        sub     ecx,00010000h

        std
        shr     ecx,2
        rep     movsd
        cld

        pop     ds
        pop     edi
        pop     esi
cEnd

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\flat.inc ===
externFP    GetSelectorBase         ; in KERNEL

sBegin Data
        externD flatBase
        externW flatSel
sEnd

;--------------------------------------------------------------------------;
;
;   MapFlat - convert a 16:16 pointer into a 0:32 pointer
;
;       note this macro assumes the memory will *not* move
;       while being accessed.  If this is not true call GlobalFix
;       on the memory
;
;   INPUT:
;       ptr16       16:16 pointer to map flat.
;       ptr32       put flat pointer here.
;
;   OUTPUT:
;       eax         flat pointer (or pointer stored)
;
;--------------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

MapFlat macro ptr16, ptr32

        ; is this call safe from a 32-bit seg?
        push    word ptr ptr16[2]

        db 66h,9Ah                      ; call <far ptr GetSelectorBase>
        dw OFFSET GetSelectorBase
        dw SEG    GetSelectorBase

        ror     eax,16                  ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16              ; move LOWORD(edx) to HIWORD(eax)

        movzx   edx,word ptr ptr16[0]   ; add pointer offset
        add     eax,edx
        sub     eax,[flatBase]          ; make relative to base offset

ifb <ptr32>
        mov     ptr16,eax
else
        mov     ptr32,eax
endif

endm

FlatDS macro
        mov     ds,[flatSel]
        mov     es,[flatSel]
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\lockbm.c ===
#include <windows.h>
#include <windowsx.h>
#include "lockbm.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifndef BI_BITFIELDS
    #define BI_BITFIELDS 3
#endif

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
//  GDI!GDIInit2()      GDI.403
//
//  this GDI function does the following:
//
//      GetSetBitmapHandle(hbm, 0)  - will return global handle of bitmap
//
//      GetSetBitmapHandle(hbm, h)  - will set global handle to <h>
//
//      GetSetBitmapHandle(hbm, -1) - will set global handle to NULL
//
static HANDLE (FAR PASCAL *GetSetBitmapHandle)(HBITMAP hbm, HANDLE h);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#define muldiv(a,b,c) (UINT)(((DWORD)(UINT)(a) * (DWORD)(UINT)(b)) / (UINT)(c))

//////////////////////////////////////////////////////////////////////////////
//
// CanLockBitmaps()
//
// determime if we can lock bitmaps on the current display device
//
//////////////////////////////////////////////////////////////////////////////
BOOL FAR CanLockBitmaps(void)
{
    return FALSE;

#if 0
    UINT w;
    UINT rc;
    HDC  hdc;
    BOOL f;

    static BOOL fCanLockBitmaps = -1;

    if (fCanLockBitmaps == -1)
    {
        w = (UINT)GetVersion();

        w = ((UINT)LOBYTE(w) << 8) | HIBYTE(w);

        hdc = GetDC(NULL);
        rc = GetDeviceCaps(hdc, RASTERCAPS);
        ReleaseDC(NULL, hdc);

        (FARPROC)GetSetBitmapHandle =
            GetProcAddress(GetModuleHandle("GDI"),MAKEINTATOM(403));

        //
        // assume we dont need this on windows 4.0?
        //
        // what about the DIBENG? it does DEVBITS and in win 4.0?
        //
        // if the display handles device bitmaps, dont do this either
        //

        f = GetProfileInt("DrawDib", "Bitmaps", TRUE);

#ifdef DEBUG
        fCanLockBitmaps = f && GetSetBitmapHandle != NULL;
#else
        fCanLockBitmaps = f && /* (w < 0x0400) && */
                          !(rc & RC_DEVBITS) &&
                          GetSetBitmapHandle != NULL;
#endif
    }

    return fCanLockBitmaps;
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// LockBitmap
//
// return a pointer to the bitmap bits
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR LockBitmap(HBITMAP hbm)
{
    return GetBitmap(hbm, NULL, 0);
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmapDIB
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb)
{
    IBITMAP FAR *pbm;

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

    if (p == NULL || cb < sizeof(BITMAP))
        return lpBits;

    pbm = p;

    if (lpbi->biCompression == 0)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            case 0x0101: pbm->bmType = BM_1BIT;  break;
            case 0x0104: pbm->bmType = BM_4BIT;  break;
            case 0x0108: pbm->bmType = BM_8BIT;  break;
            case 0x0110: pbm->bmType = BM_16555; break;
            case 0x0118: pbm->bmType = BM_24BGR; break;
            case 0x0120: pbm->bmType = BM_32BGR; break;
            case 0x0401: pbm->bmType = BM_VGA;   break;
            default: return NULL;
        }
    }
    else if (lpbi->biCompression == BI_BITFIELDS)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            //!!! hack: realy should check the bit fields!
            case 0x0110: pbm->bmType = BM_16565; break;
            case 0x0118: pbm->bmType = BM_24RGB; break;
            case 0x0120: pbm->bmType = BM_32RGB; break;
            default: return NULL;
        }
    }
    else
        return NULL;

    pbm->bmWidth        = (int)lpbi->biWidth;
    pbm->bmHeight       = ((int)lpbi->biHeight > 0) ? (int)lpbi->biHeight : -(int)lpbi->biHeight;
    pbm->bmWidthBytes   = (((int)lpbi->biBitCount * (int)lpbi->biWidth + 31)&~31)/8;
    pbm->bmPlanes       = (BYTE)lpbi->biPlanes;
    pbm->bmBitsPixel    = (BYTE)lpbi->biBitCount;
    pbm->bmBits         = lpBits;

    if (cb > sizeof(BITMAP))
    {
        pbm->bmSegmentIndex = 0;
        pbm->bmScanSegment  = pbm->bmHeight;
        pbm->bmFillBytes    = 0;
        pbm->bmBitmapInfo   = (long)lpbi;

        if ((long)lpbi->biHeight < 0)
        {
            pbm->bmNextScan = -pbm->bmWidthBytes;
            pbm->bmOffset   = (long)pbm->bmWidthBytes * (pbm->bmHeight-1);
        }
        else
        {
            pbm->bmNextScan = pbm->bmWidthBytes;
            pbm->bmOffset   = 0;
        }
    }

    return lpBits;
}

#if 0
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void FAR BitmapXY(IBITMAP FAR *pbm, int x, int y)
{
    UINT t;

    if (pbm->bmFillBytes)
    {
        while (y-- > 0)
        {
            t = (UINT)(pbm->bmOffset & 0xFFFF0000);
            pbm->bmOffset += pbm->bmNextScan;
            if ((UINT)(pbm->bmOffset & 0xFFFF0000) != t)
                pbm->bmOffset += pbm->bmFillBytes;
        }
    }
    else
    {
        pbm->bmOffset += y * (long)pbm->bmNextScan;
    }

    pbm->bmOffset += x * pbm->bmBitsPixel / 8;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// GetDIBBitmap
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi)
{
    UINT wType;
    BITMAP bm;
    UINT ScansPerSeg;
    UINT FillBytes;

    if (hbm)
        GetObject(hbm, sizeof(bm), &bm);

    wType = GetBitmapType();

    if (wType == 0)
        return NULL;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = bm.bmWidth;
    lpbi->biHeight         = bm.bmHeight;
    lpbi->biPlanes         = bm.bmPlanes;
    lpbi->biBitCount       = bm.bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)(bm.bmWidthBytes * bm.bmPlanes) * (DWORD)bm.bmHeight;
    lpbi->biXPelsPerMeter  = 0;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    switch(wType & BM_TYPE)
    {
        case BM_VGA:
            break;

        case BM_1BIT:
        case BM_4BIT:
        case BM_8BIT:
            break;

        case BM_16555:
            break;

        case BM_24BGR:
        case BM_32BGR:
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;

        default:
            return NULL;
    }

    //
    //  make sure WidthBytes is right, dont forget bitmaps are WORD aligned
    //  and DIBs are DWORD aligned.
    //
    if (bm.bmWidthBytes != ((bm.bmWidth * bm.bmBitsPixel + 31) & ~31)/8)
    {
        if (lpbi->biCompression != 0)
            return NULL;

        lpbi->biCompression = BI_BITMAP;
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
    }

    if ((wType & BM_HUGE) && (lpbi->biSizeImage > 64*1024l))
    {
        if (lpbi->biCompression == BI_BITFIELDS)
            return NULL;

        lpbi->biCompression = BI_BITMAP;

        ScansPerSeg = muldiv(64,1024,bm.bmWidthBytes * bm.bmPlanes);
        FillBytes   = (UINT)(64ul*1024 - bm.bmWidthBytes * bm.bmPlanes * ScansPerSeg);

        lpbi->biSizeImage     += FillBytes * (bm.bmHeight / ScansPerSeg);
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
        lpbi->biYPelsPerMeter  = FillBytes;
    }

    if (!(wType & BM_BOTTOMTOTOP))
        lpbi->biHeight = -bm.bmHeight;

    return LockBitmap(hbm);
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmap
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb)
{
    HANDLE h;
    DWORD  dwSize;
    IBITMAP FAR *pbm;
    HDC hdc = NULL;
    HBITMAP hbmT;

    if (!CanLockBitmaps())
        return NULL;

    if (hbm == NULL)
        return NULL;

    h = GetSetBitmapHandle(hbm, 0);

    if (h == NULL)
        return NULL;

    pbm = (LPVOID)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        return NULL;

    //
    // see if it is realy a bitmap.
    //
    if (pbm->bmType != 0)
        return NULL;

    //
    // make sure the bmBits pointer is valid.
    //
    if (pbm->bmBits == NULL)
    {
        hdc = CreateCompatibleDC(NULL);
        hbmT = SelectObject(hdc, hbm);
    }

    dwSize = (DWORD)pbm->bmHeight * (DWORD)pbm->bmWidthBytes;

    if (IsBadHugeWritePtr((LPVOID)pbm->bmBits, dwSize))
    {
        if (hdc)
        {
            SelectObject(hdc, hbmT);
            DeleteDC(hdc);
        }

        return NULL;
    }

    if (p)
    {
        UINT u;

        hmemcpy(p, pbm, min(cb, sizeof(IBITMAP)));
        pbm = p;

        u = GetBitmapType();

        pbm->bmType = u & BM_TYPE;

        if (cb > sizeof(BITMAP))
        {
            pbm->bmBitmapInfo = NULL;
            pbm->bmNextScan = pbm->bmWidthBytes * pbm->bmPlanes;

            if (u & BM_BOTTOMTOTOP)
            {
                pbm->bmOffset = 0;
            }
            else
            {
                pbm->bmOffset   = (long)pbm->bmNextScan * (pbm->bmHeight-1);
                pbm->bmNextScan = -pbm->bmNextScan;
                pbm->bmFillBytes = -pbm->bmFillBytes;
            }

            //
            // see if this particular bitmap is HUGE
            //
            if (!(u & BM_HUGE) || (DWORD)pbm->bmHeight * pbm->bmWidthBytes < 64l*1024)
            {
                pbm->bmFillBytes = 0;
                pbm->bmScanSegment = pbm->bmHeight;
            }
            else
            {
                if (pbm->bmOffset)
                    pbm->bmOffset -= (long)((pbm->bmHeight-1) / pbm->bmScanSegment) * pbm->bmFillBytes;
            }
        }
    }

    if (hdc)
    {
        SelectObject(hdc, hbmT);
        DeleteDC(hdc);
    }

    return (LPVOID)pbm->bmBits;
}

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

///////////////////////////////////////////////////////////////////////////////
//
//  GetSurfaceType
//
///////////////////////////////////////////////////////////////////////////////

#define BCODE _based(_segname("_CODE"))

static BYTE  BCODE bits8[]   = {0x00,0xF9,0xFA,0xFC,0xFF};
static WORD  BCODE bits555[] = {0x0000,0x7C00,0x03E0,0x001F,0x7FFF};
static WORD  BCODE bits5551[]= {0x8000,0xFC00,0x83E0,0x801F,0xFFFF};
static WORD  BCODE bits565[] = {0x0000,0xF800,0x07E0,0x001F,0xFFFF};
static BYTE  BCODE bitsBGR[] = {0x00,0x00,0x00, 0x00,0x00,0xFF, 0x00,0xFF,0x00, 0xFF,0x00,0x00, 0xFF,0xFF,0xFF};
static BYTE  BCODE bitsRGB[] = {0x00,0x00,0x00, 0xFF,0x00,0x00, 0x00,0xFF,0x00, 0x00,0x00,0xFF, 0xFF,0xFF,0xFF};
static DWORD BCODE bitsRGBX[]= {0x000000, 0x0000FF, 0x00FF00, 0xFF0000, 0xFFFFFF};
static DWORD BCODE bitsBGRX[]= {0x000000, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFFFF};

void FAR TestSurfaceType(HDC hdc, int x, int y)
{
    PatBlt(hdc, x, y, 5, 1, BLACKNESS);

    SetPixel(hdc, x+0, y, RGB(000,000,000));
    SetPixel(hdc, x+1, y, RGB(255,000,000));
    SetPixel(hdc, x+2, y, RGB(000,255,000));
    SetPixel(hdc, x+3, y, RGB(000,000,255));
    SetPixel(hdc, x+4, y, RGB(255,255,255));

    GetPixel(hdc, x, y);
}

UINT FAR GetSurfaceType(LPVOID lpBits)
{
    #define TESTFMT(a,n) \
        if (_fmemcmp(lpBits, (LPVOID)a, sizeof(a)) == 0) return n;

    TESTFMT(bits8,    BM_8BIT);
    TESTFMT(bits555,  BM_16555);
    TESTFMT(bits5551, BM_16555);
    TESTFMT(bits565,  BM_16565);
    TESTFMT(bitsRGB,  BM_24RGB);
    TESTFMT(bitsBGR,  BM_24BGR);
    TESTFMT(bitsRGBX, BM_32RGB);
    TESTFMT(bitsBGRX, BM_32BGR);

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetBitmapType
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

UINT FAR GetBitmapType()
{
    BITMAP bm;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdc;
    UINT u;
    BYTE bits[20*4*2];

    static UINT wBitmapType = 0xFFFF;

    if (wBitmapType != 0xFFFF)
        return wBitmapType;

    //
    // create a test bitmap (<64k)
    //
    hdc = GetDC(NULL);
    hbm = CreateCompatibleBitmap(hdc,20,2);
    ReleaseDC(NULL, hdc);

    hdc = CreateCompatibleDC(NULL);
    hbmT = SelectObject(hdc, hbm);

    GetObject(hbm, sizeof(bm), &bm);
    PatBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, BLACKNESS);

    TestSurfaceType(hdc, 0, 0);
    GetBitmapBits(hbm, sizeof(bits), bits);
    u = GetSurfaceType(bits);

    if (u == 0) {
        u = GetSurfaceType(bits + bm.bmWidthBytes);

        if (u)
            u |= BM_BOTTOMTOTOP;
    }

#ifndef WIN32
    if (u) {
        BYTE _huge *pb;
        UINT dy,w;

        //
        // see if bitmap(s) are huge format
        //
        dy = (UINT)(0x10000l/bm.bmWidthBytes) + 1;
        hbm = CreateCompatibleBitmap(hdc,bm.bmWidth,dy);
        DeleteObject(SelectObject(hdc, hbm));
        PatBlt(hdc, 0, 0, bm.bmWidth, dy, BLACKNESS);

        pb = (BYTE _huge *)LockBitmap(hbm);

        if (pb == NULL || OFFSETOF(pb) != 0)
            ; // cant lock bitmaps
        else {
            u |= BM_CANLOCK;

            w = (dy-1) * bm.bmWidthBytes;

            pb[64l*1024] = 0;
            pb[w] = 0;

            if (u & BM_BOTTOMTOTOP)
                SetPixel(hdc, 0, 0, RGB(255,255,255));
            else
                SetPixel(hdc, 0, dy-1, RGB(255,255,255));

            if (pb[64l*1024] != 0 && pb[w] == 0)
                u |= BM_HUGE;
            else if (pb[64l*1024] == 0 && pb[w] != 0)
                ;
            else
                u = 0;
        }
    }
#endif

    SelectObject(hdc, hbmT);
    DeleteObject(hbm);
    DeleteDC(hdc);

    wBitmapType = u;
    return u;
}

//////////////////////////////////////////////////////////////////////////////
//
//  returns the PDevice of the given physical or memory DC
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetPDevice(HDC hdc)
{
    HANDLE h;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdcT=NULL;
    IBITMAP FAR *pbm;
    LPVOID lpPDevice = NULL;

    // GDI.403
    static HANDLE (FAR PASCAL *GdiGetBitmapHandle)(HBITMAP hbm, HANDLE h);

    if (GdiGetBitmapHandle == NULL)
        (FARPROC)GdiGetBitmapHandle = GetProcAddress(GetModuleHandle("GDI"),MAKEINTATOM(403));

    if (GdiGetBitmapHandle == NULL)
        return NULL;

    hbm = CreateBitmap(1,1,1,1,NULL);

    //
    //  first try the passed DC if it is a bitmap/DC
    //
    hbmT = SelectBitmap(hdc, hbm);

    if (hbmT != NULL)
    {
        //
        // it is a memory DC.
        //
        h = GdiGetBitmapHandle(hbmT, 0);
    }
    else
    {
        //
        // it is a physical DC.
        //

        hdcT = CreateCompatibleDC(hdc);
        hbmT = SelectBitmap(hdcT, hbm);

        h = GdiGetBitmapHandle(hbm, 0);
    }

    if (h == NULL)
        goto exit;

    pbm = (IBITMAP FAR *)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        goto exit;

    if (pbm)
        pbm = (IBITMAP FAR *)pbm->bmlpPDevice;
    else
        pbm = NULL;

    if (IsBadReadPtr(pbm, 2))
        goto exit;

    lpPDevice = (LPVOID)pbm;

exit:
    if (hdcT)
    {
        SelectObject(hdcT, hbmT);
        DeleteObject(hdcT);
    }
    else
    {
        SelectObject(hdc, hbmT);
    }

    DeleteObject(hbm);

    return lpPDevice;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\setdi.c ===
/**************************************************************************
*
*   SETDI.C - contains routines for doing a SetDIBits() into a bitmap.
*
**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include "lockbm.h"
#include "setdi.h"

#define NAKED

/**************************************************************************
*
*  format conversion functions.
*
*  special functions....
*      copy_8_8    (no translate)
*      dither_8_8  (dither from 8bpp to fixed color device (like VGA, SVGA...)
*
**************************************************************************/

extern CONVERTPROC copy_8_8,      dither_8_8;
extern CONVERTPROC convert_8_8,   convert_8_16,    convert_8_24,    convert_8_32,    convert_8_VGA,  convert_8_565,   convert_8_RGB,   convert_8_RGBX;
extern CONVERTPROC convert_16_8,  convert_16_16,   convert_16_24,   convert_16_32,   convert_16_VGA, convert_16_565,  convert_16_RGB,  convert_16_RGBX;
extern CONVERTPROC convert_24_8,  convert_24_16,   convert_24_24,   convert_24_32,   convert_24_VGA, convert_24_565,  convert_24_RGB,  convert_24_RGBX;
extern CONVERTPROC convert_32_8,  convert_32_16,   convert_32_24,   convert_32_32,   convert_32_VGA, convert_32_565,  convert_32_RGB,  convert_32_RGBX;

static INITPROC init_8_8,   init_8_16,    init_8_24,    init_8_32,    init_8_VGA,  init_8_565,   init_8_RGB,   init_8_RGBX;
static INITPROC init_16_8,  init_16_16,   init_16_24,   init_16_32,   init_16_VGA, init_16_565,  init_16_RGB,  init_16_RGBX;
static INITPROC init_24_8,  init_24_16,   init_24_24,   init_24_32,   init_24_VGA, init_24_565,  init_24_RGB,  init_24_RGBX;
static INITPROC init_32_8,  init_32_16,   init_32_24,   init_32_32,   init_32_VGA, init_32_565,  init_32_RGB,  init_32_RGBX;

       INITPROC    init_setdi;
static CONVERTPROC convert_setdi;

static FREEPROC free_common;

static LPVOID init_dither_8_8(HDC hdc, LPBITMAPINFOHEADER lpbi);

/**************************************************************************
*
*  some conversions we dont do
*
**************************************************************************/

#define convert_8_VGA   NULL
#define convert_16_VGA  NULL
#define convert_24_VGA  NULL
#define convert_32_VGA  NULL

#define convert_8_32   NULL
#define convert_16_32  NULL
#define convert_24_32  NULL
#define convert_32_32  NULL

#define convert_8_RGBX   NULL
#define convert_16_RGBX  NULL
#define convert_24_RGBX  NULL
#define convert_32_RGBX  NULL

#define convert_8_RGB    NULL
#define convert_16_RGB   NULL
#define convert_24_RGB   NULL
#define convert_32_RGB   NULL

#define convert_16_8  NULL      // not now later!
#define convert_24_8  NULL
#define convert_32_8  NULL

/**************************************************************************
*
*  format conversion tables...
*
*  BITMAP types
*
*  8       0
*  16      1
*  24      2
*  32      3
*  VGA     4
*  16 565  5
*  24 RGB  6
*  32 RGB  7
*
**************************************************************************/

static PCONVERTPROC  ConvertProcTable[4][8] = {
    {convert_8_8,   convert_8_16,    convert_8_24,    convert_8_32,    convert_8_VGA,  convert_8_565,   convert_8_RGB,   convert_8_RGBX},
    {convert_16_8,  convert_16_16,   convert_16_24,   convert_16_32,   convert_16_VGA, convert_16_565,  convert_16_RGB,  convert_16_RGBX},
    {convert_24_8,  convert_24_16,   convert_24_24,   convert_24_32,   convert_24_VGA, convert_24_565,  convert_24_RGB,  convert_24_RGBX},
    {convert_32_8,  convert_32_16,   convert_32_24,   convert_32_32,   convert_32_VGA, convert_32_565,  convert_32_RGB,  convert_32_RGBX},
};

static PINITPROC  InitProcTable[4][8] = {
    {init_8_8,   init_8_16,    init_8_24,    init_8_32,    init_8_VGA,  init_8_565,   init_8_RGB,   init_8_RGBX},
    {init_16_8,  init_16_16,   init_16_24,   init_16_32,   init_16_VGA, init_16_565,  init_16_RGB,  init_16_RGBX},
    {init_24_8,  init_24_16,   init_24_24,   init_24_32,   init_24_VGA, init_24_565,  init_24_RGB,  init_24_RGBX},
    {init_32_8,  init_32_16,   init_32_24,   init_32_32,   init_32_VGA, init_32_565,  init_32_RGB,  init_32_RGBX},
};

/**************************************************************************
**************************************************************************/

#define RGB555(r,g,b) (\
            (((WORD)(r) >> 3) << 10) |  \
            (((WORD)(g) >> 3) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

#define RGB565(r,g,b) (\
            (((WORD)(r) >> 3) << 11) |  \
            (((WORD)(g) >> 2) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

/**************************************************************************
**************************************************************************/

#ifdef DEBUG
static
#else
__inline
#endif

LONG BitmapXY(IBITMAP *pbm, int x, int y)
{
    LONG offset = pbm->bmOffset;

//!!! wrong!!! but y for bitmaps is always zero....
//  if (pbm->bmFillBytes)
//      offset += (y / pbm->bmScanSegment) * pbm->bmFillBytes;

    offset += y * (long)pbm->bmNextScan;
    offset += x * pbm->bmBitsPixel / 8;

    return offset;
}

/**************************************************************************
* @doc INTERNAL SetBitmapBegin
*
* @api BOOL | SetBitmapBegin | prepare to do a SetDIBits() into a bitmap
*
* @rdesc Returns TRUE if success.
*
**************************************************************************/

BOOL FAR SetBitmapBegin(
    PSETDI   psd,
    HDC      hdc,               //
    HBITMAP  hbm,               //  bitmap to set into
    LPBITMAPINFOHEADER lpbi,    //  --> BITMAPINFO of source
    UINT     DibUsage)
{
    BITMAP bm;

    SetBitmapEnd(psd);  // free and old stuff

    GetObject(hbm, sizeof(bm), &bm);

    psd->hbm     = hbm;
//  psd->hdc     = hdc;
//  psd->hpal    = hpal;
    psd->DibUsage= DibUsage;

    psd->color_convert = NULL;
    psd->convert = NULL;
    psd->size = sizeof(SETDI);

    if (!GetBitmapDIB(lpbi, NULL, &psd->bmSrc, sizeof(psd->bmSrc)))
        return FALSE;

    //
    // make sure we can lock the bitmap
    //
    if (GetBitmap(hbm, &psd->bmDst, sizeof(psd->bmDst)) &&
        psd->bmDst.bmFillBytes <= 0 &&
        psd->bmSrc.bmType > 0 && psd->bmSrc.bmType <= 4 &&
        psd->bmDst.bmType > 0 && psd->bmDst.bmType <= 8)
    {
        psd->init    = InitProcTable[psd->bmSrc.bmType-1][psd->bmDst.bmType-1];
        psd->convert = ConvertProcTable[psd->bmSrc.bmType-1][psd->bmDst.bmType-1];
        psd->free    = free_common;
    }

    //
    // if we cant convert ourself try SetDIBits()
    //
    if (psd->convert == NULL)
    {
        psd->convert = convert_setdi;
        psd->init    = init_setdi;
        psd->free    = NULL;
    }

    if (psd->init)
    {
        psd->hdc = hdc;
        if (!psd->init(psd))
        {
            psd->hdc = 0;
            psd->size = 0;
            psd->convert = NULL;
            return FALSE;
        }
        psd->hdc  = NULL;
        psd->hpal = NULL;
    }

    return TRUE;
}

/**************************************************************************
* @doc INTERNAL SetBitmapColorChange
*
* @api BOOL | SetBitmapColorChange | re-init the color conversion
*
* @rdesc Returns TRUE if success.
*
**************************************************************************/

void FAR SetBitmapColorChange(PSETDI psd, HDC hdc, HPALETTE hpal)
{
    if (psd->size != sizeof(SETDI))
        return;

    if (hdc == NULL)
        return;

    if (psd->free)              //!!! ack?
        psd->free(psd);

    psd->hdc  = hdc;
    psd->hpal = hpal;

    if (psd->init)
        psd->init(psd);

    psd->hdc  = NULL;
    psd->hpal = NULL;
}

/**************************************************************************
* @doc INTERNAL SetBitmapEnd
*
* @api void | SetBitmapEnd | clean out a SETDI structure
*
**************************************************************************/

void FAR SetBitmapEnd(PSETDI psd)
{
    if (psd->size != sizeof(SETDI))
        return;

    if (psd->free)
        psd->free(psd);

    psd->size = 0;
    psd->convert = NULL;
    psd->init = NULL;
    psd->free = NULL;
}

/**************************************************************************
* @doc INTERNAL SetBitmap
*
* @api BOOL | SetBitmap | convert DIB bits to bitmaps bits.
*
**************************************************************************/

BOOL FAR SetBitmap(PSETDI psd, int DstX, int DstY, int DstDX, int DstDY, LPVOID lpBits, int SrcX, int SrcY, int SrcDX, int SrcDY)
{
    if (psd->size != sizeof(SETDI))
        return FALSE;

    psd->convert(
        psd->bmDst.bmBits,                  // --> dst.
        BitmapXY(&psd->bmDst, DstX, DstY),  // offset to start at
        psd->bmDst.bmNextScan,              // dst_next_scan.
        psd->bmDst.bmFillBytes,             // fill bytes
        lpBits,                             // --> Src.
        BitmapXY(&psd->bmSrc, SrcX, SrcY),  // offset to start at
        psd->bmSrc.bmNextScan,              // Src_next_scan.
        DstDX,
        DstDY,
        psd->color_convert);

    return TRUE;
}

/**************************************************************************
*
*   cleanup stuff
*
**************************************************************************/

static BOOL free_common(PSETDI psd)
{
    //
    // clean up what we did
    //
    if (psd->color_convert != NULL)
        GlobalFreePtr(psd->color_convert);

    psd->color_convert = NULL;

    return TRUE;
}

/**************************************************************************
*
* GetPaletteTranslate
*
*   get the palette to physical translate table.
*
*   does this by calling GDI, this should always work.
*   this only works on a palette device.
*
**************************************************************************/

BOOL GetPaletteTranslate(HDC hdc, LPBYTE pb)
{
    int  i;
    int  n;
    DWORD rgb;
    DWORD *prgb;

    prgb = (DWORD *)LocalAlloc(LPTR, 256 * sizeof(DWORD));

    if (prgb == NULL)
	return TRUE;

    GetSystemPaletteEntries(hdc, 0, 256,(PALETTEENTRY FAR *)prgb);

    for (n=0; n<256; n++)           //!!! is this needed.
	prgb[n] &= 0x00FFFFFF;

    for (i=0; i<256; i++)
    {
        //
        // GDI will figure out what physical color this palette
        // index is mapped to.
        //
        rgb = GetNearestColor(hdc, PALETTEINDEX(i)) & 0x00FFFFFF;

        //
        // quick check for identity map.
        //
	if (prgb[i] == rgb)
        {
            pb[i] = (BYTE)i;
            continue;
        }

        //
        // now we have to find the rgb in the physical palette
        //
        for (n=0; n<256; n++)
	    if (prgb[n] == rgb)
                break;

        //
        // our search should never fail, because GDI gave us a RGB
        // in the palette.
        //
        if (n == 256)   //!!! should never happen
            n = 0;

        pb[i] = (BYTE)n;
    }

    LocalFree((HLOCAL)prgb);

    return TRUE;
}

/**************************************************************************
*
* @doc INTERNAL GetPaletteMap
*
* @api BOOL | GetPhysPaletteMap | gets the physical mapping for a DIB
*
* returns TRUE if the mapping is a 1:1 mapping, FALSE otherwise
*
**************************************************************************/

BOOL GetPhysDibPaletteMap(HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb)
{
    int i;
    int n;
    BYTE ab[256];

    //
    // this will give us the palette to physical mapping.
    //
    GetPaletteTranslate(hdc, ab);

    if (Usage == DIB_PAL_COLORS)
    {
        WORD FAR *pw = (WORD FAR *)(lpbi+1);

        for (i=0; i<256; i++)
            pb[i] = ab[pw[i]];
    }
    else
    {
        ;   //!!! should never happen with current code
    }

    //
    // test for 1:1 translate
    //
    n = (int)lpbi->biClrUsed ? (int)lpbi->biClrUsed : 256;

    for (i=0; i<n; i++)
    {
        if (pb[i] != i)
        {
            //
            // some ET4000 drivers have the same color (128,128,128)
            // at index 7 and at index 248.
            //
            // we should detect a identity palette in this case.
            //
            if (i == 248 && pb[i] == 7)
            {
                pb[i] = 248;
                continue;
            }
            break;
        }
    }

    return i == n;
}

/**************************************************************************
*
* @doc INTERNAL
*
* @api void | GetDibPaletteMap | gets the mapping of a DIB color table
* in  foreground palette index's
*
**************************************************************************/

BOOL GetDibPaletteMap(HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb)
{
    HBITMAP hbm;
    int i;
    int n;

    LONG biWidth = lpbi->biWidth;
    LONG biHeight = lpbi->biHeight;

    n = (int)lpbi->biClrUsed ? (int)lpbi->biClrUsed : 256;

    for (i=0; i<n; i++)
        pb[i] = i;

    for (; i<256; i++)
        pb[i] = 0;

    if (lpbi->biBitCount != 8)
        return FALSE;

    hbm = CreateCompatibleBitmap(hdc,256,1);

    lpbi->biWidth  = 256;
    lpbi->biHeight = 1;

    SetDIBits(hdc, hbm, 0, 1, pb, (LPBITMAPINFO)lpbi, Usage);
    GetBitmapBits(hbm, 256, pb);
    DeleteObject(hbm);

    lpbi->biWidth  = biWidth;
    lpbi->biHeight = biHeight;

    //
    // test for 1:1 translate
    //
    for (i=0; i<n; i++)
    {
        if (pb[i] != i)
        {
            //
            // some ET4000 drivers have the same color (128,128,128)
            // at index 7 and at index 248.
            //
            // we should detect a identity palette in this case.
            //
            if (i == 248 && pb[i] == 7)
            {
                pb[i] = 248;
                continue;
            }
            break;
        }
    }

    return i == n;
}

/**************************************************************************
*
*   convert for SetDIBits
*
**************************************************************************/

void FAR PASCAL convert_setdi(
    LPVOID pd,      // --> dst.
    LONG   dd,      // offset to start at
    LONG   nd,      // dst_next_scan.
    LONG   fd,      // dst fill bytes
    LPVOID ps,      // --> source.
    LONG   ds,      // offset to start at
    LONG   ns,      // src_next_scan.
    LONG   dx,      // pixel count.
    LONG   dy,      // scan count.
    LPVOID pc)      // pixel convert table.
{
    PSETDI psd = (PSETDI)(LONG)pd;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    lpbi->biHeight = dy;

    SetDIBits(
        psd->hdc,
        psd->hbm,
        0,(int)dy,
        ((BYTE _huge *)ps) + ds - dd,
        (LPBITMAPINFO)lpbi,
        psd->DibUsage);

    lpbi->biHeight = psd->bmSrc.bmHeight;
}

/**************************************************************************
*
*   init stuff for SetDIBits
*
**************************************************************************/

BOOL init_setdi(PSETDI psd)
{
    UINT u;
    HDC  hdc;
    LPBYTE p;
    LPBITMAPINFOHEADER lpbi;

    // test to see if SetDIBits() works.
    // !!! we should check for 16 or a 32bit DIB and do the escape.
    // !!! on a palette device we need to build a palette map!!!

    if (psd->bmSrc.bmBitsPixel == 16 ||
        psd->bmSrc.bmBitsPixel == 32)
        return FALSE;

    // convert_setdi will need this.
    psd->bmDst.bmBits = (LPVOID)(UINT)psd;
    psd->bmDst.bmOffset = 0;
    psd->bmDst.bmBitsPixel = psd->bmSrc.bmBitsPixel;

    if (psd->hdc && psd->hpal)
    {
        // map colors to current palette!!!!!!!!!!!!!!!!!!!!!!!!!!

        //set this to be the BITMAPINFO + color map.
        psd->color_convert = 0;
    }

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;
    lpbi->biHeight = 1;

    p = (LPBYTE)GlobalAllocPtr(GHND,psd->bmSrc.bmWidthBytes);

    hdc = GetDC(NULL);

    u = SetDIBits(
        hdc,
        psd->hbm,0,1,p,
        (LPBITMAPINFO)psd->bmSrc.bmBitmapInfo,
        psd->DibUsage);

    ReleaseDC(NULL, hdc);

    lpbi->biHeight = psd->bmSrc.bmHeight;
    GlobalFreePtr(p);

    return u == 1;
}

/**************************************************************************
*
*   init stuff for 8bpp bitmaps
*
**************************************************************************/

static BOOL init_8_8(PSETDI psd)
{
    LPBITMAPINFOHEADER lpbi;

    //
    //  if we are mapping from one DIB to another figure this out
    //
    if (psd->hdc == NULL || psd->bmDst.bmBitmapInfo != 0)
    {
        // we assume this routine will not be used for  color matching
        // from DIB to DIB, so give up.

        psd->convert = copy_8_8;
        return TRUE;
    }

    //
    // we are mapping to a device (HDC)
    //
    // we need to compute a 8-->8 conversion table, from the source colors
    // (in psd->lpbiSrc) to the colors on the device.
    //
    // how we do this depends on weather the device is a palette device or not.
    //

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (GetDeviceCaps(psd->hdc, RASTERCAPS) & RC_PALETTE)
    {
        if (psd->hpal == NULL)
        {
            // no palette to match to yet
            psd->convert = copy_8_8;
            return TRUE;
        }

        if (psd->color_convert == NULL)
            psd->color_convert = GlobalAllocPtr(GHND, 256);

        //
        //  we can do this one of two ways,
        //
        //  we can always convert to the palette foreground mapping, or
        //
        //  we can convert to the current colors always (using this method
        //  we will need to recompute the xlat table on every palette
        //  change)
        //
        //  lets convert to the current device colors. (this may cause
        //  problems we will check on later...)
        //
#ifdef NAKED
        if (GetPhysDibPaletteMap(psd->hdc, lpbi, psd->DibUsage, psd->color_convert))
#else
        if (GetDibPaletteMap(psd->hdc, lpbi, psd->DibUsage, psd->color_convert))
#endif
            psd->convert = copy_8_8;
        else
            psd->convert = convert_8_8;
    }
    else
    {
        // !!!we should check for solid colors (ie no dither needed) and also
        // check for 1:1 (no translate)

        if (psd->color_convert == NULL)     //!!!
            psd->color_convert = init_dither_8_8(psd->hdc, lpbi);

        psd->convert = dither_8_8;

        //!!! we need to give the device colors to the caller
    }

    return TRUE;
}

static BOOL init_16_8(PSETDI psd)
{
    return FALSE;       // we dont handle dither yet!
}

static BOOL init_24_8(PSETDI psd)
{
    return FALSE;       // we dont handle dither yet!
}

static BOOL init_32_8(PSETDI psd)
{
    return FALSE;       // we dont handle dither yet!
}

/**************************************************************************
*
*   init stuff for 16bpp bitmaps
*
**************************************************************************/

static BOOL init_8_16(PSETDI psd)
{
    WORD FAR*pw;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*2);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pw = psd->color_convert;

    for (i=0; i<n; i++)
        pw[i] = RGB555(prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);

    for (; i<256; i++)
        pw[i] = 0;

    return TRUE;
}

static BOOL init_16_16(PSETDI psd)
{
    return TRUE;
}

static BOOL init_24_16(PSETDI psd)
{
    return TRUE;
}

static BOOL init_32_16(PSETDI psd)
{
    return TRUE;
}

/**************************************************************************
*
*   init stuff for 24bpp bitmaps
*
**************************************************************************/

static BOOL init_8_24(PSETDI psd)
{
    DWORD FAR*pd;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*4);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pd = psd->color_convert;

    for (i=0; i<n; i++)
        pd[i] = RGB(prgb[i].rgbBlue, prgb[i].rgbGreen, prgb[i].rgbRed);

    for (; i<256; i++)
        pd[i] = 0;

    return TRUE;
}

static BOOL init_16_24(PSETDI psd)
{
    return TRUE;
}

static BOOL init_24_24(PSETDI psd)
{
    return TRUE;
}

static BOOL init_32_24(PSETDI psd)
{
    return TRUE;
}

/**************************************************************************
*
*   init stuff for 32bpp bitmaps
*
**************************************************************************/

static BOOL init_8_32(PSETDI psd)
{
    return FALSE;
////return init_8_24(psd);
}

static BOOL init_16_32(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_32(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_32(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*   init stuff for VGA bitmaps
*
**************************************************************************/

static BOOL init_8_VGA(PSETDI psd)
{
    return FALSE;
}

static BOOL init_16_VGA(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_VGA(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_VGA(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*   init stuff for RGB 565 bitmaps
*
**************************************************************************/

static BOOL init_8_565(PSETDI psd)
{
    WORD FAR*pw;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*2);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pw = psd->color_convert;

    for (i=0; i<n; i++)
        pw[i] = RGB565(prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);

    for (; i<256; i++)
        pw[i] = 0;

    return TRUE;
}

static BOOL init_16_565(PSETDI psd)
{
    return TRUE;
}

static BOOL init_24_565(PSETDI psd)
{
    return TRUE;
}

static BOOL init_32_565(PSETDI psd)
{
    return TRUE;
}

/**************************************************************************
*
*   init stuff for RGB 24bpp bitmaps
*
**************************************************************************/

static BOOL init_8_RGB(PSETDI psd)
{
    DWORD FAR *pd;
    int i;
    int n;
    LPRGBQUAD prgb;
    LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)psd->bmSrc.bmBitmapInfo;

    if (psd->color_convert == NULL)     //!!!
        psd->color_convert = GlobalAllocPtr(GHND, 256*4);

    n = (lpbi->biClrUsed == 0) ? 256 : (int)lpbi->biClrUsed;
    prgb = (LPRGBQUAD)((LPBYTE)lpbi + (int)lpbi->biSize);
    pd = psd->color_convert;

    for (i=0; i<n; i++)
        pd[i] = RGB(prgb[i].rgbRed, prgb[i].rgbGreen, prgb[i].rgbBlue);

    for (; i<256; i++)
        pd[i] = 0;

    return TRUE;
}

static BOOL init_16_RGB(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_RGB(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_RGB(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*   init stuff for RGB 32bpp bitmaps
*
**************************************************************************/

static BOOL init_8_RGBX(PSETDI psd)
{
    return init_8_RGB(psd);
}

static BOOL init_16_RGBX(PSETDI psd)
{
    return FALSE;
}

static BOOL init_24_RGBX(PSETDI psd)
{
    return FALSE;
}

static BOOL init_32_RGBX(PSETDI psd)
{
    return FALSE;
}

/**************************************************************************
*
*  init_dither_8_8
*
*  initialize a dither table that maps a 8 bit color to the device's dither
*
*  pel = dither_table[y&7][pel][x&7]
*
**************************************************************************/

static LPVOID init_dither_8_8(HDC hdc, LPBITMAPINFOHEADER lpbi)
{
    HBRUSH   hbr;
    HDC      hdcMem;
//  HDC      hdc;
    HBITMAP  hbm;
    HBITMAP  hbmT;
    int      i;
    int      nColors;
    LPRGBQUAD prgb;
    LPVOID   lpDitherTable;

    struct {
        BITMAPINFOHEADER bi;
        RGBQUAD rgb[256];
    }   dib;

    lpDitherTable = GlobalAllocPtr(GHND, 256*8*8);

    if (lpDitherTable == NULL)
        return (LPVOID)-1;

    hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);

    hbm = CreateCompatibleBitmap(hdc, 256*8, 8);
    hbmT = SelectObject(hdcMem, hbm);

    if ((nColors = (int)lpbi->biClrUsed) == 0)
        nColors = 1 << (int)lpbi->biBitCount;

    prgb = (LPRGBQUAD)(lpbi+1);

    for (i=0; i<nColors; i++)
    {
        hbr = CreateSolidBrush(RGB(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue));
        hbr = SelectObject(hdcMem, hbr);
        PatBlt(hdcMem, i*8, 0, 8, 8, PATCOPY);
        hbr = SelectObject(hdcMem, hbr);
        DeleteObject(hbr);
    }

#ifdef XDEBUG
    for (i=0; i<16; i++)
        BitBlt(hdc,0,i*8,16*8,8,hdcMem,i*(16*8),0,SRCCOPY);
#endif

    dib.bi.biSize           = sizeof(BITMAPINFOHEADER);
    dib.bi.biPlanes         = 1;
    dib.bi.biBitCount       = 8;
    dib.bi.biWidth          = 256*8;
    dib.bi.biHeight         = 8;
    dib.bi.biCompression    = BI_RGB;
    dib.bi.biSizeImage      = 256*8*8;
    dib.bi.biXPelsPerMeter  = 0;
    dib.bi.biYPelsPerMeter  = 0;
    dib.bi.biClrUsed        = 0;
    dib.bi.biClrImportant   = 0;
    GetDIBits(hdc, hbm, 0, 8, lpDitherTable, (LPBITMAPINFO)&dib, DIB_RGB_COLORS);

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);
    DeleteObject(hbm);
    ReleaseDC(NULL, hdc);

    return (LPVOID)lpDitherTable;
}

#ifdef WIN32 // Provide some dummy entry points as a temporary measure for NT
void FAR PASCAL convert_16_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_16_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_16_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_24_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_24_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_24_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_32_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_32_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_32_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_16
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_24
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_565
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL convert_8_8
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL copy_8_8
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
void FAR PASCAL dither_8_8
       (LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc)              // pixel convert table.
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\setdi16.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: SETDI16.ASM
;
; move bits from one DIB format into another. doing color conversion if
; needed.
;
;   convert_8_16
;   convert_16_16
;   convert_24_16
;   convert_32_16
;
;   convert_8_565   (same as convert_8_16)
;   convert_16_565
;   convert_24_565
;   convert_32_565
;
; NOTES:
;
;  AUTHOR: ToddLa (Todd Laney) Microsoft
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
	.xlist
        include cmacro32.inc
        include windows.inc
        .list

sBegin  Data
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <_TEXT32>
endif

.386
createSeg %SEGNAME, CodeSeg, dword, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;--------------------------------------------------------------------------;

nxtscan macro reg, next_scan, fill_bytes
ifb <fill_bytes>
        add     e&reg,next_scan
else
        mov     eax,e&reg
        add     e&reg,next_scan
        cmp     ax,reg
        sbb     eax,eax
        and     eax,fill_bytes
        add     e&reg,eax
endif
        endm

;--------------------------------------------------------------------------;
;
;   convert_8_16
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   convert_8_16,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count           ; pixel count.
        ParmD   scan_count          ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        xor     ebx,ebx
        xor     edx,edx
        lfs     si,src_ptr
        les     di,dst_ptr
        lds     bx,xlat_table

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        sub     src_next_scan,eax
        add     eax,eax
        sub     dst_next_scan,eax

align 4
convert_8_16_start:
        mov     ecx,pel_count
        shr     ecx,2
        jz      short convert_8_16_ack
align 4
convert_8_16_loop:
        mov     eax,fs:[esi]        ; grab 4 pixels

        mov     dl,ah               ; get pel
        mov     bx,[edx+edx]        ; convert to 16bpp
        shl     ebx,16

        mov     dl,al               ; get pel
        mov     bx,[edx+edx]        ; convert to 16bpp
        mov     es:[edi],ebx        ; store 2 pels

        rol     eax,16

        mov     dl,ah               ; get pel
        mov     bx,[edx+edx]        ; convert to 16bpp
        rol     ebx,16

        mov     dl,al               ; get pel
        mov     bx,[edx+edx]        ; convert to 16bpp
        mov     es:[edi+4],ebx      ; store 2 pels

        add     esi,4
        add     edi,8
        dec     ecx
        jnz     short convert_8_16_loop

convert_8_16_ack:
        mov     ecx,pel_count
        and     ecx,3
        jnz     short convert_8_16_odd

convert_8_16_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_8_16_start
cEnd

convert_8_16_odd:
        mov     dl,fs:[esi]         ; get pel
        mov     bx,[edx+edx]        ; convert to 16bpp
        mov     es:[edi],bx         ; store pel
        inc     esi
        add     edi,2
        dec     ecx
        jnz     short convert_8_16_odd
        jz      short convert_8_16_next

;--------------------------------------------------------------------------;
;
;   convert_16_16
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_16_16,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        add     eax,eax
        sub     src_next_scan,eax
        sub     dst_next_scan,eax

        mov     ebx,eax
        mov     edx,eax
        shr     ebx,2
        and     edx,3
align 4
convert_16_16_start:
        mov     ecx,ebx
        rep     movs dword ptr es:[edi],dword ptr ds:[esi]
        mov     ecx,edx
        rep     movs byte ptr es:[edi],byte ptr ds:[esi]
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes
        dec     scan_count
        jnz     short convert_16_16_start
cEnd

;--------------------------------------------------------------------------;
;
;   convert_24_16
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_24_16,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        add     eax,eax
        sub     dst_next_scan,eax
        add     eax,pel_count
        sub     src_next_scan,eax

        mov     dl,0F8h
align 4
convert_24_16_start:
        mov     ecx,pel_count
align 4
convert_24_16_loop:
        mov     al,[esi+0]  ; get BLUE
        and     al,dl
        mov     bl,al
        mov     bh,[esi+1]  ; get GREEN
        shr     bh,3
        shr     ebx,3
        mov     al,[esi+2]  ; get RED
        and     al,dl
        shr     al,1
        or      bh,al

        mov     es:[edi],bx

        add     esi,3
        add     edi,2
        dec     ecx
        jnz     convert_24_16_loop

convert_24_16_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     convert_24_16_start
cEnd

;--------------------------------------------------------------------------;
;
;   convert_32_16
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_32_16,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        add     eax,eax
        sub     dst_next_scan,eax
        add     eax,eax
        sub     src_next_scan,eax

        mov     dl,0F8h
align 4
convert_32_16_start:
        mov     ecx,pel_count
align 4
convert_32_16_loop:
        mov     al,[esi+0]  ; get BLUE
        and     al,dl
        mov     bl,al
        mov     bh,[esi+1]  ; get GREEN
        shr     bh,3
        shr     ebx,3
        mov     al,[esi+2]  ; get RED
        and     al,dl
        shr     al,1
        or      bh,al

        mov     es:[edi],bx

        add     esi,4
        add     edi,2
        dec     ecx
        jnz     short convert_32_16_loop

convert_32_16_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_32_16_start
cEnd

;--------------------------------------------------------------------------;
;
;   convert_8_565
;
;--------------------------------------------------------------------------;

public convert_8_565
convert_8_565 = convert_8_16

;--------------------------------------------------------------------------;
;
;   convert_16_565
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_16_565,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        and     pel_count,not 1     ;;!!!

        mov     eax,pel_count
        add     eax,eax
        sub     src_next_scan,eax
        sub     dst_next_scan,eax

        mov     ecx,pel_count
        shr     ecx,1
        jz      short convert_16_565_exit
        mov     pel_count,ecx

align 4
convert_16_565_start:
        mov     ecx,pel_count
align 4
convert_16_565_loop:
	mov	ebx,[esi]	;ebx=xRRRRRGGGGGBBBBBxRRRRRGGGGGBBBBB
	mov	eax,ebx		;eax=xRRRRRGGGGGBBBBBxRRRRRGGGGGBBBBB
	add	eax,eax		;eax=RRRRRGGGGGBBBBBxRRRRRGGGGGBBBBBx
	and	ebx,0001F001Fh	;ebx=00000000000BBBBB00000000000BBBBB
	and	eax,0FFC0FFC0h	;eax=RRRRRGGGGG000000RRRRRGGGGG000000
        or      eax,ebx         ;eax=RRRRRGGGGG0BBBBBRRRRRGGGGG0BBBBB

	mov	es:[edi],eax	;store both 565 pels

        add     esi,4
        add     edi,4
        dec     ecx
        jnz     short convert_16_565_loop

convert_16_565_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_16_565_start

convert_16_565_exit:
cEnd

;--------------------------------------------------------------------------;
;
;   convert_24_565
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_24_565,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        add     eax,eax
        sub     dst_next_scan,eax
        add     eax,pel_count
        sub     src_next_scan,eax

        mov     dl,0F8h
align 4
convert_24_565_start:
        mov     ecx,pel_count
align 4
convert_24_565_loop:
        mov     al,[esi+0]  ; get BLUE
        and     al,dl
        mov     bl,al
        mov     bh,[esi+1]  ; get GREEN
        shr     bh,2
        shr     ebx,3
        mov     al,[esi+2]  ; get RED
        and     al,dl
        or      bh,al

        mov     es:[edi],bx

        add     esi,3
        add     edi,2
        dec     ecx
        jnz     short convert_24_565_loop

convert_24_565_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_24_565_start
cEnd

;--------------------------------------------------------------------------;
;
;   convert_32_565
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_32_565,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        add     eax,eax
        sub     dst_next_scan,eax
        add     eax,eax
        sub     src_next_scan,eax

        mov     dl,0F8h
align 4
convert_32_565_start:
        mov     ecx,pel_count
align 4
convert_32_565_loop:
        mov     al,[esi+0]  ; get BLUE
        and     al,dl
        mov     bl,al
        mov     bh,[esi+1]  ; get GREEN
        shr     bh,2
        shr     ebx,3
        mov     al,[esi+2]  ; get RED
        and     al,dl
        or      bh,al

        mov     es:[edi],bx

        add     esi,4
        add     edi,2
        dec     ecx
        jnz     short convert_32_565_loop

convert_32_565_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_32_565_start
cEnd

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\stretch.h ===
// in stretch.asm

void FAR PASCAL StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	--> BITMAPINFO of destination
	LPVOID	lpDst,		    //	--> to destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	--> BITMAPINFO of source
	LPVOID	lpSrc,		    //	--> to source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE); 	    //	y extent of the BLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\setdi.h ===
typedef void (FAR PASCAL CONVERTPROC)(
        LPVOID pd,              // --> dst.
        LONG   dd,              // offset to start at
        LONG   nd,              // dst_next_scan.
        LONG   fd,              // dst fill bytes
        LPVOID ps,              // --> source.
        LONG   ds,              // offset to start at
        LONG   ns,              // src_next_scan.
        LONG   dx,              // pixel count.
        LONG   dy,              // scan count.
        LPVOID pc);             // pixel convert table.

typedef CONVERTPROC *PCONVERTPROC;
typedef BOOL (INITPROC)(struct SETDI *psd);
typedef BOOL (FREEPROC)(struct SETDI *psd);

typedef INITPROC *PINITPROC;
typedef FREEPROC *PFREEPROC;

typedef struct SETDI
{
        LONG         size;           // for sanity checks.

        HDC          hdc;
        HPALETTE     hpal;
        HBITMAP      hbm;
        UINT         DibUsage;

        IBITMAP      bmDst;
        IBITMAP      bmSrc;

        LPVOID       color_convert;  // dither/color convert table.
        PCONVERTPROC convert;        // convert function
        PINITPROC    init;
        PFREEPROC    free;
} SETDI, *PSETDI;

BOOL FAR SetBitmapBegin(
        PSETDI   psd,
        HDC      hdc,
        HBITMAP  hbm,               //  bitmap to set into
        LPBITMAPINFOHEADER lpbi,    //  --> BITMAPINFO of source
        UINT     DibUsage);

void FAR SetBitmapColorChange(PSETDI psd, HDC hdc, HPALETTE hpal);
void FAR SetBitmapEnd(PSETDI psd);
BOOL FAR SetBitmap(PSETDI psd, int DstX, int DstY, int DstDX, int DstDY, LPVOID lpBits, int SrcX, int SrcY, int SrcDX, int SrcDY);

BOOL GetPhysDibPaletteMap(HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb);
BOOL GetDibPaletteMap    (HDC hdc, LPBITMAPINFOHEADER lpbi, UINT Usage, LPBYTE pb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\setdi24.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: SETDI24.ASM
;
; move bits from one DIB format into another. doing color conversion if
; needed.
;
;   convert_8_24
;   convert_16_24
;   convert_24_24
;   convert_32_24
;
; NOTES:
;
;  AUTHOR: ToddLa (Todd Laney) Microsoft
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
        .xlist
        include cmacro32.inc
        include windows.inc
        .list

sBegin  Data
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <_TEXT32>
endif

.386
createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;--------------------------------------------------------------------------;

nxtscan macro reg, next_scan, fill_bytes
ifb <fill_bytes>
        add     e&reg,next_scan
else
        mov     eax,e&reg
        add     e&reg,next_scan
        cmp     ax,reg
        sbb     eax,eax
        and     eax,fill_bytes
        add     e&reg,eax
endif
        endm

;--------------------------------------------------------------------------;
;
;   convert_8_24
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   convert_8_24,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        xor     ebx,ebx
        lfs     si,src_ptr
        les     di,dst_ptr
        lds     bx,xlat_table

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        sub     src_next_scan,eax
        add     eax,eax
        add     eax,pel_count
        sub     dst_next_scan,eax

        xor     eax,eax
align 4
convert_8_24_start:
        mov     ecx,pel_count
align 4
convert_8_24_loop:
        mov     bl,fs:[esi]     ; grab a pel
        mov     edx,[ebx*4]     ; convert to 24bpp
        mov     es:[edi],dl
        shr     edx,8
        mov     es:[edi+1],dx

        inc     esi
        add     edi,3
        dec     ecx
        jnz     short convert_8_24_loop     ;; ack

convert_8_24_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_8_24_start
cEnd

;--------------------------------------------------------------------------;
;
;   STOSB32 - store a byte, every four times doing a STOSD
;
;--------------------------------------------------------------------------;

STOSB32_N = 0

STOSB32 macro
        ror     eax,8                       ; rotate pixel (al) into eax

        STOSB32_N = STOSB32_N + 1

        if (STOSB32_N mod 4) eq 0
            mov     es:[edi], eax
            add     edi,4
        endif

        endm

;--------------------------------------------------------------------------;
;
;   LODSB32 - get a byte, every four times doing a LODSD
;
;--------------------------------------------------------------------------;

LODSB32_N = 0

LODSB32 macro
        if (LODSB32_N mod 4) eq 0
            mov     eax,[esi]
            add     esi,4
        else
            ror     eax,8
        endif

        LODSB32_N = LODSB32_N + 1

        endm

;--------------------------------------------------------------------------;
;
;   MAP16
;
;--------------------------------------------------------------------------;

MAP16   macro   n

if n and 1
        shr     ebx,16              ; get pel from last time
else
        mov     ebx, [esi]          ; grab two pels
        add     esi,4
endif
        ;
        ;       BX contains 5:5:5 RGB convert it to a 8:8:8 RGB
        ;
        mov     al,bl
        shl     al,3
        STOSB32

        shr     bx,2
        mov     al,bl
        and     al,dh   ; F8h
        STOSB32

        mov     al,bh
        shl     al,3
        STOSB32

        endm

;--------------------------------------------------------------------------;
;
;   convert_16_24
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_16_24,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count           ; pixel count.
        ParmD   scan_count          ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        and     pel_count,not 3         ;;!!!

        mov     eax,pel_count
        add     eax,eax
        sub     src_next_scan,eax
        add     eax,pel_count
        sub     dst_next_scan,eax

        mov     ecx,pel_count
        shr     ecx,2
        mov     pel_count,ecx
        mov     dh,0F8h
align 4
convert_16_24_start:
        mov     ecx,pel_count
align 4
convert_16_24_loop:
        MAP16   0
        MAP16   1
        MAP16   2
        MAP16   3
        dec     ecx
        jnz     convert_16_24_loop

convert_16_24_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     convert_16_24_start
cEnd

;--------------------------------------------------------------------------;
;
;   convert_24_24
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_24_24,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        add     eax,eax
        add     eax,pel_count
        sub     dst_next_scan,eax
        sub     src_next_scan,eax

        mov     ebx,eax
        mov     edx,eax
        shr     ebx,2
        and     edx,3
align 4
convert_24_24_start:
        mov     ecx,ebx
        rep     movs dword ptr es:[edi],dword ptr ds:[esi]
        mov     ecx,edx
        rep     movs byte ptr es:[edi],byte ptr ds:[esi]

        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_24_24_start
cEnd

;--------------------------------------------------------------------------;
;
;   convert_32_24
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_32_24,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        and     pel_count,not 3         ; !!!

        mov     eax,pel_count
        add     eax,eax
        add     eax,eax
        sub     src_next_scan,eax
        sub     eax,pel_count
        sub     dst_next_scan,eax

        mov     ecx,pel_count
        shr     ecx,2
        jz      short convert_32_24_exit
        mov     pel_count,ecx
align 4
convert_32_24_start:
        mov     ecx,pel_count
align 4
convert_32_24_loop:
        mov     eax,[esi]           ; eax = XRGB
        mov     ebx,[esi+4]         ; ebx = xrgb
        shl     eax,8               ; eax = RGB0
        shrd    eax,ebx,8           ; eax = bRGB
        mov     es:[edi],eax        ; store pels
        shl     ebx,8               ; ebx = rgb0

        mov     eax,[esi+8]         ; eax = XRGB
        shrd    ebx,eax,16          ; ebx = GBrg
        mov     es:[edi+4],ebx      ; store pels
        shl     eax,8               ; eax = RGB0

        mov     ebx,[esi+12]        ; ebx = xrgb
        shrd    eax,ebx,24          ; eax = rgbR
        mov     es:[edi+8],eax      ; store pels

        add     esi,16
        add     edi,12
        dec     ecx
        jnz     short convert_32_24_loop

convert_32_24_next:
        nxtscan si,src_next_scan
        nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_32_24_start

convert_32_24_exit:

cEnd

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\setdi32.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: SETDI32.ASM
;
; move bits from one DIB format into another. doing color conversion if
; needed.
;
;   convert_8_32
;   convert_16_32
;   convert_24_32
;   convert_32_32
;
; NOTES:
;
;  AUTHOR: ToddLa (Todd Laney) Microsoft
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
        .xlist
        include cmacro32.inc
        include windows.inc
        .list

sBegin  Data
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <_TEXT32>
endif

.386
createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;--------------------------------------------------------------------------;

nxtscan macro reg, next_scan, fill_bytes
ifb <fill_bytes>
        add     e&reg,next_scan
else
        mov     eax,e&reg
        add     e&reg,next_scan
        cmp     ax,reg
        sbb     eax,eax
        and     eax,fill_bytes
        add     e&reg,eax
endif
        endm

;--------------------------------------------------------------------------;
;
;   convert_8_32
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   convert_8_32,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
cEnd

;--------------------------------------------------------------------------;
;
;   convert_16_32
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_16_32,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count           ; pixel count.
        ParmD   scan_count          ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
cEnd

;--------------------------------------------------------------------------;
;
;   convert_24_32
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_24_32,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
cEnd

;--------------------------------------------------------------------------;
;
;   convert_32_32
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_32_32,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
cEnd

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\stretchc.c ===
/*
 * StretchC.C
 *
 * StretchBlt for DIBs
 *
 * C version of stretch.asm: StretchDIB optimised for AVI.
 *
 * NOTES
 *	- does not handle mirroring in x or y
 *	- does not handle pixel translation
 *	- will not work in place.
 *
 * AUTHOR
 *      C version by Geraint Davies
 */

#include <windows.h>
#include "drawdibi.h"
#include "stretch.h"

/* Outline:
 *
 * we select a y-stretching function depending on the ratio (eg 1:N or N:1).
 * it copies scanlines from source to destination, duplicating or omitting
 * scanlines as necessary to fit the destination. It copies each scanline
 * via the X_FUNC function we passed as an argument: this copies one scanline
 * duplicating or omitting pixels to fit the destination: we select an X_FUNC
 * depending on the bit-depth as well as the x-stretching ratio.
 *
 * both x and y stretching functions use the following basic model for deciding
 * when to insert/omit elements:
 *
 * 	delta = <larger extent> -1;
 *
 *      for (number of destination elements) {
 *
 *		copy one element
 *		advance pointer to larger region
 *		delta -= <smaller extent>
 *		if (delta < 0) {
 *			delta += <larger extent>;
 *			advance pointer to smaller region
 *		}
 *	}
 */


/* stretch proportions */
#define STRETCH_1_1	1
#define STRETCH_1_2	2
#define STRETCH_1_4	3
#define STRETCH_1_N	4
#define STRETCH_N_1	5
#define STRETCH_4_1	6
#define STRETCH_2_1	7



/*
 * an X_FUNC is a function that copies one scanline, stretching or shrinking it
 * to fit a destination scanline. Pick an X_FUNC depending on
 * bitdepth and stretch ratio (1:1, 1:2, 1:4, 1:N, N:1, 4:1, 2:1)
 *
 * the x_fract argument is the delta fraction: it is a representation
 * of the smaller extent (whichever that is) as a fraction of the larger,
 * and is used when stretching or shrinking to advance the pointer to the
 * smaller scanline every (fract) pixels of the larger.
 * Thus if we are expanding 1:8, x_fract will be 1/8, we will advance the
 * source pointer once every 8 pixels, and thus copy each source pixel to
 * 8 dest pixels. Note that if shrinking 8:1, x_fract will still be 1/8
 * and we will use it to control advancement of the dest pointer.
 * the fraction is multiplied by 65536.
 */
typedef void (*X_FUNC) (LPBYTE lpSrc,
			LPBYTE lpDst,
			int SrcXE,
			int DstXE,
			int x_fract);


void X_Stretch_1_1_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_4_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);


/*
 * Y_Stretch_* functions copy DstYE scanlines (using
 * an X_FUNC to copy each scanline) omitting or duplicating scanlines to
 * fit the destination extent. Pick a Y_ depending on the ratio
 * (1:N, N:1...)
 */

void Y_Stretch_1_N(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract,
		   X_FUNC x_func);

void Y_Stretch_N_1(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract,
		   X_FUNC x_func);

/*
 * special case y-stretch functions for 1:2 in both dimensions for 8 and 16 bits
 * takes no X_FUNC arg. Will do entire stretch.
 */
void Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract);


void Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract);

/* straight copy of one scanline of count bytes */
void X_CopyScanline(LPBYTE lpSrc, LPBYTE lpDst, int count);


/* -------------------------------------------------------------------- */

/*
 * StretchFactor
 *
 * calculate the stretch factor (proportion of source extent to destination
 * extent: 1:1, 1:2, 1:4, 1:N, N:1, 4:1,or 2:1) and also the
 * delta fraction (see above comment on X_FUNC). This is the ratio of
 * the smaller extent to the larger extent, represented as a fraction
 * multiplied by 65536.
 *
 * returns: the stretch factor  (stores the delta fraction in *pfract)
 */

int
StretchFactor(int SrcE, int DstE, int *pfract)
{


	if (SrcE == DstE) {
		if (pfract != NULL) {
			pfract = 0;	     	
		}

		return(STRETCH_1_1);

	}


	if (SrcE > DstE) {
		if (pfract != NULL) {
			*pfract = ( (DstE << 16) / SrcE) & 0xffff;
		}

		if (SrcE == (DstE * 2)) {
			return(STRETCH_2_1);
		} else if (SrcE == (DstE * 4)) {
			return(STRETCH_4_1);
		} else {
			return(STRETCH_N_1);
		}

	} else {

		/* calculate delta fraction based on smallest / largest */
		if (pfract != NULL) {
			*pfract = ( (SrcE << 16) / DstE) & 0xffff;
		}
	
		if (DstE == (SrcE * 2)) {
			return(STRETCH_1_2);
		} else if (DstE == (SrcE * 4)) {
			return(STRETCH_1_4);
		} else {
			return(STRETCH_1_N);
		}
	}
}


/* -------------------------------------------------------------------- */

/*
 * StretchDIB
 *
 */

void FAR PASCAL
StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	--> BITMAPINFO of destination
	LPVOID	lpvDst,		    //	--> to destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	--> BITMAPINFO of source
	LPVOID	lpvSrc,		    //	--> to source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE	 	    //	y extent of the BLT
	)
{

	int nBits;
	int SrcWidth, DstWidth;
	LPBYTE lpDst = lpvDst, lpSrc = lpvSrc;
	int x_fract;
	int x_factor;
	int y_factor;
	X_FUNC xfunc;
	

	/*
	 * check that bit depths are same and 8, 16 or 24
	 */

	if ((nBits = biDst->biBitCount) != biSrc->biBitCount) {
		return;
	}

	if ( (nBits != 8 ) && (nBits != 16) && (nBits != 24)) {
		return;
	}

	/*
	 * check that extents are not bad
	 */
	if ( (SrcXE <= 0) || (SrcYE <= 0) || (DstXE <= 0) || (DstYE <= 0)) {
		return;
	}

	/*
	 * calculate width of one scan line in bytes, rounded up to
	 * DWORD boundary.
	 */
	SrcWidth = (((biSrc->biWidth * nBits) + 31) & ~31) / 8;
	DstWidth = (((biDst->biWidth * nBits) + 31) & ~31) / 8;

	/*
	 * set initial source and dest pointers
	 */
	lpSrc += (SrcY * SrcWidth) + ((SrcX * nBits) / 8);
	lpDst += (DstY * DstWidth) + ((DstX * nBits) / 8);


	/*
	 * calculate stretch proportions (1:1, 1:2, 1:N, N:1 etc) and
	 * also the fractional stretch factor. (we are not interested in
	 * the y stretch fraction - this is only used in x stretching.
	 */

	y_factor = StretchFactor(SrcYE, DstYE, NULL);
	x_factor = StretchFactor(SrcXE, DstXE, &x_fract);

	/*
	 * we have special case routines for 1:2 in both dimensions
	 * for 8 and 16 bits
	 */
	if ((y_factor == x_factor) && (y_factor == STRETCH_1_2)) {

	 	if (nBits == 8) {
            StartCounting();
			Stretch_1_2_8Bits(lpSrc, lpDst, SrcXE, SrcYE,
					  DstXE, DstYE, SrcWidth, DstWidth,
					  x_fract);
            EndCounting("8 bit");
			return;

		} else if (nBits == 16) {
            StartCounting();
			Stretch_1_2_16Bits(lpSrc, lpDst, SrcXE, SrcYE,
					  DstXE, DstYE, SrcWidth, DstWidth,
					  x_fract);
            EndCounting("16 bit");
			return;
		}
	}


	/* pick an X stretch function */
	switch(nBits) {

	case 8:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_8Bits;
			break;

		case STRETCH_1_2:
			xfunc = X_Stretch_1_2_8Bits;
			break;

		case STRETCH_1_4:
			xfunc = X_Stretch_1_4_8Bits;
			break;

		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_8Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_8Bits;
			break;

		}
		break;

	case 16:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_16Bits;
			break;

		case STRETCH_1_2:
			xfunc = X_Stretch_1_2_16Bits;
			break;

		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_16Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_16Bits;
			break;

		}
		break;

	case 24:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_24Bits;
			break;

		case STRETCH_1_2:
		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_24Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_24Bits;
			break;

		}
		break;

	}


	/*
	 * now call appropriate stretching function depending
	 * on the y stretch factor
	 */
	switch (y_factor) {
	case STRETCH_1_1:
	case STRETCH_1_2:
	case STRETCH_1_4:
	case STRETCH_1_N:
		Y_Stretch_1_N(lpSrc, lpDst, SrcXE, SrcYE,
			      DstXE, DstYE, SrcWidth, DstWidth, x_fract, xfunc);
		break;

	case STRETCH_N_1:
	case STRETCH_4_1:
	case STRETCH_2_1:
		Y_Stretch_N_1(lpSrc, lpDst, SrcXE, SrcYE,
			      DstXE, DstYE, SrcWidth, DstWidth, x_fract, xfunc);
		break;

	}
	return;
}


/* ---- y stretching -------------------------------------------- */

/*
 * call an X_FUNC to copy scanlines from lpSrc to lpDst. Duplicate or
 * omit scanlines to stretch SrcYE to DstYE.
 */


/*
 * Y_Stretch_1_N
 *
 * write DstYE scanlines based on SrcYE scanlines, DstYE > SrcYE
 *
 */

void
Y_Stretch_1_N(LPBYTE lpSrc,
              LPBYTE lpDst,
              int SrcXE,
              int SrcYE,
              int DstXE,
              int DstYE,
	      int SrcWidth,
	      int DstWidth,
              int x_fract,
              X_FUNC x_func)
{

	int ydelta;
	int i;
	LPBYTE lpPrev = NULL;

	ydelta = DstYE -1;

	for (i = 0; i < DstYE; i++) {

		/* have we already stretched this scanline ? */
		if (lpPrev == NULL) {
			/* no - copy one scanline */
			(*x_func)(lpSrc, lpDst, SrcXE, DstXE, x_fract);
			lpPrev = lpDst;
		} else {	
			/* yes - this is a duplicate scanline. do
			 * a straight copy of one that has already
			 * been stretched/shrunk
			 */
			X_CopyScanline(lpPrev, lpDst, DstWidth);
		}

		/* advance dest pointer */
		lpDst += DstWidth;

		/* should we advance source pointer this time ? */
		if ( (ydelta -= SrcYE) < 0) {
			ydelta += DstYE;
			lpSrc += SrcWidth;
			lpPrev = NULL;
		}
	}
}


/*
 * Y_Stretch_N_1
 *
 * write DstYE scanlines based on SrcYE scanlines, DstYE < SrcYE
 *
 */
void
Y_Stretch_N_1(LPBYTE lpSrc,
              LPBYTE lpDst,
              int SrcXE,
              int SrcYE,
              int DstXE,
              int DstYE,
	      int SrcWidth,
	      int DstWidth,
              int x_fract,
              X_FUNC x_func)
{

	int ydelta;
	int i;

	ydelta = SrcYE -1;

	for (i = 0; i < DstYE; i++) {

		/* copy one scanline */
		(*x_func)(lpSrc, lpDst, SrcXE, DstXE, x_fract);

		/* advance dest pointer */
		lpDst += DstWidth;

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += SrcWidth;
			ydelta -= DstYE;
		} while (ydelta >= 0);

		ydelta += SrcYE;
	}
}

/* ---8-bit X stretching -------------------------------------------------- */

/*
 * X_Stretch_1_N_8Bits
 *
 * copy one scan line, stretching 1:N (DstXE > SrcXE). For 8-bit depth.
 */
void
X_Stretch_1_N_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one byte and advance dest */
		*lpDst++ = *lpSrc;

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc++;
		}
	}
}


/*
 * X_Stretch_N_1_8Bits
 *
 * copy one scan line, shrinking N:1 (DstXE < SrcXE). For 8-bit depth.
 */
void
X_Stretch_N_1_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one byte and advance dest */
		*lpDst++ = *lpSrc;

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc++;
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}
}

/*
 * copy one scanline of count bytes from lpSrc to lpDst. used by 1: